const textEncoder = (function(window2) {
  var fromCharCode = String.fromCharCode;
  var Object_prototype_toString = {}.toString;
  var sharedArrayBufferString = Object_prototype_toString.call(window2["SharedArrayBuffer"]);
  var undefinedObjectString = Object_prototype_toString();
  var NativeUint8Array = window2.Uint8Array;
  var patchedU8Array = NativeUint8Array || Array;
  var nativeArrayBuffer = NativeUint8Array ? ArrayBuffer : patchedU8Array;
  var arrayBuffer_isView = nativeArrayBuffer.isView || function(x2) {
    return x2 && "length" in x2;
  };
  var arrayBufferString = Object_prototype_toString.call(nativeArrayBuffer.prototype);
  var TextEncoderPrototype = TextEncoder2["prototype"];
  var GlobalTextEncoder = window2["TextEncoder"];
  var tmpBufferU16 = new (NativeUint8Array ? Uint16Array : patchedU8Array)(32);
  function TextDecoder2() {
  }
  TextDecoder2["prototype"]["decode"] = function(inputArrayOrBuffer) {
    var inputAs8 = inputArrayOrBuffer, asObjectString;
    if (!arrayBuffer_isView(inputAs8)) {
      asObjectString = Object_prototype_toString.call(inputAs8);
      if (asObjectString !== arrayBufferString && asObjectString !== sharedArrayBufferString && asObjectString !== undefinedObjectString)
        throw TypeError("Failed to execute 'decode' on 'TextDecoder': The provided value is not of type '(ArrayBuffer or ArrayBufferView)'");
      inputAs8 = NativeUint8Array ? new patchedU8Array(inputAs8) : inputAs8 || [];
    }
    var resultingString = "", tmpStr = "", index = 0, len = inputAs8.length | 0, lenMinus32 = len - 32 | 0, nextEnd = 0, cp0 = 0, codePoint = 0, minBits = 0, cp1 = 0, pos = 0, tmp = -1;
    for (; index < len; ) {
      nextEnd = index <= lenMinus32 ? 32 : len - index | 0;
      for (; pos < nextEnd; index = index + 1 | 0, pos = pos + 1 | 0) {
        cp0 = inputAs8[index] & 255;
        switch (cp0 >> 4) {
          case 15:
            cp1 = inputAs8[index = index + 1 | 0] & 255;
            if (cp1 >> 6 !== 2 || 247 < cp0) {
              index = index - 1 | 0;
              break;
            }
            codePoint = (cp0 & 7) << 6 | cp1 & 63;
            minBits = 5;
            cp0 = 256;
          //  keep track of th bit size
          case 14:
            cp1 = inputAs8[index = index + 1 | 0] & 255;
            codePoint <<= 6;
            codePoint |= (cp0 & 15) << 6 | cp1 & 63;
            minBits = cp1 >> 6 === 2 ? minBits + 4 | 0 : 24;
            cp0 = cp0 + 256 & 768;
          // keep track of th bit size
          case 13:
          case 12:
            cp1 = inputAs8[index = index + 1 | 0] & 255;
            codePoint <<= 6;
            codePoint |= (cp0 & 31) << 6 | cp1 & 63;
            minBits = minBits + 7 | 0;
            if (index < len && cp1 >> 6 === 2 && codePoint >> minBits && codePoint < 1114112) {
              cp0 = codePoint;
              codePoint = codePoint - 65536 | 0;
              if (0 <= codePoint) {
                tmp = (codePoint >> 10) + 55296 | 0;
                cp0 = (codePoint & 1023) + 56320 | 0;
                if (pos < 31) {
                  tmpBufferU16[pos] = tmp;
                  pos = pos + 1 | 0;
                  tmp = -1;
                } else {
                  cp1 = tmp;
                  tmp = cp0;
                  cp0 = cp1;
                }
              } else nextEnd = nextEnd + 1 | 0;
            } else {
              cp0 >>= 8;
              index = index - cp0 - 1 | 0;
              cp0 = 65533;
            }
            minBits = 0;
            codePoint = 0;
            nextEnd = index <= lenMinus32 ? 32 : len - index | 0;
          /*case 11:
          case 10:
          case 9:
          case 8:
          	codePoint ? codePoint = 0 : cp0 = 0xfffd; // fill with invalid replacement character
          case 7:
          case 6:
          case 5:
          case 4:
          case 3:
          case 2:
          case 1:
          case 0:
          	tmpBufferU16[pos] = cp0;
          	continue;*/
          default:
            tmpBufferU16[pos] = cp0;
            continue;
          case 11:
          case 10:
          case 9:
          case 8:
        }
        tmpBufferU16[pos] = 65533;
      }
      tmpStr += fromCharCode(
        tmpBufferU16[0],
        tmpBufferU16[1],
        tmpBufferU16[2],
        tmpBufferU16[3],
        tmpBufferU16[4],
        tmpBufferU16[5],
        tmpBufferU16[6],
        tmpBufferU16[7],
        tmpBufferU16[8],
        tmpBufferU16[9],
        tmpBufferU16[10],
        tmpBufferU16[11],
        tmpBufferU16[12],
        tmpBufferU16[13],
        tmpBufferU16[14],
        tmpBufferU16[15],
        tmpBufferU16[16],
        tmpBufferU16[17],
        tmpBufferU16[18],
        tmpBufferU16[19],
        tmpBufferU16[20],
        tmpBufferU16[21],
        tmpBufferU16[22],
        tmpBufferU16[23],
        tmpBufferU16[24],
        tmpBufferU16[25],
        tmpBufferU16[26],
        tmpBufferU16[27],
        tmpBufferU16[28],
        tmpBufferU16[29],
        tmpBufferU16[30],
        tmpBufferU16[31]
      );
      if (pos < 32) tmpStr = tmpStr.slice(0, pos - 32 | 0);
      if (index < len) {
        tmpBufferU16[0] = tmp;
        pos = ~tmp >>> 31;
        tmp = -1;
        if (tmpStr.length < resultingString.length) continue;
      } else if (tmp !== -1) {
        tmpStr += fromCharCode(tmp);
      }
      resultingString += tmpStr;
      tmpStr = "";
    }
    return resultingString;
  };
  function TextEncoder2() {
  }
  TextEncoderPrototype["encode"] = function(inputString) {
    var encodedString = inputString === void 0 ? "" : "" + inputString, len = encodedString.length | 0;
    var result = new patchedU8Array((len << 1) + 8 | 0), tmpResult;
    var i = 0, pos = 0, point = 0, nextcode = 0;
    var upgradededArraySize = !NativeUint8Array;
    for (i = 0; i < len; i = i + 1 | 0, pos = pos + 1 | 0) {
      point = encodedString.charCodeAt(i) | 0;
      if (point <= 127) {
        result[pos] = point;
      } else if (point <= 2047) {
        result[pos] = 6 << 5 | point >> 6;
        result[pos = pos + 1 | 0] = 2 << 6 | point & 63;
      } else {
        widenCheck: {
          if (55296 <= point) {
            if (point <= 56319) {
              nextcode = encodedString.charCodeAt(i = i + 1 | 0) | 0;
              if (56320 <= nextcode && nextcode <= 57343) {
                point = (point << 10) + nextcode - 56613888 | 0;
                if (point > 65535) {
                  result[pos] = 30 << 3 | point >> 18;
                  result[pos = pos + 1 | 0] = 2 << 6 | point >> 12 & 63;
                  result[pos = pos + 1 | 0] = 2 << 6 | point >> 6 & 63;
                  result[pos = pos + 1 | 0] = 2 << 6 | point & 63;
                  continue;
                }
                break widenCheck;
              }
              point = 65533;
            } else if (point <= 57343) {
              point = 65533;
            }
          }
          if (!upgradededArraySize && i << 1 < pos && i << 1 < (pos - 7 | 0)) {
            upgradededArraySize = true;
            tmpResult = new patchedU8Array(len * 3);
            tmpResult.set(result);
            result = tmpResult;
          }
        }
        result[pos] = 14 << 4 | point >> 12;
        result[pos = pos + 1 | 0] = 2 << 6 | point >> 6 & 63;
        result[pos = pos + 1 | 0] = 2 << 6 | point & 63;
      }
    }
    return NativeUint8Array ? result.subarray(0, pos) : result.slice(0, pos);
  };
  if (!GlobalTextEncoder) {
    window2["TextDecoder"] = TextDecoder2;
    window2["TextEncoder"] = TextEncoder2;
  }
});
if (typeof window !== "undefined") {
  textEncoder(window);
}
if (typeof globalThis !== "undefined") {
  textEncoder(globalThis);
  if (typeof window !== "undefined") {
    self.fetch = window.fetch;
  }
}
if (typeof global !== "undefined") {
  textEncoder(global);
  if (typeof window !== "undefined") {
    self.fetch = window.fetch;
  }
}
if (typeof self !== "undefined") {
  textEncoder(self);
  if (typeof window !== "undefined") {
    self.fetch = window.fetch;
  }
}
Promise.resolve().then(() => firstPolyfill);
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n) {
  if (Object.prototype.hasOwnProperty.call(n, "__esModule")) return n;
  var f2 = n.default;
  if (typeof f2 == "function") {
    var a2 = function a3() {
      var isInstance = false;
      try {
        isInstance = this instanceof a3;
      } catch {
      }
      if (isInstance) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a2.prototype = f2.prototype;
  } else a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n).forEach(function(k2) {
    var d = Object.getOwnPropertyDescriptor(n, k2);
    Object.defineProperty(a2, k2, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k2];
      }
    });
  });
  return a2;
}
var whatwgUrl = {};
var webidl2jsWrapper = {};
var URL$1 = {};
var lib$1 = {};
var hasRequiredLib$1;
function requireLib$1() {
  if (hasRequiredLib$1) return lib$1;
  hasRequiredLib$1 = 1;
  (function(exports) {
    function makeException(ErrorType, message, options) {
      if (options.globals) {
        ErrorType = options.globals[ErrorType.name];
      }
      return new ErrorType(`${options.context ? options.context : "Value"} ${message}.`);
    }
    function toNumber(value, options) {
      if (typeof value === "bigint") {
        throw makeException(TypeError, "is a BigInt which cannot be converted to a number", options);
      }
      if (!options.globals) {
        return Number(value);
      }
      return options.globals.Number(value);
    }
    function evenRound(x2) {
      if (x2 > 0 && x2 % 1 === 0.5 && (x2 & 1) === 0 || x2 < 0 && x2 % 1 === -0.5 && (x2 & 1) === 1) {
        return censorNegativeZero(Math.floor(x2));
      }
      return censorNegativeZero(Math.round(x2));
    }
    function integerPart(n) {
      return censorNegativeZero(Math.trunc(n));
    }
    function sign(x2) {
      return x2 < 0 ? -1 : 1;
    }
    function modulo(x2, y2) {
      const signMightNotMatch = x2 % y2;
      if (sign(y2) !== sign(signMightNotMatch)) {
        return signMightNotMatch + y2;
      }
      return signMightNotMatch;
    }
    function censorNegativeZero(x2) {
      return x2 === 0 ? 0 : x2;
    }
    function createIntegerConversion(bitLength, { unsigned }) {
      let lowerBound, upperBound;
      if (unsigned) {
        lowerBound = 0;
        upperBound = 2 ** bitLength - 1;
      } else {
        lowerBound = -(2 ** (bitLength - 1));
        upperBound = 2 ** (bitLength - 1) - 1;
      }
      const twoToTheBitLength = 2 ** bitLength;
      const twoToOneLessThanTheBitLength = 2 ** (bitLength - 1);
      return (value, options = {}) => {
        let x2 = toNumber(value, options);
        x2 = censorNegativeZero(x2);
        if (options.enforceRange) {
          if (!Number.isFinite(x2)) {
            throw makeException(TypeError, "is not a finite number", options);
          }
          x2 = integerPart(x2);
          if (x2 < lowerBound || x2 > upperBound) {
            throw makeException(
              TypeError,
              `is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`,
              options
            );
          }
          return x2;
        }
        if (!Number.isNaN(x2) && options.clamp) {
          x2 = Math.min(Math.max(x2, lowerBound), upperBound);
          x2 = evenRound(x2);
          return x2;
        }
        if (!Number.isFinite(x2) || x2 === 0) {
          return 0;
        }
        x2 = integerPart(x2);
        if (x2 >= lowerBound && x2 <= upperBound) {
          return x2;
        }
        x2 = modulo(x2, twoToTheBitLength);
        if (!unsigned && x2 >= twoToOneLessThanTheBitLength) {
          return x2 - twoToTheBitLength;
        }
        return x2;
      };
    }
    function createLongLongConversion(bitLength, { unsigned }) {
      const upperBound = Number.MAX_SAFE_INTEGER;
      const lowerBound = unsigned ? 0 : Number.MIN_SAFE_INTEGER;
      const asBigIntN = unsigned ? BigInt.asUintN : BigInt.asIntN;
      return (value, options = {}) => {
        let x2 = toNumber(value, options);
        x2 = censorNegativeZero(x2);
        if (options.enforceRange) {
          if (!Number.isFinite(x2)) {
            throw makeException(TypeError, "is not a finite number", options);
          }
          x2 = integerPart(x2);
          if (x2 < lowerBound || x2 > upperBound) {
            throw makeException(
              TypeError,
              `is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`,
              options
            );
          }
          return x2;
        }
        if (!Number.isNaN(x2) && options.clamp) {
          x2 = Math.min(Math.max(x2, lowerBound), upperBound);
          x2 = evenRound(x2);
          return x2;
        }
        if (!Number.isFinite(x2) || x2 === 0) {
          return 0;
        }
        let xBigInt = BigInt(integerPart(x2));
        xBigInt = asBigIntN(bitLength, xBigInt);
        return Number(xBigInt);
      };
    }
    exports.any = (value) => {
      return value;
    };
    exports.undefined = () => {
      return void 0;
    };
    exports.boolean = (value) => {
      return Boolean(value);
    };
    exports.byte = createIntegerConversion(8, { unsigned: false });
    exports.octet = createIntegerConversion(8, { unsigned: true });
    exports.short = createIntegerConversion(16, { unsigned: false });
    exports["unsigned short"] = createIntegerConversion(16, { unsigned: true });
    exports.long = createIntegerConversion(32, { unsigned: false });
    exports["unsigned long"] = createIntegerConversion(32, { unsigned: true });
    exports["long long"] = createLongLongConversion(64, { unsigned: false });
    exports["unsigned long long"] = createLongLongConversion(64, { unsigned: true });
    exports.double = (value, options = {}) => {
      const x2 = toNumber(value, options);
      if (!Number.isFinite(x2)) {
        throw makeException(TypeError, "is not a finite floating-point value", options);
      }
      return x2;
    };
    exports["unrestricted double"] = (value, options = {}) => {
      const x2 = toNumber(value, options);
      return x2;
    };
    exports.float = (value, options = {}) => {
      const x2 = toNumber(value, options);
      if (!Number.isFinite(x2)) {
        throw makeException(TypeError, "is not a finite floating-point value", options);
      }
      if (Object.is(x2, -0)) {
        return x2;
      }
      const y2 = Math.fround(x2);
      if (!Number.isFinite(y2)) {
        throw makeException(TypeError, "is outside the range of a single-precision floating-point value", options);
      }
      return y2;
    };
    exports["unrestricted float"] = (value, options = {}) => {
      const x2 = toNumber(value, options);
      if (isNaN(x2)) {
        return x2;
      }
      if (Object.is(x2, -0)) {
        return x2;
      }
      return Math.fround(x2);
    };
    exports.DOMString = (value, options = {}) => {
      if (options.treatNullAsEmptyString && value === null) {
        return "";
      }
      if (typeof value === "symbol") {
        throw makeException(TypeError, "is a symbol, which cannot be converted to a string", options);
      }
      const StringCtor = options.globals ? options.globals.String : String;
      return StringCtor(value);
    };
    exports.ByteString = (value, options = {}) => {
      const x2 = exports.DOMString(value, options);
      let c;
      for (let i = 0; (c = x2.codePointAt(i)) !== void 0; ++i) {
        if (c > 255) {
          throw makeException(TypeError, "is not a valid ByteString", options);
        }
      }
      return x2;
    };
    exports.USVString = (value, options = {}) => {
      const S2 = exports.DOMString(value, options);
      const n = S2.length;
      const U2 = [];
      for (let i = 0; i < n; ++i) {
        const c = S2.charCodeAt(i);
        if (c < 55296 || c > 57343) {
          U2.push(String.fromCodePoint(c));
        } else if (56320 <= c && c <= 57343) {
          U2.push(String.fromCodePoint(65533));
        } else if (i === n - 1) {
          U2.push(String.fromCodePoint(65533));
        } else {
          const d = S2.charCodeAt(i + 1);
          if (56320 <= d && d <= 57343) {
            const a2 = c & 1023;
            const b2 = d & 1023;
            U2.push(String.fromCodePoint((2 << 15) + (2 << 9) * a2 + b2));
            ++i;
          } else {
            U2.push(String.fromCodePoint(65533));
          }
        }
      }
      return U2.join("");
    };
    exports.object = (value, options = {}) => {
      if (value === null || typeof value !== "object" && typeof value !== "function") {
        throw makeException(TypeError, "is not an object", options);
      }
      return value;
    };
    const abByteLengthGetter = Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, "byteLength").get;
    const sabByteLengthGetter = typeof SharedArrayBuffer === "function" ? Object.getOwnPropertyDescriptor(SharedArrayBuffer.prototype, "byteLength").get : null;
    function isNonSharedArrayBuffer(value) {
      try {
        abByteLengthGetter.call(value);
        return true;
      } catch {
        return false;
      }
    }
    function isSharedArrayBuffer(value) {
      try {
        sabByteLengthGetter.call(value);
        return true;
      } catch {
        return false;
      }
    }
    function isArrayBufferDetached(value) {
      try {
        new Uint8Array(value);
        return false;
      } catch {
        return true;
      }
    }
    exports.ArrayBuffer = (value, options = {}) => {
      if (!isNonSharedArrayBuffer(value)) {
        if (options.allowShared && !isSharedArrayBuffer(value)) {
          throw makeException(TypeError, "is not an ArrayBuffer or SharedArrayBuffer", options);
        }
        throw makeException(TypeError, "is not an ArrayBuffer", options);
      }
      if (isArrayBufferDetached(value)) {
        throw makeException(TypeError, "is a detached ArrayBuffer", options);
      }
      return value;
    };
    const dvByteLengthGetter = Object.getOwnPropertyDescriptor(DataView.prototype, "byteLength").get;
    exports.DataView = (value, options = {}) => {
      try {
        dvByteLengthGetter.call(value);
      } catch (e) {
        throw makeException(TypeError, "is not a DataView", options);
      }
      if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {
        throw makeException(TypeError, "is backed by a SharedArrayBuffer, which is not allowed", options);
      }
      if (isArrayBufferDetached(value.buffer)) {
        throw makeException(TypeError, "is backed by a detached ArrayBuffer", options);
      }
      return value;
    };
    const typedArrayNameGetter = Object.getOwnPropertyDescriptor(
      Object.getPrototypeOf(Uint8Array).prototype,
      Symbol.toStringTag
    ).get;
    [
      Int8Array,
      Int16Array,
      Int32Array,
      Uint8Array,
      Uint16Array,
      Uint32Array,
      Uint8ClampedArray,
      Float32Array,
      Float64Array
    ].forEach((func) => {
      const { name } = func;
      const article = /^[AEIOU]/u.test(name) ? "an" : "a";
      exports[name] = (value, options = {}) => {
        if (!ArrayBuffer.isView(value) || typedArrayNameGetter.call(value) !== name) {
          throw makeException(TypeError, `is not ${article} ${name} object`, options);
        }
        if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {
          throw makeException(TypeError, "is a view on a SharedArrayBuffer, which is not allowed", options);
        }
        if (isArrayBufferDetached(value.buffer)) {
          throw makeException(TypeError, "is a view on a detached ArrayBuffer", options);
        }
        return value;
      };
    });
    exports.ArrayBufferView = (value, options = {}) => {
      if (!ArrayBuffer.isView(value)) {
        throw makeException(TypeError, "is not a view on an ArrayBuffer or SharedArrayBuffer", options);
      }
      if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {
        throw makeException(TypeError, "is a view on a SharedArrayBuffer, which is not allowed", options);
      }
      if (isArrayBufferDetached(value.buffer)) {
        throw makeException(TypeError, "is a view on a detached ArrayBuffer", options);
      }
      return value;
    };
    exports.BufferSource = (value, options = {}) => {
      if (ArrayBuffer.isView(value)) {
        if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {
          throw makeException(TypeError, "is a view on a SharedArrayBuffer, which is not allowed", options);
        }
        if (isArrayBufferDetached(value.buffer)) {
          throw makeException(TypeError, "is a view on a detached ArrayBuffer", options);
        }
        return value;
      }
      if (!options.allowShared && !isNonSharedArrayBuffer(value)) {
        throw makeException(TypeError, "is not an ArrayBuffer or a view on one", options);
      }
      if (options.allowShared && !isSharedArrayBuffer(value) && !isNonSharedArrayBuffer(value)) {
        throw makeException(TypeError, "is not an ArrayBuffer, SharedArrayBuffer, or a view on one", options);
      }
      if (isArrayBufferDetached(value)) {
        throw makeException(TypeError, "is a detached ArrayBuffer", options);
      }
      return value;
    };
    exports.DOMTimeStamp = exports["unsigned long long"];
  })(lib$1);
  return lib$1;
}
var utils$5 = { exports: {} };
var hasRequiredUtils$5;
function requireUtils$5() {
  if (hasRequiredUtils$5) return utils$5.exports;
  hasRequiredUtils$5 = 1;
  (function(module, exports) {
    function isObject(value) {
      return typeof value === "object" && value !== null || typeof value === "function";
    }
    const hasOwn = Function.prototype.call.bind(Object.prototype.hasOwnProperty);
    function define(target, source) {
      for (const key2 of Reflect.ownKeys(source)) {
        const descriptor2 = Reflect.getOwnPropertyDescriptor(source, key2);
        if (descriptor2 && !Reflect.defineProperty(target, key2, descriptor2)) {
          throw new TypeError(`Cannot redefine property: ${String(key2)}`);
        }
      }
    }
    function newObjectInRealm(globalObject, object) {
      const ctorRegistry = initCtorRegistry(globalObject);
      return Object.defineProperties(
        Object.create(ctorRegistry["%Object.prototype%"]),
        Object.getOwnPropertyDescriptors(object)
      );
    }
    const wrapperSymbol = Symbol("wrapper");
    const implSymbol = Symbol("impl");
    const sameObjectCaches = Symbol("SameObject caches");
    const ctorRegistrySymbol = Symbol.for("[webidl2js] constructor registry");
    const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
    }).prototype);
    function initCtorRegistry(globalObject) {
      if (hasOwn(globalObject, ctorRegistrySymbol)) {
        return globalObject[ctorRegistrySymbol];
      }
      const ctorRegistry = /* @__PURE__ */ Object.create(null);
      ctorRegistry["%Object.prototype%"] = globalObject.Object.prototype;
      ctorRegistry["%IteratorPrototype%"] = Object.getPrototypeOf(
        Object.getPrototypeOf(new globalObject.Array()[Symbol.iterator]())
      );
      try {
        ctorRegistry["%AsyncIteratorPrototype%"] = Object.getPrototypeOf(
          Object.getPrototypeOf(
            globalObject.eval("(async function* () {})").prototype
          )
        );
      } catch {
        ctorRegistry["%AsyncIteratorPrototype%"] = AsyncIteratorPrototype;
      }
      globalObject[ctorRegistrySymbol] = ctorRegistry;
      return ctorRegistry;
    }
    function getSameObject(wrapper, prop, creator) {
      if (!wrapper[sameObjectCaches]) {
        wrapper[sameObjectCaches] = /* @__PURE__ */ Object.create(null);
      }
      if (prop in wrapper[sameObjectCaches]) {
        return wrapper[sameObjectCaches][prop];
      }
      wrapper[sameObjectCaches][prop] = creator();
      return wrapper[sameObjectCaches][prop];
    }
    function wrapperForImpl(impl) {
      return impl ? impl[wrapperSymbol] : null;
    }
    function implForWrapper(wrapper) {
      return wrapper ? wrapper[implSymbol] : null;
    }
    function tryWrapperForImpl(impl) {
      const wrapper = wrapperForImpl(impl);
      return wrapper ? wrapper : impl;
    }
    function tryImplForWrapper(wrapper) {
      const impl = implForWrapper(wrapper);
      return impl ? impl : wrapper;
    }
    const iterInternalSymbol = Symbol("internal");
    function isArrayIndexPropName(P2) {
      if (typeof P2 !== "string") {
        return false;
      }
      const i = P2 >>> 0;
      if (i === 2 ** 32 - 1) {
        return false;
      }
      const s2 = `${i}`;
      if (P2 !== s2) {
        return false;
      }
      return true;
    }
    const byteLengthGetter = Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, "byteLength").get;
    function isArrayBuffer(value) {
      try {
        byteLengthGetter.call(value);
        return true;
      } catch (e) {
        return false;
      }
    }
    function iteratorResult([key2, value], kind) {
      let result;
      switch (kind) {
        case "key":
          result = key2;
          break;
        case "value":
          result = value;
          break;
        case "key+value":
          result = [key2, value];
          break;
      }
      return { value: result, done: false };
    }
    const supportsPropertyIndex = Symbol("supports property index");
    const supportedPropertyIndices = Symbol("supported property indices");
    const supportsPropertyName = Symbol("supports property name");
    const supportedPropertyNames = Symbol("supported property names");
    const indexedGet = Symbol("indexed property get");
    const indexedSetNew = Symbol("indexed property set new");
    const indexedSetExisting = Symbol("indexed property set existing");
    const namedGet = Symbol("named property get");
    const namedSetNew = Symbol("named property set new");
    const namedSetExisting = Symbol("named property set existing");
    const namedDelete = Symbol("named property delete");
    const asyncIteratorNext = Symbol("async iterator get the next iteration result");
    const asyncIteratorReturn = Symbol("async iterator return steps");
    const asyncIteratorInit = Symbol("async iterator initialization steps");
    const asyncIteratorEOI = Symbol("async iterator end of iteration");
    module.exports = {
      isObject,
      hasOwn,
      define,
      newObjectInRealm,
      wrapperSymbol,
      implSymbol,
      getSameObject,
      ctorRegistrySymbol,
      initCtorRegistry,
      wrapperForImpl,
      implForWrapper,
      tryWrapperForImpl,
      tryImplForWrapper,
      iterInternalSymbol,
      isArrayBuffer,
      isArrayIndexPropName,
      supportsPropertyIndex,
      supportedPropertyIndices,
      supportsPropertyName,
      supportedPropertyNames,
      indexedGet,
      indexedSetNew,
      indexedSetExisting,
      namedGet,
      namedSetNew,
      namedSetExisting,
      namedDelete,
      asyncIteratorNext,
      asyncIteratorReturn,
      asyncIteratorInit,
      asyncIteratorEOI,
      iteratorResult
    };
  })(utils$5);
  return utils$5.exports;
}
var URLImpl = {};
var urlStateMachine = { exports: {} };
const maxInt = 2147483647;
const base = 36;
const tMin = 1;
const tMax = 26;
const skew = 38;
const damp = 700;
const initialBias = 72;
const initialN = 128;
const delimiter = "-";
const regexPunycode = /^xn--/;
const regexNonASCII = /[^\0-\x7F]/;
const regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
const errors$b = {
  "overflow": "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
};
const baseMinusTMin = base - tMin;
const floor = Math.floor;
const stringFromCharCode = String.fromCharCode;
function error$1(type) {
  throw new RangeError(errors$b[type]);
}
function map(array, callback) {
  const result = [];
  let length = array.length;
  while (length--) {
    result[length] = callback(array[length]);
  }
  return result;
}
function mapDomain(domain, callback) {
  const parts = domain.split("@");
  let result = "";
  if (parts.length > 1) {
    result = parts[0] + "@";
    domain = parts[1];
  }
  domain = domain.replace(regexSeparators, ".");
  const labels = domain.split(".");
  const encoded = map(labels, callback).join(".");
  return result + encoded;
}
function ucs2decode(string) {
  const output = [];
  let counter = 0;
  const length = string.length;
  while (counter < length) {
    const value = string.charCodeAt(counter++);
    if (value >= 55296 && value <= 56319 && counter < length) {
      const extra = string.charCodeAt(counter++);
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}
const ucs2encode = (codePoints) => String.fromCodePoint(...codePoints);
const basicToDigit = function(codePoint) {
  if (codePoint >= 48 && codePoint < 58) {
    return 26 + (codePoint - 48);
  }
  if (codePoint >= 65 && codePoint < 91) {
    return codePoint - 65;
  }
  if (codePoint >= 97 && codePoint < 123) {
    return codePoint - 97;
  }
  return base;
};
const digitToBasic = function(digit, flag) {
  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
};
const adapt = function(delta, numPoints, firstTime) {
  let k2 = 0;
  delta = firstTime ? floor(delta / damp) : delta >> 1;
  delta += floor(delta / numPoints);
  for (; delta > baseMinusTMin * tMax >> 1; k2 += base) {
    delta = floor(delta / baseMinusTMin);
  }
  return floor(k2 + (baseMinusTMin + 1) * delta / (delta + skew));
};
const decode$2 = function(input) {
  const output = [];
  const inputLength = input.length;
  let i = 0;
  let n = initialN;
  let bias = initialBias;
  let basic = input.lastIndexOf(delimiter);
  if (basic < 0) {
    basic = 0;
  }
  for (let j2 = 0; j2 < basic; ++j2) {
    if (input.charCodeAt(j2) >= 128) {
      error$1("not-basic");
    }
    output.push(input.charCodeAt(j2));
  }
  for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
    const oldi = i;
    for (let w2 = 1, k2 = base; ; k2 += base) {
      if (index >= inputLength) {
        error$1("invalid-input");
      }
      const digit = basicToDigit(input.charCodeAt(index++));
      if (digit >= base) {
        error$1("invalid-input");
      }
      if (digit > floor((maxInt - i) / w2)) {
        error$1("overflow");
      }
      i += digit * w2;
      const t = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
      if (digit < t) {
        break;
      }
      const baseMinusT = base - t;
      if (w2 > floor(maxInt / baseMinusT)) {
        error$1("overflow");
      }
      w2 *= baseMinusT;
    }
    const out = output.length + 1;
    bias = adapt(i - oldi, out, oldi == 0);
    if (floor(i / out) > maxInt - n) {
      error$1("overflow");
    }
    n += floor(i / out);
    i %= out;
    output.splice(i++, 0, n);
  }
  return String.fromCodePoint(...output);
};
const encode$1 = function(input) {
  const output = [];
  input = ucs2decode(input);
  const inputLength = input.length;
  let n = initialN;
  let delta = 0;
  let bias = initialBias;
  for (const currentValue of input) {
    if (currentValue < 128) {
      output.push(stringFromCharCode(currentValue));
    }
  }
  const basicLength = output.length;
  let handledCPCount = basicLength;
  if (basicLength) {
    output.push(delimiter);
  }
  while (handledCPCount < inputLength) {
    let m2 = maxInt;
    for (const currentValue of input) {
      if (currentValue >= n && currentValue < m2) {
        m2 = currentValue;
      }
    }
    const handledCPCountPlusOne = handledCPCount + 1;
    if (m2 - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
      error$1("overflow");
    }
    delta += (m2 - n) * handledCPCountPlusOne;
    n = m2;
    for (const currentValue of input) {
      if (currentValue < n && ++delta > maxInt) {
        error$1("overflow");
      }
      if (currentValue === n) {
        let q = delta;
        for (let k2 = base; ; k2 += base) {
          const t = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
          if (q < t) {
            break;
          }
          const qMinusT = q - t;
          const baseMinusT = base - t;
          output.push(
            stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
          );
          q = floor(qMinusT / baseMinusT);
        }
        output.push(stringFromCharCode(digitToBasic(q, 0)));
        bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
        delta = 0;
        ++handledCPCount;
      }
    }
    ++delta;
    ++n;
  }
  return output.join("");
};
const toUnicode = function(input) {
  return mapDomain(input, function(string) {
    return regexPunycode.test(string) ? decode$2(string.slice(4).toLowerCase()) : string;
  });
};
const toASCII = function(input) {
  return mapDomain(input, function(string) {
    return regexNonASCII.test(string) ? "xn--" + encode$1(string) : string;
  });
};
const punycode = {
  /**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
  "version": "2.3.1",
  /**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
  "ucs2": {
    "decode": ucs2decode,
    "encode": ucs2encode
  },
  "decode": decode$2,
  "encode": encode$1,
  "toASCII": toASCII,
  "toUnicode": toUnicode
};
const punycode_es6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: decode$2,
  default: punycode,
  encode: encode$1,
  toASCII,
  toUnicode,
  ucs2decode,
  ucs2encode
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$5 = /* @__PURE__ */ getAugmentedNamespace(punycode_es6);
var regexes;
var hasRequiredRegexes;
function requireRegexes() {
  if (hasRequiredRegexes) return regexes;
  hasRequiredRegexes = 1;
  const combiningMarks = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u192B\u1930-\u193B\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10D69}-\u{10D6D}\u{10EAB}\u{10EAC}\u{10EFC}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11000}-\u{11002}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11082}\u{110B0}-\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{11134}\u{11145}\u{11146}\u{11173}\u{11180}-\u{11182}\u{111B3}-\u{111C0}\u{111C9}-\u{111CC}\u{111CE}\u{111CF}\u{1122C}-\u{11237}\u{1123E}\u{11241}\u{112DF}-\u{112EA}\u{11300}-\u{11303}\u{1133B}\u{1133C}\u{1133E}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11357}\u{11362}\u{11363}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{113B8}-\u{113C0}\u{113C2}\u{113C5}\u{113C7}-\u{113CA}\u{113CC}-\u{113D0}\u{113D2}\u{113E1}\u{113E2}\u{11435}-\u{11446}\u{1145E}\u{114B0}-\u{114C3}\u{115AF}-\u{115B5}\u{115B8}-\u{115C0}\u{115DC}\u{115DD}\u{11630}-\u{11640}\u{116AB}-\u{116B7}\u{1171D}-\u{1172B}\u{1182C}-\u{1183A}\u{11930}-\u{11935}\u{11937}\u{11938}\u{1193B}-\u{1193E}\u{11940}\u{11942}\u{11943}\u{119D1}-\u{119D7}\u{119DA}-\u{119E0}\u{119E4}\u{11A01}-\u{11A0A}\u{11A33}-\u{11A39}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A5B}\u{11A8A}-\u{11A99}\u{11C2F}-\u{11C36}\u{11C38}-\u{11C3F}\u{11C92}-\u{11CA7}\u{11CA9}-\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D8A}-\u{11D8E}\u{11D90}\u{11D91}\u{11D93}-\u{11D97}\u{11EF3}-\u{11EF6}\u{11F00}\u{11F01}\u{11F03}\u{11F34}-\u{11F3A}\u{11F3E}-\u{11F42}\u{11F5A}\u{13440}\u{13447}-\u{13455}\u{1611E}-\u{1612F}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F51}-\u{16F87}\u{16F8F}-\u{16F92}\u{16FE4}\u{16FF0}\u{16FF1}\u{1BC9D}\u{1BC9E}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D165}-\u{1D169}\u{1D16D}-\u{1D172}\u{1D17B}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E5EE}\u{1E5EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{E0100}-\u{E01EF}]/u;
  const combiningClassVirama = /[\u094D\u09CD\u0A4D\u0ACD\u0B4D\u0BCD\u0C4D\u0CCD\u0D3B\u0D3C\u0D4D\u0DCA\u0E3A\u0EBA\u0F84\u1039\u103A\u1714\u1715\u1734\u17D2\u1A60\u1B44\u1BAA\u1BAB\u1BF2\u1BF3\u2D7F\uA806\uA82C\uA8C4\uA953\uA9C0\uAAF6\uABED\u{10A3F}\u{11046}\u{11070}\u{1107F}\u{110B9}\u{11133}\u{11134}\u{111C0}\u{11235}\u{112EA}\u{1134D}\u{113CE}-\u{113D0}\u{11442}\u{114C2}\u{115BF}\u{1163F}\u{116B6}\u{1172B}\u{11839}\u{1193D}\u{1193E}\u{119E0}\u{11A34}\u{11A47}\u{11A99}\u{11C3F}\u{11D44}\u{11D45}\u{11D97}\u{11F41}\u{11F42}\u{1612F}]/u;
  const validZWNJ = /[\u0620\u0626\u0628\u062A-\u062E\u0633-\u063F\u0641-\u0647\u0649\u064A\u066E\u066F\u0678-\u0687\u069A-\u06BF\u06C1\u06C2\u06CC\u06CE\u06D0\u06D1\u06FA-\u06FC\u06FF\u0712-\u0714\u071A-\u071D\u071F-\u0727\u0729\u072B\u072D\u072E\u074E-\u0758\u075C-\u076A\u076D-\u0770\u0772\u0775-\u0777\u077A-\u077F\u07CA-\u07EA\u0841-\u0845\u0848\u084A-\u0853\u0855\u0860\u0862-\u0865\u0868\u0886\u0889-\u088D\u08A0-\u08A9\u08AF\u08B0\u08B3-\u08B8\u08BA-\u08C8\u1807\u1820-\u1878\u1887-\u18A8\u18AA\uA840-\uA872\u{10AC0}-\u{10AC4}\u{10ACD}\u{10AD3}-\u{10ADC}\u{10ADE}-\u{10AE0}\u{10AEB}-\u{10AEE}\u{10B80}\u{10B82}\u{10B86}-\u{10B88}\u{10B8A}\u{10B8B}\u{10B8D}\u{10B90}\u{10BAD}\u{10BAE}\u{10D00}-\u{10D21}\u{10D23}\u{10EC3}\u{10EC4}\u{10F30}-\u{10F32}\u{10F34}-\u{10F44}\u{10F51}-\u{10F53}\u{10F70}-\u{10F73}\u{10F76}-\u{10F81}\u{10FB0}\u{10FB2}\u{10FB3}\u{10FB8}\u{10FBB}\u{10FBC}\u{10FBE}\u{10FBF}\u{10FC1}\u{10FC4}\u{10FCA}\u{10FCB}\u{1E900}-\u{1E943}][\xAD\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u061C\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u070F\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200B\u200E\u200F\u202A-\u202E\u2060-\u2064\u206A-\u206F\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFEFF\uFFF9-\uFFFB\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10D69}-\u{10D6D}\u{10EAB}\u{10EAC}\u{10EFC}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11001}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{11241}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{113BB}-\u{113C0}\u{113CE}\u{113D0}\u{113D2}\u{113E1}\u{113E2}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C3F}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{11F00}\u{11F01}\u{11F36}-\u{11F3A}\u{11F40}\u{11F42}\u{11F5A}\u{13430}-\u{13440}\u{13447}-\u{13455}\u{1611E}-\u{16129}\u{1612D}-\u{1612F}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1BCA0}-\u{1BCA3}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D173}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E5EE}\u{1E5EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94B}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}]*\u200C[\xAD\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u061C\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u070F\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200B\u200E\u200F\u202A-\u202E\u2060-\u2064\u206A-\u206F\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFEFF\uFFF9-\uFFFB\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10D69}-\u{10D6D}\u{10EAB}\u{10EAC}\u{10EFC}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11001}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{11241}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{113BB}-\u{113C0}\u{113CE}\u{113D0}\u{113D2}\u{113E1}\u{113E2}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C3F}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{11F00}\u{11F01}\u{11F36}-\u{11F3A}\u{11F40}\u{11F42}\u{11F5A}\u{13430}-\u{13440}\u{13447}-\u{13455}\u{1611E}-\u{16129}\u{1612D}-\u{1612F}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1BCA0}-\u{1BCA3}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D173}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E5EE}\u{1E5EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94B}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}]*[\u0620\u0622-\u063F\u0641-\u064A\u066E\u066F\u0671-\u0673\u0675-\u06D3\u06D5\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u077F\u07CA-\u07EA\u0840-\u0858\u0860\u0862-\u0865\u0867-\u086A\u0870-\u0882\u0886\u0889-\u088E\u08A0-\u08AC\u08AE-\u08C8\u1807\u1820-\u1878\u1887-\u18A8\u18AA\uA840-\uA871\u{10AC0}-\u{10AC5}\u{10AC7}\u{10AC9}\u{10ACA}\u{10ACE}-\u{10AD6}\u{10AD8}-\u{10AE1}\u{10AE4}\u{10AEB}-\u{10AEF}\u{10B80}-\u{10B91}\u{10BA9}-\u{10BAE}\u{10D01}-\u{10D23}\u{10EC2}-\u{10EC4}\u{10F30}-\u{10F44}\u{10F51}-\u{10F54}\u{10F70}-\u{10F81}\u{10FB0}\u{10FB2}-\u{10FB6}\u{10FB8}-\u{10FBF}\u{10FC1}-\u{10FC4}\u{10FC9}\u{10FCA}\u{1E900}-\u{1E943}]/u;
  const bidiDomain = /[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05EA\u05EF-\u05F4\u0600-\u0605\u0608\u060B\u060D\u061B-\u064A\u0660-\u0669\u066B-\u066F\u0671-\u06D5\u06DD\u06E5\u06E6\u06EE\u06EF\u06FA-\u070D\u070F\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u083E\u0840-\u0858\u085E\u0860-\u086A\u0870-\u088E\u0890\u0891\u08A0-\u08C9\u08E2\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC2\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFC\uFE70-\uFE74\uFE76-\uFEFC\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{10920}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A00}\u{10A10}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A40}-\u{10A48}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE4}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B40}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10D23}\u{10D30}-\u{10D39}\u{10D40}-\u{10D65}\u{10D6F}-\u{10D85}\u{10D8E}\u{10D8F}\u{10E60}-\u{10E7E}\u{10E80}-\u{10EA9}\u{10EAD}\u{10EB0}\u{10EB1}\u{10EC2}-\u{10EC4}\u{10F00}-\u{10F27}\u{10F30}-\u{10F45}\u{10F51}-\u{10F59}\u{10F70}-\u{10F81}\u{10F86}-\u{10F89}\u{10FB0}-\u{10FCB}\u{10FE0}-\u{10FF6}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8CF}\u{1E900}-\u{1E943}\u{1E94B}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EC71}-\u{1ECB4}\u{1ED01}-\u{1ED3D}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}]/u;
  const bidiS1LTR = /[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u02BB-\u02C1\u02D0\u02D1\u02E0-\u02E4\u02EE\u0370-\u0373\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0482\u048A-\u052F\u0531-\u0556\u0559-\u0589\u0903-\u0939\u093B\u093D-\u0940\u0949-\u094C\u094E-\u0950\u0958-\u0961\u0964-\u0980\u0982\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD-\u09C0\u09C7\u09C8\u09CB\u09CC\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09FA\u09FC\u09FD\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3E-\u0A40\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A76\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD-\u0AC0\u0AC9\u0ACB\u0ACC\u0AD0\u0AE0\u0AE1\u0AE6-\u0AF0\u0AF9\u0B02\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B3E\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0B57\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD0\u0BD7\u0BE6-\u0BF2\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C41-\u0C44\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C66-\u0C6F\u0C77\u0C7F\u0C80\u0C82-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD-\u0CC4\u0CC6-\u0CC8\u0CCA\u0CCB\u0CD5\u0CD6\u0CDD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1-\u0CF3\u0D02-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D4E\u0D4F\u0D54-\u0D61\u0D66-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCF-\u0DD1\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E4F-\u0E5B\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00-\u0F17\u0F1A-\u0F34\u0F36\u0F38\u0F3E-\u0F47\u0F49-\u0F6C\u0F7F\u0F85\u0F88-\u0F8C\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE-\u0FDA\u1000-\u102C\u1031\u1038\u103B\u103C\u103F-\u1057\u105A-\u105D\u1061-\u1070\u1075-\u1081\u1083\u1084\u1087-\u108C\u108E-\u109C\u109E-\u10C5\u10C7\u10CD\u10D0-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1360-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u167F\u1681-\u169A\u16A0-\u16F8\u1700-\u1711\u1715\u171F-\u1731\u1734-\u1736\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17B6\u17BE-\u17C5\u17C7\u17C8\u17D4-\u17DA\u17DC\u17E0-\u17E9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A19\u1A1A\u1A1E-\u1A55\u1A57\u1A61\u1A63\u1A64\u1A6D-\u1A72\u1A80-\u1A89\u1A90-\u1A99\u1AA0-\u1AAD\u1B04-\u1B33\u1B35\u1B3B\u1B3D-\u1B41\u1B43-\u1B4C\u1B4E-\u1B6A\u1B74-\u1B7F\u1B82-\u1BA1\u1BA6\u1BA7\u1BAA\u1BAE-\u1BE5\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1BFC-\u1C2B\u1C34\u1C35\u1C3B-\u1C49\u1C4D-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CC7\u1CD3\u1CE1\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5-\u1CF7\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200E\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u214F\u2160-\u2188\u2336-\u237A\u2395\u249C-\u24E9\u26AC\u2800-\u28FF\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D70\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u302E\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3190-\u31BF\u31F0-\u321C\u3220-\u324F\u3260-\u327B\u327F-\u32B0\u32C0-\u32CB\u32D0-\u3376\u337B-\u33DD\u33E0-\u33FE\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA60C\uA610-\uA62B\uA640-\uA66E\uA680-\uA69D\uA6A0-\uA6EF\uA6F2-\uA6F7\uA722-\uA787\uA789-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA824\uA827\uA830-\uA837\uA840-\uA873\uA880-\uA8C3\uA8CE-\uA8D9\uA8F2-\uA8FE\uA900-\uA925\uA92E-\uA946\uA952\uA953\uA95F-\uA97C\uA983-\uA9B2\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9CD\uA9CF-\uA9D9\uA9DE-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA2F\uAA30\uAA33\uAA34\uAA40-\uAA42\uAA44-\uAA4B\uAA4D\uAA50-\uAA59\uAA5C-\uAA7B\uAA7D-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAAEB\uAAEE-\uAAF5\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB69\uAB70-\uABE4\uABE6\uABE7\uABE9-\uABEC\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uD800-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\u{10000}-\u{1000B}\u{1000D}-\u{10026}\u{10028}-\u{1003A}\u{1003C}\u{1003D}\u{1003F}-\u{1004D}\u{10050}-\u{1005D}\u{10080}-\u{100FA}\u{10100}\u{10102}\u{10107}-\u{10133}\u{10137}-\u{1013F}\u{1018D}\u{1018E}\u{101D0}-\u{101FC}\u{10280}-\u{1029C}\u{102A0}-\u{102D0}\u{10300}-\u{10323}\u{1032D}-\u{1034A}\u{10350}-\u{10375}\u{10380}-\u{1039D}\u{1039F}-\u{103C3}\u{103C8}-\u{103D5}\u{10400}-\u{1049D}\u{104A0}-\u{104A9}\u{104B0}-\u{104D3}\u{104D8}-\u{104FB}\u{10500}-\u{10527}\u{10530}-\u{10563}\u{1056F}-\u{1057A}\u{1057C}-\u{1058A}\u{1058C}-\u{10592}\u{10594}\u{10595}\u{10597}-\u{105A1}\u{105A3}-\u{105B1}\u{105B3}-\u{105B9}\u{105BB}\u{105BC}\u{105C0}-\u{105F3}\u{10600}-\u{10736}\u{10740}-\u{10755}\u{10760}-\u{10767}\u{10780}-\u{10785}\u{10787}-\u{107B0}\u{107B2}-\u{107BA}\u{11000}\u{11002}-\u{11037}\u{11047}-\u{1104D}\u{11066}-\u{1106F}\u{11071}\u{11072}\u{11075}\u{11082}-\u{110B2}\u{110B7}\u{110B8}\u{110BB}-\u{110C1}\u{110CD}\u{110D0}-\u{110E8}\u{110F0}-\u{110F9}\u{11103}-\u{11126}\u{1112C}\u{11136}-\u{11147}\u{11150}-\u{11172}\u{11174}-\u{11176}\u{11182}-\u{111B5}\u{111BF}-\u{111C8}\u{111CD}\u{111CE}\u{111D0}-\u{111DF}\u{111E1}-\u{111F4}\u{11200}-\u{11211}\u{11213}-\u{1122E}\u{11232}\u{11233}\u{11235}\u{11238}-\u{1123D}\u{1123F}\u{11240}\u{11280}-\u{11286}\u{11288}\u{1128A}-\u{1128D}\u{1128F}-\u{1129D}\u{1129F}-\u{112A9}\u{112B0}-\u{112DE}\u{112E0}-\u{112E2}\u{112F0}-\u{112F9}\u{11302}\u{11303}\u{11305}-\u{1130C}\u{1130F}\u{11310}\u{11313}-\u{11328}\u{1132A}-\u{11330}\u{11332}\u{11333}\u{11335}-\u{11339}\u{1133D}-\u{1133F}\u{11341}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11350}\u{11357}\u{1135D}-\u{11363}\u{11380}-\u{11389}\u{1138B}\u{1138E}\u{11390}-\u{113B5}\u{113B7}-\u{113BA}\u{113C2}\u{113C5}\u{113C7}-\u{113CA}\u{113CC}\u{113CD}\u{113CF}\u{113D1}\u{113D3}-\u{113D5}\u{113D7}\u{113D8}\u{11400}-\u{11437}\u{11440}\u{11441}\u{11445}\u{11447}-\u{1145B}\u{1145D}\u{1145F}-\u{11461}\u{11480}-\u{114B2}\u{114B9}\u{114BB}-\u{114BE}\u{114C1}\u{114C4}-\u{114C7}\u{114D0}-\u{114D9}\u{11580}-\u{115B1}\u{115B8}-\u{115BB}\u{115BE}\u{115C1}-\u{115DB}\u{11600}-\u{11632}\u{1163B}\u{1163C}\u{1163E}\u{11641}-\u{11644}\u{11650}-\u{11659}\u{11680}-\u{116AA}\u{116AC}\u{116AE}\u{116AF}\u{116B6}\u{116B8}\u{116B9}\u{116C0}-\u{116C9}\u{116D0}-\u{116E3}\u{11700}-\u{1171A}\u{1171E}\u{11720}\u{11721}\u{11726}\u{11730}-\u{11746}\u{11800}-\u{1182E}\u{11838}\u{1183B}\u{118A0}-\u{118F2}\u{118FF}-\u{11906}\u{11909}\u{1190C}-\u{11913}\u{11915}\u{11916}\u{11918}-\u{11935}\u{11937}\u{11938}\u{1193D}\u{1193F}-\u{11942}\u{11944}-\u{11946}\u{11950}-\u{11959}\u{119A0}-\u{119A7}\u{119AA}-\u{119D3}\u{119DC}-\u{119DF}\u{119E1}-\u{119E4}\u{11A00}\u{11A07}\u{11A08}\u{11A0B}-\u{11A32}\u{11A39}\u{11A3A}\u{11A3F}-\u{11A46}\u{11A50}\u{11A57}\u{11A58}\u{11A5C}-\u{11A89}\u{11A97}\u{11A9A}-\u{11AA2}\u{11AB0}-\u{11AF8}\u{11B00}-\u{11B09}\u{11BC0}-\u{11BE1}\u{11BF0}-\u{11BF9}\u{11C00}-\u{11C08}\u{11C0A}-\u{11C2F}\u{11C3E}-\u{11C45}\u{11C50}-\u{11C6C}\u{11C70}-\u{11C8F}\u{11CA9}\u{11CB1}\u{11CB4}\u{11D00}-\u{11D06}\u{11D08}\u{11D09}\u{11D0B}-\u{11D30}\u{11D46}\u{11D50}-\u{11D59}\u{11D60}-\u{11D65}\u{11D67}\u{11D68}\u{11D6A}-\u{11D8E}\u{11D93}\u{11D94}\u{11D96}\u{11D98}\u{11DA0}-\u{11DA9}\u{11EE0}-\u{11EF2}\u{11EF5}-\u{11EF8}\u{11F02}-\u{11F10}\u{11F12}-\u{11F35}\u{11F3E}\u{11F3F}\u{11F41}\u{11F43}-\u{11F59}\u{11FB0}\u{11FC0}-\u{11FD4}\u{11FFF}-\u{12399}\u{12400}-\u{1246E}\u{12470}-\u{12474}\u{12480}-\u{12543}\u{12F90}-\u{12FF2}\u{13000}-\u{1343F}\u{13441}-\u{13446}\u{13460}-\u{143FA}\u{14400}-\u{14646}\u{16100}-\u{1611D}\u{1612A}-\u{1612C}\u{16130}-\u{16139}\u{16800}-\u{16A38}\u{16A40}-\u{16A5E}\u{16A60}-\u{16A69}\u{16A6E}-\u{16ABE}\u{16AC0}-\u{16AC9}\u{16AD0}-\u{16AED}\u{16AF5}\u{16B00}-\u{16B2F}\u{16B37}-\u{16B45}\u{16B50}-\u{16B59}\u{16B5B}-\u{16B61}\u{16B63}-\u{16B77}\u{16B7D}-\u{16B8F}\u{16D40}-\u{16D79}\u{16E40}-\u{16E9A}\u{16F00}-\u{16F4A}\u{16F50}-\u{16F87}\u{16F93}-\u{16F9F}\u{16FE0}\u{16FE1}\u{16FE3}\u{16FF0}\u{16FF1}\u{17000}-\u{187F7}\u{18800}-\u{18CD5}\u{18CFF}-\u{18D08}\u{1AFF0}-\u{1AFF3}\u{1AFF5}-\u{1AFFB}\u{1AFFD}\u{1AFFE}\u{1B000}-\u{1B122}\u{1B132}\u{1B150}-\u{1B152}\u{1B155}\u{1B164}-\u{1B167}\u{1B170}-\u{1B2FB}\u{1BC00}-\u{1BC6A}\u{1BC70}-\u{1BC7C}\u{1BC80}-\u{1BC88}\u{1BC90}-\u{1BC99}\u{1BC9C}\u{1BC9F}\u{1CCD6}-\u{1CCEF}\u{1CF50}-\u{1CFC3}\u{1D000}-\u{1D0F5}\u{1D100}-\u{1D126}\u{1D129}-\u{1D166}\u{1D16A}-\u{1D172}\u{1D183}\u{1D184}\u{1D18C}-\u{1D1A9}\u{1D1AE}-\u{1D1E8}\u{1D2C0}-\u{1D2D3}\u{1D2E0}-\u{1D2F3}\u{1D360}-\u{1D378}\u{1D400}-\u{1D454}\u{1D456}-\u{1D49C}\u{1D49E}\u{1D49F}\u{1D4A2}\u{1D4A5}\u{1D4A6}\u{1D4A9}-\u{1D4AC}\u{1D4AE}-\u{1D4B9}\u{1D4BB}\u{1D4BD}-\u{1D4C3}\u{1D4C5}-\u{1D505}\u{1D507}-\u{1D50A}\u{1D50D}-\u{1D514}\u{1D516}-\u{1D51C}\u{1D51E}-\u{1D539}\u{1D53B}-\u{1D53E}\u{1D540}-\u{1D544}\u{1D546}\u{1D54A}-\u{1D550}\u{1D552}-\u{1D6A5}\u{1D6A8}-\u{1D6C0}\u{1D6C2}-\u{1D6DA}\u{1D6DC}-\u{1D6FA}\u{1D6FC}-\u{1D714}\u{1D716}-\u{1D734}\u{1D736}-\u{1D74E}\u{1D750}-\u{1D76E}\u{1D770}-\u{1D788}\u{1D78A}-\u{1D7A8}\u{1D7AA}-\u{1D7C2}\u{1D7C4}-\u{1D7CB}\u{1D800}-\u{1D9FF}\u{1DA37}-\u{1DA3A}\u{1DA6D}-\u{1DA74}\u{1DA76}-\u{1DA83}\u{1DA85}-\u{1DA8B}\u{1DF00}-\u{1DF1E}\u{1DF25}-\u{1DF2A}\u{1E030}-\u{1E06D}\u{1E100}-\u{1E12C}\u{1E137}-\u{1E13D}\u{1E140}-\u{1E149}\u{1E14E}\u{1E14F}\u{1E290}-\u{1E2AD}\u{1E2C0}-\u{1E2EB}\u{1E2F0}-\u{1E2F9}\u{1E4D0}-\u{1E4EB}\u{1E4F0}-\u{1E4F9}\u{1E5D0}-\u{1E5ED}\u{1E5F0}-\u{1E5FA}\u{1E5FF}\u{1E7E0}-\u{1E7E6}\u{1E7E8}-\u{1E7EB}\u{1E7ED}\u{1E7EE}\u{1E7F0}-\u{1E7FE}\u{1F110}-\u{1F12E}\u{1F130}-\u{1F169}\u{1F170}-\u{1F1AC}\u{1F1E6}-\u{1F202}\u{1F210}-\u{1F23B}\u{1F240}-\u{1F248}\u{1F250}\u{1F251}\u{20000}-\u{2A6DF}\u{2A700}-\u{2B739}\u{2B740}-\u{2B81D}\u{2B820}-\u{2CEA1}\u{2CEB0}-\u{2EBE0}\u{2EBF0}-\u{2EE5D}\u{2F800}-\u{2FA1D}\u{30000}-\u{3134A}\u{31350}-\u{323AF}\u{F0000}-\u{FFFFD}\u{100000}-\u{10FFFD}]/u;
  const bidiS1RTL = /[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05EA\u05EF-\u05F4\u0608\u060B\u060D\u061B-\u064A\u066D-\u066F\u0671-\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u070D\u070F\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u083E\u0840-\u0858\u085E\u0860-\u086A\u0870-\u088E\u08A0-\u08C9\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC2\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFC\uFE70-\uFE74\uFE76-\uFEFC\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{10920}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A00}\u{10A10}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A40}-\u{10A48}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE4}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B40}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10D23}\u{10D4A}-\u{10D65}\u{10D6F}-\u{10D85}\u{10D8E}\u{10D8F}\u{10E80}-\u{10EA9}\u{10EAD}\u{10EB0}\u{10EB1}\u{10EC2}-\u{10EC4}\u{10F00}-\u{10F27}\u{10F30}-\u{10F45}\u{10F51}-\u{10F59}\u{10F70}-\u{10F81}\u{10F86}-\u{10F89}\u{10FB0}-\u{10FCB}\u{10FE0}-\u{10FF6}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8CF}\u{1E900}-\u{1E943}\u{1E94B}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EC71}-\u{1ECB4}\u{1ED01}-\u{1ED3D}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}]/u;
  const bidiS2 = /^[\0-\x08\x0E-\x1B!-@\[-`\{-\x84\x86-\xA9\xAB-\xB4\xB6-\xB9\xBB-\xBF\xD7\xF7\u02B9\u02BA\u02C2-\u02CF\u02D2-\u02DF\u02E5-\u02ED\u02EF-\u036F\u0374\u0375\u037E\u0384\u0385\u0387\u03F6\u0483-\u0489\u058A\u058D-\u058F\u0591-\u05C7\u05D0-\u05EA\u05EF-\u05F4\u0600-\u070D\u070F-\u074A\u074D-\u07B1\u07C0-\u07FA\u07FD-\u082D\u0830-\u083E\u0840-\u085B\u085E\u0860-\u086A\u0870-\u088E\u0890\u0891\u0897-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09F2\u09F3\u09FB\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AF1\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0BF3-\u0BFA\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C78-\u0C7E\u0C81\u0CBC\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E3F\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39-\u0F3D\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1390-\u1399\u1400\u169B\u169C\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DB\u17DD\u17F0-\u17F9\u1800-\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1940\u1944\u1945\u19DE-\u19FF\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u200B-\u200D\u200F-\u2027\u202F-\u205E\u2060-\u2064\u206A-\u2070\u2074-\u207E\u2080-\u208E\u20A0-\u20C0\u20D0-\u20F0\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u2150-\u215F\u2189-\u218B\u2190-\u2335\u237B-\u2394\u2396-\u2429\u2440-\u244A\u2460-\u249B\u24EA-\u26AB\u26AD-\u27FF\u2900-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2CE5-\u2CEA\u2CEF-\u2CF1\u2CF9-\u2CFF\u2D7F\u2DE0-\u2E5D\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFF\u3001-\u3004\u3008-\u3020\u302A-\u302D\u3030\u3036\u3037\u303D-\u303F\u3099-\u309C\u30A0\u30FB\u31C0-\u31E5\u31EF\u321D\u321E\u3250-\u325F\u327C-\u327E\u32B1-\u32BF\u32CC-\u32CF\u3377-\u337A\u33DE\u33DF\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA60D-\uA60F\uA66F-\uA67F\uA69E\uA69F\uA6F0\uA6F1\uA700-\uA721\uA788\uA802\uA806\uA80B\uA825\uA826\uA828-\uA82C\uA838\uA839\uA874-\uA877\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uAB6A\uAB6B\uABE5\uABE8\uABED\uFB1D-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC2\uFBD3-\uFD8F\uFD92-\uFDC7\uFDCF\uFDF0-\uFE19\uFE20-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFE70-\uFE74\uFE76-\uFEFC\uFEFF\uFF01-\uFF20\uFF3B-\uFF40\uFF5B-\uFF65\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFF9-\uFFFD\u{10101}\u{10140}-\u{1018C}\u{10190}-\u{1019C}\u{101A0}\u{101FD}\u{102E0}-\u{102FB}\u{10376}-\u{1037A}\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{1091F}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A38}-\u{10A3A}\u{10A3F}-\u{10A48}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE6}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B39}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10D27}\u{10D30}-\u{10D39}\u{10D40}-\u{10D65}\u{10D69}-\u{10D85}\u{10D8E}\u{10D8F}\u{10E60}-\u{10E7E}\u{10E80}-\u{10EA9}\u{10EAB}-\u{10EAD}\u{10EB0}\u{10EB1}\u{10EC2}-\u{10EC4}\u{10EFC}-\u{10F27}\u{10F30}-\u{10F59}\u{10F70}-\u{10F89}\u{10FB0}-\u{10FCB}\u{10FE0}-\u{10FF6}\u{11001}\u{11038}-\u{11046}\u{11052}-\u{11065}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{11241}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{113BB}-\u{113C0}\u{113CE}\u{113D0}\u{113D2}\u{113E1}\u{113E2}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{11660}-\u{1166C}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A06}\u{11A09}\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{11F00}\u{11F01}\u{11F36}-\u{11F3A}\u{11F40}\u{11F42}\u{11F5A}\u{11FD5}-\u{11FF1}\u{13440}\u{13447}-\u{13455}\u{1611E}-\u{16129}\u{1612D}-\u{1612F}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE2}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1BCA0}-\u{1BCA3}\u{1CC00}-\u{1CCD5}\u{1CCF0}-\u{1CCF9}\u{1CD00}-\u{1CEB3}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D173}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D1E9}\u{1D1EA}\u{1D200}-\u{1D245}\u{1D300}-\u{1D356}\u{1D6C1}\u{1D6DB}\u{1D6FB}\u{1D715}\u{1D735}\u{1D74F}\u{1D76F}\u{1D789}\u{1D7A9}\u{1D7C3}\u{1D7CE}-\u{1D7FF}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E2FF}\u{1E4EC}-\u{1E4EF}\u{1E5EE}\u{1E5EF}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8D6}\u{1E900}-\u{1E94B}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EC71}-\u{1ECB4}\u{1ED01}-\u{1ED3D}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}\u{1EEF0}\u{1EEF1}\u{1F000}-\u{1F02B}\u{1F030}-\u{1F093}\u{1F0A0}-\u{1F0AE}\u{1F0B1}-\u{1F0BF}\u{1F0C1}-\u{1F0CF}\u{1F0D1}-\u{1F0F5}\u{1F100}-\u{1F10F}\u{1F12F}\u{1F16A}-\u{1F16F}\u{1F1AD}\u{1F260}-\u{1F265}\u{1F300}-\u{1F6D7}\u{1F6DC}-\u{1F6EC}\u{1F6F0}-\u{1F6FC}\u{1F700}-\u{1F776}\u{1F77B}-\u{1F7D9}\u{1F7E0}-\u{1F7EB}\u{1F7F0}\u{1F800}-\u{1F80B}\u{1F810}-\u{1F847}\u{1F850}-\u{1F859}\u{1F860}-\u{1F887}\u{1F890}-\u{1F8AD}\u{1F8B0}-\u{1F8BB}\u{1F8C0}\u{1F8C1}\u{1F900}-\u{1FA53}\u{1FA60}-\u{1FA6D}\u{1FA70}-\u{1FA7C}\u{1FA80}-\u{1FA89}\u{1FA8F}-\u{1FAC6}\u{1FACE}-\u{1FADC}\u{1FADF}-\u{1FAE9}\u{1FAF0}-\u{1FAF8}\u{1FB00}-\u{1FB92}\u{1FB94}-\u{1FBF9}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}]*$/u;
  const bidiS3 = /[0-9\xB2\xB3\xB9\u05BE\u05C0\u05C3\u05C6\u05D0-\u05EA\u05EF-\u05F4\u0600-\u0605\u0608\u060B\u060D\u061B-\u064A\u0660-\u0669\u066B-\u066F\u0671-\u06D5\u06DD\u06E5\u06E6\u06EE-\u070D\u070F\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u083E\u0840-\u0858\u085E\u0860-\u086A\u0870-\u088E\u0890\u0891\u08A0-\u08C9\u08E2\u200F\u2070\u2074-\u2079\u2080-\u2089\u2488-\u249B\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC2\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFC\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\u{102E1}-\u{102FB}\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{10920}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A00}\u{10A10}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A40}-\u{10A48}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE4}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B40}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10D23}\u{10D30}-\u{10D39}\u{10D40}-\u{10D65}\u{10D6F}-\u{10D85}\u{10D8E}\u{10D8F}\u{10E60}-\u{10E7E}\u{10E80}-\u{10EA9}\u{10EAD}\u{10EB0}\u{10EB1}\u{10EC2}-\u{10EC4}\u{10F00}-\u{10F27}\u{10F30}-\u{10F45}\u{10F51}-\u{10F59}\u{10F70}-\u{10F81}\u{10F86}-\u{10F89}\u{10FB0}-\u{10FCB}\u{10FE0}-\u{10FF6}\u{1CCF0}-\u{1CCF9}\u{1D7CE}-\u{1D7FF}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8CF}\u{1E900}-\u{1E943}\u{1E94B}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EC71}-\u{1ECB4}\u{1ED01}-\u{1ED3D}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}\u{1F100}-\u{1F10A}\u{1FBF0}-\u{1FBF9}][\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10D69}-\u{10D6D}\u{10EAB}\u{10EAC}\u{10EFC}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11001}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{11241}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{113BB}-\u{113C0}\u{113CE}\u{113D0}\u{113D2}\u{113E1}\u{113E2}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A06}\u{11A09}\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{11F00}\u{11F01}\u{11F36}-\u{11F3A}\u{11F40}\u{11F42}\u{11F5A}\u{13440}\u{13447}-\u{13455}\u{1611E}-\u{16129}\u{1612D}-\u{1612F}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D17B}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E5EE}\u{1E5EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{E0100}-\u{E01EF}]*$/u;
  const bidiS4EN = /[0-9\xB2\xB3\xB9\u06F0-\u06F9\u2070\u2074-\u2079\u2080-\u2089\u2488-\u249B\uFF10-\uFF19\u{102E1}-\u{102FB}\u{1CCF0}-\u{1CCF9}\u{1D7CE}-\u{1D7FF}\u{1F100}-\u{1F10A}\u{1FBF0}-\u{1FBF9}]/u;
  const bidiS4AN = /[\u0600-\u0605\u0660-\u0669\u066B\u066C\u06DD\u0890\u0891\u08E2\u{10D30}-\u{10D39}\u{10D40}-\u{10D49}\u{10E60}-\u{10E7E}]/u;
  const bidiS5 = /^[\0-\x08\x0E-\x1B!-\x84\x86-\u0377\u037A-\u037F\u0384-\u038A\u038C\u038E-\u03A1\u03A3-\u052F\u0531-\u0556\u0559-\u058A\u058D-\u058F\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0606\u0607\u0609\u060A\u060C\u060E-\u061A\u064B-\u065F\u066A\u0670\u06D6-\u06DC\u06DE-\u06E4\u06E7-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07F6-\u07F9\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09FE\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A76\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AF1\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B77\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BFA\u0C00-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3C-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C5D\u0C60-\u0C63\u0C66-\u0C6F\u0C77-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDD\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1-\u0CF3\u0D00-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4F\u0D54-\u0D63\u0D66-\u0D7F\u0D81-\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4\u0E01-\u0E3A\u0E3F-\u0E5B\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECE\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00-\u0F47\u0F49-\u0F6C\u0F71-\u0F97\u0F99-\u0FBC\u0FBE-\u0FCC\u0FCE-\u0FDA\u1000-\u10C5\u10C7\u10CD\u10D0-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u137C\u1380-\u1399\u13A0-\u13F5\u13F8-\u13FD\u1400-\u167F\u1681-\u169C\u16A0-\u16F8\u1700-\u1715\u171F-\u1736\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17DD\u17E0-\u17E9\u17F0-\u17F9\u1800-\u1819\u1820-\u1878\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1940\u1944-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u19DE-\u1A1B\u1A1E-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA0-\u1AAD\u1AB0-\u1ACE\u1B00-\u1B4C\u1B4E-\u1BF3\u1BFC-\u1C37\u1C3B-\u1C49\u1C4D-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CC7\u1CD0-\u1CFA\u1D00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FC4\u1FC6-\u1FD3\u1FD6-\u1FDB\u1FDD-\u1FEF\u1FF2-\u1FF4\u1FF6-\u1FFE\u200B-\u200E\u2010-\u2027\u202F-\u205E\u2060-\u2064\u206A-\u2071\u2074-\u208E\u2090-\u209C\u20A0-\u20C0\u20D0-\u20F0\u2100-\u218B\u2190-\u2429\u2440-\u244A\u2460-\u2B73\u2B76-\u2B95\u2B97-\u2CF3\u2CF9-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D70\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2E5D\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFF\u3001-\u303F\u3041-\u3096\u3099-\u30FF\u3105-\u312F\u3131-\u318E\u3190-\u31E5\u31EF-\u321E\u3220-\uA48C\uA490-\uA4C6\uA4D0-\uA62B\uA640-\uA6F7\uA700-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA82C\uA830-\uA839\uA840-\uA877\uA880-\uA8C5\uA8CE-\uA8D9\uA8E0-\uA953\uA95F-\uA97C\uA980-\uA9CD\uA9CF-\uA9D9\uA9DE-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA5C-\uAAC2\uAADB-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB6B\uAB70-\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uD800-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1E\uFB29\uFD3E-\uFD4F\uFDCF\uFDFD-\uFE19\uFE20-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFEFF\uFF01-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFF9-\uFFFD\u{10000}-\u{1000B}\u{1000D}-\u{10026}\u{10028}-\u{1003A}\u{1003C}\u{1003D}\u{1003F}-\u{1004D}\u{10050}-\u{1005D}\u{10080}-\u{100FA}\u{10100}-\u{10102}\u{10107}-\u{10133}\u{10137}-\u{1018E}\u{10190}-\u{1019C}\u{101A0}\u{101D0}-\u{101FD}\u{10280}-\u{1029C}\u{102A0}-\u{102D0}\u{102E0}-\u{102FB}\u{10300}-\u{10323}\u{1032D}-\u{1034A}\u{10350}-\u{1037A}\u{10380}-\u{1039D}\u{1039F}-\u{103C3}\u{103C8}-\u{103D5}\u{10400}-\u{1049D}\u{104A0}-\u{104A9}\u{104B0}-\u{104D3}\u{104D8}-\u{104FB}\u{10500}-\u{10527}\u{10530}-\u{10563}\u{1056F}-\u{1057A}\u{1057C}-\u{1058A}\u{1058C}-\u{10592}\u{10594}\u{10595}\u{10597}-\u{105A1}\u{105A3}-\u{105B1}\u{105B3}-\u{105B9}\u{105BB}\u{105BC}\u{105C0}-\u{105F3}\u{10600}-\u{10736}\u{10740}-\u{10755}\u{10760}-\u{10767}\u{10780}-\u{10785}\u{10787}-\u{107B0}\u{107B2}-\u{107BA}\u{1091F}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10B39}-\u{10B3F}\u{10D24}-\u{10D27}\u{10D69}-\u{10D6E}\u{10EAB}\u{10EAC}\u{10EFC}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11000}-\u{1104D}\u{11052}-\u{11075}\u{1107F}-\u{110C2}\u{110CD}\u{110D0}-\u{110E8}\u{110F0}-\u{110F9}\u{11100}-\u{11134}\u{11136}-\u{11147}\u{11150}-\u{11176}\u{11180}-\u{111DF}\u{111E1}-\u{111F4}\u{11200}-\u{11211}\u{11213}-\u{11241}\u{11280}-\u{11286}\u{11288}\u{1128A}-\u{1128D}\u{1128F}-\u{1129D}\u{1129F}-\u{112A9}\u{112B0}-\u{112EA}\u{112F0}-\u{112F9}\u{11300}-\u{11303}\u{11305}-\u{1130C}\u{1130F}\u{11310}\u{11313}-\u{11328}\u{1132A}-\u{11330}\u{11332}\u{11333}\u{11335}-\u{11339}\u{1133B}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11350}\u{11357}\u{1135D}-\u{11363}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11380}-\u{11389}\u{1138B}\u{1138E}\u{11390}-\u{113B5}\u{113B7}-\u{113C0}\u{113C2}\u{113C5}\u{113C7}-\u{113CA}\u{113CC}-\u{113D5}\u{113D7}\u{113D8}\u{113E1}\u{113E2}\u{11400}-\u{1145B}\u{1145D}-\u{11461}\u{11480}-\u{114C7}\u{114D0}-\u{114D9}\u{11580}-\u{115B5}\u{115B8}-\u{115DD}\u{11600}-\u{11644}\u{11650}-\u{11659}\u{11660}-\u{1166C}\u{11680}-\u{116B9}\u{116C0}-\u{116C9}\u{116D0}-\u{116E3}\u{11700}-\u{1171A}\u{1171D}-\u{1172B}\u{11730}-\u{11746}\u{11800}-\u{1183B}\u{118A0}-\u{118F2}\u{118FF}-\u{11906}\u{11909}\u{1190C}-\u{11913}\u{11915}\u{11916}\u{11918}-\u{11935}\u{11937}\u{11938}\u{1193B}-\u{11946}\u{11950}-\u{11959}\u{119A0}-\u{119A7}\u{119AA}-\u{119D7}\u{119DA}-\u{119E4}\u{11A00}-\u{11A47}\u{11A50}-\u{11AA2}\u{11AB0}-\u{11AF8}\u{11B00}-\u{11B09}\u{11BC0}-\u{11BE1}\u{11BF0}-\u{11BF9}\u{11C00}-\u{11C08}\u{11C0A}-\u{11C36}\u{11C38}-\u{11C45}\u{11C50}-\u{11C6C}\u{11C70}-\u{11C8F}\u{11C92}-\u{11CA7}\u{11CA9}-\u{11CB6}\u{11D00}-\u{11D06}\u{11D08}\u{11D09}\u{11D0B}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D47}\u{11D50}-\u{11D59}\u{11D60}-\u{11D65}\u{11D67}\u{11D68}\u{11D6A}-\u{11D8E}\u{11D90}\u{11D91}\u{11D93}-\u{11D98}\u{11DA0}-\u{11DA9}\u{11EE0}-\u{11EF8}\u{11F00}-\u{11F10}\u{11F12}-\u{11F3A}\u{11F3E}-\u{11F5A}\u{11FB0}\u{11FC0}-\u{11FF1}\u{11FFF}-\u{12399}\u{12400}-\u{1246E}\u{12470}-\u{12474}\u{12480}-\u{12543}\u{12F90}-\u{12FF2}\u{13000}-\u{13455}\u{13460}-\u{143FA}\u{14400}-\u{14646}\u{16100}-\u{16139}\u{16800}-\u{16A38}\u{16A40}-\u{16A5E}\u{16A60}-\u{16A69}\u{16A6E}-\u{16ABE}\u{16AC0}-\u{16AC9}\u{16AD0}-\u{16AED}\u{16AF0}-\u{16AF5}\u{16B00}-\u{16B45}\u{16B50}-\u{16B59}\u{16B5B}-\u{16B61}\u{16B63}-\u{16B77}\u{16B7D}-\u{16B8F}\u{16D40}-\u{16D79}\u{16E40}-\u{16E9A}\u{16F00}-\u{16F4A}\u{16F4F}-\u{16F87}\u{16F8F}-\u{16F9F}\u{16FE0}-\u{16FE4}\u{16FF0}\u{16FF1}\u{17000}-\u{187F7}\u{18800}-\u{18CD5}\u{18CFF}-\u{18D08}\u{1AFF0}-\u{1AFF3}\u{1AFF5}-\u{1AFFB}\u{1AFFD}\u{1AFFE}\u{1B000}-\u{1B122}\u{1B132}\u{1B150}-\u{1B152}\u{1B155}\u{1B164}-\u{1B167}\u{1B170}-\u{1B2FB}\u{1BC00}-\u{1BC6A}\u{1BC70}-\u{1BC7C}\u{1BC80}-\u{1BC88}\u{1BC90}-\u{1BC99}\u{1BC9C}-\u{1BCA3}\u{1CC00}-\u{1CCF9}\u{1CD00}-\u{1CEB3}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1CF50}-\u{1CFC3}\u{1D000}-\u{1D0F5}\u{1D100}-\u{1D126}\u{1D129}-\u{1D1EA}\u{1D200}-\u{1D245}\u{1D2C0}-\u{1D2D3}\u{1D2E0}-\u{1D2F3}\u{1D300}-\u{1D356}\u{1D360}-\u{1D378}\u{1D400}-\u{1D454}\u{1D456}-\u{1D49C}\u{1D49E}\u{1D49F}\u{1D4A2}\u{1D4A5}\u{1D4A6}\u{1D4A9}-\u{1D4AC}\u{1D4AE}-\u{1D4B9}\u{1D4BB}\u{1D4BD}-\u{1D4C3}\u{1D4C5}-\u{1D505}\u{1D507}-\u{1D50A}\u{1D50D}-\u{1D514}\u{1D516}-\u{1D51C}\u{1D51E}-\u{1D539}\u{1D53B}-\u{1D53E}\u{1D540}-\u{1D544}\u{1D546}\u{1D54A}-\u{1D550}\u{1D552}-\u{1D6A5}\u{1D6A8}-\u{1D7CB}\u{1D7CE}-\u{1DA8B}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1DF00}-\u{1DF1E}\u{1DF25}-\u{1DF2A}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E030}-\u{1E06D}\u{1E08F}\u{1E100}-\u{1E12C}\u{1E130}-\u{1E13D}\u{1E140}-\u{1E149}\u{1E14E}\u{1E14F}\u{1E290}-\u{1E2AE}\u{1E2C0}-\u{1E2F9}\u{1E2FF}\u{1E4D0}-\u{1E4F9}\u{1E5D0}-\u{1E5FA}\u{1E5FF}\u{1E7E0}-\u{1E7E6}\u{1E7E8}-\u{1E7EB}\u{1E7ED}\u{1E7EE}\u{1E7F0}-\u{1E7FE}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{1EEF0}\u{1EEF1}\u{1F000}-\u{1F02B}\u{1F030}-\u{1F093}\u{1F0A0}-\u{1F0AE}\u{1F0B1}-\u{1F0BF}\u{1F0C1}-\u{1F0CF}\u{1F0D1}-\u{1F0F5}\u{1F100}-\u{1F1AD}\u{1F1E6}-\u{1F202}\u{1F210}-\u{1F23B}\u{1F240}-\u{1F248}\u{1F250}\u{1F251}\u{1F260}-\u{1F265}\u{1F300}-\u{1F6D7}\u{1F6DC}-\u{1F6EC}\u{1F6F0}-\u{1F6FC}\u{1F700}-\u{1F776}\u{1F77B}-\u{1F7D9}\u{1F7E0}-\u{1F7EB}\u{1F7F0}\u{1F800}-\u{1F80B}\u{1F810}-\u{1F847}\u{1F850}-\u{1F859}\u{1F860}-\u{1F887}\u{1F890}-\u{1F8AD}\u{1F8B0}-\u{1F8BB}\u{1F8C0}\u{1F8C1}\u{1F900}-\u{1FA53}\u{1FA60}-\u{1FA6D}\u{1FA70}-\u{1FA7C}\u{1FA80}-\u{1FA89}\u{1FA8F}-\u{1FAC6}\u{1FACE}-\u{1FADC}\u{1FADF}-\u{1FAE9}\u{1FAF0}-\u{1FAF8}\u{1FB00}-\u{1FB92}\u{1FB94}-\u{1FBF9}\u{20000}-\u{2A6DF}\u{2A700}-\u{2B739}\u{2B740}-\u{2B81D}\u{2B820}-\u{2CEA1}\u{2CEB0}-\u{2EBE0}\u{2EBF0}-\u{2EE5D}\u{2F800}-\u{2FA1D}\u{30000}-\u{3134A}\u{31350}-\u{323AF}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}\u{F0000}-\u{FFFFD}\u{100000}-\u{10FFFD}]*$/u;
  const bidiS6 = /[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u02BB-\u02C1\u02D0\u02D1\u02E0-\u02E4\u02EE\u0370-\u0373\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0482\u048A-\u052F\u0531-\u0556\u0559-\u0589\u06F0-\u06F9\u0903-\u0939\u093B\u093D-\u0940\u0949-\u094C\u094E-\u0950\u0958-\u0961\u0964-\u0980\u0982\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD-\u09C0\u09C7\u09C8\u09CB\u09CC\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09FA\u09FC\u09FD\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3E-\u0A40\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A76\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD-\u0AC0\u0AC9\u0ACB\u0ACC\u0AD0\u0AE0\u0AE1\u0AE6-\u0AF0\u0AF9\u0B02\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B3E\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0B57\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD0\u0BD7\u0BE6-\u0BF2\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C41-\u0C44\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C66-\u0C6F\u0C77\u0C7F\u0C80\u0C82-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD-\u0CC4\u0CC6-\u0CC8\u0CCA\u0CCB\u0CD5\u0CD6\u0CDD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1-\u0CF3\u0D02-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D4E\u0D4F\u0D54-\u0D61\u0D66-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCF-\u0DD1\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E4F-\u0E5B\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00-\u0F17\u0F1A-\u0F34\u0F36\u0F38\u0F3E-\u0F47\u0F49-\u0F6C\u0F7F\u0F85\u0F88-\u0F8C\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE-\u0FDA\u1000-\u102C\u1031\u1038\u103B\u103C\u103F-\u1057\u105A-\u105D\u1061-\u1070\u1075-\u1081\u1083\u1084\u1087-\u108C\u108E-\u109C\u109E-\u10C5\u10C7\u10CD\u10D0-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1360-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u167F\u1681-\u169A\u16A0-\u16F8\u1700-\u1711\u1715\u171F-\u1731\u1734-\u1736\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17B6\u17BE-\u17C5\u17C7\u17C8\u17D4-\u17DA\u17DC\u17E0-\u17E9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A19\u1A1A\u1A1E-\u1A55\u1A57\u1A61\u1A63\u1A64\u1A6D-\u1A72\u1A80-\u1A89\u1A90-\u1A99\u1AA0-\u1AAD\u1B04-\u1B33\u1B35\u1B3B\u1B3D-\u1B41\u1B43-\u1B4C\u1B4E-\u1B6A\u1B74-\u1B7F\u1B82-\u1BA1\u1BA6\u1BA7\u1BAA\u1BAE-\u1BE5\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1BFC-\u1C2B\u1C34\u1C35\u1C3B-\u1C49\u1C4D-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CC7\u1CD3\u1CE1\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5-\u1CF7\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200E\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u214F\u2160-\u2188\u2336-\u237A\u2395\u2488-\u24E9\u26AC\u2800-\u28FF\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D70\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u302E\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3190-\u31BF\u31F0-\u321C\u3220-\u324F\u3260-\u327B\u327F-\u32B0\u32C0-\u32CB\u32D0-\u3376\u337B-\u33DD\u33E0-\u33FE\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA60C\uA610-\uA62B\uA640-\uA66E\uA680-\uA69D\uA6A0-\uA6EF\uA6F2-\uA6F7\uA722-\uA787\uA789-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA824\uA827\uA830-\uA837\uA840-\uA873\uA880-\uA8C3\uA8CE-\uA8D9\uA8F2-\uA8FE\uA900-\uA925\uA92E-\uA946\uA952\uA953\uA95F-\uA97C\uA983-\uA9B2\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9CD\uA9CF-\uA9D9\uA9DE-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA2F\uAA30\uAA33\uAA34\uAA40-\uAA42\uAA44-\uAA4B\uAA4D\uAA50-\uAA59\uAA5C-\uAA7B\uAA7D-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAAEB\uAAEE-\uAAF5\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB69\uAB70-\uABE4\uABE6\uABE7\uABE9-\uABEC\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uD800-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\u{10000}-\u{1000B}\u{1000D}-\u{10026}\u{10028}-\u{1003A}\u{1003C}\u{1003D}\u{1003F}-\u{1004D}\u{10050}-\u{1005D}\u{10080}-\u{100FA}\u{10100}\u{10102}\u{10107}-\u{10133}\u{10137}-\u{1013F}\u{1018D}\u{1018E}\u{101D0}-\u{101FC}\u{10280}-\u{1029C}\u{102A0}-\u{102D0}\u{102E1}-\u{102FB}\u{10300}-\u{10323}\u{1032D}-\u{1034A}\u{10350}-\u{10375}\u{10380}-\u{1039D}\u{1039F}-\u{103C3}\u{103C8}-\u{103D5}\u{10400}-\u{1049D}\u{104A0}-\u{104A9}\u{104B0}-\u{104D3}\u{104D8}-\u{104FB}\u{10500}-\u{10527}\u{10530}-\u{10563}\u{1056F}-\u{1057A}\u{1057C}-\u{1058A}\u{1058C}-\u{10592}\u{10594}\u{10595}\u{10597}-\u{105A1}\u{105A3}-\u{105B1}\u{105B3}-\u{105B9}\u{105BB}\u{105BC}\u{105C0}-\u{105F3}\u{10600}-\u{10736}\u{10740}-\u{10755}\u{10760}-\u{10767}\u{10780}-\u{10785}\u{10787}-\u{107B0}\u{107B2}-\u{107BA}\u{11000}\u{11002}-\u{11037}\u{11047}-\u{1104D}\u{11066}-\u{1106F}\u{11071}\u{11072}\u{11075}\u{11082}-\u{110B2}\u{110B7}\u{110B8}\u{110BB}-\u{110C1}\u{110CD}\u{110D0}-\u{110E8}\u{110F0}-\u{110F9}\u{11103}-\u{11126}\u{1112C}\u{11136}-\u{11147}\u{11150}-\u{11172}\u{11174}-\u{11176}\u{11182}-\u{111B5}\u{111BF}-\u{111C8}\u{111CD}\u{111CE}\u{111D0}-\u{111DF}\u{111E1}-\u{111F4}\u{11200}-\u{11211}\u{11213}-\u{1122E}\u{11232}\u{11233}\u{11235}\u{11238}-\u{1123D}\u{1123F}\u{11240}\u{11280}-\u{11286}\u{11288}\u{1128A}-\u{1128D}\u{1128F}-\u{1129D}\u{1129F}-\u{112A9}\u{112B0}-\u{112DE}\u{112E0}-\u{112E2}\u{112F0}-\u{112F9}\u{11302}\u{11303}\u{11305}-\u{1130C}\u{1130F}\u{11310}\u{11313}-\u{11328}\u{1132A}-\u{11330}\u{11332}\u{11333}\u{11335}-\u{11339}\u{1133D}-\u{1133F}\u{11341}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11350}\u{11357}\u{1135D}-\u{11363}\u{11380}-\u{11389}\u{1138B}\u{1138E}\u{11390}-\u{113B5}\u{113B7}-\u{113BA}\u{113C2}\u{113C5}\u{113C7}-\u{113CA}\u{113CC}\u{113CD}\u{113CF}\u{113D1}\u{113D3}-\u{113D5}\u{113D7}\u{113D8}\u{11400}-\u{11437}\u{11440}\u{11441}\u{11445}\u{11447}-\u{1145B}\u{1145D}\u{1145F}-\u{11461}\u{11480}-\u{114B2}\u{114B9}\u{114BB}-\u{114BE}\u{114C1}\u{114C4}-\u{114C7}\u{114D0}-\u{114D9}\u{11580}-\u{115B1}\u{115B8}-\u{115BB}\u{115BE}\u{115C1}-\u{115DB}\u{11600}-\u{11632}\u{1163B}\u{1163C}\u{1163E}\u{11641}-\u{11644}\u{11650}-\u{11659}\u{11680}-\u{116AA}\u{116AC}\u{116AE}\u{116AF}\u{116B6}\u{116B8}\u{116B9}\u{116C0}-\u{116C9}\u{116D0}-\u{116E3}\u{11700}-\u{1171A}\u{1171E}\u{11720}\u{11721}\u{11726}\u{11730}-\u{11746}\u{11800}-\u{1182E}\u{11838}\u{1183B}\u{118A0}-\u{118F2}\u{118FF}-\u{11906}\u{11909}\u{1190C}-\u{11913}\u{11915}\u{11916}\u{11918}-\u{11935}\u{11937}\u{11938}\u{1193D}\u{1193F}-\u{11942}\u{11944}-\u{11946}\u{11950}-\u{11959}\u{119A0}-\u{119A7}\u{119AA}-\u{119D3}\u{119DC}-\u{119DF}\u{119E1}-\u{119E4}\u{11A00}\u{11A07}\u{11A08}\u{11A0B}-\u{11A32}\u{11A39}\u{11A3A}\u{11A3F}-\u{11A46}\u{11A50}\u{11A57}\u{11A58}\u{11A5C}-\u{11A89}\u{11A97}\u{11A9A}-\u{11AA2}\u{11AB0}-\u{11AF8}\u{11B00}-\u{11B09}\u{11BC0}-\u{11BE1}\u{11BF0}-\u{11BF9}\u{11C00}-\u{11C08}\u{11C0A}-\u{11C2F}\u{11C3E}-\u{11C45}\u{11C50}-\u{11C6C}\u{11C70}-\u{11C8F}\u{11CA9}\u{11CB1}\u{11CB4}\u{11D00}-\u{11D06}\u{11D08}\u{11D09}\u{11D0B}-\u{11D30}\u{11D46}\u{11D50}-\u{11D59}\u{11D60}-\u{11D65}\u{11D67}\u{11D68}\u{11D6A}-\u{11D8E}\u{11D93}\u{11D94}\u{11D96}\u{11D98}\u{11DA0}-\u{11DA9}\u{11EE0}-\u{11EF2}\u{11EF5}-\u{11EF8}\u{11F02}-\u{11F10}\u{11F12}-\u{11F35}\u{11F3E}\u{11F3F}\u{11F41}\u{11F43}-\u{11F59}\u{11FB0}\u{11FC0}-\u{11FD4}\u{11FFF}-\u{12399}\u{12400}-\u{1246E}\u{12470}-\u{12474}\u{12480}-\u{12543}\u{12F90}-\u{12FF2}\u{13000}-\u{1343F}\u{13441}-\u{13446}\u{13460}-\u{143FA}\u{14400}-\u{14646}\u{16100}-\u{1611D}\u{1612A}-\u{1612C}\u{16130}-\u{16139}\u{16800}-\u{16A38}\u{16A40}-\u{16A5E}\u{16A60}-\u{16A69}\u{16A6E}-\u{16ABE}\u{16AC0}-\u{16AC9}\u{16AD0}-\u{16AED}\u{16AF5}\u{16B00}-\u{16B2F}\u{16B37}-\u{16B45}\u{16B50}-\u{16B59}\u{16B5B}-\u{16B61}\u{16B63}-\u{16B77}\u{16B7D}-\u{16B8F}\u{16D40}-\u{16D79}\u{16E40}-\u{16E9A}\u{16F00}-\u{16F4A}\u{16F50}-\u{16F87}\u{16F93}-\u{16F9F}\u{16FE0}\u{16FE1}\u{16FE3}\u{16FF0}\u{16FF1}\u{17000}-\u{187F7}\u{18800}-\u{18CD5}\u{18CFF}-\u{18D08}\u{1AFF0}-\u{1AFF3}\u{1AFF5}-\u{1AFFB}\u{1AFFD}\u{1AFFE}\u{1B000}-\u{1B122}\u{1B132}\u{1B150}-\u{1B152}\u{1B155}\u{1B164}-\u{1B167}\u{1B170}-\u{1B2FB}\u{1BC00}-\u{1BC6A}\u{1BC70}-\u{1BC7C}\u{1BC80}-\u{1BC88}\u{1BC90}-\u{1BC99}\u{1BC9C}\u{1BC9F}\u{1CCD6}-\u{1CCF9}\u{1CF50}-\u{1CFC3}\u{1D000}-\u{1D0F5}\u{1D100}-\u{1D126}\u{1D129}-\u{1D166}\u{1D16A}-\u{1D172}\u{1D183}\u{1D184}\u{1D18C}-\u{1D1A9}\u{1D1AE}-\u{1D1E8}\u{1D2C0}-\u{1D2D3}\u{1D2E0}-\u{1D2F3}\u{1D360}-\u{1D378}\u{1D400}-\u{1D454}\u{1D456}-\u{1D49C}\u{1D49E}\u{1D49F}\u{1D4A2}\u{1D4A5}\u{1D4A6}\u{1D4A9}-\u{1D4AC}\u{1D4AE}-\u{1D4B9}\u{1D4BB}\u{1D4BD}-\u{1D4C3}\u{1D4C5}-\u{1D505}\u{1D507}-\u{1D50A}\u{1D50D}-\u{1D514}\u{1D516}-\u{1D51C}\u{1D51E}-\u{1D539}\u{1D53B}-\u{1D53E}\u{1D540}-\u{1D544}\u{1D546}\u{1D54A}-\u{1D550}\u{1D552}-\u{1D6A5}\u{1D6A8}-\u{1D6C0}\u{1D6C2}-\u{1D6DA}\u{1D6DC}-\u{1D6FA}\u{1D6FC}-\u{1D714}\u{1D716}-\u{1D734}\u{1D736}-\u{1D74E}\u{1D750}-\u{1D76E}\u{1D770}-\u{1D788}\u{1D78A}-\u{1D7A8}\u{1D7AA}-\u{1D7C2}\u{1D7C4}-\u{1D7CB}\u{1D7CE}-\u{1D9FF}\u{1DA37}-\u{1DA3A}\u{1DA6D}-\u{1DA74}\u{1DA76}-\u{1DA83}\u{1DA85}-\u{1DA8B}\u{1DF00}-\u{1DF1E}\u{1DF25}-\u{1DF2A}\u{1E030}-\u{1E06D}\u{1E100}-\u{1E12C}\u{1E137}-\u{1E13D}\u{1E140}-\u{1E149}\u{1E14E}\u{1E14F}\u{1E290}-\u{1E2AD}\u{1E2C0}-\u{1E2EB}\u{1E2F0}-\u{1E2F9}\u{1E4D0}-\u{1E4EB}\u{1E4F0}-\u{1E4F9}\u{1E5D0}-\u{1E5ED}\u{1E5F0}-\u{1E5FA}\u{1E5FF}\u{1E7E0}-\u{1E7E6}\u{1E7E8}-\u{1E7EB}\u{1E7ED}\u{1E7EE}\u{1E7F0}-\u{1E7FE}\u{1F100}-\u{1F10A}\u{1F110}-\u{1F12E}\u{1F130}-\u{1F169}\u{1F170}-\u{1F1AC}\u{1F1E6}-\u{1F202}\u{1F210}-\u{1F23B}\u{1F240}-\u{1F248}\u{1F250}\u{1F251}\u{1FBF0}-\u{1FBF9}\u{20000}-\u{2A6DF}\u{2A700}-\u{2B739}\u{2B740}-\u{2B81D}\u{2B820}-\u{2CEA1}\u{2CEB0}-\u{2EBE0}\u{2EBF0}-\u{2EE5D}\u{2F800}-\u{2FA1D}\u{30000}-\u{3134A}\u{31350}-\u{323AF}\u{F0000}-\u{FFFFD}\u{100000}-\u{10FFFD}][\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10D69}-\u{10D6D}\u{10EAB}\u{10EAC}\u{10EFC}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11001}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{11241}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{113BB}-\u{113C0}\u{113CE}\u{113D0}\u{113D2}\u{113E1}\u{113E2}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A06}\u{11A09}\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{11F00}\u{11F01}\u{11F36}-\u{11F3A}\u{11F40}\u{11F42}\u{11F5A}\u{13440}\u{13447}-\u{13455}\u{1611E}-\u{16129}\u{1612D}-\u{1612F}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D17B}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E5EE}\u{1E5EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{E0100}-\u{E01EF}]*$/u;
  regexes = {
    combiningMarks,
    combiningClassVirama,
    validZWNJ,
    bidiDomain,
    bidiS1LTR,
    bidiS1RTL,
    bidiS2,
    bidiS3,
    bidiS4EN,
    bidiS4AN,
    bidiS5,
    bidiS6
  };
  return regexes;
}
const require$$2$1 = /* @__PURE__ */ JSON.parse('[[[0,44],2],[[45,46],2],[47,2],[[48,57],2],[[58,64],2],[65,1,"a"],[66,1,"b"],[67,1,"c"],[68,1,"d"],[69,1,"e"],[70,1,"f"],[71,1,"g"],[72,1,"h"],[73,1,"i"],[74,1,"j"],[75,1,"k"],[76,1,"l"],[77,1,"m"],[78,1,"n"],[79,1,"o"],[80,1,"p"],[81,1,"q"],[82,1,"r"],[83,1,"s"],[84,1,"t"],[85,1,"u"],[86,1,"v"],[87,1,"w"],[88,1,"x"],[89,1,"y"],[90,1,"z"],[[91,96],2],[[97,122],2],[[123,127],2],[[128,159],3],[160,1," "],[[161,167],2],[168,1," "],[169,2],[170,1,"a"],[[171,172],2],[173,7],[174,2],[175,1," "],[[176,177],2],[178,1,"2"],[179,1,"3"],[180,1," "],[181,1,""],[182,2],[183,2],[184,1," "],[185,1,"1"],[186,1,"o"],[187,2],[188,1,"14"],[189,1,"12"],[190,1,"34"],[191,2],[192,1,""],[193,1,""],[194,1,""],[195,1,""],[196,1,""],[197,1,""],[198,1,""],[199,1,""],[200,1,""],[201,1,""],[202,1,""],[203,1,""],[204,1,""],[205,1,""],[206,1,""],[207,1,""],[208,1,""],[209,1,""],[210,1,""],[211,1,""],[212,1,""],[213,1,""],[214,1,""],[215,2],[216,1,""],[217,1,""],[218,1,""],[219,1,""],[220,1,""],[221,1,""],[222,1,""],[223,6,"ss"],[[224,246],2],[247,2],[[248,255],2],[256,1,""],[257,2],[258,1,""],[259,2],[260,1,""],[261,2],[262,1,""],[263,2],[264,1,""],[265,2],[266,1,""],[267,2],[268,1,""],[269,2],[270,1,""],[271,2],[272,1,""],[273,2],[274,1,""],[275,2],[276,1,""],[277,2],[278,1,""],[279,2],[280,1,""],[281,2],[282,1,""],[283,2],[284,1,""],[285,2],[286,1,""],[287,2],[288,1,""],[289,2],[290,1,""],[291,2],[292,1,""],[293,2],[294,1,""],[295,2],[296,1,""],[297,2],[298,1,""],[299,2],[300,1,""],[301,2],[302,1,""],[303,2],[304,1,"i"],[305,2],[[306,307],1,"ij"],[308,1,""],[309,2],[310,1,""],[[311,312],2],[313,1,""],[314,2],[315,1,""],[316,2],[317,1,""],[318,2],[[319,320],1,"l"],[321,1,""],[322,2],[323,1,""],[324,2],[325,1,""],[326,2],[327,1,""],[328,2],[329,1,"n"],[330,1,""],[331,2],[332,1,""],[333,2],[334,1,""],[335,2],[336,1,""],[337,2],[338,1,""],[339,2],[340,1,""],[341,2],[342,1,""],[343,2],[344,1,""],[345,2],[346,1,""],[347,2],[348,1,""],[349,2],[350,1,""],[351,2],[352,1,""],[353,2],[354,1,""],[355,2],[356,1,""],[357,2],[358,1,""],[359,2],[360,1,""],[361,2],[362,1,""],[363,2],[364,1,""],[365,2],[366,1,""],[367,2],[368,1,""],[369,2],[370,1,""],[371,2],[372,1,""],[373,2],[374,1,""],[375,2],[376,1,""],[377,1,""],[378,2],[379,1,""],[380,2],[381,1,""],[382,2],[383,1,"s"],[384,2],[385,1,""],[386,1,""],[387,2],[388,1,""],[389,2],[390,1,""],[391,1,""],[392,2],[393,1,""],[394,1,""],[395,1,""],[[396,397],2],[398,1,""],[399,1,""],[400,1,""],[401,1,""],[402,2],[403,1,""],[404,1,""],[405,2],[406,1,""],[407,1,""],[408,1,""],[[409,411],2],[412,1,""],[413,1,""],[414,2],[415,1,""],[416,1,""],[417,2],[418,1,""],[419,2],[420,1,""],[421,2],[422,1,""],[423,1,""],[424,2],[425,1,""],[[426,427],2],[428,1,""],[429,2],[430,1,""],[431,1,""],[432,2],[433,1,""],[434,1,""],[435,1,""],[436,2],[437,1,""],[438,2],[439,1,""],[440,1,""],[[441,443],2],[444,1,""],[[445,451],2],[[452,454],1,"d"],[[455,457],1,"lj"],[[458,460],1,"nj"],[461,1,""],[462,2],[463,1,""],[464,2],[465,1,""],[466,2],[467,1,""],[468,2],[469,1,""],[470,2],[471,1,""],[472,2],[473,1,""],[474,2],[475,1,""],[[476,477],2],[478,1,""],[479,2],[480,1,""],[481,2],[482,1,""],[483,2],[484,1,""],[485,2],[486,1,""],[487,2],[488,1,""],[489,2],[490,1,""],[491,2],[492,1,""],[493,2],[494,1,""],[[495,496],2],[[497,499],1,"dz"],[500,1,""],[501,2],[502,1,""],[503,1,""],[504,1,""],[505,2],[506,1,""],[507,2],[508,1,""],[509,2],[510,1,""],[511,2],[512,1,""],[513,2],[514,1,""],[515,2],[516,1,""],[517,2],[518,1,""],[519,2],[520,1,""],[521,2],[522,1,""],[523,2],[524,1,""],[525,2],[526,1,""],[527,2],[528,1,""],[529,2],[530,1,""],[531,2],[532,1,""],[533,2],[534,1,""],[535,2],[536,1,""],[537,2],[538,1,""],[539,2],[540,1,""],[541,2],[542,1,""],[543,2],[544,1,""],[545,2],[546,1,""],[547,2],[548,1,""],[549,2],[550,1,""],[551,2],[552,1,""],[553,2],[554,1,""],[555,2],[556,1,""],[557,2],[558,1,""],[559,2],[560,1,""],[561,2],[562,1,""],[563,2],[[564,566],2],[[567,569],2],[570,1,""],[571,1,""],[572,2],[573,1,""],[574,1,""],[[575,576],2],[577,1,""],[578,2],[579,1,""],[580,1,""],[581,1,""],[582,1,""],[583,2],[584,1,""],[585,2],[586,1,""],[587,2],[588,1,""],[589,2],[590,1,""],[591,2],[[592,680],2],[[681,685],2],[[686,687],2],[688,1,"h"],[689,1,""],[690,1,"j"],[691,1,"r"],[692,1,""],[693,1,""],[694,1,""],[695,1,"w"],[696,1,"y"],[[697,705],2],[[706,709],2],[[710,721],2],[[722,727],2],[728,1," "],[729,1," "],[730,1," "],[731,1," "],[732,1," "],[733,1," "],[734,2],[735,2],[736,1,""],[737,1,"l"],[738,1,"s"],[739,1,"x"],[740,1,""],[[741,745],2],[[746,747],2],[748,2],[749,2],[750,2],[[751,767],2],[[768,831],2],[832,1,""],[833,1,""],[834,2],[835,1,""],[836,1,""],[837,1,""],[[838,846],2],[847,7],[[848,855],2],[[856,860],2],[[861,863],2],[[864,865],2],[866,2],[[867,879],2],[880,1,""],[881,2],[882,1,""],[883,2],[884,1,""],[885,2],[886,1,""],[887,2],[[888,889],3],[890,1," "],[[891,893],2],[894,1,";"],[895,1,""],[[896,899],3],[900,1," "],[901,1," "],[902,1,""],[903,1,""],[904,1,""],[905,1,""],[906,1,""],[907,3],[908,1,""],[909,3],[910,1,""],[911,1,""],[912,2],[913,1,""],[914,1,""],[915,1,""],[916,1,""],[917,1,""],[918,1,""],[919,1,""],[920,1,""],[921,1,""],[922,1,""],[923,1,""],[924,1,""],[925,1,""],[926,1,""],[927,1,""],[928,1,""],[929,1,""],[930,3],[931,1,""],[932,1,""],[933,1,""],[934,1,""],[935,1,""],[936,1,""],[937,1,""],[938,1,""],[939,1,""],[[940,961],2],[962,6,""],[[963,974],2],[975,1,""],[976,1,""],[977,1,""],[978,1,""],[979,1,""],[980,1,""],[981,1,""],[982,1,""],[983,2],[984,1,""],[985,2],[986,1,""],[987,2],[988,1,""],[989,2],[990,1,""],[991,2],[992,1,""],[993,2],[994,1,""],[995,2],[996,1,""],[997,2],[998,1,""],[999,2],[1000,1,""],[1001,2],[1002,1,""],[1003,2],[1004,1,""],[1005,2],[1006,1,""],[1007,2],[1008,1,""],[1009,1,""],[1010,1,""],[1011,2],[1012,1,""],[1013,1,""],[1014,2],[1015,1,""],[1016,2],[1017,1,""],[1018,1,""],[1019,2],[1020,2],[1021,1,""],[1022,1,""],[1023,1,""],[1024,1,""],[1025,1,""],[1026,1,""],[1027,1,""],[1028,1,""],[1029,1,""],[1030,1,""],[1031,1,""],[1032,1,""],[1033,1,""],[1034,1,""],[1035,1,""],[1036,1,""],[1037,1,""],[1038,1,""],[1039,1,""],[1040,1,""],[1041,1,""],[1042,1,""],[1043,1,""],[1044,1,""],[1045,1,""],[1046,1,""],[1047,1,""],[1048,1,""],[1049,1,""],[1050,1,""],[1051,1,""],[1052,1,""],[1053,1,""],[1054,1,""],[1055,1,""],[1056,1,""],[1057,1,""],[1058,1,""],[1059,1,""],[1060,1,""],[1061,1,""],[1062,1,""],[1063,1,""],[1064,1,""],[1065,1,""],[1066,1,""],[1067,1,""],[1068,1,""],[1069,1,""],[1070,1,""],[1071,1,""],[[1072,1103],2],[1104,2],[[1105,1116],2],[1117,2],[[1118,1119],2],[1120,1,""],[1121,2],[1122,1,""],[1123,2],[1124,1,""],[1125,2],[1126,1,""],[1127,2],[1128,1,""],[1129,2],[1130,1,""],[1131,2],[1132,1,""],[1133,2],[1134,1,""],[1135,2],[1136,1,""],[1137,2],[1138,1,""],[1139,2],[1140,1,""],[1141,2],[1142,1,""],[1143,2],[1144,1,""],[1145,2],[1146,1,""],[1147,2],[1148,1,""],[1149,2],[1150,1,""],[1151,2],[1152,1,""],[1153,2],[1154,2],[[1155,1158],2],[1159,2],[[1160,1161],2],[1162,1,""],[1163,2],[1164,1,""],[1165,2],[1166,1,""],[1167,2],[1168,1,""],[1169,2],[1170,1,""],[1171,2],[1172,1,""],[1173,2],[1174,1,""],[1175,2],[1176,1,""],[1177,2],[1178,1,""],[1179,2],[1180,1,""],[1181,2],[1182,1,""],[1183,2],[1184,1,""],[1185,2],[1186,1,""],[1187,2],[1188,1,""],[1189,2],[1190,1,""],[1191,2],[1192,1,""],[1193,2],[1194,1,""],[1195,2],[1196,1,""],[1197,2],[1198,1,""],[1199,2],[1200,1,""],[1201,2],[1202,1,""],[1203,2],[1204,1,""],[1205,2],[1206,1,""],[1207,2],[1208,1,""],[1209,2],[1210,1,""],[1211,2],[1212,1,""],[1213,2],[1214,1,""],[1215,2],[1216,1,""],[1217,1,""],[1218,2],[1219,1,""],[1220,2],[1221,1,""],[1222,2],[1223,1,""],[1224,2],[1225,1,""],[1226,2],[1227,1,""],[1228,2],[1229,1,""],[1230,2],[1231,2],[1232,1,""],[1233,2],[1234,1,""],[1235,2],[1236,1,""],[1237,2],[1238,1,""],[1239,2],[1240,1,""],[1241,2],[1242,1,""],[1243,2],[1244,1,""],[1245,2],[1246,1,""],[1247,2],[1248,1,""],[1249,2],[1250,1,""],[1251,2],[1252,1,""],[1253,2],[1254,1,""],[1255,2],[1256,1,""],[1257,2],[1258,1,""],[1259,2],[1260,1,""],[1261,2],[1262,1,""],[1263,2],[1264,1,""],[1265,2],[1266,1,""],[1267,2],[1268,1,""],[1269,2],[1270,1,""],[1271,2],[1272,1,""],[1273,2],[1274,1,""],[1275,2],[1276,1,""],[1277,2],[1278,1,""],[1279,2],[1280,1,""],[1281,2],[1282,1,""],[1283,2],[1284,1,""],[1285,2],[1286,1,""],[1287,2],[1288,1,""],[1289,2],[1290,1,""],[1291,2],[1292,1,""],[1293,2],[1294,1,""],[1295,2],[1296,1,""],[1297,2],[1298,1,""],[1299,2],[1300,1,""],[1301,2],[1302,1,""],[1303,2],[1304,1,""],[1305,2],[1306,1,""],[1307,2],[1308,1,""],[1309,2],[1310,1,""],[1311,2],[1312,1,""],[1313,2],[1314,1,""],[1315,2],[1316,1,""],[1317,2],[1318,1,""],[1319,2],[1320,1,""],[1321,2],[1322,1,""],[1323,2],[1324,1,""],[1325,2],[1326,1,""],[1327,2],[1328,3],[1329,1,""],[1330,1,""],[1331,1,""],[1332,1,""],[1333,1,""],[1334,1,""],[1335,1,""],[1336,1,""],[1337,1,""],[1338,1,""],[1339,1,""],[1340,1,""],[1341,1,""],[1342,1,""],[1343,1,""],[1344,1,""],[1345,1,""],[1346,1,""],[1347,1,""],[1348,1,""],[1349,1,""],[1350,1,""],[1351,1,""],[1352,1,""],[1353,1,""],[1354,1,""],[1355,1,""],[1356,1,""],[1357,1,""],[1358,1,""],[1359,1,""],[1360,1,""],[1361,1,""],[1362,1,""],[1363,1,""],[1364,1,""],[1365,1,""],[1366,1,""],[[1367,1368],3],[1369,2],[[1370,1375],2],[1376,2],[[1377,1414],2],[1415,1,""],[1416,2],[1417,2],[1418,2],[[1419,1420],3],[[1421,1422],2],[1423,2],[1424,3],[[1425,1441],2],[1442,2],[[1443,1455],2],[[1456,1465],2],[1466,2],[[1467,1469],2],[1470,2],[1471,2],[1472,2],[[1473,1474],2],[1475,2],[1476,2],[1477,2],[1478,2],[1479,2],[[1480,1487],3],[[1488,1514],2],[[1515,1518],3],[1519,2],[[1520,1524],2],[[1525,1535],3],[[1536,1539],3],[1540,3],[1541,3],[[1542,1546],2],[1547,2],[1548,2],[[1549,1551],2],[[1552,1557],2],[[1558,1562],2],[1563,2],[1564,3],[1565,2],[1566,2],[1567,2],[1568,2],[[1569,1594],2],[[1595,1599],2],[1600,2],[[1601,1618],2],[[1619,1621],2],[[1622,1624],2],[[1625,1630],2],[1631,2],[[1632,1641],2],[[1642,1645],2],[[1646,1647],2],[[1648,1652],2],[1653,1,""],[1654,1,""],[1655,1,""],[1656,1,""],[[1657,1719],2],[[1720,1721],2],[[1722,1726],2],[1727,2],[[1728,1742],2],[1743,2],[[1744,1747],2],[1748,2],[[1749,1756],2],[1757,3],[1758,2],[[1759,1768],2],[1769,2],[[1770,1773],2],[[1774,1775],2],[[1776,1785],2],[[1786,1790],2],[1791,2],[[1792,1805],2],[1806,3],[1807,3],[[1808,1836],2],[[1837,1839],2],[[1840,1866],2],[[1867,1868],3],[[1869,1871],2],[[1872,1901],2],[[1902,1919],2],[[1920,1968],2],[1969,2],[[1970,1983],3],[[1984,2037],2],[[2038,2042],2],[[2043,2044],3],[2045,2],[[2046,2047],2],[[2048,2093],2],[[2094,2095],3],[[2096,2110],2],[2111,3],[[2112,2139],2],[[2140,2141],3],[2142,2],[2143,3],[[2144,2154],2],[[2155,2159],3],[[2160,2183],2],[2184,2],[[2185,2190],2],[2191,3],[[2192,2193],3],[[2194,2198],3],[2199,2],[[2200,2207],2],[2208,2],[2209,2],[[2210,2220],2],[[2221,2226],2],[[2227,2228],2],[2229,2],[[2230,2237],2],[[2238,2247],2],[[2248,2258],2],[2259,2],[[2260,2273],2],[2274,3],[2275,2],[[2276,2302],2],[2303,2],[2304,2],[[2305,2307],2],[2308,2],[[2309,2361],2],[[2362,2363],2],[[2364,2381],2],[2382,2],[2383,2],[[2384,2388],2],[2389,2],[[2390,2391],2],[2392,1,""],[2393,1,""],[2394,1,""],[2395,1,""],[2396,1,""],[2397,1,""],[2398,1,""],[2399,1,""],[[2400,2403],2],[[2404,2405],2],[[2406,2415],2],[2416,2],[[2417,2418],2],[[2419,2423],2],[2424,2],[[2425,2426],2],[[2427,2428],2],[2429,2],[[2430,2431],2],[2432,2],[[2433,2435],2],[2436,3],[[2437,2444],2],[[2445,2446],3],[[2447,2448],2],[[2449,2450],3],[[2451,2472],2],[2473,3],[[2474,2480],2],[2481,3],[2482,2],[[2483,2485],3],[[2486,2489],2],[[2490,2491],3],[2492,2],[2493,2],[[2494,2500],2],[[2501,2502],3],[[2503,2504],2],[[2505,2506],3],[[2507,2509],2],[2510,2],[[2511,2518],3],[2519,2],[[2520,2523],3],[2524,1,""],[2525,1,""],[2526,3],[2527,1,""],[[2528,2531],2],[[2532,2533],3],[[2534,2545],2],[[2546,2554],2],[2555,2],[2556,2],[2557,2],[2558,2],[[2559,2560],3],[2561,2],[2562,2],[2563,2],[2564,3],[[2565,2570],2],[[2571,2574],3],[[2575,2576],2],[[2577,2578],3],[[2579,2600],2],[2601,3],[[2602,2608],2],[2609,3],[2610,2],[2611,1,""],[2612,3],[2613,2],[2614,1,""],[2615,3],[[2616,2617],2],[[2618,2619],3],[2620,2],[2621,3],[[2622,2626],2],[[2627,2630],3],[[2631,2632],2],[[2633,2634],3],[[2635,2637],2],[[2638,2640],3],[2641,2],[[2642,2648],3],[2649,1,""],[2650,1,""],[2651,1,""],[2652,2],[2653,3],[2654,1,""],[[2655,2661],3],[[2662,2676],2],[2677,2],[2678,2],[[2679,2688],3],[[2689,2691],2],[2692,3],[[2693,2699],2],[2700,2],[2701,2],[2702,3],[[2703,2705],2],[2706,3],[[2707,2728],2],[2729,3],[[2730,2736],2],[2737,3],[[2738,2739],2],[2740,3],[[2741,2745],2],[[2746,2747],3],[[2748,2757],2],[2758,3],[[2759,2761],2],[2762,3],[[2763,2765],2],[[2766,2767],3],[2768,2],[[2769,2783],3],[2784,2],[[2785,2787],2],[[2788,2789],3],[[2790,2799],2],[2800,2],[2801,2],[[2802,2808],3],[2809,2],[[2810,2815],2],[2816,3],[[2817,2819],2],[2820,3],[[2821,2828],2],[[2829,2830],3],[[2831,2832],2],[[2833,2834],3],[[2835,2856],2],[2857,3],[[2858,2864],2],[2865,3],[[2866,2867],2],[2868,3],[2869,2],[[2870,2873],2],[[2874,2875],3],[[2876,2883],2],[2884,2],[[2885,2886],3],[[2887,2888],2],[[2889,2890],3],[[2891,2893],2],[[2894,2900],3],[2901,2],[[2902,2903],2],[[2904,2907],3],[2908,1,""],[2909,1,""],[2910,3],[[2911,2913],2],[[2914,2915],2],[[2916,2917],3],[[2918,2927],2],[2928,2],[2929,2],[[2930,2935],2],[[2936,2945],3],[[2946,2947],2],[2948,3],[[2949,2954],2],[[2955,2957],3],[[2958,2960],2],[2961,3],[[2962,2965],2],[[2966,2968],3],[[2969,2970],2],[2971,3],[2972,2],[2973,3],[[2974,2975],2],[[2976,2978],3],[[2979,2980],2],[[2981,2983],3],[[2984,2986],2],[[2987,2989],3],[[2990,2997],2],[2998,2],[[2999,3001],2],[[3002,3005],3],[[3006,3010],2],[[3011,3013],3],[[3014,3016],2],[3017,3],[[3018,3021],2],[[3022,3023],3],[3024,2],[[3025,3030],3],[3031,2],[[3032,3045],3],[3046,2],[[3047,3055],2],[[3056,3058],2],[[3059,3066],2],[[3067,3071],3],[3072,2],[[3073,3075],2],[3076,2],[[3077,3084],2],[3085,3],[[3086,3088],2],[3089,3],[[3090,3112],2],[3113,3],[[3114,3123],2],[3124,2],[[3125,3129],2],[[3130,3131],3],[3132,2],[3133,2],[[3134,3140],2],[3141,3],[[3142,3144],2],[3145,3],[[3146,3149],2],[[3150,3156],3],[[3157,3158],2],[3159,3],[[3160,3161],2],[3162,2],[[3163,3164],3],[3165,2],[[3166,3167],3],[[3168,3169],2],[[3170,3171],2],[[3172,3173],3],[[3174,3183],2],[[3184,3190],3],[3191,2],[[3192,3199],2],[3200,2],[3201,2],[[3202,3203],2],[3204,2],[[3205,3212],2],[3213,3],[[3214,3216],2],[3217,3],[[3218,3240],2],[3241,3],[[3242,3251],2],[3252,3],[[3253,3257],2],[[3258,3259],3],[[3260,3261],2],[[3262,3268],2],[3269,3],[[3270,3272],2],[3273,3],[[3274,3277],2],[[3278,3284],3],[[3285,3286],2],[[3287,3292],3],[3293,2],[3294,2],[3295,3],[[3296,3297],2],[[3298,3299],2],[[3300,3301],3],[[3302,3311],2],[3312,3],[[3313,3314],2],[3315,2],[[3316,3327],3],[3328,2],[3329,2],[[3330,3331],2],[3332,2],[[3333,3340],2],[3341,3],[[3342,3344],2],[3345,3],[[3346,3368],2],[3369,2],[[3370,3385],2],[3386,2],[[3387,3388],2],[3389,2],[[3390,3395],2],[3396,2],[3397,3],[[3398,3400],2],[3401,3],[[3402,3405],2],[3406,2],[3407,2],[[3408,3411],3],[[3412,3414],2],[3415,2],[[3416,3422],2],[3423,2],[[3424,3425],2],[[3426,3427],2],[[3428,3429],3],[[3430,3439],2],[[3440,3445],2],[[3446,3448],2],[3449,2],[[3450,3455],2],[3456,3],[3457,2],[[3458,3459],2],[3460,3],[[3461,3478],2],[[3479,3481],3],[[3482,3505],2],[3506,3],[[3507,3515],2],[3516,3],[3517,2],[[3518,3519],3],[[3520,3526],2],[[3527,3529],3],[3530,2],[[3531,3534],3],[[3535,3540],2],[3541,3],[3542,2],[3543,3],[[3544,3551],2],[[3552,3557],3],[[3558,3567],2],[[3568,3569],3],[[3570,3571],2],[3572,2],[[3573,3584],3],[[3585,3634],2],[3635,1,""],[[3636,3642],2],[[3643,3646],3],[3647,2],[[3648,3662],2],[3663,2],[[3664,3673],2],[[3674,3675],2],[[3676,3712],3],[[3713,3714],2],[3715,3],[3716,2],[3717,3],[3718,2],[[3719,3720],2],[3721,2],[3722,2],[3723,3],[3724,2],[3725,2],[[3726,3731],2],[[3732,3735],2],[3736,2],[[3737,3743],2],[3744,2],[[3745,3747],2],[3748,3],[3749,2],[3750,3],[3751,2],[[3752,3753],2],[[3754,3755],2],[3756,2],[[3757,3762],2],[3763,1,""],[[3764,3769],2],[3770,2],[[3771,3773],2],[[3774,3775],3],[[3776,3780],2],[3781,3],[3782,2],[3783,3],[[3784,3789],2],[3790,2],[3791,3],[[3792,3801],2],[[3802,3803],3],[3804,1,""],[3805,1,""],[[3806,3807],2],[[3808,3839],3],[3840,2],[[3841,3850],2],[3851,2],[3852,1,""],[[3853,3863],2],[[3864,3865],2],[[3866,3871],2],[[3872,3881],2],[[3882,3892],2],[3893,2],[3894,2],[3895,2],[3896,2],[3897,2],[[3898,3901],2],[[3902,3906],2],[3907,1,""],[[3908,3911],2],[3912,3],[[3913,3916],2],[3917,1,""],[[3918,3921],2],[3922,1,""],[[3923,3926],2],[3927,1,""],[[3928,3931],2],[3932,1,""],[[3933,3944],2],[3945,1,""],[3946,2],[[3947,3948],2],[[3949,3952],3],[[3953,3954],2],[3955,1,""],[3956,2],[3957,1,""],[3958,1,""],[3959,1,""],[3960,1,""],[3961,1,""],[[3962,3968],2],[3969,1,""],[[3970,3972],2],[3973,2],[[3974,3979],2],[[3980,3983],2],[[3984,3986],2],[3987,1,""],[[3988,3989],2],[3990,2],[3991,2],[3992,3],[[3993,3996],2],[3997,1,""],[[3998,4001],2],[4002,1,""],[[4003,4006],2],[4007,1,""],[[4008,4011],2],[4012,1,""],[4013,2],[[4014,4016],2],[[4017,4023],2],[4024,2],[4025,1,""],[[4026,4028],2],[4029,3],[[4030,4037],2],[4038,2],[[4039,4044],2],[4045,3],[4046,2],[4047,2],[[4048,4049],2],[[4050,4052],2],[[4053,4056],2],[[4057,4058],2],[[4059,4095],3],[[4096,4129],2],[4130,2],[[4131,4135],2],[4136,2],[[4137,4138],2],[4139,2],[[4140,4146],2],[[4147,4149],2],[[4150,4153],2],[[4154,4159],2],[[4160,4169],2],[[4170,4175],2],[[4176,4185],2],[[4186,4249],2],[[4250,4253],2],[[4254,4255],2],[4256,1,""],[4257,1,""],[4258,1,""],[4259,1,""],[4260,1,""],[4261,1,""],[4262,1,""],[4263,1,""],[4264,1,""],[4265,1,""],[4266,1,""],[4267,1,""],[4268,1,""],[4269,1,""],[4270,1,""],[4271,1,""],[4272,1,""],[4273,1,""],[4274,1,""],[4275,1,""],[4276,1,""],[4277,1,""],[4278,1,""],[4279,1,""],[4280,1,""],[4281,1,""],[4282,1,""],[4283,1,""],[4284,1,""],[4285,1,""],[4286,1,""],[4287,1,""],[4288,1,""],[4289,1,""],[4290,1,""],[4291,1,""],[4292,1,""],[4293,1,""],[4294,3],[4295,1,""],[[4296,4300],3],[4301,1,""],[[4302,4303],3],[[4304,4342],2],[[4343,4344],2],[[4345,4346],2],[4347,2],[4348,1,""],[[4349,4351],2],[[4352,4441],2],[[4442,4446],2],[[4447,4448],7],[[4449,4514],2],[[4515,4519],2],[[4520,4601],2],[[4602,4607],2],[[4608,4614],2],[4615,2],[[4616,4678],2],[4679,2],[4680,2],[4681,3],[[4682,4685],2],[[4686,4687],3],[[4688,4694],2],[4695,3],[4696,2],[4697,3],[[4698,4701],2],[[4702,4703],3],[[4704,4742],2],[4743,2],[4744,2],[4745,3],[[4746,4749],2],[[4750,4751],3],[[4752,4782],2],[4783,2],[4784,2],[4785,3],[[4786,4789],2],[[4790,4791],3],[[4792,4798],2],[4799,3],[4800,2],[4801,3],[[4802,4805],2],[[4806,4807],3],[[4808,4814],2],[4815,2],[[4816,4822],2],[4823,3],[[4824,4846],2],[4847,2],[[4848,4878],2],[4879,2],[4880,2],[4881,3],[[4882,4885],2],[[4886,4887],3],[[4888,4894],2],[4895,2],[[4896,4934],2],[4935,2],[[4936,4954],2],[[4955,4956],3],[[4957,4958],2],[4959,2],[4960,2],[[4961,4988],2],[[4989,4991],3],[[4992,5007],2],[[5008,5017],2],[[5018,5023],3],[[5024,5108],2],[5109,2],[[5110,5111],3],[5112,1,""],[5113,1,""],[5114,1,""],[5115,1,""],[5116,1,""],[5117,1,""],[[5118,5119],3],[5120,2],[[5121,5740],2],[[5741,5742],2],[[5743,5750],2],[[5751,5759],2],[5760,3],[[5761,5786],2],[[5787,5788],2],[[5789,5791],3],[[5792,5866],2],[[5867,5872],2],[[5873,5880],2],[[5881,5887],3],[[5888,5900],2],[5901,2],[[5902,5908],2],[5909,2],[[5910,5918],3],[5919,2],[[5920,5940],2],[[5941,5942],2],[[5943,5951],3],[[5952,5971],2],[[5972,5983],3],[[5984,5996],2],[5997,3],[[5998,6000],2],[6001,3],[[6002,6003],2],[[6004,6015],3],[[6016,6067],2],[[6068,6069],7],[[6070,6099],2],[[6100,6102],2],[6103,2],[[6104,6107],2],[6108,2],[6109,2],[[6110,6111],3],[[6112,6121],2],[[6122,6127],3],[[6128,6137],2],[[6138,6143],3],[[6144,6154],2],[[6155,6158],7],[6159,7],[[6160,6169],2],[[6170,6175],3],[[6176,6263],2],[6264,2],[[6265,6271],3],[[6272,6313],2],[6314,2],[[6315,6319],3],[[6320,6389],2],[[6390,6399],3],[[6400,6428],2],[[6429,6430],2],[6431,3],[[6432,6443],2],[[6444,6447],3],[[6448,6459],2],[[6460,6463],3],[6464,2],[[6465,6467],3],[[6468,6469],2],[[6470,6509],2],[[6510,6511],3],[[6512,6516],2],[[6517,6527],3],[[6528,6569],2],[[6570,6571],2],[[6572,6575],3],[[6576,6601],2],[[6602,6607],3],[[6608,6617],2],[6618,2],[[6619,6621],3],[[6622,6623],2],[[6624,6655],2],[[6656,6683],2],[[6684,6685],3],[[6686,6687],2],[[6688,6750],2],[6751,3],[[6752,6780],2],[[6781,6782],3],[[6783,6793],2],[[6794,6799],3],[[6800,6809],2],[[6810,6815],3],[[6816,6822],2],[6823,2],[[6824,6829],2],[[6830,6831],3],[[6832,6845],2],[6846,2],[[6847,6848],2],[[6849,6862],2],[[6863,6911],3],[[6912,6987],2],[6988,2],[6989,3],[[6990,6991],2],[[6992,7001],2],[[7002,7018],2],[[7019,7027],2],[[7028,7036],2],[[7037,7038],2],[7039,2],[[7040,7082],2],[[7083,7085],2],[[7086,7097],2],[[7098,7103],2],[[7104,7155],2],[[7156,7163],3],[[7164,7167],2],[[7168,7223],2],[[7224,7226],3],[[7227,7231],2],[[7232,7241],2],[[7242,7244],3],[[7245,7293],2],[[7294,7295],2],[7296,1,""],[7297,1,""],[7298,1,""],[7299,1,""],[[7300,7301],1,""],[7302,1,""],[7303,1,""],[7304,1,""],[7305,1,""],[7306,2],[[7307,7311],3],[7312,1,""],[7313,1,""],[7314,1,""],[7315,1,""],[7316,1,""],[7317,1,""],[7318,1,""],[7319,1,""],[7320,1,""],[7321,1,""],[7322,1,""],[7323,1,""],[7324,1,""],[7325,1,""],[7326,1,""],[7327,1,""],[7328,1,""],[7329,1,""],[7330,1,""],[7331,1,""],[7332,1,""],[7333,1,""],[7334,1,""],[7335,1,""],[7336,1,""],[7337,1,""],[7338,1,""],[7339,1,""],[7340,1,""],[7341,1,""],[7342,1,""],[7343,1,""],[7344,1,""],[7345,1,""],[7346,1,""],[7347,1,""],[7348,1,""],[7349,1,""],[7350,1,""],[7351,1,""],[7352,1,""],[7353,1,""],[7354,1,""],[[7355,7356],3],[7357,1,""],[7358,1,""],[7359,1,""],[[7360,7367],2],[[7368,7375],3],[[7376,7378],2],[7379,2],[[7380,7410],2],[[7411,7414],2],[7415,2],[[7416,7417],2],[7418,2],[[7419,7423],3],[[7424,7467],2],[7468,1,"a"],[7469,1,""],[7470,1,"b"],[7471,2],[7472,1,"d"],[7473,1,"e"],[7474,1,""],[7475,1,"g"],[7476,1,"h"],[7477,1,"i"],[7478,1,"j"],[7479,1,"k"],[7480,1,"l"],[7481,1,"m"],[7482,1,"n"],[7483,2],[7484,1,"o"],[7485,1,""],[7486,1,"p"],[7487,1,"r"],[7488,1,"t"],[7489,1,"u"],[7490,1,"w"],[7491,1,"a"],[7492,1,""],[7493,1,""],[7494,1,""],[7495,1,"b"],[7496,1,"d"],[7497,1,"e"],[7498,1,""],[7499,1,""],[7500,1,""],[7501,1,"g"],[7502,2],[7503,1,"k"],[7504,1,"m"],[7505,1,""],[7506,1,"o"],[7507,1,""],[7508,1,""],[7509,1,""],[7510,1,"p"],[7511,1,"t"],[7512,1,"u"],[7513,1,""],[7514,1,""],[7515,1,"v"],[7516,1,""],[7517,1,""],[7518,1,""],[7519,1,""],[7520,1,""],[7521,1,""],[7522,1,"i"],[7523,1,"r"],[7524,1,"u"],[7525,1,"v"],[7526,1,""],[7527,1,""],[7528,1,""],[7529,1,""],[7530,1,""],[7531,2],[[7532,7543],2],[7544,1,""],[[7545,7578],2],[7579,1,""],[7580,1,"c"],[7581,1,""],[7582,1,""],[7583,1,""],[7584,1,"f"],[7585,1,""],[7586,1,""],[7587,1,""],[7588,1,""],[7589,1,""],[7590,1,""],[7591,1,""],[7592,1,""],[7593,1,""],[7594,1,""],[7595,1,""],[7596,1,""],[7597,1,""],[7598,1,""],[7599,1,""],[7600,1,""],[7601,1,""],[7602,1,""],[7603,1,""],[7604,1,""],[7605,1,""],[7606,1,""],[7607,1,""],[7608,1,""],[7609,1,""],[7610,1,""],[7611,1,"z"],[7612,1,""],[7613,1,""],[7614,1,""],[7615,1,""],[[7616,7619],2],[[7620,7626],2],[[7627,7654],2],[[7655,7669],2],[[7670,7673],2],[7674,2],[7675,2],[7676,2],[7677,2],[[7678,7679],2],[7680,1,""],[7681,2],[7682,1,""],[7683,2],[7684,1,""],[7685,2],[7686,1,""],[7687,2],[7688,1,""],[7689,2],[7690,1,""],[7691,2],[7692,1,""],[7693,2],[7694,1,""],[7695,2],[7696,1,""],[7697,2],[7698,1,""],[7699,2],[7700,1,""],[7701,2],[7702,1,""],[7703,2],[7704,1,""],[7705,2],[7706,1,""],[7707,2],[7708,1,""],[7709,2],[7710,1,""],[7711,2],[7712,1,""],[7713,2],[7714,1,""],[7715,2],[7716,1,""],[7717,2],[7718,1,""],[7719,2],[7720,1,""],[7721,2],[7722,1,""],[7723,2],[7724,1,""],[7725,2],[7726,1,""],[7727,2],[7728,1,""],[7729,2],[7730,1,""],[7731,2],[7732,1,""],[7733,2],[7734,1,""],[7735,2],[7736,1,""],[7737,2],[7738,1,""],[7739,2],[7740,1,""],[7741,2],[7742,1,""],[7743,2],[7744,1,""],[7745,2],[7746,1,""],[7747,2],[7748,1,""],[7749,2],[7750,1,""],[7751,2],[7752,1,""],[7753,2],[7754,1,""],[7755,2],[7756,1,""],[7757,2],[7758,1,""],[7759,2],[7760,1,""],[7761,2],[7762,1,""],[7763,2],[7764,1,""],[7765,2],[7766,1,""],[7767,2],[7768,1,""],[7769,2],[7770,1,""],[7771,2],[7772,1,""],[7773,2],[7774,1,""],[7775,2],[7776,1,""],[7777,2],[7778,1,""],[7779,2],[7780,1,""],[7781,2],[7782,1,""],[7783,2],[7784,1,""],[7785,2],[7786,1,""],[7787,2],[7788,1,""],[7789,2],[7790,1,""],[7791,2],[7792,1,""],[7793,2],[7794,1,""],[7795,2],[7796,1,""],[7797,2],[7798,1,""],[7799,2],[7800,1,""],[7801,2],[7802,1,""],[7803,2],[7804,1,""],[7805,2],[7806,1,""],[7807,2],[7808,1,""],[7809,2],[7810,1,""],[7811,2],[7812,1,""],[7813,2],[7814,1,""],[7815,2],[7816,1,""],[7817,2],[7818,1,""],[7819,2],[7820,1,""],[7821,2],[7822,1,""],[7823,2],[7824,1,""],[7825,2],[7826,1,""],[7827,2],[7828,1,""],[[7829,7833],2],[7834,1,"a"],[7835,1,""],[[7836,7837],2],[7838,1,""],[7839,2],[7840,1,""],[7841,2],[7842,1,""],[7843,2],[7844,1,""],[7845,2],[7846,1,""],[7847,2],[7848,1,""],[7849,2],[7850,1,""],[7851,2],[7852,1,""],[7853,2],[7854,1,""],[7855,2],[7856,1,""],[7857,2],[7858,1,""],[7859,2],[7860,1,""],[7861,2],[7862,1,""],[7863,2],[7864,1,""],[7865,2],[7866,1,""],[7867,2],[7868,1,""],[7869,2],[7870,1,""],[7871,2],[7872,1,""],[7873,2],[7874,1,""],[7875,2],[7876,1,""],[7877,2],[7878,1,""],[7879,2],[7880,1,""],[7881,2],[7882,1,""],[7883,2],[7884,1,""],[7885,2],[7886,1,""],[7887,2],[7888,1,""],[7889,2],[7890,1,""],[7891,2],[7892,1,""],[7893,2],[7894,1,""],[7895,2],[7896,1,""],[7897,2],[7898,1,""],[7899,2],[7900,1,""],[7901,2],[7902,1,""],[7903,2],[7904,1,""],[7905,2],[7906,1,""],[7907,2],[7908,1,""],[7909,2],[7910,1,""],[7911,2],[7912,1,""],[7913,2],[7914,1,""],[7915,2],[7916,1,""],[7917,2],[7918,1,""],[7919,2],[7920,1,""],[7921,2],[7922,1,""],[7923,2],[7924,1,""],[7925,2],[7926,1,""],[7927,2],[7928,1,""],[7929,2],[7930,1,""],[7931,2],[7932,1,""],[7933,2],[7934,1,""],[7935,2],[[7936,7943],2],[7944,1,""],[7945,1,""],[7946,1,""],[7947,1,""],[7948,1,""],[7949,1,""],[7950,1,""],[7951,1,""],[[7952,7957],2],[[7958,7959],3],[7960,1,""],[7961,1,""],[7962,1,""],[7963,1,""],[7964,1,""],[7965,1,""],[[7966,7967],3],[[7968,7975],2],[7976,1,""],[7977,1,""],[7978,1,""],[7979,1,""],[7980,1,""],[7981,1,""],[7982,1,""],[7983,1,""],[[7984,7991],2],[7992,1,""],[7993,1,""],[7994,1,""],[7995,1,""],[7996,1,""],[7997,1,""],[7998,1,""],[7999,1,""],[[8000,8005],2],[[8006,8007],3],[8008,1,""],[8009,1,""],[8010,1,""],[8011,1,""],[8012,1,""],[8013,1,""],[[8014,8015],3],[[8016,8023],2],[8024,3],[8025,1,""],[8026,3],[8027,1,""],[8028,3],[8029,1,""],[8030,3],[8031,1,""],[[8032,8039],2],[8040,1,""],[8041,1,""],[8042,1,""],[8043,1,""],[8044,1,""],[8045,1,""],[8046,1,""],[8047,1,""],[8048,2],[8049,1,""],[8050,2],[8051,1,""],[8052,2],[8053,1,""],[8054,2],[8055,1,""],[8056,2],[8057,1,""],[8058,2],[8059,1,""],[8060,2],[8061,1,""],[[8062,8063],3],[8064,1,""],[8065,1,""],[8066,1,""],[8067,1,""],[8068,1,""],[8069,1,""],[8070,1,""],[8071,1,""],[8072,1,""],[8073,1,""],[8074,1,""],[8075,1,""],[8076,1,""],[8077,1,""],[8078,1,""],[8079,1,""],[8080,1,""],[8081,1,""],[8082,1,""],[8083,1,""],[8084,1,""],[8085,1,""],[8086,1,""],[8087,1,""],[8088,1,""],[8089,1,""],[8090,1,""],[8091,1,""],[8092,1,""],[8093,1,""],[8094,1,""],[8095,1,""],[8096,1,""],[8097,1,""],[8098,1,""],[8099,1,""],[8100,1,""],[8101,1,""],[8102,1,""],[8103,1,""],[8104,1,""],[8105,1,""],[8106,1,""],[8107,1,""],[8108,1,""],[8109,1,""],[8110,1,""],[8111,1,""],[[8112,8113],2],[8114,1,""],[8115,1,""],[8116,1,""],[8117,3],[8118,2],[8119,1,""],[8120,1,""],[8121,1,""],[8122,1,""],[8123,1,""],[8124,1,""],[8125,1," "],[8126,1,""],[8127,1," "],[8128,1," "],[8129,1," "],[8130,1,""],[8131,1,""],[8132,1,""],[8133,3],[8134,2],[8135,1,""],[8136,1,""],[8137,1,""],[8138,1,""],[8139,1,""],[8140,1,""],[8141,1," "],[8142,1," "],[8143,1," "],[[8144,8146],2],[8147,1,""],[[8148,8149],3],[[8150,8151],2],[8152,1,""],[8153,1,""],[8154,1,""],[8155,1,""],[8156,3],[8157,1," "],[8158,1," "],[8159,1," "],[[8160,8162],2],[8163,1,""],[[8164,8167],2],[8168,1,""],[8169,1,""],[8170,1,""],[8171,1,""],[8172,1,""],[8173,1," "],[8174,1," "],[8175,1,"`"],[[8176,8177],3],[8178,1,""],[8179,1,""],[8180,1,""],[8181,3],[8182,2],[8183,1,""],[8184,1,""],[8185,1,""],[8186,1,""],[8187,1,""],[8188,1,""],[8189,1," "],[8190,1," "],[8191,3],[[8192,8202],1," "],[8203,7],[[8204,8205],6,""],[[8206,8207],3],[8208,2],[8209,1,""],[[8210,8214],2],[8215,1," "],[[8216,8227],2],[[8228,8230],3],[8231,2],[[8232,8238],3],[8239,1," "],[[8240,8242],2],[8243,1,""],[8244,1,""],[8245,2],[8246,1,""],[8247,1,""],[[8248,8251],2],[8252,1,"!!"],[8253,2],[8254,1," "],[[8255,8262],2],[8263,1,"??"],[8264,1,"?!"],[8265,1,"!?"],[[8266,8269],2],[[8270,8274],2],[[8275,8276],2],[[8277,8278],2],[8279,1,""],[[8280,8286],2],[8287,1," "],[[8288,8291],7],[8292,7],[8293,3],[[8294,8297],3],[[8298,8303],7],[8304,1,"0"],[8305,1,"i"],[[8306,8307],3],[8308,1,"4"],[8309,1,"5"],[8310,1,"6"],[8311,1,"7"],[8312,1,"8"],[8313,1,"9"],[8314,1,"+"],[8315,1,""],[8316,1,"="],[8317,1,"("],[8318,1,")"],[8319,1,"n"],[8320,1,"0"],[8321,1,"1"],[8322,1,"2"],[8323,1,"3"],[8324,1,"4"],[8325,1,"5"],[8326,1,"6"],[8327,1,"7"],[8328,1,"8"],[8329,1,"9"],[8330,1,"+"],[8331,1,""],[8332,1,"="],[8333,1,"("],[8334,1,")"],[8335,3],[8336,1,"a"],[8337,1,"e"],[8338,1,"o"],[8339,1,"x"],[8340,1,""],[8341,1,"h"],[8342,1,"k"],[8343,1,"l"],[8344,1,"m"],[8345,1,"n"],[8346,1,"p"],[8347,1,"s"],[8348,1,"t"],[[8349,8351],3],[[8352,8359],2],[8360,1,"rs"],[[8361,8362],2],[8363,2],[8364,2],[[8365,8367],2],[[8368,8369],2],[[8370,8373],2],[[8374,8376],2],[8377,2],[8378,2],[[8379,8381],2],[8382,2],[8383,2],[8384,2],[[8385,8399],3],[[8400,8417],2],[[8418,8419],2],[[8420,8426],2],[8427,2],[[8428,8431],2],[8432,2],[[8433,8447],3],[8448,1,"a/c"],[8449,1,"a/s"],[8450,1,"c"],[8451,1,"c"],[8452,2],[8453,1,"c/o"],[8454,1,"c/u"],[8455,1,""],[8456,2],[8457,1,"f"],[8458,1,"g"],[[8459,8462],1,"h"],[8463,1,""],[[8464,8465],1,"i"],[[8466,8467],1,"l"],[8468,2],[8469,1,"n"],[8470,1,"no"],[[8471,8472],2],[8473,1,"p"],[8474,1,"q"],[[8475,8477],1,"r"],[[8478,8479],2],[8480,1,"sm"],[8481,1,"tel"],[8482,1,"tm"],[8483,2],[8484,1,"z"],[8485,2],[8486,1,""],[8487,2],[8488,1,"z"],[8489,2],[8490,1,"k"],[8491,1,""],[8492,1,"b"],[8493,1,"c"],[8494,2],[[8495,8496],1,"e"],[8497,1,"f"],[8498,1,""],[8499,1,"m"],[8500,1,"o"],[8501,1,""],[8502,1,""],[8503,1,""],[8504,1,""],[8505,1,"i"],[8506,2],[8507,1,"fax"],[8508,1,""],[[8509,8510],1,""],[8511,1,""],[8512,1,""],[[8513,8516],2],[[8517,8518],1,"d"],[8519,1,"e"],[8520,1,"i"],[8521,1,"j"],[[8522,8523],2],[8524,2],[8525,2],[8526,2],[8527,2],[8528,1,"17"],[8529,1,"19"],[8530,1,"110"],[8531,1,"13"],[8532,1,"23"],[8533,1,"15"],[8534,1,"25"],[8535,1,"35"],[8536,1,"45"],[8537,1,"16"],[8538,1,"56"],[8539,1,"18"],[8540,1,"38"],[8541,1,"58"],[8542,1,"78"],[8543,1,"1"],[8544,1,"i"],[8545,1,"ii"],[8546,1,"iii"],[8547,1,"iv"],[8548,1,"v"],[8549,1,"vi"],[8550,1,"vii"],[8551,1,"viii"],[8552,1,"ix"],[8553,1,"x"],[8554,1,"xi"],[8555,1,"xii"],[8556,1,"l"],[8557,1,"c"],[8558,1,"d"],[8559,1,"m"],[8560,1,"i"],[8561,1,"ii"],[8562,1,"iii"],[8563,1,"iv"],[8564,1,"v"],[8565,1,"vi"],[8566,1,"vii"],[8567,1,"viii"],[8568,1,"ix"],[8569,1,"x"],[8570,1,"xi"],[8571,1,"xii"],[8572,1,"l"],[8573,1,"c"],[8574,1,"d"],[8575,1,"m"],[[8576,8578],2],[8579,1,""],[8580,2],[[8581,8584],2],[8585,1,"03"],[[8586,8587],2],[[8588,8591],3],[[8592,8682],2],[[8683,8691],2],[[8692,8703],2],[[8704,8747],2],[8748,1,""],[8749,1,""],[8750,2],[8751,1,""],[8752,1,""],[[8753,8945],2],[[8946,8959],2],[8960,2],[8961,2],[[8962,9000],2],[9001,1,""],[9002,1,""],[[9003,9082],2],[9083,2],[9084,2],[[9085,9114],2],[[9115,9166],2],[[9167,9168],2],[[9169,9179],2],[[9180,9191],2],[9192,2],[[9193,9203],2],[[9204,9210],2],[[9211,9214],2],[9215,2],[[9216,9252],2],[[9253,9254],2],[[9255,9257],2],[[9258,9279],3],[[9280,9290],2],[[9291,9311],3],[9312,1,"1"],[9313,1,"2"],[9314,1,"3"],[9315,1,"4"],[9316,1,"5"],[9317,1,"6"],[9318,1,"7"],[9319,1,"8"],[9320,1,"9"],[9321,1,"10"],[9322,1,"11"],[9323,1,"12"],[9324,1,"13"],[9325,1,"14"],[9326,1,"15"],[9327,1,"16"],[9328,1,"17"],[9329,1,"18"],[9330,1,"19"],[9331,1,"20"],[9332,1,"(1)"],[9333,1,"(2)"],[9334,1,"(3)"],[9335,1,"(4)"],[9336,1,"(5)"],[9337,1,"(6)"],[9338,1,"(7)"],[9339,1,"(8)"],[9340,1,"(9)"],[9341,1,"(10)"],[9342,1,"(11)"],[9343,1,"(12)"],[9344,1,"(13)"],[9345,1,"(14)"],[9346,1,"(15)"],[9347,1,"(16)"],[9348,1,"(17)"],[9349,1,"(18)"],[9350,1,"(19)"],[9351,1,"(20)"],[[9352,9371],3],[9372,1,"(a)"],[9373,1,"(b)"],[9374,1,"(c)"],[9375,1,"(d)"],[9376,1,"(e)"],[9377,1,"(f)"],[9378,1,"(g)"],[9379,1,"(h)"],[9380,1,"(i)"],[9381,1,"(j)"],[9382,1,"(k)"],[9383,1,"(l)"],[9384,1,"(m)"],[9385,1,"(n)"],[9386,1,"(o)"],[9387,1,"(p)"],[9388,1,"(q)"],[9389,1,"(r)"],[9390,1,"(s)"],[9391,1,"(t)"],[9392,1,"(u)"],[9393,1,"(v)"],[9394,1,"(w)"],[9395,1,"(x)"],[9396,1,"(y)"],[9397,1,"(z)"],[9398,1,"a"],[9399,1,"b"],[9400,1,"c"],[9401,1,"d"],[9402,1,"e"],[9403,1,"f"],[9404,1,"g"],[9405,1,"h"],[9406,1,"i"],[9407,1,"j"],[9408,1,"k"],[9409,1,"l"],[9410,1,"m"],[9411,1,"n"],[9412,1,"o"],[9413,1,"p"],[9414,1,"q"],[9415,1,"r"],[9416,1,"s"],[9417,1,"t"],[9418,1,"u"],[9419,1,"v"],[9420,1,"w"],[9421,1,"x"],[9422,1,"y"],[9423,1,"z"],[9424,1,"a"],[9425,1,"b"],[9426,1,"c"],[9427,1,"d"],[9428,1,"e"],[9429,1,"f"],[9430,1,"g"],[9431,1,"h"],[9432,1,"i"],[9433,1,"j"],[9434,1,"k"],[9435,1,"l"],[9436,1,"m"],[9437,1,"n"],[9438,1,"o"],[9439,1,"p"],[9440,1,"q"],[9441,1,"r"],[9442,1,"s"],[9443,1,"t"],[9444,1,"u"],[9445,1,"v"],[9446,1,"w"],[9447,1,"x"],[9448,1,"y"],[9449,1,"z"],[9450,1,"0"],[[9451,9470],2],[9471,2],[[9472,9621],2],[[9622,9631],2],[[9632,9711],2],[[9712,9719],2],[[9720,9727],2],[[9728,9747],2],[[9748,9749],2],[[9750,9751],2],[9752,2],[9753,2],[[9754,9839],2],[[9840,9841],2],[[9842,9853],2],[[9854,9855],2],[[9856,9865],2],[[9866,9873],2],[[9874,9884],2],[9885,2],[[9886,9887],2],[[9888,9889],2],[[9890,9905],2],[9906,2],[[9907,9916],2],[[9917,9919],2],[[9920,9923],2],[[9924,9933],2],[9934,2],[[9935,9953],2],[9954,2],[9955,2],[[9956,9959],2],[[9960,9983],2],[9984,2],[[9985,9988],2],[9989,2],[[9990,9993],2],[[9994,9995],2],[[9996,10023],2],[10024,2],[[10025,10059],2],[10060,2],[10061,2],[10062,2],[[10063,10066],2],[[10067,10069],2],[10070,2],[10071,2],[[10072,10078],2],[[10079,10080],2],[[10081,10087],2],[[10088,10101],2],[[10102,10132],2],[[10133,10135],2],[[10136,10159],2],[10160,2],[[10161,10174],2],[10175,2],[[10176,10182],2],[[10183,10186],2],[10187,2],[10188,2],[10189,2],[[10190,10191],2],[[10192,10219],2],[[10220,10223],2],[[10224,10239],2],[[10240,10495],2],[[10496,10763],2],[10764,1,""],[[10765,10867],2],[10868,1,"::="],[10869,1,"=="],[10870,1,"==="],[[10871,10971],2],[10972,1,""],[[10973,11007],2],[[11008,11021],2],[[11022,11027],2],[[11028,11034],2],[[11035,11039],2],[[11040,11043],2],[[11044,11084],2],[[11085,11087],2],[[11088,11092],2],[[11093,11097],2],[[11098,11123],2],[[11124,11125],3],[[11126,11157],2],[11158,3],[11159,2],[[11160,11193],2],[[11194,11196],2],[[11197,11208],2],[11209,2],[[11210,11217],2],[11218,2],[[11219,11243],2],[[11244,11247],2],[[11248,11262],2],[11263,2],[11264,1,""],[11265,1,""],[11266,1,""],[11267,1,""],[11268,1,""],[11269,1,""],[11270,1,""],[11271,1,""],[11272,1,""],[11273,1,""],[11274,1,""],[11275,1,""],[11276,1,""],[11277,1,""],[11278,1,""],[11279,1,""],[11280,1,""],[11281,1,""],[11282,1,""],[11283,1,""],[11284,1,""],[11285,1,""],[11286,1,""],[11287,1,""],[11288,1,""],[11289,1,""],[11290,1,""],[11291,1,""],[11292,1,""],[11293,1,""],[11294,1,""],[11295,1,""],[11296,1,""],[11297,1,""],[11298,1,""],[11299,1,""],[11300,1,""],[11301,1,""],[11302,1,""],[11303,1,""],[11304,1,""],[11305,1,""],[11306,1,""],[11307,1,""],[11308,1,""],[11309,1,""],[11310,1,""],[11311,1,""],[[11312,11358],2],[11359,2],[11360,1,""],[11361,2],[11362,1,""],[11363,1,""],[11364,1,""],[[11365,11366],2],[11367,1,""],[11368,2],[11369,1,""],[11370,2],[11371,1,""],[11372,2],[11373,1,""],[11374,1,""],[11375,1,""],[11376,1,""],[11377,2],[11378,1,""],[11379,2],[11380,2],[11381,1,""],[[11382,11383],2],[[11384,11387],2],[11388,1,"j"],[11389,1,"v"],[11390,1,""],[11391,1,""],[11392,1,""],[11393,2],[11394,1,""],[11395,2],[11396,1,""],[11397,2],[11398,1,""],[11399,2],[11400,1,""],[11401,2],[11402,1,""],[11403,2],[11404,1,""],[11405,2],[11406,1,""],[11407,2],[11408,1,""],[11409,2],[11410,1,""],[11411,2],[11412,1,""],[11413,2],[11414,1,""],[11415,2],[11416,1,""],[11417,2],[11418,1,""],[11419,2],[11420,1,""],[11421,2],[11422,1,""],[11423,2],[11424,1,""],[11425,2],[11426,1,""],[11427,2],[11428,1,""],[11429,2],[11430,1,""],[11431,2],[11432,1,""],[11433,2],[11434,1,""],[11435,2],[11436,1,""],[11437,2],[11438,1,""],[11439,2],[11440,1,""],[11441,2],[11442,1,""],[11443,2],[11444,1,""],[11445,2],[11446,1,""],[11447,2],[11448,1,""],[11449,2],[11450,1,""],[11451,2],[11452,1,""],[11453,2],[11454,1,""],[11455,2],[11456,1,""],[11457,2],[11458,1,""],[11459,2],[11460,1,""],[11461,2],[11462,1,""],[11463,2],[11464,1,""],[11465,2],[11466,1,""],[11467,2],[11468,1,""],[11469,2],[11470,1,""],[11471,2],[11472,1,""],[11473,2],[11474,1,""],[11475,2],[11476,1,""],[11477,2],[11478,1,""],[11479,2],[11480,1,""],[11481,2],[11482,1,""],[11483,2],[11484,1,""],[11485,2],[11486,1,""],[11487,2],[11488,1,""],[11489,2],[11490,1,""],[[11491,11492],2],[[11493,11498],2],[11499,1,""],[11500,2],[11501,1,""],[[11502,11505],2],[11506,1,""],[11507,2],[[11508,11512],3],[[11513,11519],2],[[11520,11557],2],[11558,3],[11559,2],[[11560,11564],3],[11565,2],[[11566,11567],3],[[11568,11621],2],[[11622,11623],2],[[11624,11630],3],[11631,1,""],[11632,2],[[11633,11646],3],[11647,2],[[11648,11670],2],[[11671,11679],3],[[11680,11686],2],[11687,3],[[11688,11694],2],[11695,3],[[11696,11702],2],[11703,3],[[11704,11710],2],[11711,3],[[11712,11718],2],[11719,3],[[11720,11726],2],[11727,3],[[11728,11734],2],[11735,3],[[11736,11742],2],[11743,3],[[11744,11775],2],[[11776,11799],2],[[11800,11803],2],[[11804,11805],2],[[11806,11822],2],[11823,2],[11824,2],[11825,2],[[11826,11835],2],[[11836,11842],2],[[11843,11844],2],[[11845,11849],2],[[11850,11854],2],[11855,2],[[11856,11858],2],[[11859,11869],2],[[11870,11903],3],[[11904,11929],2],[11930,3],[[11931,11934],2],[11935,1,""],[[11936,12018],2],[12019,1,""],[[12020,12031],3],[12032,1,""],[12033,1,""],[12034,1,""],[12035,1,""],[12036,1,""],[12037,1,""],[12038,1,""],[12039,1,""],[12040,1,""],[12041,1,""],[12042,1,""],[12043,1,""],[12044,1,""],[12045,1,""],[12046,1,""],[12047,1,""],[12048,1,""],[12049,1,""],[12050,1,""],[12051,1,""],[12052,1,""],[12053,1,""],[12054,1,""],[12055,1,""],[12056,1,""],[12057,1,""],[12058,1,""],[12059,1,""],[12060,1,""],[12061,1,""],[12062,1,""],[12063,1,""],[12064,1,""],[12065,1,""],[12066,1,""],[12067,1,""],[12068,1,""],[12069,1,""],[12070,1,""],[12071,1,""],[12072,1,""],[12073,1,""],[12074,1,""],[12075,1,""],[12076,1,""],[12077,1,""],[12078,1,""],[12079,1,""],[12080,1,""],[12081,1,""],[12082,1,""],[12083,1,""],[12084,1,""],[12085,1,""],[12086,1,""],[12087,1,""],[12088,1,""],[12089,1,""],[12090,1,""],[12091,1,""],[12092,1,""],[12093,1,""],[12094,1,""],[12095,1,""],[12096,1,""],[12097,1,""],[12098,1,""],[12099,1,""],[12100,1,""],[12101,1,""],[12102,1,""],[12103,1,""],[12104,1,""],[12105,1,""],[12106,1,""],[12107,1,""],[12108,1,""],[12109,1,""],[12110,1,""],[12111,1,""],[12112,1,""],[12113,1,""],[12114,1,""],[12115,1,""],[12116,1,""],[12117,1,""],[12118,1,""],[12119,1,""],[12120,1,""],[12121,1,""],[12122,1,""],[12123,1,""],[12124,1,""],[12125,1,""],[12126,1,""],[12127,1,""],[12128,1,""],[12129,1,""],[12130,1,""],[12131,1,""],[12132,1,""],[12133,1,""],[12134,1,""],[12135,1,""],[12136,1,""],[12137,1,""],[12138,1,""],[12139,1,""],[12140,1,""],[12141,1,""],[12142,1,""],[12143,1,""],[12144,1,""],[12145,1,""],[12146,1,""],[12147,1,""],[12148,1,""],[12149,1,""],[12150,1,""],[12151,1,""],[12152,1,""],[12153,1,""],[12154,1,""],[12155,1,""],[12156,1,""],[12157,1,""],[12158,1,""],[12159,1,""],[12160,1,""],[12161,1,""],[12162,1,""],[12163,1,""],[12164,1,""],[12165,1,""],[12166,1,""],[12167,1,""],[12168,1,""],[12169,1,""],[12170,1,""],[12171,1,""],[12172,1,""],[12173,1,""],[12174,1,""],[12175,1,""],[12176,1,""],[12177,1,""],[12178,1,""],[12179,1,""],[12180,1,""],[12181,1,""],[12182,1,""],[12183,1,""],[12184,1,""],[12185,1,""],[12186,1,""],[12187,1,""],[12188,1,""],[12189,1,""],[12190,1,""],[12191,1,""],[12192,1,""],[12193,1,""],[12194,1,""],[12195,1,""],[12196,1,""],[12197,1,""],[12198,1,""],[12199,1,""],[12200,1,""],[12201,1,""],[12202,1,""],[12203,1,""],[12204,1,""],[12205,1,""],[12206,1,""],[12207,1,""],[12208,1,""],[12209,1,""],[12210,1,""],[12211,1,""],[12212,1,""],[12213,1,""],[12214,1,""],[12215,1,""],[12216,1,""],[12217,1,""],[12218,1,""],[12219,1,""],[12220,1,""],[12221,1,""],[12222,1,""],[12223,1,""],[12224,1,""],[12225,1,""],[12226,1,""],[12227,1,""],[12228,1,""],[12229,1,""],[12230,1,""],[12231,1,""],[12232,1,""],[12233,1,""],[12234,1,""],[12235,1,""],[12236,1,""],[12237,1,""],[12238,1,""],[12239,1,""],[12240,1,""],[12241,1,""],[12242,1,""],[12243,1,""],[12244,1,""],[12245,1,""],[[12246,12271],3],[[12272,12283],3],[[12284,12287],3],[12288,1," "],[12289,2],[12290,1,"."],[[12291,12292],2],[[12293,12295],2],[[12296,12329],2],[[12330,12333],2],[[12334,12341],2],[12342,1,""],[12343,2],[12344,1,""],[12345,1,""],[12346,1,""],[12347,2],[12348,2],[12349,2],[12350,2],[12351,2],[12352,3],[[12353,12436],2],[[12437,12438],2],[[12439,12440],3],[[12441,12442],2],[12443,1," "],[12444,1," "],[[12445,12446],2],[12447,1,""],[12448,2],[[12449,12542],2],[12543,1,""],[[12544,12548],3],[[12549,12588],2],[12589,2],[12590,2],[12591,2],[12592,3],[12593,1,""],[12594,1,""],[12595,1,""],[12596,1,""],[12597,1,""],[12598,1,""],[12599,1,""],[12600,1,""],[12601,1,""],[12602,1,""],[12603,1,""],[12604,1,""],[12605,1,""],[12606,1,""],[12607,1,""],[12608,1,""],[12609,1,""],[12610,1,""],[12611,1,""],[12612,1,""],[12613,1,""],[12614,1,""],[12615,1,""],[12616,1,""],[12617,1,""],[12618,1,""],[12619,1,""],[12620,1,""],[12621,1,""],[12622,1,""],[12623,1,""],[12624,1,""],[12625,1,""],[12626,1,""],[12627,1,""],[12628,1,""],[12629,1,""],[12630,1,""],[12631,1,""],[12632,1,""],[12633,1,""],[12634,1,""],[12635,1,""],[12636,1,""],[12637,1,""],[12638,1,""],[12639,1,""],[12640,1,""],[12641,1,""],[12642,1,""],[12643,1,""],[12644,7],[12645,1,""],[12646,1,""],[12647,1,""],[12648,1,""],[12649,1,""],[12650,1,""],[12651,1,""],[12652,1,""],[12653,1,""],[12654,1,""],[12655,1,""],[12656,1,""],[12657,1,""],[12658,1,""],[12659,1,""],[12660,1,""],[12661,1,""],[12662,1,""],[12663,1,""],[12664,1,""],[12665,1,""],[12666,1,""],[12667,1,""],[12668,1,""],[12669,1,""],[12670,1,""],[12671,1,""],[12672,1,""],[12673,1,""],[12674,1,""],[12675,1,""],[12676,1,""],[12677,1,""],[12678,1,""],[12679,1,""],[12680,1,""],[12681,1,""],[12682,1,""],[12683,1,""],[12684,1,""],[12685,1,""],[12686,1,""],[12687,3],[[12688,12689],2],[12690,1,""],[12691,1,""],[12692,1,""],[12693,1,""],[12694,1,""],[12695,1,""],[12696,1,""],[12697,1,""],[12698,1,""],[12699,1,""],[12700,1,""],[12701,1,""],[12702,1,""],[12703,1,""],[[12704,12727],2],[[12728,12730],2],[[12731,12735],2],[[12736,12751],2],[[12752,12771],2],[[12772,12773],2],[[12774,12782],3],[12783,3],[[12784,12799],2],[12800,1,"()"],[12801,1,"()"],[12802,1,"()"],[12803,1,"()"],[12804,1,"()"],[12805,1,"()"],[12806,1,"()"],[12807,1,"()"],[12808,1,"()"],[12809,1,"()"],[12810,1,"()"],[12811,1,"()"],[12812,1,"()"],[12813,1,"()"],[12814,1,"()"],[12815,1,"()"],[12816,1,"()"],[12817,1,"()"],[12818,1,"()"],[12819,1,"()"],[12820,1,"()"],[12821,1,"()"],[12822,1,"()"],[12823,1,"()"],[12824,1,"()"],[12825,1,"()"],[12826,1,"()"],[12827,1,"()"],[12828,1,"()"],[12829,1,"()"],[12830,1,"()"],[12831,3],[12832,1,"()"],[12833,1,"()"],[12834,1,"()"],[12835,1,"()"],[12836,1,"()"],[12837,1,"()"],[12838,1,"()"],[12839,1,"()"],[12840,1,"()"],[12841,1,"()"],[12842,1,"()"],[12843,1,"()"],[12844,1,"()"],[12845,1,"()"],[12846,1,"()"],[12847,1,"()"],[12848,1,"()"],[12849,1,"()"],[12850,1,"()"],[12851,1,"()"],[12852,1,"()"],[12853,1,"()"],[12854,1,"()"],[12855,1,"()"],[12856,1,"()"],[12857,1,"()"],[12858,1,"()"],[12859,1,"()"],[12860,1,"()"],[12861,1,"()"],[12862,1,"()"],[12863,1,"()"],[12864,1,"()"],[12865,1,"()"],[12866,1,"()"],[12867,1,"()"],[12868,1,""],[12869,1,""],[12870,1,""],[12871,1,""],[[12872,12879],2],[12880,1,"pte"],[12881,1,"21"],[12882,1,"22"],[12883,1,"23"],[12884,1,"24"],[12885,1,"25"],[12886,1,"26"],[12887,1,"27"],[12888,1,"28"],[12889,1,"29"],[12890,1,"30"],[12891,1,"31"],[12892,1,"32"],[12893,1,"33"],[12894,1,"34"],[12895,1,"35"],[12896,1,""],[12897,1,""],[12898,1,""],[12899,1,""],[12900,1,""],[12901,1,""],[12902,1,""],[12903,1,""],[12904,1,""],[12905,1,""],[12906,1,""],[12907,1,""],[12908,1,""],[12909,1,""],[12910,1,""],[12911,1,""],[12912,1,""],[12913,1,""],[12914,1,""],[12915,1,""],[12916,1,""],[12917,1,""],[12918,1,""],[12919,1,""],[12920,1,""],[12921,1,""],[12922,1,""],[12923,1,""],[12924,1,""],[12925,1,""],[12926,1,""],[12927,2],[12928,1,""],[12929,1,""],[12930,1,""],[12931,1,""],[12932,1,""],[12933,1,""],[12934,1,""],[12935,1,""],[12936,1,""],[12937,1,""],[12938,1,""],[12939,1,""],[12940,1,""],[12941,1,""],[12942,1,""],[12943,1,""],[12944,1,""],[12945,1,""],[12946,1,""],[12947,1,""],[12948,1,""],[12949,1,""],[12950,1,""],[12951,1,""],[12952,1,""],[12953,1,""],[12954,1,""],[12955,1,""],[12956,1,""],[12957,1,""],[12958,1,""],[12959,1,""],[12960,1,""],[12961,1,""],[12962,1,""],[12963,1,""],[12964,1,""],[12965,1,""],[12966,1,""],[12967,1,""],[12968,1,""],[12969,1,""],[12970,1,""],[12971,1,""],[12972,1,""],[12973,1,""],[12974,1,""],[12975,1,""],[12976,1,""],[12977,1,"36"],[12978,1,"37"],[12979,1,"38"],[12980,1,"39"],[12981,1,"40"],[12982,1,"41"],[12983,1,"42"],[12984,1,"43"],[12985,1,"44"],[12986,1,"45"],[12987,1,"46"],[12988,1,"47"],[12989,1,"48"],[12990,1,"49"],[12991,1,"50"],[12992,1,"1"],[12993,1,"2"],[12994,1,"3"],[12995,1,"4"],[12996,1,"5"],[12997,1,"6"],[12998,1,"7"],[12999,1,"8"],[13000,1,"9"],[13001,1,"10"],[13002,1,"11"],[13003,1,"12"],[13004,1,"hg"],[13005,1,"erg"],[13006,1,"ev"],[13007,1,"ltd"],[13008,1,""],[13009,1,""],[13010,1,""],[13011,1,""],[13012,1,""],[13013,1,""],[13014,1,""],[13015,1,""],[13016,1,""],[13017,1,""],[13018,1,""],[13019,1,""],[13020,1,""],[13021,1,""],[13022,1,""],[13023,1,""],[13024,1,""],[13025,1,""],[13026,1,""],[13027,1,""],[13028,1,""],[13029,1,""],[13030,1,""],[13031,1,""],[13032,1,""],[13033,1,""],[13034,1,""],[13035,1,""],[13036,1,""],[13037,1,""],[13038,1,""],[13039,1,""],[13040,1,""],[13041,1,""],[13042,1,""],[13043,1,""],[13044,1,""],[13045,1,""],[13046,1,""],[13047,1,""],[13048,1,""],[13049,1,""],[13050,1,""],[13051,1,""],[13052,1,""],[13053,1,""],[13054,1,""],[13055,1,""],[13056,1,""],[13057,1,""],[13058,1,""],[13059,1,""],[13060,1,""],[13061,1,""],[13062,1,""],[13063,1,""],[13064,1,""],[13065,1,""],[13066,1,""],[13067,1,""],[13068,1,""],[13069,1,""],[13070,1,""],[13071,1,""],[13072,1,""],[13073,1,""],[13074,1,""],[13075,1,""],[13076,1,""],[13077,1,""],[13078,1,""],[13079,1,""],[13080,1,""],[13081,1,""],[13082,1,""],[13083,1,""],[13084,1,""],[13085,1,""],[13086,1,""],[13087,1,""],[13088,1,""],[13089,1,""],[13090,1,""],[13091,1,""],[13092,1,""],[13093,1,""],[13094,1,""],[13095,1,""],[13096,1,""],[13097,1,""],[13098,1,""],[13099,1,""],[13100,1,""],[13101,1,""],[13102,1,""],[13103,1,""],[13104,1,""],[13105,1,""],[13106,1,""],[13107,1,""],[13108,1,""],[13109,1,""],[13110,1,""],[13111,1,""],[13112,1,""],[13113,1,""],[13114,1,""],[13115,1,""],[13116,1,""],[13117,1,""],[13118,1,""],[13119,1,""],[13120,1,""],[13121,1,""],[13122,1,""],[13123,1,""],[13124,1,""],[13125,1,""],[13126,1,""],[13127,1,""],[13128,1,""],[13129,1,""],[13130,1,""],[13131,1,""],[13132,1,""],[13133,1,""],[13134,1,""],[13135,1,""],[13136,1,""],[13137,1,""],[13138,1,""],[13139,1,""],[13140,1,""],[13141,1,""],[13142,1,""],[13143,1,""],[13144,1,"0"],[13145,1,"1"],[13146,1,"2"],[13147,1,"3"],[13148,1,"4"],[13149,1,"5"],[13150,1,"6"],[13151,1,"7"],[13152,1,"8"],[13153,1,"9"],[13154,1,"10"],[13155,1,"11"],[13156,1,"12"],[13157,1,"13"],[13158,1,"14"],[13159,1,"15"],[13160,1,"16"],[13161,1,"17"],[13162,1,"18"],[13163,1,"19"],[13164,1,"20"],[13165,1,"21"],[13166,1,"22"],[13167,1,"23"],[13168,1,"24"],[13169,1,"hpa"],[13170,1,"da"],[13171,1,"au"],[13172,1,"bar"],[13173,1,"ov"],[13174,1,"pc"],[13175,1,"dm"],[13176,1,"dm2"],[13177,1,"dm3"],[13178,1,"iu"],[13179,1,""],[13180,1,""],[13181,1,""],[13182,1,""],[13183,1,""],[13184,1,"pa"],[13185,1,"na"],[13186,1,"a"],[13187,1,"ma"],[13188,1,"ka"],[13189,1,"kb"],[13190,1,"mb"],[13191,1,"gb"],[13192,1,"cal"],[13193,1,"kcal"],[13194,1,"pf"],[13195,1,"nf"],[13196,1,"f"],[13197,1,"g"],[13198,1,"mg"],[13199,1,"kg"],[13200,1,"hz"],[13201,1,"khz"],[13202,1,"mhz"],[13203,1,"ghz"],[13204,1,"thz"],[13205,1,"l"],[13206,1,"ml"],[13207,1,"dl"],[13208,1,"kl"],[13209,1,"fm"],[13210,1,"nm"],[13211,1,"m"],[13212,1,"mm"],[13213,1,"cm"],[13214,1,"km"],[13215,1,"mm2"],[13216,1,"cm2"],[13217,1,"m2"],[13218,1,"km2"],[13219,1,"mm3"],[13220,1,"cm3"],[13221,1,"m3"],[13222,1,"km3"],[13223,1,"ms"],[13224,1,"ms2"],[13225,1,"pa"],[13226,1,"kpa"],[13227,1,"mpa"],[13228,1,"gpa"],[13229,1,"rad"],[13230,1,"rads"],[13231,1,"rads2"],[13232,1,"ps"],[13233,1,"ns"],[13234,1,"s"],[13235,1,"ms"],[13236,1,"pv"],[13237,1,"nv"],[13238,1,"v"],[13239,1,"mv"],[13240,1,"kv"],[13241,1,"mv"],[13242,1,"pw"],[13243,1,"nw"],[13244,1,"w"],[13245,1,"mw"],[13246,1,"kw"],[13247,1,"mw"],[13248,1,"k"],[13249,1,"m"],[13250,3],[13251,1,"bq"],[13252,1,"cc"],[13253,1,"cd"],[13254,1,"ckg"],[13255,3],[13256,1,"db"],[13257,1,"gy"],[13258,1,"ha"],[13259,1,"hp"],[13260,1,"in"],[13261,1,"kk"],[13262,1,"km"],[13263,1,"kt"],[13264,1,"lm"],[13265,1,"ln"],[13266,1,"log"],[13267,1,"lx"],[13268,1,"mb"],[13269,1,"mil"],[13270,1,"mol"],[13271,1,"ph"],[13272,3],[13273,1,"ppm"],[13274,1,"pr"],[13275,1,"sr"],[13276,1,"sv"],[13277,1,"wb"],[13278,1,"vm"],[13279,1,"am"],[13280,1,"1"],[13281,1,"2"],[13282,1,"3"],[13283,1,"4"],[13284,1,"5"],[13285,1,"6"],[13286,1,"7"],[13287,1,"8"],[13288,1,"9"],[13289,1,"10"],[13290,1,"11"],[13291,1,"12"],[13292,1,"13"],[13293,1,"14"],[13294,1,"15"],[13295,1,"16"],[13296,1,"17"],[13297,1,"18"],[13298,1,"19"],[13299,1,"20"],[13300,1,"21"],[13301,1,"22"],[13302,1,"23"],[13303,1,"24"],[13304,1,"25"],[13305,1,"26"],[13306,1,"27"],[13307,1,"28"],[13308,1,"29"],[13309,1,"30"],[13310,1,"31"],[13311,1,"gal"],[[13312,19893],2],[[19894,19903],2],[[19904,19967],2],[[19968,40869],2],[[40870,40891],2],[[40892,40899],2],[[40900,40907],2],[40908,2],[[40909,40917],2],[[40918,40938],2],[[40939,40943],2],[[40944,40956],2],[[40957,40959],2],[[40960,42124],2],[[42125,42127],3],[[42128,42145],2],[[42146,42147],2],[[42148,42163],2],[42164,2],[[42165,42176],2],[42177,2],[[42178,42180],2],[42181,2],[42182,2],[[42183,42191],3],[[42192,42237],2],[[42238,42239],2],[[42240,42508],2],[[42509,42511],2],[[42512,42539],2],[[42540,42559],3],[42560,1,""],[42561,2],[42562,1,""],[42563,2],[42564,1,""],[42565,2],[42566,1,""],[42567,2],[42568,1,""],[42569,2],[42570,1,""],[42571,2],[42572,1,""],[42573,2],[42574,1,""],[42575,2],[42576,1,""],[42577,2],[42578,1,""],[42579,2],[42580,1,""],[42581,2],[42582,1,""],[42583,2],[42584,1,""],[42585,2],[42586,1,""],[42587,2],[42588,1,""],[42589,2],[42590,1,""],[42591,2],[42592,1,""],[42593,2],[42594,1,""],[42595,2],[42596,1,""],[42597,2],[42598,1,""],[42599,2],[42600,1,""],[42601,2],[42602,1,""],[42603,2],[42604,1,""],[[42605,42607],2],[[42608,42611],2],[[42612,42619],2],[[42620,42621],2],[42622,2],[42623,2],[42624,1,""],[42625,2],[42626,1,""],[42627,2],[42628,1,""],[42629,2],[42630,1,""],[42631,2],[42632,1,""],[42633,2],[42634,1,""],[42635,2],[42636,1,""],[42637,2],[42638,1,""],[42639,2],[42640,1,""],[42641,2],[42642,1,""],[42643,2],[42644,1,""],[42645,2],[42646,1,""],[42647,2],[42648,1,""],[42649,2],[42650,1,""],[42651,2],[42652,1,""],[42653,1,""],[42654,2],[42655,2],[[42656,42725],2],[[42726,42735],2],[[42736,42737],2],[[42738,42743],2],[[42744,42751],3],[[42752,42774],2],[[42775,42778],2],[[42779,42783],2],[[42784,42785],2],[42786,1,""],[42787,2],[42788,1,""],[42789,2],[42790,1,""],[42791,2],[42792,1,""],[42793,2],[42794,1,""],[42795,2],[42796,1,""],[42797,2],[42798,1,""],[[42799,42801],2],[42802,1,""],[42803,2],[42804,1,""],[42805,2],[42806,1,""],[42807,2],[42808,1,""],[42809,2],[42810,1,""],[42811,2],[42812,1,""],[42813,2],[42814,1,""],[42815,2],[42816,1,""],[42817,2],[42818,1,""],[42819,2],[42820,1,""],[42821,2],[42822,1,""],[42823,2],[42824,1,""],[42825,2],[42826,1,""],[42827,2],[42828,1,""],[42829,2],[42830,1,""],[42831,2],[42832,1,""],[42833,2],[42834,1,""],[42835,2],[42836,1,""],[42837,2],[42838,1,""],[42839,2],[42840,1,""],[42841,2],[42842,1,""],[42843,2],[42844,1,""],[42845,2],[42846,1,""],[42847,2],[42848,1,""],[42849,2],[42850,1,""],[42851,2],[42852,1,""],[42853,2],[42854,1,""],[42855,2],[42856,1,""],[42857,2],[42858,1,""],[42859,2],[42860,1,""],[42861,2],[42862,1,""],[42863,2],[42864,1,""],[[42865,42872],2],[42873,1,""],[42874,2],[42875,1,""],[42876,2],[42877,1,""],[42878,1,""],[42879,2],[42880,1,""],[42881,2],[42882,1,""],[42883,2],[42884,1,""],[42885,2],[42886,1,""],[[42887,42888],2],[[42889,42890],2],[42891,1,""],[42892,2],[42893,1,""],[42894,2],[42895,2],[42896,1,""],[42897,2],[42898,1,""],[42899,2],[[42900,42901],2],[42902,1,""],[42903,2],[42904,1,""],[42905,2],[42906,1,""],[42907,2],[42908,1,""],[42909,2],[42910,1,""],[42911,2],[42912,1,""],[42913,2],[42914,1,""],[42915,2],[42916,1,""],[42917,2],[42918,1,""],[42919,2],[42920,1,""],[42921,2],[42922,1,""],[42923,1,""],[42924,1,""],[42925,1,""],[42926,1,""],[42927,2],[42928,1,""],[42929,1,""],[42930,1,""],[42931,1,""],[42932,1,""],[42933,2],[42934,1,""],[42935,2],[42936,1,""],[42937,2],[42938,1,""],[42939,2],[42940,1,""],[42941,2],[42942,1,""],[42943,2],[42944,1,""],[42945,2],[42946,1,""],[42947,2],[42948,1,""],[42949,1,""],[42950,1,""],[42951,1,""],[42952,2],[42953,1,""],[42954,2],[42955,1,""],[42956,1,""],[42957,2],[[42958,42959],3],[42960,1,""],[42961,2],[42962,3],[42963,2],[42964,3],[42965,2],[42966,1,""],[42967,2],[42968,1,""],[42969,2],[42970,1,""],[42971,2],[42972,1,""],[[42973,42993],3],[42994,1,"c"],[42995,1,"f"],[42996,1,"q"],[42997,1,""],[42998,2],[42999,2],[43000,1,""],[43001,1,""],[43002,2],[[43003,43007],2],[[43008,43047],2],[[43048,43051],2],[43052,2],[[43053,43055],3],[[43056,43065],2],[[43066,43071],3],[[43072,43123],2],[[43124,43127],2],[[43128,43135],3],[[43136,43204],2],[43205,2],[[43206,43213],3],[[43214,43215],2],[[43216,43225],2],[[43226,43231],3],[[43232,43255],2],[[43256,43258],2],[43259,2],[43260,2],[43261,2],[[43262,43263],2],[[43264,43309],2],[[43310,43311],2],[[43312,43347],2],[[43348,43358],3],[43359,2],[[43360,43388],2],[[43389,43391],3],[[43392,43456],2],[[43457,43469],2],[43470,3],[[43471,43481],2],[[43482,43485],3],[[43486,43487],2],[[43488,43518],2],[43519,3],[[43520,43574],2],[[43575,43583],3],[[43584,43597],2],[[43598,43599],3],[[43600,43609],2],[[43610,43611],3],[[43612,43615],2],[[43616,43638],2],[[43639,43641],2],[[43642,43643],2],[[43644,43647],2],[[43648,43714],2],[[43715,43738],3],[[43739,43741],2],[[43742,43743],2],[[43744,43759],2],[[43760,43761],2],[[43762,43766],2],[[43767,43776],3],[[43777,43782],2],[[43783,43784],3],[[43785,43790],2],[[43791,43792],3],[[43793,43798],2],[[43799,43807],3],[[43808,43814],2],[43815,3],[[43816,43822],2],[43823,3],[[43824,43866],2],[43867,2],[43868,1,""],[43869,1,""],[43870,1,""],[43871,1,""],[[43872,43875],2],[[43876,43877],2],[[43878,43879],2],[43880,2],[43881,1,""],[[43882,43883],2],[[43884,43887],3],[43888,1,""],[43889,1,""],[43890,1,""],[43891,1,""],[43892,1,""],[43893,1,""],[43894,1,""],[43895,1,""],[43896,1,""],[43897,1,""],[43898,1,""],[43899,1,""],[43900,1,""],[43901,1,""],[43902,1,""],[43903,1,""],[43904,1,""],[43905,1,""],[43906,1,""],[43907,1,""],[43908,1,""],[43909,1,""],[43910,1,""],[43911,1,""],[43912,1,""],[43913,1,""],[43914,1,""],[43915,1,""],[43916,1,""],[43917,1,""],[43918,1,""],[43919,1,""],[43920,1,""],[43921,1,""],[43922,1,""],[43923,1,""],[43924,1,""],[43925,1,""],[43926,1,""],[43927,1,""],[43928,1,""],[43929,1,""],[43930,1,""],[43931,1,""],[43932,1,""],[43933,1,""],[43934,1,""],[43935,1,""],[43936,1,""],[43937,1,""],[43938,1,""],[43939,1,""],[43940,1,""],[43941,1,""],[43942,1,""],[43943,1,""],[43944,1,""],[43945,1,""],[43946,1,""],[43947,1,""],[43948,1,""],[43949,1,""],[43950,1,""],[43951,1,""],[43952,1,""],[43953,1,""],[43954,1,""],[43955,1,""],[43956,1,""],[43957,1,""],[43958,1,""],[43959,1,""],[43960,1,""],[43961,1,""],[43962,1,""],[43963,1,""],[43964,1,""],[43965,1,""],[43966,1,""],[43967,1,""],[[43968,44010],2],[44011,2],[[44012,44013],2],[[44014,44015],3],[[44016,44025],2],[[44026,44031],3],[[44032,55203],2],[[55204,55215],3],[[55216,55238],2],[[55239,55242],3],[[55243,55291],2],[[55292,55295],3],[[55296,57343],3],[[57344,63743],3],[63744,1,""],[63745,1,""],[63746,1,""],[63747,1,""],[63748,1,""],[63749,1,""],[63750,1,""],[[63751,63752],1,""],[63753,1,""],[63754,1,""],[63755,1,""],[63756,1,""],[63757,1,""],[63758,1,""],[63759,1,""],[63760,1,""],[63761,1,""],[63762,1,""],[63763,1,""],[63764,1,""],[63765,1,""],[63766,1,""],[63767,1,""],[63768,1,""],[63769,1,""],[63770,1,""],[63771,1,""],[63772,1,""],[63773,1,""],[63774,1,""],[63775,1,""],[63776,1,""],[63777,1,""],[63778,1,""],[63779,1,""],[63780,1,""],[63781,1,""],[63782,1,""],[63783,1,""],[63784,1,""],[63785,1,""],[63786,1,""],[63787,1,""],[63788,1,""],[63789,1,""],[63790,1,""],[63791,1,""],[63792,1,""],[63793,1,""],[63794,1,""],[63795,1,""],[63796,1,""],[63797,1,""],[63798,1,""],[63799,1,""],[63800,1,""],[63801,1,""],[63802,1,""],[63803,1,""],[63804,1,""],[63805,1,""],[63806,1,""],[63807,1,""],[63808,1,""],[63809,1,""],[63810,1,""],[63811,1,""],[63812,1,""],[63813,1,""],[63814,1,""],[63815,1,""],[63816,1,""],[63817,1,""],[63818,1,""],[63819,1,""],[63820,1,""],[63821,1,""],[63822,1,""],[63823,1,""],[63824,1,""],[63825,1,""],[63826,1,""],[63827,1,""],[63828,1,""],[63829,1,""],[63830,1,""],[63831,1,""],[63832,1,""],[63833,1,""],[63834,1,""],[63835,1,""],[63836,1,""],[63837,1,""],[63838,1,""],[63839,1,""],[63840,1,""],[63841,1,""],[63842,1,""],[63843,1,""],[63844,1,""],[63845,1,""],[63846,1,""],[63847,1,""],[63848,1,""],[63849,1,""],[63850,1,""],[63851,1,""],[63852,1,""],[63853,1,""],[63854,1,""],[63855,1,""],[63856,1,""],[63857,1,""],[63858,1,""],[63859,1,""],[63860,1,""],[63861,1,""],[63862,1,""],[63863,1,""],[63864,1,""],[63865,1,""],[63866,1,""],[63867,1,""],[63868,1,""],[63869,1,""],[63870,1,""],[63871,1,""],[63872,1,""],[63873,1,""],[63874,1,""],[63875,1,""],[63876,1,""],[63877,1,""],[63878,1,""],[63879,1,""],[63880,1,""],[63881,1,""],[63882,1,""],[63883,1,""],[63884,1,""],[63885,1,""],[63886,1,""],[63887,1,""],[63888,1,""],[63889,1,""],[63890,1,""],[63891,1,""],[63892,1,""],[63893,1,""],[63894,1,""],[63895,1,""],[63896,1,""],[63897,1,""],[63898,1,""],[63899,1,""],[63900,1,""],[63901,1,""],[63902,1,""],[63903,1,""],[63904,1,""],[63905,1,""],[63906,1,""],[63907,1,""],[63908,1,""],[63909,1,""],[63910,1,""],[63911,1,""],[63912,1,""],[63913,1,""],[63914,1,""],[63915,1,""],[63916,1,""],[63917,1,""],[63918,1,""],[63919,1,""],[63920,1,""],[63921,1,""],[63922,1,""],[63923,1,""],[63924,1,""],[63925,1,""],[63926,1,""],[63927,1,""],[63928,1,""],[63929,1,""],[63930,1,""],[63931,1,""],[63932,1,""],[63933,1,""],[63934,1,""],[63935,1,""],[63936,1,""],[63937,1,""],[63938,1,""],[63939,1,""],[63940,1,""],[63941,1,""],[63942,1,""],[63943,1,""],[63944,1,""],[63945,1,""],[63946,1,""],[63947,1,""],[63948,1,""],[63949,1,""],[63950,1,""],[63951,1,""],[63952,1,""],[63953,1,""],[63954,1,""],[63955,1,""],[63956,1,""],[63957,1,""],[63958,1,""],[63959,1,""],[63960,1,""],[63961,1,""],[63962,1,""],[63963,1,""],[63964,1,""],[63965,1,""],[63966,1,""],[63967,1,""],[63968,1,""],[63969,1,""],[63970,1,""],[63971,1,""],[63972,1,""],[63973,1,""],[63974,1,""],[63975,1,""],[63976,1,""],[63977,1,""],[63978,1,""],[63979,1,""],[63980,1,""],[63981,1,""],[63982,1,""],[63983,1,""],[63984,1,""],[63985,1,""],[63986,1,""],[63987,1,""],[63988,1,""],[63989,1,""],[63990,1,""],[63991,1,""],[63992,1,""],[63993,1,""],[63994,1,""],[63995,1,""],[63996,1,""],[63997,1,""],[63998,1,""],[63999,1,""],[64000,1,""],[64001,1,""],[64002,1,""],[64003,1,""],[64004,1,""],[64005,1,""],[64006,1,""],[64007,1,""],[64008,1,""],[64009,1,""],[64010,1,""],[64011,1,""],[64012,1,""],[64013,1,""],[[64014,64015],2],[64016,1,""],[64017,2],[64018,1,""],[[64019,64020],2],[64021,1,""],[64022,1,""],[64023,1,""],[64024,1,""],[64025,1,""],[64026,1,""],[64027,1,""],[64028,1,""],[64029,1,""],[64030,1,""],[64031,2],[64032,1,""],[64033,2],[64034,1,""],[[64035,64036],2],[64037,1,""],[64038,1,""],[[64039,64041],2],[64042,1,""],[64043,1,""],[64044,1,""],[64045,1,""],[64046,1,""],[64047,1,""],[64048,1,""],[64049,1,""],[64050,1,""],[64051,1,""],[64052,1,""],[64053,1,""],[64054,1,""],[64055,1,""],[64056,1,""],[64057,1,""],[64058,1,""],[64059,1,""],[64060,1,""],[64061,1,""],[64062,1,""],[64063,1,""],[64064,1,""],[64065,1,""],[64066,1,""],[64067,1,""],[64068,1,""],[64069,1,""],[64070,1,""],[64071,1,""],[64072,1,""],[64073,1,""],[64074,1,""],[64075,1,""],[64076,1,""],[64077,1,""],[64078,1,""],[64079,1,""],[64080,1,""],[64081,1,""],[64082,1,""],[64083,1,""],[64084,1,""],[64085,1,""],[64086,1,""],[64087,1,""],[64088,1,""],[64089,1,""],[64090,1,""],[64091,1,""],[64092,1,""],[[64093,64094],1,""],[64095,1,""],[64096,1,""],[64097,1,""],[64098,1,""],[64099,1,""],[64100,1,""],[64101,1,""],[64102,1,""],[64103,1,""],[64104,1,""],[64105,1,""],[64106,1,""],[64107,1,""],[64108,1,""],[64109,1,""],[[64110,64111],3],[64112,1,""],[64113,1,""],[64114,1,""],[64115,1,""],[64116,1,""],[64117,1,""],[64118,1,""],[64119,1,""],[64120,1,""],[64121,1,""],[64122,1,""],[64123,1,""],[64124,1,""],[64125,1,""],[64126,1,""],[64127,1,""],[64128,1,""],[64129,1,""],[64130,1,""],[64131,1,""],[64132,1,""],[64133,1,""],[64134,1,""],[64135,1,""],[64136,1,""],[64137,1,""],[64138,1,""],[64139,1,""],[64140,1,""],[64141,1,""],[64142,1,""],[64143,1,""],[64144,1,""],[64145,1,""],[64146,1,""],[64147,1,""],[64148,1,""],[64149,1,""],[64150,1,""],[64151,1,""],[64152,1,""],[64153,1,""],[64154,1,""],[64155,1,""],[64156,1,""],[64157,1,""],[64158,1,""],[64159,1,""],[64160,1,""],[64161,1,""],[64162,1,""],[64163,1,""],[64164,1,""],[64165,1,""],[64166,1,""],[64167,1,""],[64168,1,""],[64169,1,""],[64170,1,""],[64171,1,""],[64172,1,""],[64173,1,""],[64174,1,""],[64175,1,""],[64176,1,""],[64177,1,""],[64178,1,""],[64179,1,""],[64180,1,""],[64181,1,""],[64182,1,""],[64183,1,""],[64184,1,""],[64185,1,""],[64186,1,""],[64187,1,""],[64188,1,""],[64189,1,""],[64190,1,""],[64191,1,""],[64192,1,""],[64193,1,""],[64194,1,""],[64195,1,""],[64196,1,""],[64197,1,""],[64198,1,""],[64199,1,""],[64200,1,""],[64201,1,""],[64202,1,""],[64203,1,""],[64204,1,""],[64205,1,""],[64206,1,""],[64207,1,""],[64208,1,""],[64209,1,""],[64210,1,""],[64211,1,""],[64212,1,""],[64213,1,""],[64214,1,""],[64215,1,""],[64216,1,""],[64217,1,""],[[64218,64255],3],[64256,1,"ff"],[64257,1,"fi"],[64258,1,"fl"],[64259,1,"ffi"],[64260,1,"ffl"],[[64261,64262],1,"st"],[[64263,64274],3],[64275,1,""],[64276,1,""],[64277,1,""],[64278,1,""],[64279,1,""],[[64280,64284],3],[64285,1,""],[64286,2],[64287,1,""],[64288,1,""],[64289,1,""],[64290,1,""],[64291,1,""],[64292,1,""],[64293,1,""],[64294,1,""],[64295,1,""],[64296,1,""],[64297,1,"+"],[64298,1,""],[64299,1,""],[64300,1,""],[64301,1,""],[64302,1,""],[64303,1,""],[64304,1,""],[64305,1,""],[64306,1,""],[64307,1,""],[64308,1,""],[64309,1,""],[64310,1,""],[64311,3],[64312,1,""],[64313,1,""],[64314,1,""],[64315,1,""],[64316,1,""],[64317,3],[64318,1,""],[64319,3],[64320,1,""],[64321,1,""],[64322,3],[64323,1,""],[64324,1,""],[64325,3],[64326,1,""],[64327,1,""],[64328,1,""],[64329,1,""],[64330,1,""],[64331,1,""],[64332,1,""],[64333,1,""],[64334,1,""],[64335,1,""],[[64336,64337],1,""],[[64338,64341],1,""],[[64342,64345],1,""],[[64346,64349],1,""],[[64350,64353],1,""],[[64354,64357],1,""],[[64358,64361],1,""],[[64362,64365],1,""],[[64366,64369],1,""],[[64370,64373],1,""],[[64374,64377],1,""],[[64378,64381],1,""],[[64382,64385],1,""],[[64386,64387],1,""],[[64388,64389],1,""],[[64390,64391],1,""],[[64392,64393],1,""],[[64394,64395],1,""],[[64396,64397],1,""],[[64398,64401],1,""],[[64402,64405],1,""],[[64406,64409],1,""],[[64410,64413],1,""],[[64414,64415],1,""],[[64416,64419],1,""],[[64420,64421],1,""],[[64422,64425],1,""],[[64426,64429],1,""],[[64430,64431],1,""],[[64432,64433],1,""],[[64434,64449],2],[64450,2],[[64451,64466],3],[[64467,64470],1,""],[[64471,64472],1,""],[[64473,64474],1,""],[[64475,64476],1,""],[64477,1,""],[[64478,64479],1,""],[[64480,64481],1,""],[[64482,64483],1,""],[[64484,64487],1,""],[[64488,64489],1,""],[[64490,64491],1,""],[[64492,64493],1,""],[[64494,64495],1,""],[[64496,64497],1,""],[[64498,64499],1,""],[[64500,64501],1,""],[[64502,64504],1,""],[[64505,64507],1,""],[[64508,64511],1,""],[64512,1,""],[64513,1,""],[64514,1,""],[64515,1,""],[64516,1,""],[64517,1,""],[64518,1,""],[64519,1,""],[64520,1,""],[64521,1,""],[64522,1,""],[64523,1,""],[64524,1,""],[64525,1,""],[64526,1,""],[64527,1,""],[64528,1,""],[64529,1,""],[64530,1,""],[64531,1,""],[64532,1,""],[64533,1,""],[64534,1,""],[64535,1,""],[64536,1,""],[64537,1,""],[64538,1,""],[64539,1,""],[64540,1,""],[64541,1,""],[64542,1,""],[64543,1,""],[64544,1,""],[64545,1,""],[64546,1,""],[64547,1,""],[64548,1,""],[64549,1,""],[64550,1,""],[64551,1,""],[64552,1,""],[64553,1,""],[64554,1,""],[64555,1,""],[64556,1,""],[64557,1,""],[64558,1,""],[64559,1,""],[64560,1,""],[64561,1,""],[64562,1,""],[64563,1,""],[64564,1,""],[64565,1,""],[64566,1,""],[64567,1,""],[64568,1,""],[64569,1,""],[64570,1,""],[64571,1,""],[64572,1,""],[64573,1,""],[64574,1,""],[64575,1,""],[64576,1,""],[64577,1,""],[64578,1,""],[64579,1,""],[64580,1,""],[64581,1,""],[64582,1,""],[64583,1,""],[64584,1,""],[64585,1,""],[64586,1,""],[64587,1,""],[64588,1,""],[64589,1,""],[64590,1,""],[64591,1,""],[64592,1,""],[64593,1,""],[64594,1,""],[64595,1,""],[64596,1,""],[64597,1,""],[64598,1,""],[64599,1,""],[64600,1,""],[64601,1,""],[64602,1,""],[64603,1,""],[64604,1,""],[64605,1,""],[64606,1," "],[64607,1," "],[64608,1," "],[64609,1," "],[64610,1," "],[64611,1," "],[64612,1,""],[64613,1,""],[64614,1,""],[64615,1,""],[64616,1,""],[64617,1,""],[64618,1,""],[64619,1,""],[64620,1,""],[64621,1,""],[64622,1,""],[64623,1,""],[64624,1,""],[64625,1,""],[64626,1,""],[64627,1,""],[64628,1,""],[64629,1,""],[64630,1,""],[64631,1,""],[64632,1,""],[64633,1,""],[64634,1,""],[64635,1,""],[64636,1,""],[64637,1,""],[64638,1,""],[64639,1,""],[64640,1,""],[64641,1,""],[64642,1,""],[64643,1,""],[64644,1,""],[64645,1,""],[64646,1,""],[64647,1,""],[64648,1,""],[64649,1,""],[64650,1,""],[64651,1,""],[64652,1,""],[64653,1,""],[64654,1,""],[64655,1,""],[64656,1,""],[64657,1,""],[64658,1,""],[64659,1,""],[64660,1,""],[64661,1,""],[64662,1,""],[64663,1,""],[64664,1,""],[64665,1,""],[64666,1,""],[64667,1,""],[64668,1,""],[64669,1,""],[64670,1,""],[64671,1,""],[64672,1,""],[64673,1,""],[64674,1,""],[64675,1,""],[64676,1,""],[64677,1,""],[64678,1,""],[64679,1,""],[64680,1,""],[64681,1,""],[64682,1,""],[64683,1,""],[64684,1,""],[64685,1,""],[64686,1,""],[64687,1,""],[64688,1,""],[64689,1,""],[64690,1,""],[64691,1,""],[64692,1,""],[64693,1,""],[64694,1,""],[64695,1,""],[64696,1,""],[64697,1,""],[64698,1,""],[64699,1,""],[64700,1,""],[64701,1,""],[64702,1,""],[64703,1,""],[64704,1,""],[64705,1,""],[64706,1,""],[64707,1,""],[64708,1,""],[64709,1,""],[64710,1,""],[64711,1,""],[64712,1,""],[64713,1,""],[64714,1,""],[64715,1,""],[64716,1,""],[64717,1,""],[64718,1,""],[64719,1,""],[64720,1,""],[64721,1,""],[64722,1,""],[64723,1,""],[64724,1,""],[64725,1,""],[64726,1,""],[64727,1,""],[64728,1,""],[64729,1,""],[64730,1,""],[64731,1,""],[64732,1,""],[64733,1,""],[64734,1,""],[64735,1,""],[64736,1,""],[64737,1,""],[64738,1,""],[64739,1,""],[64740,1,""],[64741,1,""],[64742,1,""],[64743,1,""],[64744,1,""],[64745,1,""],[64746,1,""],[64747,1,""],[64748,1,""],[64749,1,""],[64750,1,""],[64751,1,""],[64752,1,""],[64753,1,""],[64754,1,""],[64755,1,""],[64756,1,""],[64757,1,""],[64758,1,""],[64759,1,""],[64760,1,""],[64761,1,""],[64762,1,""],[64763,1,""],[64764,1,""],[64765,1,""],[64766,1,""],[64767,1,""],[64768,1,""],[64769,1,""],[64770,1,""],[64771,1,""],[64772,1,""],[64773,1,""],[64774,1,""],[64775,1,""],[64776,1,""],[64777,1,""],[64778,1,""],[64779,1,""],[64780,1,""],[64781,1,""],[64782,1,""],[64783,1,""],[64784,1,""],[64785,1,""],[64786,1,""],[64787,1,""],[64788,1,""],[64789,1,""],[64790,1,""],[64791,1,""],[64792,1,""],[64793,1,""],[64794,1,""],[64795,1,""],[64796,1,""],[64797,1,""],[64798,1,""],[64799,1,""],[64800,1,""],[64801,1,""],[64802,1,""],[64803,1,""],[64804,1,""],[64805,1,""],[64806,1,""],[64807,1,""],[64808,1,""],[64809,1,""],[64810,1,""],[64811,1,""],[64812,1,""],[64813,1,""],[64814,1,""],[64815,1,""],[64816,1,""],[64817,1,""],[64818,1,""],[64819,1,""],[64820,1,""],[64821,1,""],[64822,1,""],[64823,1,""],[64824,1,""],[64825,1,""],[64826,1,""],[64827,1,""],[[64828,64829],1,""],[[64830,64831],2],[[64832,64847],2],[64848,1,""],[[64849,64850],1,""],[64851,1,""],[64852,1,""],[64853,1,""],[64854,1,""],[64855,1,""],[[64856,64857],1,""],[64858,1,""],[64859,1,""],[64860,1,""],[64861,1,""],[64862,1,""],[[64863,64864],1,""],[64865,1,""],[[64866,64867],1,""],[[64868,64869],1,""],[64870,1,""],[[64871,64872],1,""],[64873,1,""],[[64874,64875],1,""],[[64876,64877],1,""],[64878,1,""],[[64879,64880],1,""],[[64881,64882],1,""],[64883,1,""],[64884,1,""],[64885,1,""],[[64886,64887],1,""],[64888,1,""],[64889,1,""],[64890,1,""],[64891,1,""],[[64892,64893],1,""],[64894,1,""],[64895,1,""],[64896,1,""],[64897,1,""],[64898,1,""],[[64899,64900],1,""],[[64901,64902],1,""],[[64903,64904],1,""],[64905,1,""],[64906,1,""],[64907,1,""],[64908,1,""],[64909,1,""],[64910,1,""],[64911,1,""],[[64912,64913],3],[64914,1,""],[64915,1,""],[64916,1,""],[64917,1,""],[64918,1,""],[[64919,64920],1,""],[64921,1,""],[64922,1,""],[64923,1,""],[[64924,64925],1,""],[64926,1,""],[64927,1,""],[64928,1,""],[64929,1,""],[64930,1,""],[64931,1,""],[64932,1,""],[64933,1,""],[64934,1,""],[64935,1,""],[64936,1,""],[64937,1,""],[64938,1,""],[64939,1,""],[64940,1,""],[64941,1,""],[64942,1,""],[64943,1,""],[64944,1,""],[64945,1,""],[64946,1,""],[64947,1,""],[64948,1,""],[64949,1,""],[64950,1,""],[64951,1,""],[64952,1,""],[64953,1,""],[64954,1,""],[64955,1,""],[64956,1,""],[64957,1,""],[64958,1,""],[64959,1,""],[64960,1,""],[64961,1,""],[64962,1,""],[64963,1,""],[64964,1,""],[64965,1,""],[64966,1,""],[64967,1,""],[[64968,64974],3],[64975,2],[[64976,65007],3],[65008,1,""],[65009,1,""],[65010,1,""],[65011,1,""],[65012,1,""],[65013,1,""],[65014,1,""],[65015,1,""],[65016,1,""],[65017,1,""],[65018,1,"   "],[65019,1," "],[65020,1,""],[65021,2],[[65022,65023],2],[[65024,65039],7],[65040,1,","],[65041,1,""],[65042,3],[65043,1,":"],[65044,1,";"],[65045,1,"!"],[65046,1,"?"],[65047,1,""],[65048,1,""],[65049,3],[[65050,65055],3],[[65056,65059],2],[[65060,65062],2],[[65063,65069],2],[[65070,65071],2],[65072,3],[65073,1,""],[65074,1,""],[[65075,65076],1,"_"],[65077,1,"("],[65078,1,")"],[65079,1,"{"],[65080,1,"}"],[65081,1,""],[65082,1,""],[65083,1,""],[65084,1,""],[65085,1,""],[65086,1,""],[65087,1,""],[65088,1,""],[65089,1,""],[65090,1,""],[65091,1,""],[65092,1,""],[[65093,65094],2],[65095,1,"["],[65096,1,"]"],[[65097,65100],1," "],[[65101,65103],1,"_"],[65104,1,","],[65105,1,""],[65106,3],[65107,3],[65108,1,";"],[65109,1,":"],[65110,1,"?"],[65111,1,"!"],[65112,1,""],[65113,1,"("],[65114,1,")"],[65115,1,"{"],[65116,1,"}"],[65117,1,""],[65118,1,""],[65119,1,"#"],[65120,1,"&"],[65121,1,"*"],[65122,1,"+"],[65123,1,"-"],[65124,1,"<"],[65125,1,">"],[65126,1,"="],[65127,3],[65128,1,"\\\\"],[65129,1,"$"],[65130,1,"%"],[65131,1,"@"],[[65132,65135],3],[65136,1," "],[65137,1,""],[65138,1," "],[65139,2],[65140,1," "],[65141,3],[65142,1," "],[65143,1,""],[65144,1," "],[65145,1,""],[65146,1," "],[65147,1,""],[65148,1," "],[65149,1,""],[65150,1," "],[65151,1,""],[65152,1,""],[[65153,65154],1,""],[[65155,65156],1,""],[[65157,65158],1,""],[[65159,65160],1,""],[[65161,65164],1,""],[[65165,65166],1,""],[[65167,65170],1,""],[[65171,65172],1,""],[[65173,65176],1,""],[[65177,65180],1,""],[[65181,65184],1,""],[[65185,65188],1,""],[[65189,65192],1,""],[[65193,65194],1,""],[[65195,65196],1,""],[[65197,65198],1,""],[[65199,65200],1,""],[[65201,65204],1,""],[[65205,65208],1,""],[[65209,65212],1,""],[[65213,65216],1,""],[[65217,65220],1,""],[[65221,65224],1,""],[[65225,65228],1,""],[[65229,65232],1,""],[[65233,65236],1,""],[[65237,65240],1,""],[[65241,65244],1,""],[[65245,65248],1,""],[[65249,65252],1,""],[[65253,65256],1,""],[[65257,65260],1,""],[[65261,65262],1,""],[[65263,65264],1,""],[[65265,65268],1,""],[[65269,65270],1,""],[[65271,65272],1,""],[[65273,65274],1,""],[[65275,65276],1,""],[[65277,65278],3],[65279,7],[65280,3],[65281,1,"!"],[65282,1,"\\""],[65283,1,"#"],[65284,1,"$"],[65285,1,"%"],[65286,1,"&"],[65287,1,"\'"],[65288,1,"("],[65289,1,")"],[65290,1,"*"],[65291,1,"+"],[65292,1,","],[65293,1,"-"],[65294,1,"."],[65295,1,"/"],[65296,1,"0"],[65297,1,"1"],[65298,1,"2"],[65299,1,"3"],[65300,1,"4"],[65301,1,"5"],[65302,1,"6"],[65303,1,"7"],[65304,1,"8"],[65305,1,"9"],[65306,1,":"],[65307,1,";"],[65308,1,"<"],[65309,1,"="],[65310,1,">"],[65311,1,"?"],[65312,1,"@"],[65313,1,"a"],[65314,1,"b"],[65315,1,"c"],[65316,1,"d"],[65317,1,"e"],[65318,1,"f"],[65319,1,"g"],[65320,1,"h"],[65321,1,"i"],[65322,1,"j"],[65323,1,"k"],[65324,1,"l"],[65325,1,"m"],[65326,1,"n"],[65327,1,"o"],[65328,1,"p"],[65329,1,"q"],[65330,1,"r"],[65331,1,"s"],[65332,1,"t"],[65333,1,"u"],[65334,1,"v"],[65335,1,"w"],[65336,1,"x"],[65337,1,"y"],[65338,1,"z"],[65339,1,"["],[65340,1,"\\\\"],[65341,1,"]"],[65342,1,"^"],[65343,1,"_"],[65344,1,"`"],[65345,1,"a"],[65346,1,"b"],[65347,1,"c"],[65348,1,"d"],[65349,1,"e"],[65350,1,"f"],[65351,1,"g"],[65352,1,"h"],[65353,1,"i"],[65354,1,"j"],[65355,1,"k"],[65356,1,"l"],[65357,1,"m"],[65358,1,"n"],[65359,1,"o"],[65360,1,"p"],[65361,1,"q"],[65362,1,"r"],[65363,1,"s"],[65364,1,"t"],[65365,1,"u"],[65366,1,"v"],[65367,1,"w"],[65368,1,"x"],[65369,1,"y"],[65370,1,"z"],[65371,1,"{"],[65372,1,"|"],[65373,1,"}"],[65374,1,"~"],[65375,1,""],[65376,1,""],[65377,1,"."],[65378,1,""],[65379,1,""],[65380,1,""],[65381,1,""],[65382,1,""],[65383,1,""],[65384,1,""],[65385,1,""],[65386,1,""],[65387,1,""],[65388,1,""],[65389,1,""],[65390,1,""],[65391,1,""],[65392,1,""],[65393,1,""],[65394,1,""],[65395,1,""],[65396,1,""],[65397,1,""],[65398,1,""],[65399,1,""],[65400,1,""],[65401,1,""],[65402,1,""],[65403,1,""],[65404,1,""],[65405,1,""],[65406,1,""],[65407,1,""],[65408,1,""],[65409,1,""],[65410,1,""],[65411,1,""],[65412,1,""],[65413,1,""],[65414,1,""],[65415,1,""],[65416,1,""],[65417,1,""],[65418,1,""],[65419,1,""],[65420,1,""],[65421,1,""],[65422,1,""],[65423,1,""],[65424,1,""],[65425,1,""],[65426,1,""],[65427,1,""],[65428,1,""],[65429,1,""],[65430,1,""],[65431,1,""],[65432,1,""],[65433,1,""],[65434,1,""],[65435,1,""],[65436,1,""],[65437,1,""],[65438,1,""],[65439,1,""],[65440,7],[65441,1,""],[65442,1,""],[65443,1,""],[65444,1,""],[65445,1,""],[65446,1,""],[65447,1,""],[65448,1,""],[65449,1,""],[65450,1,""],[65451,1,""],[65452,1,""],[65453,1,""],[65454,1,""],[65455,1,""],[65456,1,""],[65457,1,""],[65458,1,""],[65459,1,""],[65460,1,""],[65461,1,""],[65462,1,""],[65463,1,""],[65464,1,""],[65465,1,""],[65466,1,""],[65467,1,""],[65468,1,""],[65469,1,""],[65470,1,""],[[65471,65473],3],[65474,1,""],[65475,1,""],[65476,1,""],[65477,1,""],[65478,1,""],[65479,1,""],[[65480,65481],3],[65482,1,""],[65483,1,""],[65484,1,""],[65485,1,""],[65486,1,""],[65487,1,""],[[65488,65489],3],[65490,1,""],[65491,1,""],[65492,1,""],[65493,1,""],[65494,1,""],[65495,1,""],[[65496,65497],3],[65498,1,""],[65499,1,""],[65500,1,""],[[65501,65503],3],[65504,1,""],[65505,1,""],[65506,1,""],[65507,1," "],[65508,1,""],[65509,1,""],[65510,1,""],[65511,3],[65512,1,""],[65513,1,""],[65514,1,""],[65515,1,""],[65516,1,""],[65517,1,""],[65518,1,""],[[65519,65528],3],[[65529,65531],3],[65532,3],[65533,3],[[65534,65535],3],[[65536,65547],2],[65548,3],[[65549,65574],2],[65575,3],[[65576,65594],2],[65595,3],[[65596,65597],2],[65598,3],[[65599,65613],2],[[65614,65615],3],[[65616,65629],2],[[65630,65663],3],[[65664,65786],2],[[65787,65791],3],[[65792,65794],2],[[65795,65798],3],[[65799,65843],2],[[65844,65846],3],[[65847,65855],2],[[65856,65930],2],[[65931,65932],2],[[65933,65934],2],[65935,3],[[65936,65947],2],[65948,2],[[65949,65951],3],[65952,2],[[65953,65999],3],[[66000,66044],2],[66045,2],[[66046,66175],3],[[66176,66204],2],[[66205,66207],3],[[66208,66256],2],[[66257,66271],3],[66272,2],[[66273,66299],2],[[66300,66303],3],[[66304,66334],2],[66335,2],[[66336,66339],2],[[66340,66348],3],[[66349,66351],2],[[66352,66368],2],[66369,2],[[66370,66377],2],[66378,2],[[66379,66383],3],[[66384,66426],2],[[66427,66431],3],[[66432,66461],2],[66462,3],[66463,2],[[66464,66499],2],[[66500,66503],3],[[66504,66511],2],[[66512,66517],2],[[66518,66559],3],[66560,1,""],[66561,1,""],[66562,1,""],[66563,1,""],[66564,1,""],[66565,1,""],[66566,1,""],[66567,1,""],[66568,1,""],[66569,1,""],[66570,1,""],[66571,1,""],[66572,1,""],[66573,1,""],[66574,1,""],[66575,1,""],[66576,1,""],[66577,1,""],[66578,1,""],[66579,1,""],[66580,1,""],[66581,1,""],[66582,1,""],[66583,1,""],[66584,1,""],[66585,1,""],[66586,1,""],[66587,1,""],[66588,1,""],[66589,1,""],[66590,1,""],[66591,1,""],[66592,1,""],[66593,1,""],[66594,1,""],[66595,1,""],[66596,1,""],[66597,1,""],[66598,1,""],[66599,1,""],[[66600,66637],2],[[66638,66717],2],[[66718,66719],3],[[66720,66729],2],[[66730,66735],3],[66736,1,""],[66737,1,""],[66738,1,""],[66739,1,""],[66740,1,""],[66741,1,""],[66742,1,""],[66743,1,""],[66744,1,""],[66745,1,""],[66746,1,""],[66747,1,""],[66748,1,""],[66749,1,""],[66750,1,""],[66751,1,""],[66752,1,""],[66753,1,""],[66754,1,""],[66755,1,""],[66756,1,""],[66757,1,""],[66758,1,""],[66759,1,""],[66760,1,""],[66761,1,""],[66762,1,""],[66763,1,""],[66764,1,""],[66765,1,""],[66766,1,""],[66767,1,""],[66768,1,""],[66769,1,""],[66770,1,""],[66771,1,""],[[66772,66775],3],[[66776,66811],2],[[66812,66815],3],[[66816,66855],2],[[66856,66863],3],[[66864,66915],2],[[66916,66926],3],[66927,2],[66928,1,""],[66929,1,""],[66930,1,""],[66931,1,""],[66932,1,""],[66933,1,""],[66934,1,""],[66935,1,""],[66936,1,""],[66937,1,""],[66938,1,""],[66939,3],[66940,1,""],[66941,1,""],[66942,1,""],[66943,1,""],[66944,1,""],[66945,1,""],[66946,1,""],[66947,1,""],[66948,1,""],[66949,1,""],[66950,1,""],[66951,1,""],[66952,1,""],[66953,1,""],[66954,1,""],[66955,3],[66956,1,""],[66957,1,""],[66958,1,""],[66959,1,""],[66960,1,""],[66961,1,""],[66962,1,""],[66963,3],[66964,1,""],[66965,1,""],[66966,3],[[66967,66977],2],[66978,3],[[66979,66993],2],[66994,3],[[66995,67001],2],[67002,3],[[67003,67004],2],[[67005,67007],3],[[67008,67059],2],[[67060,67071],3],[[67072,67382],2],[[67383,67391],3],[[67392,67413],2],[[67414,67423],3],[[67424,67431],2],[[67432,67455],3],[67456,2],[67457,1,""],[67458,1,""],[67459,1,""],[67460,1,""],[67461,1,""],[67462,3],[67463,1,""],[67464,1,""],[67465,1,""],[67466,1,""],[67467,1,""],[67468,1,""],[67469,1,""],[67470,1,""],[67471,1,""],[67472,1,""],[67473,1,""],[67474,1,""],[67475,1,""],[67476,1,""],[67477,1,""],[67478,1,""],[67479,1,""],[67480,1,""],[67481,1,""],[67482,1,""],[67483,1,""],[67484,1,""],[67485,1,""],[67486,1,""],[67487,1,""],[67488,1,""],[67489,1,""],[67490,1,""],[67491,1,""],[67492,1,""],[67493,1,"q"],[67494,1,""],[67495,1,""],[67496,1,""],[67497,1,""],[67498,1,""],[67499,1,""],[67500,1,""],[67501,1,""],[67502,1,""],[67503,1,""],[67504,1,""],[67505,3],[67506,1,""],[67507,1,""],[67508,1,""],[67509,1,""],[67510,1,""],[67511,1,""],[67512,1,""],[67513,1,""],[67514,1,""],[[67515,67583],3],[[67584,67589],2],[[67590,67591],3],[67592,2],[67593,3],[[67594,67637],2],[67638,3],[[67639,67640],2],[[67641,67643],3],[67644,2],[[67645,67646],3],[67647,2],[[67648,67669],2],[67670,3],[[67671,67679],2],[[67680,67702],2],[[67703,67711],2],[[67712,67742],2],[[67743,67750],3],[[67751,67759],2],[[67760,67807],3],[[67808,67826],2],[67827,3],[[67828,67829],2],[[67830,67834],3],[[67835,67839],2],[[67840,67861],2],[[67862,67865],2],[[67866,67867],2],[[67868,67870],3],[67871,2],[[67872,67897],2],[[67898,67902],3],[67903,2],[[67904,67967],3],[[67968,68023],2],[[68024,68027],3],[[68028,68029],2],[[68030,68031],2],[[68032,68047],2],[[68048,68049],3],[[68050,68095],2],[[68096,68099],2],[68100,3],[[68101,68102],2],[[68103,68107],3],[[68108,68115],2],[68116,3],[[68117,68119],2],[68120,3],[[68121,68147],2],[[68148,68149],2],[[68150,68151],3],[[68152,68154],2],[[68155,68158],3],[68159,2],[[68160,68167],2],[68168,2],[[68169,68175],3],[[68176,68184],2],[[68185,68191],3],[[68192,68220],2],[[68221,68223],2],[[68224,68252],2],[[68253,68255],2],[[68256,68287],3],[[68288,68295],2],[68296,2],[[68297,68326],2],[[68327,68330],3],[[68331,68342],2],[[68343,68351],3],[[68352,68405],2],[[68406,68408],3],[[68409,68415],2],[[68416,68437],2],[[68438,68439],3],[[68440,68447],2],[[68448,68466],2],[[68467,68471],3],[[68472,68479],2],[[68480,68497],2],[[68498,68504],3],[[68505,68508],2],[[68509,68520],3],[[68521,68527],2],[[68528,68607],3],[[68608,68680],2],[[68681,68735],3],[68736,1,""],[68737,1,""],[68738,1,""],[68739,1,""],[68740,1,""],[68741,1,""],[68742,1,""],[68743,1,""],[68744,1,""],[68745,1,""],[68746,1,""],[68747,1,""],[68748,1,""],[68749,1,""],[68750,1,""],[68751,1,""],[68752,1,""],[68753,1,""],[68754,1,""],[68755,1,""],[68756,1,""],[68757,1,""],[68758,1,""],[68759,1,""],[68760,1,""],[68761,1,""],[68762,1,""],[68763,1,""],[68764,1,""],[68765,1,""],[68766,1,""],[68767,1,""],[68768,1,""],[68769,1,""],[68770,1,""],[68771,1,""],[68772,1,""],[68773,1,""],[68774,1,""],[68775,1,""],[68776,1,""],[68777,1,""],[68778,1,""],[68779,1,""],[68780,1,""],[68781,1,""],[68782,1,""],[68783,1,""],[68784,1,""],[68785,1,""],[68786,1,""],[[68787,68799],3],[[68800,68850],2],[[68851,68857],3],[[68858,68863],2],[[68864,68903],2],[[68904,68911],3],[[68912,68921],2],[[68922,68927],3],[[68928,68943],2],[68944,1,""],[68945,1,""],[68946,1,""],[68947,1,""],[68948,1,""],[68949,1,""],[68950,1,""],[68951,1,""],[68952,1,""],[68953,1,""],[68954,1,""],[68955,1,""],[68956,1,""],[68957,1,""],[68958,1,""],[68959,1,""],[68960,1,""],[68961,1,""],[68962,1,""],[68963,1,""],[68964,1,""],[68965,1,""],[[68966,68968],3],[[68969,68973],2],[68974,2],[[68975,68997],2],[[68998,69005],3],[[69006,69007],2],[[69008,69215],3],[[69216,69246],2],[69247,3],[[69248,69289],2],[69290,3],[[69291,69292],2],[69293,2],[[69294,69295],3],[[69296,69297],2],[[69298,69313],3],[[69314,69316],2],[[69317,69371],3],[69372,2],[[69373,69375],2],[[69376,69404],2],[[69405,69414],2],[69415,2],[[69416,69423],3],[[69424,69456],2],[[69457,69465],2],[[69466,69487],3],[[69488,69509],2],[[69510,69513],2],[[69514,69551],3],[[69552,69572],2],[[69573,69579],2],[[69580,69599],3],[[69600,69622],2],[[69623,69631],3],[[69632,69702],2],[[69703,69709],2],[[69710,69713],3],[[69714,69733],2],[[69734,69743],2],[[69744,69749],2],[[69750,69758],3],[69759,2],[[69760,69818],2],[[69819,69820],2],[69821,3],[[69822,69825],2],[69826,2],[[69827,69836],3],[69837,3],[[69838,69839],3],[[69840,69864],2],[[69865,69871],3],[[69872,69881],2],[[69882,69887],3],[[69888,69940],2],[69941,3],[[69942,69951],2],[[69952,69955],2],[[69956,69958],2],[69959,2],[[69960,69967],3],[[69968,70003],2],[[70004,70005],2],[70006,2],[[70007,70015],3],[[70016,70084],2],[[70085,70088],2],[[70089,70092],2],[70093,2],[[70094,70095],2],[[70096,70105],2],[70106,2],[70107,2],[70108,2],[[70109,70111],2],[70112,3],[[70113,70132],2],[[70133,70143],3],[[70144,70161],2],[70162,3],[[70163,70199],2],[[70200,70205],2],[70206,2],[[70207,70209],2],[[70210,70271],3],[[70272,70278],2],[70279,3],[70280,2],[70281,3],[[70282,70285],2],[70286,3],[[70287,70301],2],[70302,3],[[70303,70312],2],[70313,2],[[70314,70319],3],[[70320,70378],2],[[70379,70383],3],[[70384,70393],2],[[70394,70399],3],[70400,2],[[70401,70403],2],[70404,3],[[70405,70412],2],[[70413,70414],3],[[70415,70416],2],[[70417,70418],3],[[70419,70440],2],[70441,3],[[70442,70448],2],[70449,3],[[70450,70451],2],[70452,3],[[70453,70457],2],[70458,3],[70459,2],[[70460,70468],2],[[70469,70470],3],[[70471,70472],2],[[70473,70474],3],[[70475,70477],2],[[70478,70479],3],[70480,2],[[70481,70486],3],[70487,2],[[70488,70492],3],[[70493,70499],2],[[70500,70501],3],[[70502,70508],2],[[70509,70511],3],[[70512,70516],2],[[70517,70527],3],[[70528,70537],2],[70538,3],[70539,2],[[70540,70541],3],[70542,2],[70543,3],[[70544,70581],2],[70582,3],[[70583,70592],2],[70593,3],[70594,2],[[70595,70596],3],[70597,2],[70598,3],[[70599,70602],2],[70603,3],[[70604,70611],2],[[70612,70613],2],[70614,3],[[70615,70616],2],[[70617,70624],3],[[70625,70626],2],[[70627,70655],3],[[70656,70730],2],[[70731,70735],2],[[70736,70745],2],[70746,2],[70747,2],[70748,3],[70749,2],[70750,2],[70751,2],[[70752,70753],2],[[70754,70783],3],[[70784,70853],2],[70854,2],[70855,2],[[70856,70863],3],[[70864,70873],2],[[70874,71039],3],[[71040,71093],2],[[71094,71095],3],[[71096,71104],2],[[71105,71113],2],[[71114,71127],2],[[71128,71133],2],[[71134,71167],3],[[71168,71232],2],[[71233,71235],2],[71236,2],[[71237,71247],3],[[71248,71257],2],[[71258,71263],3],[[71264,71276],2],[[71277,71295],3],[[71296,71351],2],[71352,2],[71353,2],[[71354,71359],3],[[71360,71369],2],[[71370,71375],3],[[71376,71395],2],[[71396,71423],3],[[71424,71449],2],[71450,2],[[71451,71452],3],[[71453,71467],2],[[71468,71471],3],[[71472,71481],2],[[71482,71487],2],[[71488,71494],2],[[71495,71679],3],[[71680,71738],2],[71739,2],[[71740,71839],3],[71840,1,""],[71841,1,""],[71842,1,""],[71843,1,""],[71844,1,""],[71845,1,""],[71846,1,""],[71847,1,""],[71848,1,""],[71849,1,""],[71850,1,""],[71851,1,""],[71852,1,""],[71853,1,""],[71854,1,""],[71855,1,""],[71856,1,""],[71857,1,""],[71858,1,""],[71859,1,""],[71860,1,""],[71861,1,""],[71862,1,""],[71863,1,""],[71864,1,""],[71865,1,""],[71866,1,""],[71867,1,""],[71868,1,""],[71869,1,""],[71870,1,""],[71871,1,""],[[71872,71913],2],[[71914,71922],2],[[71923,71934],3],[71935,2],[[71936,71942],2],[[71943,71944],3],[71945,2],[[71946,71947],3],[[71948,71955],2],[71956,3],[[71957,71958],2],[71959,3],[[71960,71989],2],[71990,3],[[71991,71992],2],[[71993,71994],3],[[71995,72003],2],[[72004,72006],2],[[72007,72015],3],[[72016,72025],2],[[72026,72095],3],[[72096,72103],2],[[72104,72105],3],[[72106,72151],2],[[72152,72153],3],[[72154,72161],2],[72162,2],[[72163,72164],2],[[72165,72191],3],[[72192,72254],2],[[72255,72262],2],[72263,2],[[72264,72271],3],[[72272,72323],2],[[72324,72325],2],[[72326,72345],2],[[72346,72348],2],[72349,2],[[72350,72354],2],[[72355,72367],3],[[72368,72383],2],[[72384,72440],2],[[72441,72447],3],[[72448,72457],2],[[72458,72639],3],[[72640,72672],2],[72673,2],[[72674,72687],3],[[72688,72697],2],[[72698,72703],3],[[72704,72712],2],[72713,3],[[72714,72758],2],[72759,3],[[72760,72768],2],[[72769,72773],2],[[72774,72783],3],[[72784,72793],2],[[72794,72812],2],[[72813,72815],3],[[72816,72817],2],[[72818,72847],2],[[72848,72849],3],[[72850,72871],2],[72872,3],[[72873,72886],2],[[72887,72959],3],[[72960,72966],2],[72967,3],[[72968,72969],2],[72970,3],[[72971,73014],2],[[73015,73017],3],[73018,2],[73019,3],[[73020,73021],2],[73022,3],[[73023,73031],2],[[73032,73039],3],[[73040,73049],2],[[73050,73055],3],[[73056,73061],2],[73062,3],[[73063,73064],2],[73065,3],[[73066,73102],2],[73103,3],[[73104,73105],2],[73106,3],[[73107,73112],2],[[73113,73119],3],[[73120,73129],2],[[73130,73439],3],[[73440,73462],2],[[73463,73464],2],[[73465,73471],3],[[73472,73488],2],[73489,3],[[73490,73530],2],[[73531,73533],3],[[73534,73538],2],[[73539,73551],2],[[73552,73561],2],[73562,2],[[73563,73647],3],[73648,2],[[73649,73663],3],[[73664,73713],2],[[73714,73726],3],[73727,2],[[73728,74606],2],[[74607,74648],2],[74649,2],[[74650,74751],3],[[74752,74850],2],[[74851,74862],2],[74863,3],[[74864,74867],2],[74868,2],[[74869,74879],3],[[74880,75075],2],[[75076,77711],3],[[77712,77808],2],[[77809,77810],2],[[77811,77823],3],[[77824,78894],2],[78895,2],[[78896,78904],3],[[78905,78911],3],[[78912,78933],2],[[78934,78943],3],[[78944,82938],2],[[82939,82943],3],[[82944,83526],2],[[83527,90367],3],[[90368,90425],2],[[90426,92159],3],[[92160,92728],2],[[92729,92735],3],[[92736,92766],2],[92767,3],[[92768,92777],2],[[92778,92781],3],[[92782,92783],2],[[92784,92862],2],[92863,3],[[92864,92873],2],[[92874,92879],3],[[92880,92909],2],[[92910,92911],3],[[92912,92916],2],[92917,2],[[92918,92927],3],[[92928,92982],2],[[92983,92991],2],[[92992,92995],2],[[92996,92997],2],[[92998,93007],3],[[93008,93017],2],[93018,3],[[93019,93025],2],[93026,3],[[93027,93047],2],[[93048,93052],3],[[93053,93071],2],[[93072,93503],3],[[93504,93548],2],[[93549,93551],2],[[93552,93561],2],[[93562,93759],3],[93760,1,""],[93761,1,""],[93762,1,""],[93763,1,""],[93764,1,""],[93765,1,""],[93766,1,""],[93767,1,""],[93768,1,""],[93769,1,""],[93770,1,""],[93771,1,""],[93772,1,""],[93773,1,""],[93774,1,""],[93775,1,""],[93776,1,""],[93777,1,""],[93778,1,""],[93779,1,""],[93780,1,""],[93781,1,""],[93782,1,""],[93783,1,""],[93784,1,""],[93785,1,""],[93786,1,""],[93787,1,""],[93788,1,""],[93789,1,""],[93790,1,""],[93791,1,""],[[93792,93823],2],[[93824,93850],2],[[93851,93951],3],[[93952,94020],2],[[94021,94026],2],[[94027,94030],3],[94031,2],[[94032,94078],2],[[94079,94087],2],[[94088,94094],3],[[94095,94111],2],[[94112,94175],3],[94176,2],[94177,2],[94178,2],[94179,2],[94180,2],[[94181,94191],3],[[94192,94193],2],[[94194,94207],3],[[94208,100332],2],[[100333,100337],2],[[100338,100343],2],[[100344,100351],3],[[100352,101106],2],[[101107,101589],2],[[101590,101630],3],[101631,2],[[101632,101640],2],[[101641,110575],3],[[110576,110579],2],[110580,3],[[110581,110587],2],[110588,3],[[110589,110590],2],[110591,3],[[110592,110593],2],[[110594,110878],2],[[110879,110882],2],[[110883,110897],3],[110898,2],[[110899,110927],3],[[110928,110930],2],[[110931,110932],3],[110933,2],[[110934,110947],3],[[110948,110951],2],[[110952,110959],3],[[110960,111355],2],[[111356,113663],3],[[113664,113770],2],[[113771,113775],3],[[113776,113788],2],[[113789,113791],3],[[113792,113800],2],[[113801,113807],3],[[113808,113817],2],[[113818,113819],3],[113820,2],[[113821,113822],2],[113823,2],[[113824,113827],7],[[113828,117759],3],[[117760,117973],2],[117974,1,"a"],[117975,1,"b"],[117976,1,"c"],[117977,1,"d"],[117978,1,"e"],[117979,1,"f"],[117980,1,"g"],[117981,1,"h"],[117982,1,"i"],[117983,1,"j"],[117984,1,"k"],[117985,1,"l"],[117986,1,"m"],[117987,1,"n"],[117988,1,"o"],[117989,1,"p"],[117990,1,"q"],[117991,1,"r"],[117992,1,"s"],[117993,1,"t"],[117994,1,"u"],[117995,1,"v"],[117996,1,"w"],[117997,1,"x"],[117998,1,"y"],[117999,1,"z"],[118000,1,"0"],[118001,1,"1"],[118002,1,"2"],[118003,1,"3"],[118004,1,"4"],[118005,1,"5"],[118006,1,"6"],[118007,1,"7"],[118008,1,"8"],[118009,1,"9"],[[118010,118015],3],[[118016,118451],2],[[118452,118527],3],[[118528,118573],2],[[118574,118575],3],[[118576,118598],2],[[118599,118607],3],[[118608,118723],2],[[118724,118783],3],[[118784,119029],2],[[119030,119039],3],[[119040,119078],2],[[119079,119080],3],[119081,2],[[119082,119133],2],[119134,1,""],[119135,1,""],[119136,1,""],[119137,1,""],[119138,1,""],[119139,1,""],[119140,1,""],[[119141,119154],2],[[119155,119162],7],[[119163,119226],2],[119227,1,""],[119228,1,""],[119229,1,""],[119230,1,""],[119231,1,""],[119232,1,""],[[119233,119261],2],[[119262,119272],2],[[119273,119274],2],[[119275,119295],3],[[119296,119365],2],[[119366,119487],3],[[119488,119507],2],[[119508,119519],3],[[119520,119539],2],[[119540,119551],3],[[119552,119638],2],[[119639,119647],3],[[119648,119665],2],[[119666,119672],2],[[119673,119807],3],[119808,1,"a"],[119809,1,"b"],[119810,1,"c"],[119811,1,"d"],[119812,1,"e"],[119813,1,"f"],[119814,1,"g"],[119815,1,"h"],[119816,1,"i"],[119817,1,"j"],[119818,1,"k"],[119819,1,"l"],[119820,1,"m"],[119821,1,"n"],[119822,1,"o"],[119823,1,"p"],[119824,1,"q"],[119825,1,"r"],[119826,1,"s"],[119827,1,"t"],[119828,1,"u"],[119829,1,"v"],[119830,1,"w"],[119831,1,"x"],[119832,1,"y"],[119833,1,"z"],[119834,1,"a"],[119835,1,"b"],[119836,1,"c"],[119837,1,"d"],[119838,1,"e"],[119839,1,"f"],[119840,1,"g"],[119841,1,"h"],[119842,1,"i"],[119843,1,"j"],[119844,1,"k"],[119845,1,"l"],[119846,1,"m"],[119847,1,"n"],[119848,1,"o"],[119849,1,"p"],[119850,1,"q"],[119851,1,"r"],[119852,1,"s"],[119853,1,"t"],[119854,1,"u"],[119855,1,"v"],[119856,1,"w"],[119857,1,"x"],[119858,1,"y"],[119859,1,"z"],[119860,1,"a"],[119861,1,"b"],[119862,1,"c"],[119863,1,"d"],[119864,1,"e"],[119865,1,"f"],[119866,1,"g"],[119867,1,"h"],[119868,1,"i"],[119869,1,"j"],[119870,1,"k"],[119871,1,"l"],[119872,1,"m"],[119873,1,"n"],[119874,1,"o"],[119875,1,"p"],[119876,1,"q"],[119877,1,"r"],[119878,1,"s"],[119879,1,"t"],[119880,1,"u"],[119881,1,"v"],[119882,1,"w"],[119883,1,"x"],[119884,1,"y"],[119885,1,"z"],[119886,1,"a"],[119887,1,"b"],[119888,1,"c"],[119889,1,"d"],[119890,1,"e"],[119891,1,"f"],[119892,1,"g"],[119893,3],[119894,1,"i"],[119895,1,"j"],[119896,1,"k"],[119897,1,"l"],[119898,1,"m"],[119899,1,"n"],[119900,1,"o"],[119901,1,"p"],[119902,1,"q"],[119903,1,"r"],[119904,1,"s"],[119905,1,"t"],[119906,1,"u"],[119907,1,"v"],[119908,1,"w"],[119909,1,"x"],[119910,1,"y"],[119911,1,"z"],[119912,1,"a"],[119913,1,"b"],[119914,1,"c"],[119915,1,"d"],[119916,1,"e"],[119917,1,"f"],[119918,1,"g"],[119919,1,"h"],[119920,1,"i"],[119921,1,"j"],[119922,1,"k"],[119923,1,"l"],[119924,1,"m"],[119925,1,"n"],[119926,1,"o"],[119927,1,"p"],[119928,1,"q"],[119929,1,"r"],[119930,1,"s"],[119931,1,"t"],[119932,1,"u"],[119933,1,"v"],[119934,1,"w"],[119935,1,"x"],[119936,1,"y"],[119937,1,"z"],[119938,1,"a"],[119939,1,"b"],[119940,1,"c"],[119941,1,"d"],[119942,1,"e"],[119943,1,"f"],[119944,1,"g"],[119945,1,"h"],[119946,1,"i"],[119947,1,"j"],[119948,1,"k"],[119949,1,"l"],[119950,1,"m"],[119951,1,"n"],[119952,1,"o"],[119953,1,"p"],[119954,1,"q"],[119955,1,"r"],[119956,1,"s"],[119957,1,"t"],[119958,1,"u"],[119959,1,"v"],[119960,1,"w"],[119961,1,"x"],[119962,1,"y"],[119963,1,"z"],[119964,1,"a"],[119965,3],[119966,1,"c"],[119967,1,"d"],[[119968,119969],3],[119970,1,"g"],[[119971,119972],3],[119973,1,"j"],[119974,1,"k"],[[119975,119976],3],[119977,1,"n"],[119978,1,"o"],[119979,1,"p"],[119980,1,"q"],[119981,3],[119982,1,"s"],[119983,1,"t"],[119984,1,"u"],[119985,1,"v"],[119986,1,"w"],[119987,1,"x"],[119988,1,"y"],[119989,1,"z"],[119990,1,"a"],[119991,1,"b"],[119992,1,"c"],[119993,1,"d"],[119994,3],[119995,1,"f"],[119996,3],[119997,1,"h"],[119998,1,"i"],[119999,1,"j"],[120000,1,"k"],[120001,1,"l"],[120002,1,"m"],[120003,1,"n"],[120004,3],[120005,1,"p"],[120006,1,"q"],[120007,1,"r"],[120008,1,"s"],[120009,1,"t"],[120010,1,"u"],[120011,1,"v"],[120012,1,"w"],[120013,1,"x"],[120014,1,"y"],[120015,1,"z"],[120016,1,"a"],[120017,1,"b"],[120018,1,"c"],[120019,1,"d"],[120020,1,"e"],[120021,1,"f"],[120022,1,"g"],[120023,1,"h"],[120024,1,"i"],[120025,1,"j"],[120026,1,"k"],[120027,1,"l"],[120028,1,"m"],[120029,1,"n"],[120030,1,"o"],[120031,1,"p"],[120032,1,"q"],[120033,1,"r"],[120034,1,"s"],[120035,1,"t"],[120036,1,"u"],[120037,1,"v"],[120038,1,"w"],[120039,1,"x"],[120040,1,"y"],[120041,1,"z"],[120042,1,"a"],[120043,1,"b"],[120044,1,"c"],[120045,1,"d"],[120046,1,"e"],[120047,1,"f"],[120048,1,"g"],[120049,1,"h"],[120050,1,"i"],[120051,1,"j"],[120052,1,"k"],[120053,1,"l"],[120054,1,"m"],[120055,1,"n"],[120056,1,"o"],[120057,1,"p"],[120058,1,"q"],[120059,1,"r"],[120060,1,"s"],[120061,1,"t"],[120062,1,"u"],[120063,1,"v"],[120064,1,"w"],[120065,1,"x"],[120066,1,"y"],[120067,1,"z"],[120068,1,"a"],[120069,1,"b"],[120070,3],[120071,1,"d"],[120072,1,"e"],[120073,1,"f"],[120074,1,"g"],[[120075,120076],3],[120077,1,"j"],[120078,1,"k"],[120079,1,"l"],[120080,1,"m"],[120081,1,"n"],[120082,1,"o"],[120083,1,"p"],[120084,1,"q"],[120085,3],[120086,1,"s"],[120087,1,"t"],[120088,1,"u"],[120089,1,"v"],[120090,1,"w"],[120091,1,"x"],[120092,1,"y"],[120093,3],[120094,1,"a"],[120095,1,"b"],[120096,1,"c"],[120097,1,"d"],[120098,1,"e"],[120099,1,"f"],[120100,1,"g"],[120101,1,"h"],[120102,1,"i"],[120103,1,"j"],[120104,1,"k"],[120105,1,"l"],[120106,1,"m"],[120107,1,"n"],[120108,1,"o"],[120109,1,"p"],[120110,1,"q"],[120111,1,"r"],[120112,1,"s"],[120113,1,"t"],[120114,1,"u"],[120115,1,"v"],[120116,1,"w"],[120117,1,"x"],[120118,1,"y"],[120119,1,"z"],[120120,1,"a"],[120121,1,"b"],[120122,3],[120123,1,"d"],[120124,1,"e"],[120125,1,"f"],[120126,1,"g"],[120127,3],[120128,1,"i"],[120129,1,"j"],[120130,1,"k"],[120131,1,"l"],[120132,1,"m"],[120133,3],[120134,1,"o"],[[120135,120137],3],[120138,1,"s"],[120139,1,"t"],[120140,1,"u"],[120141,1,"v"],[120142,1,"w"],[120143,1,"x"],[120144,1,"y"],[120145,3],[120146,1,"a"],[120147,1,"b"],[120148,1,"c"],[120149,1,"d"],[120150,1,"e"],[120151,1,"f"],[120152,1,"g"],[120153,1,"h"],[120154,1,"i"],[120155,1,"j"],[120156,1,"k"],[120157,1,"l"],[120158,1,"m"],[120159,1,"n"],[120160,1,"o"],[120161,1,"p"],[120162,1,"q"],[120163,1,"r"],[120164,1,"s"],[120165,1,"t"],[120166,1,"u"],[120167,1,"v"],[120168,1,"w"],[120169,1,"x"],[120170,1,"y"],[120171,1,"z"],[120172,1,"a"],[120173,1,"b"],[120174,1,"c"],[120175,1,"d"],[120176,1,"e"],[120177,1,"f"],[120178,1,"g"],[120179,1,"h"],[120180,1,"i"],[120181,1,"j"],[120182,1,"k"],[120183,1,"l"],[120184,1,"m"],[120185,1,"n"],[120186,1,"o"],[120187,1,"p"],[120188,1,"q"],[120189,1,"r"],[120190,1,"s"],[120191,1,"t"],[120192,1,"u"],[120193,1,"v"],[120194,1,"w"],[120195,1,"x"],[120196,1,"y"],[120197,1,"z"],[120198,1,"a"],[120199,1,"b"],[120200,1,"c"],[120201,1,"d"],[120202,1,"e"],[120203,1,"f"],[120204,1,"g"],[120205,1,"h"],[120206,1,"i"],[120207,1,"j"],[120208,1,"k"],[120209,1,"l"],[120210,1,"m"],[120211,1,"n"],[120212,1,"o"],[120213,1,"p"],[120214,1,"q"],[120215,1,"r"],[120216,1,"s"],[120217,1,"t"],[120218,1,"u"],[120219,1,"v"],[120220,1,"w"],[120221,1,"x"],[120222,1,"y"],[120223,1,"z"],[120224,1,"a"],[120225,1,"b"],[120226,1,"c"],[120227,1,"d"],[120228,1,"e"],[120229,1,"f"],[120230,1,"g"],[120231,1,"h"],[120232,1,"i"],[120233,1,"j"],[120234,1,"k"],[120235,1,"l"],[120236,1,"m"],[120237,1,"n"],[120238,1,"o"],[120239,1,"p"],[120240,1,"q"],[120241,1,"r"],[120242,1,"s"],[120243,1,"t"],[120244,1,"u"],[120245,1,"v"],[120246,1,"w"],[120247,1,"x"],[120248,1,"y"],[120249,1,"z"],[120250,1,"a"],[120251,1,"b"],[120252,1,"c"],[120253,1,"d"],[120254,1,"e"],[120255,1,"f"],[120256,1,"g"],[120257,1,"h"],[120258,1,"i"],[120259,1,"j"],[120260,1,"k"],[120261,1,"l"],[120262,1,"m"],[120263,1,"n"],[120264,1,"o"],[120265,1,"p"],[120266,1,"q"],[120267,1,"r"],[120268,1,"s"],[120269,1,"t"],[120270,1,"u"],[120271,1,"v"],[120272,1,"w"],[120273,1,"x"],[120274,1,"y"],[120275,1,"z"],[120276,1,"a"],[120277,1,"b"],[120278,1,"c"],[120279,1,"d"],[120280,1,"e"],[120281,1,"f"],[120282,1,"g"],[120283,1,"h"],[120284,1,"i"],[120285,1,"j"],[120286,1,"k"],[120287,1,"l"],[120288,1,"m"],[120289,1,"n"],[120290,1,"o"],[120291,1,"p"],[120292,1,"q"],[120293,1,"r"],[120294,1,"s"],[120295,1,"t"],[120296,1,"u"],[120297,1,"v"],[120298,1,"w"],[120299,1,"x"],[120300,1,"y"],[120301,1,"z"],[120302,1,"a"],[120303,1,"b"],[120304,1,"c"],[120305,1,"d"],[120306,1,"e"],[120307,1,"f"],[120308,1,"g"],[120309,1,"h"],[120310,1,"i"],[120311,1,"j"],[120312,1,"k"],[120313,1,"l"],[120314,1,"m"],[120315,1,"n"],[120316,1,"o"],[120317,1,"p"],[120318,1,"q"],[120319,1,"r"],[120320,1,"s"],[120321,1,"t"],[120322,1,"u"],[120323,1,"v"],[120324,1,"w"],[120325,1,"x"],[120326,1,"y"],[120327,1,"z"],[120328,1,"a"],[120329,1,"b"],[120330,1,"c"],[120331,1,"d"],[120332,1,"e"],[120333,1,"f"],[120334,1,"g"],[120335,1,"h"],[120336,1,"i"],[120337,1,"j"],[120338,1,"k"],[120339,1,"l"],[120340,1,"m"],[120341,1,"n"],[120342,1,"o"],[120343,1,"p"],[120344,1,"q"],[120345,1,"r"],[120346,1,"s"],[120347,1,"t"],[120348,1,"u"],[120349,1,"v"],[120350,1,"w"],[120351,1,"x"],[120352,1,"y"],[120353,1,"z"],[120354,1,"a"],[120355,1,"b"],[120356,1,"c"],[120357,1,"d"],[120358,1,"e"],[120359,1,"f"],[120360,1,"g"],[120361,1,"h"],[120362,1,"i"],[120363,1,"j"],[120364,1,"k"],[120365,1,"l"],[120366,1,"m"],[120367,1,"n"],[120368,1,"o"],[120369,1,"p"],[120370,1,"q"],[120371,1,"r"],[120372,1,"s"],[120373,1,"t"],[120374,1,"u"],[120375,1,"v"],[120376,1,"w"],[120377,1,"x"],[120378,1,"y"],[120379,1,"z"],[120380,1,"a"],[120381,1,"b"],[120382,1,"c"],[120383,1,"d"],[120384,1,"e"],[120385,1,"f"],[120386,1,"g"],[120387,1,"h"],[120388,1,"i"],[120389,1,"j"],[120390,1,"k"],[120391,1,"l"],[120392,1,"m"],[120393,1,"n"],[120394,1,"o"],[120395,1,"p"],[120396,1,"q"],[120397,1,"r"],[120398,1,"s"],[120399,1,"t"],[120400,1,"u"],[120401,1,"v"],[120402,1,"w"],[120403,1,"x"],[120404,1,"y"],[120405,1,"z"],[120406,1,"a"],[120407,1,"b"],[120408,1,"c"],[120409,1,"d"],[120410,1,"e"],[120411,1,"f"],[120412,1,"g"],[120413,1,"h"],[120414,1,"i"],[120415,1,"j"],[120416,1,"k"],[120417,1,"l"],[120418,1,"m"],[120419,1,"n"],[120420,1,"o"],[120421,1,"p"],[120422,1,"q"],[120423,1,"r"],[120424,1,"s"],[120425,1,"t"],[120426,1,"u"],[120427,1,"v"],[120428,1,"w"],[120429,1,"x"],[120430,1,"y"],[120431,1,"z"],[120432,1,"a"],[120433,1,"b"],[120434,1,"c"],[120435,1,"d"],[120436,1,"e"],[120437,1,"f"],[120438,1,"g"],[120439,1,"h"],[120440,1,"i"],[120441,1,"j"],[120442,1,"k"],[120443,1,"l"],[120444,1,"m"],[120445,1,"n"],[120446,1,"o"],[120447,1,"p"],[120448,1,"q"],[120449,1,"r"],[120450,1,"s"],[120451,1,"t"],[120452,1,"u"],[120453,1,"v"],[120454,1,"w"],[120455,1,"x"],[120456,1,"y"],[120457,1,"z"],[120458,1,"a"],[120459,1,"b"],[120460,1,"c"],[120461,1,"d"],[120462,1,"e"],[120463,1,"f"],[120464,1,"g"],[120465,1,"h"],[120466,1,"i"],[120467,1,"j"],[120468,1,"k"],[120469,1,"l"],[120470,1,"m"],[120471,1,"n"],[120472,1,"o"],[120473,1,"p"],[120474,1,"q"],[120475,1,"r"],[120476,1,"s"],[120477,1,"t"],[120478,1,"u"],[120479,1,"v"],[120480,1,"w"],[120481,1,"x"],[120482,1,"y"],[120483,1,"z"],[120484,1,""],[120485,1,""],[[120486,120487],3],[120488,1,""],[120489,1,""],[120490,1,""],[120491,1,""],[120492,1,""],[120493,1,""],[120494,1,""],[120495,1,""],[120496,1,""],[120497,1,""],[120498,1,""],[120499,1,""],[120500,1,""],[120501,1,""],[120502,1,""],[120503,1,""],[120504,1,""],[120505,1,""],[120506,1,""],[120507,1,""],[120508,1,""],[120509,1,""],[120510,1,""],[120511,1,""],[120512,1,""],[120513,1,""],[120514,1,""],[120515,1,""],[120516,1,""],[120517,1,""],[120518,1,""],[120519,1,""],[120520,1,""],[120521,1,""],[120522,1,""],[120523,1,""],[120524,1,""],[120525,1,""],[120526,1,""],[120527,1,""],[120528,1,""],[120529,1,""],[120530,1,""],[[120531,120532],1,""],[120533,1,""],[120534,1,""],[120535,1,""],[120536,1,""],[120537,1,""],[120538,1,""],[120539,1,""],[120540,1,""],[120541,1,""],[120542,1,""],[120543,1,""],[120544,1,""],[120545,1,""],[120546,1,""],[120547,1,""],[120548,1,""],[120549,1,""],[120550,1,""],[120551,1,""],[120552,1,""],[120553,1,""],[120554,1,""],[120555,1,""],[120556,1,""],[120557,1,""],[120558,1,""],[120559,1,""],[120560,1,""],[120561,1,""],[120562,1,""],[120563,1,""],[120564,1,""],[120565,1,""],[120566,1,""],[120567,1,""],[120568,1,""],[120569,1,""],[120570,1,""],[120571,1,""],[120572,1,""],[120573,1,""],[120574,1,""],[120575,1,""],[120576,1,""],[120577,1,""],[120578,1,""],[120579,1,""],[120580,1,""],[120581,1,""],[120582,1,""],[120583,1,""],[120584,1,""],[120585,1,""],[120586,1,""],[120587,1,""],[120588,1,""],[[120589,120590],1,""],[120591,1,""],[120592,1,""],[120593,1,""],[120594,1,""],[120595,1,""],[120596,1,""],[120597,1,""],[120598,1,""],[120599,1,""],[120600,1,""],[120601,1,""],[120602,1,""],[120603,1,""],[120604,1,""],[120605,1,""],[120606,1,""],[120607,1,""],[120608,1,""],[120609,1,""],[120610,1,""],[120611,1,""],[120612,1,""],[120613,1,""],[120614,1,""],[120615,1,""],[120616,1,""],[120617,1,""],[120618,1,""],[120619,1,""],[120620,1,""],[120621,1,""],[120622,1,""],[120623,1,""],[120624,1,""],[120625,1,""],[120626,1,""],[120627,1,""],[120628,1,""],[120629,1,""],[120630,1,""],[120631,1,""],[120632,1,""],[120633,1,""],[120634,1,""],[120635,1,""],[120636,1,""],[120637,1,""],[120638,1,""],[120639,1,""],[120640,1,""],[120641,1,""],[120642,1,""],[120643,1,""],[120644,1,""],[120645,1,""],[120646,1,""],[[120647,120648],1,""],[120649,1,""],[120650,1,""],[120651,1,""],[120652,1,""],[120653,1,""],[120654,1,""],[120655,1,""],[120656,1,""],[120657,1,""],[120658,1,""],[120659,1,""],[120660,1,""],[120661,1,""],[120662,1,""],[120663,1,""],[120664,1,""],[120665,1,""],[120666,1,""],[120667,1,""],[120668,1,""],[120669,1,""],[120670,1,""],[120671,1,""],[120672,1,""],[120673,1,""],[120674,1,""],[120675,1,""],[120676,1,""],[120677,1,""],[120678,1,""],[120679,1,""],[120680,1,""],[120681,1,""],[120682,1,""],[120683,1,""],[120684,1,""],[120685,1,""],[120686,1,""],[120687,1,""],[120688,1,""],[120689,1,""],[120690,1,""],[120691,1,""],[120692,1,""],[120693,1,""],[120694,1,""],[120695,1,""],[120696,1,""],[120697,1,""],[120698,1,""],[120699,1,""],[120700,1,""],[120701,1,""],[120702,1,""],[120703,1,""],[120704,1,""],[[120705,120706],1,""],[120707,1,""],[120708,1,""],[120709,1,""],[120710,1,""],[120711,1,""],[120712,1,""],[120713,1,""],[120714,1,""],[120715,1,""],[120716,1,""],[120717,1,""],[120718,1,""],[120719,1,""],[120720,1,""],[120721,1,""],[120722,1,""],[120723,1,""],[120724,1,""],[120725,1,""],[120726,1,""],[120727,1,""],[120728,1,""],[120729,1,""],[120730,1,""],[120731,1,""],[120732,1,""],[120733,1,""],[120734,1,""],[120735,1,""],[120736,1,""],[120737,1,""],[120738,1,""],[120739,1,""],[120740,1,""],[120741,1,""],[120742,1,""],[120743,1,""],[120744,1,""],[120745,1,""],[120746,1,""],[120747,1,""],[120748,1,""],[120749,1,""],[120750,1,""],[120751,1,""],[120752,1,""],[120753,1,""],[120754,1,""],[120755,1,""],[120756,1,""],[120757,1,""],[120758,1,""],[120759,1,""],[120760,1,""],[120761,1,""],[120762,1,""],[[120763,120764],1,""],[120765,1,""],[120766,1,""],[120767,1,""],[120768,1,""],[120769,1,""],[120770,1,""],[120771,1,""],[120772,1,""],[120773,1,""],[120774,1,""],[120775,1,""],[120776,1,""],[120777,1,""],[[120778,120779],1,""],[[120780,120781],3],[120782,1,"0"],[120783,1,"1"],[120784,1,"2"],[120785,1,"3"],[120786,1,"4"],[120787,1,"5"],[120788,1,"6"],[120789,1,"7"],[120790,1,"8"],[120791,1,"9"],[120792,1,"0"],[120793,1,"1"],[120794,1,"2"],[120795,1,"3"],[120796,1,"4"],[120797,1,"5"],[120798,1,"6"],[120799,1,"7"],[120800,1,"8"],[120801,1,"9"],[120802,1,"0"],[120803,1,"1"],[120804,1,"2"],[120805,1,"3"],[120806,1,"4"],[120807,1,"5"],[120808,1,"6"],[120809,1,"7"],[120810,1,"8"],[120811,1,"9"],[120812,1,"0"],[120813,1,"1"],[120814,1,"2"],[120815,1,"3"],[120816,1,"4"],[120817,1,"5"],[120818,1,"6"],[120819,1,"7"],[120820,1,"8"],[120821,1,"9"],[120822,1,"0"],[120823,1,"1"],[120824,1,"2"],[120825,1,"3"],[120826,1,"4"],[120827,1,"5"],[120828,1,"6"],[120829,1,"7"],[120830,1,"8"],[120831,1,"9"],[[120832,121343],2],[[121344,121398],2],[[121399,121402],2],[[121403,121452],2],[[121453,121460],2],[121461,2],[[121462,121475],2],[121476,2],[[121477,121483],2],[[121484,121498],3],[[121499,121503],2],[121504,3],[[121505,121519],2],[[121520,122623],3],[[122624,122654],2],[[122655,122660],3],[[122661,122666],2],[[122667,122879],3],[[122880,122886],2],[122887,3],[[122888,122904],2],[[122905,122906],3],[[122907,122913],2],[122914,3],[[122915,122916],2],[122917,3],[[122918,122922],2],[[122923,122927],3],[122928,1,""],[122929,1,""],[122930,1,""],[122931,1,""],[122932,1,""],[122933,1,""],[122934,1,""],[122935,1,""],[122936,1,""],[122937,1,""],[122938,1,""],[122939,1,""],[122940,1,""],[122941,1,""],[122942,1,""],[122943,1,""],[122944,1,""],[122945,1,""],[122946,1,""],[122947,1,""],[122948,1,""],[122949,1,""],[122950,1,""],[122951,1,""],[122952,1,""],[122953,1,""],[122954,1,""],[122955,1,""],[122956,1,""],[122957,1,""],[122958,1,""],[122959,1,""],[122960,1,""],[122961,1,""],[122962,1,""],[122963,1,""],[122964,1,""],[122965,1,""],[122966,1,""],[122967,1,""],[122968,1,""],[122969,1,""],[122970,1,""],[122971,1,""],[122972,1,""],[122973,1,""],[122974,1,""],[122975,1,""],[122976,1,""],[122977,1,""],[122978,1,""],[122979,1,""],[122980,1,""],[122981,1,""],[122982,1,""],[122983,1,""],[122984,1,""],[122985,1,""],[122986,1,""],[122987,1,""],[122988,1,""],[122989,1,""],[[122990,123022],3],[123023,2],[[123024,123135],3],[[123136,123180],2],[[123181,123183],3],[[123184,123197],2],[[123198,123199],3],[[123200,123209],2],[[123210,123213],3],[123214,2],[123215,2],[[123216,123535],3],[[123536,123566],2],[[123567,123583],3],[[123584,123641],2],[[123642,123646],3],[123647,2],[[123648,124111],3],[[124112,124153],2],[[124154,124367],3],[[124368,124410],2],[[124411,124414],3],[124415,2],[[124416,124895],3],[[124896,124902],2],[124903,3],[[124904,124907],2],[124908,3],[[124909,124910],2],[124911,3],[[124912,124926],2],[124927,3],[[124928,125124],2],[[125125,125126],3],[[125127,125135],2],[[125136,125142],2],[[125143,125183],3],[125184,1,""],[125185,1,""],[125186,1,""],[125187,1,""],[125188,1,""],[125189,1,""],[125190,1,""],[125191,1,""],[125192,1,""],[125193,1,""],[125194,1,""],[125195,1,""],[125196,1,""],[125197,1,""],[125198,1,""],[125199,1,""],[125200,1,""],[125201,1,""],[125202,1,""],[125203,1,""],[125204,1,""],[125205,1,""],[125206,1,""],[125207,1,""],[125208,1,""],[125209,1,""],[125210,1,""],[125211,1,""],[125212,1,""],[125213,1,""],[125214,1,""],[125215,1,""],[125216,1,""],[125217,1,""],[[125218,125258],2],[125259,2],[[125260,125263],3],[[125264,125273],2],[[125274,125277],3],[[125278,125279],2],[[125280,126064],3],[[126065,126132],2],[[126133,126208],3],[[126209,126269],2],[[126270,126463],3],[126464,1,""],[126465,1,""],[126466,1,""],[126467,1,""],[126468,3],[126469,1,""],[126470,1,""],[126471,1,""],[126472,1,""],[126473,1,""],[126474,1,""],[126475,1,""],[126476,1,""],[126477,1,""],[126478,1,""],[126479,1,""],[126480,1,""],[126481,1,""],[126482,1,""],[126483,1,""],[126484,1,""],[126485,1,""],[126486,1,""],[126487,1,""],[126488,1,""],[126489,1,""],[126490,1,""],[126491,1,""],[126492,1,""],[126493,1,""],[126494,1,""],[126495,1,""],[126496,3],[126497,1,""],[126498,1,""],[126499,3],[126500,1,""],[[126501,126502],3],[126503,1,""],[126504,3],[126505,1,""],[126506,1,""],[126507,1,""],[126508,1,""],[126509,1,""],[126510,1,""],[126511,1,""],[126512,1,""],[126513,1,""],[126514,1,""],[126515,3],[126516,1,""],[126517,1,""],[126518,1,""],[126519,1,""],[126520,3],[126521,1,""],[126522,3],[126523,1,""],[[126524,126529],3],[126530,1,""],[[126531,126534],3],[126535,1,""],[126536,3],[126537,1,""],[126538,3],[126539,1,""],[126540,3],[126541,1,""],[126542,1,""],[126543,1,""],[126544,3],[126545,1,""],[126546,1,""],[126547,3],[126548,1,""],[[126549,126550],3],[126551,1,""],[126552,3],[126553,1,""],[126554,3],[126555,1,""],[126556,3],[126557,1,""],[126558,3],[126559,1,""],[126560,3],[126561,1,""],[126562,1,""],[126563,3],[126564,1,""],[[126565,126566],3],[126567,1,""],[126568,1,""],[126569,1,""],[126570,1,""],[126571,3],[126572,1,""],[126573,1,""],[126574,1,""],[126575,1,""],[126576,1,""],[126577,1,""],[126578,1,""],[126579,3],[126580,1,""],[126581,1,""],[126582,1,""],[126583,1,""],[126584,3],[126585,1,""],[126586,1,""],[126587,1,""],[126588,1,""],[126589,3],[126590,1,""],[126591,3],[126592,1,""],[126593,1,""],[126594,1,""],[126595,1,""],[126596,1,""],[126597,1,""],[126598,1,""],[126599,1,""],[126600,1,""],[126601,1,""],[126602,3],[126603,1,""],[126604,1,""],[126605,1,""],[126606,1,""],[126607,1,""],[126608,1,""],[126609,1,""],[126610,1,""],[126611,1,""],[126612,1,""],[126613,1,""],[126614,1,""],[126615,1,""],[126616,1,""],[126617,1,""],[126618,1,""],[126619,1,""],[[126620,126624],3],[126625,1,""],[126626,1,""],[126627,1,""],[126628,3],[126629,1,""],[126630,1,""],[126631,1,""],[126632,1,""],[126633,1,""],[126634,3],[126635,1,""],[126636,1,""],[126637,1,""],[126638,1,""],[126639,1,""],[126640,1,""],[126641,1,""],[126642,1,""],[126643,1,""],[126644,1,""],[126645,1,""],[126646,1,""],[126647,1,""],[126648,1,""],[126649,1,""],[126650,1,""],[126651,1,""],[[126652,126703],3],[[126704,126705],2],[[126706,126975],3],[[126976,127019],2],[[127020,127023],3],[[127024,127123],2],[[127124,127135],3],[[127136,127150],2],[[127151,127152],3],[[127153,127166],2],[127167,2],[127168,3],[[127169,127183],2],[127184,3],[[127185,127199],2],[[127200,127221],2],[[127222,127231],3],[127232,3],[127233,1,"0,"],[127234,1,"1,"],[127235,1,"2,"],[127236,1,"3,"],[127237,1,"4,"],[127238,1,"5,"],[127239,1,"6,"],[127240,1,"7,"],[127241,1,"8,"],[127242,1,"9,"],[[127243,127244],2],[[127245,127247],2],[127248,1,"(a)"],[127249,1,"(b)"],[127250,1,"(c)"],[127251,1,"(d)"],[127252,1,"(e)"],[127253,1,"(f)"],[127254,1,"(g)"],[127255,1,"(h)"],[127256,1,"(i)"],[127257,1,"(j)"],[127258,1,"(k)"],[127259,1,"(l)"],[127260,1,"(m)"],[127261,1,"(n)"],[127262,1,"(o)"],[127263,1,"(p)"],[127264,1,"(q)"],[127265,1,"(r)"],[127266,1,"(s)"],[127267,1,"(t)"],[127268,1,"(u)"],[127269,1,"(v)"],[127270,1,"(w)"],[127271,1,"(x)"],[127272,1,"(y)"],[127273,1,"(z)"],[127274,1,"s"],[127275,1,"c"],[127276,1,"r"],[127277,1,"cd"],[127278,1,"wz"],[127279,2],[127280,1,"a"],[127281,1,"b"],[127282,1,"c"],[127283,1,"d"],[127284,1,"e"],[127285,1,"f"],[127286,1,"g"],[127287,1,"h"],[127288,1,"i"],[127289,1,"j"],[127290,1,"k"],[127291,1,"l"],[127292,1,"m"],[127293,1,"n"],[127294,1,"o"],[127295,1,"p"],[127296,1,"q"],[127297,1,"r"],[127298,1,"s"],[127299,1,"t"],[127300,1,"u"],[127301,1,"v"],[127302,1,"w"],[127303,1,"x"],[127304,1,"y"],[127305,1,"z"],[127306,1,"hv"],[127307,1,"mv"],[127308,1,"sd"],[127309,1,"ss"],[127310,1,"ppv"],[127311,1,"wc"],[[127312,127318],2],[127319,2],[[127320,127326],2],[127327,2],[[127328,127337],2],[127338,1,"mc"],[127339,1,"md"],[127340,1,"mr"],[[127341,127343],2],[[127344,127352],2],[127353,2],[127354,2],[[127355,127356],2],[[127357,127358],2],[127359,2],[[127360,127369],2],[[127370,127373],2],[[127374,127375],2],[127376,1,"dj"],[[127377,127386],2],[[127387,127404],2],[127405,2],[[127406,127461],3],[[127462,127487],2],[127488,1,""],[127489,1,""],[127490,1,""],[[127491,127503],3],[127504,1,""],[127505,1,""],[127506,1,""],[127507,1,""],[127508,1,""],[127509,1,""],[127510,1,""],[127511,1,""],[127512,1,""],[127513,1,""],[127514,1,""],[127515,1,""],[127516,1,""],[127517,1,""],[127518,1,""],[127519,1,""],[127520,1,""],[127521,1,""],[127522,1,""],[127523,1,""],[127524,1,""],[127525,1,""],[127526,1,""],[127527,1,""],[127528,1,""],[127529,1,""],[127530,1,""],[127531,1,""],[127532,1,""],[127533,1,""],[127534,1,""],[127535,1,""],[127536,1,""],[127537,1,""],[127538,1,""],[127539,1,""],[127540,1,""],[127541,1,""],[127542,1,""],[127543,1,""],[127544,1,""],[127545,1,""],[127546,1,""],[127547,1,""],[[127548,127551],3],[127552,1,""],[127553,1,""],[127554,1,""],[127555,1,""],[127556,1,""],[127557,1,""],[127558,1,""],[127559,1,""],[127560,1,""],[[127561,127567],3],[127568,1,""],[127569,1,""],[[127570,127583],3],[[127584,127589],2],[[127590,127743],3],[[127744,127776],2],[[127777,127788],2],[[127789,127791],2],[[127792,127797],2],[127798,2],[[127799,127868],2],[127869,2],[[127870,127871],2],[[127872,127891],2],[[127892,127903],2],[[127904,127940],2],[127941,2],[[127942,127946],2],[[127947,127950],2],[[127951,127955],2],[[127956,127967],2],[[127968,127984],2],[[127985,127991],2],[[127992,127999],2],[[128000,128062],2],[128063,2],[128064,2],[128065,2],[[128066,128247],2],[128248,2],[[128249,128252],2],[[128253,128254],2],[128255,2],[[128256,128317],2],[[128318,128319],2],[[128320,128323],2],[[128324,128330],2],[[128331,128335],2],[[128336,128359],2],[[128360,128377],2],[128378,2],[[128379,128419],2],[128420,2],[[128421,128506],2],[[128507,128511],2],[128512,2],[[128513,128528],2],[128529,2],[[128530,128532],2],[128533,2],[128534,2],[128535,2],[128536,2],[128537,2],[128538,2],[128539,2],[[128540,128542],2],[128543,2],[[128544,128549],2],[[128550,128551],2],[[128552,128555],2],[128556,2],[128557,2],[[128558,128559],2],[[128560,128563],2],[128564,2],[[128565,128576],2],[[128577,128578],2],[[128579,128580],2],[[128581,128591],2],[[128592,128639],2],[[128640,128709],2],[[128710,128719],2],[128720,2],[[128721,128722],2],[[128723,128724],2],[128725,2],[[128726,128727],2],[[128728,128731],3],[128732,2],[[128733,128735],2],[[128736,128748],2],[[128749,128751],3],[[128752,128755],2],[[128756,128758],2],[[128759,128760],2],[128761,2],[128762,2],[[128763,128764],2],[[128765,128767],3],[[128768,128883],2],[[128884,128886],2],[[128887,128890],3],[[128891,128895],2],[[128896,128980],2],[[128981,128984],2],[128985,2],[[128986,128991],3],[[128992,129003],2],[[129004,129007],3],[129008,2],[[129009,129023],3],[[129024,129035],2],[[129036,129039],3],[[129040,129095],2],[[129096,129103],3],[[129104,129113],2],[[129114,129119],3],[[129120,129159],2],[[129160,129167],3],[[129168,129197],2],[[129198,129199],3],[[129200,129201],2],[[129202,129211],2],[[129212,129215],3],[[129216,129217],2],[[129218,129279],3],[[129280,129291],2],[129292,2],[[129293,129295],2],[[129296,129304],2],[[129305,129310],2],[129311,2],[[129312,129319],2],[[129320,129327],2],[129328,2],[[129329,129330],2],[[129331,129342],2],[129343,2],[[129344,129355],2],[129356,2],[[129357,129359],2],[[129360,129374],2],[[129375,129387],2],[[129388,129392],2],[129393,2],[129394,2],[[129395,129398],2],[[129399,129400],2],[129401,2],[129402,2],[129403,2],[[129404,129407],2],[[129408,129412],2],[[129413,129425],2],[[129426,129431],2],[[129432,129442],2],[[129443,129444],2],[[129445,129450],2],[[129451,129453],2],[[129454,129455],2],[[129456,129465],2],[[129466,129471],2],[129472,2],[[129473,129474],2],[[129475,129482],2],[129483,2],[129484,2],[[129485,129487],2],[[129488,129510],2],[[129511,129535],2],[[129536,129619],2],[[129620,129631],3],[[129632,129645],2],[[129646,129647],3],[[129648,129651],2],[129652,2],[[129653,129655],2],[[129656,129658],2],[[129659,129660],2],[[129661,129663],3],[[129664,129666],2],[[129667,129670],2],[[129671,129672],2],[129673,2],[[129674,129678],3],[129679,2],[[129680,129685],2],[[129686,129704],2],[[129705,129708],2],[[129709,129711],2],[[129712,129718],2],[[129719,129722],2],[[129723,129725],2],[129726,2],[129727,2],[[129728,129730],2],[[129731,129733],2],[129734,2],[[129735,129741],3],[[129742,129743],2],[[129744,129750],2],[[129751,129753],2],[[129754,129755],2],[129756,2],[[129757,129758],3],[129759,2],[[129760,129767],2],[129768,2],[129769,2],[[129770,129775],3],[[129776,129782],2],[[129783,129784],2],[[129785,129791],3],[[129792,129938],2],[129939,3],[[129940,129994],2],[[129995,130031],2],[130032,1,"0"],[130033,1,"1"],[130034,1,"2"],[130035,1,"3"],[130036,1,"4"],[130037,1,"5"],[130038,1,"6"],[130039,1,"7"],[130040,1,"8"],[130041,1,"9"],[[130042,131069],3],[[131070,131071],3],[[131072,173782],2],[[173783,173789],2],[[173790,173791],2],[[173792,173823],3],[[173824,177972],2],[[177973,177976],2],[177977,2],[[177978,177983],3],[[177984,178205],2],[[178206,178207],3],[[178208,183969],2],[[183970,183983],3],[[183984,191456],2],[[191457,191471],3],[[191472,192093],2],[[192094,194559],3],[194560,1,""],[194561,1,""],[194562,1,""],[194563,1,""],[194564,1,""],[194565,1,""],[194566,1,""],[194567,1,""],[194568,1,""],[194569,1,""],[194570,1,""],[194571,1,""],[194572,1,""],[194573,1,""],[194574,1,""],[194575,1,""],[194576,1,""],[194577,1,""],[194578,1,""],[194579,1,""],[194580,1,""],[194581,1,""],[194582,1,""],[194583,1,""],[194584,1,""],[194585,1,""],[194586,1,""],[194587,1,""],[194588,1,""],[194589,1,""],[194590,1,""],[194591,1,""],[194592,1,""],[194593,1,""],[194594,1,""],[194595,1,""],[194596,1,""],[194597,1,""],[194598,1,""],[194599,1,""],[194600,1,""],[194601,1,""],[194602,1,""],[194603,1,""],[194604,1,""],[194605,1,""],[194606,1,""],[194607,1,""],[194608,1,""],[[194609,194611],1,""],[194612,1,""],[194613,1,""],[194614,1,""],[194615,1,""],[194616,1,""],[194617,1,""],[194618,1,""],[194619,1,""],[194620,1,""],[194621,1,""],[194622,1,""],[194623,1,""],[194624,1,""],[194625,1,""],[194626,1,""],[194627,1,""],[194628,1,""],[[194629,194630],1,""],[194631,1,""],[194632,1,""],[194633,1,""],[194634,1,""],[194635,1,""],[194636,1,""],[194637,1,""],[194638,1,""],[194639,1,""],[194640,1,""],[194641,1,""],[194642,1,""],[194643,1,""],[194644,1,""],[194645,1,""],[194646,1,""],[194647,1,""],[194648,1,""],[194649,1,""],[194650,1,""],[194651,1,""],[194652,1,""],[194653,1,""],[194654,1,""],[194655,1,""],[194656,1,""],[194657,1,""],[194658,1,""],[194659,1,""],[194660,1,""],[194661,1,""],[194662,1,""],[194663,1,""],[194664,1,""],[194665,1,""],[[194666,194667],1,""],[194668,1,""],[194669,1,""],[194670,1,""],[194671,1,""],[194672,1,""],[194673,1,""],[194674,1,""],[194675,1,""],[194676,1,""],[194677,1,""],[194678,1,""],[194679,1,""],[194680,1,""],[194681,1,""],[194682,1,""],[194683,1,""],[194684,1,""],[194685,1,""],[194686,1,""],[194687,1,""],[194688,1,""],[194689,1,""],[194690,1,""],[194691,1,""],[194692,1,""],[194693,1,""],[194694,1,""],[194695,1,""],[194696,1,""],[194697,1,""],[194698,1,""],[194699,1,""],[194700,1,""],[194701,1,""],[194702,1,""],[194703,1,""],[194704,1,""],[[194705,194706],1,""],[194707,1,""],[[194708,194709],1,""],[194710,1,""],[194711,1,""],[194712,1,""],[194713,1,""],[194714,1,""],[194715,1,""],[194716,1,""],[194717,1,""],[194718,1,""],[194719,1,""],[194720,1,""],[194721,1,""],[194722,1,""],[194723,1,""],[194724,1,""],[194725,1,""],[194726,1,""],[194727,1,""],[194728,1,""],[194729,1,""],[194730,1,""],[194731,1,""],[194732,1,""],[194733,1,""],[194734,1,""],[194735,1,""],[194736,1,""],[194737,1,""],[194738,1,""],[194739,1,""],[194740,1,""],[194741,1,""],[194742,1,""],[194743,1,""],[194744,1,""],[194745,1,""],[194746,1,""],[194747,1,""],[194748,1,""],[194749,1,""],[194750,1,""],[194751,1,""],[194752,1,""],[194753,1,""],[194754,1,""],[194755,1,""],[194756,1,""],[194757,1,""],[194758,1,""],[194759,1,""],[194760,1,""],[194761,1,""],[194762,1,""],[194763,1,""],[194764,1,""],[194765,1,""],[194766,1,""],[194767,1,""],[194768,1,""],[194769,1,""],[194770,1,""],[194771,1,""],[194772,1,""],[194773,1,""],[194774,1,""],[194775,1,""],[194776,1,""],[194777,1,""],[194778,1,""],[194779,1,""],[194780,1,""],[194781,1,""],[194782,1,""],[194783,1,""],[194784,1,""],[194785,1,""],[194786,1,""],[194787,1,""],[194788,1,""],[194789,1,""],[194790,1,""],[194791,1,""],[194792,1,""],[194793,1,""],[194794,1,""],[194795,1,""],[194796,1,""],[194797,1,""],[194798,1,""],[194799,1,""],[194800,1,""],[194801,1,""],[194802,1,""],[194803,1,""],[194804,1,""],[194805,1,""],[194806,1,""],[194807,1,""],[194808,1,""],[194809,1,""],[194810,1,""],[194811,1,""],[194812,1,""],[194813,1,""],[194814,1,""],[194815,1,""],[194816,1,""],[194817,1,""],[194818,1,""],[194819,1,""],[194820,1,""],[194821,1,""],[194822,1,""],[194823,1,""],[194824,1,""],[194825,1,""],[194826,1,""],[194827,1,""],[194828,1,""],[194829,1,""],[194830,1,""],[194831,1,""],[194832,1,""],[194833,1,""],[194834,1,""],[194835,1,""],[194836,1,""],[194837,1,""],[194838,1,""],[194839,1,""],[194840,1,""],[194841,1,""],[194842,1,""],[194843,1,""],[194844,1,""],[194845,1,""],[194846,1,""],[194847,1,""],[194848,1,""],[194849,1,""],[194850,1,""],[194851,1,""],[194852,1,""],[194853,1,""],[194854,1,""],[194855,1,""],[194856,1,""],[194857,1,""],[194858,1,""],[194859,1,""],[[194860,194861],1,""],[194862,1,""],[194863,1,""],[194864,1,""],[194865,1,""],[194866,1,""],[194867,1,""],[194868,1,""],[194869,1,""],[194870,1,""],[194871,1,""],[194872,1,""],[194873,1,""],[194874,1,""],[194875,1,""],[194876,1,""],[194877,1,""],[194878,1,""],[194879,1,""],[194880,1,""],[194881,1,""],[194882,1,""],[194883,1,""],[194884,1,""],[194885,1,""],[[194886,194887],1,""],[194888,1,""],[194889,1,""],[194890,1,""],[194891,1,""],[194892,1,""],[194893,1,""],[194894,1,""],[194895,1,""],[194896,1,""],[194897,1,""],[194898,1,""],[194899,1,""],[194900,1,""],[194901,1,""],[194902,1,""],[194903,1,""],[194904,1,""],[194905,1,""],[194906,1,""],[194907,1,""],[194908,1,""],[[194909,194910],1,""],[194911,1,""],[194912,1,""],[194913,1,""],[194914,1,""],[194915,1,""],[194916,1,""],[194917,1,""],[194918,1,""],[194919,1,""],[194920,1,""],[194921,1,""],[194922,1,""],[194923,1,""],[194924,1,""],[194925,1,""],[194926,1,""],[194927,1,""],[194928,1,""],[194929,1,""],[194930,1,""],[194931,1,""],[194932,1,""],[194933,1,""],[194934,1,""],[194935,1,""],[194936,1,""],[194937,1,""],[194938,1,""],[194939,1,""],[194940,1,""],[194941,1,""],[194942,1,""],[194943,1,""],[194944,1,""],[194945,1,""],[194946,1,""],[194947,1,""],[194948,1,""],[194949,1,""],[194950,1,""],[194951,1,""],[194952,1,""],[194953,1,""],[194954,1,""],[194955,1,""],[194956,1,""],[194957,1,""],[194958,1,""],[194959,1,""],[194960,1,""],[194961,1,""],[194962,1,""],[194963,1,""],[194964,1,""],[194965,1,""],[194966,1,""],[194967,1,""],[194968,1,""],[194969,1,""],[194970,1,""],[194971,1,""],[194972,1,""],[194973,1,""],[194974,1,""],[194975,1,""],[194976,1,""],[194977,1,""],[194978,1,""],[194979,1,""],[194980,1,""],[194981,1,""],[194982,1,""],[194983,1,""],[194984,1,""],[194985,1,""],[194986,1,""],[194987,1,""],[194988,1,""],[194989,1,""],[194990,1,""],[194991,1,""],[194992,1,""],[194993,1,""],[194994,1,""],[194995,1,""],[194996,1,""],[194997,1,""],[194998,1,""],[194999,1,""],[195000,1,""],[195001,1,""],[195002,1,""],[195003,1,""],[195004,1,""],[195005,1,""],[195006,1,""],[195007,1,""],[195008,1,""],[195009,1,""],[195010,1,""],[195011,1,""],[195012,1,""],[195013,1,""],[195014,1,""],[195015,1,""],[195016,1,""],[195017,1,""],[195018,1,""],[195019,1,""],[195020,1,""],[195021,1,""],[195022,1,""],[195023,1,""],[195024,1,""],[195025,1,""],[195026,1,""],[195027,1,""],[195028,1,""],[195029,1,""],[195030,1,""],[195031,1,""],[195032,1,""],[195033,1,""],[195034,1,""],[195035,1,""],[195036,1,""],[195037,1,""],[195038,1,""],[195039,1,""],[195040,1,""],[195041,1,""],[195042,1,""],[195043,1,""],[195044,1,""],[195045,1,""],[195046,1,""],[195047,1,""],[195048,1,""],[195049,1,""],[195050,1,""],[195051,1,""],[195052,1,""],[195053,1,""],[195054,1,""],[195055,1,""],[195056,1,""],[195057,1,""],[195058,1,""],[195059,1,""],[195060,1,""],[195061,1,""],[195062,1,""],[195063,1,""],[195064,1,""],[195065,1,""],[195066,1,""],[195067,1,""],[195068,1,""],[195069,1,""],[[195070,195071],1,""],[195072,1,""],[195073,1,""],[195074,1,""],[195075,1,""],[195076,1,""],[195077,1,""],[195078,1,""],[195079,1,""],[195080,1,""],[195081,1,""],[195082,1,""],[195083,1,""],[195084,1,""],[195085,1,""],[195086,1,""],[195087,1,""],[195088,1,""],[195089,1,""],[195090,1,""],[195091,1,""],[195092,1,""],[195093,1,""],[195094,1,""],[195095,1,""],[195096,1,""],[195097,1,""],[195098,1,""],[195099,1,""],[195100,1,""],[195101,1,""],[[195102,196605],3],[[196606,196607],3],[[196608,201546],2],[[201547,201551],3],[[201552,205743],2],[[205744,262141],3],[[262142,262143],3],[[262144,327677],3],[[327678,327679],3],[[327680,393213],3],[[393214,393215],3],[[393216,458749],3],[[458750,458751],3],[[458752,524285],3],[[524286,524287],3],[[524288,589821],3],[[589822,589823],3],[[589824,655357],3],[[655358,655359],3],[[655360,720893],3],[[720894,720895],3],[[720896,786429],3],[[786430,786431],3],[[786432,851965],3],[[851966,851967],3],[[851968,917501],3],[[917502,917503],3],[917504,3],[917505,3],[[917506,917535],3],[[917536,917631],3],[[917632,917759],3],[[917760,917999],7],[[918000,983037],3],[[983038,983039],3],[[983040,1048573],3],[[1048574,1048575],3],[[1048576,1114109],3],[[1114110,1114111],3]]');
var statusMapping = {};
var hasRequiredStatusMapping;
function requireStatusMapping() {
  if (hasRequiredStatusMapping) return statusMapping;
  hasRequiredStatusMapping = 1;
  statusMapping.STATUS_MAPPING = {
    mapped: 1,
    valid: 2,
    disallowed: 3,
    deviation: 6,
    ignored: 7
  };
  return statusMapping;
}
var tr46;
var hasRequiredTr46;
function requireTr46() {
  if (hasRequiredTr46) return tr46;
  hasRequiredTr46 = 1;
  const punycode2 = require$$0$5;
  const regexes2 = requireRegexes();
  const mappingTable = require$$2$1;
  const { STATUS_MAPPING } = requireStatusMapping();
  function containsNonASCII(str) {
    return /[^\x00-\x7F]/u.test(str);
  }
  function findStatus(val) {
    let start = 0;
    let end2 = mappingTable.length - 1;
    while (start <= end2) {
      const mid = Math.floor((start + end2) / 2);
      const target = mappingTable[mid];
      const min = Array.isArray(target[0]) ? target[0][0] : target[0];
      const max = Array.isArray(target[0]) ? target[0][1] : target[0];
      if (min <= val && max >= val) {
        return target.slice(1);
      } else if (min > val) {
        end2 = mid - 1;
      } else {
        start = mid + 1;
      }
    }
    return null;
  }
  function mapChars(domainName, { transitionalProcessing }) {
    let processed = "";
    for (const ch of domainName) {
      const [status, mapping] = findStatus(ch.codePointAt(0));
      switch (status) {
        case STATUS_MAPPING.disallowed:
          processed += ch;
          break;
        case STATUS_MAPPING.ignored:
          break;
        case STATUS_MAPPING.mapped:
          if (transitionalProcessing && ch === "") {
            processed += "ss";
          } else {
            processed += mapping;
          }
          break;
        case STATUS_MAPPING.deviation:
          if (transitionalProcessing) {
            processed += mapping;
          } else {
            processed += ch;
          }
          break;
        case STATUS_MAPPING.valid:
          processed += ch;
          break;
      }
    }
    return processed;
  }
  function validateLabel(label, {
    checkHyphens,
    checkBidi,
    checkJoiners,
    transitionalProcessing,
    useSTD3ASCIIRules,
    isBidi
  }) {
    if (label.length === 0) {
      return true;
    }
    if (label.normalize("NFC") !== label) {
      return false;
    }
    const codePoints = Array.from(label);
    if (checkHyphens) {
      if (codePoints[2] === "-" && codePoints[3] === "-" || (label.startsWith("-") || label.endsWith("-"))) {
        return false;
      }
    }
    if (!checkHyphens) {
      if (label.startsWith("xn--")) {
        return false;
      }
    }
    if (label.includes(".")) {
      return false;
    }
    if (regexes2.combiningMarks.test(codePoints[0])) {
      return false;
    }
    for (const ch of codePoints) {
      const codePoint = ch.codePointAt(0);
      const [status] = findStatus(codePoint);
      if (transitionalProcessing) {
        if (status !== STATUS_MAPPING.valid) {
          return false;
        }
      } else if (status !== STATUS_MAPPING.valid && status !== STATUS_MAPPING.deviation) {
        return false;
      }
      if (useSTD3ASCIIRules && codePoint <= 127) {
        if (!/^(?:[a-z]|[0-9]|-)$/u.test(ch)) {
          return false;
        }
      }
    }
    if (checkJoiners) {
      let last = 0;
      for (const [i, ch] of codePoints.entries()) {
        if (ch === "" || ch === "") {
          if (i > 0) {
            if (regexes2.combiningClassVirama.test(codePoints[i - 1])) {
              continue;
            }
            if (ch === "") {
              const next = codePoints.indexOf("", i + 1);
              const test = next < 0 ? codePoints.slice(last) : codePoints.slice(last, next);
              if (regexes2.validZWNJ.test(test.join(""))) {
                last = i + 1;
                continue;
              }
            }
          }
          return false;
        }
      }
    }
    if (checkBidi && isBidi) {
      let rtl;
      if (regexes2.bidiS1LTR.test(codePoints[0])) {
        rtl = false;
      } else if (regexes2.bidiS1RTL.test(codePoints[0])) {
        rtl = true;
      } else {
        return false;
      }
      if (rtl) {
        if (!regexes2.bidiS2.test(label) || !regexes2.bidiS3.test(label) || regexes2.bidiS4EN.test(label) && regexes2.bidiS4AN.test(label)) {
          return false;
        }
      } else if (!regexes2.bidiS5.test(label) || !regexes2.bidiS6.test(label)) {
        return false;
      }
    }
    return true;
  }
  function isBidiDomain(labels) {
    const domain = labels.map((label) => {
      if (label.startsWith("xn--")) {
        try {
          return punycode2.decode(label.substring(4));
        } catch {
          return "";
        }
      }
      return label;
    }).join(".");
    return regexes2.bidiDomain.test(domain);
  }
  function processing(domainName, options) {
    let string = mapChars(domainName, options);
    string = string.normalize("NFC");
    const labels = string.split(".");
    const isBidi = isBidiDomain(labels);
    let error2 = false;
    for (const [i, origLabel] of labels.entries()) {
      let label = origLabel;
      let transitionalProcessingForThisLabel = options.transitionalProcessing;
      if (label.startsWith("xn--")) {
        if (containsNonASCII(label)) {
          error2 = true;
          continue;
        }
        try {
          label = punycode2.decode(label.substring(4));
        } catch {
          if (!options.ignoreInvalidPunycode) {
            error2 = true;
            continue;
          }
        }
        labels[i] = label;
        if (label === "" || !containsNonASCII(label)) {
          error2 = true;
        }
        transitionalProcessingForThisLabel = false;
      }
      if (error2) {
        continue;
      }
      const validation = validateLabel(label, {
        ...options,
        transitionalProcessing: transitionalProcessingForThisLabel,
        isBidi
      });
      if (!validation) {
        error2 = true;
      }
    }
    return {
      string: labels.join("."),
      error: error2
    };
  }
  function toASCII2(domainName, {
    checkHyphens = false,
    checkBidi = false,
    checkJoiners = false,
    useSTD3ASCIIRules = false,
    verifyDNSLength = false,
    transitionalProcessing = false,
    ignoreInvalidPunycode = false
  } = {}) {
    const result = processing(domainName, {
      checkHyphens,
      checkBidi,
      checkJoiners,
      useSTD3ASCIIRules,
      transitionalProcessing,
      ignoreInvalidPunycode
    });
    let labels = result.string.split(".");
    labels = labels.map((l) => {
      if (containsNonASCII(l)) {
        try {
          return `xn--${punycode2.encode(l)}`;
        } catch {
          result.error = true;
        }
      }
      return l;
    });
    if (verifyDNSLength) {
      const total = labels.join(".").length;
      if (total > 253 || total === 0) {
        result.error = true;
      }
      for (let i = 0; i < labels.length; ++i) {
        if (labels[i].length > 63 || labels[i].length === 0) {
          result.error = true;
          break;
        }
      }
    }
    if (result.error) {
      return null;
    }
    return labels.join(".");
  }
  function toUnicode2(domainName, {
    checkHyphens = false,
    checkBidi = false,
    checkJoiners = false,
    useSTD3ASCIIRules = false,
    transitionalProcessing = false,
    ignoreInvalidPunycode = false
  } = {}) {
    const result = processing(domainName, {
      checkHyphens,
      checkBidi,
      checkJoiners,
      useSTD3ASCIIRules,
      transitionalProcessing,
      ignoreInvalidPunycode
    });
    return {
      domain: result.string,
      error: result.error
    };
  }
  tr46 = {
    toASCII: toASCII2,
    toUnicode: toUnicode2
  };
  return tr46;
}
var infra;
var hasRequiredInfra;
function requireInfra() {
  if (hasRequiredInfra) return infra;
  hasRequiredInfra = 1;
  function isASCIIDigit(c) {
    return c >= 48 && c <= 57;
  }
  function isASCIIAlpha(c) {
    return c >= 65 && c <= 90 || c >= 97 && c <= 122;
  }
  function isASCIIAlphanumeric(c) {
    return isASCIIAlpha(c) || isASCIIDigit(c);
  }
  function isASCIIHex(c) {
    return isASCIIDigit(c) || c >= 65 && c <= 70 || c >= 97 && c <= 102;
  }
  infra = {
    isASCIIDigit,
    isASCIIAlpha,
    isASCIIAlphanumeric,
    isASCIIHex
  };
  return infra;
}
var encoding;
var hasRequiredEncoding;
function requireEncoding() {
  if (hasRequiredEncoding) return encoding;
  hasRequiredEncoding = 1;
  const utf8Encoder = new TextEncoder();
  const utf8Decoder = new TextDecoder("utf-8", { ignoreBOM: true });
  function utf8Encode(string) {
    return utf8Encoder.encode(string);
  }
  function utf8DecodeWithoutBOM(bytes) {
    return utf8Decoder.decode(bytes);
  }
  encoding = {
    utf8Encode,
    utf8DecodeWithoutBOM
  };
  return encoding;
}
var percentEncoding;
var hasRequiredPercentEncoding;
function requirePercentEncoding() {
  if (hasRequiredPercentEncoding) return percentEncoding;
  hasRequiredPercentEncoding = 1;
  const { isASCIIHex } = requireInfra();
  const { utf8Encode } = requireEncoding();
  function p2(char) {
    return char.codePointAt(0);
  }
  function percentEncode(c) {
    let hex = c.toString(16).toUpperCase();
    if (hex.length === 1) {
      hex = `0${hex}`;
    }
    return `%${hex}`;
  }
  function percentDecodeBytes(input) {
    const output = new Uint8Array(input.byteLength);
    let outputIndex = 0;
    for (let i = 0; i < input.byteLength; ++i) {
      const byte = input[i];
      if (byte !== 37) {
        output[outputIndex++] = byte;
      } else if (byte === 37 && (!isASCIIHex(input[i + 1]) || !isASCIIHex(input[i + 2]))) {
        output[outputIndex++] = byte;
      } else {
        const bytePoint = parseInt(String.fromCodePoint(input[i + 1], input[i + 2]), 16);
        output[outputIndex++] = bytePoint;
        i += 2;
      }
    }
    return output.slice(0, outputIndex);
  }
  function percentDecodeString(input) {
    const bytes = utf8Encode(input);
    return percentDecodeBytes(bytes);
  }
  function isC0ControlPercentEncode(c) {
    return c <= 31 || c > 126;
  }
  const extraFragmentPercentEncodeSet = /* @__PURE__ */ new Set([p2(" "), p2('"'), p2("<"), p2(">"), p2("`")]);
  function isFragmentPercentEncode(c) {
    return isC0ControlPercentEncode(c) || extraFragmentPercentEncodeSet.has(c);
  }
  const extraQueryPercentEncodeSet = /* @__PURE__ */ new Set([p2(" "), p2('"'), p2("#"), p2("<"), p2(">")]);
  function isQueryPercentEncode(c) {
    return isC0ControlPercentEncode(c) || extraQueryPercentEncodeSet.has(c);
  }
  function isSpecialQueryPercentEncode(c) {
    return isQueryPercentEncode(c) || c === p2("'");
  }
  const extraPathPercentEncodeSet = /* @__PURE__ */ new Set([p2("?"), p2("`"), p2("{"), p2("}"), p2("^")]);
  function isPathPercentEncode(c) {
    return isQueryPercentEncode(c) || extraPathPercentEncodeSet.has(c);
  }
  const extraUserinfoPercentEncodeSet = /* @__PURE__ */ new Set([p2("/"), p2(":"), p2(";"), p2("="), p2("@"), p2("["), p2("\\"), p2("]"), p2("|")]);
  function isUserinfoPercentEncode(c) {
    return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
  }
  const extraComponentPercentEncodeSet = /* @__PURE__ */ new Set([p2("$"), p2("%"), p2("&"), p2("+"), p2(",")]);
  function isComponentPercentEncode(c) {
    return isUserinfoPercentEncode(c) || extraComponentPercentEncodeSet.has(c);
  }
  const extraURLEncodedPercentEncodeSet = /* @__PURE__ */ new Set([p2("!"), p2("'"), p2("("), p2(")"), p2("~")]);
  function isURLEncodedPercentEncode(c) {
    return isComponentPercentEncode(c) || extraURLEncodedPercentEncodeSet.has(c);
  }
  function utf8PercentEncodeCodePointInternal(codePoint, percentEncodePredicate) {
    const bytes = utf8Encode(codePoint);
    let output = "";
    for (const byte of bytes) {
      if (!percentEncodePredicate(byte)) {
        output += String.fromCharCode(byte);
      } else {
        output += percentEncode(byte);
      }
    }
    return output;
  }
  function utf8PercentEncodeCodePoint(codePoint, percentEncodePredicate) {
    return utf8PercentEncodeCodePointInternal(String.fromCodePoint(codePoint), percentEncodePredicate);
  }
  function utf8PercentEncodeString(input, percentEncodePredicate, spaceAsPlus = false) {
    let output = "";
    for (const codePoint of input) {
      if (spaceAsPlus && codePoint === " ") {
        output += "+";
      } else {
        output += utf8PercentEncodeCodePointInternal(codePoint, percentEncodePredicate);
      }
    }
    return output;
  }
  percentEncoding = {
    isC0ControlPercentEncode,
    isFragmentPercentEncode,
    isQueryPercentEncode,
    isSpecialQueryPercentEncode,
    isPathPercentEncode,
    isUserinfoPercentEncode,
    isURLEncodedPercentEncode,
    percentDecodeString,
    percentDecodeBytes,
    utf8PercentEncodeString,
    utf8PercentEncodeCodePoint
  };
  return percentEncoding;
}
var hasRequiredUrlStateMachine;
function requireUrlStateMachine() {
  if (hasRequiredUrlStateMachine) return urlStateMachine.exports;
  hasRequiredUrlStateMachine = 1;
  (function(module) {
    const tr462 = requireTr46();
    const infra2 = requireInfra();
    const { utf8DecodeWithoutBOM } = requireEncoding();
    const {
      percentDecodeString,
      utf8PercentEncodeCodePoint,
      utf8PercentEncodeString,
      isC0ControlPercentEncode,
      isFragmentPercentEncode,
      isQueryPercentEncode,
      isSpecialQueryPercentEncode,
      isPathPercentEncode,
      isUserinfoPercentEncode
    } = requirePercentEncoding();
    function p2(char) {
      return char.codePointAt(0);
    }
    const specialSchemes = {
      ftp: 21,
      file: null,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    const failure = Symbol("failure");
    function countSymbols(str) {
      return [...str].length;
    }
    function at2(input, idx) {
      const c = input[idx];
      return isNaN(c) ? void 0 : String.fromCodePoint(c);
    }
    function isSingleDot(buffer2) {
      return buffer2 === "." || buffer2.toLowerCase() === "%2e";
    }
    function isDoubleDot(buffer2) {
      buffer2 = buffer2.toLowerCase();
      return buffer2 === ".." || buffer2 === "%2e." || buffer2 === ".%2e" || buffer2 === "%2e%2e";
    }
    function isWindowsDriveLetterCodePoints(cp1, cp2) {
      return infra2.isASCIIAlpha(cp1) && (cp2 === p2(":") || cp2 === p2("|"));
    }
    function isWindowsDriveLetterString(string) {
      return string.length === 2 && infra2.isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
    }
    function isNormalizedWindowsDriveLetterString(string) {
      return string.length === 2 && infra2.isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
    }
    function containsForbiddenHostCodePoint(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|<|>|\?|@|\[|\\|\]|\^|\|/u) !== -1;
    }
    function containsForbiddenDomainCodePoint(string) {
      return containsForbiddenHostCodePoint(string) || string.search(/[\u0000-\u001F]|%|\u007F/u) !== -1;
    }
    function isSpecialScheme(scheme) {
      return specialSchemes[scheme] !== void 0;
    }
    function isSpecial(url) {
      return isSpecialScheme(url.scheme);
    }
    function isNotSpecial(url) {
      return !isSpecialScheme(url.scheme);
    }
    function defaultPort(scheme) {
      return specialSchemes[scheme];
    }
    function parseIPv4Number(input) {
      if (input === "") {
        return failure;
      }
      let R2 = 10;
      if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
        input = input.substring(2);
        R2 = 16;
      } else if (input.length >= 2 && input.charAt(0) === "0") {
        input = input.substring(1);
        R2 = 8;
      }
      if (input === "") {
        return 0;
      }
      let regex = /[^0-7]/u;
      if (R2 === 10) {
        regex = /[^0-9]/u;
      }
      if (R2 === 16) {
        regex = /[^0-9A-Fa-f]/u;
      }
      if (regex.test(input)) {
        return failure;
      }
      return parseInt(input, R2);
    }
    function parseIPv4(input) {
      const parts = input.split(".");
      if (parts[parts.length - 1] === "") {
        if (parts.length > 1) {
          parts.pop();
        }
      }
      if (parts.length > 4) {
        return failure;
      }
      const numbers = [];
      for (const part of parts) {
        const n = parseIPv4Number(part);
        if (n === failure) {
          return failure;
        }
        numbers.push(n);
      }
      for (let i = 0; i < numbers.length - 1; ++i) {
        if (numbers[i] > 255) {
          return failure;
        }
      }
      if (numbers[numbers.length - 1] >= 256 ** (5 - numbers.length)) {
        return failure;
      }
      let ipv4 = numbers.pop();
      let counter = 0;
      for (const n of numbers) {
        ipv4 += n * 256 ** (3 - counter);
        ++counter;
      }
      return ipv4;
    }
    function serializeIPv4(address) {
      let output = "";
      let n = address;
      for (let i = 1; i <= 4; ++i) {
        output = String(n % 256) + output;
        if (i !== 4) {
          output = `.${output}`;
        }
        n = Math.floor(n / 256);
      }
      return output;
    }
    function parseIPv6(input) {
      const address = [0, 0, 0, 0, 0, 0, 0, 0];
      let pieceIndex = 0;
      let compress = null;
      let pointer = 0;
      input = Array.from(input, (c) => c.codePointAt(0));
      if (input[pointer] === p2(":")) {
        if (input[pointer + 1] !== p2(":")) {
          return failure;
        }
        pointer += 2;
        ++pieceIndex;
        compress = pieceIndex;
      }
      while (pointer < input.length) {
        if (pieceIndex === 8) {
          return failure;
        }
        if (input[pointer] === p2(":")) {
          if (compress !== null) {
            return failure;
          }
          ++pointer;
          ++pieceIndex;
          compress = pieceIndex;
          continue;
        }
        let value = 0;
        let length = 0;
        while (length < 4 && infra2.isASCIIHex(input[pointer])) {
          value = value * 16 + parseInt(at2(input, pointer), 16);
          ++pointer;
          ++length;
        }
        if (input[pointer] === p2(".")) {
          if (length === 0) {
            return failure;
          }
          pointer -= length;
          if (pieceIndex > 6) {
            return failure;
          }
          let numbersSeen = 0;
          while (input[pointer] !== void 0) {
            let ipv4Piece = null;
            if (numbersSeen > 0) {
              if (input[pointer] === p2(".") && numbersSeen < 4) {
                ++pointer;
              } else {
                return failure;
              }
            }
            if (!infra2.isASCIIDigit(input[pointer])) {
              return failure;
            }
            while (infra2.isASCIIDigit(input[pointer])) {
              const number = parseInt(at2(input, pointer));
              if (ipv4Piece === null) {
                ipv4Piece = number;
              } else if (ipv4Piece === 0) {
                return failure;
              } else {
                ipv4Piece = ipv4Piece * 10 + number;
              }
              if (ipv4Piece > 255) {
                return failure;
              }
              ++pointer;
            }
            address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
            ++numbersSeen;
            if (numbersSeen === 2 || numbersSeen === 4) {
              ++pieceIndex;
            }
          }
          if (numbersSeen !== 4) {
            return failure;
          }
          break;
        } else if (input[pointer] === p2(":")) {
          ++pointer;
          if (input[pointer] === void 0) {
            return failure;
          }
        } else if (input[pointer] !== void 0) {
          return failure;
        }
        address[pieceIndex] = value;
        ++pieceIndex;
      }
      if (compress !== null) {
        let swaps = pieceIndex - compress;
        pieceIndex = 7;
        while (pieceIndex !== 0 && swaps > 0) {
          const temp = address[compress + swaps - 1];
          address[compress + swaps - 1] = address[pieceIndex];
          address[pieceIndex] = temp;
          --pieceIndex;
          --swaps;
        }
      } else if (compress === null && pieceIndex !== 8) {
        return failure;
      }
      return address;
    }
    function serializeIPv6(address) {
      let output = "";
      const compress = findTheIPv6AddressCompressedPieceIndex(address);
      let ignore0 = false;
      for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
        if (ignore0 && address[pieceIndex] === 0) {
          continue;
        } else if (ignore0) {
          ignore0 = false;
        }
        if (compress === pieceIndex) {
          const separator = pieceIndex === 0 ? "::" : ":";
          output += separator;
          ignore0 = true;
          continue;
        }
        output += address[pieceIndex].toString(16);
        if (pieceIndex !== 7) {
          output += ":";
        }
      }
      return output;
    }
    function parseHost(input, isOpaque = false) {
      if (input[0] === "[") {
        if (input[input.length - 1] !== "]") {
          return failure;
        }
        return parseIPv6(input.substring(1, input.length - 1));
      }
      if (isOpaque) {
        return parseOpaqueHost(input);
      }
      const domain = utf8DecodeWithoutBOM(percentDecodeString(input));
      const asciiDomain = domainToASCII(domain);
      if (asciiDomain === failure) {
        return failure;
      }
      if (endsInANumber(asciiDomain)) {
        return parseIPv4(asciiDomain);
      }
      return asciiDomain;
    }
    function endsInANumber(input) {
      const parts = input.split(".");
      if (parts[parts.length - 1] === "") {
        if (parts.length === 1) {
          return false;
        }
        parts.pop();
      }
      const last = parts[parts.length - 1];
      if (parseIPv4Number(last) !== failure) {
        return true;
      }
      if (/^[0-9]+$/u.test(last)) {
        return true;
      }
      return false;
    }
    function parseOpaqueHost(input) {
      if (containsForbiddenHostCodePoint(input)) {
        return failure;
      }
      return utf8PercentEncodeString(input, isC0ControlPercentEncode);
    }
    function findTheIPv6AddressCompressedPieceIndex(address) {
      let longestIndex = null;
      let longestSize = 1;
      let foundIndex = null;
      let foundSize = 0;
      for (let pieceIndex = 0; pieceIndex < address.length; ++pieceIndex) {
        if (address[pieceIndex] !== 0) {
          if (foundSize > longestSize) {
            longestIndex = foundIndex;
            longestSize = foundSize;
          }
          foundIndex = null;
          foundSize = 0;
        } else {
          if (foundIndex === null) {
            foundIndex = pieceIndex;
          }
          ++foundSize;
        }
      }
      if (foundSize > longestSize) {
        return foundIndex;
      }
      return longestIndex;
    }
    function serializeHost(host) {
      if (typeof host === "number") {
        return serializeIPv4(host);
      }
      if (host instanceof Array) {
        return `[${serializeIPv6(host)}]`;
      }
      return host;
    }
    function domainToASCII(domain, beStrict = false) {
      const result = tr462.toASCII(domain, {
        checkHyphens: beStrict,
        checkBidi: true,
        checkJoiners: true,
        useSTD3ASCIIRules: beStrict,
        transitionalProcessing: false,
        verifyDNSLength: beStrict,
        ignoreInvalidPunycode: false
      });
      if (result === null) {
        return failure;
      }
      if (!beStrict) {
        if (result === "") {
          return failure;
        }
        if (containsForbiddenDomainCodePoint(result)) {
          return failure;
        }
      }
      return result;
    }
    function trimControlChars(string) {
      let start = 0;
      let end2 = string.length;
      for (; start < end2; ++start) {
        if (string.charCodeAt(start) > 32) {
          break;
        }
      }
      for (; end2 > start; --end2) {
        if (string.charCodeAt(end2 - 1) > 32) {
          break;
        }
      }
      return string.substring(start, end2);
    }
    function trimTabAndNewline(url) {
      return url.replace(/\u0009|\u000A|\u000D/ug, "");
    }
    function shortenPath(url) {
      const { path } = url;
      if (path.length === 0) {
        return;
      }
      if (url.scheme === "file" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {
        return;
      }
      path.pop();
    }
    function includesCredentials(url) {
      return url.username !== "" || url.password !== "";
    }
    function cannotHaveAUsernamePasswordPort(url) {
      return url.host === null || url.host === "" || url.scheme === "file";
    }
    function hasAnOpaquePath(url) {
      return typeof url.path === "string";
    }
    function isNormalizedWindowsDriveLetter(string) {
      return /^[A-Za-z]:$/u.test(string);
    }
    function URLStateMachine(input, base2, encodingOverride, url, stateOverride) {
      this.pointer = 0;
      this.input = input;
      this.base = base2 || null;
      this.encodingOverride = encodingOverride || "utf-8";
      this.stateOverride = stateOverride;
      this.url = url;
      this.failure = false;
      this.parseError = false;
      if (!this.url) {
        this.url = {
          scheme: "",
          username: "",
          password: "",
          host: null,
          port: null,
          path: [],
          query: null,
          fragment: null
        };
        const res2 = trimControlChars(this.input);
        if (res2 !== this.input) {
          this.parseError = true;
        }
        this.input = res2;
      }
      const res = trimTabAndNewline(this.input);
      if (res !== this.input) {
        this.parseError = true;
      }
      this.input = res;
      this.state = stateOverride || "scheme start";
      this.buffer = "";
      this.atFlag = false;
      this.arrFlag = false;
      this.passwordTokenSeenFlag = false;
      this.input = Array.from(this.input, (c) => c.codePointAt(0));
      for (; this.pointer <= this.input.length; ++this.pointer) {
        const c = this.input[this.pointer];
        const cStr = isNaN(c) ? void 0 : String.fromCodePoint(c);
        const ret = this[`parse ${this.state}`](c, cStr);
        if (!ret) {
          break;
        } else if (ret === failure) {
          this.failure = true;
          break;
        }
      }
    }
    URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
      if (infra2.isASCIIAlpha(c)) {
        this.buffer += cStr.toLowerCase();
        this.state = "scheme";
      } else if (!this.stateOverride) {
        this.state = "no scheme";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
      if (infra2.isASCIIAlphanumeric(c) || c === p2("+") || c === p2("-") || c === p2(".")) {
        this.buffer += cStr.toLowerCase();
      } else if (c === p2(":")) {
        if (this.stateOverride) {
          if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
            return false;
          }
          if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
            return false;
          }
          if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
            return false;
          }
          if (this.url.scheme === "file" && this.url.host === "") {
            return false;
          }
        }
        this.url.scheme = this.buffer;
        if (this.stateOverride) {
          if (this.url.port === defaultPort(this.url.scheme)) {
            this.url.port = null;
          }
          return false;
        }
        this.buffer = "";
        if (this.url.scheme === "file") {
          if (this.input[this.pointer + 1] !== p2("/") || this.input[this.pointer + 2] !== p2("/")) {
            this.parseError = true;
          }
          this.state = "file";
        } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
          this.state = "special relative or authority";
        } else if (isSpecial(this.url)) {
          this.state = "special authority slashes";
        } else if (this.input[this.pointer + 1] === p2("/")) {
          this.state = "path or authority";
          ++this.pointer;
        } else {
          this.url.path = "";
          this.state = "opaque path";
        }
      } else if (!this.stateOverride) {
        this.buffer = "";
        this.state = "no scheme";
        this.pointer = -1;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
      if (this.base === null || hasAnOpaquePath(this.base) && c !== p2("#")) {
        return failure;
      } else if (hasAnOpaquePath(this.base) && c === p2("#")) {
        this.url.scheme = this.base.scheme;
        this.url.path = this.base.path;
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.state = "fragment";
      } else if (this.base.scheme === "file") {
        this.state = "file";
        --this.pointer;
      } else {
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
      if (c === p2("/") && this.input[this.pointer + 1] === p2("/")) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
      if (c === p2("/")) {
        this.state = "authority";
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
      this.url.scheme = this.base.scheme;
      if (c === p2("/")) {
        this.state = "relative slash";
      } else if (isSpecial(this.url) && c === p2("\\")) {
        this.parseError = true;
        this.state = "relative slash";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        if (c === p2("?")) {
          this.url.query = "";
          this.state = "query";
        } else if (c === p2("#")) {
          this.url.fragment = "";
          this.state = "fragment";
        } else if (!isNaN(c)) {
          this.url.query = null;
          this.url.path.pop();
          this.state = "path";
          --this.pointer;
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
      if (isSpecial(this.url) && (c === p2("/") || c === p2("\\"))) {
        if (c === p2("\\")) {
          this.parseError = true;
        }
        this.state = "special authority ignore slashes";
      } else if (c === p2("/")) {
        this.state = "authority";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
      if (c === p2("/") && this.input[this.pointer + 1] === p2("/")) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "special authority ignore slashes";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
      if (c !== p2("/") && c !== p2("\\")) {
        this.state = "authority";
        --this.pointer;
      } else {
        this.parseError = true;
      }
      return true;
    };
    URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
      if (c === p2("@")) {
        this.parseError = true;
        if (this.atFlag) {
          this.buffer = `%40${this.buffer}`;
        }
        this.atFlag = true;
        const len = countSymbols(this.buffer);
        for (let pointer = 0; pointer < len; ++pointer) {
          const codePoint = this.buffer.codePointAt(pointer);
          if (codePoint === p2(":") && !this.passwordTokenSeenFlag) {
            this.passwordTokenSeenFlag = true;
            continue;
          }
          const encodedCodePoints = utf8PercentEncodeCodePoint(codePoint, isUserinfoPercentEncode);
          if (this.passwordTokenSeenFlag) {
            this.url.password += encodedCodePoints;
          } else {
            this.url.username += encodedCodePoints;
          }
        }
        this.buffer = "";
      } else if (isNaN(c) || c === p2("/") || c === p2("?") || c === p2("#") || isSpecial(this.url) && c === p2("\\")) {
        if (this.atFlag && this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        this.pointer -= countSymbols(this.buffer) + 1;
        this.buffer = "";
        this.state = "host";
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
      if (this.stateOverride && this.url.scheme === "file") {
        --this.pointer;
        this.state = "file host";
      } else if (c === p2(":") && !this.arrFlag) {
        if (this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        if (this.stateOverride === "hostname") {
          return false;
        }
        const host = parseHost(this.buffer, isNotSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "port";
      } else if (isNaN(c) || c === p2("/") || c === p2("?") || c === p2("#") || isSpecial(this.url) && c === p2("\\")) {
        --this.pointer;
        if (isSpecial(this.url) && this.buffer === "") {
          this.parseError = true;
          return failure;
        } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
          this.parseError = true;
          return false;
        }
        const host = parseHost(this.buffer, isNotSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "path start";
        if (this.stateOverride) {
          return false;
        }
      } else {
        if (c === p2("[")) {
          this.arrFlag = true;
        } else if (c === p2("]")) {
          this.arrFlag = false;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
      if (infra2.isASCIIDigit(c)) {
        this.buffer += cStr;
      } else if (isNaN(c) || c === p2("/") || c === p2("?") || c === p2("#") || isSpecial(this.url) && c === p2("\\") || this.stateOverride) {
        if (this.buffer !== "") {
          const port = parseInt(this.buffer);
          if (port > 2 ** 16 - 1) {
            this.parseError = true;
            return failure;
          }
          this.url.port = port === defaultPort(this.url.scheme) ? null : port;
          this.buffer = "";
        }
        if (this.stateOverride) {
          return false;
        }
        this.state = "path start";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    const fileOtherwiseCodePoints = /* @__PURE__ */ new Set([p2("/"), p2("\\"), p2("?"), p2("#")]);
    function startsWithWindowsDriveLetter(input, pointer) {
      const length = input.length - pointer;
      return length >= 2 && isWindowsDriveLetterCodePoints(input[pointer], input[pointer + 1]) && (length === 2 || fileOtherwiseCodePoints.has(input[pointer + 2]));
    }
    URLStateMachine.prototype["parse file"] = function parseFile(c) {
      this.url.scheme = "file";
      this.url.host = "";
      if (c === p2("/") || c === p2("\\")) {
        if (c === p2("\\")) {
          this.parseError = true;
        }
        this.state = "file slash";
      } else if (this.base !== null && this.base.scheme === "file") {
        this.url.host = this.base.host;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        if (c === p2("?")) {
          this.url.query = "";
          this.state = "query";
        } else if (c === p2("#")) {
          this.url.fragment = "";
          this.state = "fragment";
        } else if (!isNaN(c)) {
          this.url.query = null;
          if (!startsWithWindowsDriveLetter(this.input, this.pointer)) {
            shortenPath(this.url);
          } else {
            this.parseError = true;
            this.url.path = [];
          }
          this.state = "path";
          --this.pointer;
        }
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
      if (c === p2("/") || c === p2("\\")) {
        if (c === p2("\\")) {
          this.parseError = true;
        }
        this.state = "file host";
      } else {
        if (this.base !== null && this.base.scheme === "file") {
          if (!startsWithWindowsDriveLetter(this.input, this.pointer) && isNormalizedWindowsDriveLetterString(this.base.path[0])) {
            this.url.path.push(this.base.path[0]);
          }
          this.url.host = this.base.host;
        }
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
      if (isNaN(c) || c === p2("/") || c === p2("\\") || c === p2("?") || c === p2("#")) {
        --this.pointer;
        if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
          this.parseError = true;
          this.state = "path";
        } else if (this.buffer === "") {
          this.url.host = "";
          if (this.stateOverride) {
            return false;
          }
          this.state = "path start";
        } else {
          let host = parseHost(this.buffer, isNotSpecial(this.url));
          if (host === failure) {
            return failure;
          }
          if (host === "localhost") {
            host = "";
          }
          this.url.host = host;
          if (this.stateOverride) {
            return false;
          }
          this.buffer = "";
          this.state = "path start";
        }
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
      if (isSpecial(this.url)) {
        if (c === p2("\\")) {
          this.parseError = true;
        }
        this.state = "path";
        if (c !== p2("/") && c !== p2("\\")) {
          --this.pointer;
        }
      } else if (!this.stateOverride && c === p2("?")) {
        this.url.query = "";
        this.state = "query";
      } else if (!this.stateOverride && c === p2("#")) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (c !== void 0) {
        this.state = "path";
        if (c !== p2("/")) {
          --this.pointer;
        }
      } else if (this.stateOverride && this.url.host === null) {
        this.url.path.push("");
      }
      return true;
    };
    URLStateMachine.prototype["parse path"] = function parsePath(c) {
      if (isNaN(c) || c === p2("/") || isSpecial(this.url) && c === p2("\\") || !this.stateOverride && (c === p2("?") || c === p2("#"))) {
        if (isSpecial(this.url) && c === p2("\\")) {
          this.parseError = true;
        }
        if (isDoubleDot(this.buffer)) {
          shortenPath(this.url);
          if (c !== p2("/") && !(isSpecial(this.url) && c === p2("\\"))) {
            this.url.path.push("");
          }
        } else if (isSingleDot(this.buffer) && c !== p2("/") && !(isSpecial(this.url) && c === p2("\\"))) {
          this.url.path.push("");
        } else if (!isSingleDot(this.buffer)) {
          if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
            this.buffer = `${this.buffer[0]}:`;
          }
          this.url.path.push(this.buffer);
        }
        this.buffer = "";
        if (c === p2("?")) {
          this.url.query = "";
          this.state = "query";
        }
        if (c === p2("#")) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c === p2("%") && (!infra2.isASCIIHex(this.input[this.pointer + 1]) || !infra2.isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += utf8PercentEncodeCodePoint(c, isPathPercentEncode);
      }
      return true;
    };
    URLStateMachine.prototype["parse opaque path"] = function parseOpaquePath(c) {
      if (c === p2("?")) {
        this.url.query = "";
        this.state = "query";
      } else if (c === p2("#")) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (c === p2(" ")) {
        const remaining = this.input[this.pointer + 1];
        if (remaining === p2("?") || remaining === p2("#")) {
          this.url.path += "%20";
        } else {
          this.url.path += " ";
        }
      } else {
        if (!isNaN(c) && c !== p2("%")) {
          this.parseError = true;
        }
        if (c === p2("%") && (!infra2.isASCIIHex(this.input[this.pointer + 1]) || !infra2.isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        if (!isNaN(c)) {
          this.url.path += utf8PercentEncodeCodePoint(c, isC0ControlPercentEncode);
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
      if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
        this.encodingOverride = "utf-8";
      }
      if (!this.stateOverride && c === p2("#") || isNaN(c)) {
        const queryPercentEncodePredicate = isSpecial(this.url) ? isSpecialQueryPercentEncode : isQueryPercentEncode;
        this.url.query += utf8PercentEncodeString(this.buffer, queryPercentEncodePredicate);
        this.buffer = "";
        if (c === p2("#")) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else if (!isNaN(c)) {
        if (c === p2("%") && (!infra2.isASCIIHex(this.input[this.pointer + 1]) || !infra2.isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
      if (!isNaN(c)) {
        if (c === p2("%") && (!infra2.isASCIIHex(this.input[this.pointer + 1]) || !infra2.isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.url.fragment += utf8PercentEncodeCodePoint(c, isFragmentPercentEncode);
      }
      return true;
    };
    function serializeURL(url, excludeFragment) {
      let output = `${url.scheme}:`;
      if (url.host !== null) {
        output += "//";
        if (url.username !== "" || url.password !== "") {
          output += url.username;
          if (url.password !== "") {
            output += `:${url.password}`;
          }
          output += "@";
        }
        output += serializeHost(url.host);
        if (url.port !== null) {
          output += `:${url.port}`;
        }
      }
      if (url.host === null && !hasAnOpaquePath(url) && url.path.length > 1 && url.path[0] === "") {
        output += "/.";
      }
      output += serializePath(url);
      if (url.query !== null) {
        output += `?${url.query}`;
      }
      if (!excludeFragment && url.fragment !== null) {
        output += `#${url.fragment}`;
      }
      return output;
    }
    function serializeOrigin(tuple2) {
      let result = `${tuple2.scheme}://`;
      result += serializeHost(tuple2.host);
      if (tuple2.port !== null) {
        result += `:${tuple2.port}`;
      }
      return result;
    }
    function serializePath(url) {
      if (hasAnOpaquePath(url)) {
        return url.path;
      }
      let output = "";
      for (const segment of url.path) {
        output += `/${segment}`;
      }
      return output;
    }
    module.exports.serializeURL = serializeURL;
    module.exports.serializePath = serializePath;
    module.exports.serializeURLOrigin = function(url) {
      switch (url.scheme) {
        case "blob": {
          const pathURL = module.exports.parseURL(serializePath(url));
          if (pathURL === null) {
            return "null";
          }
          if (pathURL.scheme !== "http" && pathURL.scheme !== "https") {
            return "null";
          }
          return module.exports.serializeURLOrigin(pathURL);
        }
        case "ftp":
        case "http":
        case "https":
        case "ws":
        case "wss":
          return serializeOrigin({
            scheme: url.scheme,
            host: url.host,
            port: url.port
          });
        case "file":
          return "null";
        default:
          return "null";
      }
    };
    module.exports.basicURLParse = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
      if (usm.failure) {
        return null;
      }
      return usm.url;
    };
    module.exports.setTheUsername = function(url, username) {
      url.username = utf8PercentEncodeString(username, isUserinfoPercentEncode);
    };
    module.exports.setThePassword = function(url, password) {
      url.password = utf8PercentEncodeString(password, isUserinfoPercentEncode);
    };
    module.exports.serializeHost = serializeHost;
    module.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
    module.exports.hasAnOpaquePath = hasAnOpaquePath;
    module.exports.serializeInteger = function(integer) {
      return String(integer);
    };
    module.exports.parseURL = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      return module.exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
    };
  })(urlStateMachine);
  return urlStateMachine.exports;
}
var urlencoded;
var hasRequiredUrlencoded;
function requireUrlencoded() {
  if (hasRequiredUrlencoded) return urlencoded;
  hasRequiredUrlencoded = 1;
  const { utf8Encode, utf8DecodeWithoutBOM } = requireEncoding();
  const { percentDecodeBytes, utf8PercentEncodeString, isURLEncodedPercentEncode } = requirePercentEncoding();
  function p2(char) {
    return char.codePointAt(0);
  }
  function parseUrlencoded(input) {
    const sequences = strictlySplitByteSequence(input, p2("&"));
    const output = [];
    for (const bytes of sequences) {
      if (bytes.length === 0) {
        continue;
      }
      let name, value;
      const indexOfEqual = bytes.indexOf(p2("="));
      if (indexOfEqual >= 0) {
        name = bytes.slice(0, indexOfEqual);
        value = bytes.slice(indexOfEqual + 1);
      } else {
        name = bytes;
        value = new Uint8Array(0);
      }
      name = replaceByteInByteSequence(name, 43, 32);
      value = replaceByteInByteSequence(value, 43, 32);
      const nameString = utf8DecodeWithoutBOM(percentDecodeBytes(name));
      const valueString = utf8DecodeWithoutBOM(percentDecodeBytes(value));
      output.push([nameString, valueString]);
    }
    return output;
  }
  function parseUrlencodedString(input) {
    return parseUrlencoded(utf8Encode(input));
  }
  function serializeUrlencoded(tuples) {
    let output = "";
    for (const [i, tuple2] of tuples.entries()) {
      const name = utf8PercentEncodeString(tuple2[0], isURLEncodedPercentEncode, true);
      const value = utf8PercentEncodeString(tuple2[1], isURLEncodedPercentEncode, true);
      if (i !== 0) {
        output += "&";
      }
      output += `${name}=${value}`;
    }
    return output;
  }
  function strictlySplitByteSequence(buf2, cp) {
    const list = [];
    let last = 0;
    let i = buf2.indexOf(cp);
    while (i >= 0) {
      list.push(buf2.slice(last, i));
      last = i + 1;
      i = buf2.indexOf(cp, last);
    }
    if (last !== buf2.length) {
      list.push(buf2.slice(last));
    }
    return list;
  }
  function replaceByteInByteSequence(buf2, from, to2) {
    let i = buf2.indexOf(from);
    while (i >= 0) {
      buf2[i] = to2;
      i = buf2.indexOf(from, i + 1);
    }
    return buf2;
  }
  urlencoded = {
    parseUrlencodedString,
    serializeUrlencoded
  };
  return urlencoded;
}
var URLSearchParams$1 = {};
var _Function = {};
var hasRequired_Function;
function require_Function() {
  if (hasRequired_Function) return _Function;
  hasRequired_Function = 1;
  const conversions = requireLib$1();
  const utils2 = requireUtils$5();
  _Function.convert = (globalObject, value, { context = "The provided value" } = {}) => {
    if (typeof value !== "function") {
      throw new globalObject.TypeError(context + " is not a function");
    }
    function invokeTheCallbackFunction(...args) {
      const thisArg = utils2.tryWrapperForImpl(this);
      let callResult;
      for (let i = 0; i < args.length; i++) {
        args[i] = utils2.tryWrapperForImpl(args[i]);
      }
      callResult = Reflect.apply(value, thisArg, args);
      callResult = conversions["any"](callResult, { context, globals: globalObject });
      return callResult;
    }
    invokeTheCallbackFunction.construct = (...args) => {
      for (let i = 0; i < args.length; i++) {
        args[i] = utils2.tryWrapperForImpl(args[i]);
      }
      let callResult = Reflect.construct(value, args);
      callResult = conversions["any"](callResult, { context, globals: globalObject });
      return callResult;
    };
    invokeTheCallbackFunction[utils2.wrapperSymbol] = value;
    invokeTheCallbackFunction.objectReference = value;
    return invokeTheCallbackFunction;
  };
  return _Function;
}
var URLSearchParamsImpl = {};
var hasRequiredURLSearchParamsImpl;
function requireURLSearchParamsImpl() {
  if (hasRequiredURLSearchParamsImpl) return URLSearchParamsImpl;
  hasRequiredURLSearchParamsImpl = 1;
  const urlencoded2 = requireUrlencoded();
  URLSearchParamsImpl.implementation = class URLSearchParamsImpl {
    constructor(globalObject, constructorArgs, { doNotStripQMark = false }) {
      let init = constructorArgs[0];
      this._list = [];
      this._url = null;
      if (!doNotStripQMark && typeof init === "string" && init[0] === "?") {
        init = init.slice(1);
      }
      if (Array.isArray(init)) {
        for (const pair of init) {
          if (pair.length !== 2) {
            throw new TypeError("Failed to construct 'URLSearchParams': parameter 1 sequence's element does not contain exactly two elements.");
          }
          this._list.push([pair[0], pair[1]]);
        }
      } else if (typeof init === "object" && Object.getPrototypeOf(init) === null) {
        for (const name of Object.keys(init)) {
          const value = init[name];
          this._list.push([name, value]);
        }
      } else {
        this._list = urlencoded2.parseUrlencodedString(init);
      }
    }
    _updateSteps() {
      if (this._url !== null) {
        let serializedQuery = urlencoded2.serializeUrlencoded(this._list);
        if (serializedQuery === "") {
          serializedQuery = null;
        }
        this._url._url.query = serializedQuery;
      }
    }
    get size() {
      return this._list.length;
    }
    append(name, value) {
      this._list.push([name, value]);
      this._updateSteps();
    }
    delete(name, value) {
      let i = 0;
      while (i < this._list.length) {
        if (this._list[i][0] === name && (value === void 0 || this._list[i][1] === value)) {
          this._list.splice(i, 1);
        } else {
          i++;
        }
      }
      this._updateSteps();
    }
    get(name) {
      for (const tuple2 of this._list) {
        if (tuple2[0] === name) {
          return tuple2[1];
        }
      }
      return null;
    }
    getAll(name) {
      const output = [];
      for (const tuple2 of this._list) {
        if (tuple2[0] === name) {
          output.push(tuple2[1]);
        }
      }
      return output;
    }
    has(name, value) {
      for (const tuple2 of this._list) {
        if (tuple2[0] === name && (value === void 0 || tuple2[1] === value)) {
          return true;
        }
      }
      return false;
    }
    set(name, value) {
      let found = false;
      let i = 0;
      while (i < this._list.length) {
        if (this._list[i][0] === name) {
          if (found) {
            this._list.splice(i, 1);
          } else {
            found = true;
            this._list[i][1] = value;
            i++;
          }
        } else {
          i++;
        }
      }
      if (!found) {
        this._list.push([name, value]);
      }
      this._updateSteps();
    }
    sort() {
      this._list.sort((a2, b2) => {
        if (a2[0] < b2[0]) {
          return -1;
        }
        if (a2[0] > b2[0]) {
          return 1;
        }
        return 0;
      });
      this._updateSteps();
    }
    [Symbol.iterator]() {
      return this._list[Symbol.iterator]();
    }
    toString() {
      return urlencoded2.serializeUrlencoded(this._list);
    }
  };
  return URLSearchParamsImpl;
}
var hasRequiredURLSearchParams;
function requireURLSearchParams() {
  if (hasRequiredURLSearchParams) return URLSearchParams$1;
  hasRequiredURLSearchParams = 1;
  (function(exports) {
    const conversions = requireLib$1();
    const utils2 = requireUtils$5();
    const Function2 = require_Function();
    const newObjectInRealm = utils2.newObjectInRealm;
    const implSymbol = utils2.implSymbol;
    const ctorRegistrySymbol = utils2.ctorRegistrySymbol;
    const interfaceName = "URLSearchParams";
    exports.is = (value) => {
      return utils2.isObject(value) && utils2.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
    };
    exports.isImpl = (value) => {
      return utils2.isObject(value) && value instanceof Impl.implementation;
    };
    exports.convert = (globalObject, value, { context = "The provided value" } = {}) => {
      if (exports.is(value)) {
        return utils2.implForWrapper(value);
      }
      throw new globalObject.TypeError(`${context} is not of type 'URLSearchParams'.`);
    };
    exports.createDefaultIterator = (globalObject, target, kind) => {
      const ctorRegistry = globalObject[ctorRegistrySymbol];
      const iteratorPrototype = ctorRegistry["URLSearchParams Iterator"];
      const iterator = Object.create(iteratorPrototype);
      Object.defineProperty(iterator, utils2.iterInternalSymbol, {
        value: { target, kind, index: 0 },
        configurable: true
      });
      return iterator;
    };
    function makeWrapper(globalObject, newTarget) {
      let proto;
      if (newTarget !== void 0) {
        proto = newTarget.prototype;
      }
      if (!utils2.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["URLSearchParams"].prototype;
      }
      return Object.create(proto);
    }
    exports.create = (globalObject, constructorArgs, privateData) => {
      const wrapper = makeWrapper(globalObject);
      return exports.setup(wrapper, globalObject, constructorArgs, privateData);
    };
    exports.createImpl = (globalObject, constructorArgs, privateData) => {
      const wrapper = exports.create(globalObject, constructorArgs, privateData);
      return utils2.implForWrapper(wrapper);
    };
    exports._internalSetup = (wrapper, globalObject) => {
    };
    exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
      privateData.wrapper = wrapper;
      exports._internalSetup(wrapper, globalObject);
      Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
      });
      wrapper[implSymbol][utils2.wrapperSymbol] = wrapper;
      if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
      }
      return wrapper;
    };
    exports.new = (globalObject, newTarget) => {
      const wrapper = makeWrapper(globalObject, newTarget);
      exports._internalSetup(wrapper, globalObject);
      Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
      });
      wrapper[implSymbol][utils2.wrapperSymbol] = wrapper;
      if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
      }
      return wrapper[implSymbol];
    };
    const exposed = /* @__PURE__ */ new Set(["Window", "Worker"]);
    exports.install = (globalObject, globalNames) => {
      if (!globalNames.some((globalName) => exposed.has(globalName))) {
        return;
      }
      const ctorRegistry = utils2.initCtorRegistry(globalObject);
      class URLSearchParams2 {
        constructor() {
          const args = [];
          {
            let curArg = arguments[0];
            if (curArg !== void 0) {
              if (utils2.isObject(curArg)) {
                if (curArg[Symbol.iterator] !== void 0) {
                  if (!utils2.isObject(curArg)) {
                    throw new globalObject.TypeError(
                      "Failed to construct 'URLSearchParams': parameter 1 sequence is not an iterable object."
                    );
                  } else {
                    const V2 = [];
                    const tmp = curArg;
                    for (let nextItem of tmp) {
                      if (!utils2.isObject(nextItem)) {
                        throw new globalObject.TypeError(
                          "Failed to construct 'URLSearchParams': parameter 1 sequence's element is not an iterable object."
                        );
                      } else {
                        const V3 = [];
                        const tmp2 = nextItem;
                        for (let nextItem2 of tmp2) {
                          nextItem2 = conversions["USVString"](nextItem2, {
                            context: "Failed to construct 'URLSearchParams': parameter 1 sequence's element's element",
                            globals: globalObject
                          });
                          V3.push(nextItem2);
                        }
                        nextItem = V3;
                      }
                      V2.push(nextItem);
                    }
                    curArg = V2;
                  }
                } else {
                  if (!utils2.isObject(curArg)) {
                    throw new globalObject.TypeError(
                      "Failed to construct 'URLSearchParams': parameter 1 record is not an object."
                    );
                  } else {
                    const result = /* @__PURE__ */ Object.create(null);
                    for (const key2 of Reflect.ownKeys(curArg)) {
                      const desc = Object.getOwnPropertyDescriptor(curArg, key2);
                      if (desc && desc.enumerable) {
                        let typedKey = key2;
                        typedKey = conversions["USVString"](typedKey, {
                          context: "Failed to construct 'URLSearchParams': parameter 1 record's key",
                          globals: globalObject
                        });
                        let typedValue = curArg[key2];
                        typedValue = conversions["USVString"](typedValue, {
                          context: "Failed to construct 'URLSearchParams': parameter 1 record's value",
                          globals: globalObject
                        });
                        result[typedKey] = typedValue;
                      }
                    }
                    curArg = result;
                  }
                }
              } else {
                curArg = conversions["USVString"](curArg, {
                  context: "Failed to construct 'URLSearchParams': parameter 1",
                  globals: globalObject
                });
              }
            } else {
              curArg = "";
            }
            args.push(curArg);
          }
          return exports.setup(Object.create(new.target.prototype), globalObject, args);
        }
        append(name, value) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError(
              "'append' called on an object that is not a valid instance of URLSearchParams."
            );
          }
          if (arguments.length < 2) {
            throw new globalObject.TypeError(
              `Failed to execute 'append' on 'URLSearchParams': 2 arguments required, but only ${arguments.length} present.`
            );
          }
          const args = [];
          {
            let curArg = arguments[0];
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'append' on 'URLSearchParams': parameter 1",
              globals: globalObject
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[1];
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'append' on 'URLSearchParams': parameter 2",
              globals: globalObject
            });
            args.push(curArg);
          }
          return utils2.tryWrapperForImpl(esValue[implSymbol].append(...args));
        }
        delete(name) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError(
              "'delete' called on an object that is not a valid instance of URLSearchParams."
            );
          }
          if (arguments.length < 1) {
            throw new globalObject.TypeError(
              `Failed to execute 'delete' on 'URLSearchParams': 1 argument required, but only ${arguments.length} present.`
            );
          }
          const args = [];
          {
            let curArg = arguments[0];
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'delete' on 'URLSearchParams': parameter 1",
              globals: globalObject
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[1];
            if (curArg !== void 0) {
              curArg = conversions["USVString"](curArg, {
                context: "Failed to execute 'delete' on 'URLSearchParams': parameter 2",
                globals: globalObject
              });
            }
            args.push(curArg);
          }
          return utils2.tryWrapperForImpl(esValue[implSymbol].delete(...args));
        }
        get(name) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'get' called on an object that is not a valid instance of URLSearchParams.");
          }
          if (arguments.length < 1) {
            throw new globalObject.TypeError(
              `Failed to execute 'get' on 'URLSearchParams': 1 argument required, but only ${arguments.length} present.`
            );
          }
          const args = [];
          {
            let curArg = arguments[0];
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'get' on 'URLSearchParams': parameter 1",
              globals: globalObject
            });
            args.push(curArg);
          }
          return esValue[implSymbol].get(...args);
        }
        getAll(name) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError(
              "'getAll' called on an object that is not a valid instance of URLSearchParams."
            );
          }
          if (arguments.length < 1) {
            throw new globalObject.TypeError(
              `Failed to execute 'getAll' on 'URLSearchParams': 1 argument required, but only ${arguments.length} present.`
            );
          }
          const args = [];
          {
            let curArg = arguments[0];
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'getAll' on 'URLSearchParams': parameter 1",
              globals: globalObject
            });
            args.push(curArg);
          }
          return utils2.tryWrapperForImpl(esValue[implSymbol].getAll(...args));
        }
        has(name) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'has' called on an object that is not a valid instance of URLSearchParams.");
          }
          if (arguments.length < 1) {
            throw new globalObject.TypeError(
              `Failed to execute 'has' on 'URLSearchParams': 1 argument required, but only ${arguments.length} present.`
            );
          }
          const args = [];
          {
            let curArg = arguments[0];
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'has' on 'URLSearchParams': parameter 1",
              globals: globalObject
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[1];
            if (curArg !== void 0) {
              curArg = conversions["USVString"](curArg, {
                context: "Failed to execute 'has' on 'URLSearchParams': parameter 2",
                globals: globalObject
              });
            }
            args.push(curArg);
          }
          return esValue[implSymbol].has(...args);
        }
        set(name, value) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'set' called on an object that is not a valid instance of URLSearchParams.");
          }
          if (arguments.length < 2) {
            throw new globalObject.TypeError(
              `Failed to execute 'set' on 'URLSearchParams': 2 arguments required, but only ${arguments.length} present.`
            );
          }
          const args = [];
          {
            let curArg = arguments[0];
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'set' on 'URLSearchParams': parameter 1",
              globals: globalObject
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[1];
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'set' on 'URLSearchParams': parameter 2",
              globals: globalObject
            });
            args.push(curArg);
          }
          return utils2.tryWrapperForImpl(esValue[implSymbol].set(...args));
        }
        sort() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'sort' called on an object that is not a valid instance of URLSearchParams.");
          }
          return utils2.tryWrapperForImpl(esValue[implSymbol].sort());
        }
        toString() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError(
              "'toString' called on an object that is not a valid instance of URLSearchParams."
            );
          }
          return esValue[implSymbol].toString();
        }
        keys() {
          if (!exports.is(this)) {
            throw new globalObject.TypeError("'keys' called on an object that is not a valid instance of URLSearchParams.");
          }
          return exports.createDefaultIterator(globalObject, this, "key");
        }
        values() {
          if (!exports.is(this)) {
            throw new globalObject.TypeError(
              "'values' called on an object that is not a valid instance of URLSearchParams."
            );
          }
          return exports.createDefaultIterator(globalObject, this, "value");
        }
        entries() {
          if (!exports.is(this)) {
            throw new globalObject.TypeError(
              "'entries' called on an object that is not a valid instance of URLSearchParams."
            );
          }
          return exports.createDefaultIterator(globalObject, this, "key+value");
        }
        forEach(callback) {
          if (!exports.is(this)) {
            throw new globalObject.TypeError(
              "'forEach' called on an object that is not a valid instance of URLSearchParams."
            );
          }
          if (arguments.length < 1) {
            throw new globalObject.TypeError(
              "Failed to execute 'forEach' on 'iterable': 1 argument required, but only 0 present."
            );
          }
          callback = Function2.convert(globalObject, callback, {
            context: "Failed to execute 'forEach' on 'iterable': The callback provided as parameter 1"
          });
          const thisArg = arguments[1];
          let pairs = Array.from(this[implSymbol]);
          let i = 0;
          while (i < pairs.length) {
            const [key2, value] = pairs[i].map(utils2.tryWrapperForImpl);
            callback.call(thisArg, value, key2, this);
            pairs = Array.from(this[implSymbol]);
            i++;
          }
        }
        get size() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError(
              "'get size' called on an object that is not a valid instance of URLSearchParams."
            );
          }
          return esValue[implSymbol]["size"];
        }
      }
      Object.defineProperties(URLSearchParams2.prototype, {
        append: { enumerable: true },
        delete: { enumerable: true },
        get: { enumerable: true },
        getAll: { enumerable: true },
        has: { enumerable: true },
        set: { enumerable: true },
        sort: { enumerable: true },
        toString: { enumerable: true },
        keys: { enumerable: true },
        values: { enumerable: true },
        entries: { enumerable: true },
        forEach: { enumerable: true },
        size: { enumerable: true },
        [Symbol.toStringTag]: { value: "URLSearchParams", configurable: true },
        [Symbol.iterator]: { value: URLSearchParams2.prototype.entries, configurable: true, writable: true }
      });
      ctorRegistry[interfaceName] = URLSearchParams2;
      ctorRegistry["URLSearchParams Iterator"] = Object.create(ctorRegistry["%IteratorPrototype%"], {
        [Symbol.toStringTag]: {
          configurable: true,
          value: "URLSearchParams Iterator"
        }
      });
      utils2.define(ctorRegistry["URLSearchParams Iterator"], {
        next() {
          const internal = this && this[utils2.iterInternalSymbol];
          if (!internal) {
            throw new globalObject.TypeError("next() called on a value that is not a URLSearchParams iterator object");
          }
          const { target, kind, index } = internal;
          const values = Array.from(target[implSymbol]);
          const len = values.length;
          if (index >= len) {
            return newObjectInRealm(globalObject, { value: void 0, done: true });
          }
          const pair = values[index];
          internal.index = index + 1;
          return newObjectInRealm(globalObject, utils2.iteratorResult(pair.map(utils2.tryWrapperForImpl), kind));
        }
      });
      Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: URLSearchParams2
      });
    };
    const Impl = requireURLSearchParamsImpl();
  })(URLSearchParams$1);
  return URLSearchParams$1;
}
var hasRequiredURLImpl;
function requireURLImpl() {
  if (hasRequiredURLImpl) return URLImpl;
  hasRequiredURLImpl = 1;
  const usm = requireUrlStateMachine();
  const urlencoded2 = requireUrlencoded();
  const URLSearchParams2 = requireURLSearchParams();
  URLImpl.implementation = class URLImpl2 {
    // Unlike the spec, we duplicate some code between the constructor and canParse, because we want to give useful error
    // messages in the constructor that distinguish between the different causes of failure.
    constructor(globalObject, [url, base2]) {
      let parsedBase = null;
      if (base2 !== void 0) {
        parsedBase = usm.basicURLParse(base2);
        if (parsedBase === null) {
          throw new TypeError(`Invalid base URL: ${base2}`);
        }
      }
      const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
      if (parsedURL === null) {
        throw new TypeError(`Invalid URL: ${url}`);
      }
      const query = parsedURL.query !== null ? parsedURL.query : "";
      this._url = parsedURL;
      this._query = URLSearchParams2.createImpl(globalObject, [query], { doNotStripQMark: true });
      this._query._url = this;
    }
    static parse(globalObject, input, base2) {
      try {
        return new URLImpl2(globalObject, [input, base2]);
      } catch {
        return null;
      }
    }
    static canParse(url, base2) {
      let parsedBase = null;
      if (base2 !== void 0) {
        parsedBase = usm.basicURLParse(base2);
        if (parsedBase === null) {
          return false;
        }
      }
      const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
      if (parsedURL === null) {
        return false;
      }
      return true;
    }
    get href() {
      return usm.serializeURL(this._url);
    }
    set href(v2) {
      const parsedURL = usm.basicURLParse(v2);
      if (parsedURL === null) {
        throw new TypeError(`Invalid URL: ${v2}`);
      }
      this._url = parsedURL;
      this._query._list.splice(0);
      const { query } = parsedURL;
      if (query !== null) {
        this._query._list = urlencoded2.parseUrlencodedString(query);
      }
    }
    get origin() {
      return usm.serializeURLOrigin(this._url);
    }
    get protocol() {
      return `${this._url.scheme}:`;
    }
    set protocol(v2) {
      usm.basicURLParse(`${v2}:`, { url: this._url, stateOverride: "scheme start" });
    }
    get username() {
      return this._url.username;
    }
    set username(v2) {
      if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
        return;
      }
      usm.setTheUsername(this._url, v2);
    }
    get password() {
      return this._url.password;
    }
    set password(v2) {
      if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
        return;
      }
      usm.setThePassword(this._url, v2);
    }
    get host() {
      const url = this._url;
      if (url.host === null) {
        return "";
      }
      if (url.port === null) {
        return usm.serializeHost(url.host);
      }
      return `${usm.serializeHost(url.host)}:${usm.serializeInteger(url.port)}`;
    }
    set host(v2) {
      if (usm.hasAnOpaquePath(this._url)) {
        return;
      }
      usm.basicURLParse(v2, { url: this._url, stateOverride: "host" });
    }
    get hostname() {
      if (this._url.host === null) {
        return "";
      }
      return usm.serializeHost(this._url.host);
    }
    set hostname(v2) {
      if (usm.hasAnOpaquePath(this._url)) {
        return;
      }
      usm.basicURLParse(v2, { url: this._url, stateOverride: "hostname" });
    }
    get port() {
      if (this._url.port === null) {
        return "";
      }
      return usm.serializeInteger(this._url.port);
    }
    set port(v2) {
      if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
        return;
      }
      if (v2 === "") {
        this._url.port = null;
      } else {
        usm.basicURLParse(v2, { url: this._url, stateOverride: "port" });
      }
    }
    get pathname() {
      return usm.serializePath(this._url);
    }
    set pathname(v2) {
      if (usm.hasAnOpaquePath(this._url)) {
        return;
      }
      this._url.path = [];
      usm.basicURLParse(v2, { url: this._url, stateOverride: "path start" });
    }
    get search() {
      if (this._url.query === null || this._url.query === "") {
        return "";
      }
      return `?${this._url.query}`;
    }
    set search(v2) {
      const url = this._url;
      if (v2 === "") {
        url.query = null;
        this._query._list = [];
        return;
      }
      const input = v2[0] === "?" ? v2.substring(1) : v2;
      url.query = "";
      usm.basicURLParse(input, { url, stateOverride: "query" });
      this._query._list = urlencoded2.parseUrlencodedString(input);
    }
    get searchParams() {
      return this._query;
    }
    get hash() {
      if (this._url.fragment === null || this._url.fragment === "") {
        return "";
      }
      return `#${this._url.fragment}`;
    }
    set hash(v2) {
      if (v2 === "") {
        this._url.fragment = null;
        return;
      }
      const input = v2[0] === "#" ? v2.substring(1) : v2;
      this._url.fragment = "";
      usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
    }
    toJSON() {
      return this.href;
    }
  };
  return URLImpl;
}
var hasRequiredURL;
function requireURL() {
  if (hasRequiredURL) return URL$1;
  hasRequiredURL = 1;
  (function(exports) {
    const conversions = requireLib$1();
    const utils2 = requireUtils$5();
    const implSymbol = utils2.implSymbol;
    const ctorRegistrySymbol = utils2.ctorRegistrySymbol;
    const interfaceName = "URL";
    exports.is = (value) => {
      return utils2.isObject(value) && utils2.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
    };
    exports.isImpl = (value) => {
      return utils2.isObject(value) && value instanceof Impl.implementation;
    };
    exports.convert = (globalObject, value, { context = "The provided value" } = {}) => {
      if (exports.is(value)) {
        return utils2.implForWrapper(value);
      }
      throw new globalObject.TypeError(`${context} is not of type 'URL'.`);
    };
    function makeWrapper(globalObject, newTarget) {
      let proto;
      if (newTarget !== void 0) {
        proto = newTarget.prototype;
      }
      if (!utils2.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["URL"].prototype;
      }
      return Object.create(proto);
    }
    exports.create = (globalObject, constructorArgs, privateData) => {
      const wrapper = makeWrapper(globalObject);
      return exports.setup(wrapper, globalObject, constructorArgs, privateData);
    };
    exports.createImpl = (globalObject, constructorArgs, privateData) => {
      const wrapper = exports.create(globalObject, constructorArgs, privateData);
      return utils2.implForWrapper(wrapper);
    };
    exports._internalSetup = (wrapper, globalObject) => {
    };
    exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
      privateData.wrapper = wrapper;
      exports._internalSetup(wrapper, globalObject);
      Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
      });
      wrapper[implSymbol][utils2.wrapperSymbol] = wrapper;
      if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
      }
      return wrapper;
    };
    exports.new = (globalObject, newTarget) => {
      const wrapper = makeWrapper(globalObject, newTarget);
      exports._internalSetup(wrapper, globalObject);
      Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
      });
      wrapper[implSymbol][utils2.wrapperSymbol] = wrapper;
      if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
      }
      return wrapper[implSymbol];
    };
    const exposed = /* @__PURE__ */ new Set(["Window", "Worker"]);
    exports.install = (globalObject, globalNames) => {
      if (!globalNames.some((globalName) => exposed.has(globalName))) {
        return;
      }
      const ctorRegistry = utils2.initCtorRegistry(globalObject);
      class URL2 {
        constructor(url) {
          if (arguments.length < 1) {
            throw new globalObject.TypeError(
              `Failed to construct 'URL': 1 argument required, but only ${arguments.length} present.`
            );
          }
          const args = [];
          {
            let curArg = arguments[0];
            curArg = conversions["USVString"](curArg, {
              context: "Failed to construct 'URL': parameter 1",
              globals: globalObject
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[1];
            if (curArg !== void 0) {
              curArg = conversions["USVString"](curArg, {
                context: "Failed to construct 'URL': parameter 2",
                globals: globalObject
              });
            }
            args.push(curArg);
          }
          return exports.setup(Object.create(new.target.prototype), globalObject, args);
        }
        toJSON() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'toJSON' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol].toJSON();
        }
        get href() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'get href' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["href"];
        }
        set href(V2) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'set href' called on an object that is not a valid instance of URL.");
          }
          V2 = conversions["USVString"](V2, {
            context: "Failed to set the 'href' property on 'URL': The provided value",
            globals: globalObject
          });
          esValue[implSymbol]["href"] = V2;
        }
        toString() {
          const esValue = this;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'toString' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["href"];
        }
        get origin() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'get origin' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["origin"];
        }
        get protocol() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'get protocol' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["protocol"];
        }
        set protocol(V2) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'set protocol' called on an object that is not a valid instance of URL.");
          }
          V2 = conversions["USVString"](V2, {
            context: "Failed to set the 'protocol' property on 'URL': The provided value",
            globals: globalObject
          });
          esValue[implSymbol]["protocol"] = V2;
        }
        get username() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'get username' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["username"];
        }
        set username(V2) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'set username' called on an object that is not a valid instance of URL.");
          }
          V2 = conversions["USVString"](V2, {
            context: "Failed to set the 'username' property on 'URL': The provided value",
            globals: globalObject
          });
          esValue[implSymbol]["username"] = V2;
        }
        get password() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'get password' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["password"];
        }
        set password(V2) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'set password' called on an object that is not a valid instance of URL.");
          }
          V2 = conversions["USVString"](V2, {
            context: "Failed to set the 'password' property on 'URL': The provided value",
            globals: globalObject
          });
          esValue[implSymbol]["password"] = V2;
        }
        get host() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'get host' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["host"];
        }
        set host(V2) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'set host' called on an object that is not a valid instance of URL.");
          }
          V2 = conversions["USVString"](V2, {
            context: "Failed to set the 'host' property on 'URL': The provided value",
            globals: globalObject
          });
          esValue[implSymbol]["host"] = V2;
        }
        get hostname() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'get hostname' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["hostname"];
        }
        set hostname(V2) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'set hostname' called on an object that is not a valid instance of URL.");
          }
          V2 = conversions["USVString"](V2, {
            context: "Failed to set the 'hostname' property on 'URL': The provided value",
            globals: globalObject
          });
          esValue[implSymbol]["hostname"] = V2;
        }
        get port() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'get port' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["port"];
        }
        set port(V2) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'set port' called on an object that is not a valid instance of URL.");
          }
          V2 = conversions["USVString"](V2, {
            context: "Failed to set the 'port' property on 'URL': The provided value",
            globals: globalObject
          });
          esValue[implSymbol]["port"] = V2;
        }
        get pathname() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'get pathname' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["pathname"];
        }
        set pathname(V2) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'set pathname' called on an object that is not a valid instance of URL.");
          }
          V2 = conversions["USVString"](V2, {
            context: "Failed to set the 'pathname' property on 'URL': The provided value",
            globals: globalObject
          });
          esValue[implSymbol]["pathname"] = V2;
        }
        get search() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'get search' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["search"];
        }
        set search(V2) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'set search' called on an object that is not a valid instance of URL.");
          }
          V2 = conversions["USVString"](V2, {
            context: "Failed to set the 'search' property on 'URL': The provided value",
            globals: globalObject
          });
          esValue[implSymbol]["search"] = V2;
        }
        get searchParams() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'get searchParams' called on an object that is not a valid instance of URL.");
          }
          return utils2.getSameObject(this, "searchParams", () => {
            return utils2.tryWrapperForImpl(esValue[implSymbol]["searchParams"]);
          });
        }
        get hash() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'get hash' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["hash"];
        }
        set hash(V2) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'set hash' called on an object that is not a valid instance of URL.");
          }
          V2 = conversions["USVString"](V2, {
            context: "Failed to set the 'hash' property on 'URL': The provided value",
            globals: globalObject
          });
          esValue[implSymbol]["hash"] = V2;
        }
        static parse(url) {
          if (arguments.length < 1) {
            throw new globalObject.TypeError(
              `Failed to execute 'parse' on 'URL': 1 argument required, but only ${arguments.length} present.`
            );
          }
          const args = [];
          {
            let curArg = arguments[0];
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'parse' on 'URL': parameter 1",
              globals: globalObject
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[1];
            if (curArg !== void 0) {
              curArg = conversions["USVString"](curArg, {
                context: "Failed to execute 'parse' on 'URL': parameter 2",
                globals: globalObject
              });
            }
            args.push(curArg);
          }
          return utils2.tryWrapperForImpl(Impl.implementation.parse(globalObject, ...args));
        }
        static canParse(url) {
          if (arguments.length < 1) {
            throw new globalObject.TypeError(
              `Failed to execute 'canParse' on 'URL': 1 argument required, but only ${arguments.length} present.`
            );
          }
          const args = [];
          {
            let curArg = arguments[0];
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'canParse' on 'URL': parameter 1",
              globals: globalObject
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[1];
            if (curArg !== void 0) {
              curArg = conversions["USVString"](curArg, {
                context: "Failed to execute 'canParse' on 'URL': parameter 2",
                globals: globalObject
              });
            }
            args.push(curArg);
          }
          return Impl.implementation.canParse(...args);
        }
      }
      Object.defineProperties(URL2.prototype, {
        toJSON: { enumerable: true },
        href: { enumerable: true },
        toString: { enumerable: true },
        origin: { enumerable: true },
        protocol: { enumerable: true },
        username: { enumerable: true },
        password: { enumerable: true },
        host: { enumerable: true },
        hostname: { enumerable: true },
        port: { enumerable: true },
        pathname: { enumerable: true },
        search: { enumerable: true },
        searchParams: { enumerable: true },
        hash: { enumerable: true },
        [Symbol.toStringTag]: { value: "URL", configurable: true }
      });
      Object.defineProperties(URL2, { parse: { enumerable: true }, canParse: { enumerable: true } });
      ctorRegistry[interfaceName] = URL2;
      Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: URL2
      });
      if (globalNames.includes("Window")) {
        Object.defineProperty(globalObject, "webkitURL", {
          configurable: true,
          writable: true,
          value: URL2
        });
      }
    };
    const Impl = requireURLImpl();
  })(URL$1);
  return URL$1;
}
var hasRequiredWebidl2jsWrapper;
function requireWebidl2jsWrapper() {
  if (hasRequiredWebidl2jsWrapper) return webidl2jsWrapper;
  hasRequiredWebidl2jsWrapper = 1;
  const URL2 = requireURL();
  const URLSearchParams2 = requireURLSearchParams();
  webidl2jsWrapper.URL = URL2;
  webidl2jsWrapper.URLSearchParams = URLSearchParams2;
  return webidl2jsWrapper;
}
var hasRequiredWhatwgUrl;
function requireWhatwgUrl() {
  if (hasRequiredWhatwgUrl) return whatwgUrl;
  hasRequiredWhatwgUrl = 1;
  const { URL: URL2, URLSearchParams: URLSearchParams2 } = requireWebidl2jsWrapper();
  const urlStateMachine2 = requireUrlStateMachine();
  const percentEncoding2 = requirePercentEncoding();
  const sharedGlobalObject = { Array, Object, Promise, String, TypeError };
  URL2.install(sharedGlobalObject, ["Window"]);
  URLSearchParams2.install(sharedGlobalObject, ["Window"]);
  whatwgUrl.URL = sharedGlobalObject.URL;
  whatwgUrl.URLSearchParams = sharedGlobalObject.URLSearchParams;
  whatwgUrl.parseURL = urlStateMachine2.parseURL;
  whatwgUrl.basicURLParse = urlStateMachine2.basicURLParse;
  whatwgUrl.serializeURL = urlStateMachine2.serializeURL;
  whatwgUrl.serializePath = urlStateMachine2.serializePath;
  whatwgUrl.serializeHost = urlStateMachine2.serializeHost;
  whatwgUrl.serializeInteger = urlStateMachine2.serializeInteger;
  whatwgUrl.serializeURLOrigin = urlStateMachine2.serializeURLOrigin;
  whatwgUrl.setTheUsername = urlStateMachine2.setTheUsername;
  whatwgUrl.setThePassword = urlStateMachine2.setThePassword;
  whatwgUrl.cannotHaveAUsernamePasswordPort = urlStateMachine2.cannotHaveAUsernamePasswordPort;
  whatwgUrl.hasAnOpaquePath = urlStateMachine2.hasAnOpaquePath;
  whatwgUrl.percentDecodeString = percentEncoding2.percentDecodeString;
  whatwgUrl.percentDecodeBytes = percentEncoding2.percentDecodeBytes;
  return whatwgUrl;
}
var whatwgUrlExports = requireWhatwgUrl();
var buffer = {};
var base64Js = {};
var hasRequiredBase64Js;
function requireBase64Js() {
  if (hasRequiredBase64Js) return base64Js;
  hasRequiredBase64Js = 1;
  base64Js.byteLength = byteLength;
  base64Js.toByteArray = toByteArray;
  base64Js.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
  function getLens(b64) {
    var len2 = b64.length;
    if (len2 % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1) validLen = len2;
    var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i2;
    for (i2 = 0; i2 < len2; i2 += 4) {
      tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint8, start, end2) {
    var tmp;
    var output = [];
    for (var i2 = start; i2 < end2; i2 += 3) {
      tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  function fromByteArray(uint8) {
    var tmp;
    var len2 = uint8.length;
    var extraBytes = len2 % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
      parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len2 - 1];
      parts.push(
        lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
      );
    } else if (extraBytes === 2) {
      tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
      parts.push(
        lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
      );
    }
    return parts.join("");
  }
  return base64Js;
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
var hasRequiredIeee754;
function requireIeee754() {
  if (hasRequiredIeee754) return ieee754;
  hasRequiredIeee754 = 1;
  ieee754.read = function(buffer2, offset, isLE, mLen, nBytes) {
    var e, m2;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s2 = buffer2[offset + i];
    i += d;
    e = s2 & (1 << -nBits) - 1;
    s2 >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer2[offset + i], i += d, nBits -= 8) {
    }
    m2 = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m2 = m2 * 256 + buffer2[offset + i], i += d, nBits -= 8) {
    }
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
    } else {
      m2 = m2 + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s2 ? -1 : 1) * m2 * Math.pow(2, e - mLen);
  };
  ieee754.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
    var e, m2, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt2 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m2 = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt2 / c;
      } else {
        value += rt2 * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }
      if (e + eBias >= eMax) {
        m2 = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m2 = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (; mLen >= 8; buffer2[offset + i] = m2 & 255, i += d, m2 /= 256, mLen -= 8) {
    }
    e = e << mLen | m2;
    eLen += mLen;
    for (; eLen > 0; buffer2[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
    }
    buffer2[offset + i - d] |= s2 * 128;
  };
  return ieee754;
}
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
var hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer) return buffer;
  hasRequiredBuffer = 1;
  (function(exports) {
    const base64 = requireBase64Js();
    const ieee7542 = requireIeee754();
    const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer2;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    const K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this)) return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this)) return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf2 = new Uint8Array(length);
      Object.setPrototypeOf(buf2, Buffer2.prototype);
      return buf2;
    }
    function Buffer2(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer2.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length);
      }
      const b2 = fromObject(value);
      if (b2) return b2;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding2) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding2 === "string" ? createBuffer(size).fill(fill, encoding2) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding2) {
      return alloc(size, fill, encoding2);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding2) {
      if (typeof encoding2 !== "string" || encoding2 === "") {
        encoding2 = "utf8";
      }
      if (!Buffer2.isEncoding(encoding2)) {
        throw new TypeError("Unknown encoding: " + encoding2);
      }
      const length = byteLength(string, encoding2) | 0;
      let buf2 = createBuffer(length);
      const actual = buf2.write(string, encoding2);
      if (actual !== length) {
        buf2 = buf2.slice(0, actual);
      }
      return buf2;
    }
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf2 = createBuffer(length);
      for (let i = 0; i < length; i += 1) {
        buf2[i] = array[i] & 255;
      }
      return buf2;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf2;
      if (byteOffset === void 0 && length === void 0) {
        buf2 = new Uint8Array(array);
      } else if (length === void 0) {
        buf2 = new Uint8Array(array, byteOffset);
      } else {
        buf2 = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf2, Buffer2.prototype);
      return buf2;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf2 = createBuffer(len);
        if (buf2.length === 0) {
          return buf2;
        }
        obj.copy(buf2, 0, 0, len);
        return buf2;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer2.alloc(+length);
    }
    Buffer2.isBuffer = function isBuffer2(b2) {
      return b2 != null && b2._isBuffer === true && b2 !== Buffer2.prototype;
    };
    Buffer2.compare = function compare(a2, b2) {
      if (isInstance(a2, Uint8Array)) a2 = Buffer2.from(a2, a2.offset, a2.byteLength);
      if (isInstance(b2, Uint8Array)) b2 = Buffer2.from(b2, b2.offset, b2.byteLength);
      if (!Buffer2.isBuffer(a2) || !Buffer2.isBuffer(b2)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a2 === b2) return 0;
      let x2 = a2.length;
      let y2 = b2.length;
      for (let i = 0, len = Math.min(x2, y2); i < len; ++i) {
        if (a2[i] !== b2[i]) {
          x2 = a2[i];
          y2 = b2[i];
          break;
        }
      }
      if (x2 < y2) return -1;
      if (y2 < x2) return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding2) {
      switch (String(encoding2).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      let i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      const buffer2 = Buffer2.allocUnsafe(length);
      let pos = 0;
      for (i = 0; i < list.length; ++i) {
        let buf2 = list[i];
        if (isInstance(buf2, Uint8Array)) {
          if (pos + buf2.length > buffer2.length) {
            if (!Buffer2.isBuffer(buf2)) buf2 = Buffer2.from(buf2);
            buf2.copy(buffer2, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer2,
              buf2,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf2)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf2.copy(buffer2, pos);
        }
        pos += buf2.length;
      }
      return buffer2;
    };
    function byteLength(string, encoding2) {
      if (Buffer2.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding2) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding2 = ("" + encoding2).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength;
    function slowToString(encoding2, start, end2) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end2 === void 0 || end2 > this.length) {
        end2 = this.length;
      }
      if (end2 <= 0) {
        return "";
      }
      end2 >>>= 0;
      start >>>= 0;
      if (end2 <= start) {
        return "";
      }
      if (!encoding2) encoding2 = "utf8";
      while (true) {
        switch (encoding2) {
          case "hex":
            return hexSlice(this, start, end2);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end2);
          case "ascii":
            return asciiSlice(this, start, end2);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end2);
          case "base64":
            return base64Slice(this, start, end2);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end2);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding2);
            encoding2 = (encoding2 + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b2, n, m2) {
      const i = b2[n];
      b2[n] = b2[m2];
      b2[m2] = i;
    }
    Buffer2.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString() {
      const length = this.length;
      if (length === 0) return "";
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals(b2) {
      if (!Buffer2.isBuffer(b2)) throw new TypeError("Argument must be a Buffer");
      if (this === b2) return true;
      return Buffer2.compare(this, b2) === 0;
    };
    Buffer2.prototype.inspect = function inspect() {
      let str = "";
      const max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max) str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare(target, start, end2, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end2 === void 0) {
        end2 = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end2 > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end2) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end2) {
        return 1;
      }
      start >>>= 0;
      end2 >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      let x2 = thisEnd - thisStart;
      let y2 = end2 - start;
      const len = Math.min(x2, y2);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end2);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x2 = thisCopy[i];
          y2 = targetCopy[i];
          break;
        }
      }
      if (x2 < y2) return -1;
      if (y2 < x2) return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer2, val, byteOffset, encoding2, dir) {
      if (buffer2.length === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding2 = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer2.length - 1;
      }
      if (byteOffset < 0) byteOffset = buffer2.length + byteOffset;
      if (byteOffset >= buffer2.length) {
        if (dir) return -1;
        else byteOffset = buffer2.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding2);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer2, val, byteOffset, encoding2, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer2, [val], byteOffset, encoding2, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding2, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding2 !== void 0) {
        encoding2 = String(encoding2).toLowerCase();
        if (encoding2 === "ucs2" || encoding2 === "ucs-2" || encoding2 === "utf16le" || encoding2 === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf2, i2) {
        if (indexSize === 1) {
          return buf2[i2];
        } else {
          return buf2.readUInt16BE(i2 * indexSize);
        }
      }
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j2 = 0; j2 < valLength; j2++) {
            if (read(arr, i + j2) !== read(val, j2)) {
              found = false;
              break;
            }
          }
          if (found) return i;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding2) {
      return this.indexOf(val, byteOffset, encoding2) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding2) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding2, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding2) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding2, false);
    };
    function hexWrite(buf2, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf2.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i;
      for (i = 0; i < length; ++i) {
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf2[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf2, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf2.length - offset), buf2, offset, length);
    }
    function asciiWrite(buf2, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf2, offset, length);
    }
    function base64Write(buf2, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf2, offset, length);
    }
    function ucs2Write(buf2, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf2.length - offset), buf2, offset, length);
    }
    Buffer2.prototype.write = function write(string, offset, length, encoding2) {
      if (offset === void 0) {
        encoding2 = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding2 = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding2 === void 0) encoding2 = "utf8";
        } else {
          encoding2 = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining) length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding2) encoding2 = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding2) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding2);
            encoding2 = ("" + encoding2).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf2, start, end2) {
      if (start === 0 && end2 === buf2.length) {
        return base64.fromByteArray(buf2);
      } else {
        return base64.fromByteArray(buf2.slice(start, end2));
      }
    }
    function utf8Slice(buf2, start, end2) {
      end2 = Math.min(buf2.length, end2);
      const res = [];
      let i = start;
      while (i < end2) {
        const firstByte = buf2[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end2) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf2[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf2[i + 1];
              thirdByte = buf2[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf2[i + 1];
              thirdByte = buf2[i + 2];
              fourthByte = buf2[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    const MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf2, start, end2) {
      let ret = "";
      end2 = Math.min(buf2.length, end2);
      for (let i = start; i < end2; ++i) {
        ret += String.fromCharCode(buf2[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf2, start, end2) {
      let ret = "";
      end2 = Math.min(buf2.length, end2);
      for (let i = start; i < end2; ++i) {
        ret += String.fromCharCode(buf2[i]);
      }
      return ret;
    }
    function hexSlice(buf2, start, end2) {
      const len = buf2.length;
      if (!start || start < 0) start = 0;
      if (!end2 || end2 < 0 || end2 > len) end2 = len;
      let out = "";
      for (let i = start; i < end2; ++i) {
        out += hexSliceLookupTable[buf2[i]];
      }
      return out;
    }
    function utf16leSlice(buf2, start, end2) {
      const bytes = buf2.slice(start, end2);
      let res = "";
      for (let i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice(start, end2) {
      const len = this.length;
      start = ~~start;
      end2 = end2 === void 0 ? len : ~~end2;
      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end2 < 0) {
        end2 += len;
        if (end2 < 0) end2 = 0;
      } else if (end2 > len) {
        end2 = len;
      }
      if (end2 < start) end2 = start;
      const newBuf = this.subarray(start, end2);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
      if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo2 = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo2) + (BigInt(hi) << BigInt(32));
    });
    Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo2 = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo2);
    });
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let i = byteLength2;
      let mul = 1;
      let val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128)) return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee7542.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee7542.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee7542.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee7542.read(this, offset, false, 52, 8);
    };
    function checkInt(buf2, value, offset, ext, max, min) {
      if (!Buffer2.isBuffer(buf2)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf2.length) throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf2, value, offset, min, max) {
      checkIntBI(value, min, max, buf2, offset, 7);
      let lo2 = Number(value & BigInt(4294967295));
      buf2[offset++] = lo2;
      lo2 = lo2 >> 8;
      buf2[offset++] = lo2;
      lo2 = lo2 >> 8;
      buf2[offset++] = lo2;
      lo2 = lo2 >> 8;
      buf2[offset++] = lo2;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf2[offset++] = hi;
      hi = hi >> 8;
      buf2[offset++] = hi;
      hi = hi >> 8;
      buf2[offset++] = hi;
      hi = hi >> 8;
      buf2[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf2, value, offset, min, max) {
      checkIntBI(value, min, max, buf2, offset, 7);
      let lo2 = Number(value & BigInt(4294967295));
      buf2[offset + 7] = lo2;
      lo2 = lo2 >> 8;
      buf2[offset + 6] = lo2;
      lo2 = lo2 >> 8;
      buf2[offset + 5] = lo2;
      lo2 = lo2 >> 8;
      buf2[offset + 4] = lo2;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf2[offset + 3] = hi;
      hi = hi >> 8;
      buf2[offset + 2] = hi;
      hi = hi >> 8;
      buf2[offset + 1] = hi;
      hi = hi >> 8;
      buf2[offset] = hi;
      return offset + 8;
    }
    Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
      if (value < 0) value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0) value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf2, value, offset, ext, max, min) {
      if (offset + ext > buf2.length) throw new RangeError("Index out of range");
      if (offset < 0) throw new RangeError("Index out of range");
    }
    function writeFloat(buf2, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf2, value, offset, 4);
      }
      ieee7542.write(buf2, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf2, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf2, value, offset, 8);
      }
      ieee7542.write(buf2, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end2) {
      if (!Buffer2.isBuffer(target)) throw new TypeError("argument should be a Buffer");
      if (!start) start = 0;
      if (!end2 && end2 !== 0) end2 = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end2 > 0 && end2 < start) end2 = start;
      if (end2 === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
      if (end2 < 0) throw new RangeError("sourceEnd out of bounds");
      if (end2 > this.length) end2 = this.length;
      if (target.length - targetStart < end2 - start) {
        end2 = target.length - targetStart + start;
      }
      const len = end2 - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end2);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end2),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end2, encoding2) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding2 = start;
          start = 0;
          end2 = this.length;
        } else if (typeof end2 === "string") {
          encoding2 = end2;
          end2 = this.length;
        }
        if (encoding2 !== void 0 && typeof encoding2 !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding2 === "string" && !Buffer2.isEncoding(encoding2)) {
          throw new TypeError("Unknown encoding: " + encoding2);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding2 === "utf8" && code < 128 || encoding2 === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end2) {
        throw new RangeError("Out of range index");
      }
      if (end2 <= start) {
        return this;
      }
      start = start >>> 0;
      end2 = end2 === void 0 ? this.length : end2 >>> 0;
      if (!val) val = 0;
      let i;
      if (typeof val === "number") {
        for (i = start; i < end2; ++i) {
          this[i] = val;
        }
      } else {
        const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding2);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end2 - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    const errors2 = {};
    function E2(sym, getMessage, Base) {
      errors2[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E2(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name) {
        if (name) {
          return `${name} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E2(
      "ERR_INVALID_ARG_TYPE",
      function(name, actual) {
        return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E2(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function checkBounds(buf2, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf2[offset] === void 0 || buf2[offset + byteLength2] === void 0) {
        boundsError(offset, buf2.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf2, offset, byteLength2) {
      if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
          }
        }
        throw new errors2.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf2, offset, byteLength2);
    }
    function validateNumber(value, name) {
      if (typeof value !== "number") {
        throw new errors2.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors2.ERR_OUT_OF_RANGE("offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors2.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors2.ERR_OUT_OF_RANGE(
        "offset",
        `>= ${0} and <= ${length}`,
        value
      );
    }
    const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2) return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0) break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0) break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0) break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c, hi, lo2;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo2 = c % 256;
        byteArray.push(lo2);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src2, dst, offset, length) {
      let i;
      for (i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src2.length) break;
        dst[i + offset] = src2[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    const hexSliceLookupTable = (function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j2 = 0; j2 < 16; ++j2) {
          table[i16 + j2] = alphabet[i] + alphabet[j2];
        }
      }
      return table;
    })();
    function defineBigIntMethod(fn2) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn2;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  })(buffer);
  return buffer;
}
var bufferExports = requireBuffer();
var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key2, value) => key2 in obj ? __defProp$1(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __publicField$1 = (obj, key2, value) => __defNormalProp$1(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);
if (typeof window !== "undefined") {
  window.Buffer = bufferExports.Buffer;
  window.URL = whatwgUrlExports.URL;
  window.URLSearchParams = whatwgUrlExports.URLSearchParams;
}
if (typeof globalThis !== "undefined") {
  globalThis.Buffer = bufferExports.Buffer;
  globalThis.URL = whatwgUrlExports.URL;
  globalThis.URLSearchParams = whatwgUrlExports.URLSearchParams;
}
if (typeof global !== "undefined") {
  global.Buffer = bufferExports.Buffer;
  global.URL = whatwgUrlExports.URL;
  global.URLSearchParams = whatwgUrlExports.URLSearchParams;
}
if (typeof window !== "undefined") {
  if (typeof EventTarget === "undefined") {
    const EventTargetPolyfill = class EventTarget {
      constructor() {
        __publicField$1(this, "_listeners", /* @__PURE__ */ new Map());
      }
      addEventListener(type, listener) {
        var _a2;
        if (!this._listeners.has(type)) {
          this._listeners.set(type, []);
        }
        const actualListener = typeof listener === "function" ? listener : (_a2 = listener == null ? void 0 : listener.handleEvent) == null ? void 0 : _a2.bind(listener);
        if (actualListener) {
          this._listeners.get(type).push(actualListener);
        }
      }
      removeEventListener(type, listener) {
        var _a2;
        const typeListeners = this._listeners.get(type);
        if (typeListeners) {
          const actualListener = typeof listener === "function" ? listener : (_a2 = listener == null ? void 0 : listener.handleEvent) == null ? void 0 : _a2.bind(listener);
          if (actualListener) {
            const index = typeListeners.indexOf(actualListener);
            if (index > -1) {
              typeListeners.splice(index, 1);
            }
          }
        }
      }
      dispatchEvent(event) {
        const typeListeners = this._listeners.get(event.type);
        if (typeListeners) {
          typeListeners.forEach((listener) => {
            try {
              listener(event);
            } catch (error2) {
              console.error("Error in event listener:", error2);
            }
          });
        }
        return true;
      }
    };
    window.EventTarget = EventTargetPolyfill;
    globalThis.EventTarget = EventTargetPolyfill;
  }
  if (typeof Event === "undefined") {
    const EventPolyfill = class Event {
      constructor(type, eventInit) {
        __publicField$1(this, "type");
        __publicField$1(this, "bubbles");
        __publicField$1(this, "cancelable");
        this.type = type;
        this.bubbles = (eventInit == null ? void 0 : eventInit.bubbles) || false;
        this.cancelable = (eventInit == null ? void 0 : eventInit.cancelable) || false;
      }
    };
    window.Event = EventPolyfill;
    globalThis.Event = EventPolyfill;
  }
  if (typeof CustomEvent === "undefined") {
    const CustomEventPolyfill = class CustomEvent extends window.Event {
      constructor(type, eventInit) {
        super(type, eventInit);
        __publicField$1(this, "detail");
        this.detail = eventInit == null ? void 0 : eventInit.detail;
      }
    };
    window.CustomEvent = CustomEventPolyfill;
    globalThis.CustomEvent = CustomEventPolyfill;
  }
  if (typeof MessageEvent === "undefined") {
    const MessageEventPolyfill = class MessageEvent extends window.Event {
      constructor(type, eventInit) {
        super(type, eventInit);
        __publicField$1(this, "data");
        __publicField$1(this, "source");
        __publicField$1(this, "origin");
        this.data = eventInit == null ? void 0 : eventInit.data;
        this.source = eventInit == null ? void 0 : eventInit.source;
        this.origin = (eventInit == null ? void 0 : eventInit.origin) || "";
      }
    };
    window.MessageEvent = MessageEventPolyfill;
    globalThis.MessageEvent = MessageEventPolyfill;
  }
  if (typeof MutationObserver === "undefined") {
    const MutationObserverPolyfill = class MutationObserver {
      constructor(callback) {
      }
      observe(target, options) {
      }
      disconnect() {
      }
      takeRecords() {
        return [];
      }
    };
    window.MutationObserver = MutationObserverPolyfill;
    globalThis.MutationObserver = MutationObserverPolyfill;
  }
  if (typeof Node === "undefined") {
    window.Node = {
      ELEMENT_NODE: 1,
      ATTRIBUTE_NODE: 2,
      TEXT_NODE: 3,
      CDATA_SECTION_NODE: 4,
      ENTITY_REFERENCE_NODE: 5,
      ENTITY_NODE: 6,
      PROCESSING_INSTRUCTION_NODE: 7,
      COMMENT_NODE: 8,
      DOCUMENT_NODE: 9,
      DOCUMENT_TYPE_NODE: 10,
      DOCUMENT_FRAGMENT_NODE: 11,
      NOTATION_NODE: 12
    };
  }
  if (!window.addEventListener) {
    const listeners = /* @__PURE__ */ new Map();
    window.addEventListener = function(type, listener) {
      var _a2;
      if (!listeners.has(type)) {
        listeners.set(type, []);
      }
      const actualListener = typeof listener === "function" ? listener : (_a2 = listener == null ? void 0 : listener.handleEvent) == null ? void 0 : _a2.bind(listener);
      if (actualListener) {
        listeners.get(type).push(actualListener);
      }
    };
    window.removeEventListener = function(type, listener) {
      var _a2;
      const typeListeners = listeners.get(type);
      if (typeListeners) {
        const actualListener = typeof listener === "function" ? listener : (_a2 = listener == null ? void 0 : listener.handleEvent) == null ? void 0 : _a2.bind(listener);
        if (actualListener) {
          const index = typeListeners.indexOf(actualListener);
          if (index > -1) {
            typeListeners.splice(index, 1);
          }
        }
      }
    };
    window.dispatchEvent = function(event) {
      const typeListeners = listeners.get(event.type);
      if (typeListeners) {
        typeListeners.forEach((listener) => {
          try {
            listener(event);
          } catch (error2) {
            console.error("Error in event listener:", error2);
          }
        });
      }
      return true;
    };
  }
  if (typeof AbortController === "undefined") {
    window.AbortController = class AbortController {
      constructor() {
        __publicField$1(this, "signal", {
          aborted: false,
          addEventListener: () => {
          },
          removeEventListener: () => {
          }
        });
      }
      abort() {
        this.signal.aborted = true;
      }
    };
  }
  if (typeof crypto === "undefined" || !crypto.randomUUID) {
    if (typeof crypto === "undefined") {
      window.crypto = {};
    }
    if (!crypto.randomUUID) {
      crypto.randomUUID = function() {
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
          const r = Math.random() * 16 | 0;
          const v2 = c === "x" ? r : r & 3 | 8;
          return v2.toString(16);
        });
      };
    }
  }
  if (typeof document === "undefined") {
    window.document = {
      readyState: "complete",
      getElementById: () => null,
      addEventListener: window.addEventListener,
      removeEventListener: window.removeEventListener,
      dispatchEvent: window.dispatchEvent,
      querySelectorAll: () => [],
      body: {
        addEventListener: window.addEventListener,
        removeEventListener: window.removeEventListener
      }
    };
    window.Element = function() {
    };
    window.Element.prototype.querySelectorAll = () => [];
    window.Element.prototype.addEventListener = () => {
    };
    window.Element.prototype.removeEventListener = () => {
    };
  }
  if (!window.location) {
    window.location = {
      href: "about:blank",
      origin: "about:blank",
      protocol: "about:",
      host: "",
      hostname: "",
      port: "",
      pathname: "/blank",
      search: "",
      hash: "",
      assign: function(url) {
        this.href = url;
      },
      replace: function(url) {
        this.href = url;
      },
      reload: function() {
      },
      toString: function() {
        return this.href;
      }
    };
  }
}
Promise.resolve().then(() => main);
const firstPolyfill = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" }));
var naclUtil$1 = { exports: {} };
var naclUtil = naclUtil$1.exports;
var hasRequiredNaclUtil;
function requireNaclUtil() {
  if (hasRequiredNaclUtil) return naclUtil$1.exports;
  hasRequiredNaclUtil = 1;
  (function(module) {
    (function(root, f2) {
      if (module.exports) module.exports = f2();
      else if (root.nacl) root.nacl.util = f2();
      else {
        root.nacl = {};
        root.nacl.util = f2();
      }
    })(naclUtil, function() {
      var util2 = {};
      function validateBase64(s2) {
        if (!/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(s2)) {
          throw new TypeError("invalid encoding");
        }
      }
      util2.decodeUTF8 = function(s2) {
        if (typeof s2 !== "string") throw new TypeError("expected string");
        var i, d = unescape(encodeURIComponent(s2)), b2 = new Uint8Array(d.length);
        for (i = 0; i < d.length; i++) b2[i] = d.charCodeAt(i);
        return b2;
      };
      util2.encodeUTF8 = function(arr) {
        var i, s2 = [];
        for (i = 0; i < arr.length; i++) s2.push(String.fromCharCode(arr[i]));
        return decodeURIComponent(escape(s2.join("")));
      };
      if (typeof atob === "undefined") {
        if (typeof Buffer.from !== "undefined") {
          util2.encodeBase64 = function(arr) {
            return Buffer.from(arr).toString("base64");
          };
          util2.decodeBase64 = function(s2) {
            validateBase64(s2);
            return new Uint8Array(Array.prototype.slice.call(Buffer.from(s2, "base64"), 0));
          };
        } else {
          util2.encodeBase64 = function(arr) {
            return new Buffer(arr).toString("base64");
          };
          util2.decodeBase64 = function(s2) {
            validateBase64(s2);
            return new Uint8Array(Array.prototype.slice.call(new Buffer(s2, "base64"), 0));
          };
        }
      } else {
        util2.encodeBase64 = function(arr) {
          var i, s2 = [], len = arr.length;
          for (i = 0; i < len; i++) s2.push(String.fromCharCode(arr[i]));
          return btoa(s2.join(""));
        };
        util2.decodeBase64 = function(s2) {
          validateBase64(s2);
          var i, d = atob(s2), b2 = new Uint8Array(d.length);
          for (i = 0; i < d.length; i++) b2[i] = d.charCodeAt(i);
          return b2;
        };
      }
      return util2;
    });
  })(naclUtil$1);
  return naclUtil$1.exports;
}
var naclUtilExports = requireNaclUtil();
const nacl$1 = /* @__PURE__ */ getDefaultExportFromCjs(naclUtilExports);
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var naclFast = { exports: {} };
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$4$2 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var hasRequiredNaclFast;
function requireNaclFast() {
  if (hasRequiredNaclFast) return naclFast.exports;
  hasRequiredNaclFast = 1;
  (function(module) {
    (function(nacl2) {
      var gf = function(init) {
        var i, r = new Float64Array(16);
        if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
        return r;
      };
      var randombytes = function() {
        throw new Error("no PRNG");
      };
      var _0 = new Uint8Array(16);
      var _9 = new Uint8Array(32);
      _9[0] = 9;
      var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D2 = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D22 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X2 = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I2 = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function ts64(x2, i, h2, l) {
        x2[i] = h2 >> 24 & 255;
        x2[i + 1] = h2 >> 16 & 255;
        x2[i + 2] = h2 >> 8 & 255;
        x2[i + 3] = h2 & 255;
        x2[i + 4] = l >> 24 & 255;
        x2[i + 5] = l >> 16 & 255;
        x2[i + 6] = l >> 8 & 255;
        x2[i + 7] = l & 255;
      }
      function vn2(x2, xi, y2, yi, n) {
        var i, d = 0;
        for (i = 0; i < n; i++) d |= x2[xi + i] ^ y2[yi + i];
        return (1 & d - 1 >>> 8) - 1;
      }
      function crypto_verify_16(x2, xi, y2, yi) {
        return vn2(x2, xi, y2, yi, 16);
      }
      function crypto_verify_32(x2, xi, y2, yi) {
        return vn2(x2, xi, y2, yi, 32);
      }
      function core_salsa20(o4, p2, k2, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k2[0] & 255 | (k2[1] & 255) << 8 | (k2[2] & 255) << 16 | (k2[3] & 255) << 24, j2 = k2[4] & 255 | (k2[5] & 255) << 8 | (k2[6] & 255) << 16 | (k2[7] & 255) << 24, j3 = k2[8] & 255 | (k2[9] & 255) << 8 | (k2[10] & 255) << 16 | (k2[11] & 255) << 24, j4 = k2[12] & 255 | (k2[13] & 255) << 8 | (k2[14] & 255) << 16 | (k2[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p2[0] & 255 | (p2[1] & 255) << 8 | (p2[2] & 255) << 16 | (p2[3] & 255) << 24, j7 = p2[4] & 255 | (p2[5] & 255) << 8 | (p2[6] & 255) << 16 | (p2[7] & 255) << 24, j8 = p2[8] & 255 | (p2[9] & 255) << 8 | (p2[10] & 255) << 16 | (p2[11] & 255) << 24, j9 = p2[12] & 255 | (p2[13] & 255) << 8 | (p2[14] & 255) << 16 | (p2[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k2[16] & 255 | (k2[17] & 255) << 8 | (k2[18] & 255) << 16 | (k2[19] & 255) << 24, j12 = k2[20] & 255 | (k2[21] & 255) << 8 | (k2[22] & 255) << 16 | (k2[23] & 255) << 24, j13 = k2[24] & 255 | (k2[25] & 255) << 8 | (k2[26] & 255) << 16 | (k2[27] & 255) << 24, j14 = k2[28] & 255 | (k2[29] & 255) << 8 | (k2[30] & 255) << 16 | (k2[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        x0 = x0 + j0 | 0;
        x1 = x1 + j1 | 0;
        x2 = x2 + j2 | 0;
        x3 = x3 + j3 | 0;
        x4 = x4 + j4 | 0;
        x5 = x5 + j5 | 0;
        x6 = x6 + j6 | 0;
        x7 = x7 + j7 | 0;
        x8 = x8 + j8 | 0;
        x9 = x9 + j9 | 0;
        x10 = x10 + j10 | 0;
        x11 = x11 + j11 | 0;
        x12 = x12 + j12 | 0;
        x13 = x13 + j13 | 0;
        x14 = x14 + j14 | 0;
        x15 = x15 + j15 | 0;
        o4[0] = x0 >>> 0 & 255;
        o4[1] = x0 >>> 8 & 255;
        o4[2] = x0 >>> 16 & 255;
        o4[3] = x0 >>> 24 & 255;
        o4[4] = x1 >>> 0 & 255;
        o4[5] = x1 >>> 8 & 255;
        o4[6] = x1 >>> 16 & 255;
        o4[7] = x1 >>> 24 & 255;
        o4[8] = x2 >>> 0 & 255;
        o4[9] = x2 >>> 8 & 255;
        o4[10] = x2 >>> 16 & 255;
        o4[11] = x2 >>> 24 & 255;
        o4[12] = x3 >>> 0 & 255;
        o4[13] = x3 >>> 8 & 255;
        o4[14] = x3 >>> 16 & 255;
        o4[15] = x3 >>> 24 & 255;
        o4[16] = x4 >>> 0 & 255;
        o4[17] = x4 >>> 8 & 255;
        o4[18] = x4 >>> 16 & 255;
        o4[19] = x4 >>> 24 & 255;
        o4[20] = x5 >>> 0 & 255;
        o4[21] = x5 >>> 8 & 255;
        o4[22] = x5 >>> 16 & 255;
        o4[23] = x5 >>> 24 & 255;
        o4[24] = x6 >>> 0 & 255;
        o4[25] = x6 >>> 8 & 255;
        o4[26] = x6 >>> 16 & 255;
        o4[27] = x6 >>> 24 & 255;
        o4[28] = x7 >>> 0 & 255;
        o4[29] = x7 >>> 8 & 255;
        o4[30] = x7 >>> 16 & 255;
        o4[31] = x7 >>> 24 & 255;
        o4[32] = x8 >>> 0 & 255;
        o4[33] = x8 >>> 8 & 255;
        o4[34] = x8 >>> 16 & 255;
        o4[35] = x8 >>> 24 & 255;
        o4[36] = x9 >>> 0 & 255;
        o4[37] = x9 >>> 8 & 255;
        o4[38] = x9 >>> 16 & 255;
        o4[39] = x9 >>> 24 & 255;
        o4[40] = x10 >>> 0 & 255;
        o4[41] = x10 >>> 8 & 255;
        o4[42] = x10 >>> 16 & 255;
        o4[43] = x10 >>> 24 & 255;
        o4[44] = x11 >>> 0 & 255;
        o4[45] = x11 >>> 8 & 255;
        o4[46] = x11 >>> 16 & 255;
        o4[47] = x11 >>> 24 & 255;
        o4[48] = x12 >>> 0 & 255;
        o4[49] = x12 >>> 8 & 255;
        o4[50] = x12 >>> 16 & 255;
        o4[51] = x12 >>> 24 & 255;
        o4[52] = x13 >>> 0 & 255;
        o4[53] = x13 >>> 8 & 255;
        o4[54] = x13 >>> 16 & 255;
        o4[55] = x13 >>> 24 & 255;
        o4[56] = x14 >>> 0 & 255;
        o4[57] = x14 >>> 8 & 255;
        o4[58] = x14 >>> 16 & 255;
        o4[59] = x14 >>> 24 & 255;
        o4[60] = x15 >>> 0 & 255;
        o4[61] = x15 >>> 8 & 255;
        o4[62] = x15 >>> 16 & 255;
        o4[63] = x15 >>> 24 & 255;
      }
      function core_hsalsa20(o4, p2, k2, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k2[0] & 255 | (k2[1] & 255) << 8 | (k2[2] & 255) << 16 | (k2[3] & 255) << 24, j2 = k2[4] & 255 | (k2[5] & 255) << 8 | (k2[6] & 255) << 16 | (k2[7] & 255) << 24, j3 = k2[8] & 255 | (k2[9] & 255) << 8 | (k2[10] & 255) << 16 | (k2[11] & 255) << 24, j4 = k2[12] & 255 | (k2[13] & 255) << 8 | (k2[14] & 255) << 16 | (k2[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p2[0] & 255 | (p2[1] & 255) << 8 | (p2[2] & 255) << 16 | (p2[3] & 255) << 24, j7 = p2[4] & 255 | (p2[5] & 255) << 8 | (p2[6] & 255) << 16 | (p2[7] & 255) << 24, j8 = p2[8] & 255 | (p2[9] & 255) << 8 | (p2[10] & 255) << 16 | (p2[11] & 255) << 24, j9 = p2[12] & 255 | (p2[13] & 255) << 8 | (p2[14] & 255) << 16 | (p2[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k2[16] & 255 | (k2[17] & 255) << 8 | (k2[18] & 255) << 16 | (k2[19] & 255) << 24, j12 = k2[20] & 255 | (k2[21] & 255) << 8 | (k2[22] & 255) << 16 | (k2[23] & 255) << 24, j13 = k2[24] & 255 | (k2[25] & 255) << 8 | (k2[26] & 255) << 16 | (k2[27] & 255) << 24, j14 = k2[28] & 255 | (k2[29] & 255) << 8 | (k2[30] & 255) << 16 | (k2[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        o4[0] = x0 >>> 0 & 255;
        o4[1] = x0 >>> 8 & 255;
        o4[2] = x0 >>> 16 & 255;
        o4[3] = x0 >>> 24 & 255;
        o4[4] = x5 >>> 0 & 255;
        o4[5] = x5 >>> 8 & 255;
        o4[6] = x5 >>> 16 & 255;
        o4[7] = x5 >>> 24 & 255;
        o4[8] = x10 >>> 0 & 255;
        o4[9] = x10 >>> 8 & 255;
        o4[10] = x10 >>> 16 & 255;
        o4[11] = x10 >>> 24 & 255;
        o4[12] = x15 >>> 0 & 255;
        o4[13] = x15 >>> 8 & 255;
        o4[14] = x15 >>> 16 & 255;
        o4[15] = x15 >>> 24 & 255;
        o4[16] = x6 >>> 0 & 255;
        o4[17] = x6 >>> 8 & 255;
        o4[18] = x6 >>> 16 & 255;
        o4[19] = x6 >>> 24 & 255;
        o4[20] = x7 >>> 0 & 255;
        o4[21] = x7 >>> 8 & 255;
        o4[22] = x7 >>> 16 & 255;
        o4[23] = x7 >>> 24 & 255;
        o4[24] = x8 >>> 0 & 255;
        o4[25] = x8 >>> 8 & 255;
        o4[26] = x8 >>> 16 & 255;
        o4[27] = x8 >>> 24 & 255;
        o4[28] = x9 >>> 0 & 255;
        o4[29] = x9 >>> 8 & 255;
        o4[30] = x9 >>> 16 & 255;
        o4[31] = x9 >>> 24 & 255;
      }
      function crypto_core_salsa20(out, inp, k2, c) {
        core_salsa20(out, inp, k2, c);
      }
      function crypto_core_hsalsa20(out, inp, k2, c) {
        core_hsalsa20(out, inp, k2, c);
      }
      var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
      function crypto_stream_salsa20_xor(c, cpos, m2, mpos, b2, n, k2) {
        var z2 = new Uint8Array(16), x2 = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++) z2[i] = 0;
        for (i = 0; i < 8; i++) z2[i] = n[i];
        while (b2 >= 64) {
          crypto_core_salsa20(x2, z2, k2, sigma);
          for (i = 0; i < 64; i++) c[cpos + i] = m2[mpos + i] ^ x2[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = u + (z2[i] & 255) | 0;
            z2[i] = u & 255;
            u >>>= 8;
          }
          b2 -= 64;
          cpos += 64;
          mpos += 64;
        }
        if (b2 > 0) {
          crypto_core_salsa20(x2, z2, k2, sigma);
          for (i = 0; i < b2; i++) c[cpos + i] = m2[mpos + i] ^ x2[i];
        }
        return 0;
      }
      function crypto_stream_salsa20(c, cpos, b2, n, k2) {
        var z2 = new Uint8Array(16), x2 = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++) z2[i] = 0;
        for (i = 0; i < 8; i++) z2[i] = n[i];
        while (b2 >= 64) {
          crypto_core_salsa20(x2, z2, k2, sigma);
          for (i = 0; i < 64; i++) c[cpos + i] = x2[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = u + (z2[i] & 255) | 0;
            z2[i] = u & 255;
            u >>>= 8;
          }
          b2 -= 64;
          cpos += 64;
        }
        if (b2 > 0) {
          crypto_core_salsa20(x2, z2, k2, sigma);
          for (i = 0; i < b2; i++) c[cpos + i] = x2[i];
        }
        return 0;
      }
      function crypto_stream(c, cpos, d, n, k2) {
        var s2 = new Uint8Array(32);
        crypto_core_hsalsa20(s2, n, k2, sigma);
        var sn2 = new Uint8Array(8);
        for (var i = 0; i < 8; i++) sn2[i] = n[i + 16];
        return crypto_stream_salsa20(c, cpos, d, sn2, s2);
      }
      function crypto_stream_xor(c, cpos, m2, mpos, d, n, k2) {
        var s2 = new Uint8Array(32);
        crypto_core_hsalsa20(s2, n, k2, sigma);
        var sn2 = new Uint8Array(8);
        for (var i = 0; i < 8; i++) sn2[i] = n[i + 16];
        return crypto_stream_salsa20_xor(c, cpos, m2, mpos, d, sn2, s2);
      }
      var poly1305 = function(key2) {
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.leftover = 0;
        this.fin = 0;
        var t0, t1, t2, t3, t4, t5, t6, t7;
        t0 = key2[0] & 255 | (key2[1] & 255) << 8;
        this.r[0] = t0 & 8191;
        t1 = key2[2] & 255 | (key2[3] & 255) << 8;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        t2 = key2[4] & 255 | (key2[5] & 255) << 8;
        this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        t3 = key2[6] & 255 | (key2[7] & 255) << 8;
        this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        t4 = key2[8] & 255 | (key2[9] & 255) << 8;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this.r[5] = t4 >>> 1 & 8190;
        t5 = key2[10] & 255 | (key2[11] & 255) << 8;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        t6 = key2[12] & 255 | (key2[13] & 255) << 8;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        t7 = key2[14] & 255 | (key2[15] & 255) << 8;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this.r[9] = t7 >>> 5 & 127;
        this.pad[0] = key2[16] & 255 | (key2[17] & 255) << 8;
        this.pad[1] = key2[18] & 255 | (key2[19] & 255) << 8;
        this.pad[2] = key2[20] & 255 | (key2[21] & 255) << 8;
        this.pad[3] = key2[22] & 255 | (key2[23] & 255) << 8;
        this.pad[4] = key2[24] & 255 | (key2[25] & 255) << 8;
        this.pad[5] = key2[26] & 255 | (key2[27] & 255) << 8;
        this.pad[6] = key2[28] & 255 | (key2[29] & 255) << 8;
        this.pad[7] = key2[30] & 255 | (key2[31] & 255) << 8;
      };
      poly1305.prototype.blocks = function(m2, mpos, bytes) {
        var hibit = this.fin ? 0 : 1 << 11;
        var t0, t1, t2, t3, t4, t5, t6, t7, c;
        var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
        var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
        var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
        while (bytes >= 16) {
          t0 = m2[mpos + 0] & 255 | (m2[mpos + 1] & 255) << 8;
          h0 += t0 & 8191;
          t1 = m2[mpos + 2] & 255 | (m2[mpos + 3] & 255) << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          t2 = m2[mpos + 4] & 255 | (m2[mpos + 5] & 255) << 8;
          h2 += (t1 >>> 10 | t2 << 6) & 8191;
          t3 = m2[mpos + 6] & 255 | (m2[mpos + 7] & 255) << 8;
          h3 += (t2 >>> 7 | t3 << 9) & 8191;
          t4 = m2[mpos + 8] & 255 | (m2[mpos + 9] & 255) << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          t5 = m2[mpos + 10] & 255 | (m2[mpos + 11] & 255) << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          t6 = m2[mpos + 12] & 255 | (m2[mpos + 13] & 255) << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          t7 = m2[mpos + 14] & 255 | (m2[mpos + 15] & 255) << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          c = 0;
          d0 = c;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h2 * (5 * r8);
          d0 += h3 * (5 * r7);
          d0 += h4 * (5 * r6);
          c = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c += d0 >>> 13;
          d0 &= 8191;
          d1 = c;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h2 * (5 * r9);
          d1 += h3 * (5 * r8);
          d1 += h4 * (5 * r7);
          c = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c += d1 >>> 13;
          d1 &= 8191;
          d2 = c;
          d2 += h0 * r2;
          d2 += h1 * r1;
          d2 += h2 * r0;
          d2 += h3 * (5 * r9);
          d2 += h4 * (5 * r8);
          c = d2 >>> 13;
          d2 &= 8191;
          d2 += h5 * (5 * r7);
          d2 += h6 * (5 * r6);
          d2 += h7 * (5 * r5);
          d2 += h8 * (5 * r4);
          d2 += h9 * (5 * r3);
          c += d2 >>> 13;
          d2 &= 8191;
          d3 = c;
          d3 += h0 * r3;
          d3 += h1 * r2;
          d3 += h2 * r1;
          d3 += h3 * r0;
          d3 += h4 * (5 * r9);
          c = d3 >>> 13;
          d3 &= 8191;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c += d3 >>> 13;
          d3 &= 8191;
          d4 = c;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h2 * r2;
          d4 += h3 * r1;
          d4 += h4 * r0;
          c = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c += d4 >>> 13;
          d4 &= 8191;
          d5 = c;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h2 * r3;
          d5 += h3 * r2;
          d5 += h4 * r1;
          c = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c += d5 >>> 13;
          d5 &= 8191;
          d6 = c;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h2 * r4;
          d6 += h3 * r3;
          d6 += h4 * r2;
          c = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c += d6 >>> 13;
          d6 &= 8191;
          d7 = c;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h2 * r5;
          d7 += h3 * r4;
          d7 += h4 * r3;
          c = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c += d7 >>> 13;
          d7 &= 8191;
          d8 = c;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h2 * r6;
          d8 += h3 * r5;
          d8 += h4 * r4;
          c = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c += d8 >>> 13;
          d8 &= 8191;
          d9 = c;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h2 * r7;
          d9 += h3 * r6;
          d9 += h4 * r5;
          c = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c += d9 >>> 13;
          d9 &= 8191;
          c = (c << 2) + c | 0;
          c = c + d0 | 0;
          d0 = c & 8191;
          c = c >>> 13;
          d1 += c;
          h0 = d0;
          h1 = d1;
          h2 = d2;
          h3 = d3;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes -= 16;
        }
        this.h[0] = h0;
        this.h[1] = h1;
        this.h[2] = h2;
        this.h[3] = h3;
        this.h[4] = h4;
        this.h[5] = h5;
        this.h[6] = h6;
        this.h[7] = h7;
        this.h[8] = h8;
        this.h[9] = h9;
      };
      poly1305.prototype.finish = function(mac, macpos) {
        var g2 = new Uint16Array(10);
        var c, mask, f2, i;
        if (this.leftover) {
          i = this.leftover;
          this.buffer[i++] = 1;
          for (; i < 16; i++) this.buffer[i] = 0;
          this.fin = 1;
          this.blocks(this.buffer, 0, 16);
        }
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        for (i = 2; i < 10; i++) {
          this.h[i] += c;
          c = this.h[i] >>> 13;
          this.h[i] &= 8191;
        }
        this.h[0] += c * 5;
        c = this.h[0] >>> 13;
        this.h[0] &= 8191;
        this.h[1] += c;
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        this.h[2] += c;
        g2[0] = this.h[0] + 5;
        c = g2[0] >>> 13;
        g2[0] &= 8191;
        for (i = 1; i < 10; i++) {
          g2[i] = this.h[i] + c;
          c = g2[i] >>> 13;
          g2[i] &= 8191;
        }
        g2[9] -= 1 << 13;
        mask = (c ^ 1) - 1;
        for (i = 0; i < 10; i++) g2[i] &= mask;
        mask = ~mask;
        for (i = 0; i < 10; i++) this.h[i] = this.h[i] & mask | g2[i];
        this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
        this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
        this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
        this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
        this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
        this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
        this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
        this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
        f2 = this.h[0] + this.pad[0];
        this.h[0] = f2 & 65535;
        for (i = 1; i < 8; i++) {
          f2 = (this.h[i] + this.pad[i] | 0) + (f2 >>> 16) | 0;
          this.h[i] = f2 & 65535;
        }
        mac[macpos + 0] = this.h[0] >>> 0 & 255;
        mac[macpos + 1] = this.h[0] >>> 8 & 255;
        mac[macpos + 2] = this.h[1] >>> 0 & 255;
        mac[macpos + 3] = this.h[1] >>> 8 & 255;
        mac[macpos + 4] = this.h[2] >>> 0 & 255;
        mac[macpos + 5] = this.h[2] >>> 8 & 255;
        mac[macpos + 6] = this.h[3] >>> 0 & 255;
        mac[macpos + 7] = this.h[3] >>> 8 & 255;
        mac[macpos + 8] = this.h[4] >>> 0 & 255;
        mac[macpos + 9] = this.h[4] >>> 8 & 255;
        mac[macpos + 10] = this.h[5] >>> 0 & 255;
        mac[macpos + 11] = this.h[5] >>> 8 & 255;
        mac[macpos + 12] = this.h[6] >>> 0 & 255;
        mac[macpos + 13] = this.h[6] >>> 8 & 255;
        mac[macpos + 14] = this.h[7] >>> 0 & 255;
        mac[macpos + 15] = this.h[7] >>> 8 & 255;
      };
      poly1305.prototype.update = function(m2, mpos, bytes) {
        var i, want;
        if (this.leftover) {
          want = 16 - this.leftover;
          if (want > bytes)
            want = bytes;
          for (i = 0; i < want; i++)
            this.buffer[this.leftover + i] = m2[mpos + i];
          bytes -= want;
          mpos += want;
          this.leftover += want;
          if (this.leftover < 16)
            return;
          this.blocks(this.buffer, 0, 16);
          this.leftover = 0;
        }
        if (bytes >= 16) {
          want = bytes - bytes % 16;
          this.blocks(m2, mpos, want);
          mpos += want;
          bytes -= want;
        }
        if (bytes) {
          for (i = 0; i < bytes; i++)
            this.buffer[this.leftover + i] = m2[mpos + i];
          this.leftover += bytes;
        }
      };
      function crypto_onetimeauth(out, outpos, m2, mpos, n, k2) {
        var s2 = new poly1305(k2);
        s2.update(m2, mpos, n);
        s2.finish(out, outpos);
        return 0;
      }
      function crypto_onetimeauth_verify(h2, hpos, m2, mpos, n, k2) {
        var x2 = new Uint8Array(16);
        crypto_onetimeauth(x2, 0, m2, mpos, n, k2);
        return crypto_verify_16(h2, hpos, x2, 0);
      }
      function crypto_secretbox(c, m2, d, n, k2) {
        var i;
        if (d < 32) return -1;
        crypto_stream_xor(c, 0, m2, 0, d, n, k2);
        crypto_onetimeauth(c, 16, c, 32, d - 32, c);
        for (i = 0; i < 16; i++) c[i] = 0;
        return 0;
      }
      function crypto_secretbox_open(m2, c, d, n, k2) {
        var i;
        var x2 = new Uint8Array(32);
        if (d < 32) return -1;
        crypto_stream(x2, 0, 32, n, k2);
        if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x2) !== 0) return -1;
        crypto_stream_xor(m2, 0, c, 0, d, n, k2);
        for (i = 0; i < 32; i++) m2[i] = 0;
        return 0;
      }
      function set25519(r, a2) {
        var i;
        for (i = 0; i < 16; i++) r[i] = a2[i] | 0;
      }
      function car25519(o4) {
        var i, v2, c = 1;
        for (i = 0; i < 16; i++) {
          v2 = o4[i] + c + 65535;
          c = Math.floor(v2 / 65536);
          o4[i] = v2 - c * 65536;
        }
        o4[0] += c - 1 + 37 * (c - 1);
      }
      function sel25519(p2, q, b2) {
        var t, c = ~(b2 - 1);
        for (var i = 0; i < 16; i++) {
          t = c & (p2[i] ^ q[i]);
          p2[i] ^= t;
          q[i] ^= t;
        }
      }
      function pack25519(o4, n) {
        var i, j2, b2;
        var m2 = gf(), t = gf();
        for (i = 0; i < 16; i++) t[i] = n[i];
        car25519(t);
        car25519(t);
        car25519(t);
        for (j2 = 0; j2 < 2; j2++) {
          m2[0] = t[0] - 65517;
          for (i = 1; i < 15; i++) {
            m2[i] = t[i] - 65535 - (m2[i - 1] >> 16 & 1);
            m2[i - 1] &= 65535;
          }
          m2[15] = t[15] - 32767 - (m2[14] >> 16 & 1);
          b2 = m2[15] >> 16 & 1;
          m2[14] &= 65535;
          sel25519(t, m2, 1 - b2);
        }
        for (i = 0; i < 16; i++) {
          o4[2 * i] = t[i] & 255;
          o4[2 * i + 1] = t[i] >> 8;
        }
      }
      function neq25519(a2, b2) {
        var c = new Uint8Array(32), d = new Uint8Array(32);
        pack25519(c, a2);
        pack25519(d, b2);
        return crypto_verify_32(c, 0, d, 0);
      }
      function par25519(a2) {
        var d = new Uint8Array(32);
        pack25519(d, a2);
        return d[0] & 1;
      }
      function unpack25519(o4, n) {
        var i;
        for (i = 0; i < 16; i++) o4[i] = n[2 * i] + (n[2 * i + 1] << 8);
        o4[15] &= 32767;
      }
      function A2(o4, a2, b2) {
        for (var i = 0; i < 16; i++) o4[i] = a2[i] + b2[i];
      }
      function Z2(o4, a2, b2) {
        for (var i = 0; i < 16; i++) o4[i] = a2[i] - b2[i];
      }
      function M2(o4, a2, b2) {
        var v2, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b2[0], b1 = b2[1], b22 = b2[2], b3 = b2[3], b4 = b2[4], b5 = b2[5], b6 = b2[6], b7 = b2[7], b8 = b2[8], b9 = b2[9], b10 = b2[10], b11 = b2[11], b12 = b2[12], b13 = b2[13], b14 = b2[14], b15 = b2[15];
        v2 = a2[0];
        t0 += v2 * b0;
        t1 += v2 * b1;
        t2 += v2 * b22;
        t3 += v2 * b3;
        t4 += v2 * b4;
        t5 += v2 * b5;
        t6 += v2 * b6;
        t7 += v2 * b7;
        t8 += v2 * b8;
        t9 += v2 * b9;
        t10 += v2 * b10;
        t11 += v2 * b11;
        t12 += v2 * b12;
        t13 += v2 * b13;
        t14 += v2 * b14;
        t15 += v2 * b15;
        v2 = a2[1];
        t1 += v2 * b0;
        t2 += v2 * b1;
        t3 += v2 * b22;
        t4 += v2 * b3;
        t5 += v2 * b4;
        t6 += v2 * b5;
        t7 += v2 * b6;
        t8 += v2 * b7;
        t9 += v2 * b8;
        t10 += v2 * b9;
        t11 += v2 * b10;
        t12 += v2 * b11;
        t13 += v2 * b12;
        t14 += v2 * b13;
        t15 += v2 * b14;
        t16 += v2 * b15;
        v2 = a2[2];
        t2 += v2 * b0;
        t3 += v2 * b1;
        t4 += v2 * b22;
        t5 += v2 * b3;
        t6 += v2 * b4;
        t7 += v2 * b5;
        t8 += v2 * b6;
        t9 += v2 * b7;
        t10 += v2 * b8;
        t11 += v2 * b9;
        t12 += v2 * b10;
        t13 += v2 * b11;
        t14 += v2 * b12;
        t15 += v2 * b13;
        t16 += v2 * b14;
        t17 += v2 * b15;
        v2 = a2[3];
        t3 += v2 * b0;
        t4 += v2 * b1;
        t5 += v2 * b22;
        t6 += v2 * b3;
        t7 += v2 * b4;
        t8 += v2 * b5;
        t9 += v2 * b6;
        t10 += v2 * b7;
        t11 += v2 * b8;
        t12 += v2 * b9;
        t13 += v2 * b10;
        t14 += v2 * b11;
        t15 += v2 * b12;
        t16 += v2 * b13;
        t17 += v2 * b14;
        t18 += v2 * b15;
        v2 = a2[4];
        t4 += v2 * b0;
        t5 += v2 * b1;
        t6 += v2 * b22;
        t7 += v2 * b3;
        t8 += v2 * b4;
        t9 += v2 * b5;
        t10 += v2 * b6;
        t11 += v2 * b7;
        t12 += v2 * b8;
        t13 += v2 * b9;
        t14 += v2 * b10;
        t15 += v2 * b11;
        t16 += v2 * b12;
        t17 += v2 * b13;
        t18 += v2 * b14;
        t19 += v2 * b15;
        v2 = a2[5];
        t5 += v2 * b0;
        t6 += v2 * b1;
        t7 += v2 * b22;
        t8 += v2 * b3;
        t9 += v2 * b4;
        t10 += v2 * b5;
        t11 += v2 * b6;
        t12 += v2 * b7;
        t13 += v2 * b8;
        t14 += v2 * b9;
        t15 += v2 * b10;
        t16 += v2 * b11;
        t17 += v2 * b12;
        t18 += v2 * b13;
        t19 += v2 * b14;
        t20 += v2 * b15;
        v2 = a2[6];
        t6 += v2 * b0;
        t7 += v2 * b1;
        t8 += v2 * b22;
        t9 += v2 * b3;
        t10 += v2 * b4;
        t11 += v2 * b5;
        t12 += v2 * b6;
        t13 += v2 * b7;
        t14 += v2 * b8;
        t15 += v2 * b9;
        t16 += v2 * b10;
        t17 += v2 * b11;
        t18 += v2 * b12;
        t19 += v2 * b13;
        t20 += v2 * b14;
        t21 += v2 * b15;
        v2 = a2[7];
        t7 += v2 * b0;
        t8 += v2 * b1;
        t9 += v2 * b22;
        t10 += v2 * b3;
        t11 += v2 * b4;
        t12 += v2 * b5;
        t13 += v2 * b6;
        t14 += v2 * b7;
        t15 += v2 * b8;
        t16 += v2 * b9;
        t17 += v2 * b10;
        t18 += v2 * b11;
        t19 += v2 * b12;
        t20 += v2 * b13;
        t21 += v2 * b14;
        t22 += v2 * b15;
        v2 = a2[8];
        t8 += v2 * b0;
        t9 += v2 * b1;
        t10 += v2 * b22;
        t11 += v2 * b3;
        t12 += v2 * b4;
        t13 += v2 * b5;
        t14 += v2 * b6;
        t15 += v2 * b7;
        t16 += v2 * b8;
        t17 += v2 * b9;
        t18 += v2 * b10;
        t19 += v2 * b11;
        t20 += v2 * b12;
        t21 += v2 * b13;
        t22 += v2 * b14;
        t23 += v2 * b15;
        v2 = a2[9];
        t9 += v2 * b0;
        t10 += v2 * b1;
        t11 += v2 * b22;
        t12 += v2 * b3;
        t13 += v2 * b4;
        t14 += v2 * b5;
        t15 += v2 * b6;
        t16 += v2 * b7;
        t17 += v2 * b8;
        t18 += v2 * b9;
        t19 += v2 * b10;
        t20 += v2 * b11;
        t21 += v2 * b12;
        t22 += v2 * b13;
        t23 += v2 * b14;
        t24 += v2 * b15;
        v2 = a2[10];
        t10 += v2 * b0;
        t11 += v2 * b1;
        t12 += v2 * b22;
        t13 += v2 * b3;
        t14 += v2 * b4;
        t15 += v2 * b5;
        t16 += v2 * b6;
        t17 += v2 * b7;
        t18 += v2 * b8;
        t19 += v2 * b9;
        t20 += v2 * b10;
        t21 += v2 * b11;
        t22 += v2 * b12;
        t23 += v2 * b13;
        t24 += v2 * b14;
        t25 += v2 * b15;
        v2 = a2[11];
        t11 += v2 * b0;
        t12 += v2 * b1;
        t13 += v2 * b22;
        t14 += v2 * b3;
        t15 += v2 * b4;
        t16 += v2 * b5;
        t17 += v2 * b6;
        t18 += v2 * b7;
        t19 += v2 * b8;
        t20 += v2 * b9;
        t21 += v2 * b10;
        t22 += v2 * b11;
        t23 += v2 * b12;
        t24 += v2 * b13;
        t25 += v2 * b14;
        t26 += v2 * b15;
        v2 = a2[12];
        t12 += v2 * b0;
        t13 += v2 * b1;
        t14 += v2 * b22;
        t15 += v2 * b3;
        t16 += v2 * b4;
        t17 += v2 * b5;
        t18 += v2 * b6;
        t19 += v2 * b7;
        t20 += v2 * b8;
        t21 += v2 * b9;
        t22 += v2 * b10;
        t23 += v2 * b11;
        t24 += v2 * b12;
        t25 += v2 * b13;
        t26 += v2 * b14;
        t27 += v2 * b15;
        v2 = a2[13];
        t13 += v2 * b0;
        t14 += v2 * b1;
        t15 += v2 * b22;
        t16 += v2 * b3;
        t17 += v2 * b4;
        t18 += v2 * b5;
        t19 += v2 * b6;
        t20 += v2 * b7;
        t21 += v2 * b8;
        t22 += v2 * b9;
        t23 += v2 * b10;
        t24 += v2 * b11;
        t25 += v2 * b12;
        t26 += v2 * b13;
        t27 += v2 * b14;
        t28 += v2 * b15;
        v2 = a2[14];
        t14 += v2 * b0;
        t15 += v2 * b1;
        t16 += v2 * b22;
        t17 += v2 * b3;
        t18 += v2 * b4;
        t19 += v2 * b5;
        t20 += v2 * b6;
        t21 += v2 * b7;
        t22 += v2 * b8;
        t23 += v2 * b9;
        t24 += v2 * b10;
        t25 += v2 * b11;
        t26 += v2 * b12;
        t27 += v2 * b13;
        t28 += v2 * b14;
        t29 += v2 * b15;
        v2 = a2[15];
        t15 += v2 * b0;
        t16 += v2 * b1;
        t17 += v2 * b22;
        t18 += v2 * b3;
        t19 += v2 * b4;
        t20 += v2 * b5;
        t21 += v2 * b6;
        t22 += v2 * b7;
        t23 += v2 * b8;
        t24 += v2 * b9;
        t25 += v2 * b10;
        t26 += v2 * b11;
        t27 += v2 * b12;
        t28 += v2 * b13;
        t29 += v2 * b14;
        t30 += v2 * b15;
        t0 += 38 * t16;
        t1 += 38 * t17;
        t2 += 38 * t18;
        t3 += 38 * t19;
        t4 += 38 * t20;
        t5 += 38 * t21;
        t6 += 38 * t22;
        t7 += 38 * t23;
        t8 += 38 * t24;
        t9 += 38 * t25;
        t10 += 38 * t26;
        t11 += 38 * t27;
        t12 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        c = 1;
        v2 = t0 + c + 65535;
        c = Math.floor(v2 / 65536);
        t0 = v2 - c * 65536;
        v2 = t1 + c + 65535;
        c = Math.floor(v2 / 65536);
        t1 = v2 - c * 65536;
        v2 = t2 + c + 65535;
        c = Math.floor(v2 / 65536);
        t2 = v2 - c * 65536;
        v2 = t3 + c + 65535;
        c = Math.floor(v2 / 65536);
        t3 = v2 - c * 65536;
        v2 = t4 + c + 65535;
        c = Math.floor(v2 / 65536);
        t4 = v2 - c * 65536;
        v2 = t5 + c + 65535;
        c = Math.floor(v2 / 65536);
        t5 = v2 - c * 65536;
        v2 = t6 + c + 65535;
        c = Math.floor(v2 / 65536);
        t6 = v2 - c * 65536;
        v2 = t7 + c + 65535;
        c = Math.floor(v2 / 65536);
        t7 = v2 - c * 65536;
        v2 = t8 + c + 65535;
        c = Math.floor(v2 / 65536);
        t8 = v2 - c * 65536;
        v2 = t9 + c + 65535;
        c = Math.floor(v2 / 65536);
        t9 = v2 - c * 65536;
        v2 = t10 + c + 65535;
        c = Math.floor(v2 / 65536);
        t10 = v2 - c * 65536;
        v2 = t11 + c + 65535;
        c = Math.floor(v2 / 65536);
        t11 = v2 - c * 65536;
        v2 = t12 + c + 65535;
        c = Math.floor(v2 / 65536);
        t12 = v2 - c * 65536;
        v2 = t13 + c + 65535;
        c = Math.floor(v2 / 65536);
        t13 = v2 - c * 65536;
        v2 = t14 + c + 65535;
        c = Math.floor(v2 / 65536);
        t14 = v2 - c * 65536;
        v2 = t15 + c + 65535;
        c = Math.floor(v2 / 65536);
        t15 = v2 - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        c = 1;
        v2 = t0 + c + 65535;
        c = Math.floor(v2 / 65536);
        t0 = v2 - c * 65536;
        v2 = t1 + c + 65535;
        c = Math.floor(v2 / 65536);
        t1 = v2 - c * 65536;
        v2 = t2 + c + 65535;
        c = Math.floor(v2 / 65536);
        t2 = v2 - c * 65536;
        v2 = t3 + c + 65535;
        c = Math.floor(v2 / 65536);
        t3 = v2 - c * 65536;
        v2 = t4 + c + 65535;
        c = Math.floor(v2 / 65536);
        t4 = v2 - c * 65536;
        v2 = t5 + c + 65535;
        c = Math.floor(v2 / 65536);
        t5 = v2 - c * 65536;
        v2 = t6 + c + 65535;
        c = Math.floor(v2 / 65536);
        t6 = v2 - c * 65536;
        v2 = t7 + c + 65535;
        c = Math.floor(v2 / 65536);
        t7 = v2 - c * 65536;
        v2 = t8 + c + 65535;
        c = Math.floor(v2 / 65536);
        t8 = v2 - c * 65536;
        v2 = t9 + c + 65535;
        c = Math.floor(v2 / 65536);
        t9 = v2 - c * 65536;
        v2 = t10 + c + 65535;
        c = Math.floor(v2 / 65536);
        t10 = v2 - c * 65536;
        v2 = t11 + c + 65535;
        c = Math.floor(v2 / 65536);
        t11 = v2 - c * 65536;
        v2 = t12 + c + 65535;
        c = Math.floor(v2 / 65536);
        t12 = v2 - c * 65536;
        v2 = t13 + c + 65535;
        c = Math.floor(v2 / 65536);
        t13 = v2 - c * 65536;
        v2 = t14 + c + 65535;
        c = Math.floor(v2 / 65536);
        t14 = v2 - c * 65536;
        v2 = t15 + c + 65535;
        c = Math.floor(v2 / 65536);
        t15 = v2 - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        o4[0] = t0;
        o4[1] = t1;
        o4[2] = t2;
        o4[3] = t3;
        o4[4] = t4;
        o4[5] = t5;
        o4[6] = t6;
        o4[7] = t7;
        o4[8] = t8;
        o4[9] = t9;
        o4[10] = t10;
        o4[11] = t11;
        o4[12] = t12;
        o4[13] = t13;
        o4[14] = t14;
        o4[15] = t15;
      }
      function S2(o4, a2) {
        M2(o4, a2, a2);
      }
      function inv25519(o4, i) {
        var c = gf();
        var a2;
        for (a2 = 0; a2 < 16; a2++) c[a2] = i[a2];
        for (a2 = 253; a2 >= 0; a2--) {
          S2(c, c);
          if (a2 !== 2 && a2 !== 4) M2(c, c, i);
        }
        for (a2 = 0; a2 < 16; a2++) o4[a2] = c[a2];
      }
      function pow2523(o4, i) {
        var c = gf();
        var a2;
        for (a2 = 0; a2 < 16; a2++) c[a2] = i[a2];
        for (a2 = 250; a2 >= 0; a2--) {
          S2(c, c);
          if (a2 !== 1) M2(c, c, i);
        }
        for (a2 = 0; a2 < 16; a2++) o4[a2] = c[a2];
      }
      function crypto_scalarmult(q, n, p2) {
        var z2 = new Uint8Array(32);
        var x2 = new Float64Array(80), r, i;
        var a2 = gf(), b2 = gf(), c = gf(), d = gf(), e = gf(), f2 = gf();
        for (i = 0; i < 31; i++) z2[i] = n[i];
        z2[31] = n[31] & 127 | 64;
        z2[0] &= 248;
        unpack25519(x2, p2);
        for (i = 0; i < 16; i++) {
          b2[i] = x2[i];
          d[i] = a2[i] = c[i] = 0;
        }
        a2[0] = d[0] = 1;
        for (i = 254; i >= 0; --i) {
          r = z2[i >>> 3] >>> (i & 7) & 1;
          sel25519(a2, b2, r);
          sel25519(c, d, r);
          A2(e, a2, c);
          Z2(a2, a2, c);
          A2(c, b2, d);
          Z2(b2, b2, d);
          S2(d, e);
          S2(f2, a2);
          M2(a2, c, a2);
          M2(c, b2, e);
          A2(e, a2, c);
          Z2(a2, a2, c);
          S2(b2, a2);
          Z2(c, d, f2);
          M2(a2, c, _121665);
          A2(a2, a2, d);
          M2(c, c, a2);
          M2(a2, d, f2);
          M2(d, b2, x2);
          S2(b2, e);
          sel25519(a2, b2, r);
          sel25519(c, d, r);
        }
        for (i = 0; i < 16; i++) {
          x2[i + 16] = a2[i];
          x2[i + 32] = c[i];
          x2[i + 48] = b2[i];
          x2[i + 64] = d[i];
        }
        var x32 = x2.subarray(32);
        var x16 = x2.subarray(16);
        inv25519(x32, x32);
        M2(x16, x16, x32);
        pack25519(q, x16);
        return 0;
      }
      function crypto_scalarmult_base(q, n) {
        return crypto_scalarmult(q, n, _9);
      }
      function crypto_box_keypair(y2, x2) {
        randombytes(x2, 32);
        return crypto_scalarmult_base(y2, x2);
      }
      function crypto_box_beforenm(k2, y2, x2) {
        var s2 = new Uint8Array(32);
        crypto_scalarmult(s2, x2, y2);
        return crypto_core_hsalsa20(k2, _0, s2, sigma);
      }
      var crypto_box_afternm = crypto_secretbox;
      var crypto_box_open_afternm = crypto_secretbox_open;
      function crypto_box(c, m2, d, n, y2, x2) {
        var k2 = new Uint8Array(32);
        crypto_box_beforenm(k2, y2, x2);
        return crypto_box_afternm(c, m2, d, n, k2);
      }
      function crypto_box_open(m2, c, d, n, y2, x2) {
        var k2 = new Uint8Array(32);
        crypto_box_beforenm(k2, y2, x2);
        return crypto_box_open_afternm(m2, c, d, n, k2);
      }
      var K2 = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function crypto_hashblocks_hl(hh, hl, m2, n) {
        var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j2, h2, l, a2, b2, c, d;
        var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
        var pos = 0;
        while (n >= 128) {
          for (i = 0; i < 16; i++) {
            j2 = 8 * i + pos;
            wh[i] = m2[j2 + 0] << 24 | m2[j2 + 1] << 16 | m2[j2 + 2] << 8 | m2[j2 + 3];
            wl[i] = m2[j2 + 4] << 24 | m2[j2 + 5] << 16 | m2[j2 + 6] << 8 | m2[j2 + 7];
          }
          for (i = 0; i < 80; i++) {
            bh0 = ah0;
            bh1 = ah1;
            bh2 = ah2;
            bh3 = ah3;
            bh4 = ah4;
            bh5 = ah5;
            bh6 = ah6;
            bh7 = ah7;
            bl0 = al0;
            bl1 = al1;
            bl2 = al2;
            bl3 = al3;
            bl4 = al4;
            bl5 = al5;
            bl6 = al6;
            bl7 = al7;
            h2 = ah7;
            l = al7;
            a2 = l & 65535;
            b2 = l >>> 16;
            c = h2 & 65535;
            d = h2 >>> 16;
            h2 = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
            l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
            a2 += l & 65535;
            b2 += l >>> 16;
            c += h2 & 65535;
            d += h2 >>> 16;
            h2 = ah4 & ah5 ^ ~ah4 & ah6;
            l = al4 & al5 ^ ~al4 & al6;
            a2 += l & 65535;
            b2 += l >>> 16;
            c += h2 & 65535;
            d += h2 >>> 16;
            h2 = K2[i * 2];
            l = K2[i * 2 + 1];
            a2 += l & 65535;
            b2 += l >>> 16;
            c += h2 & 65535;
            d += h2 >>> 16;
            h2 = wh[i % 16];
            l = wl[i % 16];
            a2 += l & 65535;
            b2 += l >>> 16;
            c += h2 & 65535;
            d += h2 >>> 16;
            b2 += a2 >>> 16;
            c += b2 >>> 16;
            d += c >>> 16;
            th = c & 65535 | d << 16;
            tl = a2 & 65535 | b2 << 16;
            h2 = th;
            l = tl;
            a2 = l & 65535;
            b2 = l >>> 16;
            c = h2 & 65535;
            d = h2 >>> 16;
            h2 = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
            l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
            a2 += l & 65535;
            b2 += l >>> 16;
            c += h2 & 65535;
            d += h2 >>> 16;
            h2 = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
            l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
            a2 += l & 65535;
            b2 += l >>> 16;
            c += h2 & 65535;
            d += h2 >>> 16;
            b2 += a2 >>> 16;
            c += b2 >>> 16;
            d += c >>> 16;
            bh7 = c & 65535 | d << 16;
            bl7 = a2 & 65535 | b2 << 16;
            h2 = bh3;
            l = bl3;
            a2 = l & 65535;
            b2 = l >>> 16;
            c = h2 & 65535;
            d = h2 >>> 16;
            h2 = th;
            l = tl;
            a2 += l & 65535;
            b2 += l >>> 16;
            c += h2 & 65535;
            d += h2 >>> 16;
            b2 += a2 >>> 16;
            c += b2 >>> 16;
            d += c >>> 16;
            bh3 = c & 65535 | d << 16;
            bl3 = a2 & 65535 | b2 << 16;
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i % 16 === 15) {
              for (j2 = 0; j2 < 16; j2++) {
                h2 = wh[j2];
                l = wl[j2];
                a2 = l & 65535;
                b2 = l >>> 16;
                c = h2 & 65535;
                d = h2 >>> 16;
                h2 = wh[(j2 + 9) % 16];
                l = wl[(j2 + 9) % 16];
                a2 += l & 65535;
                b2 += l >>> 16;
                c += h2 & 65535;
                d += h2 >>> 16;
                th = wh[(j2 + 1) % 16];
                tl = wl[(j2 + 1) % 16];
                h2 = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                a2 += l & 65535;
                b2 += l >>> 16;
                c += h2 & 65535;
                d += h2 >>> 16;
                th = wh[(j2 + 14) % 16];
                tl = wl[(j2 + 14) % 16];
                h2 = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                a2 += l & 65535;
                b2 += l >>> 16;
                c += h2 & 65535;
                d += h2 >>> 16;
                b2 += a2 >>> 16;
                c += b2 >>> 16;
                d += c >>> 16;
                wh[j2] = c & 65535 | d << 16;
                wl[j2] = a2 & 65535 | b2 << 16;
              }
            }
          }
          h2 = ah0;
          l = al0;
          a2 = l & 65535;
          b2 = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[0];
          l = hl[0];
          a2 += l & 65535;
          b2 += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b2 += a2 >>> 16;
          c += b2 >>> 16;
          d += c >>> 16;
          hh[0] = ah0 = c & 65535 | d << 16;
          hl[0] = al0 = a2 & 65535 | b2 << 16;
          h2 = ah1;
          l = al1;
          a2 = l & 65535;
          b2 = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[1];
          l = hl[1];
          a2 += l & 65535;
          b2 += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b2 += a2 >>> 16;
          c += b2 >>> 16;
          d += c >>> 16;
          hh[1] = ah1 = c & 65535 | d << 16;
          hl[1] = al1 = a2 & 65535 | b2 << 16;
          h2 = ah2;
          l = al2;
          a2 = l & 65535;
          b2 = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[2];
          l = hl[2];
          a2 += l & 65535;
          b2 += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b2 += a2 >>> 16;
          c += b2 >>> 16;
          d += c >>> 16;
          hh[2] = ah2 = c & 65535 | d << 16;
          hl[2] = al2 = a2 & 65535 | b2 << 16;
          h2 = ah3;
          l = al3;
          a2 = l & 65535;
          b2 = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[3];
          l = hl[3];
          a2 += l & 65535;
          b2 += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b2 += a2 >>> 16;
          c += b2 >>> 16;
          d += c >>> 16;
          hh[3] = ah3 = c & 65535 | d << 16;
          hl[3] = al3 = a2 & 65535 | b2 << 16;
          h2 = ah4;
          l = al4;
          a2 = l & 65535;
          b2 = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[4];
          l = hl[4];
          a2 += l & 65535;
          b2 += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b2 += a2 >>> 16;
          c += b2 >>> 16;
          d += c >>> 16;
          hh[4] = ah4 = c & 65535 | d << 16;
          hl[4] = al4 = a2 & 65535 | b2 << 16;
          h2 = ah5;
          l = al5;
          a2 = l & 65535;
          b2 = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[5];
          l = hl[5];
          a2 += l & 65535;
          b2 += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b2 += a2 >>> 16;
          c += b2 >>> 16;
          d += c >>> 16;
          hh[5] = ah5 = c & 65535 | d << 16;
          hl[5] = al5 = a2 & 65535 | b2 << 16;
          h2 = ah6;
          l = al6;
          a2 = l & 65535;
          b2 = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[6];
          l = hl[6];
          a2 += l & 65535;
          b2 += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b2 += a2 >>> 16;
          c += b2 >>> 16;
          d += c >>> 16;
          hh[6] = ah6 = c & 65535 | d << 16;
          hl[6] = al6 = a2 & 65535 | b2 << 16;
          h2 = ah7;
          l = al7;
          a2 = l & 65535;
          b2 = l >>> 16;
          c = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[7];
          l = hl[7];
          a2 += l & 65535;
          b2 += l >>> 16;
          c += h2 & 65535;
          d += h2 >>> 16;
          b2 += a2 >>> 16;
          c += b2 >>> 16;
          d += c >>> 16;
          hh[7] = ah7 = c & 65535 | d << 16;
          hl[7] = al7 = a2 & 65535 | b2 << 16;
          pos += 128;
          n -= 128;
        }
        return n;
      }
      function crypto_hash(out, m2, n) {
        var hh = new Int32Array(8), hl = new Int32Array(8), x2 = new Uint8Array(256), i, b2 = n;
        hh[0] = 1779033703;
        hh[1] = 3144134277;
        hh[2] = 1013904242;
        hh[3] = 2773480762;
        hh[4] = 1359893119;
        hh[5] = 2600822924;
        hh[6] = 528734635;
        hh[7] = 1541459225;
        hl[0] = 4089235720;
        hl[1] = 2227873595;
        hl[2] = 4271175723;
        hl[3] = 1595750129;
        hl[4] = 2917565137;
        hl[5] = 725511199;
        hl[6] = 4215389547;
        hl[7] = 327033209;
        crypto_hashblocks_hl(hh, hl, m2, n);
        n %= 128;
        for (i = 0; i < n; i++) x2[i] = m2[b2 - n + i];
        x2[n] = 128;
        n = 256 - 128 * (n < 112 ? 1 : 0);
        x2[n - 9] = 0;
        ts64(x2, n - 8, b2 / 536870912 | 0, b2 << 3);
        crypto_hashblocks_hl(hh, hl, x2, n);
        for (i = 0; i < 8; i++) ts64(out, 8 * i, hh[i], hl[i]);
        return 0;
      }
      function add(p2, q) {
        var a2 = gf(), b2 = gf(), c = gf(), d = gf(), e = gf(), f2 = gf(), g2 = gf(), h2 = gf(), t = gf();
        Z2(a2, p2[1], p2[0]);
        Z2(t, q[1], q[0]);
        M2(a2, a2, t);
        A2(b2, p2[0], p2[1]);
        A2(t, q[0], q[1]);
        M2(b2, b2, t);
        M2(c, p2[3], q[3]);
        M2(c, c, D22);
        M2(d, p2[2], q[2]);
        A2(d, d, d);
        Z2(e, b2, a2);
        Z2(f2, d, c);
        A2(g2, d, c);
        A2(h2, b2, a2);
        M2(p2[0], e, f2);
        M2(p2[1], h2, g2);
        M2(p2[2], g2, f2);
        M2(p2[3], e, h2);
      }
      function cswap(p2, q, b2) {
        var i;
        for (i = 0; i < 4; i++) {
          sel25519(p2[i], q[i], b2);
        }
      }
      function pack(r, p2) {
        var tx = gf(), ty = gf(), zi = gf();
        inv25519(zi, p2[2]);
        M2(tx, p2[0], zi);
        M2(ty, p2[1], zi);
        pack25519(r, ty);
        r[31] ^= par25519(tx) << 7;
      }
      function scalarmult(p2, q, s2) {
        var b2, i;
        set25519(p2[0], gf0);
        set25519(p2[1], gf1);
        set25519(p2[2], gf1);
        set25519(p2[3], gf0);
        for (i = 255; i >= 0; --i) {
          b2 = s2[i / 8 | 0] >> (i & 7) & 1;
          cswap(p2, q, b2);
          add(q, p2);
          add(p2, p2);
          cswap(p2, q, b2);
        }
      }
      function scalarbase(p2, s2) {
        var q = [gf(), gf(), gf(), gf()];
        set25519(q[0], X2);
        set25519(q[1], Y);
        set25519(q[2], gf1);
        M2(q[3], X2, Y);
        scalarmult(p2, q, s2);
      }
      function crypto_sign_keypair(pk, sk, seeded) {
        var d = new Uint8Array(64);
        var p2 = [gf(), gf(), gf(), gf()];
        var i;
        if (!seeded) randombytes(sk, 32);
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        scalarbase(p2, d);
        pack(pk, p2);
        for (i = 0; i < 32; i++) sk[i + 32] = pk[i];
        return 0;
      }
      var L = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
      function modL(r, x2) {
        var carry, i, j2, k2;
        for (i = 63; i >= 32; --i) {
          carry = 0;
          for (j2 = i - 32, k2 = i - 12; j2 < k2; ++j2) {
            x2[j2] += carry - 16 * x2[i] * L[j2 - (i - 32)];
            carry = Math.floor((x2[j2] + 128) / 256);
            x2[j2] -= carry * 256;
          }
          x2[j2] += carry;
          x2[i] = 0;
        }
        carry = 0;
        for (j2 = 0; j2 < 32; j2++) {
          x2[j2] += carry - (x2[31] >> 4) * L[j2];
          carry = x2[j2] >> 8;
          x2[j2] &= 255;
        }
        for (j2 = 0; j2 < 32; j2++) x2[j2] -= carry * L[j2];
        for (i = 0; i < 32; i++) {
          x2[i + 1] += x2[i] >> 8;
          r[i] = x2[i] & 255;
        }
      }
      function reduce(r) {
        var x2 = new Float64Array(64), i;
        for (i = 0; i < 64; i++) x2[i] = r[i];
        for (i = 0; i < 64; i++) r[i] = 0;
        modL(r, x2);
      }
      function crypto_sign(sm, m2, n, sk) {
        var d = new Uint8Array(64), h2 = new Uint8Array(64), r = new Uint8Array(64);
        var i, j2, x2 = new Float64Array(64);
        var p2 = [gf(), gf(), gf(), gf()];
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        var smlen = n + 64;
        for (i = 0; i < n; i++) sm[64 + i] = m2[i];
        for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];
        crypto_hash(r, sm.subarray(32), n + 32);
        reduce(r);
        scalarbase(p2, r);
        pack(sm, p2);
        for (i = 32; i < 64; i++) sm[i] = sk[i];
        crypto_hash(h2, sm, n + 64);
        reduce(h2);
        for (i = 0; i < 64; i++) x2[i] = 0;
        for (i = 0; i < 32; i++) x2[i] = r[i];
        for (i = 0; i < 32; i++) {
          for (j2 = 0; j2 < 32; j2++) {
            x2[i + j2] += h2[i] * d[j2];
          }
        }
        modL(sm.subarray(32), x2);
        return smlen;
      }
      function unpackneg(r, p2) {
        var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r[2], gf1);
        unpack25519(r[1], p2);
        S2(num, r[1]);
        M2(den, num, D2);
        Z2(num, num, r[2]);
        A2(den, r[2], den);
        S2(den2, den);
        S2(den4, den2);
        M2(den6, den4, den2);
        M2(t, den6, num);
        M2(t, t, den);
        pow2523(t, t);
        M2(t, t, num);
        M2(t, t, den);
        M2(t, t, den);
        M2(r[0], t, den);
        S2(chk, r[0]);
        M2(chk, chk, den);
        if (neq25519(chk, num)) M2(r[0], r[0], I2);
        S2(chk, r[0]);
        M2(chk, chk, den);
        if (neq25519(chk, num)) return -1;
        if (par25519(r[0]) === p2[31] >> 7) Z2(r[0], gf0, r[0]);
        M2(r[3], r[0], r[1]);
        return 0;
      }
      function crypto_sign_open(m2, sm, n, pk) {
        var i;
        var t = new Uint8Array(32), h2 = new Uint8Array(64);
        var p2 = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
        if (n < 64) return -1;
        if (unpackneg(q, pk)) return -1;
        for (i = 0; i < n; i++) m2[i] = sm[i];
        for (i = 0; i < 32; i++) m2[i + 32] = pk[i];
        crypto_hash(h2, m2, n);
        reduce(h2);
        scalarmult(p2, q, h2);
        scalarbase(q, sm.subarray(32));
        add(p2, q);
        pack(t, p2);
        n -= 64;
        if (crypto_verify_32(sm, 0, t, 0)) {
          for (i = 0; i < n; i++) m2[i] = 0;
          return -1;
        }
        for (i = 0; i < n; i++) m2[i] = sm[i + 64];
        return n;
      }
      var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
      nacl2.lowlevel = {
        crypto_core_hsalsa20,
        crypto_stream_xor,
        crypto_stream,
        crypto_stream_salsa20_xor,
        crypto_stream_salsa20,
        crypto_onetimeauth,
        crypto_onetimeauth_verify,
        crypto_verify_16,
        crypto_verify_32,
        crypto_secretbox,
        crypto_secretbox_open,
        crypto_scalarmult,
        crypto_scalarmult_base,
        crypto_box_beforenm,
        crypto_box_afternm,
        crypto_box,
        crypto_box_open,
        crypto_box_keypair,
        crypto_hash,
        crypto_sign,
        crypto_sign_keypair,
        crypto_sign_open,
        crypto_secretbox_KEYBYTES,
        crypto_secretbox_NONCEBYTES,
        crypto_secretbox_ZEROBYTES,
        crypto_secretbox_BOXZEROBYTES,
        crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES,
        crypto_box_PUBLICKEYBYTES,
        crypto_box_SECRETKEYBYTES,
        crypto_box_BEFORENMBYTES,
        crypto_box_NONCEBYTES,
        crypto_box_ZEROBYTES,
        crypto_box_BOXZEROBYTES,
        crypto_sign_BYTES,
        crypto_sign_PUBLICKEYBYTES,
        crypto_sign_SECRETKEYBYTES,
        crypto_sign_SEEDBYTES,
        crypto_hash_BYTES,
        gf,
        D: D2,
        L,
        pack25519,
        unpack25519,
        M: M2,
        A: A2,
        S: S2,
        Z: Z2,
        pow2523,
        add,
        set25519,
        modL,
        scalarmult,
        scalarbase
      };
      function checkLengths(k2, n) {
        if (k2.length !== crypto_secretbox_KEYBYTES) throw new Error("bad key size");
        if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error("bad nonce size");
      }
      function checkBoxLengths(pk, sk) {
        if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error("bad public key size");
        if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error("bad secret key size");
      }
      function checkArrayTypes() {
        for (var i = 0; i < arguments.length; i++) {
          if (!(arguments[i] instanceof Uint8Array))
            throw new TypeError("unexpected type, use Uint8Array");
        }
      }
      function cleanup(arr) {
        for (var i = 0; i < arr.length; i++) arr[i] = 0;
      }
      nacl2.randomBytes = function(n) {
        var b2 = new Uint8Array(n);
        randombytes(b2, n);
        return b2;
      };
      nacl2.secretbox = function(msg, nonce, key2) {
        checkArrayTypes(msg, nonce, key2);
        checkLengths(key2, nonce);
        var m2 = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
        var c = new Uint8Array(m2.length);
        for (var i = 0; i < msg.length; i++) m2[i + crypto_secretbox_ZEROBYTES] = msg[i];
        crypto_secretbox(c, m2, m2.length, nonce, key2);
        return c.subarray(crypto_secretbox_BOXZEROBYTES);
      };
      nacl2.secretbox.open = function(box, nonce, key2) {
        checkArrayTypes(box, nonce, key2);
        checkLengths(key2, nonce);
        var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
        var m2 = new Uint8Array(c.length);
        for (var i = 0; i < box.length; i++) c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
        if (c.length < 32) return null;
        if (crypto_secretbox_open(m2, c, c.length, nonce, key2) !== 0) return null;
        return m2.subarray(crypto_secretbox_ZEROBYTES);
      };
      nacl2.secretbox.keyLength = crypto_secretbox_KEYBYTES;
      nacl2.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
      nacl2.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
      nacl2.scalarMult = function(n, p2) {
        checkArrayTypes(n, p2);
        if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
        if (p2.length !== crypto_scalarmult_BYTES) throw new Error("bad p size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult(q, n, p2);
        return q;
      };
      nacl2.scalarMult.base = function(n) {
        checkArrayTypes(n);
        if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult_base(q, n);
        return q;
      };
      nacl2.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
      nacl2.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
      nacl2.box = function(msg, nonce, publicKey, secretKey) {
        var k2 = nacl2.box.before(publicKey, secretKey);
        return nacl2.secretbox(msg, nonce, k2);
      };
      nacl2.box.before = function(publicKey, secretKey) {
        checkArrayTypes(publicKey, secretKey);
        checkBoxLengths(publicKey, secretKey);
        var k2 = new Uint8Array(crypto_box_BEFORENMBYTES);
        crypto_box_beforenm(k2, publicKey, secretKey);
        return k2;
      };
      nacl2.box.after = nacl2.secretbox;
      nacl2.box.open = function(msg, nonce, publicKey, secretKey) {
        var k2 = nacl2.box.before(publicKey, secretKey);
        return nacl2.secretbox.open(msg, nonce, k2);
      };
      nacl2.box.open.after = nacl2.secretbox.open;
      nacl2.box.keyPair = function() {
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
        crypto_box_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl2.box.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        crypto_scalarmult_base(pk, secretKey);
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl2.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
      nacl2.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
      nacl2.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
      nacl2.box.nonceLength = crypto_box_NONCEBYTES;
      nacl2.box.overheadLength = nacl2.secretbox.overheadLength;
      nacl2.sign = function(msg, secretKey) {
        checkArrayTypes(msg, secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
        crypto_sign(signedMsg, msg, msg.length, secretKey);
        return signedMsg;
      };
      nacl2.sign.open = function(signedMsg, publicKey) {
        checkArrayTypes(signedMsg, publicKey);
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var tmp = new Uint8Array(signedMsg.length);
        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
        if (mlen < 0) return null;
        var m2 = new Uint8Array(mlen);
        for (var i = 0; i < m2.length; i++) m2[i] = tmp[i];
        return m2;
      };
      nacl2.sign.detached = function(msg, secretKey) {
        var signedMsg = nacl2.sign(msg, secretKey);
        var sig = new Uint8Array(crypto_sign_BYTES);
        for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
        return sig;
      };
      nacl2.sign.detached.verify = function(msg, sig, publicKey) {
        checkArrayTypes(msg, sig, publicKey);
        if (sig.length !== crypto_sign_BYTES)
          throw new Error("bad signature size");
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
        var m2 = new Uint8Array(crypto_sign_BYTES + msg.length);
        var i;
        for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
        for (i = 0; i < msg.length; i++) sm[i + crypto_sign_BYTES] = msg[i];
        return crypto_sign_open(m2, sm, sm.length, publicKey) >= 0;
      };
      nacl2.sign.keyPair = function() {
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        crypto_sign_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl2.sign.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32 + i];
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl2.sign.keyPair.fromSeed = function(seed) {
        checkArrayTypes(seed);
        if (seed.length !== crypto_sign_SEEDBYTES)
          throw new Error("bad seed size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        for (var i = 0; i < 32; i++) sk[i] = seed[i];
        crypto_sign_keypair(pk, sk, true);
        return { publicKey: pk, secretKey: sk };
      };
      nacl2.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
      nacl2.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
      nacl2.sign.seedLength = crypto_sign_SEEDBYTES;
      nacl2.sign.signatureLength = crypto_sign_BYTES;
      nacl2.hash = function(msg) {
        checkArrayTypes(msg);
        var h2 = new Uint8Array(crypto_hash_BYTES);
        crypto_hash(h2, msg, msg.length);
        return h2;
      };
      nacl2.hash.hashLength = crypto_hash_BYTES;
      nacl2.verify = function(x2, y2) {
        checkArrayTypes(x2, y2);
        if (x2.length === 0 || y2.length === 0) return false;
        if (x2.length !== y2.length) return false;
        return vn2(x2, 0, y2, 0, x2.length) === 0 ? true : false;
      };
      nacl2.setPRNG = function(fn2) {
        randombytes = fn2;
      };
      (function() {
        var crypto2 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (crypto2 && crypto2.getRandomValues) {
          var QUOTA = 65536;
          nacl2.setPRNG(function(x2, n) {
            var i, v2 = new Uint8Array(n);
            for (i = 0; i < n; i += QUOTA) {
              crypto2.getRandomValues(v2.subarray(i, i + Math.min(n - i, QUOTA)));
            }
            for (i = 0; i < n; i++) x2[i] = v2[i];
            cleanup(v2);
          });
        } else if (typeof commonjsRequire !== "undefined") {
          crypto2 = require$$4$2;
          if (crypto2 && crypto2.randomBytes) {
            nacl2.setPRNG(function(x2, n) {
              var i, v2 = crypto2.randomBytes(n);
              for (i = 0; i < n; i++) x2[i] = v2[i];
              cleanup(v2);
            });
          }
        }
      })();
    })(module.exports ? module.exports : self.nacl = self.nacl || {});
  })(naclFast);
  return naclFast.exports;
}
var naclFastExports = requireNaclFast();
const f = /* @__PURE__ */ getDefaultExportFromCjs(naclFastExports);
var CONNECT_EVENT_ERROR_CODES;
(function(CONNECT_EVENT_ERROR_CODES2) {
  CONNECT_EVENT_ERROR_CODES2[CONNECT_EVENT_ERROR_CODES2["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR";
  CONNECT_EVENT_ERROR_CODES2[CONNECT_EVENT_ERROR_CODES2["BAD_REQUEST_ERROR"] = 1] = "BAD_REQUEST_ERROR";
  CONNECT_EVENT_ERROR_CODES2[CONNECT_EVENT_ERROR_CODES2["MANIFEST_NOT_FOUND_ERROR"] = 2] = "MANIFEST_NOT_FOUND_ERROR";
  CONNECT_EVENT_ERROR_CODES2[CONNECT_EVENT_ERROR_CODES2["MANIFEST_CONTENT_ERROR"] = 3] = "MANIFEST_CONTENT_ERROR";
  CONNECT_EVENT_ERROR_CODES2[CONNECT_EVENT_ERROR_CODES2["UNKNOWN_APP_ERROR"] = 100] = "UNKNOWN_APP_ERROR";
  CONNECT_EVENT_ERROR_CODES2[CONNECT_EVENT_ERROR_CODES2["USER_REJECTS_ERROR"] = 300] = "USER_REJECTS_ERROR";
  CONNECT_EVENT_ERROR_CODES2[CONNECT_EVENT_ERROR_CODES2["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED";
})(CONNECT_EVENT_ERROR_CODES || (CONNECT_EVENT_ERROR_CODES = {}));
var CONNECT_ITEM_ERROR_CODES;
(function(CONNECT_ITEM_ERROR_CODES2) {
  CONNECT_ITEM_ERROR_CODES2[CONNECT_ITEM_ERROR_CODES2["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR";
  CONNECT_ITEM_ERROR_CODES2[CONNECT_ITEM_ERROR_CODES2["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED";
})(CONNECT_ITEM_ERROR_CODES || (CONNECT_ITEM_ERROR_CODES = {}));
var SEND_TRANSACTION_ERROR_CODES;
(function(SEND_TRANSACTION_ERROR_CODES2) {
  SEND_TRANSACTION_ERROR_CODES2[SEND_TRANSACTION_ERROR_CODES2["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR";
  SEND_TRANSACTION_ERROR_CODES2[SEND_TRANSACTION_ERROR_CODES2["BAD_REQUEST_ERROR"] = 1] = "BAD_REQUEST_ERROR";
  SEND_TRANSACTION_ERROR_CODES2[SEND_TRANSACTION_ERROR_CODES2["UNKNOWN_APP_ERROR"] = 100] = "UNKNOWN_APP_ERROR";
  SEND_TRANSACTION_ERROR_CODES2[SEND_TRANSACTION_ERROR_CODES2["USER_REJECTS_ERROR"] = 300] = "USER_REJECTS_ERROR";
  SEND_TRANSACTION_ERROR_CODES2[SEND_TRANSACTION_ERROR_CODES2["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED";
})(SEND_TRANSACTION_ERROR_CODES || (SEND_TRANSACTION_ERROR_CODES = {}));
var SIGN_DATA_ERROR_CODES;
(function(SIGN_DATA_ERROR_CODES2) {
  SIGN_DATA_ERROR_CODES2[SIGN_DATA_ERROR_CODES2["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR";
  SIGN_DATA_ERROR_CODES2[SIGN_DATA_ERROR_CODES2["BAD_REQUEST_ERROR"] = 1] = "BAD_REQUEST_ERROR";
  SIGN_DATA_ERROR_CODES2[SIGN_DATA_ERROR_CODES2["UNKNOWN_APP_ERROR"] = 100] = "UNKNOWN_APP_ERROR";
  SIGN_DATA_ERROR_CODES2[SIGN_DATA_ERROR_CODES2["USER_REJECTS_ERROR"] = 300] = "USER_REJECTS_ERROR";
  SIGN_DATA_ERROR_CODES2[SIGN_DATA_ERROR_CODES2["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED";
})(SIGN_DATA_ERROR_CODES || (SIGN_DATA_ERROR_CODES = {}));
var DISCONNECT_ERROR_CODES;
(function(DISCONNECT_ERROR_CODES2) {
  DISCONNECT_ERROR_CODES2[DISCONNECT_ERROR_CODES2["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR";
  DISCONNECT_ERROR_CODES2[DISCONNECT_ERROR_CODES2["BAD_REQUEST_ERROR"] = 1] = "BAD_REQUEST_ERROR";
  DISCONNECT_ERROR_CODES2[DISCONNECT_ERROR_CODES2["UNKNOWN_APP_ERROR"] = 100] = "UNKNOWN_APP_ERROR";
  DISCONNECT_ERROR_CODES2[DISCONNECT_ERROR_CODES2["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED";
})(DISCONNECT_ERROR_CODES || (DISCONNECT_ERROR_CODES = {}));
var CHAIN;
(function(CHAIN2) {
  CHAIN2["MAINNET"] = "-239";
  CHAIN2["TESTNET"] = "-3";
})(CHAIN || (CHAIN = {}));
function encodeUint8Array(value, urlSafe) {
  const encoded = nacl$1.encodeBase64(value);
  if (!urlSafe) {
    return encoded;
  }
  return encodeURIComponent(encoded);
}
function decodeToUint8Array(value, urlSafe) {
  if (urlSafe) {
    value = decodeURIComponent(value);
  }
  return nacl$1.decodeBase64(value);
}
function encode(value, urlSafe = false) {
  let uint8Array;
  if (value instanceof Uint8Array) {
    uint8Array = value;
  } else {
    if (typeof value !== "string") {
      value = JSON.stringify(value);
    }
    uint8Array = nacl$1.decodeUTF8(value);
  }
  return encodeUint8Array(uint8Array, urlSafe);
}
function decode$1(value, urlSafe = false) {
  const decodedUint8Array = decodeToUint8Array(value, urlSafe);
  return {
    toString() {
      return nacl$1.encodeUTF8(decodedUint8Array);
    },
    toObject() {
      try {
        return JSON.parse(nacl$1.encodeUTF8(decodedUint8Array));
      } catch (e) {
        return null;
      }
    },
    toUint8Array() {
      return decodedUint8Array;
    }
  };
}
const Base64 = {
  encode,
  decode: decode$1
};
function concatUint8Arrays(buffer1, buffer2) {
  const mergedArray = new Uint8Array(buffer1.length + buffer2.length);
  mergedArray.set(buffer1);
  mergedArray.set(buffer2, buffer1.length);
  return mergedArray;
}
function splitToUint8Arrays(array, index) {
  if (index >= array.length) {
    throw new Error("Index is out of buffer");
  }
  const subArray1 = array.slice(0, index);
  const subArray2 = array.slice(index);
  return [subArray1, subArray2];
}
function toHexString(byteArray) {
  let hexString = "";
  byteArray.forEach((byte) => {
    hexString += ("0" + (byte & 255).toString(16)).slice(-2);
  });
  return hexString;
}
function hexToByteArray(hexString) {
  if (hexString.length % 2 !== 0) {
    throw new Error(`Cannot convert ${hexString} to bytesArray`);
  }
  const result = new Uint8Array(hexString.length / 2);
  for (let i = 0; i < hexString.length; i += 2) {
    result[i / 2] = parseInt(hexString.slice(i, i + 2), 16);
  }
  return result;
}
class SessionCrypto {
  constructor(keyPair) {
    this.nonceLength = 24;
    this.keyPair = keyPair ? this.createKeypairFromString(keyPair) : this.createKeypair();
    this.sessionId = toHexString(this.keyPair.publicKey);
  }
  createKeypair() {
    return f.box.keyPair();
  }
  createKeypairFromString(keyPair) {
    return {
      publicKey: hexToByteArray(keyPair.publicKey),
      secretKey: hexToByteArray(keyPair.secretKey)
    };
  }
  createNonce() {
    return f.randomBytes(this.nonceLength);
  }
  encrypt(message, receiverPublicKey) {
    const encodedMessage = new TextEncoder().encode(message);
    const nonce = this.createNonce();
    const encrypted = f.box(encodedMessage, nonce, receiverPublicKey, this.keyPair.secretKey);
    return concatUint8Arrays(nonce, encrypted);
  }
  decrypt(message, senderPublicKey) {
    const [nonce, internalMessage] = splitToUint8Arrays(message, this.nonceLength);
    const decrypted = f.box.open(internalMessage, nonce, senderPublicKey, this.keyPair.secretKey);
    if (!decrypted) {
      throw new Error(`Decryption error: 
 message: ${message.toString()} 
 sender pubkey: ${senderPublicKey.toString()} 
 keypair pubkey: ${this.keyPair.publicKey.toString()} 
 keypair secretkey: ${this.keyPair.secretKey.toString()}`);
    }
    return new TextDecoder().decode(decrypted);
  }
  stringifyKeypair() {
    return {
      publicKey: toHexString(this.keyPair.publicKey),
      secretKey: toHexString(this.keyPair.secretKey)
    };
  }
}
var dist$5 = {};
var Address = {};
var symbol_inspect;
var hasRequiredSymbol_inspect;
function requireSymbol_inspect() {
  if (hasRequiredSymbol_inspect) return symbol_inspect;
  hasRequiredSymbol_inspect = 1;
  const SymbolInspect = Symbol.for("nodejs.util.inspect.custom");
  symbol_inspect = SymbolInspect;
  return symbol_inspect;
}
var crc16 = {};
var hasRequiredCrc16;
function requireCrc16() {
  if (hasRequiredCrc16) return crc16;
  hasRequiredCrc16 = 1;
  Object.defineProperty(crc16, "__esModule", { value: true });
  crc16.crc16 = void 0;
  function crc16$1(data) {
    const poly = 4129;
    let reg = 0;
    const message = Buffer.alloc(data.length + 2);
    message.set(data);
    for (let byte of message) {
      let mask = 128;
      while (mask > 0) {
        reg <<= 1;
        if (byte & mask) {
          reg += 1;
        }
        mask >>= 1;
        if (reg > 65535) {
          reg &= 65535;
          reg ^= poly;
        }
      }
    }
    return Buffer.from([Math.floor(reg / 256), reg % 256]);
  }
  crc16.crc16 = crc16$1;
  return crc16;
}
var hasRequiredAddress;
function requireAddress() {
  if (hasRequiredAddress) return Address;
  hasRequiredAddress = 1;
  var __importDefault = Address && Address.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  var _a2;
  Object.defineProperty(Address, "__esModule", { value: true });
  Address.address = Address.Address = void 0;
  const symbol_inspect_1 = __importDefault(requireSymbol_inspect());
  const crc16_1 = requireCrc16();
  const bounceable_tag = 17;
  const non_bounceable_tag = 81;
  const test_flag = 128;
  function parseFriendlyAddress(src2) {
    if (typeof src2 === "string" && !Address$1.isFriendly(src2)) {
      throw new Error("Unknown address type");
    }
    const data = Buffer.isBuffer(src2) ? src2 : Buffer.from(src2, "base64");
    if (data.length !== 36) {
      throw new Error("Unknown address type: byte length is not equal to 36");
    }
    const addr = data.subarray(0, 34);
    const crc = data.subarray(34, 36);
    const calcedCrc = (0, crc16_1.crc16)(addr);
    if (!(calcedCrc[0] === crc[0] && calcedCrc[1] === crc[1])) {
      throw new Error("Invalid checksum: " + src2);
    }
    let tag = addr[0];
    let isTestOnly = false;
    let isBounceable = false;
    if (tag & test_flag) {
      isTestOnly = true;
      tag = tag ^ test_flag;
    }
    if (tag !== bounceable_tag && tag !== non_bounceable_tag)
      throw "Unknown address tag";
    isBounceable = tag === bounceable_tag;
    let workchain = null;
    if (addr[1] === 255) {
      workchain = -1;
    } else {
      workchain = addr[1];
    }
    const hashPart = addr.subarray(2, 34);
    return { isTestOnly, isBounceable, workchain, hashPart };
  }
  let Address$1 = class Address2 {
    static isAddress(src2) {
      return src2 instanceof Address2;
    }
    static isFriendly(source) {
      if (source.length !== 48) {
        return false;
      }
      if (!/^[A-Za-z0-9+/_-]+$/.test(source)) {
        return false;
      }
      return true;
    }
    static isRaw(source) {
      if (source.indexOf(":") === -1) {
        return false;
      }
      let [wc, hash] = source.split(":");
      if (!Number.isInteger(parseFloat(wc))) {
        return false;
      }
      if (!/[a-f0-9]+/.test(hash.toLowerCase())) {
        return false;
      }
      if (hash.length !== 64) {
        return false;
      }
      return true;
    }
    static normalize(source) {
      if (typeof source === "string") {
        return Address2.parse(source).toString();
      } else {
        return source.toString();
      }
    }
    static parse(source) {
      if (Address2.isFriendly(source)) {
        return this.parseFriendly(source).address;
      } else if (Address2.isRaw(source)) {
        return this.parseRaw(source);
      } else {
        throw new Error("Unknown address type: " + source);
      }
    }
    static parseRaw(source) {
      let workChain = parseInt(source.split(":")[0]);
      let hash = Buffer.from(source.split(":")[1], "hex");
      return new Address2(workChain, hash);
    }
    static parseFriendly(source) {
      if (Buffer.isBuffer(source)) {
        let r = parseFriendlyAddress(source);
        return {
          isBounceable: r.isBounceable,
          isTestOnly: r.isTestOnly,
          address: new Address2(r.workchain, r.hashPart)
        };
      } else {
        let addr = source.replace(/\-/g, "+").replace(/_/g, "/");
        let r = parseFriendlyAddress(addr);
        return {
          isBounceable: r.isBounceable,
          isTestOnly: r.isTestOnly,
          address: new Address2(r.workchain, r.hashPart)
        };
      }
    }
    constructor(workChain, hash) {
      this.toRawString = () => {
        return this.workChain + ":" + this.hash.toString("hex");
      };
      this.toRaw = () => {
        const addressWithChecksum = Buffer.alloc(36);
        addressWithChecksum.set(this.hash);
        addressWithChecksum.set([this.workChain, this.workChain, this.workChain, this.workChain], 32);
        return addressWithChecksum;
      };
      this.toStringBuffer = (args) => {
        let testOnly = args && args.testOnly !== void 0 ? args.testOnly : false;
        let bounceable = args && args.bounceable !== void 0 ? args.bounceable : true;
        let tag = bounceable ? bounceable_tag : non_bounceable_tag;
        if (testOnly) {
          tag |= test_flag;
        }
        const addr = Buffer.alloc(34);
        addr[0] = tag;
        addr[1] = this.workChain;
        addr.set(this.hash, 2);
        const addressWithChecksum = Buffer.alloc(36);
        addressWithChecksum.set(addr);
        addressWithChecksum.set((0, crc16_1.crc16)(addr), 34);
        return addressWithChecksum;
      };
      this.toString = (args) => {
        let urlSafe = args && args.urlSafe !== void 0 ? args.urlSafe : true;
        let buffer2 = this.toStringBuffer(args);
        if (urlSafe) {
          return buffer2.toString("base64").replace(/\+/g, "-").replace(/\//g, "_");
        } else {
          return buffer2.toString("base64");
        }
      };
      this[_a2] = () => this.toString();
      if (hash.length !== 32) {
        throw new Error("Invalid address hash length: " + hash.length);
      }
      this.workChain = workChain;
      this.hash = hash;
      Object.freeze(this);
    }
    equals(src2) {
      if (src2.workChain !== this.workChain) {
        return false;
      }
      return src2.hash.equals(this.hash);
    }
  };
  Address.Address = Address$1;
  _a2 = symbol_inspect_1.default;
  function address(src2) {
    return Address$1.parse(src2);
  }
  Address.address = address;
  return Address;
}
var ExternalAddress = {};
var hasRequiredExternalAddress;
function requireExternalAddress() {
  if (hasRequiredExternalAddress) return ExternalAddress;
  hasRequiredExternalAddress = 1;
  var __importDefault = ExternalAddress && ExternalAddress.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  var _a2;
  Object.defineProperty(ExternalAddress, "__esModule", { value: true });
  ExternalAddress.ExternalAddress = void 0;
  const symbol_inspect_1 = __importDefault(requireSymbol_inspect());
  let ExternalAddress$1 = class ExternalAddress2 {
    static isAddress(src2) {
      return src2 instanceof ExternalAddress2;
    }
    constructor(value, bits) {
      this[_a2] = () => this.toString();
      this.value = value;
      this.bits = bits;
    }
    toString() {
      return `External<${this.bits}:${this.value}>`;
    }
  };
  ExternalAddress.ExternalAddress = ExternalAddress$1;
  _a2 = symbol_inspect_1.default;
  return ExternalAddress;
}
var ADNLAddress = {};
var base32 = {};
var hasRequiredBase32;
function requireBase32() {
  if (hasRequiredBase32) return base32;
  hasRequiredBase32 = 1;
  Object.defineProperty(base32, "__esModule", { value: true });
  base32.base32Decode = base32.base32Encode = void 0;
  const alphabet = "abcdefghijklmnopqrstuvwxyz234567";
  function base32Encode(buffer2) {
    const length = buffer2.byteLength;
    let bits = 0;
    let value = 0;
    let output = "";
    for (let i = 0; i < length; i++) {
      value = value << 8 | buffer2[i];
      bits += 8;
      while (bits >= 5) {
        output += alphabet[value >>> bits - 5 & 31];
        bits -= 5;
      }
    }
    if (bits > 0) {
      output += alphabet[value << 5 - bits & 31];
    }
    return output;
  }
  base32.base32Encode = base32Encode;
  function readChar(alphabet2, char) {
    const idx = alphabet2.indexOf(char);
    if (idx === -1) {
      throw new Error("Invalid character found: " + char);
    }
    return idx;
  }
  function base32Decode(input) {
    let cleanedInput;
    cleanedInput = input.toLowerCase();
    const { length } = cleanedInput;
    let bits = 0;
    let value = 0;
    let index = 0;
    const output = Buffer.alloc(length * 5 / 8 | 0);
    for (let i = 0; i < length; i++) {
      value = value << 5 | readChar(alphabet, cleanedInput[i]);
      bits += 5;
      if (bits >= 8) {
        output[index++] = value >>> bits - 8 & 255;
        bits -= 8;
      }
    }
    return output;
  }
  base32.base32Decode = base32Decode;
  return base32;
}
var hasRequiredADNLAddress;
function requireADNLAddress() {
  if (hasRequiredADNLAddress) return ADNLAddress;
  hasRequiredADNLAddress = 1;
  var __importDefault = ADNLAddress && ADNLAddress.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  var _a2;
  Object.defineProperty(ADNLAddress, "__esModule", { value: true });
  ADNLAddress.ADNLAddress = void 0;
  const symbol_inspect_1 = __importDefault(requireSymbol_inspect());
  const base32_1 = requireBase32();
  const crc16_1 = requireCrc16();
  let ADNLAddress$1 = class ADNLAddress2 {
    static parseFriendly(src2) {
      if (src2.length !== 55) {
        throw Error("Invalid address");
      }
      src2 = "f" + src2;
      let decoded = (0, base32_1.base32Decode)(src2);
      if (decoded[0] !== 45) {
        throw Error("Invalid address");
      }
      let gotHash = decoded.slice(33);
      let hash = (0, crc16_1.crc16)(decoded.slice(0, 33));
      if (!hash.equals(gotHash)) {
        throw Error("Invalid address");
      }
      return new ADNLAddress2(decoded.slice(1, 33));
    }
    static parseRaw(src2) {
      const data = Buffer.from(src2, "base64");
      return new ADNLAddress2(data);
    }
    constructor(address) {
      this.toRaw = () => {
        return this.address.toString("hex").toUpperCase();
      };
      this.toString = () => {
        let data = Buffer.concat([Buffer.from([45]), this.address]);
        let hash = (0, crc16_1.crc16)(data);
        data = Buffer.concat([data, hash]);
        return (0, base32_1.base32Encode)(data).slice(1);
      };
      this[_a2] = () => this.toString();
      if (address.length !== 32) {
        throw Error("Invalid address");
      }
      this.address = address;
    }
    equals(b2) {
      return this.address.equals(b2.address);
    }
  };
  ADNLAddress.ADNLAddress = ADNLAddress$1;
  _a2 = symbol_inspect_1.default;
  return ADNLAddress;
}
var contractAddress = {};
var Builder$3 = {};
var BitBuilder = {};
var BitString = {};
var paddedBits = {};
var hasRequiredPaddedBits;
function requirePaddedBits() {
  if (hasRequiredPaddedBits) return paddedBits;
  hasRequiredPaddedBits = 1;
  Object.defineProperty(paddedBits, "__esModule", { value: true });
  paddedBits.paddedBufferToBits = paddedBits.bitsToPaddedBuffer = void 0;
  const BitBuilder_1 = requireBitBuilder();
  const BitString_1 = requireBitString();
  function bitsToPaddedBuffer(bits) {
    let builder2 = new BitBuilder_1.BitBuilder(Math.ceil(bits.length / 8) * 8);
    builder2.writeBits(bits);
    let padding = Math.ceil(bits.length / 8) * 8 - bits.length;
    for (let i = 0; i < padding; i++) {
      if (i === 0) {
        builder2.writeBit(1);
      } else {
        builder2.writeBit(0);
      }
    }
    return builder2.buffer();
  }
  paddedBits.bitsToPaddedBuffer = bitsToPaddedBuffer;
  function paddedBufferToBits(buff) {
    let bitLen = 0;
    for (let i = buff.length - 1; i >= 0; i--) {
      if (buff[i] !== 0) {
        const testByte = buff[i];
        let bitPos = testByte & -testByte;
        if ((bitPos & 1) == 0) {
          bitPos = Math.log2(bitPos) + 1;
        }
        if (i > 0) {
          bitLen = i << 3;
        }
        bitLen += 8 - bitPos;
        break;
      }
    }
    return new BitString_1.BitString(buff, 0, bitLen);
  }
  paddedBits.paddedBufferToBits = paddedBufferToBits;
  return paddedBits;
}
var hasRequiredBitString;
function requireBitString() {
  if (hasRequiredBitString) return BitString;
  hasRequiredBitString = 1;
  var __importDefault = BitString && BitString.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  var _a2;
  Object.defineProperty(BitString, "__esModule", { value: true });
  BitString.BitString = void 0;
  const paddedBits_1 = requirePaddedBits();
  const symbol_inspect_1 = __importDefault(requireSymbol_inspect());
  let BitString$1 = class BitString2 {
    /**
     * Checks if supplied object is BitString
     * @param src is unknow object
     * @returns true if object is BitString and false otherwise
     **/
    static isBitString(src2) {
      return src2 instanceof BitString2;
    }
    /**
     * Constructing BitString from a buffer
     * @param data data that contains the bitstring data. NOTE: We are expecting this buffer to be NOT modified
     * @param offset offset in bits from the start of the buffer
     * @param length length of the bitstring in bits
     */
    constructor(data, offset, length) {
      this[_a2] = () => this.toString();
      if (length < 0) {
        throw new Error(`Length ${length} is out of bounds`);
      }
      this._length = length;
      this._data = data;
      this._offset = offset;
    }
    /**
     * Returns the length of the bitstring
     */
    get length() {
      return this._length;
    }
    /**
     * Returns the bit at the specified index
     * @param index index of the bit
     * @throws Error if index is out of bounds
     * @returns true if the bit is set, false otherwise
     */
    at(index) {
      if (index >= this._length) {
        throw new Error(`Index ${index} > ${this._length} is out of bounds`);
      }
      if (index < 0) {
        throw new Error(`Index ${index} < 0 is out of bounds`);
      }
      let byteIndex = this._offset + index >> 3;
      let bitIndex = 7 - (this._offset + index) % 8;
      return (this._data[byteIndex] & 1 << bitIndex) !== 0;
    }
    /**
     * Get a subscring of the bitstring
     * @param offset
     * @param length
     * @returns
     */
    substring(offset, length) {
      if (offset > this._length) {
        throw new Error(`Offset(${offset}) > ${this._length} is out of bounds`);
      }
      if (offset < 0) {
        throw new Error(`Offset(${offset}) < 0 is out of bounds`);
      }
      if (length === 0) {
        return BitString2.EMPTY;
      }
      if (offset + length > this._length) {
        throw new Error(`Offset ${offset} + Length ${length} > ${this._length} is out of bounds`);
      }
      return new BitString2(this._data, this._offset + offset, length);
    }
    /**
     * Try to get a buffer from the bitstring without allocations
     * @param offset offset in bits
     * @param length length in bits
     * @returns buffer if the bitstring is aligned to bytes, null otherwise
     */
    subbuffer(offset, length) {
      if (offset > this._length) {
        throw new Error(`Offset ${offset} is out of bounds`);
      }
      if (offset < 0) {
        throw new Error(`Offset ${offset} is out of bounds`);
      }
      if (offset + length > this._length) {
        throw new Error(`Offset + Lenght = ${offset + length} is out of bounds`);
      }
      if (length % 8 !== 0) {
        return null;
      }
      if ((this._offset + offset) % 8 !== 0) {
        return null;
      }
      let start = this._offset + offset >> 3;
      let end2 = start + (length >> 3);
      return this._data.subarray(start, end2);
    }
    /**
     * Checks for equality
     * @param b other bitstring
     * @returns true if the bitstrings are equal, false otherwise
     */
    equals(b2) {
      if (this._length !== b2._length) {
        return false;
      }
      for (let i = 0; i < this._length; i++) {
        if (this.at(i) !== b2.at(i)) {
          return false;
        }
      }
      return true;
    }
    /**
     * Format to canonical string
     * @returns formatted bits as a string
     */
    toString() {
      const padded = (0, paddedBits_1.bitsToPaddedBuffer)(this);
      if (this._length % 4 === 0) {
        const s2 = padded.subarray(0, Math.ceil(this._length / 8)).toString("hex").toUpperCase();
        if (this._length % 8 === 0) {
          return s2;
        } else {
          return s2.substring(0, s2.length - 1);
        }
      } else {
        const hex = padded.toString("hex").toUpperCase();
        if (this._length % 8 <= 4) {
          return hex.substring(0, hex.length - 1) + "_";
        } else {
          return hex + "_";
        }
      }
    }
  };
  BitString.BitString = BitString$1;
  _a2 = symbol_inspect_1.default;
  BitString$1.EMPTY = new BitString$1(Buffer.alloc(0), 0, 0);
  return BitString;
}
var hasRequiredBitBuilder;
function requireBitBuilder() {
  if (hasRequiredBitBuilder) return BitBuilder;
  hasRequiredBitBuilder = 1;
  Object.defineProperty(BitBuilder, "__esModule", { value: true });
  BitBuilder.BitBuilder = void 0;
  const Address_1 = requireAddress();
  const ExternalAddress_1 = requireExternalAddress();
  const BitString_1 = requireBitString();
  let BitBuilder$1 = class BitBuilder {
    constructor(size = 1023) {
      this._buffer = Buffer.alloc(Math.ceil(size / 8));
      this._length = 0;
    }
    /**
     * Current number of bits written
     */
    get length() {
      return this._length;
    }
    /**
     * Write a single bit
     * @param value bit to write, true or positive number for 1, false or zero or negative for 0
     */
    writeBit(value) {
      let n = this._length;
      if (n > this._buffer.length * 8) {
        throw new Error("BitBuilder overflow");
      }
      if (typeof value === "boolean" && value === true || typeof value === "number" && value > 0) {
        this._buffer[n / 8 | 0] |= 1 << 7 - n % 8;
      }
      this._length++;
    }
    /**
     * Copy bits from BitString
     * @param src source bits
     */
    writeBits(src2) {
      for (let i = 0; i < src2.length; i++) {
        this.writeBit(src2.at(i));
      }
    }
    /**
     * Write bits from buffer
     * @param src source buffer
     */
    writeBuffer(src2) {
      if (this._length % 8 === 0) {
        if (this._length + src2.length * 8 > this._buffer.length * 8) {
          throw new Error("BitBuilder overflow");
        }
        src2.copy(this._buffer, this._length / 8);
        this._length += src2.length * 8;
      } else {
        for (let i = 0; i < src2.length; i++) {
          this.writeUint(src2[i], 8);
        }
      }
    }
    /**
     * Write uint value
     * @param value value as bigint or number
     * @param bits number of bits to write
     */
    writeUint(value, bits) {
      if (bits < 0 || !Number.isSafeInteger(bits)) {
        throw Error(`invalid bit length. Got ${bits}`);
      }
      const v2 = BigInt(value);
      if (bits === 0) {
        if (v2 !== 0n) {
          throw Error(`value is not zero for ${bits} bits. Got ${value}`);
        } else {
          return;
        }
      }
      const vBits = 1n << BigInt(bits);
      if (v2 < 0 || v2 >= vBits) {
        throw Error(`bitLength is too small for a value ${value}. Got ${bits}`);
      }
      if (this._length + bits > this._buffer.length * 8) {
        throw new Error("BitBuilder overflow");
      }
      const tillByte = 8 - this._length % 8;
      if (tillByte > 0) {
        const bidx = Math.floor(this._length / 8);
        if (bits < tillByte) {
          const wb = Number(v2);
          this._buffer[bidx] |= wb << tillByte - bits;
          this._length += bits;
        } else {
          const wb = Number(v2 >> BigInt(bits - tillByte));
          this._buffer[bidx] |= wb;
          this._length += tillByte;
        }
      }
      bits -= tillByte;
      while (bits > 0) {
        if (bits >= 8) {
          this._buffer[this._length / 8] = Number(v2 >> BigInt(bits - 8) & 0xffn);
          this._length += 8;
          bits -= 8;
        } else {
          this._buffer[this._length / 8] = Number(v2 << BigInt(8 - bits) & 0xffn);
          this._length += bits;
          bits = 0;
        }
      }
    }
    /**
     * Write int value
     * @param value value as bigint or number
     * @param bits number of bits to write
     */
    writeInt(value, bits) {
      let v2 = BigInt(value);
      if (bits < 0 || !Number.isSafeInteger(bits)) {
        throw Error(`invalid bit length. Got ${bits}`);
      }
      if (bits === 0) {
        if (v2 !== 0n) {
          throw Error(`value is not zero for ${bits} bits. Got ${value}`);
        } else {
          return;
        }
      }
      if (bits === 1) {
        if (v2 !== -1n && v2 !== 0n) {
          throw Error(`value is not zero or -1 for ${bits} bits. Got ${value}`);
        } else {
          this.writeBit(value === -1n);
          return;
        }
      }
      let vBits = 1n << BigInt(bits) - 1n;
      if (v2 < -vBits || v2 >= vBits) {
        throw Error(`value is out of range for ${bits} bits. Got ${value}`);
      }
      if (v2 < 0) {
        this.writeBit(true);
        v2 = vBits + v2;
      } else {
        this.writeBit(false);
      }
      this.writeUint(v2, bits - 1);
    }
    /**
     * Wrtie var uint value, used for serializing coins
     * @param value value to write as bigint or number
     * @param bits header bits to write size
     */
    writeVarUint(value, bits) {
      let v2 = BigInt(value);
      if (bits < 0 || !Number.isSafeInteger(bits)) {
        throw Error(`invalid bit length. Got ${bits}`);
      }
      if (v2 < 0) {
        throw Error(`value is negative. Got ${value}`);
      }
      if (v2 === 0n) {
        this.writeUint(0, bits);
        return;
      }
      const sizeBytes = Math.ceil(v2.toString(2).length / 8);
      const sizeBits = sizeBytes * 8;
      this.writeUint(sizeBytes, bits);
      this.writeUint(v2, sizeBits);
    }
    /**
     * Wrtie var int value, used for serializing coins
     * @param value value to write as bigint or number
     * @param bits header bits to write size
     */
    writeVarInt(value, bits) {
      let v2 = BigInt(value);
      if (bits < 0 || !Number.isSafeInteger(bits)) {
        throw Error(`invalid bit length. Got ${bits}`);
      }
      if (v2 === 0n) {
        this.writeUint(0, bits);
        return;
      }
      let v22 = v2 > 0 ? v2 : -v2;
      const sizeBytes = Math.ceil((v22.toString(2).length + 1) / 8);
      const sizeBits = sizeBytes * 8;
      this.writeUint(sizeBytes, bits);
      this.writeInt(v2, sizeBits);
    }
    /**
     * Write coins in var uint format
     * @param amount amount to write
     */
    writeCoins(amount) {
      this.writeVarUint(amount, 4);
    }
    /**
     * Write address
     * @param address write address or address external
     */
    writeAddress(address) {
      if (address === null || address === void 0) {
        this.writeUint(0, 2);
        return;
      }
      if (Address_1.Address.isAddress(address)) {
        this.writeUint(2, 2);
        this.writeUint(0, 1);
        this.writeInt(address.workChain, 8);
        this.writeBuffer(address.hash);
        return;
      }
      if (ExternalAddress_1.ExternalAddress.isAddress(address)) {
        this.writeUint(1, 2);
        this.writeUint(address.bits, 9);
        this.writeUint(address.value, address.bits);
        return;
      }
      throw Error(`Invalid address. Got ${address}`);
    }
    /**
     * Build BitString
     * @returns result bit string
     */
    build() {
      return new BitString_1.BitString(this._buffer, 0, this._length);
    }
    /**
     * Build into Buffer
     * @returns result buffer
     */
    buffer() {
      if (this._length % 8 !== 0) {
        throw new Error("BitBuilder buffer is not byte aligned");
      }
      return this._buffer.subarray(0, this._length / 8);
    }
  };
  BitBuilder.BitBuilder = BitBuilder$1;
  return BitBuilder;
}
var Cell = {};
var CellType = {};
var hasRequiredCellType;
function requireCellType() {
  if (hasRequiredCellType) return CellType;
  hasRequiredCellType = 1;
  Object.defineProperty(CellType, "__esModule", { value: true });
  CellType.CellType = void 0;
  var CellType$1;
  (function(CellType2) {
    CellType2[CellType2["Ordinary"] = -1] = "Ordinary";
    CellType2[CellType2["PrunedBranch"] = 1] = "PrunedBranch";
    CellType2[CellType2["Library"] = 2] = "Library";
    CellType2[CellType2["MerkleProof"] = 3] = "MerkleProof";
    CellType2[CellType2["MerkleUpdate"] = 4] = "MerkleUpdate";
  })(CellType$1 || (CellType.CellType = CellType$1 = {}));
  return CellType;
}
var Slice = {};
var Dictionary = {};
var generateMerkleProof = {};
var readUnaryLength = {};
var hasRequiredReadUnaryLength;
function requireReadUnaryLength() {
  if (hasRequiredReadUnaryLength) return readUnaryLength;
  hasRequiredReadUnaryLength = 1;
  Object.defineProperty(readUnaryLength, "__esModule", { value: true });
  readUnaryLength.readUnaryLength = void 0;
  function readUnaryLength$1(slice) {
    let res = 0;
    while (slice.loadBit()) {
      res++;
    }
    return res;
  }
  readUnaryLength.readUnaryLength = readUnaryLength$1;
  return readUnaryLength;
}
var exoticMerkleProof = {};
var BitReader = {};
var hasRequiredBitReader;
function requireBitReader() {
  if (hasRequiredBitReader) return BitReader;
  hasRequiredBitReader = 1;
  Object.defineProperty(BitReader, "__esModule", { value: true });
  BitReader.BitReader = void 0;
  const Address_1 = requireAddress();
  const ExternalAddress_1 = requireExternalAddress();
  let BitReader$1 = class BitReader2 {
    constructor(bits, offset = 0) {
      this._checkpoints = [];
      this._bits = bits;
      this._offset = offset;
    }
    /**
     * Offset in source bit string
     */
    get offset() {
      return this._offset;
    }
    /**
     * Number of bits remaining
     */
    get remaining() {
      return this._bits.length - this._offset;
    }
    /**
     * Skip bits
     * @param bits number of bits to skip
     */
    skip(bits) {
      if (bits < 0 || this._offset + bits > this._bits.length) {
        throw new Error(`Index ${this._offset + bits} is out of bounds`);
      }
      this._offset += bits;
    }
    /**
     * Reset to the beginning or latest checkpoint
     */
    reset() {
      if (this._checkpoints.length > 0) {
        this._offset = this._checkpoints.pop();
      } else {
        this._offset = 0;
      }
    }
    /**
     * Save checkpoint
     */
    save() {
      this._checkpoints.push(this._offset);
    }
    /**
     * Load a single bit
     * @returns true if the bit is set, false otherwise
     */
    loadBit() {
      let r = this._bits.at(this._offset);
      this._offset++;
      return r;
    }
    /**
     * Preload bit
     * @returns true if the bit is set, false otherwise
     */
    preloadBit() {
      return this._bits.at(this._offset);
    }
    /**
     * Load bit string
     * @param bits number of bits to read
     * @returns new bitstring
     */
    loadBits(bits) {
      let r = this._bits.substring(this._offset, bits);
      this._offset += bits;
      return r;
    }
    /**
     * Preload bit string
     * @param bits number of bits to read
     * @returns new bitstring
     */
    preloadBits(bits) {
      return this._bits.substring(this._offset, bits);
    }
    /**
     * Load buffer
     * @param bytes number of bytes
     * @returns new buffer
     */
    loadBuffer(bytes) {
      let buf2 = this._preloadBuffer(bytes, this._offset);
      this._offset += bytes * 8;
      return buf2;
    }
    /**
     * Preload buffer
     * @param bytes number of bytes
     * @returns new buffer
     */
    preloadBuffer(bytes) {
      return this._preloadBuffer(bytes, this._offset);
    }
    /**
     * Load uint value
     * @param bits uint bits
     * @returns read value as number
     */
    loadUint(bits) {
      return this._toSafeInteger(this.loadUintBig(bits), "loadUintBig");
    }
    /**
     * Load uint value as bigint
     * @param bits uint bits
     * @returns read value as bigint
     */
    loadUintBig(bits) {
      let loaded = this.preloadUintBig(bits);
      this._offset += bits;
      return loaded;
    }
    /**
     * Preload uint value
     * @param bits uint bits
     * @returns read value as number
     */
    preloadUint(bits) {
      return this._toSafeInteger(this._preloadUint(bits, this._offset), "preloadUintBig");
    }
    /**
     * Preload uint value as bigint
     * @param bits uint bits
     * @returns read value as bigint
     */
    preloadUintBig(bits) {
      return this._preloadUint(bits, this._offset);
    }
    /**
     * Load int value
     * @param bits int bits
     * @returns read value as bigint
     */
    loadInt(bits) {
      let res = this._preloadInt(bits, this._offset);
      this._offset += bits;
      return this._toSafeInteger(res, "loadUintBig");
    }
    /**
     * Load int value as bigint
     * @param bits int bits
     * @returns read value as bigint
     */
    loadIntBig(bits) {
      let res = this._preloadInt(bits, this._offset);
      this._offset += bits;
      return res;
    }
    /**
     * Preload int value
     * @param bits int bits
     * @returns read value as bigint
     */
    preloadInt(bits) {
      return this._toSafeInteger(this._preloadInt(bits, this._offset), "preloadIntBig");
    }
    /**
     * Preload int value
     * @param bits int bits
     * @returns read value as bigint
     */
    preloadIntBig(bits) {
      return this._preloadInt(bits, this._offset);
    }
    /**
     * Load varuint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    loadVarUint(bits) {
      let size = Number(this.loadUint(bits));
      return this._toSafeInteger(this.loadUintBig(size * 8), "loadVarUintBig");
    }
    /**
     * Load varuint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    loadVarUintBig(bits) {
      let size = Number(this.loadUint(bits));
      return this.loadUintBig(size * 8);
    }
    /**
     * Preload varuint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    preloadVarUint(bits) {
      let size = Number(this._preloadUint(bits, this._offset));
      return this._toSafeInteger(this._preloadUint(size * 8, this._offset + bits), "preloadVarUintBig");
    }
    /**
     * Preload varuint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    preloadVarUintBig(bits) {
      let size = Number(this._preloadUint(bits, this._offset));
      return this._preloadUint(size * 8, this._offset + bits);
    }
    /**
     * Load varint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    loadVarInt(bits) {
      let size = Number(this.loadUint(bits));
      return this._toSafeInteger(this.loadIntBig(size * 8), "loadVarIntBig");
    }
    /**
     * Load varint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    loadVarIntBig(bits) {
      let size = Number(this.loadUint(bits));
      return this.loadIntBig(size * 8);
    }
    /**
     * Preload varint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    preloadVarInt(bits) {
      let size = Number(this._preloadUint(bits, this._offset));
      return this._toSafeInteger(this._preloadInt(size * 8, this._offset + bits), "preloadVarIntBig");
    }
    /**
     * Preload varint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    preloadVarIntBig(bits) {
      let size = Number(this._preloadUint(bits, this._offset));
      return this._preloadInt(size * 8, this._offset + bits);
    }
    /**
     * Load coins value
     * @returns read value as bigint
     */
    loadCoins() {
      return this.loadVarUintBig(4);
    }
    /**
     * Preload coins value
     * @returns read value as bigint
     */
    preloadCoins() {
      return this.preloadVarUintBig(4);
    }
    /**
     * Load Address
     * @returns Address
     */
    loadAddress() {
      let type = Number(this._preloadUint(2, this._offset));
      if (type === 2) {
        return this._loadInternalAddress();
      } else {
        throw new Error("Invalid address: " + type);
      }
    }
    /**
     * Load internal address
     * @returns Address or null
     */
    loadMaybeAddress() {
      let type = Number(this._preloadUint(2, this._offset));
      if (type === 0) {
        this._offset += 2;
        return null;
      } else if (type === 2) {
        return this._loadInternalAddress();
      } else {
        throw new Error("Invalid address");
      }
    }
    /**
     * Load external address
     * @returns ExternalAddress
     */
    loadExternalAddress() {
      let type = Number(this._preloadUint(2, this._offset));
      if (type === 1) {
        return this._loadExternalAddress();
      } else {
        throw new Error("Invalid address");
      }
    }
    /**
     * Load external address
     * @returns ExternalAddress or null
     */
    loadMaybeExternalAddress() {
      let type = Number(this._preloadUint(2, this._offset));
      if (type === 0) {
        this._offset += 2;
        return null;
      } else if (type === 1) {
        return this._loadExternalAddress();
      } else {
        throw new Error("Invalid address");
      }
    }
    /**
     * Read address of any type
     * @returns Address or ExternalAddress or null
     */
    loadAddressAny() {
      let type = Number(this._preloadUint(2, this._offset));
      if (type === 0) {
        this._offset += 2;
        return null;
      } else if (type === 2) {
        return this._loadInternalAddress();
      } else if (type === 1) {
        return this._loadExternalAddress();
      } else if (type === 3) {
        throw Error("Unsupported");
      } else {
        throw Error("Unreachable");
      }
    }
    /**
     * Load bit string that was padded to make it byte alligned. Used in BOC serialization
     * @param bytes number of bytes to read
     */
    loadPaddedBits(bits) {
      if (bits % 8 !== 0) {
        throw new Error("Invalid number of bits");
      }
      let length = bits;
      while (true) {
        if (this._bits.at(this._offset + length - 1)) {
          length--;
          break;
        } else {
          length--;
        }
      }
      let r = this._bits.substring(this._offset, length);
      this._offset += bits;
      return r;
    }
    /**
     * Clone BitReader
     */
    clone() {
      return new BitReader2(this._bits, this._offset);
    }
    /**
     * Preload int from specific offset
     * @param bits bits to preload
     * @param offset offset to start from
     * @returns read value as bigint
     */
    _preloadInt(bits, offset) {
      if (bits == 0) {
        return 0n;
      }
      let sign = this._bits.at(offset);
      let res = 0n;
      for (let i = 0; i < bits - 1; i++) {
        if (this._bits.at(offset + 1 + i)) {
          res += 1n << BigInt(bits - i - 1 - 1);
        }
      }
      if (sign) {
        res = res - (1n << BigInt(bits - 1));
      }
      return res;
    }
    /**
     * Preload uint from specific offset
     * @param bits bits to preload
     * @param offset offset to start from
     * @returns read value as bigint
     */
    _preloadUint(bits, offset) {
      if (bits == 0) {
        return 0n;
      }
      let res = 0n;
      for (let i = 0; i < bits; i++) {
        if (this._bits.at(offset + i)) {
          res += 1n << BigInt(bits - i - 1);
        }
      }
      return res;
    }
    _preloadBuffer(bytes, offset) {
      let fastBuffer = this._bits.subbuffer(offset, bytes * 8);
      if (fastBuffer) {
        return fastBuffer;
      }
      let buf2 = Buffer.alloc(bytes);
      for (let i = 0; i < bytes; i++) {
        buf2[i] = Number(this._preloadUint(8, offset + i * 8));
      }
      return buf2;
    }
    _loadInternalAddress() {
      let type = Number(this._preloadUint(2, this._offset));
      if (type !== 2) {
        throw Error("Invalid address");
      }
      let rewrite_pfx = void 0;
      let rewrite_depth = void 0;
      if (this._preloadUint(1, this._offset + 2) !== 0n) {
        rewrite_depth = Number(this._preloadUint(5, this._offset + 3));
        rewrite_pfx = this._preloadUint(rewrite_depth, this._offset + 8);
        this._offset += 5 + rewrite_depth;
      }
      let wc = Number(this._preloadInt(8, this._offset + 3));
      let hash = this._preloadBuffer(32, this._offset + 11);
      if (rewrite_depth !== void 0 && rewrite_pfx !== void 0) {
        let pfx = Number(rewrite_pfx);
        let byteIndex = 0;
        let bitIndex = 0;
        let bitsRemaining = rewrite_depth;
        while (bitsRemaining > 0) {
          let bitsInThisByte = Math.min(8 - bitIndex, bitsRemaining);
          let mask = (1 << bitsInThisByte) - 1 << 8 - bitIndex - bitsInThisByte;
          let bits = (pfx >> bitsRemaining - bitsInThisByte & (1 << bitsInThisByte) - 1) << 8 - bitIndex - bitsInThisByte;
          hash[byteIndex] = hash[byteIndex] & ~mask | bits;
          bitsRemaining -= bitsInThisByte;
          bitIndex += bitsInThisByte;
          if (bitIndex === 8) {
            byteIndex++;
            bitIndex = 0;
          }
        }
      }
      this._offset += 267;
      return new Address_1.Address(wc, hash);
    }
    _loadExternalAddress() {
      let type = Number(this._preloadUint(2, this._offset));
      if (type !== 1) {
        throw Error("Invalid address");
      }
      let bits = Number(this._preloadUint(9, this._offset + 2));
      let value = this._preloadUint(bits, this._offset + 11);
      this._offset += 11 + bits;
      return new ExternalAddress_1.ExternalAddress(value, bits);
    }
    _toSafeInteger(src2, alt) {
      if (BigInt(Number.MAX_SAFE_INTEGER) < src2 || src2 < BigInt(Number.MIN_SAFE_INTEGER)) {
        throw new TypeError(`${src2} is out of safe integer range. Use ${alt} instead`);
      }
      return Number(src2);
    }
  };
  BitReader.BitReader = BitReader$1;
  return BitReader;
}
var hasRequiredExoticMerkleProof;
function requireExoticMerkleProof() {
  if (hasRequiredExoticMerkleProof) return exoticMerkleProof;
  hasRequiredExoticMerkleProof = 1;
  Object.defineProperty(exoticMerkleProof, "__esModule", { value: true });
  exoticMerkleProof.convertToMerkleProof = exoticMerkleProof.exoticMerkleProof = void 0;
  const BitReader_1 = requireBitReader();
  const Builder_12 = requireBuilder$1();
  function exoticMerkleProof$1(bits, refs) {
    const reader2 = new BitReader_1.BitReader(bits);
    const size = 8 + 256 + 16;
    if (bits.length !== size) {
      throw new Error(`Merkle Proof cell must have exactly (8 + 256 + 16) bits, got "${bits.length}"`);
    }
    if (refs.length !== 1) {
      throw new Error(`Merkle Proof cell must have exactly 1 ref, got "${refs.length}"`);
    }
    let type = reader2.loadUint(8);
    if (type !== 3) {
      throw new Error(`Merkle Proof cell must have type 3, got "${type}"`);
    }
    const proofHash = reader2.loadBuffer(32);
    const proofDepth = reader2.loadUint(16);
    const refHash = refs[0].hash(0);
    const refDepth = refs[0].depth(0);
    if (proofDepth !== refDepth) {
      throw new Error(`Merkle Proof cell ref depth must be exactly "${proofDepth}", got "${refDepth}"`);
    }
    if (!proofHash.equals(refHash)) {
      throw new Error(`Merkle Proof cell ref hash must be exactly "${proofHash.toString("hex")}", got "${refHash.toString("hex")}"`);
    }
    return {
      proofDepth,
      proofHash
    };
  }
  exoticMerkleProof.exoticMerkleProof = exoticMerkleProof$1;
  function convertToMerkleProof(c) {
    return (0, Builder_12.beginCell)().storeUint(3, 8).storeBuffer(c.hash(0)).storeUint(c.depth(0), 16).storeRef(c).endCell({ exotic: true });
  }
  exoticMerkleProof.convertToMerkleProof = convertToMerkleProof;
  return exoticMerkleProof;
}
var hasRequiredGenerateMerkleProof;
function requireGenerateMerkleProof() {
  if (hasRequiredGenerateMerkleProof) return generateMerkleProof;
  hasRequiredGenerateMerkleProof = 1;
  Object.defineProperty(generateMerkleProof, "__esModule", { value: true });
  generateMerkleProof.generateMerkleProof = generateMerkleProof.generateMerkleProofDirect = void 0;
  const Builder_12 = requireBuilder$1();
  const readUnaryLength_1 = requireReadUnaryLength();
  const exoticMerkleProof_1 = requireExoticMerkleProof();
  function convertToPrunedBranch(c) {
    return (0, Builder_12.beginCell)().storeUint(1, 8).storeUint(1, 8).storeBuffer(c.hash(0)).storeUint(c.depth(0), 16).endCell({ exotic: true });
  }
  function doGenerateMerkleProof(prefix, slice, n, keys) {
    const originalCell = slice.asCell();
    if (keys.length == 0) {
      return convertToPrunedBranch(originalCell);
    }
    let lb0 = slice.loadBit() ? 1 : 0;
    let prefixLength = 0;
    let pp = prefix;
    if (lb0 === 0) {
      prefixLength = (0, readUnaryLength_1.readUnaryLength)(slice);
      for (let i = 0; i < prefixLength; i++) {
        pp += slice.loadBit() ? "1" : "0";
      }
    } else {
      let lb1 = slice.loadBit() ? 1 : 0;
      if (lb1 === 0) {
        prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));
        for (let i = 0; i < prefixLength; i++) {
          pp += slice.loadBit() ? "1" : "0";
        }
      } else {
        let bit = slice.loadBit() ? "1" : "0";
        prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));
        for (let i = 0; i < prefixLength; i++) {
          pp += bit;
        }
      }
    }
    if (n - prefixLength === 0) {
      return originalCell;
    } else {
      let sl = originalCell.beginParse();
      let left = sl.loadRef();
      let right = sl.loadRef();
      if (!left.isExotic) {
        const leftKeys = keys.filter((key2) => {
          return pp + "0" === key2.slice(0, pp.length + 1);
        });
        left = doGenerateMerkleProof(pp + "0", left.beginParse(), n - prefixLength - 1, leftKeys);
      }
      if (!right.isExotic) {
        const rightKeys = keys.filter((key2) => {
          return pp + "1" === key2.slice(0, pp.length + 1);
        });
        right = doGenerateMerkleProof(pp + "1", right.beginParse(), n - prefixLength - 1, rightKeys);
      }
      return (0, Builder_12.beginCell)().storeSlice(sl).storeRef(left).storeRef(right).endCell();
    }
  }
  function generateMerkleProofDirect(dict, keys, keyObject) {
    keys.forEach((key2) => {
      if (!dict.has(key2)) {
        throw new Error(`Trying to generate merkle proof for a missing key "${key2}"`);
      }
    });
    const s2 = (0, Builder_12.beginCell)().storeDictDirect(dict).asSlice();
    return doGenerateMerkleProof("", s2, keyObject.bits, keys.map((key2) => keyObject.serialize(key2).toString(2).padStart(keyObject.bits, "0")));
  }
  generateMerkleProof.generateMerkleProofDirect = generateMerkleProofDirect;
  function generateMerkleProof$1(dict, keys, keyObject) {
    return (0, exoticMerkleProof_1.convertToMerkleProof)(generateMerkleProofDirect(dict, keys, keyObject));
  }
  generateMerkleProof.generateMerkleProof = generateMerkleProof$1;
  return generateMerkleProof;
}
var generateMerkleUpdate = {};
var hasRequiredGenerateMerkleUpdate;
function requireGenerateMerkleUpdate() {
  if (hasRequiredGenerateMerkleUpdate) return generateMerkleUpdate;
  hasRequiredGenerateMerkleUpdate = 1;
  Object.defineProperty(generateMerkleUpdate, "__esModule", { value: true });
  generateMerkleUpdate.generateMerkleUpdate = void 0;
  const Builder_12 = requireBuilder$1();
  const generateMerkleProof_1 = requireGenerateMerkleProof();
  function convertToMerkleUpdate(c1, c2) {
    return (0, Builder_12.beginCell)().storeUint(4, 8).storeBuffer(c1.hash(0)).storeBuffer(c2.hash(0)).storeUint(c1.depth(0), 16).storeUint(c2.depth(0), 16).storeRef(c1).storeRef(c2).endCell({ exotic: true });
  }
  function generateMerkleUpdate$1(dict, key2, keyObject, newValue) {
    const oldProof = (0, generateMerkleProof_1.generateMerkleProof)(dict, [key2], keyObject).refs[0];
    dict.set(key2, newValue);
    const newProof = (0, generateMerkleProof_1.generateMerkleProof)(dict, [key2], keyObject).refs[0];
    return convertToMerkleUpdate(oldProof, newProof);
  }
  generateMerkleUpdate.generateMerkleUpdate = generateMerkleUpdate$1;
  return generateMerkleUpdate;
}
var parseDict = {};
var hasRequiredParseDict;
function requireParseDict() {
  if (hasRequiredParseDict) return parseDict;
  hasRequiredParseDict = 1;
  Object.defineProperty(parseDict, "__esModule", { value: true });
  parseDict.parseDict = void 0;
  function readUnaryLength2(slice) {
    let res = 0;
    while (slice.loadBit()) {
      res++;
    }
    return res;
  }
  function doParse(prefix, slice, n, res, extractor) {
    let lb0 = slice.loadBit() ? 1 : 0;
    let prefixLength = 0;
    let pp = prefix;
    if (lb0 === 0) {
      prefixLength = readUnaryLength2(slice);
      for (let i = 0; i < prefixLength; i++) {
        pp += slice.loadBit() ? "1" : "0";
      }
    } else {
      let lb1 = slice.loadBit() ? 1 : 0;
      if (lb1 === 0) {
        prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));
        for (let i = 0; i < prefixLength; i++) {
          pp += slice.loadBit() ? "1" : "0";
        }
      } else {
        let bit = slice.loadBit() ? "1" : "0";
        prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));
        for (let i = 0; i < prefixLength; i++) {
          pp += bit;
        }
      }
    }
    if (n - prefixLength === 0) {
      res.set(BigInt("0b" + pp), extractor(slice));
    } else {
      let left = slice.loadRef();
      let right = slice.loadRef();
      if (!left.isExotic) {
        doParse(pp + "0", left.beginParse(), n - prefixLength - 1, res, extractor);
      }
      if (!right.isExotic) {
        doParse(pp + "1", right.beginParse(), n - prefixLength - 1, res, extractor);
      }
    }
  }
  function parseDict$1(sc, keySize, extractor) {
    let res = /* @__PURE__ */ new Map();
    if (sc) {
      doParse("", sc, keySize, res, extractor);
    }
    return res;
  }
  parseDict.parseDict = parseDict$1;
  return parseDict;
}
var serializeDict = {};
var findCommonPrefix = {};
var hasRequiredFindCommonPrefix;
function requireFindCommonPrefix() {
  if (hasRequiredFindCommonPrefix) return findCommonPrefix;
  hasRequiredFindCommonPrefix = 1;
  Object.defineProperty(findCommonPrefix, "__esModule", { value: true });
  findCommonPrefix.findCommonPrefix = void 0;
  function findCommonPrefix$1(src2, startPos = 0) {
    if (src2.length === 0) {
      return "";
    }
    let r = src2[0].slice(startPos);
    for (let i = 1; i < src2.length; i++) {
      const s2 = src2[i];
      while (s2.indexOf(r, startPos) !== startPos) {
        r = r.substring(0, r.length - 1);
        if (r === "") {
          return r;
        }
      }
    }
    return r;
  }
  findCommonPrefix.findCommonPrefix = findCommonPrefix$1;
  return findCommonPrefix;
}
var hasRequiredSerializeDict;
function requireSerializeDict() {
  if (hasRequiredSerializeDict) return serializeDict;
  hasRequiredSerializeDict = 1;
  Object.defineProperty(serializeDict, "__esModule", { value: true });
  serializeDict.serializeDict = serializeDict.detectLabelType = serializeDict.writeLabelSame = serializeDict.writeLabelLong = serializeDict.writeLabelShort = serializeDict.buildTree = void 0;
  const Builder_12 = requireBuilder$1();
  const findCommonPrefix_1 = requireFindCommonPrefix();
  function pad(src2, size) {
    while (src2.length < size) {
      src2 = "0" + src2;
    }
    return src2;
  }
  function forkMap(src2, prefixLen) {
    if (src2.size === 0) {
      throw Error("Internal inconsistency");
    }
    let left = /* @__PURE__ */ new Map();
    let right = /* @__PURE__ */ new Map();
    for (let [k2, d] of src2.entries()) {
      if (k2[prefixLen] === "0") {
        left.set(k2, d);
      } else {
        right.set(k2, d);
      }
    }
    if (left.size === 0) {
      throw Error("Internal inconsistency. Left emtpy.");
    }
    if (right.size === 0) {
      throw Error("Internal inconsistency. Right emtpy.");
    }
    return { left, right };
  }
  function buildNode(src2, prefixLen) {
    if (src2.size === 0) {
      throw Error("Internal inconsistency");
    }
    if (src2.size === 1) {
      return { type: "leaf", value: Array.from(src2.values())[0] };
    }
    let { left, right } = forkMap(src2, prefixLen);
    return {
      type: "fork",
      left: buildEdge(left, prefixLen + 1),
      right: buildEdge(right, prefixLen + 1)
    };
  }
  function buildEdge(src2, prefixLen = 0) {
    if (src2.size === 0) {
      throw Error("Internal inconsistency");
    }
    const label = (0, findCommonPrefix_1.findCommonPrefix)(Array.from(src2.keys()), prefixLen);
    return { label, node: buildNode(src2, label.length + prefixLen) };
  }
  function buildTree(src2, keyLength) {
    let converted = /* @__PURE__ */ new Map();
    for (let k2 of Array.from(src2.keys())) {
      const padded = pad(k2.toString(2), keyLength);
      converted.set(padded, src2.get(k2));
    }
    return buildEdge(converted);
  }
  serializeDict.buildTree = buildTree;
  function writeLabelShort(src2, to2) {
    to2.storeBit(0);
    for (let i = 0; i < src2.length; i++) {
      to2.storeBit(1);
    }
    to2.storeBit(0);
    if (src2.length > 0) {
      to2.storeUint(BigInt("0b" + src2), src2.length);
    }
    return to2;
  }
  serializeDict.writeLabelShort = writeLabelShort;
  function labelShortLength(src2) {
    return 1 + src2.length + 1 + src2.length;
  }
  function writeLabelLong(src2, keyLength, to2) {
    to2.storeBit(1);
    to2.storeBit(0);
    let length = Math.ceil(Math.log2(keyLength + 1));
    to2.storeUint(src2.length, length);
    if (src2.length > 0) {
      to2.storeUint(BigInt("0b" + src2), src2.length);
    }
    return to2;
  }
  serializeDict.writeLabelLong = writeLabelLong;
  function labelLongLength(src2, keyLength) {
    return 1 + 1 + Math.ceil(Math.log2(keyLength + 1)) + src2.length;
  }
  function writeLabelSame(value, length, keyLength, to2) {
    to2.storeBit(1);
    to2.storeBit(1);
    to2.storeBit(value);
    let lenLen = Math.ceil(Math.log2(keyLength + 1));
    to2.storeUint(length, lenLen);
  }
  serializeDict.writeLabelSame = writeLabelSame;
  function labelSameLength(keyLength) {
    return 1 + 1 + 1 + Math.ceil(Math.log2(keyLength + 1));
  }
  function isSame(src2) {
    if (src2.length === 0 || src2.length === 1) {
      return true;
    }
    for (let i = 1; i < src2.length; i++) {
      if (src2[i] !== src2[0]) {
        return false;
      }
    }
    return true;
  }
  function detectLabelType(src2, keyLength) {
    let kind = "short";
    let kindLength = labelShortLength(src2);
    let longLength = labelLongLength(src2, keyLength);
    if (longLength < kindLength) {
      kindLength = longLength;
      kind = "long";
    }
    if (isSame(src2)) {
      let sameLength = labelSameLength(keyLength);
      if (sameLength < kindLength) {
        kindLength = sameLength;
        kind = "same";
      }
    }
    return kind;
  }
  serializeDict.detectLabelType = detectLabelType;
  function writeLabel(src2, keyLength, to2) {
    let type = detectLabelType(src2, keyLength);
    if (type === "short") {
      writeLabelShort(src2, to2);
    } else if (type === "long") {
      writeLabelLong(src2, keyLength, to2);
    } else if (type === "same") {
      writeLabelSame(src2[0] === "1", src2.length, keyLength, to2);
    }
  }
  function writeNode(src2, keyLength, serializer, to2) {
    if (src2.type === "leaf") {
      serializer(src2.value, to2);
    }
    if (src2.type === "fork") {
      const leftCell = (0, Builder_12.beginCell)();
      const rightCell = (0, Builder_12.beginCell)();
      writeEdge(src2.left, keyLength - 1, serializer, leftCell);
      writeEdge(src2.right, keyLength - 1, serializer, rightCell);
      to2.storeRef(leftCell);
      to2.storeRef(rightCell);
    }
  }
  function writeEdge(src2, keyLength, serializer, to2) {
    writeLabel(src2.label, keyLength, to2);
    writeNode(src2.node, keyLength - src2.label.length, serializer, to2);
  }
  function serializeDict$1(src2, keyLength, serializer, to2) {
    const tree = buildTree(src2, keyLength);
    writeEdge(tree, keyLength, serializer, to2);
  }
  serializeDict.serializeDict = serializeDict$1;
  return serializeDict;
}
var internalKeySerializer = {};
var hasRequiredInternalKeySerializer;
function requireInternalKeySerializer() {
  if (hasRequiredInternalKeySerializer) return internalKeySerializer;
  hasRequiredInternalKeySerializer = 1;
  Object.defineProperty(internalKeySerializer, "__esModule", { value: true });
  internalKeySerializer.deserializeInternalKey = internalKeySerializer.serializeInternalKey = void 0;
  const Address_1 = requireAddress();
  const BitString_1 = requireBitString();
  const paddedBits_1 = requirePaddedBits();
  function serializeInternalKey(value) {
    if (typeof value === "number") {
      if (!Number.isSafeInteger(value)) {
        throw Error("Invalid key type: not a safe integer: " + value);
      }
      return "n:" + value.toString(10);
    } else if (typeof value === "bigint") {
      return "b:" + value.toString(10);
    } else if (Address_1.Address.isAddress(value)) {
      return "a:" + value.toString();
    } else if (Buffer.isBuffer(value)) {
      return "f:" + value.toString("hex");
    } else if (BitString_1.BitString.isBitString(value)) {
      return "B:" + value.toString();
    } else {
      throw Error("Invalid key type");
    }
  }
  internalKeySerializer.serializeInternalKey = serializeInternalKey;
  function deserializeInternalKey(value) {
    let k2 = value.slice(0, 2);
    let v2 = value.slice(2);
    if (k2 === "n:") {
      return parseInt(v2, 10);
    } else if (k2 === "b:") {
      return BigInt(v2);
    } else if (k2 === "a:") {
      return Address_1.Address.parse(v2);
    } else if (k2 === "f:") {
      return Buffer.from(v2, "hex");
    } else if (k2 === "B:") {
      const lastDash = v2.slice(-1) == "_";
      const isPadded = lastDash || v2.length % 2 != 0;
      if (isPadded) {
        let charLen = lastDash ? v2.length - 1 : v2.length;
        const padded = v2.substr(0, charLen) + "0";
        if (!lastDash && (charLen & 1) !== 0) {
          return new BitString_1.BitString(Buffer.from(padded, "hex"), 0, charLen << 2);
        } else {
          return (0, paddedBits_1.paddedBufferToBits)(Buffer.from(padded, "hex"));
        }
      } else {
        return new BitString_1.BitString(Buffer.from(v2, "hex"), 0, v2.length << 2);
      }
    }
    throw Error("Invalid key type: " + k2);
  }
  internalKeySerializer.deserializeInternalKey = deserializeInternalKey;
  return internalKeySerializer;
}
var hasRequiredDictionary;
function requireDictionary() {
  if (hasRequiredDictionary) return Dictionary;
  hasRequiredDictionary = 1;
  Object.defineProperty(Dictionary, "__esModule", { value: true });
  Dictionary.Dictionary = void 0;
  const Address_1 = requireAddress();
  const Builder_12 = requireBuilder$1();
  const Cell_1 = requireCell();
  const BitString_1 = requireBitString();
  const generateMerkleProof_1 = requireGenerateMerkleProof();
  const generateMerkleUpdate_1 = requireGenerateMerkleUpdate();
  const parseDict_1 = requireParseDict();
  const serializeDict_1 = requireSerializeDict();
  const internalKeySerializer_1 = requireInternalKeySerializer();
  let Dictionary$1 = class Dictionary2 {
    /**
     * Create an empty map
     * @param key key type
     * @param value value type
     * @returns Dictionary<K, V>
     */
    static empty(key2, value) {
      if (key2 && value) {
        return new Dictionary2(/* @__PURE__ */ new Map(), key2, value);
      } else {
        return new Dictionary2(/* @__PURE__ */ new Map(), null, null);
      }
    }
    /**
     * Load dictionary from slice
     * @param key key description
     * @param value value description
     * @param src slice
     * @returns Dictionary<K, V>
     */
    static load(key2, value, sc) {
      let slice;
      if (sc instanceof Cell_1.Cell) {
        if (sc.isExotic) {
          return Dictionary2.empty(key2, value);
        }
        slice = sc.beginParse();
      } else {
        slice = sc;
      }
      let cell = slice.loadMaybeRef();
      if (cell && !cell.isExotic) {
        return Dictionary2.loadDirect(key2, value, cell.beginParse());
      } else {
        return Dictionary2.empty(key2, value);
      }
    }
    /**
     * Low level method for rare dictionaries from system contracts.
     * Loads dictionary from slice directly without going to the ref.
     *
     * @param key key description
     * @param value value description
     * @param sc slice
     * @returns Dictionary<K, V>
     */
    static loadDirect(key2, value, sc) {
      if (!sc) {
        return Dictionary2.empty(key2, value);
      }
      let slice;
      if (sc instanceof Cell_1.Cell) {
        slice = sc.beginParse();
      } else {
        slice = sc;
      }
      let values = (0, parseDict_1.parseDict)(slice, key2.bits, value.parse);
      let prepare = /* @__PURE__ */ new Map();
      for (let [k2, v2] of values) {
        prepare.set((0, internalKeySerializer_1.serializeInternalKey)(key2.parse(k2)), v2);
      }
      return new Dictionary2(prepare, key2, value);
    }
    constructor(values, key2, value) {
      this._key = key2;
      this._value = value;
      this._map = values;
    }
    get size() {
      return this._map.size;
    }
    get(key2) {
      return this._map.get((0, internalKeySerializer_1.serializeInternalKey)(key2));
    }
    has(key2) {
      return this._map.has((0, internalKeySerializer_1.serializeInternalKey)(key2));
    }
    set(key2, value) {
      this._map.set((0, internalKeySerializer_1.serializeInternalKey)(key2), value);
      return this;
    }
    delete(key2) {
      const k2 = (0, internalKeySerializer_1.serializeInternalKey)(key2);
      return this._map.delete(k2);
    }
    clear() {
      this._map.clear();
    }
    *[Symbol.iterator]() {
      for (const [k2, v2] of this._map) {
        const key2 = (0, internalKeySerializer_1.deserializeInternalKey)(k2);
        yield [key2, v2];
      }
    }
    keys() {
      return Array.from(this._map.keys()).map((v2) => (0, internalKeySerializer_1.deserializeInternalKey)(v2));
    }
    values() {
      return Array.from(this._map.values());
    }
    store(builder2, key2, value) {
      if (this._map.size === 0) {
        builder2.storeBit(0);
      } else {
        let resolvedKey = this._key;
        if (key2 !== null && key2 !== void 0) {
          resolvedKey = key2;
        }
        let resolvedValue = this._value;
        if (value !== null && value !== void 0) {
          resolvedValue = value;
        }
        if (!resolvedKey) {
          throw Error("Key serializer is not defined");
        }
        if (!resolvedValue) {
          throw Error("Value serializer is not defined");
        }
        let prepared = /* @__PURE__ */ new Map();
        for (const [k2, v2] of this._map) {
          prepared.set(resolvedKey.serialize((0, internalKeySerializer_1.deserializeInternalKey)(k2)), v2);
        }
        builder2.storeBit(1);
        let dd = (0, Builder_12.beginCell)();
        (0, serializeDict_1.serializeDict)(prepared, resolvedKey.bits, resolvedValue.serialize, dd);
        builder2.storeRef(dd.endCell());
      }
    }
    storeDirect(builder2, key2, value) {
      if (this._map.size === 0) {
        throw Error("Cannot store empty dictionary directly");
      }
      let resolvedKey = this._key;
      if (key2 !== null && key2 !== void 0) {
        resolvedKey = key2;
      }
      let resolvedValue = this._value;
      if (value !== null && value !== void 0) {
        resolvedValue = value;
      }
      if (!resolvedKey) {
        throw Error("Key serializer is not defined");
      }
      if (!resolvedValue) {
        throw Error("Value serializer is not defined");
      }
      let prepared = /* @__PURE__ */ new Map();
      for (const [k2, v2] of this._map) {
        prepared.set(resolvedKey.serialize((0, internalKeySerializer_1.deserializeInternalKey)(k2)), v2);
      }
      (0, serializeDict_1.serializeDict)(prepared, resolvedKey.bits, resolvedValue.serialize, builder2);
    }
    /**
     * Generate merkle proof for multiple keys in the dictionary
     * @param keys an array of the keys
     * @returns generated merkle proof cell
     */
    generateMerkleProof(keys) {
      return (0, generateMerkleProof_1.generateMerkleProof)(this, keys, this._key);
    }
    /**
     * Low level method for generating pruned dictionary directly.
     * The result can be used as a part of a bigger merkle proof
     * @param keys an array of the keys
     * @returns cell that contains the pruned dictionary
     */
    generateMerkleProofDirect(keys) {
      return (0, generateMerkleProof_1.generateMerkleProofDirect)(this, keys, this._key);
    }
    generateMerkleUpdate(key2, newValue) {
      return (0, generateMerkleUpdate_1.generateMerkleUpdate)(this, key2, this._key, newValue);
    }
  };
  Dictionary.Dictionary = Dictionary$1;
  Dictionary$1.Keys = {
    /**
     * Standard address key
     * @returns DictionaryKey<Address>
     */
    Address: () => {
      return createAddressKey();
    },
    /**
     * Create standard big integer key
     * @param bits number of bits
     * @returns DictionaryKey<bigint>
     */
    BigInt: (bits) => {
      return createBigIntKey(bits);
    },
    /**
     * Create integer key
     * @param bits bits of integer
     * @returns DictionaryKey<number>
     */
    Int: (bits) => {
      return createIntKey(bits);
    },
    /**
     * Create standard unsigned big integer key
     * @param bits number of bits
     * @returns DictionaryKey<bigint>
     */
    BigUint: (bits) => {
      return createBigUintKey(bits);
    },
    /**
     * Create standard unsigned integer key
     * @param bits number of bits
     * @returns DictionaryKey<number>
     */
    Uint: (bits) => {
      return createUintKey(bits);
    },
    /**
     * Create standard buffer key
     * @param bytes number of bytes of a buffer
     * @returns DictionaryKey<Buffer>
     */
    Buffer: (bytes) => {
      return createBufferKey(bytes);
    },
    /**
     * Create BitString key
     * @param bits key length
     * @returns DictionaryKey<BitString>
     * Point is that Buffer has to be 8 bit aligned,
     * while key is TVM dictionary doesn't have to be
     * aligned at all.
     */
    BitString: (bits) => {
      return createBitStringKey(bits);
    }
  };
  Dictionary$1.Values = {
    /**
     * Create standard integer value
     * @returns DictionaryValue<bigint>
     */
    BigInt: (bits) => {
      return createBigIntValue(bits);
    },
    /**
     * Create standard integer value
     * @returns DictionaryValue<number>
     */
    Int: (bits) => {
      return createIntValue(bits);
    },
    /**
     * Create big var int
     * @param bits nubmer of header bits
     * @returns DictionaryValue<bigint>
     */
    BigVarInt: (bits) => {
      return createBigVarIntValue(bits);
    },
    /**
     * Create standard unsigned integer value
     * @param bits number of bits
     * @returns DictionaryValue<bigint>
     */
    BigUint: (bits) => {
      return createBigUintValue(bits);
    },
    /**
     * Create standard unsigned integer value
     * @param bits number of bits
     * @returns DictionaryValue<bigint>
     */
    Uint: (bits) => {
      return createUintValue(bits);
    },
    /**
     * Create big var int
     * @param bits nubmer of header bits
     * @returns DictionaryValue<bigint>
     */
    BigVarUint: (bits) => {
      return createBigVarUintValue(bits);
    },
    /**
     * Create standard boolean value
     * @returns DictionaryValue<boolean>
     */
    Bool: () => {
      return createBooleanValue();
    },
    /**
     * Create standard address value
     * @returns DictionaryValue<Address>
     */
    Address: () => {
      return createAddressValue();
    },
    /**
     * Create standard cell value
     * @returns DictionaryValue<Cell>
     */
    Cell: () => {
      return createCellValue();
    },
    /**
     * Create Builder value
     * @param bytes number of bytes of a buffer
     * @returns DictionaryValue<Builder>
     */
    Buffer: (bytes) => {
      return createBufferValue(bytes);
    },
    /**
     * Create BitString value
     * @param requested bit length
     * @returns DictionaryValue<BitString>
     * Point is that Buffer is not applicable
     * when length is not 8 bit alligned.
     */
    BitString: (bits) => {
      return createBitStringValue(bits);
    },
    /**
     * Create dictionary value
     * @param key
     * @param value
     */
    Dictionary: (key2, value) => {
      return createDictionaryValue(key2, value);
    }
  };
  function createAddressKey() {
    return {
      bits: 267,
      serialize: (src2) => {
        if (!Address_1.Address.isAddress(src2)) {
          throw Error("Key is not an address");
        }
        return (0, Builder_12.beginCell)().storeAddress(src2).endCell().beginParse().preloadUintBig(267);
      },
      parse: (src2) => {
        return (0, Builder_12.beginCell)().storeUint(src2, 267).endCell().beginParse().loadAddress();
      }
    };
  }
  function createBigIntKey(bits) {
    return {
      bits,
      serialize: (src2) => {
        if (typeof src2 !== "bigint") {
          throw Error("Key is not a bigint");
        }
        return (0, Builder_12.beginCell)().storeInt(src2, bits).endCell().beginParse().loadUintBig(bits);
      },
      parse: (src2) => {
        return (0, Builder_12.beginCell)().storeUint(src2, bits).endCell().beginParse().loadIntBig(bits);
      }
    };
  }
  function createIntKey(bits) {
    return {
      bits,
      serialize: (src2) => {
        if (typeof src2 !== "number") {
          throw Error("Key is not a number");
        }
        if (!Number.isSafeInteger(src2)) {
          throw Error("Key is not a safe integer: " + src2);
        }
        return (0, Builder_12.beginCell)().storeInt(src2, bits).endCell().beginParse().loadUintBig(bits);
      },
      parse: (src2) => {
        return (0, Builder_12.beginCell)().storeUint(src2, bits).endCell().beginParse().loadInt(bits);
      }
    };
  }
  function createBigUintKey(bits) {
    return {
      bits,
      serialize: (src2) => {
        if (typeof src2 !== "bigint") {
          throw Error("Key is not a bigint");
        }
        if (src2 < 0) {
          throw Error("Key is negative: " + src2);
        }
        return (0, Builder_12.beginCell)().storeUint(src2, bits).endCell().beginParse().loadUintBig(bits);
      },
      parse: (src2) => {
        return (0, Builder_12.beginCell)().storeUint(src2, bits).endCell().beginParse().loadUintBig(bits);
      }
    };
  }
  function createUintKey(bits) {
    return {
      bits,
      serialize: (src2) => {
        if (typeof src2 !== "number") {
          throw Error("Key is not a number");
        }
        if (!Number.isSafeInteger(src2)) {
          throw Error("Key is not a safe integer: " + src2);
        }
        if (src2 < 0) {
          throw Error("Key is negative: " + src2);
        }
        return (0, Builder_12.beginCell)().storeUint(src2, bits).endCell().beginParse().loadUintBig(bits);
      },
      parse: (src2) => {
        return Number((0, Builder_12.beginCell)().storeUint(src2, bits).endCell().beginParse().loadUint(bits));
      }
    };
  }
  function createBufferKey(bytes) {
    return {
      bits: bytes * 8,
      serialize: (src2) => {
        if (!Buffer.isBuffer(src2)) {
          throw Error("Key is not a buffer");
        }
        return (0, Builder_12.beginCell)().storeBuffer(src2).endCell().beginParse().loadUintBig(bytes * 8);
      },
      parse: (src2) => {
        return (0, Builder_12.beginCell)().storeUint(src2, bytes * 8).endCell().beginParse().loadBuffer(bytes);
      }
    };
  }
  function createBitStringKey(bits) {
    return {
      bits,
      serialize: (src2) => {
        if (!BitString_1.BitString.isBitString(src2))
          throw Error("Key is not a BitString");
        return (0, Builder_12.beginCell)().storeBits(src2).endCell().beginParse().loadUintBig(bits);
      },
      parse: (src2) => {
        return (0, Builder_12.beginCell)().storeUint(src2, bits).endCell().beginParse().loadBits(bits);
      }
    };
  }
  function createIntValue(bits) {
    return {
      serialize: (src2, buidler) => {
        buidler.storeInt(src2, bits);
      },
      parse: (src2) => {
        let value = src2.loadInt(bits);
        src2.endParse();
        return value;
      }
    };
  }
  function createBigIntValue(bits) {
    return {
      serialize: (src2, buidler) => {
        buidler.storeInt(src2, bits);
      },
      parse: (src2) => {
        let value = src2.loadIntBig(bits);
        src2.endParse();
        return value;
      }
    };
  }
  function createBigVarIntValue(bits) {
    return {
      serialize: (src2, buidler) => {
        buidler.storeVarInt(src2, bits);
      },
      parse: (src2) => {
        let value = src2.loadVarIntBig(bits);
        src2.endParse();
        return value;
      }
    };
  }
  function createBigVarUintValue(bits) {
    return {
      serialize: (src2, buidler) => {
        buidler.storeVarUint(src2, bits);
      },
      parse: (src2) => {
        let value = src2.loadVarUintBig(bits);
        src2.endParse();
        return value;
      }
    };
  }
  function createUintValue(bits) {
    return {
      serialize: (src2, buidler) => {
        buidler.storeUint(src2, bits);
      },
      parse: (src2) => {
        let value = src2.loadUint(bits);
        src2.endParse();
        return value;
      }
    };
  }
  function createBigUintValue(bits) {
    return {
      serialize: (src2, buidler) => {
        buidler.storeUint(src2, bits);
      },
      parse: (src2) => {
        let value = src2.loadUintBig(bits);
        src2.endParse();
        return value;
      }
    };
  }
  function createBooleanValue() {
    return {
      serialize: (src2, buidler) => {
        buidler.storeBit(src2);
      },
      parse: (src2) => {
        let value = src2.loadBit();
        src2.endParse();
        return value;
      }
    };
  }
  function createAddressValue() {
    return {
      serialize: (src2, buidler) => {
        buidler.storeAddress(src2);
      },
      parse: (src2) => {
        let addr = src2.loadAddress();
        src2.endParse();
        return addr;
      }
    };
  }
  function createCellValue() {
    return {
      serialize: (src2, buidler) => {
        buidler.storeRef(src2);
      },
      parse: (src2) => {
        let value = src2.loadRef();
        src2.endParse();
        return value;
      }
    };
  }
  function createDictionaryValue(key2, value) {
    return {
      serialize: (src2, buidler) => {
        src2.store(buidler);
      },
      parse: (src2) => {
        let dict = Dictionary$1.load(key2, value, src2);
        src2.endParse();
        return dict;
      }
    };
  }
  function createBufferValue(size) {
    return {
      serialize: (src2, buidler) => {
        if (src2.length !== size) {
          throw Error("Invalid buffer size");
        }
        buidler.storeBuffer(src2);
      },
      parse: (src2) => {
        let value = src2.loadBuffer(size);
        src2.endParse();
        return value;
      }
    };
  }
  function createBitStringValue(bits) {
    return {
      serialize: (src2, builder2) => {
        if (src2.length !== bits) {
          throw Error("Invalid BitString size");
        }
        builder2.storeBits(src2);
      },
      parse: (src2) => {
        let value = src2.loadBits(bits);
        src2.endParse();
        return value;
      }
    };
  }
  return Dictionary;
}
var strings = {};
var hasRequiredStrings;
function requireStrings() {
  if (hasRequiredStrings) return strings;
  hasRequiredStrings = 1;
  Object.defineProperty(strings, "__esModule", { value: true });
  strings.writeString = strings.stringToCell = strings.readString = void 0;
  const Builder_12 = requireBuilder$1();
  function readBuffer(slice) {
    if (slice.remainingBits % 8 !== 0) {
      throw new Error(`Invalid string length: ${slice.remainingBits}`);
    }
    if (slice.remainingRefs !== 0 && slice.remainingRefs !== 1) {
      throw new Error(`invalid number of refs: ${slice.remainingRefs}`);
    }
    let res;
    if (slice.remainingBits === 0) {
      res = Buffer.alloc(0);
    } else {
      res = slice.loadBuffer(slice.remainingBits / 8);
    }
    if (slice.remainingRefs === 1) {
      res = Buffer.concat([res, readBuffer(slice.loadRef().beginParse())]);
    }
    return res;
  }
  function readString(slice) {
    return readBuffer(slice).toString();
  }
  strings.readString = readString;
  function writeBuffer(src2, builder2) {
    if (src2.length > 0) {
      let bytes = Math.floor(builder2.availableBits / 8);
      if (src2.length > bytes) {
        let a2 = src2.subarray(0, bytes);
        let t = src2.subarray(bytes);
        builder2 = builder2.storeBuffer(a2);
        let bb = (0, Builder_12.beginCell)();
        writeBuffer(t, bb);
        builder2 = builder2.storeRef(bb.endCell());
      } else {
        builder2 = builder2.storeBuffer(src2);
      }
    }
  }
  function stringToCell(src2) {
    let builder2 = (0, Builder_12.beginCell)();
    writeBuffer(Buffer.from(src2), builder2);
    return builder2.endCell();
  }
  strings.stringToCell = stringToCell;
  function writeString(src2, builder2) {
    writeBuffer(Buffer.from(src2), builder2);
  }
  strings.writeString = writeString;
  return strings;
}
var hasRequiredSlice;
function requireSlice() {
  if (hasRequiredSlice) return Slice;
  hasRequiredSlice = 1;
  var __importDefault = Slice && Slice.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  var _a2;
  Object.defineProperty(Slice, "__esModule", { value: true });
  Slice.Slice = void 0;
  const symbol_inspect_1 = __importDefault(requireSymbol_inspect());
  const Dictionary_1 = requireDictionary();
  const Builder_12 = requireBuilder$1();
  const strings_1 = requireStrings();
  let Slice$1 = class Slice2 {
    constructor(reader2, refs) {
      this[_a2] = () => this.toString();
      this._reader = reader2.clone();
      this._refs = [...refs];
      this._refsOffset = 0;
    }
    /**
     * Get remaining bits
     */
    get remainingBits() {
      return this._reader.remaining;
    }
    /**
     * Get offset bits
     */
    get offsetBits() {
      return this._reader.offset;
    }
    /**
     * Get remaining refs
     */
    get remainingRefs() {
      return this._refs.length - this._refsOffset;
    }
    /**
     * Get offset refs
     */
    get offsetRefs() {
      return this._refsOffset;
    }
    /**
     * Skip bits
     * @param bits
     */
    skip(bits) {
      this._reader.skip(bits);
      return this;
    }
    /**
     * Load a single bit
     * @returns true or false depending on the bit value
     */
    loadBit() {
      return this._reader.loadBit();
    }
    /**
     * Preload a signle bit
     * @returns true or false depending on the bit value
     */
    preloadBit() {
      return this._reader.preloadBit();
    }
    /**
     * Load a boolean
     * @returns true or false depending on the bit value
     */
    loadBoolean() {
      return this.loadBit();
    }
    /**
     * Load maybe boolean
     * @returns true or false depending on the bit value or null
     */
    loadMaybeBoolean() {
      if (this.loadBit()) {
        return this.loadBoolean();
      } else {
        return null;
      }
    }
    /**
     * Load bits as a new BitString
     * @param bits number of bits to read
     * @returns new BitString
     */
    loadBits(bits) {
      return this._reader.loadBits(bits);
    }
    /**
     * Preload bits as a new BitString
     * @param bits number of bits to read
     * @returns new BitString
     */
    preloadBits(bits) {
      return this._reader.preloadBits(bits);
    }
    /**
     * Load uint
     * @param bits number of bits to read
     * @returns uint value
     */
    loadUint(bits) {
      return this._reader.loadUint(bits);
    }
    /**
     * Load uint
     * @param bits number of bits to read
     * @returns uint value
     */
    loadUintBig(bits) {
      return this._reader.loadUintBig(bits);
    }
    /**
     * Preload uint
     * @param bits number of bits to read
     * @returns uint value
     */
    preloadUint(bits) {
      return this._reader.preloadUint(bits);
    }
    /**
     * Preload uint
     * @param bits number of bits to read
     * @returns uint value
     */
    preloadUintBig(bits) {
      return this._reader.preloadUintBig(bits);
    }
    /**
     * Load maybe uint
     * @param bits number of bits to read
     * @returns uint value or null
     */
    loadMaybeUint(bits) {
      if (this.loadBit()) {
        return this.loadUint(bits);
      } else {
        return null;
      }
    }
    /**
     * Load maybe uint
     * @param bits number of bits to read
     * @returns uint value or null
     */
    loadMaybeUintBig(bits) {
      if (this.loadBit()) {
        return this.loadUintBig(bits);
      } else {
        return null;
      }
    }
    /**
     * Load int
     * @param bits number of bits to read
     * @returns int value
     */
    loadInt(bits) {
      return this._reader.loadInt(bits);
    }
    /**
     * Load int
     * @param bits number of bits to read
     * @returns int value
     */
    loadIntBig(bits) {
      return this._reader.loadIntBig(bits);
    }
    /**
     * Preload int
     * @param bits number of bits to read
     * @returns int value
     */
    preloadInt(bits) {
      return this._reader.preloadInt(bits);
    }
    /**
     * Preload int
     * @param bits number of bits to read
     * @returns int value
     */
    preloadIntBig(bits) {
      return this._reader.preloadIntBig(bits);
    }
    /**
     * Load maybe uint
     * @param bits number of bits to read
     * @returns uint value or null
     */
    loadMaybeInt(bits) {
      if (this.loadBit()) {
        return this.loadInt(bits);
      } else {
        return null;
      }
    }
    /**
     * Load maybe uint
     * @param bits number of bits to read
     * @returns uint value or null
     */
    loadMaybeIntBig(bits) {
      if (this.loadBit()) {
        return this.loadIntBig(bits);
      } else {
        return null;
      }
    }
    /**
     * Load varuint
     * @param bits number of bits to read in header
     * @returns varuint value
     */
    loadVarUint(bits) {
      return this._reader.loadVarUint(bits);
    }
    /**
     * Load varuint
     * @param bits number of bits to read in header
     * @returns varuint value
     */
    loadVarUintBig(bits) {
      return this._reader.loadVarUintBig(bits);
    }
    /**
     * Preload varuint
     * @param bits number of bits to read in header
     * @returns varuint value
     */
    preloadVarUint(bits) {
      return this._reader.preloadVarUint(bits);
    }
    /**
     * Preload varuint
     * @param bits number of bits to read in header
     * @returns varuint value
     */
    preloadVarUintBig(bits) {
      return this._reader.preloadVarUintBig(bits);
    }
    /**
     * Load varint
     * @param bits number of bits to read in header
     * @returns varint value
     */
    loadVarInt(bits) {
      return this._reader.loadVarInt(bits);
    }
    /**
     * Load varint
     * @param bits number of bits to read in header
     * @returns varint value
     */
    loadVarIntBig(bits) {
      return this._reader.loadVarIntBig(bits);
    }
    /**
     * Preload varint
     * @param bits number of bits to read in header
     * @returns varint value
     */
    preloadVarInt(bits) {
      return this._reader.preloadVarInt(bits);
    }
    /**
     * Preload varint
     * @param bits number of bits to read in header
     * @returns varint value
     */
    preloadVarIntBig(bits) {
      return this._reader.preloadVarIntBig(bits);
    }
    /**
     * Load coins
     * @returns coins value
     */
    loadCoins() {
      return this._reader.loadCoins();
    }
    /**
     * Preload coins
     * @returns coins value
     */
    preloadCoins() {
      return this._reader.preloadCoins();
    }
    /**
     * Load maybe coins
     * @returns coins value or null
     */
    loadMaybeCoins() {
      if (this._reader.loadBit()) {
        return this._reader.loadCoins();
      } else {
        return null;
      }
    }
    /**
     * Load internal Address
     * @returns Address
     */
    loadAddress() {
      return this._reader.loadAddress();
    }
    /**
     * Load optional internal Address
     * @returns Address or null
     */
    loadMaybeAddress() {
      return this._reader.loadMaybeAddress();
    }
    /**
     * Load external address
     * @returns ExternalAddress
     */
    loadExternalAddress() {
      return this._reader.loadExternalAddress();
    }
    /**
     * Load optional external address
     * @returns ExternalAddress or null
     */
    loadMaybeExternalAddress() {
      return this._reader.loadMaybeExternalAddress();
    }
    /**
     * Load address
     * @returns Address, ExternalAddress or null
     */
    loadAddressAny() {
      return this._reader.loadAddressAny();
    }
    /**
     * Load reference
     * @returns Cell
     */
    loadRef() {
      if (this._refsOffset >= this._refs.length) {
        throw new Error("No more references");
      }
      return this._refs[this._refsOffset++];
    }
    /**
     * Preload reference
     * @returns Cell
     */
    preloadRef() {
      if (this._refsOffset >= this._refs.length) {
        throw new Error("No more references");
      }
      return this._refs[this._refsOffset];
    }
    /**
     * Load optional reference
     * @returns Cell or null
     */
    loadMaybeRef() {
      if (this.loadBit()) {
        return this.loadRef();
      } else {
        return null;
      }
    }
    /**
     * Preload optional reference
     * @returns Cell or null
     */
    preloadMaybeRef() {
      if (this.preloadBit()) {
        return this.preloadRef();
      } else {
        return null;
      }
    }
    /**
     * Load byte buffer
     * @param bytes number of bytes to load
     * @returns Buffer
     */
    loadBuffer(bytes) {
      return this._reader.loadBuffer(bytes);
    }
    /**
     * Load byte buffer
     * @param bytes number of bytes to load
     * @returns Buffer
     */
    preloadBuffer(bytes) {
      return this._reader.preloadBuffer(bytes);
    }
    /**
     * Load string tail
     */
    loadStringTail() {
      return (0, strings_1.readString)(this);
    }
    /**
     * Load maybe string tail
     * @returns string or null
     */
    loadMaybeStringTail() {
      if (this.loadBit()) {
        return (0, strings_1.readString)(this);
      } else {
        return null;
      }
    }
    /**
     * Load string tail from ref
     * @returns string
     */
    loadStringRefTail() {
      return (0, strings_1.readString)(this.loadRef().beginParse());
    }
    /**
     * Load maybe string tail from ref
     * @returns string or null
     */
    loadMaybeStringRefTail() {
      const ref = this.loadMaybeRef();
      if (ref) {
        return (0, strings_1.readString)(ref.beginParse());
      } else {
        return null;
      }
    }
    /**
     * Loads dictionary
     * @param key key description
     * @param value value description
     * @returns Dictionary<K, V>
     */
    loadDict(key2, value) {
      return Dictionary_1.Dictionary.load(key2, value, this);
    }
    /**
     * Loads dictionary directly from current slice
     * @param key key description
     * @param value value description
     * @returns Dictionary<K, V>
     */
    loadDictDirect(key2, value) {
      return Dictionary_1.Dictionary.loadDirect(key2, value, this);
    }
    /**
     * Checks if slice is empty
     */
    endParse() {
      if (this.remainingBits > 0 || this.remainingRefs > 0) {
        throw new Error("Slice is not empty");
      }
    }
    /**
     * Convert slice to cell
     */
    asCell() {
      return (0, Builder_12.beginCell)().storeSlice(this).endCell();
    }
    /**
     *
     * @returns
     */
    asBuilder() {
      return (0, Builder_12.beginCell)().storeSlice(this);
    }
    /**
     * Clone slice
     * @returns cloned slice
     */
    clone(fromStart = false) {
      if (fromStart) {
        let reader2 = this._reader.clone();
        reader2.reset();
        return new Slice2(reader2, this._refs);
      } else {
        let res = new Slice2(this._reader, this._refs);
        res._refsOffset = this._refsOffset;
        return res;
      }
    }
    /**
     * Print slice as string by converting it to cell
     * @returns string
     */
    toString() {
      return this.asCell().toString();
    }
  };
  Slice.Slice = Slice$1;
  _a2 = symbol_inspect_1.default;
  return Slice;
}
var resolveExotic = {};
var exoticLibrary = {};
var hasRequiredExoticLibrary;
function requireExoticLibrary() {
  if (hasRequiredExoticLibrary) return exoticLibrary;
  hasRequiredExoticLibrary = 1;
  Object.defineProperty(exoticLibrary, "__esModule", { value: true });
  exoticLibrary.exoticLibrary = void 0;
  const BitReader_1 = requireBitReader();
  function exoticLibrary$1(bits, refs) {
    const reader2 = new BitReader_1.BitReader(bits);
    const size = 8 + 256;
    if (bits.length !== size) {
      throw new Error(`Library cell must have exactly (8 + 256) bits, got "${bits.length}"`);
    }
    let type = reader2.loadUint(8);
    if (type !== 2) {
      throw new Error(`Library cell must have type 2, got "${type}"`);
    }
    return {};
  }
  exoticLibrary.exoticLibrary = exoticLibrary$1;
  return exoticLibrary;
}
var exoticMerkleUpdate = {};
var hasRequiredExoticMerkleUpdate;
function requireExoticMerkleUpdate() {
  if (hasRequiredExoticMerkleUpdate) return exoticMerkleUpdate;
  hasRequiredExoticMerkleUpdate = 1;
  Object.defineProperty(exoticMerkleUpdate, "__esModule", { value: true });
  exoticMerkleUpdate.exoticMerkleUpdate = void 0;
  const BitReader_1 = requireBitReader();
  function exoticMerkleUpdate$1(bits, refs) {
    const reader2 = new BitReader_1.BitReader(bits);
    const size = 8 + 2 * (256 + 16);
    if (bits.length !== size) {
      throw new Error(`Merkle Update cell must have exactly (8 + (2 * (256 + 16))) bits, got "${bits.length}"`);
    }
    if (refs.length !== 2) {
      throw new Error(`Merkle Update cell must have exactly 2 refs, got "${refs.length}"`);
    }
    let type = reader2.loadUint(8);
    if (type !== 4) {
      throw new Error(`Merkle Update cell type must be exactly 4, got "${type}"`);
    }
    const proofHash1 = reader2.loadBuffer(32);
    const proofHash2 = reader2.loadBuffer(32);
    const proofDepth1 = reader2.loadUint(16);
    const proofDepth2 = reader2.loadUint(16);
    if (proofDepth1 !== refs[0].depth(0)) {
      throw new Error(`Merkle Update cell ref depth must be exactly "${proofDepth1}", got "${refs[0].depth(0)}"`);
    }
    if (!proofHash1.equals(refs[0].hash(0))) {
      throw new Error(`Merkle Update cell ref hash must be exactly "${proofHash1.toString("hex")}", got "${refs[0].hash(0).toString("hex")}"`);
    }
    if (proofDepth2 !== refs[1].depth(0)) {
      throw new Error(`Merkle Update cell ref depth must be exactly "${proofDepth2}", got "${refs[1].depth(0)}"`);
    }
    if (!proofHash2.equals(refs[1].hash(0))) {
      throw new Error(`Merkle Update cell ref hash must be exactly "${proofHash2.toString("hex")}", got "${refs[1].hash(0).toString("hex")}"`);
    }
    return {
      proofDepth1,
      proofDepth2,
      proofHash1,
      proofHash2
    };
  }
  exoticMerkleUpdate.exoticMerkleUpdate = exoticMerkleUpdate$1;
  return exoticMerkleUpdate;
}
var exoticPruned = {};
var LevelMask = {};
var hasRequiredLevelMask;
function requireLevelMask() {
  if (hasRequiredLevelMask) return LevelMask;
  hasRequiredLevelMask = 1;
  Object.defineProperty(LevelMask, "__esModule", { value: true });
  LevelMask.LevelMask = void 0;
  let LevelMask$1 = class LevelMask2 {
    constructor(mask = 0) {
      this._mask = 0;
      this._mask = mask;
      this._hashIndex = countSetBits(this._mask);
      this._hashCount = this._hashIndex + 1;
    }
    get value() {
      return this._mask;
    }
    get level() {
      return 32 - Math.clz32(this._mask);
    }
    get hashIndex() {
      return this._hashIndex;
    }
    get hashCount() {
      return this._hashCount;
    }
    apply(level) {
      return new LevelMask2(this._mask & (1 << level) - 1);
    }
    isSignificant(level) {
      let res = level === 0 || (this._mask >> level - 1) % 2 !== 0;
      return res;
    }
  };
  LevelMask.LevelMask = LevelMask$1;
  function countSetBits(n) {
    n = n - (n >> 1 & 1431655765);
    n = (n & 858993459) + (n >> 2 & 858993459);
    return (n + (n >> 4) & 252645135) * 16843009 >> 24;
  }
  return LevelMask;
}
var hasRequiredExoticPruned;
function requireExoticPruned() {
  if (hasRequiredExoticPruned) return exoticPruned;
  hasRequiredExoticPruned = 1;
  Object.defineProperty(exoticPruned, "__esModule", { value: true });
  exoticPruned.exoticPruned = void 0;
  const BitReader_1 = requireBitReader();
  const LevelMask_1 = requireLevelMask();
  function exoticPruned$1(bits, refs) {
    let reader2 = new BitReader_1.BitReader(bits);
    let type = reader2.loadUint(8);
    if (type !== 1) {
      throw new Error(`Pruned branch cell must have type 1, got "${type}"`);
    }
    if (refs.length !== 0) {
      throw new Error(`Pruned Branch cell can't has refs, got "${refs.length}"`);
    }
    let mask;
    if (bits.length === 280) {
      mask = new LevelMask_1.LevelMask(1);
    } else {
      mask = new LevelMask_1.LevelMask(reader2.loadUint(8));
      if (mask.level < 1 || mask.level > 3) {
        throw new Error(`Pruned Branch cell level must be >= 1 and <= 3, got "${mask.level}/${mask.value}"`);
      }
      const size = 8 + 8 + mask.apply(mask.level - 1).hashCount * (256 + 16);
      if (bits.length !== size) {
        throw new Error(`Pruned branch cell must have exactly ${size} bits, got "${bits.length}"`);
      }
    }
    let pruned = [];
    let hashes = [];
    let depths = [];
    for (let i = 0; i < mask.level; i++) {
      hashes.push(reader2.loadBuffer(32));
    }
    for (let i = 0; i < mask.level; i++) {
      depths.push(reader2.loadUint(16));
    }
    for (let i = 0; i < mask.level; i++) {
      pruned.push({
        depth: depths[i],
        hash: hashes[i]
      });
    }
    return {
      mask: mask.value,
      pruned
    };
  }
  exoticPruned.exoticPruned = exoticPruned$1;
  return exoticPruned;
}
var hasRequiredResolveExotic;
function requireResolveExotic() {
  if (hasRequiredResolveExotic) return resolveExotic;
  hasRequiredResolveExotic = 1;
  Object.defineProperty(resolveExotic, "__esModule", { value: true });
  resolveExotic.resolveExotic = void 0;
  const BitReader_1 = requireBitReader();
  const CellType_1 = requireCellType();
  const exoticLibrary_1 = requireExoticLibrary();
  const exoticMerkleProof_1 = requireExoticMerkleProof();
  const exoticMerkleUpdate_1 = requireExoticMerkleUpdate();
  const exoticPruned_1 = requireExoticPruned();
  const LevelMask_1 = requireLevelMask();
  function resolvePruned(bits, refs) {
    let pruned = (0, exoticPruned_1.exoticPruned)(bits, refs);
    let depths = [];
    let hashes = [];
    let mask = new LevelMask_1.LevelMask(pruned.mask);
    for (let i = 0; i < pruned.pruned.length; i++) {
      depths.push(pruned.pruned[i].depth);
      hashes.push(pruned.pruned[i].hash);
    }
    return {
      type: CellType_1.CellType.PrunedBranch,
      depths,
      hashes,
      mask
    };
  }
  function resolveLibrary(bits, refs) {
    (0, exoticLibrary_1.exoticLibrary)(bits, refs);
    let depths = [];
    let hashes = [];
    let mask = new LevelMask_1.LevelMask();
    return {
      type: CellType_1.CellType.Library,
      depths,
      hashes,
      mask
    };
  }
  function resolveMerkleProof(bits, refs) {
    (0, exoticMerkleProof_1.exoticMerkleProof)(bits, refs);
    let depths = [];
    let hashes = [];
    let mask = new LevelMask_1.LevelMask(refs[0].level() >> 1);
    return {
      type: CellType_1.CellType.MerkleProof,
      depths,
      hashes,
      mask
    };
  }
  function resolveMerkleUpdate(bits, refs) {
    (0, exoticMerkleUpdate_1.exoticMerkleUpdate)(bits, refs);
    let depths = [];
    let hashes = [];
    let mask = new LevelMask_1.LevelMask((refs[0].level() | refs[1].level()) >> 1);
    return {
      type: CellType_1.CellType.MerkleUpdate,
      depths,
      hashes,
      mask
    };
  }
  function resolveExotic$1(bits, refs) {
    let reader2 = new BitReader_1.BitReader(bits);
    let type = reader2.preloadUint(8);
    if (type === 1) {
      return resolvePruned(bits, refs);
    }
    if (type === 2) {
      return resolveLibrary(bits, refs);
    }
    if (type === 3) {
      return resolveMerkleProof(bits, refs);
    }
    if (type === 4) {
      return resolveMerkleUpdate(bits, refs);
    }
    throw Error("Invalid exotic cell type: " + type);
  }
  resolveExotic.resolveExotic = resolveExotic$1;
  return resolveExotic;
}
var wonderCalculator = {};
var descriptor = {};
var hasRequiredDescriptor;
function requireDescriptor() {
  if (hasRequiredDescriptor) return descriptor;
  hasRequiredDescriptor = 1;
  Object.defineProperty(descriptor, "__esModule", { value: true });
  descriptor.getRepr = descriptor.getBitsDescriptor = descriptor.getRefsDescriptor = void 0;
  const CellType_1 = requireCellType();
  const paddedBits_1 = requirePaddedBits();
  function getRefsDescriptor(refs, levelMask, type) {
    return refs.length + (type !== CellType_1.CellType.Ordinary ? 1 : 0) * 8 + levelMask * 32;
  }
  descriptor.getRefsDescriptor = getRefsDescriptor;
  function getBitsDescriptor(bits) {
    let len = bits.length;
    return Math.ceil(len / 8) + Math.floor(len / 8);
  }
  descriptor.getBitsDescriptor = getBitsDescriptor;
  function getRepr(originalBits, bits, refs, level, levelMask, type) {
    const bitsLen = Math.ceil(bits.length / 8);
    const repr = Buffer.alloc(2 + bitsLen + (2 + 32) * refs.length);
    let reprCursor = 0;
    repr[reprCursor++] = getRefsDescriptor(refs, levelMask, type);
    repr[reprCursor++] = getBitsDescriptor(originalBits);
    (0, paddedBits_1.bitsToPaddedBuffer)(bits).copy(repr, reprCursor);
    reprCursor += bitsLen;
    for (const c of refs) {
      let childDepth;
      if (type == CellType_1.CellType.MerkleProof || type == CellType_1.CellType.MerkleUpdate) {
        childDepth = c.depth(level + 1);
      } else {
        childDepth = c.depth(level);
      }
      repr[reprCursor++] = Math.floor(childDepth / 256);
      repr[reprCursor++] = childDepth % 256;
    }
    for (const c of refs) {
      let childHash;
      if (type == CellType_1.CellType.MerkleProof || type == CellType_1.CellType.MerkleUpdate) {
        childHash = c.hash(level + 1);
      } else {
        childHash = c.hash(level);
      }
      childHash.copy(repr, reprCursor);
      reprCursor += 32;
    }
    return repr;
  }
  descriptor.getRepr = getRepr;
  return descriptor;
}
var dist$4 = {};
var sha256$2 = {};
var sha$1 = { exports: {} };
var sha = sha$1.exports;
var hasRequiredSha;
function requireSha() {
  if (hasRequiredSha) return sha$1.exports;
  hasRequiredSha = 1;
  (function(module, exports) {
    !(function(n, r) {
      module.exports = r();
    })(sha, (function() {
      var n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      function r(n2, r2, t2, e2) {
        var i2, o5, u2, f3 = r2 || [0], w3 = (t2 = t2 || 0) >>> 3, s4 = -1 === e2 ? 3 : 0;
        for (i2 = 0; i2 < n2.length; i2 += 1) o5 = (u2 = i2 + w3) >>> 2, f3.length <= o5 && f3.push(0), f3[o5] |= n2[i2] << 8 * (s4 + e2 * (u2 % 4));
        return { value: f3, binLen: 8 * n2.length + t2 };
      }
      function t(t2, e2, i2) {
        switch (e2) {
          case "UTF8":
          case "UTF16BE":
          case "UTF16LE":
            break;
          default:
            throw new Error("encoding must be UTF8, UTF16BE, or UTF16LE");
        }
        switch (t2) {
          case "HEX":
            return function(n2, r2, t3) {
              return (function(n3, r3, t4, e3) {
                var i3, o5, u2, f3;
                if (0 != n3.length % 2) throw new Error("String of HEX type must be in byte increments");
                var w3 = r3 || [0], s4 = (t4 = t4 || 0) >>> 3, a3 = -1 === e3 ? 3 : 0;
                for (i3 = 0; i3 < n3.length; i3 += 2) {
                  if (o5 = parseInt(n3.substr(i3, 2), 16), isNaN(o5)) throw new Error("String of HEX type contains invalid characters");
                  for (u2 = (f3 = (i3 >>> 1) + s4) >>> 2; w3.length <= u2; ) w3.push(0);
                  w3[u2] |= o5 << 8 * (a3 + e3 * (f3 % 4));
                }
                return { value: w3, binLen: 4 * n3.length + t4 };
              })(n2, r2, t3, i2);
            };
          case "TEXT":
            return function(n2, r2, t3) {
              return (function(n3, r3, t4, e3, i3) {
                var o5, u2, f3, w3, s4, a3, h3, c2, v3 = 0, A3 = t4 || [0], E3 = (e3 = e3 || 0) >>> 3;
                if ("UTF8" === r3) for (h3 = -1 === i3 ? 3 : 0, f3 = 0; f3 < n3.length; f3 += 1) for (u2 = [], 128 > (o5 = n3.charCodeAt(f3)) ? u2.push(o5) : 2048 > o5 ? (u2.push(192 | o5 >>> 6), u2.push(128 | 63 & o5)) : 55296 > o5 || 57344 <= o5 ? u2.push(224 | o5 >>> 12, 128 | o5 >>> 6 & 63, 128 | 63 & o5) : (f3 += 1, o5 = 65536 + ((1023 & o5) << 10 | 1023 & n3.charCodeAt(f3)), u2.push(240 | o5 >>> 18, 128 | o5 >>> 12 & 63, 128 | o5 >>> 6 & 63, 128 | 63 & o5)), w3 = 0; w3 < u2.length; w3 += 1) {
                  for (s4 = (a3 = v3 + E3) >>> 2; A3.length <= s4; ) A3.push(0);
                  A3[s4] |= u2[w3] << 8 * (h3 + i3 * (a3 % 4)), v3 += 1;
                }
                else for (h3 = -1 === i3 ? 2 : 0, c2 = "UTF16LE" === r3 && 1 !== i3 || "UTF16LE" !== r3 && 1 === i3, f3 = 0; f3 < n3.length; f3 += 1) {
                  for (o5 = n3.charCodeAt(f3), true === c2 && (o5 = (w3 = 255 & o5) << 8 | o5 >>> 8), s4 = (a3 = v3 + E3) >>> 2; A3.length <= s4; ) A3.push(0);
                  A3[s4] |= o5 << 8 * (h3 + i3 * (a3 % 4)), v3 += 2;
                }
                return { value: A3, binLen: 8 * v3 + e3 };
              })(n2, e2, r2, t3, i2);
            };
          case "B64":
            return function(r2, t3, e3) {
              return (function(r3, t4, e4, i3) {
                var o5, u2, f3, w3, s4, a3, h3 = 0, c2 = t4 || [0], v3 = (e4 = e4 || 0) >>> 3, A3 = -1 === i3 ? 3 : 0, E3 = r3.indexOf("=");
                if (-1 === r3.search(/^[a-zA-Z0-9=+/]+$/)) throw new Error("Invalid character in base-64 string");
                if (r3 = r3.replace(/=/g, ""), -1 !== E3 && E3 < r3.length) throw new Error("Invalid '=' found in base-64 string");
                for (o5 = 0; o5 < r3.length; o5 += 4) {
                  for (w3 = r3.substr(o5, 4), f3 = 0, u2 = 0; u2 < w3.length; u2 += 1) f3 |= n.indexOf(w3.charAt(u2)) << 18 - 6 * u2;
                  for (u2 = 0; u2 < w3.length - 1; u2 += 1) {
                    for (s4 = (a3 = h3 + v3) >>> 2; c2.length <= s4; ) c2.push(0);
                    c2[s4] |= (f3 >>> 16 - 8 * u2 & 255) << 8 * (A3 + i3 * (a3 % 4)), h3 += 1;
                  }
                }
                return { value: c2, binLen: 8 * h3 + e4 };
              })(r2, t3, e3, i2);
            };
          case "BYTES":
            return function(n2, r2, t3) {
              return (function(n3, r3, t4, e3) {
                var i3, o5, u2, f3, w3 = r3 || [0], s4 = (t4 = t4 || 0) >>> 3, a3 = -1 === e3 ? 3 : 0;
                for (o5 = 0; o5 < n3.length; o5 += 1) i3 = n3.charCodeAt(o5), u2 = (f3 = o5 + s4) >>> 2, w3.length <= u2 && w3.push(0), w3[u2] |= i3 << 8 * (a3 + e3 * (f3 % 4));
                return { value: w3, binLen: 8 * n3.length + t4 };
              })(n2, r2, t3, i2);
            };
          case "ARRAYBUFFER":
            try {
              new ArrayBuffer(0);
            } catch (n2) {
              throw new Error("ARRAYBUFFER not supported by this environment");
            }
            return function(n2, t3, e3) {
              return (function(n3, t4, e4, i3) {
                return r(new Uint8Array(n3), t4, e4, i3);
              })(n2, t3, e3, i2);
            };
          case "UINT8ARRAY":
            try {
              new Uint8Array(0);
            } catch (n2) {
              throw new Error("UINT8ARRAY not supported by this environment");
            }
            return function(n2, t3, e3) {
              return r(n2, t3, e3, i2);
            };
          default:
            throw new Error("format must be HEX, TEXT, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY");
        }
      }
      function e(r2, t2, e2, i2) {
        switch (r2) {
          case "HEX":
            return function(n2) {
              return (function(n3, r3, t3, e3) {
                var i3, o5, u2 = "", f3 = r3 / 8, w3 = -1 === t3 ? 3 : 0;
                for (i3 = 0; i3 < f3; i3 += 1) o5 = n3[i3 >>> 2] >>> 8 * (w3 + t3 * (i3 % 4)), u2 += "0123456789abcdef".charAt(o5 >>> 4 & 15) + "0123456789abcdef".charAt(15 & o5);
                return e3.outputUpper ? u2.toUpperCase() : u2;
              })(n2, t2, e2, i2);
            };
          case "B64":
            return function(r3) {
              return (function(r4, t3, e3, i3) {
                var o5, u2, f3, w3, s4, a3 = "", h3 = t3 / 8, c2 = -1 === e3 ? 3 : 0;
                for (o5 = 0; o5 < h3; o5 += 3) for (w3 = o5 + 1 < h3 ? r4[o5 + 1 >>> 2] : 0, s4 = o5 + 2 < h3 ? r4[o5 + 2 >>> 2] : 0, f3 = (r4[o5 >>> 2] >>> 8 * (c2 + e3 * (o5 % 4)) & 255) << 16 | (w3 >>> 8 * (c2 + e3 * ((o5 + 1) % 4)) & 255) << 8 | s4 >>> 8 * (c2 + e3 * ((o5 + 2) % 4)) & 255, u2 = 0; u2 < 4; u2 += 1) a3 += 8 * o5 + 6 * u2 <= t3 ? n.charAt(f3 >>> 6 * (3 - u2) & 63) : i3.b64Pad;
                return a3;
              })(r3, t2, e2, i2);
            };
          case "BYTES":
            return function(n2) {
              return (function(n3, r3, t3) {
                var e3, i3, o5 = "", u2 = r3 / 8, f3 = -1 === t3 ? 3 : 0;
                for (e3 = 0; e3 < u2; e3 += 1) i3 = n3[e3 >>> 2] >>> 8 * (f3 + t3 * (e3 % 4)) & 255, o5 += String.fromCharCode(i3);
                return o5;
              })(n2, t2, e2);
            };
          case "ARRAYBUFFER":
            try {
              new ArrayBuffer(0);
            } catch (n2) {
              throw new Error("ARRAYBUFFER not supported by this environment");
            }
            return function(n2) {
              return (function(n3, r3, t3) {
                var e3, i3 = r3 / 8, o5 = new ArrayBuffer(i3), u2 = new Uint8Array(o5), f3 = -1 === t3 ? 3 : 0;
                for (e3 = 0; e3 < i3; e3 += 1) u2[e3] = n3[e3 >>> 2] >>> 8 * (f3 + t3 * (e3 % 4)) & 255;
                return o5;
              })(n2, t2, e2);
            };
          case "UINT8ARRAY":
            try {
              new Uint8Array(0);
            } catch (n2) {
              throw new Error("UINT8ARRAY not supported by this environment");
            }
            return function(n2) {
              return (function(n3, r3, t3) {
                var e3, i3 = r3 / 8, o5 = -1 === t3 ? 3 : 0, u2 = new Uint8Array(i3);
                for (e3 = 0; e3 < i3; e3 += 1) u2[e3] = n3[e3 >>> 2] >>> 8 * (o5 + t3 * (e3 % 4)) & 255;
                return u2;
              })(n2, t2, e2);
            };
          default:
            throw new Error("format must be HEX, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY");
        }
      }
      var i = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], o4 = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428], u = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], f2 = "Chosen SHA variant is not supported";
      function w2(n2, r2) {
        var t2, e2, i2 = n2.binLen >>> 3, o5 = r2.binLen >>> 3, u2 = i2 << 3, f3 = 4 - i2 << 3;
        if (i2 % 4 != 0) {
          for (t2 = 0; t2 < o5; t2 += 4) e2 = i2 + t2 >>> 2, n2.value[e2] |= r2.value[t2 >>> 2] << u2, n2.value.push(0), n2.value[e2 + 1] |= r2.value[t2 >>> 2] >>> f3;
          return (n2.value.length << 2) - 4 >= o5 + i2 && n2.value.pop(), { value: n2.value, binLen: n2.binLen + r2.binLen };
        }
        return { value: n2.value.concat(r2.value), binLen: n2.binLen + r2.binLen };
      }
      function s2(n2) {
        var r2 = { outputUpper: false, b64Pad: "=", outputLen: -1 }, t2 = n2 || {}, e2 = "Output length must be a multiple of 8";
        if (r2.outputUpper = t2.outputUpper || false, t2.b64Pad && (r2.b64Pad = t2.b64Pad), t2.outputLen) {
          if (t2.outputLen % 8 != 0) throw new Error(e2);
          r2.outputLen = t2.outputLen;
        } else if (t2.shakeLen) {
          if (t2.shakeLen % 8 != 0) throw new Error(e2);
          r2.outputLen = t2.shakeLen;
        }
        if ("boolean" != typeof r2.outputUpper) throw new Error("Invalid outputUpper formatting option");
        if ("string" != typeof r2.b64Pad) throw new Error("Invalid b64Pad formatting option");
        return r2;
      }
      function a2(n2, r2, e2, i2) {
        var o5 = n2 + " must include a value and format";
        if (!r2) {
          if (!i2) throw new Error(o5);
          return i2;
        }
        if (void 0 === r2.value || !r2.format) throw new Error(o5);
        return t(r2.format, r2.encoding || "UTF8", e2)(r2.value);
      }
      var h2 = (function() {
        function n2(n3, r2, t2) {
          var e2 = t2 || {};
          if (this.t = r2, this.i = e2.encoding || "UTF8", this.numRounds = e2.numRounds || 1, isNaN(this.numRounds) || this.numRounds !== parseInt(this.numRounds, 10) || 1 > this.numRounds) throw new Error("numRounds must a integer >= 1");
          this.o = n3, this.u = [], this.s = 0, this.h = false, this.v = 0, this.A = false, this.l = [], this.H = [];
        }
        return n2.prototype.update = function(n3) {
          var r2, t2 = 0, e2 = this.S >>> 5, i2 = this.p(n3, this.u, this.s), o5 = i2.binLen, u2 = i2.value, f3 = o5 >>> 5;
          for (r2 = 0; r2 < f3; r2 += e2) t2 + this.S <= o5 && (this.m = this.R(u2.slice(r2, r2 + e2), this.m), t2 += this.S);
          this.v += t2, this.u = u2.slice(t2 >>> 5), this.s = o5 % this.S, this.h = true;
        }, n2.prototype.getHash = function(n3, r2) {
          var t2, i2, o5 = this.U, u2 = s2(r2);
          if (this.T) {
            if (-1 === u2.outputLen) throw new Error("Output length must be specified in options");
            o5 = u2.outputLen;
          }
          var f3 = e(n3, o5, this.C, u2);
          if (this.A && this.F) return f3(this.F(u2));
          for (i2 = this.K(this.u.slice(), this.s, this.v, this.B(this.m), o5), t2 = 1; t2 < this.numRounds; t2 += 1) this.T && o5 % 32 != 0 && (i2[i2.length - 1] &= 16777215 >>> 24 - o5 % 32), i2 = this.K(i2, o5, 0, this.L(this.o), o5);
          return f3(i2);
        }, n2.prototype.setHMACKey = function(n3, r2, e2) {
          if (!this.g) throw new Error("Variant does not support HMAC");
          if (this.h) throw new Error("Cannot set MAC key after calling update");
          var i2 = t(r2, (e2 || {}).encoding || "UTF8", this.C);
          this.k(i2(n3));
        }, n2.prototype.k = function(n3) {
          var r2, t2 = this.S >>> 3, e2 = t2 / 4 - 1;
          if (1 !== this.numRounds) throw new Error("Cannot set numRounds with MAC");
          if (this.A) throw new Error("MAC key already set");
          for (t2 < n3.binLen / 8 && (n3.value = this.K(n3.value, n3.binLen, 0, this.L(this.o), this.U)); n3.value.length <= e2; ) n3.value.push(0);
          for (r2 = 0; r2 <= e2; r2 += 1) this.l[r2] = 909522486 ^ n3.value[r2], this.H[r2] = 1549556828 ^ n3.value[r2];
          this.m = this.R(this.l, this.m), this.v = this.S, this.A = true;
        }, n2.prototype.getHMAC = function(n3, r2) {
          var t2 = s2(r2);
          return e(n3, this.U, this.C, t2)(this.Y());
        }, n2.prototype.Y = function() {
          var n3;
          if (!this.A) throw new Error("Cannot call getHMAC without first setting MAC key");
          var r2 = this.K(this.u.slice(), this.s, this.v, this.B(this.m), this.U);
          return n3 = this.R(this.H, this.L(this.o)), n3 = this.K(r2, this.U, this.S, n3, this.U);
        }, n2;
      })(), c = function(n2, r2) {
        return (c = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n3, r3) {
          n3.__proto__ = r3;
        } || function(n3, r3) {
          for (var t2 in r3) Object.prototype.hasOwnProperty.call(r3, t2) && (n3[t2] = r3[t2]);
        })(n2, r2);
      };
      function v2(n2, r2) {
        function t2() {
          this.constructor = n2;
        }
        c(n2, r2), n2.prototype = null === r2 ? Object.create(r2) : (t2.prototype = r2.prototype, new t2());
      }
      function A2(n2, r2) {
        return n2 << r2 | n2 >>> 32 - r2;
      }
      function E2(n2, r2) {
        return n2 >>> r2 | n2 << 32 - r2;
      }
      function l(n2, r2) {
        return n2 >>> r2;
      }
      function b2(n2, r2, t2) {
        return n2 ^ r2 ^ t2;
      }
      function H2(n2, r2, t2) {
        return n2 & r2 ^ ~n2 & t2;
      }
      function d(n2, r2, t2) {
        return n2 & r2 ^ n2 & t2 ^ r2 & t2;
      }
      function S2(n2) {
        return E2(n2, 2) ^ E2(n2, 13) ^ E2(n2, 22);
      }
      function p2(n2, r2) {
        var t2 = (65535 & n2) + (65535 & r2);
        return (65535 & (n2 >>> 16) + (r2 >>> 16) + (t2 >>> 16)) << 16 | 65535 & t2;
      }
      function m2(n2, r2, t2, e2) {
        var i2 = (65535 & n2) + (65535 & r2) + (65535 & t2) + (65535 & e2);
        return (65535 & (n2 >>> 16) + (r2 >>> 16) + (t2 >>> 16) + (e2 >>> 16) + (i2 >>> 16)) << 16 | 65535 & i2;
      }
      function y2(n2, r2, t2, e2, i2) {
        var o5 = (65535 & n2) + (65535 & r2) + (65535 & t2) + (65535 & e2) + (65535 & i2);
        return (65535 & (n2 >>> 16) + (r2 >>> 16) + (t2 >>> 16) + (e2 >>> 16) + (i2 >>> 16) + (o5 >>> 16)) << 16 | 65535 & o5;
      }
      function R2(n2) {
        return E2(n2, 7) ^ E2(n2, 18) ^ l(n2, 3);
      }
      function U2(n2) {
        return E2(n2, 6) ^ E2(n2, 11) ^ E2(n2, 25);
      }
      function T10(n2) {
        return [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      }
      function C2(n2, r2) {
        var t2, e2, i2, o5, u2, f3, w3, s4 = [];
        for (t2 = r2[0], e2 = r2[1], i2 = r2[2], o5 = r2[3], u2 = r2[4], w3 = 0; w3 < 80; w3 += 1) s4[w3] = w3 < 16 ? n2[w3] : A2(s4[w3 - 3] ^ s4[w3 - 8] ^ s4[w3 - 14] ^ s4[w3 - 16], 1), f3 = w3 < 20 ? y2(A2(t2, 5), H2(e2, i2, o5), u2, 1518500249, s4[w3]) : w3 < 40 ? y2(A2(t2, 5), b2(e2, i2, o5), u2, 1859775393, s4[w3]) : w3 < 60 ? y2(A2(t2, 5), d(e2, i2, o5), u2, 2400959708, s4[w3]) : y2(A2(t2, 5), b2(e2, i2, o5), u2, 3395469782, s4[w3]), u2 = o5, o5 = i2, i2 = A2(e2, 30), e2 = t2, t2 = f3;
        return r2[0] = p2(t2, r2[0]), r2[1] = p2(e2, r2[1]), r2[2] = p2(i2, r2[2]), r2[3] = p2(o5, r2[3]), r2[4] = p2(u2, r2[4]), r2;
      }
      function F2(n2, r2, t2, e2) {
        for (var i2, o5 = 15 + (r2 + 65 >>> 9 << 4), u2 = r2 + t2; n2.length <= o5; ) n2.push(0);
        for (n2[r2 >>> 5] |= 128 << 24 - r2 % 32, n2[o5] = 4294967295 & u2, n2[o5 - 1] = u2 / 4294967296 | 0, i2 = 0; i2 < n2.length; i2 += 16) e2 = C2(n2.slice(i2, i2 + 16), e2);
        return e2;
      }
      var K2 = (function(n2) {
        function r2(r3, e2, i2) {
          var o5 = this;
          if ("SHA-1" !== r3) throw new Error(f2);
          var u2 = i2 || {};
          return (o5 = n2.call(this, r3, e2, i2) || this).g = true, o5.F = o5.Y, o5.C = -1, o5.p = t(o5.t, o5.i, o5.C), o5.R = C2, o5.B = function(n3) {
            return n3.slice();
          }, o5.L = T10, o5.K = F2, o5.m = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], o5.S = 512, o5.U = 160, o5.T = false, u2.hmacKey && o5.k(a2("hmacKey", u2.hmacKey, o5.C)), o5;
        }
        return v2(r2, n2), r2;
      })(h2);
      function B2(n2) {
        return "SHA-224" == n2 ? o4.slice() : u.slice();
      }
      function L(n2, r2) {
        var t2, e2, o5, u2, f3, w3, s4, a3, h3, c2, v3, A3, b3 = [];
        for (t2 = r2[0], e2 = r2[1], o5 = r2[2], u2 = r2[3], f3 = r2[4], w3 = r2[5], s4 = r2[6], a3 = r2[7], v3 = 0; v3 < 64; v3 += 1) b3[v3] = v3 < 16 ? n2[v3] : m2(E2(A3 = b3[v3 - 2], 17) ^ E2(A3, 19) ^ l(A3, 10), b3[v3 - 7], R2(b3[v3 - 15]), b3[v3 - 16]), h3 = y2(a3, U2(f3), H2(f3, w3, s4), i[v3], b3[v3]), c2 = p2(S2(t2), d(t2, e2, o5)), a3 = s4, s4 = w3, w3 = f3, f3 = p2(u2, h3), u2 = o5, o5 = e2, e2 = t2, t2 = p2(h3, c2);
        return r2[0] = p2(t2, r2[0]), r2[1] = p2(e2, r2[1]), r2[2] = p2(o5, r2[2]), r2[3] = p2(u2, r2[3]), r2[4] = p2(f3, r2[4]), r2[5] = p2(w3, r2[5]), r2[6] = p2(s4, r2[6]), r2[7] = p2(a3, r2[7]), r2;
      }
      var g2 = (function(n2) {
        function r2(r3, e2, i2) {
          var o5 = this;
          if ("SHA-224" !== r3 && "SHA-256" !== r3) throw new Error(f2);
          var u2 = i2 || {};
          return (o5 = n2.call(this, r3, e2, i2) || this).F = o5.Y, o5.g = true, o5.C = -1, o5.p = t(o5.t, o5.i, o5.C), o5.R = L, o5.B = function(n3) {
            return n3.slice();
          }, o5.L = B2, o5.K = function(n3, t2, e3, i3) {
            return (function(n4, r4, t3, e4, i4) {
              for (var o6, u3 = 15 + (r4 + 65 >>> 9 << 4), f3 = r4 + t3; n4.length <= u3; ) n4.push(0);
              for (n4[r4 >>> 5] |= 128 << 24 - r4 % 32, n4[u3] = 4294967295 & f3, n4[u3 - 1] = f3 / 4294967296 | 0, o6 = 0; o6 < n4.length; o6 += 16) e4 = L(n4.slice(o6, o6 + 16), e4);
              return "SHA-224" === i4 ? [e4[0], e4[1], e4[2], e4[3], e4[4], e4[5], e4[6]] : e4;
            })(n3, t2, e3, i3, r3);
          }, o5.m = B2(r3), o5.S = 512, o5.U = "SHA-224" === r3 ? 224 : 256, o5.T = false, u2.hmacKey && o5.k(a2("hmacKey", u2.hmacKey, o5.C)), o5;
        }
        return v2(r2, n2), r2;
      })(h2), k2 = function(n2, r2) {
        this.N = n2, this.I = r2;
      };
      function Y(n2, r2) {
        var t2;
        return r2 > 32 ? (t2 = 64 - r2, new k2(n2.I << r2 | n2.N >>> t2, n2.N << r2 | n2.I >>> t2)) : 0 !== r2 ? (t2 = 32 - r2, new k2(n2.N << r2 | n2.I >>> t2, n2.I << r2 | n2.N >>> t2)) : n2;
      }
      function N2(n2, r2) {
        var t2;
        return r2 < 32 ? (t2 = 32 - r2, new k2(n2.N >>> r2 | n2.I << t2, n2.I >>> r2 | n2.N << t2)) : (t2 = 64 - r2, new k2(n2.I >>> r2 | n2.N << t2, n2.N >>> r2 | n2.I << t2));
      }
      function I2(n2, r2) {
        return new k2(n2.N >>> r2, n2.I >>> r2 | n2.N << 32 - r2);
      }
      function M2(n2, r2, t2) {
        return new k2(n2.N & r2.N ^ ~n2.N & t2.N, n2.I & r2.I ^ ~n2.I & t2.I);
      }
      function X2(n2, r2, t2) {
        return new k2(n2.N & r2.N ^ n2.N & t2.N ^ r2.N & t2.N, n2.I & r2.I ^ n2.I & t2.I ^ r2.I & t2.I);
      }
      function z2(n2) {
        var r2 = N2(n2, 28), t2 = N2(n2, 34), e2 = N2(n2, 39);
        return new k2(r2.N ^ t2.N ^ e2.N, r2.I ^ t2.I ^ e2.I);
      }
      function O2(n2, r2) {
        var t2, e2;
        t2 = (65535 & n2.I) + (65535 & r2.I);
        var i2 = (65535 & (e2 = (n2.I >>> 16) + (r2.I >>> 16) + (t2 >>> 16))) << 16 | 65535 & t2;
        return t2 = (65535 & n2.N) + (65535 & r2.N) + (e2 >>> 16), e2 = (n2.N >>> 16) + (r2.N >>> 16) + (t2 >>> 16), new k2((65535 & e2) << 16 | 65535 & t2, i2);
      }
      function j2(n2, r2, t2, e2) {
        var i2, o5;
        i2 = (65535 & n2.I) + (65535 & r2.I) + (65535 & t2.I) + (65535 & e2.I);
        var u2 = (65535 & (o5 = (n2.I >>> 16) + (r2.I >>> 16) + (t2.I >>> 16) + (e2.I >>> 16) + (i2 >>> 16))) << 16 | 65535 & i2;
        return i2 = (65535 & n2.N) + (65535 & r2.N) + (65535 & t2.N) + (65535 & e2.N) + (o5 >>> 16), o5 = (n2.N >>> 16) + (r2.N >>> 16) + (t2.N >>> 16) + (e2.N >>> 16) + (i2 >>> 16), new k2((65535 & o5) << 16 | 65535 & i2, u2);
      }
      function _(n2, r2, t2, e2, i2) {
        var o5, u2;
        o5 = (65535 & n2.I) + (65535 & r2.I) + (65535 & t2.I) + (65535 & e2.I) + (65535 & i2.I);
        var f3 = (65535 & (u2 = (n2.I >>> 16) + (r2.I >>> 16) + (t2.I >>> 16) + (e2.I >>> 16) + (i2.I >>> 16) + (o5 >>> 16))) << 16 | 65535 & o5;
        return o5 = (65535 & n2.N) + (65535 & r2.N) + (65535 & t2.N) + (65535 & e2.N) + (65535 & i2.N) + (u2 >>> 16), u2 = (n2.N >>> 16) + (r2.N >>> 16) + (t2.N >>> 16) + (e2.N >>> 16) + (i2.N >>> 16) + (o5 >>> 16), new k2((65535 & u2) << 16 | 65535 & o5, f3);
      }
      function P2(n2, r2) {
        return new k2(n2.N ^ r2.N, n2.I ^ r2.I);
      }
      function x2(n2) {
        var r2 = N2(n2, 1), t2 = N2(n2, 8), e2 = I2(n2, 7);
        return new k2(r2.N ^ t2.N ^ e2.N, r2.I ^ t2.I ^ e2.I);
      }
      function V2(n2) {
        var r2 = N2(n2, 14), t2 = N2(n2, 18), e2 = N2(n2, 41);
        return new k2(r2.N ^ t2.N ^ e2.N, r2.I ^ t2.I ^ e2.I);
      }
      var Z2 = [new k2(i[0], 3609767458), new k2(i[1], 602891725), new k2(i[2], 3964484399), new k2(i[3], 2173295548), new k2(i[4], 4081628472), new k2(i[5], 3053834265), new k2(i[6], 2937671579), new k2(i[7], 3664609560), new k2(i[8], 2734883394), new k2(i[9], 1164996542), new k2(i[10], 1323610764), new k2(i[11], 3590304994), new k2(i[12], 4068182383), new k2(i[13], 991336113), new k2(i[14], 633803317), new k2(i[15], 3479774868), new k2(i[16], 2666613458), new k2(i[17], 944711139), new k2(i[18], 2341262773), new k2(i[19], 2007800933), new k2(i[20], 1495990901), new k2(i[21], 1856431235), new k2(i[22], 3175218132), new k2(i[23], 2198950837), new k2(i[24], 3999719339), new k2(i[25], 766784016), new k2(i[26], 2566594879), new k2(i[27], 3203337956), new k2(i[28], 1034457026), new k2(i[29], 2466948901), new k2(i[30], 3758326383), new k2(i[31], 168717936), new k2(i[32], 1188179964), new k2(i[33], 1546045734), new k2(i[34], 1522805485), new k2(i[35], 2643833823), new k2(i[36], 2343527390), new k2(i[37], 1014477480), new k2(i[38], 1206759142), new k2(i[39], 344077627), new k2(i[40], 1290863460), new k2(i[41], 3158454273), new k2(i[42], 3505952657), new k2(i[43], 106217008), new k2(i[44], 3606008344), new k2(i[45], 1432725776), new k2(i[46], 1467031594), new k2(i[47], 851169720), new k2(i[48], 3100823752), new k2(i[49], 1363258195), new k2(i[50], 3750685593), new k2(i[51], 3785050280), new k2(i[52], 3318307427), new k2(i[53], 3812723403), new k2(i[54], 2003034995), new k2(i[55], 3602036899), new k2(i[56], 1575990012), new k2(i[57], 1125592928), new k2(i[58], 2716904306), new k2(i[59], 442776044), new k2(i[60], 593698344), new k2(i[61], 3733110249), new k2(i[62], 2999351573), new k2(i[63], 3815920427), new k2(3391569614, 3928383900), new k2(3515267271, 566280711), new k2(3940187606, 3454069534), new k2(4118630271, 4000239992), new k2(116418474, 1914138554), new k2(174292421, 2731055270), new k2(289380356, 3203993006), new k2(460393269, 320620315), new k2(685471733, 587496836), new k2(852142971, 1086792851), new k2(1017036298, 365543100), new k2(1126000580, 2618297676), new k2(1288033470, 3409855158), new k2(1501505948, 4234509866), new k2(1607167915, 987167468), new k2(1816402316, 1246189591)];
      function q(n2) {
        return "SHA-384" === n2 ? [new k2(3418070365, o4[0]), new k2(1654270250, o4[1]), new k2(2438529370, o4[2]), new k2(355462360, o4[3]), new k2(1731405415, o4[4]), new k2(41048885895, o4[5]), new k2(3675008525, o4[6]), new k2(1203062813, o4[7])] : [new k2(u[0], 4089235720), new k2(u[1], 2227873595), new k2(u[2], 4271175723), new k2(u[3], 1595750129), new k2(u[4], 2917565137), new k2(u[5], 725511199), new k2(u[6], 4215389547), new k2(u[7], 327033209)];
      }
      function D2(n2, r2) {
        var t2, e2, i2, o5, u2, f3, w3, s4, a3, h3, c2, v3, A3, E3, l2, b3, H3 = [];
        for (t2 = r2[0], e2 = r2[1], i2 = r2[2], o5 = r2[3], u2 = r2[4], f3 = r2[5], w3 = r2[6], s4 = r2[7], c2 = 0; c2 < 80; c2 += 1) c2 < 16 ? (v3 = 2 * c2, H3[c2] = new k2(n2[v3], n2[v3 + 1])) : H3[c2] = j2((A3 = H3[c2 - 2], E3 = void 0, l2 = void 0, b3 = void 0, E3 = N2(A3, 19), l2 = N2(A3, 61), b3 = I2(A3, 6), new k2(E3.N ^ l2.N ^ b3.N, E3.I ^ l2.I ^ b3.I)), H3[c2 - 7], x2(H3[c2 - 15]), H3[c2 - 16]), a3 = _(s4, V2(u2), M2(u2, f3, w3), Z2[c2], H3[c2]), h3 = O2(z2(t2), X2(t2, e2, i2)), s4 = w3, w3 = f3, f3 = u2, u2 = O2(o5, a3), o5 = i2, i2 = e2, e2 = t2, t2 = O2(a3, h3);
        return r2[0] = O2(t2, r2[0]), r2[1] = O2(e2, r2[1]), r2[2] = O2(i2, r2[2]), r2[3] = O2(o5, r2[3]), r2[4] = O2(u2, r2[4]), r2[5] = O2(f3, r2[5]), r2[6] = O2(w3, r2[6]), r2[7] = O2(s4, r2[7]), r2;
      }
      var G2 = (function(n2) {
        function r2(r3, e2, i2) {
          var o5 = this;
          if ("SHA-384" !== r3 && "SHA-512" !== r3) throw new Error(f2);
          var u2 = i2 || {};
          return (o5 = n2.call(this, r3, e2, i2) || this).F = o5.Y, o5.g = true, o5.C = -1, o5.p = t(o5.t, o5.i, o5.C), o5.R = D2, o5.B = function(n3) {
            return n3.slice();
          }, o5.L = q, o5.K = function(n3, t2, e3, i3) {
            return (function(n4, r4, t3, e4, i4) {
              for (var o6, u3 = 31 + (r4 + 129 >>> 10 << 5), f3 = r4 + t3; n4.length <= u3; ) n4.push(0);
              for (n4[r4 >>> 5] |= 128 << 24 - r4 % 32, n4[u3] = 4294967295 & f3, n4[u3 - 1] = f3 / 4294967296 | 0, o6 = 0; o6 < n4.length; o6 += 32) e4 = D2(n4.slice(o6, o6 + 32), e4);
              return "SHA-384" === i4 ? [(e4 = e4)[0].N, e4[0].I, e4[1].N, e4[1].I, e4[2].N, e4[2].I, e4[3].N, e4[3].I, e4[4].N, e4[4].I, e4[5].N, e4[5].I] : [e4[0].N, e4[0].I, e4[1].N, e4[1].I, e4[2].N, e4[2].I, e4[3].N, e4[3].I, e4[4].N, e4[4].I, e4[5].N, e4[5].I, e4[6].N, e4[6].I, e4[7].N, e4[7].I];
            })(n3, t2, e3, i3, r3);
          }, o5.m = q(r3), o5.S = 1024, o5.U = "SHA-384" === r3 ? 384 : 512, o5.T = false, u2.hmacKey && o5.k(a2("hmacKey", u2.hmacKey, o5.C)), o5;
        }
        return v2(r2, n2), r2;
      })(h2), J2 = [new k2(0, 1), new k2(0, 32898), new k2(2147483648, 32906), new k2(2147483648, 2147516416), new k2(0, 32907), new k2(0, 2147483649), new k2(2147483648, 2147516545), new k2(2147483648, 32777), new k2(0, 138), new k2(0, 136), new k2(0, 2147516425), new k2(0, 2147483658), new k2(0, 2147516555), new k2(2147483648, 139), new k2(2147483648, 32905), new k2(2147483648, 32771), new k2(2147483648, 32770), new k2(2147483648, 128), new k2(0, 32778), new k2(2147483648, 2147483658), new k2(2147483648, 2147516545), new k2(2147483648, 32896), new k2(0, 2147483649), new k2(2147483648, 2147516424)], Q2 = [[0, 36, 3, 41, 18], [1, 44, 10, 45, 2], [62, 6, 43, 15, 61], [28, 55, 25, 21, 56], [27, 20, 39, 8, 14]];
      function W2(n2) {
        var r2, t2 = [];
        for (r2 = 0; r2 < 5; r2 += 1) t2[r2] = [new k2(0, 0), new k2(0, 0), new k2(0, 0), new k2(0, 0), new k2(0, 0)];
        return t2;
      }
      function $2(n2) {
        var r2, t2 = [];
        for (r2 = 0; r2 < 5; r2 += 1) t2[r2] = n2[r2].slice();
        return t2;
      }
      function nn2(n2, r2) {
        var t2, e2, i2, o5, u2, f3, w3, s4, a3, h3 = [], c2 = [];
        if (null !== n2) for (e2 = 0; e2 < n2.length; e2 += 2) r2[(e2 >>> 1) % 5][(e2 >>> 1) / 5 | 0] = P2(r2[(e2 >>> 1) % 5][(e2 >>> 1) / 5 | 0], new k2(n2[e2 + 1], n2[e2]));
        for (t2 = 0; t2 < 24; t2 += 1) {
          for (o5 = W2(), e2 = 0; e2 < 5; e2 += 1) h3[e2] = (u2 = r2[e2][0], f3 = r2[e2][1], w3 = r2[e2][2], s4 = r2[e2][3], a3 = r2[e2][4], new k2(u2.N ^ f3.N ^ w3.N ^ s4.N ^ a3.N, u2.I ^ f3.I ^ w3.I ^ s4.I ^ a3.I));
          for (e2 = 0; e2 < 5; e2 += 1) c2[e2] = P2(h3[(e2 + 4) % 5], Y(h3[(e2 + 1) % 5], 1));
          for (e2 = 0; e2 < 5; e2 += 1) for (i2 = 0; i2 < 5; i2 += 1) r2[e2][i2] = P2(r2[e2][i2], c2[e2]);
          for (e2 = 0; e2 < 5; e2 += 1) for (i2 = 0; i2 < 5; i2 += 1) o5[i2][(2 * e2 + 3 * i2) % 5] = Y(r2[e2][i2], Q2[e2][i2]);
          for (e2 = 0; e2 < 5; e2 += 1) for (i2 = 0; i2 < 5; i2 += 1) r2[e2][i2] = P2(o5[e2][i2], new k2(~o5[(e2 + 1) % 5][i2].N & o5[(e2 + 2) % 5][i2].N, ~o5[(e2 + 1) % 5][i2].I & o5[(e2 + 2) % 5][i2].I));
          r2[0][0] = P2(r2[0][0], J2[t2]);
        }
        return r2;
      }
      function rn2(n2) {
        var r2, t2, e2 = 0, i2 = [0, 0], o5 = [4294967295 & n2, n2 / 4294967296 & 2097151];
        for (r2 = 6; r2 >= 0; r2--) 0 === (t2 = o5[r2 >> 2] >>> 8 * r2 & 255) && 0 === e2 || (i2[e2 + 1 >> 2] |= t2 << 8 * (e2 + 1), e2 += 1);
        return e2 = 0 !== e2 ? e2 : 1, i2[0] |= e2, { value: e2 + 1 > 4 ? i2 : [i2[0]], binLen: 8 + 8 * e2 };
      }
      function tn2(n2) {
        return w2(rn2(n2.binLen), n2);
      }
      function en2(n2, r2) {
        var t2, e2 = rn2(r2), i2 = r2 >>> 2, o5 = (i2 - (e2 = w2(e2, n2)).value.length % i2) % i2;
        for (t2 = 0; t2 < o5; t2++) e2.value.push(0);
        return e2.value;
      }
      var on2 = (function(n2) {
        function r2(r3, e2, i2) {
          var o5 = this, u2 = 6, w3 = 0, s4 = i2 || {};
          if (1 !== (o5 = n2.call(this, r3, e2, i2) || this).numRounds) {
            if (s4.kmacKey || s4.hmacKey) throw new Error("Cannot set numRounds with MAC");
            if ("CSHAKE128" === o5.o || "CSHAKE256" === o5.o) throw new Error("Cannot set numRounds for CSHAKE variants");
          }
          switch (o5.C = 1, o5.p = t(o5.t, o5.i, o5.C), o5.R = nn2, o5.B = $2, o5.L = W2, o5.m = W2(), o5.T = false, r3) {
            case "SHA3-224":
              o5.S = w3 = 1152, o5.U = 224, o5.g = true, o5.F = o5.Y;
              break;
            case "SHA3-256":
              o5.S = w3 = 1088, o5.U = 256, o5.g = true, o5.F = o5.Y;
              break;
            case "SHA3-384":
              o5.S = w3 = 832, o5.U = 384, o5.g = true, o5.F = o5.Y;
              break;
            case "SHA3-512":
              o5.S = w3 = 576, o5.U = 512, o5.g = true, o5.F = o5.Y;
              break;
            case "SHAKE128":
              u2 = 31, o5.S = w3 = 1344, o5.U = -1, o5.T = true, o5.g = false, o5.F = null;
              break;
            case "SHAKE256":
              u2 = 31, o5.S = w3 = 1088, o5.U = -1, o5.T = true, o5.g = false, o5.F = null;
              break;
            case "KMAC128":
              u2 = 4, o5.S = w3 = 1344, o5.M(i2), o5.U = -1, o5.T = true, o5.g = false, o5.F = o5.X;
              break;
            case "KMAC256":
              u2 = 4, o5.S = w3 = 1088, o5.M(i2), o5.U = -1, o5.T = true, o5.g = false, o5.F = o5.X;
              break;
            case "CSHAKE128":
              o5.S = w3 = 1344, u2 = o5.O(i2), o5.U = -1, o5.T = true, o5.g = false, o5.F = null;
              break;
            case "CSHAKE256":
              o5.S = w3 = 1088, u2 = o5.O(i2), o5.U = -1, o5.T = true, o5.g = false, o5.F = null;
              break;
            default:
              throw new Error(f2);
          }
          return o5.K = function(n3, r4, t2, e3, i3) {
            return (function(n4, r5, t3, e4, i4, o6, u3) {
              var f3, w4, s5 = 0, a3 = [], h3 = i4 >>> 5, c2 = r5 >>> 5;
              for (f3 = 0; f3 < c2 && r5 >= i4; f3 += h3) e4 = nn2(n4.slice(f3, f3 + h3), e4), r5 -= i4;
              for (n4 = n4.slice(f3), r5 %= i4; n4.length < h3; ) n4.push(0);
              for (n4[(f3 = r5 >>> 3) >> 2] ^= o6 << f3 % 4 * 8, n4[h3 - 1] ^= 2147483648, e4 = nn2(n4, e4); 32 * a3.length < u3 && (w4 = e4[s5 % 5][s5 / 5 | 0], a3.push(w4.I), !(32 * a3.length >= u3)); ) a3.push(w4.N), 0 == 64 * (s5 += 1) % i4 && (nn2(null, e4), s5 = 0);
              return a3;
            })(n3, r4, 0, e3, w3, u2, i3);
          }, s4.hmacKey && o5.k(a2("hmacKey", s4.hmacKey, o5.C)), o5;
        }
        return v2(r2, n2), r2.prototype.O = function(n3, r3) {
          var t2 = (function(n4) {
            var r4 = n4 || {};
            return { funcName: a2("funcName", r4.funcName, 1, { value: [], binLen: 0 }), customization: a2("Customization", r4.customization, 1, { value: [], binLen: 0 }) };
          })(n3 || {});
          r3 && (t2.funcName = r3);
          var e2 = w2(tn2(t2.funcName), tn2(t2.customization));
          if (0 !== t2.customization.binLen || 0 !== t2.funcName.binLen) {
            for (var i2 = en2(e2, this.S >>> 3), o5 = 0; o5 < i2.length; o5 += this.S >>> 5) this.m = this.R(i2.slice(o5, o5 + (this.S >>> 5)), this.m), this.v += this.S;
            return 4;
          }
          return 31;
        }, r2.prototype.M = function(n3) {
          var r3 = (function(n4) {
            var r4 = n4 || {};
            return { kmacKey: a2("kmacKey", r4.kmacKey, 1), funcName: { value: [1128353099], binLen: 32 }, customization: a2("Customization", r4.customization, 1, { value: [], binLen: 0 }) };
          })(n3 || {});
          this.O(n3, r3.funcName);
          for (var t2 = en2(tn2(r3.kmacKey), this.S >>> 3), e2 = 0; e2 < t2.length; e2 += this.S >>> 5) this.m = this.R(t2.slice(e2, e2 + (this.S >>> 5)), this.m), this.v += this.S;
          this.A = true;
        }, r2.prototype.X = function(n3) {
          var r3 = w2({ value: this.u.slice(), binLen: this.s }, (function(n4) {
            var r4, t2, e2 = 0, i2 = [0, 0], o5 = [4294967295 & n4, n4 / 4294967296 & 2097151];
            for (r4 = 6; r4 >= 0; r4--) 0 == (t2 = o5[r4 >> 2] >>> 8 * r4 & 255) && 0 === e2 || (i2[e2 >> 2] |= t2 << 8 * e2, e2 += 1);
            return i2[(e2 = 0 !== e2 ? e2 : 1) >> 2] |= e2 << 8 * e2, { value: e2 + 1 > 4 ? i2 : [i2[0]], binLen: 8 + 8 * e2 };
          })(n3.outputLen));
          return this.K(r3.value, r3.binLen, this.v, this.B(this.m), n3.outputLen);
        }, r2;
      })(h2);
      return (function() {
        function n2(n3, r2, t2) {
          if ("SHA-1" == n3) this.j = new K2(n3, r2, t2);
          else if ("SHA-224" == n3 || "SHA-256" == n3) this.j = new g2(n3, r2, t2);
          else if ("SHA-384" == n3 || "SHA-512" == n3) this.j = new G2(n3, r2, t2);
          else {
            if ("SHA3-224" != n3 && "SHA3-256" != n3 && "SHA3-384" != n3 && "SHA3-512" != n3 && "SHAKE128" != n3 && "SHAKE256" != n3 && "CSHAKE128" != n3 && "CSHAKE256" != n3 && "KMAC128" != n3 && "KMAC256" != n3) throw new Error(f2);
            this.j = new on2(n3, r2, t2);
          }
        }
        return n2.prototype.update = function(n3) {
          this.j.update(n3);
        }, n2.prototype.getHash = function(n3, r2) {
          return this.j.getHash(n3, r2);
        }, n2.prototype.setHMACKey = function(n3, r2, t2) {
          this.j.setHMACKey(n3, r2, t2);
        }, n2.prototype.getHMAC = function(n3, r2) {
          return this.j.getHMAC(n3, r2);
        }, n2;
      })();
    }));
  })(sha$1);
  return sha$1.exports;
}
var native = {};
var getSecureRandom$1 = {};
const empty = {};
const empty$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: empty
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$4 = /* @__PURE__ */ getAugmentedNamespace(empty$1);
var hasRequiredGetSecureRandom$1;
function requireGetSecureRandom$1() {
  if (hasRequiredGetSecureRandom$1) return getSecureRandom$1;
  hasRequiredGetSecureRandom$1 = 1;
  Object.defineProperty(getSecureRandom$1, "__esModule", { value: true });
  getSecureRandom$1.getSecureRandomWords = getSecureRandom$1.getSecureRandomBytes = void 0;
  const getRandomBytes = require$$0$4.getRandomBytes;
  function getSecureRandomBytes(size) {
    return Buffer.from(getRandomBytes(size));
  }
  getSecureRandom$1.getSecureRandomBytes = getSecureRandomBytes;
  function getSecureRandomWords(size) {
    const bytes = getSecureRandomBytes(size * 2);
    return new Uint16Array(bytes.buffer, bytes.byteOffset, size);
  }
  getSecureRandom$1.getSecureRandomWords = getSecureRandomWords;
  return getSecureRandom$1;
}
var hmac_sha512$1 = {};
var hasRequiredHmac_sha512$1;
function requireHmac_sha512$1() {
  if (hasRequiredHmac_sha512$1) return hmac_sha512$1;
  hasRequiredHmac_sha512$1 = 1;
  var __importDefault = hmac_sha512$1 && hmac_sha512$1.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(hmac_sha512$1, "__esModule", { value: true });
  hmac_sha512$1.hmac_sha512 = void 0;
  const jssha_1 = __importDefault(requireSha());
  async function hmac_sha5122(key2, data) {
    let keyBuffer = typeof key2 === "string" ? Buffer.from(key2, "utf-8") : key2;
    let dataBuffer = typeof data === "string" ? Buffer.from(data, "utf-8") : data;
    const shaObj = new jssha_1.default("SHA-512", "HEX", {
      hmacKey: { value: keyBuffer.toString("hex"), format: "HEX" }
    });
    shaObj.update(dataBuffer.toString("hex"));
    const hmac2 = shaObj.getHash("HEX");
    return Buffer.from(hmac2, "hex");
  }
  hmac_sha512$1.hmac_sha512 = hmac_sha5122;
  return hmac_sha512$1;
}
var pbkdf2_sha512$1 = {};
const implementation = {
  derive(password, salt, iterations, keySize, hash) {
    return window.Pbkdf2.derive(password, salt, iterations, keySize, hash);
  }
};
const pbkdf2$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: implementation
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$3 = /* @__PURE__ */ getAugmentedNamespace(pbkdf2$1);
var hasRequiredPbkdf2_sha512$1;
function requirePbkdf2_sha512$1() {
  if (hasRequiredPbkdf2_sha512$1) return pbkdf2_sha512$1;
  hasRequiredPbkdf2_sha512$1 = 1;
  Object.defineProperty(pbkdf2_sha512$1, "__esModule", { value: true });
  pbkdf2_sha512$1.pbkdf2_sha512 = void 0;
  async function pbkdf2_sha5122(key2, salt, iterations, keyLen) {
    const keyBuffer = typeof key2 === "string" ? Buffer.from(key2, "utf-8") : key2;
    const saltBuffer = typeof salt === "string" ? Buffer.from(salt, "utf-8") : salt;
    let pbkdf22 = require$$0$3.default;
    let res = await pbkdf22.derive(keyBuffer.toString("base64"), saltBuffer.toString("base64"), iterations, keyLen, "sha-512");
    return Buffer.from(res, "base64");
  }
  pbkdf2_sha512$1.pbkdf2_sha512 = pbkdf2_sha5122;
  return pbkdf2_sha512$1;
}
var sha256$1 = {};
var hasRequiredSha256$2;
function requireSha256$2() {
  if (hasRequiredSha256$2) return sha256$1;
  hasRequiredSha256$2 = 1;
  var __importDefault = sha256$1 && sha256$1.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(sha256$1, "__esModule", { value: true });
  sha256$1.sha256 = void 0;
  const jssha_1 = __importDefault(requireSha());
  async function sha2562(source) {
    let src2;
    if (typeof source === "string") {
      src2 = Buffer.from(source, "utf-8").toString("hex");
    } else {
      src2 = source.toString("hex");
    }
    let hasher = new jssha_1.default("SHA-256", "HEX");
    hasher.update(src2);
    let res = hasher.getHash("HEX");
    return Buffer.from(res, "hex");
  }
  sha256$1.sha256 = sha2562;
  return sha256$1;
}
var sha512$2 = {};
var hasRequiredSha512$2;
function requireSha512$2() {
  if (hasRequiredSha512$2) return sha512$2;
  hasRequiredSha512$2 = 1;
  var __importDefault = sha512$2 && sha512$2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(sha512$2, "__esModule", { value: true });
  sha512$2.sha512 = void 0;
  const jssha_1 = __importDefault(requireSha());
  async function sha5122(source) {
    let src2;
    if (typeof source === "string") {
      src2 = Buffer.from(source, "utf-8").toString("hex");
    } else {
      src2 = source.toString("hex");
    }
    let hasher = new jssha_1.default("SHA-512", "HEX");
    hasher.update(src2);
    let res = hasher.getHash("HEX");
    return Buffer.from(res, "hex");
  }
  sha512$2.sha512 = sha5122;
  return sha512$2;
}
var hasRequiredNative;
function requireNative() {
  if (hasRequiredNative) return native;
  hasRequiredNative = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha512 = exports.sha256 = exports.pbkdf2_sha512 = exports.hmac_sha512 = exports.getSecureRandomWords = exports.getSecureRandomBytes = void 0;
    var getSecureRandom_1 = requireGetSecureRandom$1();
    Object.defineProperty(exports, "getSecureRandomBytes", { enumerable: true, get: function() {
      return getSecureRandom_1.getSecureRandomBytes;
    } });
    Object.defineProperty(exports, "getSecureRandomWords", { enumerable: true, get: function() {
      return getSecureRandom_1.getSecureRandomWords;
    } });
    var hmac_sha512_1 = requireHmac_sha512$1();
    Object.defineProperty(exports, "hmac_sha512", { enumerable: true, get: function() {
      return hmac_sha512_1.hmac_sha512;
    } });
    var pbkdf2_sha512_1 = requirePbkdf2_sha512$1();
    Object.defineProperty(exports, "pbkdf2_sha512", { enumerable: true, get: function() {
      return pbkdf2_sha512_1.pbkdf2_sha512;
    } });
    var sha256_1 = requireSha256$2();
    Object.defineProperty(exports, "sha256", { enumerable: true, get: function() {
      return sha256_1.sha256;
    } });
    var sha512_1 = requireSha512$2();
    Object.defineProperty(exports, "sha512", { enumerable: true, get: function() {
      return sha512_1.sha512;
    } });
  })(native);
  return native;
}
var hasRequiredSha256$1;
function requireSha256$1() {
  if (hasRequiredSha256$1) return sha256$2;
  hasRequiredSha256$1 = 1;
  var __importDefault = sha256$2 && sha256$2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(sha256$2, "__esModule", { value: true });
  sha256$2.sha256 = sha256$2.sha256_fallback = sha256$2.sha256_sync = void 0;
  const jssha_1 = __importDefault(requireSha());
  const crypto_primitives_1 = requireNative();
  function sha256_sync(source) {
    let src2;
    if (typeof source === "string") {
      src2 = Buffer.from(source, "utf-8").toString("hex");
    } else {
      src2 = source.toString("hex");
    }
    let hasher = new jssha_1.default("SHA-256", "HEX");
    hasher.update(src2);
    let res = hasher.getHash("HEX");
    return Buffer.from(res, "hex");
  }
  sha256$2.sha256_sync = sha256_sync;
  async function sha256_fallback(source) {
    return sha256_sync(source);
  }
  sha256$2.sha256_fallback = sha256_fallback;
  function sha2562(source) {
    return (0, crypto_primitives_1.sha256)(source);
  }
  sha256$2.sha256 = sha2562;
  return sha256$2;
}
var sha512$1 = {};
var hasRequiredSha512$1;
function requireSha512$1() {
  if (hasRequiredSha512$1) return sha512$1;
  hasRequiredSha512$1 = 1;
  var __importDefault = sha512$1 && sha512$1.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(sha512$1, "__esModule", { value: true });
  sha512$1.sha512 = sha512$1.sha512_fallback = sha512$1.sha512_sync = void 0;
  const jssha_1 = __importDefault(requireSha());
  const crypto_primitives_1 = requireNative();
  function sha512_sync(source) {
    let src2;
    if (typeof source === "string") {
      src2 = Buffer.from(source, "utf-8").toString("hex");
    } else {
      src2 = source.toString("hex");
    }
    let hasher = new jssha_1.default("SHA-512", "HEX");
    hasher.update(src2);
    let res = hasher.getHash("HEX");
    return Buffer.from(res, "hex");
  }
  sha512$1.sha512_sync = sha512_sync;
  async function sha512_fallback(source) {
    return sha512_sync(source);
  }
  sha512$1.sha512_fallback = sha512_fallback;
  async function sha5122(source) {
    return (0, crypto_primitives_1.sha512)(source);
  }
  sha512$1.sha512 = sha5122;
  return sha512$1;
}
var pbkdf2_sha512 = {};
var hasRequiredPbkdf2_sha512;
function requirePbkdf2_sha512() {
  if (hasRequiredPbkdf2_sha512) return pbkdf2_sha512;
  hasRequiredPbkdf2_sha512 = 1;
  Object.defineProperty(pbkdf2_sha512, "__esModule", { value: true });
  pbkdf2_sha512.pbkdf2_sha512 = void 0;
  const crypto_primitives_1 = requireNative();
  function pbkdf2_sha512$12(key2, salt, iterations, keyLen) {
    return (0, crypto_primitives_1.pbkdf2_sha512)(key2, salt, iterations, keyLen);
  }
  pbkdf2_sha512.pbkdf2_sha512 = pbkdf2_sha512$12;
  return pbkdf2_sha512;
}
var hmac_sha512 = {};
var hasRequiredHmac_sha512;
function requireHmac_sha512() {
  if (hasRequiredHmac_sha512) return hmac_sha512;
  hasRequiredHmac_sha512 = 1;
  var __importDefault = hmac_sha512 && hmac_sha512.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(hmac_sha512, "__esModule", { value: true });
  hmac_sha512.hmac_sha512 = hmac_sha512.hmac_sha512_fallback = void 0;
  const jssha_1 = __importDefault(requireSha());
  const crypto_primitives_1 = requireNative();
  async function hmac_sha512_fallback(key2, data) {
    let keyBuffer = typeof key2 === "string" ? Buffer.from(key2, "utf-8") : key2;
    let dataBuffer = typeof data === "string" ? Buffer.from(data, "utf-8") : data;
    const shaObj = new jssha_1.default("SHA-512", "HEX", {
      hmacKey: { value: keyBuffer.toString("hex"), format: "HEX" }
    });
    shaObj.update(dataBuffer.toString("hex"));
    const hmac2 = shaObj.getHash("HEX");
    return Buffer.from(hmac2, "hex");
  }
  hmac_sha512.hmac_sha512_fallback = hmac_sha512_fallback;
  function hmac_sha512$12(key2, data) {
    return (0, crypto_primitives_1.hmac_sha512)(key2, data);
  }
  hmac_sha512.hmac_sha512 = hmac_sha512$12;
  return hmac_sha512;
}
var getSecureRandom = {};
var hasRequiredGetSecureRandom;
function requireGetSecureRandom() {
  if (hasRequiredGetSecureRandom) return getSecureRandom;
  hasRequiredGetSecureRandom = 1;
  Object.defineProperty(getSecureRandom, "__esModule", { value: true });
  getSecureRandom.getSecureRandomNumber = getSecureRandom.getSecureRandomWords = getSecureRandom.getSecureRandomBytes = void 0;
  const crypto_primitives_1 = requireNative();
  async function getSecureRandomBytes(size) {
    return (0, crypto_primitives_1.getSecureRandomBytes)(size);
  }
  getSecureRandom.getSecureRandomBytes = getSecureRandomBytes;
  async function getSecureRandomWords(size) {
    return getSecureRandomWords();
  }
  getSecureRandom.getSecureRandomWords = getSecureRandomWords;
  async function getSecureRandomNumber(min, max) {
    let range = max - min;
    var bitsNeeded = Math.ceil(Math.log2(range));
    if (bitsNeeded > 53) {
      throw new Error("Range is too large");
    }
    var bytesNeeded = Math.ceil(bitsNeeded / 8);
    var mask = Math.pow(2, bitsNeeded) - 1;
    while (true) {
      let res = await getSecureRandomBytes(bitsNeeded);
      let power = (bytesNeeded - 1) * 8;
      let numberValue = 0;
      for (var i = 0; i < bytesNeeded; i++) {
        numberValue += res[i] * Math.pow(2, power);
        power -= 8;
      }
      numberValue = numberValue & mask;
      if (numberValue >= range) {
        continue;
      }
      return min + numberValue;
    }
  }
  getSecureRandom.getSecureRandomNumber = getSecureRandomNumber;
  return getSecureRandom;
}
var newSecureWords = {};
var wordlist$1 = {};
var hasRequiredWordlist$1;
function requireWordlist$1() {
  if (hasRequiredWordlist$1) return wordlist$1;
  hasRequiredWordlist$1 = 1;
  Object.defineProperty(wordlist$1, "__esModule", { value: true });
  wordlist$1.wordlist = void 0;
  wordlist$1.wordlist = [
    "abacus",
    "abdomen",
    "abdominal",
    "abide",
    "abiding",
    "ability",
    "ablaze",
    "able",
    "abnormal",
    "abrasion",
    "abrasive",
    "abreast",
    "abridge",
    "abroad",
    "abruptly",
    "absence",
    "absentee",
    "absently",
    "absinthe",
    "absolute",
    "absolve",
    "abstain",
    "abstract",
    "absurd",
    "accent",
    "acclaim",
    "acclimate",
    "accompany",
    "account",
    "accuracy",
    "accurate",
    "accustom",
    "acetone",
    "achiness",
    "aching",
    "acid",
    "acorn",
    "acquaint",
    "acquire",
    "acre",
    "acrobat",
    "acronym",
    "acting",
    "action",
    "activate",
    "activator",
    "active",
    "activism",
    "activist",
    "activity",
    "actress",
    "acts",
    "acutely",
    "acuteness",
    "aeration",
    "aerobics",
    "aerosol",
    "aerospace",
    "afar",
    "affair",
    "affected",
    "affecting",
    "affection",
    "affidavit",
    "affiliate",
    "affirm",
    "affix",
    "afflicted",
    "affluent",
    "afford",
    "affront",
    "aflame",
    "afloat",
    "aflutter",
    "afoot",
    "afraid",
    "afterglow",
    "afterlife",
    "aftermath",
    "aftermost",
    "afternoon",
    "aged",
    "ageless",
    "agency",
    "agenda",
    "agent",
    "aggregate",
    "aghast",
    "agile",
    "agility",
    "aging",
    "agnostic",
    "agonize",
    "agonizing",
    "agony",
    "agreeable",
    "agreeably",
    "agreed",
    "agreeing",
    "agreement",
    "aground",
    "ahead",
    "ahoy",
    "aide",
    "aids",
    "aim",
    "ajar",
    "alabaster",
    "alarm",
    "albatross",
    "album",
    "alfalfa",
    "algebra",
    "algorithm",
    "alias",
    "alibi",
    "alienable",
    "alienate",
    "aliens",
    "alike",
    "alive",
    "alkaline",
    "alkalize",
    "almanac",
    "almighty",
    "almost",
    "aloe",
    "aloft",
    "aloha",
    "alone",
    "alongside",
    "aloof",
    "alphabet",
    "alright",
    "although",
    "altitude",
    "alto",
    "aluminum",
    "alumni",
    "always",
    "amaretto",
    "amaze",
    "amazingly",
    "amber",
    "ambiance",
    "ambiguity",
    "ambiguous",
    "ambition",
    "ambitious",
    "ambulance",
    "ambush",
    "amendable",
    "amendment",
    "amends",
    "amenity",
    "amiable",
    "amicably",
    "amid",
    "amigo",
    "amino",
    "amiss",
    "ammonia",
    "ammonium",
    "amnesty",
    "amniotic",
    "among",
    "amount",
    "amperage",
    "ample",
    "amplifier",
    "amplify",
    "amply",
    "amuck",
    "amulet",
    "amusable",
    "amused",
    "amusement",
    "amuser",
    "amusing",
    "anaconda",
    "anaerobic",
    "anagram",
    "anatomist",
    "anatomy",
    "anchor",
    "anchovy",
    "ancient",
    "android",
    "anemia",
    "anemic",
    "aneurism",
    "anew",
    "angelfish",
    "angelic",
    "anger",
    "angled",
    "angler",
    "angles",
    "angling",
    "angrily",
    "angriness",
    "anguished",
    "angular",
    "animal",
    "animate",
    "animating",
    "animation",
    "animator",
    "anime",
    "animosity",
    "ankle",
    "annex",
    "annotate",
    "announcer",
    "annoying",
    "annually",
    "annuity",
    "anointer",
    "another",
    "answering",
    "antacid",
    "antarctic",
    "anteater",
    "antelope",
    "antennae",
    "anthem",
    "anthill",
    "anthology",
    "antibody",
    "antics",
    "antidote",
    "antihero",
    "antiquely",
    "antiques",
    "antiquity",
    "antirust",
    "antitoxic",
    "antitrust",
    "antiviral",
    "antivirus",
    "antler",
    "antonym",
    "antsy",
    "anvil",
    "anybody",
    "anyhow",
    "anymore",
    "anyone",
    "anyplace",
    "anything",
    "anytime",
    "anyway",
    "anywhere",
    "aorta",
    "apache",
    "apostle",
    "appealing",
    "appear",
    "appease",
    "appeasing",
    "appendage",
    "appendix",
    "appetite",
    "appetizer",
    "applaud",
    "applause",
    "apple",
    "appliance",
    "applicant",
    "applied",
    "apply",
    "appointee",
    "appraisal",
    "appraiser",
    "apprehend",
    "approach",
    "approval",
    "approve",
    "apricot",
    "april",
    "apron",
    "aptitude",
    "aptly",
    "aqua",
    "aqueduct",
    "arbitrary",
    "arbitrate",
    "ardently",
    "area",
    "arena",
    "arguable",
    "arguably",
    "argue",
    "arise",
    "armadillo",
    "armband",
    "armchair",
    "armed",
    "armful",
    "armhole",
    "arming",
    "armless",
    "armoire",
    "armored",
    "armory",
    "armrest",
    "army",
    "aroma",
    "arose",
    "around",
    "arousal",
    "arrange",
    "array",
    "arrest",
    "arrival",
    "arrive",
    "arrogance",
    "arrogant",
    "arson",
    "art",
    "ascend",
    "ascension",
    "ascent",
    "ascertain",
    "ashamed",
    "ashen",
    "ashes",
    "ashy",
    "aside",
    "askew",
    "asleep",
    "asparagus",
    "aspect",
    "aspirate",
    "aspire",
    "aspirin",
    "astonish",
    "astound",
    "astride",
    "astrology",
    "astronaut",
    "astronomy",
    "astute",
    "atlantic",
    "atlas",
    "atom",
    "atonable",
    "atop",
    "atrium",
    "atrocious",
    "atrophy",
    "attach",
    "attain",
    "attempt",
    "attendant",
    "attendee",
    "attention",
    "attentive",
    "attest",
    "attic",
    "attire",
    "attitude",
    "attractor",
    "attribute",
    "atypical",
    "auction",
    "audacious",
    "audacity",
    "audible",
    "audibly",
    "audience",
    "audio",
    "audition",
    "augmented",
    "august",
    "authentic",
    "author",
    "autism",
    "autistic",
    "autograph",
    "automaker",
    "automated",
    "automatic",
    "autopilot",
    "available",
    "avalanche",
    "avatar",
    "avenge",
    "avenging",
    "avenue",
    "average",
    "aversion",
    "avert",
    "aviation",
    "aviator",
    "avid",
    "avoid",
    "await",
    "awaken",
    "award",
    "aware",
    "awhile",
    "awkward",
    "awning",
    "awoke",
    "awry",
    "axis",
    "babble",
    "babbling",
    "babied",
    "baboon",
    "backache",
    "backboard",
    "backboned",
    "backdrop",
    "backed",
    "backer",
    "backfield",
    "backfire",
    "backhand",
    "backing",
    "backlands",
    "backlash",
    "backless",
    "backlight",
    "backlit",
    "backlog",
    "backpack",
    "backpedal",
    "backrest",
    "backroom",
    "backshift",
    "backside",
    "backslid",
    "backspace",
    "backspin",
    "backstab",
    "backstage",
    "backtalk",
    "backtrack",
    "backup",
    "backward",
    "backwash",
    "backwater",
    "backyard",
    "bacon",
    "bacteria",
    "bacterium",
    "badass",
    "badge",
    "badland",
    "badly",
    "badness",
    "baffle",
    "baffling",
    "bagel",
    "bagful",
    "baggage",
    "bagged",
    "baggie",
    "bagginess",
    "bagging",
    "baggy",
    "bagpipe",
    "baguette",
    "baked",
    "bakery",
    "bakeshop",
    "baking",
    "balance",
    "balancing",
    "balcony",
    "balmy",
    "balsamic",
    "bamboo",
    "banana",
    "banish",
    "banister",
    "banjo",
    "bankable",
    "bankbook",
    "banked",
    "banker",
    "banking",
    "banknote",
    "bankroll",
    "banner",
    "bannister",
    "banshee",
    "banter",
    "barbecue",
    "barbed",
    "barbell",
    "barber",
    "barcode",
    "barge",
    "bargraph",
    "barista",
    "baritone",
    "barley",
    "barmaid",
    "barman",
    "barn",
    "barometer",
    "barrack",
    "barracuda",
    "barrel",
    "barrette",
    "barricade",
    "barrier",
    "barstool",
    "bartender",
    "barterer",
    "bash",
    "basically",
    "basics",
    "basil",
    "basin",
    "basis",
    "basket",
    "batboy",
    "batch",
    "bath",
    "baton",
    "bats",
    "battalion",
    "battered",
    "battering",
    "battery",
    "batting",
    "battle",
    "bauble",
    "bazooka",
    "blabber",
    "bladder",
    "blade",
    "blah",
    "blame",
    "blaming",
    "blanching",
    "blandness",
    "blank",
    "blaspheme",
    "blasphemy",
    "blast",
    "blatancy",
    "blatantly",
    "blazer",
    "blazing",
    "bleach",
    "bleak",
    "bleep",
    "blemish",
    "blend",
    "bless",
    "blighted",
    "blimp",
    "bling",
    "blinked",
    "blinker",
    "blinking",
    "blinks",
    "blip",
    "blissful",
    "blitz",
    "blizzard",
    "bloated",
    "bloating",
    "blob",
    "blog",
    "bloomers",
    "blooming",
    "blooper",
    "blot",
    "blouse",
    "blubber",
    "bluff",
    "bluish",
    "blunderer",
    "blunt",
    "blurb",
    "blurred",
    "blurry",
    "blurt",
    "blush",
    "blustery",
    "boaster",
    "boastful",
    "boasting",
    "boat",
    "bobbed",
    "bobbing",
    "bobble",
    "bobcat",
    "bobsled",
    "bobtail",
    "bodacious",
    "body",
    "bogged",
    "boggle",
    "bogus",
    "boil",
    "bok",
    "bolster",
    "bolt",
    "bonanza",
    "bonded",
    "bonding",
    "bondless",
    "boned",
    "bonehead",
    "boneless",
    "bonelike",
    "boney",
    "bonfire",
    "bonnet",
    "bonsai",
    "bonus",
    "bony",
    "boogeyman",
    "boogieman",
    "book",
    "boondocks",
    "booted",
    "booth",
    "bootie",
    "booting",
    "bootlace",
    "bootleg",
    "boots",
    "boozy",
    "borax",
    "boring",
    "borough",
    "borrower",
    "borrowing",
    "boss",
    "botanical",
    "botanist",
    "botany",
    "botch",
    "both",
    "bottle",
    "bottling",
    "bottom",
    "bounce",
    "bouncing",
    "bouncy",
    "bounding",
    "boundless",
    "bountiful",
    "bovine",
    "boxcar",
    "boxer",
    "boxing",
    "boxlike",
    "boxy",
    "breach",
    "breath",
    "breeches",
    "breeching",
    "breeder",
    "breeding",
    "breeze",
    "breezy",
    "brethren",
    "brewery",
    "brewing",
    "briar",
    "bribe",
    "brick",
    "bride",
    "bridged",
    "brigade",
    "bright",
    "brilliant",
    "brim",
    "bring",
    "brink",
    "brisket",
    "briskly",
    "briskness",
    "bristle",
    "brittle",
    "broadband",
    "broadcast",
    "broaden",
    "broadly",
    "broadness",
    "broadside",
    "broadways",
    "broiler",
    "broiling",
    "broken",
    "broker",
    "bronchial",
    "bronco",
    "bronze",
    "bronzing",
    "brook",
    "broom",
    "brought",
    "browbeat",
    "brownnose",
    "browse",
    "browsing",
    "bruising",
    "brunch",
    "brunette",
    "brunt",
    "brush",
    "brussels",
    "brute",
    "brutishly",
    "bubble",
    "bubbling",
    "bubbly",
    "buccaneer",
    "bucked",
    "bucket",
    "buckle",
    "buckshot",
    "buckskin",
    "bucktooth",
    "buckwheat",
    "buddhism",
    "buddhist",
    "budding",
    "buddy",
    "budget",
    "buffalo",
    "buffed",
    "buffer",
    "buffing",
    "buffoon",
    "buggy",
    "bulb",
    "bulge",
    "bulginess",
    "bulgur",
    "bulk",
    "bulldog",
    "bulldozer",
    "bullfight",
    "bullfrog",
    "bullhorn",
    "bullion",
    "bullish",
    "bullpen",
    "bullring",
    "bullseye",
    "bullwhip",
    "bully",
    "bunch",
    "bundle",
    "bungee",
    "bunion",
    "bunkbed",
    "bunkhouse",
    "bunkmate",
    "bunny",
    "bunt",
    "busboy",
    "bush",
    "busily",
    "busload",
    "bust",
    "busybody",
    "buzz",
    "cabana",
    "cabbage",
    "cabbie",
    "cabdriver",
    "cable",
    "caboose",
    "cache",
    "cackle",
    "cacti",
    "cactus",
    "caddie",
    "caddy",
    "cadet",
    "cadillac",
    "cadmium",
    "cage",
    "cahoots",
    "cake",
    "calamari",
    "calamity",
    "calcium",
    "calculate",
    "calculus",
    "caliber",
    "calibrate",
    "calm",
    "caloric",
    "calorie",
    "calzone",
    "camcorder",
    "cameo",
    "camera",
    "camisole",
    "camper",
    "campfire",
    "camping",
    "campsite",
    "campus",
    "canal",
    "canary",
    "cancel",
    "candied",
    "candle",
    "candy",
    "cane",
    "canine",
    "canister",
    "cannabis",
    "canned",
    "canning",
    "cannon",
    "cannot",
    "canola",
    "canon",
    "canopener",
    "canopy",
    "canteen",
    "canyon",
    "capable",
    "capably",
    "capacity",
    "cape",
    "capillary",
    "capital",
    "capitol",
    "capped",
    "capricorn",
    "capsize",
    "capsule",
    "caption",
    "captivate",
    "captive",
    "captivity",
    "capture",
    "caramel",
    "carat",
    "caravan",
    "carbon",
    "cardboard",
    "carded",
    "cardiac",
    "cardigan",
    "cardinal",
    "cardstock",
    "carefully",
    "caregiver",
    "careless",
    "caress",
    "caretaker",
    "cargo",
    "caring",
    "carless",
    "carload",
    "carmaker",
    "carnage",
    "carnation",
    "carnival",
    "carnivore",
    "carol",
    "carpenter",
    "carpentry",
    "carpool",
    "carport",
    "carried",
    "carrot",
    "carrousel",
    "carry",
    "cartel",
    "cartload",
    "carton",
    "cartoon",
    "cartridge",
    "cartwheel",
    "carve",
    "carving",
    "carwash",
    "cascade",
    "case",
    "cash",
    "casing",
    "casino",
    "casket",
    "cassette",
    "casually",
    "casualty",
    "catacomb",
    "catalog",
    "catalyst",
    "catalyze",
    "catapult",
    "cataract",
    "catatonic",
    "catcall",
    "catchable",
    "catcher",
    "catching",
    "catchy",
    "caterer",
    "catering",
    "catfight",
    "catfish",
    "cathedral",
    "cathouse",
    "catlike",
    "catnap",
    "catnip",
    "catsup",
    "cattail",
    "cattishly",
    "cattle",
    "catty",
    "catwalk",
    "caucasian",
    "caucus",
    "causal",
    "causation",
    "cause",
    "causing",
    "cauterize",
    "caution",
    "cautious",
    "cavalier",
    "cavalry",
    "caviar",
    "cavity",
    "cedar",
    "celery",
    "celestial",
    "celibacy",
    "celibate",
    "celtic",
    "cement",
    "census",
    "ceramics",
    "ceremony",
    "certainly",
    "certainty",
    "certified",
    "certify",
    "cesarean",
    "cesspool",
    "chafe",
    "chaffing",
    "chain",
    "chair",
    "chalice",
    "challenge",
    "chamber",
    "chamomile",
    "champion",
    "chance",
    "change",
    "channel",
    "chant",
    "chaos",
    "chaperone",
    "chaplain",
    "chapped",
    "chaps",
    "chapter",
    "character",
    "charbroil",
    "charcoal",
    "charger",
    "charging",
    "chariot",
    "charity",
    "charm",
    "charred",
    "charter",
    "charting",
    "chase",
    "chasing",
    "chaste",
    "chastise",
    "chastity",
    "chatroom",
    "chatter",
    "chatting",
    "chatty",
    "cheating",
    "cheddar",
    "cheek",
    "cheer",
    "cheese",
    "cheesy",
    "chef",
    "chemicals",
    "chemist",
    "chemo",
    "cherisher",
    "cherub",
    "chess",
    "chest",
    "chevron",
    "chevy",
    "chewable",
    "chewer",
    "chewing",
    "chewy",
    "chief",
    "chihuahua",
    "childcare",
    "childhood",
    "childish",
    "childless",
    "childlike",
    "chili",
    "chill",
    "chimp",
    "chip",
    "chirping",
    "chirpy",
    "chitchat",
    "chivalry",
    "chive",
    "chloride",
    "chlorine",
    "choice",
    "chokehold",
    "choking",
    "chomp",
    "chooser",
    "choosing",
    "choosy",
    "chop",
    "chosen",
    "chowder",
    "chowtime",
    "chrome",
    "chubby",
    "chuck",
    "chug",
    "chummy",
    "chump",
    "chunk",
    "churn",
    "chute",
    "cider",
    "cilantro",
    "cinch",
    "cinema",
    "cinnamon",
    "circle",
    "circling",
    "circular",
    "circulate",
    "circus",
    "citable",
    "citadel",
    "citation",
    "citizen",
    "citric",
    "citrus",
    "city",
    "civic",
    "civil",
    "clad",
    "claim",
    "clambake",
    "clammy",
    "clamor",
    "clamp",
    "clamshell",
    "clang",
    "clanking",
    "clapped",
    "clapper",
    "clapping",
    "clarify",
    "clarinet",
    "clarity",
    "clash",
    "clasp",
    "class",
    "clatter",
    "clause",
    "clavicle",
    "claw",
    "clay",
    "clean",
    "clear",
    "cleat",
    "cleaver",
    "cleft",
    "clench",
    "clergyman",
    "clerical",
    "clerk",
    "clever",
    "clicker",
    "client",
    "climate",
    "climatic",
    "cling",
    "clinic",
    "clinking",
    "clip",
    "clique",
    "cloak",
    "clobber",
    "clock",
    "clone",
    "cloning",
    "closable",
    "closure",
    "clothes",
    "clothing",
    "cloud",
    "clover",
    "clubbed",
    "clubbing",
    "clubhouse",
    "clump",
    "clumsily",
    "clumsy",
    "clunky",
    "clustered",
    "clutch",
    "clutter",
    "coach",
    "coagulant",
    "coastal",
    "coaster",
    "coasting",
    "coastland",
    "coastline",
    "coat",
    "coauthor",
    "cobalt",
    "cobbler",
    "cobweb",
    "cocoa",
    "coconut",
    "cod",
    "coeditor",
    "coerce",
    "coexist",
    "coffee",
    "cofounder",
    "cognition",
    "cognitive",
    "cogwheel",
    "coherence",
    "coherent",
    "cohesive",
    "coil",
    "coke",
    "cola",
    "cold",
    "coleslaw",
    "coliseum",
    "collage",
    "collapse",
    "collar",
    "collected",
    "collector",
    "collide",
    "collie",
    "collision",
    "colonial",
    "colonist",
    "colonize",
    "colony",
    "colossal",
    "colt",
    "coma",
    "come",
    "comfort",
    "comfy",
    "comic",
    "coming",
    "comma",
    "commence",
    "commend",
    "comment",
    "commerce",
    "commode",
    "commodity",
    "commodore",
    "common",
    "commotion",
    "commute",
    "commuting",
    "compacted",
    "compacter",
    "compactly",
    "compactor",
    "companion",
    "company",
    "compare",
    "compel",
    "compile",
    "comply",
    "component",
    "composed",
    "composer",
    "composite",
    "compost",
    "composure",
    "compound",
    "compress",
    "comprised",
    "computer",
    "computing",
    "comrade",
    "concave",
    "conceal",
    "conceded",
    "concept",
    "concerned",
    "concert",
    "conch",
    "concierge",
    "concise",
    "conclude",
    "concrete",
    "concur",
    "condense",
    "condiment",
    "condition",
    "condone",
    "conducive",
    "conductor",
    "conduit",
    "cone",
    "confess",
    "confetti",
    "confidant",
    "confident",
    "confider",
    "confiding",
    "configure",
    "confined",
    "confining",
    "confirm",
    "conflict",
    "conform",
    "confound",
    "confront",
    "confused",
    "confusing",
    "confusion",
    "congenial",
    "congested",
    "congrats",
    "congress",
    "conical",
    "conjoined",
    "conjure",
    "conjuror",
    "connected",
    "connector",
    "consensus",
    "consent",
    "console",
    "consoling",
    "consonant",
    "constable",
    "constant",
    "constrain",
    "constrict",
    "construct",
    "consult",
    "consumer",
    "consuming",
    "contact",
    "container",
    "contempt",
    "contend",
    "contented",
    "contently",
    "contents",
    "contest",
    "context",
    "contort",
    "contour",
    "contrite",
    "control",
    "contusion",
    "convene",
    "convent",
    "copartner",
    "cope",
    "copied",
    "copier",
    "copilot",
    "coping",
    "copious",
    "copper",
    "copy",
    "coral",
    "cork",
    "cornball",
    "cornbread",
    "corncob",
    "cornea",
    "corned",
    "corner",
    "cornfield",
    "cornflake",
    "cornhusk",
    "cornmeal",
    "cornstalk",
    "corny",
    "coronary",
    "coroner",
    "corporal",
    "corporate",
    "corral",
    "correct",
    "corridor",
    "corrode",
    "corroding",
    "corrosive",
    "corsage",
    "corset",
    "cortex",
    "cosigner",
    "cosmetics",
    "cosmic",
    "cosmos",
    "cosponsor",
    "cost",
    "cottage",
    "cotton",
    "couch",
    "cough",
    "could",
    "countable",
    "countdown",
    "counting",
    "countless",
    "country",
    "county",
    "courier",
    "covenant",
    "cover",
    "coveted",
    "coveting",
    "coyness",
    "cozily",
    "coziness",
    "cozy",
    "crabbing",
    "crabgrass",
    "crablike",
    "crabmeat",
    "cradle",
    "cradling",
    "crafter",
    "craftily",
    "craftsman",
    "craftwork",
    "crafty",
    "cramp",
    "cranberry",
    "crane",
    "cranial",
    "cranium",
    "crank",
    "crate",
    "crave",
    "craving",
    "crawfish",
    "crawlers",
    "crawling",
    "crayfish",
    "crayon",
    "crazed",
    "crazily",
    "craziness",
    "crazy",
    "creamed",
    "creamer",
    "creamlike",
    "crease",
    "creasing",
    "creatable",
    "create",
    "creation",
    "creative",
    "creature",
    "credible",
    "credibly",
    "credit",
    "creed",
    "creme",
    "creole",
    "crepe",
    "crept",
    "crescent",
    "crested",
    "cresting",
    "crestless",
    "crevice",
    "crewless",
    "crewman",
    "crewmate",
    "crib",
    "cricket",
    "cried",
    "crier",
    "crimp",
    "crimson",
    "cringe",
    "cringing",
    "crinkle",
    "crinkly",
    "crisped",
    "crisping",
    "crisply",
    "crispness",
    "crispy",
    "criteria",
    "critter",
    "croak",
    "crock",
    "crook",
    "croon",
    "crop",
    "cross",
    "crouch",
    "crouton",
    "crowbar",
    "crowd",
    "crown",
    "crucial",
    "crudely",
    "crudeness",
    "cruelly",
    "cruelness",
    "cruelty",
    "crumb",
    "crummiest",
    "crummy",
    "crumpet",
    "crumpled",
    "cruncher",
    "crunching",
    "crunchy",
    "crusader",
    "crushable",
    "crushed",
    "crusher",
    "crushing",
    "crust",
    "crux",
    "crying",
    "cryptic",
    "crystal",
    "cubbyhole",
    "cube",
    "cubical",
    "cubicle",
    "cucumber",
    "cuddle",
    "cuddly",
    "cufflink",
    "culinary",
    "culminate",
    "culpable",
    "culprit",
    "cultivate",
    "cultural",
    "culture",
    "cupbearer",
    "cupcake",
    "cupid",
    "cupped",
    "cupping",
    "curable",
    "curator",
    "curdle",
    "cure",
    "curfew",
    "curing",
    "curled",
    "curler",
    "curliness",
    "curling",
    "curly",
    "curry",
    "curse",
    "cursive",
    "cursor",
    "curtain",
    "curtly",
    "curtsy",
    "curvature",
    "curve",
    "curvy",
    "cushy",
    "cusp",
    "cussed",
    "custard",
    "custodian",
    "custody",
    "customary",
    "customer",
    "customize",
    "customs",
    "cut",
    "cycle",
    "cyclic",
    "cycling",
    "cyclist",
    "cylinder",
    "cymbal",
    "cytoplasm",
    "cytoplast",
    "dab",
    "dad",
    "daffodil",
    "dagger",
    "daily",
    "daintily",
    "dainty",
    "dairy",
    "daisy",
    "dallying",
    "dance",
    "dancing",
    "dandelion",
    "dander",
    "dandruff",
    "dandy",
    "danger",
    "dangle",
    "dangling",
    "daredevil",
    "dares",
    "daringly",
    "darkened",
    "darkening",
    "darkish",
    "darkness",
    "darkroom",
    "darling",
    "darn",
    "dart",
    "darwinism",
    "dash",
    "dastardly",
    "data",
    "datebook",
    "dating",
    "daughter",
    "daunting",
    "dawdler",
    "dawn",
    "daybed",
    "daybreak",
    "daycare",
    "daydream",
    "daylight",
    "daylong",
    "dayroom",
    "daytime",
    "dazzler",
    "dazzling",
    "deacon",
    "deafening",
    "deafness",
    "dealer",
    "dealing",
    "dealmaker",
    "dealt",
    "dean",
    "debatable",
    "debate",
    "debating",
    "debit",
    "debrief",
    "debtless",
    "debtor",
    "debug",
    "debunk",
    "decade",
    "decaf",
    "decal",
    "decathlon",
    "decay",
    "deceased",
    "deceit",
    "deceiver",
    "deceiving",
    "december",
    "decency",
    "decent",
    "deception",
    "deceptive",
    "decibel",
    "decidable",
    "decimal",
    "decimeter",
    "decipher",
    "deck",
    "declared",
    "decline",
    "decode",
    "decompose",
    "decorated",
    "decorator",
    "decoy",
    "decrease",
    "decree",
    "dedicate",
    "dedicator",
    "deduce",
    "deduct",
    "deed",
    "deem",
    "deepen",
    "deeply",
    "deepness",
    "deface",
    "defacing",
    "defame",
    "default",
    "defeat",
    "defection",
    "defective",
    "defendant",
    "defender",
    "defense",
    "defensive",
    "deferral",
    "deferred",
    "defiance",
    "defiant",
    "defile",
    "defiling",
    "define",
    "definite",
    "deflate",
    "deflation",
    "deflator",
    "deflected",
    "deflector",
    "defog",
    "deforest",
    "defraud",
    "defrost",
    "deftly",
    "defuse",
    "defy",
    "degraded",
    "degrading",
    "degrease",
    "degree",
    "dehydrate",
    "deity",
    "dejected",
    "delay",
    "delegate",
    "delegator",
    "delete",
    "deletion",
    "delicacy",
    "delicate",
    "delicious",
    "delighted",
    "delirious",
    "delirium",
    "deliverer",
    "delivery",
    "delouse",
    "delta",
    "deluge",
    "delusion",
    "deluxe",
    "demanding",
    "demeaning",
    "demeanor",
    "demise",
    "democracy",
    "democrat",
    "demote",
    "demotion",
    "demystify",
    "denatured",
    "deniable",
    "denial",
    "denim",
    "denote",
    "dense",
    "density",
    "dental",
    "dentist",
    "denture",
    "deny",
    "deodorant",
    "deodorize",
    "departed",
    "departure",
    "depict",
    "deplete",
    "depletion",
    "deplored",
    "deploy",
    "deport",
    "depose",
    "depraved",
    "depravity",
    "deprecate",
    "depress",
    "deprive",
    "depth",
    "deputize",
    "deputy",
    "derail",
    "deranged",
    "derby",
    "derived",
    "desecrate",
    "deserve",
    "deserving",
    "designate",
    "designed",
    "designer",
    "designing",
    "deskbound",
    "desktop",
    "deskwork",
    "desolate",
    "despair",
    "despise",
    "despite",
    "destiny",
    "destitute",
    "destruct",
    "detached",
    "detail",
    "detection",
    "detective",
    "detector",
    "detention",
    "detergent",
    "detest",
    "detonate",
    "detonator",
    "detoxify",
    "detract",
    "deuce",
    "devalue",
    "deviancy",
    "deviant",
    "deviate",
    "deviation",
    "deviator",
    "device",
    "devious",
    "devotedly",
    "devotee",
    "devotion",
    "devourer",
    "devouring",
    "devoutly",
    "dexterity",
    "dexterous",
    "diabetes",
    "diabetic",
    "diabolic",
    "diagnoses",
    "diagnosis",
    "diagram",
    "dial",
    "diameter",
    "diaper",
    "diaphragm",
    "diary",
    "dice",
    "dicing",
    "dictate",
    "dictation",
    "dictator",
    "difficult",
    "diffused",
    "diffuser",
    "diffusion",
    "diffusive",
    "dig",
    "dilation",
    "diligence",
    "diligent",
    "dill",
    "dilute",
    "dime",
    "diminish",
    "dimly",
    "dimmed",
    "dimmer",
    "dimness",
    "dimple",
    "diner",
    "dingbat",
    "dinghy",
    "dinginess",
    "dingo",
    "dingy",
    "dining",
    "dinner",
    "diocese",
    "dioxide",
    "diploma",
    "dipped",
    "dipper",
    "dipping",
    "directed",
    "direction",
    "directive",
    "directly",
    "directory",
    "direness",
    "dirtiness",
    "disabled",
    "disagree",
    "disallow",
    "disarm",
    "disarray",
    "disaster",
    "disband",
    "disbelief",
    "disburse",
    "discard",
    "discern",
    "discharge",
    "disclose",
    "discolor",
    "discount",
    "discourse",
    "discover",
    "discuss",
    "disdain",
    "disengage",
    "disfigure",
    "disgrace",
    "dish",
    "disinfect",
    "disjoin",
    "disk",
    "dislike",
    "disliking",
    "dislocate",
    "dislodge",
    "disloyal",
    "dismantle",
    "dismay",
    "dismiss",
    "dismount",
    "disobey",
    "disorder",
    "disown",
    "disparate",
    "disparity",
    "dispatch",
    "dispense",
    "dispersal",
    "dispersed",
    "disperser",
    "displace",
    "display",
    "displease",
    "disposal",
    "dispose",
    "disprove",
    "dispute",
    "disregard",
    "disrupt",
    "dissuade",
    "distance",
    "distant",
    "distaste",
    "distill",
    "distinct",
    "distort",
    "distract",
    "distress",
    "district",
    "distrust",
    "ditch",
    "ditto",
    "ditzy",
    "dividable",
    "divided",
    "dividend",
    "dividers",
    "dividing",
    "divinely",
    "diving",
    "divinity",
    "divisible",
    "divisibly",
    "division",
    "divisive",
    "divorcee",
    "dizziness",
    "dizzy",
    "doable",
    "docile",
    "dock",
    "doctrine",
    "document",
    "dodge",
    "dodgy",
    "doily",
    "doing",
    "dole",
    "dollar",
    "dollhouse",
    "dollop",
    "dolly",
    "dolphin",
    "domain",
    "domelike",
    "domestic",
    "dominion",
    "dominoes",
    "donated",
    "donation",
    "donator",
    "donor",
    "donut",
    "doodle",
    "doorbell",
    "doorframe",
    "doorknob",
    "doorman",
    "doormat",
    "doornail",
    "doorpost",
    "doorstep",
    "doorstop",
    "doorway",
    "doozy",
    "dork",
    "dormitory",
    "dorsal",
    "dosage",
    "dose",
    "dotted",
    "doubling",
    "douche",
    "dove",
    "down",
    "dowry",
    "doze",
    "drab",
    "dragging",
    "dragonfly",
    "dragonish",
    "dragster",
    "drainable",
    "drainage",
    "drained",
    "drainer",
    "drainpipe",
    "dramatic",
    "dramatize",
    "drank",
    "drapery",
    "drastic",
    "draw",
    "dreaded",
    "dreadful",
    "dreadlock",
    "dreamboat",
    "dreamily",
    "dreamland",
    "dreamless",
    "dreamlike",
    "dreamt",
    "dreamy",
    "drearily",
    "dreary",
    "drench",
    "dress",
    "drew",
    "dribble",
    "dried",
    "drier",
    "drift",
    "driller",
    "drilling",
    "drinkable",
    "drinking",
    "dripping",
    "drippy",
    "drivable",
    "driven",
    "driver",
    "driveway",
    "driving",
    "drizzle",
    "drizzly",
    "drone",
    "drool",
    "droop",
    "drop-down",
    "dropbox",
    "dropkick",
    "droplet",
    "dropout",
    "dropper",
    "drove",
    "drown",
    "drowsily",
    "drudge",
    "drum",
    "dry",
    "dubbed",
    "dubiously",
    "duchess",
    "duckbill",
    "ducking",
    "duckling",
    "ducktail",
    "ducky",
    "duct",
    "dude",
    "duffel",
    "dugout",
    "duh",
    "duke",
    "duller",
    "dullness",
    "duly",
    "dumping",
    "dumpling",
    "dumpster",
    "duo",
    "dupe",
    "duplex",
    "duplicate",
    "duplicity",
    "durable",
    "durably",
    "duration",
    "duress",
    "during",
    "dusk",
    "dust",
    "dutiful",
    "duty",
    "duvet",
    "dwarf",
    "dweeb",
    "dwelled",
    "dweller",
    "dwelling",
    "dwindle",
    "dwindling",
    "dynamic",
    "dynamite",
    "dynasty",
    "dyslexia",
    "dyslexic",
    "each",
    "eagle",
    "earache",
    "eardrum",
    "earflap",
    "earful",
    "earlobe",
    "early",
    "earmark",
    "earmuff",
    "earphone",
    "earpiece",
    "earplugs",
    "earring",
    "earshot",
    "earthen",
    "earthlike",
    "earthling",
    "earthly",
    "earthworm",
    "earthy",
    "earwig",
    "easeful",
    "easel",
    "easiest",
    "easily",
    "easiness",
    "easing",
    "eastbound",
    "eastcoast",
    "easter",
    "eastward",
    "eatable",
    "eaten",
    "eatery",
    "eating",
    "eats",
    "ebay",
    "ebony",
    "ebook",
    "ecard",
    "eccentric",
    "echo",
    "eclair",
    "eclipse",
    "ecologist",
    "ecology",
    "economic",
    "economist",
    "economy",
    "ecosphere",
    "ecosystem",
    "edge",
    "edginess",
    "edging",
    "edgy",
    "edition",
    "editor",
    "educated",
    "education",
    "educator",
    "eel",
    "effective",
    "effects",
    "efficient",
    "effort",
    "eggbeater",
    "egging",
    "eggnog",
    "eggplant",
    "eggshell",
    "egomaniac",
    "egotism",
    "egotistic",
    "either",
    "eject",
    "elaborate",
    "elastic",
    "elated",
    "elbow",
    "eldercare",
    "elderly",
    "eldest",
    "electable",
    "election",
    "elective",
    "elephant",
    "elevate",
    "elevating",
    "elevation",
    "elevator",
    "eleven",
    "elf",
    "eligible",
    "eligibly",
    "eliminate",
    "elite",
    "elitism",
    "elixir",
    "elk",
    "ellipse",
    "elliptic",
    "elm",
    "elongated",
    "elope",
    "eloquence",
    "eloquent",
    "elsewhere",
    "elude",
    "elusive",
    "elves",
    "email",
    "embargo",
    "embark",
    "embassy",
    "embattled",
    "embellish",
    "ember",
    "embezzle",
    "emblaze",
    "emblem",
    "embody",
    "embolism",
    "emboss",
    "embroider",
    "emcee",
    "emerald",
    "emergency",
    "emission",
    "emit",
    "emote",
    "emoticon",
    "emotion",
    "empathic",
    "empathy",
    "emperor",
    "emphases",
    "emphasis",
    "emphasize",
    "emphatic",
    "empirical",
    "employed",
    "employee",
    "employer",
    "emporium",
    "empower",
    "emptier",
    "emptiness",
    "empty",
    "emu",
    "enable",
    "enactment",
    "enamel",
    "enchanted",
    "enchilada",
    "encircle",
    "enclose",
    "enclosure",
    "encode",
    "encore",
    "encounter",
    "encourage",
    "encroach",
    "encrust",
    "encrypt",
    "endanger",
    "endeared",
    "endearing",
    "ended",
    "ending",
    "endless",
    "endnote",
    "endocrine",
    "endorphin",
    "endorse",
    "endowment",
    "endpoint",
    "endurable",
    "endurance",
    "enduring",
    "energetic",
    "energize",
    "energy",
    "enforced",
    "enforcer",
    "engaged",
    "engaging",
    "engine",
    "engorge",
    "engraved",
    "engraver",
    "engraving",
    "engross",
    "engulf",
    "enhance",
    "enigmatic",
    "enjoyable",
    "enjoyably",
    "enjoyer",
    "enjoying",
    "enjoyment",
    "enlarged",
    "enlarging",
    "enlighten",
    "enlisted",
    "enquirer",
    "enrage",
    "enrich",
    "enroll",
    "enslave",
    "ensnare",
    "ensure",
    "entail",
    "entangled",
    "entering",
    "entertain",
    "enticing",
    "entire",
    "entitle",
    "entity",
    "entomb",
    "entourage",
    "entrap",
    "entree",
    "entrench",
    "entrust",
    "entryway",
    "entwine",
    "enunciate",
    "envelope",
    "enviable",
    "enviably",
    "envious",
    "envision",
    "envoy",
    "envy",
    "enzyme",
    "epic",
    "epidemic",
    "epidermal",
    "epidermis",
    "epidural",
    "epilepsy",
    "epileptic",
    "epilogue",
    "epiphany",
    "episode",
    "equal",
    "equate",
    "equation",
    "equator",
    "equinox",
    "equipment",
    "equity",
    "equivocal",
    "eradicate",
    "erasable",
    "erased",
    "eraser",
    "erasure",
    "ergonomic",
    "errand",
    "errant",
    "erratic",
    "error",
    "erupt",
    "escalate",
    "escalator",
    "escapable",
    "escapade",
    "escapist",
    "escargot",
    "eskimo",
    "esophagus",
    "espionage",
    "espresso",
    "esquire",
    "essay",
    "essence",
    "essential",
    "establish",
    "estate",
    "esteemed",
    "estimate",
    "estimator",
    "estranged",
    "estrogen",
    "etching",
    "eternal",
    "eternity",
    "ethanol",
    "ether",
    "ethically",
    "ethics",
    "euphemism",
    "evacuate",
    "evacuee",
    "evade",
    "evaluate",
    "evaluator",
    "evaporate",
    "evasion",
    "evasive",
    "even",
    "everglade",
    "evergreen",
    "everybody",
    "everyday",
    "everyone",
    "evict",
    "evidence",
    "evident",
    "evil",
    "evoke",
    "evolution",
    "evolve",
    "exact",
    "exalted",
    "example",
    "excavate",
    "excavator",
    "exceeding",
    "exception",
    "excess",
    "exchange",
    "excitable",
    "exciting",
    "exclaim",
    "exclude",
    "excluding",
    "exclusion",
    "exclusive",
    "excretion",
    "excretory",
    "excursion",
    "excusable",
    "excusably",
    "excuse",
    "exemplary",
    "exemplify",
    "exemption",
    "exerciser",
    "exert",
    "exes",
    "exfoliate",
    "exhale",
    "exhaust",
    "exhume",
    "exile",
    "existing",
    "exit",
    "exodus",
    "exonerate",
    "exorcism",
    "exorcist",
    "expand",
    "expanse",
    "expansion",
    "expansive",
    "expectant",
    "expedited",
    "expediter",
    "expel",
    "expend",
    "expenses",
    "expensive",
    "expert",
    "expire",
    "expiring",
    "explain",
    "expletive",
    "explicit",
    "explode",
    "exploit",
    "explore",
    "exploring",
    "exponent",
    "exporter",
    "exposable",
    "expose",
    "exposure",
    "express",
    "expulsion",
    "exquisite",
    "extended",
    "extending",
    "extent",
    "extenuate",
    "exterior",
    "external",
    "extinct",
    "extortion",
    "extradite",
    "extras",
    "extrovert",
    "extrude",
    "extruding",
    "exuberant",
    "fable",
    "fabric",
    "fabulous",
    "facebook",
    "facecloth",
    "facedown",
    "faceless",
    "facelift",
    "faceplate",
    "faceted",
    "facial",
    "facility",
    "facing",
    "facsimile",
    "faction",
    "factoid",
    "factor",
    "factsheet",
    "factual",
    "faculty",
    "fade",
    "fading",
    "failing",
    "falcon",
    "fall",
    "false",
    "falsify",
    "fame",
    "familiar",
    "family",
    "famine",
    "famished",
    "fanatic",
    "fancied",
    "fanciness",
    "fancy",
    "fanfare",
    "fang",
    "fanning",
    "fantasize",
    "fantastic",
    "fantasy",
    "fascism",
    "fastball",
    "faster",
    "fasting",
    "fastness",
    "faucet",
    "favorable",
    "favorably",
    "favored",
    "favoring",
    "favorite",
    "fax",
    "feast",
    "federal",
    "fedora",
    "feeble",
    "feed",
    "feel",
    "feisty",
    "feline",
    "felt-tip",
    "feminine",
    "feminism",
    "feminist",
    "feminize",
    "femur",
    "fence",
    "fencing",
    "fender",
    "ferment",
    "fernlike",
    "ferocious",
    "ferocity",
    "ferret",
    "ferris",
    "ferry",
    "fervor",
    "fester",
    "festival",
    "festive",
    "festivity",
    "fetal",
    "fetch",
    "fever",
    "fiber",
    "fiction",
    "fiddle",
    "fiddling",
    "fidelity",
    "fidgeting",
    "fidgety",
    "fifteen",
    "fifth",
    "fiftieth",
    "fifty",
    "figment",
    "figure",
    "figurine",
    "filing",
    "filled",
    "filler",
    "filling",
    "film",
    "filter",
    "filth",
    "filtrate",
    "finale",
    "finalist",
    "finalize",
    "finally",
    "finance",
    "financial",
    "finch",
    "fineness",
    "finer",
    "finicky",
    "finished",
    "finisher",
    "finishing",
    "finite",
    "finless",
    "finlike",
    "fiscally",
    "fit",
    "five",
    "flaccid",
    "flagman",
    "flagpole",
    "flagship",
    "flagstick",
    "flagstone",
    "flail",
    "flakily",
    "flaky",
    "flame",
    "flammable",
    "flanked",
    "flanking",
    "flannels",
    "flap",
    "flaring",
    "flashback",
    "flashbulb",
    "flashcard",
    "flashily",
    "flashing",
    "flashy",
    "flask",
    "flatbed",
    "flatfoot",
    "flatly",
    "flatness",
    "flatten",
    "flattered",
    "flatterer",
    "flattery",
    "flattop",
    "flatware",
    "flatworm",
    "flavored",
    "flavorful",
    "flavoring",
    "flaxseed",
    "fled",
    "fleshed",
    "fleshy",
    "flick",
    "flier",
    "flight",
    "flinch",
    "fling",
    "flint",
    "flip",
    "flirt",
    "float",
    "flock",
    "flogging",
    "flop",
    "floral",
    "florist",
    "floss",
    "flounder",
    "flyable",
    "flyaway",
    "flyer",
    "flying",
    "flyover",
    "flypaper",
    "foam",
    "foe",
    "fog",
    "foil",
    "folic",
    "folk",
    "follicle",
    "follow",
    "fondling",
    "fondly",
    "fondness",
    "fondue",
    "font",
    "food",
    "fool",
    "footage",
    "football",
    "footbath",
    "footboard",
    "footer",
    "footgear",
    "foothill",
    "foothold",
    "footing",
    "footless",
    "footman",
    "footnote",
    "footpad",
    "footpath",
    "footprint",
    "footrest",
    "footsie",
    "footsore",
    "footwear",
    "footwork",
    "fossil",
    "foster",
    "founder",
    "founding",
    "fountain",
    "fox",
    "foyer",
    "fraction",
    "fracture",
    "fragile",
    "fragility",
    "fragment",
    "fragrance",
    "fragrant",
    "frail",
    "frame",
    "framing",
    "frantic",
    "fraternal",
    "frayed",
    "fraying",
    "frays",
    "freckled",
    "freckles",
    "freebase",
    "freebee",
    "freebie",
    "freedom",
    "freefall",
    "freehand",
    "freeing",
    "freeload",
    "freely",
    "freemason",
    "freeness",
    "freestyle",
    "freeware",
    "freeway",
    "freewill",
    "freezable",
    "freezing",
    "freight",
    "french",
    "frenzied",
    "frenzy",
    "frequency",
    "frequent",
    "fresh",
    "fretful",
    "fretted",
    "friction",
    "friday",
    "fridge",
    "fried",
    "friend",
    "frighten",
    "frightful",
    "frigidity",
    "frigidly",
    "frill",
    "fringe",
    "frisbee",
    "frisk",
    "fritter",
    "frivolous",
    "frolic",
    "from",
    "front",
    "frostbite",
    "frosted",
    "frostily",
    "frosting",
    "frostlike",
    "frosty",
    "froth",
    "frown",
    "frozen",
    "fructose",
    "frugality",
    "frugally",
    "fruit",
    "frustrate",
    "frying",
    "gab",
    "gaffe",
    "gag",
    "gainfully",
    "gaining",
    "gains",
    "gala",
    "gallantly",
    "galleria",
    "gallery",
    "galley",
    "gallon",
    "gallows",
    "gallstone",
    "galore",
    "galvanize",
    "gambling",
    "game",
    "gaming",
    "gamma",
    "gander",
    "gangly",
    "gangrene",
    "gangway",
    "gap",
    "garage",
    "garbage",
    "garden",
    "gargle",
    "garland",
    "garlic",
    "garment",
    "garnet",
    "garnish",
    "garter",
    "gas",
    "gatherer",
    "gathering",
    "gating",
    "gauging",
    "gauntlet",
    "gauze",
    "gave",
    "gawk",
    "gazing",
    "gear",
    "gecko",
    "geek",
    "geiger",
    "gem",
    "gender",
    "generic",
    "generous",
    "genetics",
    "genre",
    "gentile",
    "gentleman",
    "gently",
    "gents",
    "geography",
    "geologic",
    "geologist",
    "geology",
    "geometric",
    "geometry",
    "geranium",
    "gerbil",
    "geriatric",
    "germicide",
    "germinate",
    "germless",
    "germproof",
    "gestate",
    "gestation",
    "gesture",
    "getaway",
    "getting",
    "getup",
    "giant",
    "gibberish",
    "giblet",
    "giddily",
    "giddiness",
    "giddy",
    "gift",
    "gigabyte",
    "gigahertz",
    "gigantic",
    "giggle",
    "giggling",
    "giggly",
    "gigolo",
    "gilled",
    "gills",
    "gimmick",
    "girdle",
    "giveaway",
    "given",
    "giver",
    "giving",
    "gizmo",
    "gizzard",
    "glacial",
    "glacier",
    "glade",
    "gladiator",
    "gladly",
    "glamorous",
    "glamour",
    "glance",
    "glancing",
    "glandular",
    "glare",
    "glaring",
    "glass",
    "glaucoma",
    "glazing",
    "gleaming",
    "gleeful",
    "glider",
    "gliding",
    "glimmer",
    "glimpse",
    "glisten",
    "glitch",
    "glitter",
    "glitzy",
    "gloater",
    "gloating",
    "gloomily",
    "gloomy",
    "glorified",
    "glorifier",
    "glorify",
    "glorious",
    "glory",
    "gloss",
    "glove",
    "glowing",
    "glowworm",
    "glucose",
    "glue",
    "gluten",
    "glutinous",
    "glutton",
    "gnarly",
    "gnat",
    "goal",
    "goatskin",
    "goes",
    "goggles",
    "going",
    "goldfish",
    "goldmine",
    "goldsmith",
    "golf",
    "goliath",
    "gonad",
    "gondola",
    "gone",
    "gong",
    "good",
    "gooey",
    "goofball",
    "goofiness",
    "goofy",
    "google",
    "goon",
    "gopher",
    "gore",
    "gorged",
    "gorgeous",
    "gory",
    "gosling",
    "gossip",
    "gothic",
    "gotten",
    "gout",
    "gown",
    "grab",
    "graceful",
    "graceless",
    "gracious",
    "gradation",
    "graded",
    "grader",
    "gradient",
    "grading",
    "gradually",
    "graduate",
    "graffiti",
    "grafted",
    "grafting",
    "grain",
    "granddad",
    "grandkid",
    "grandly",
    "grandma",
    "grandpa",
    "grandson",
    "granite",
    "granny",
    "granola",
    "grant",
    "granular",
    "grape",
    "graph",
    "grapple",
    "grappling",
    "grasp",
    "grass",
    "gratified",
    "gratify",
    "grating",
    "gratitude",
    "gratuity",
    "gravel",
    "graveness",
    "graves",
    "graveyard",
    "gravitate",
    "gravity",
    "gravy",
    "gray",
    "grazing",
    "greasily",
    "greedily",
    "greedless",
    "greedy",
    "green",
    "greeter",
    "greeting",
    "grew",
    "greyhound",
    "grid",
    "grief",
    "grievance",
    "grieving",
    "grievous",
    "grill",
    "grimace",
    "grimacing",
    "grime",
    "griminess",
    "grimy",
    "grinch",
    "grinning",
    "grip",
    "gristle",
    "grit",
    "groggily",
    "groggy",
    "groin",
    "groom",
    "groove",
    "grooving",
    "groovy",
    "grope",
    "ground",
    "grouped",
    "grout",
    "grove",
    "grower",
    "growing",
    "growl",
    "grub",
    "grudge",
    "grudging",
    "grueling",
    "gruffly",
    "grumble",
    "grumbling",
    "grumbly",
    "grumpily",
    "grunge",
    "grunt",
    "guacamole",
    "guidable",
    "guidance",
    "guide",
    "guiding",
    "guileless",
    "guise",
    "gulf",
    "gullible",
    "gully",
    "gulp",
    "gumball",
    "gumdrop",
    "gumminess",
    "gumming",
    "gummy",
    "gurgle",
    "gurgling",
    "guru",
    "gush",
    "gusto",
    "gusty",
    "gutless",
    "guts",
    "gutter",
    "guy",
    "guzzler",
    "gyration",
    "habitable",
    "habitant",
    "habitat",
    "habitual",
    "hacked",
    "hacker",
    "hacking",
    "hacksaw",
    "had",
    "haggler",
    "haiku",
    "half",
    "halogen",
    "halt",
    "halved",
    "halves",
    "hamburger",
    "hamlet",
    "hammock",
    "hamper",
    "hamster",
    "hamstring",
    "handbag",
    "handball",
    "handbook",
    "handbrake",
    "handcart",
    "handclap",
    "handclasp",
    "handcraft",
    "handcuff",
    "handed",
    "handful",
    "handgrip",
    "handgun",
    "handheld",
    "handiness",
    "handiwork",
    "handlebar",
    "handled",
    "handler",
    "handling",
    "handmade",
    "handoff",
    "handpick",
    "handprint",
    "handrail",
    "handsaw",
    "handset",
    "handsfree",
    "handshake",
    "handstand",
    "handwash",
    "handwork",
    "handwoven",
    "handwrite",
    "handyman",
    "hangnail",
    "hangout",
    "hangover",
    "hangup",
    "hankering",
    "hankie",
    "hanky",
    "haphazard",
    "happening",
    "happier",
    "happiest",
    "happily",
    "happiness",
    "happy",
    "harbor",
    "hardcopy",
    "hardcore",
    "hardcover",
    "harddisk",
    "hardened",
    "hardener",
    "hardening",
    "hardhat",
    "hardhead",
    "hardiness",
    "hardly",
    "hardness",
    "hardship",
    "hardware",
    "hardwired",
    "hardwood",
    "hardy",
    "harmful",
    "harmless",
    "harmonica",
    "harmonics",
    "harmonize",
    "harmony",
    "harness",
    "harpist",
    "harsh",
    "harvest",
    "hash",
    "hassle",
    "haste",
    "hastily",
    "hastiness",
    "hasty",
    "hatbox",
    "hatchback",
    "hatchery",
    "hatchet",
    "hatching",
    "hatchling",
    "hate",
    "hatless",
    "hatred",
    "haunt",
    "haven",
    "hazard",
    "hazelnut",
    "hazily",
    "haziness",
    "hazing",
    "hazy",
    "headache",
    "headband",
    "headboard",
    "headcount",
    "headdress",
    "headed",
    "header",
    "headfirst",
    "headgear",
    "heading",
    "headlamp",
    "headless",
    "headlock",
    "headphone",
    "headpiece",
    "headrest",
    "headroom",
    "headscarf",
    "headset",
    "headsman",
    "headstand",
    "headstone",
    "headway",
    "headwear",
    "heap",
    "heat",
    "heave",
    "heavily",
    "heaviness",
    "heaving",
    "hedge",
    "hedging",
    "heftiness",
    "hefty",
    "helium",
    "helmet",
    "helper",
    "helpful",
    "helping",
    "helpless",
    "helpline",
    "hemlock",
    "hemstitch",
    "hence",
    "henchman",
    "henna",
    "herald",
    "herbal",
    "herbicide",
    "herbs",
    "heritage",
    "hermit",
    "heroics",
    "heroism",
    "herring",
    "herself",
    "hertz",
    "hesitancy",
    "hesitant",
    "hesitate",
    "hexagon",
    "hexagram",
    "hubcap",
    "huddle",
    "huddling",
    "huff",
    "hug",
    "hula",
    "hulk",
    "hull",
    "human",
    "humble",
    "humbling",
    "humbly",
    "humid",
    "humiliate",
    "humility",
    "humming",
    "hummus",
    "humongous",
    "humorist",
    "humorless",
    "humorous",
    "humpback",
    "humped",
    "humvee",
    "hunchback",
    "hundredth",
    "hunger",
    "hungrily",
    "hungry",
    "hunk",
    "hunter",
    "hunting",
    "huntress",
    "huntsman",
    "hurdle",
    "hurled",
    "hurler",
    "hurling",
    "hurray",
    "hurricane",
    "hurried",
    "hurry",
    "hurt",
    "husband",
    "hush",
    "husked",
    "huskiness",
    "hut",
    "hybrid",
    "hydrant",
    "hydrated",
    "hydration",
    "hydrogen",
    "hydroxide",
    "hyperlink",
    "hypertext",
    "hyphen",
    "hypnoses",
    "hypnosis",
    "hypnotic",
    "hypnotism",
    "hypnotist",
    "hypnotize",
    "hypocrisy",
    "hypocrite",
    "ibuprofen",
    "ice",
    "iciness",
    "icing",
    "icky",
    "icon",
    "icy",
    "idealism",
    "idealist",
    "idealize",
    "ideally",
    "idealness",
    "identical",
    "identify",
    "identity",
    "ideology",
    "idiocy",
    "idiom",
    "idly",
    "igloo",
    "ignition",
    "ignore",
    "iguana",
    "illicitly",
    "illusion",
    "illusive",
    "image",
    "imaginary",
    "imagines",
    "imaging",
    "imbecile",
    "imitate",
    "imitation",
    "immature",
    "immerse",
    "immersion",
    "imminent",
    "immobile",
    "immodest",
    "immorally",
    "immortal",
    "immovable",
    "immovably",
    "immunity",
    "immunize",
    "impaired",
    "impale",
    "impart",
    "impatient",
    "impeach",
    "impeding",
    "impending",
    "imperfect",
    "imperial",
    "impish",
    "implant",
    "implement",
    "implicate",
    "implicit",
    "implode",
    "implosion",
    "implosive",
    "imply",
    "impolite",
    "important",
    "importer",
    "impose",
    "imposing",
    "impotence",
    "impotency",
    "impotent",
    "impound",
    "imprecise",
    "imprint",
    "imprison",
    "impromptu",
    "improper",
    "improve",
    "improving",
    "improvise",
    "imprudent",
    "impulse",
    "impulsive",
    "impure",
    "impurity",
    "iodine",
    "iodize",
    "ion",
    "ipad",
    "iphone",
    "ipod",
    "irate",
    "irk",
    "iron",
    "irregular",
    "irrigate",
    "irritable",
    "irritably",
    "irritant",
    "irritate",
    "islamic",
    "islamist",
    "isolated",
    "isolating",
    "isolation",
    "isotope",
    "issue",
    "issuing",
    "italicize",
    "italics",
    "item",
    "itinerary",
    "itunes",
    "ivory",
    "ivy",
    "jab",
    "jackal",
    "jacket",
    "jackknife",
    "jackpot",
    "jailbird",
    "jailbreak",
    "jailer",
    "jailhouse",
    "jalapeno",
    "jam",
    "janitor",
    "january",
    "jargon",
    "jarring",
    "jasmine",
    "jaundice",
    "jaunt",
    "java",
    "jawed",
    "jawless",
    "jawline",
    "jaws",
    "jaybird",
    "jaywalker",
    "jazz",
    "jeep",
    "jeeringly",
    "jellied",
    "jelly",
    "jersey",
    "jester",
    "jet",
    "jiffy",
    "jigsaw",
    "jimmy",
    "jingle",
    "jingling",
    "jinx",
    "jitters",
    "jittery",
    "job",
    "jockey",
    "jockstrap",
    "jogger",
    "jogging",
    "john",
    "joining",
    "jokester",
    "jokingly",
    "jolliness",
    "jolly",
    "jolt",
    "jot",
    "jovial",
    "joyfully",
    "joylessly",
    "joyous",
    "joyride",
    "joystick",
    "jubilance",
    "jubilant",
    "judge",
    "judgingly",
    "judicial",
    "judiciary",
    "judo",
    "juggle",
    "juggling",
    "jugular",
    "juice",
    "juiciness",
    "juicy",
    "jujitsu",
    "jukebox",
    "july",
    "jumble",
    "jumbo",
    "jump",
    "junction",
    "juncture",
    "june",
    "junior",
    "juniper",
    "junkie",
    "junkman",
    "junkyard",
    "jurist",
    "juror",
    "jury",
    "justice",
    "justifier",
    "justify",
    "justly",
    "justness",
    "juvenile",
    "kabob",
    "kangaroo",
    "karaoke",
    "karate",
    "karma",
    "kebab",
    "keenly",
    "keenness",
    "keep",
    "keg",
    "kelp",
    "kennel",
    "kept",
    "kerchief",
    "kerosene",
    "kettle",
    "kick",
    "kiln",
    "kilobyte",
    "kilogram",
    "kilometer",
    "kilowatt",
    "kilt",
    "kimono",
    "kindle",
    "kindling",
    "kindly",
    "kindness",
    "kindred",
    "kinetic",
    "kinfolk",
    "king",
    "kinship",
    "kinsman",
    "kinswoman",
    "kissable",
    "kisser",
    "kissing",
    "kitchen",
    "kite",
    "kitten",
    "kitty",
    "kiwi",
    "kleenex",
    "knapsack",
    "knee",
    "knelt",
    "knickers",
    "knoll",
    "koala",
    "kooky",
    "kosher",
    "krypton",
    "kudos",
    "kung",
    "labored",
    "laborer",
    "laboring",
    "laborious",
    "labrador",
    "ladder",
    "ladies",
    "ladle",
    "ladybug",
    "ladylike",
    "lagged",
    "lagging",
    "lagoon",
    "lair",
    "lake",
    "lance",
    "landed",
    "landfall",
    "landfill",
    "landing",
    "landlady",
    "landless",
    "landline",
    "landlord",
    "landmark",
    "landmass",
    "landmine",
    "landowner",
    "landscape",
    "landside",
    "landslide",
    "language",
    "lankiness",
    "lanky",
    "lantern",
    "lapdog",
    "lapel",
    "lapped",
    "lapping",
    "laptop",
    "lard",
    "large",
    "lark",
    "lash",
    "lasso",
    "last",
    "latch",
    "late",
    "lather",
    "latitude",
    "latrine",
    "latter",
    "latticed",
    "launch",
    "launder",
    "laundry",
    "laurel",
    "lavender",
    "lavish",
    "laxative",
    "lazily",
    "laziness",
    "lazy",
    "lecturer",
    "left",
    "legacy",
    "legal",
    "legend",
    "legged",
    "leggings",
    "legible",
    "legibly",
    "legislate",
    "lego",
    "legroom",
    "legume",
    "legwarmer",
    "legwork",
    "lemon",
    "lend",
    "length",
    "lens",
    "lent",
    "leotard",
    "lesser",
    "letdown",
    "lethargic",
    "lethargy",
    "letter",
    "lettuce",
    "level",
    "leverage",
    "levers",
    "levitate",
    "levitator",
    "liability",
    "liable",
    "liberty",
    "librarian",
    "library",
    "licking",
    "licorice",
    "lid",
    "life",
    "lifter",
    "lifting",
    "liftoff",
    "ligament",
    "likely",
    "likeness",
    "likewise",
    "liking",
    "lilac",
    "lilly",
    "lily",
    "limb",
    "limeade",
    "limelight",
    "limes",
    "limit",
    "limping",
    "limpness",
    "line",
    "lingo",
    "linguini",
    "linguist",
    "lining",
    "linked",
    "linoleum",
    "linseed",
    "lint",
    "lion",
    "lip",
    "liquefy",
    "liqueur",
    "liquid",
    "lisp",
    "list",
    "litigate",
    "litigator",
    "litmus",
    "litter",
    "little",
    "livable",
    "lived",
    "lively",
    "liver",
    "livestock",
    "lividly",
    "living",
    "lizard",
    "lubricant",
    "lubricate",
    "lucid",
    "luckily",
    "luckiness",
    "luckless",
    "lucrative",
    "ludicrous",
    "lugged",
    "lukewarm",
    "lullaby",
    "lumber",
    "luminance",
    "luminous",
    "lumpiness",
    "lumping",
    "lumpish",
    "lunacy",
    "lunar",
    "lunchbox",
    "luncheon",
    "lunchroom",
    "lunchtime",
    "lung",
    "lurch",
    "lure",
    "luridness",
    "lurk",
    "lushly",
    "lushness",
    "luster",
    "lustfully",
    "lustily",
    "lustiness",
    "lustrous",
    "lusty",
    "luxurious",
    "luxury",
    "lying",
    "lyrically",
    "lyricism",
    "lyricist",
    "lyrics",
    "macarena",
    "macaroni",
    "macaw",
    "mace",
    "machine",
    "machinist",
    "magazine",
    "magenta",
    "maggot",
    "magical",
    "magician",
    "magma",
    "magnesium",
    "magnetic",
    "magnetism",
    "magnetize",
    "magnifier",
    "magnify",
    "magnitude",
    "magnolia",
    "mahogany",
    "maimed",
    "majestic",
    "majesty",
    "majorette",
    "majority",
    "makeover",
    "maker",
    "makeshift",
    "making",
    "malformed",
    "malt",
    "mama",
    "mammal",
    "mammary",
    "mammogram",
    "manager",
    "managing",
    "manatee",
    "mandarin",
    "mandate",
    "mandatory",
    "mandolin",
    "manger",
    "mangle",
    "mango",
    "mangy",
    "manhandle",
    "manhole",
    "manhood",
    "manhunt",
    "manicotti",
    "manicure",
    "manifesto",
    "manila",
    "mankind",
    "manlike",
    "manliness",
    "manly",
    "manmade",
    "manned",
    "mannish",
    "manor",
    "manpower",
    "mantis",
    "mantra",
    "manual",
    "many",
    "map",
    "marathon",
    "marauding",
    "marbled",
    "marbles",
    "marbling",
    "march",
    "mardi",
    "margarine",
    "margarita",
    "margin",
    "marigold",
    "marina",
    "marine",
    "marital",
    "maritime",
    "marlin",
    "marmalade",
    "maroon",
    "married",
    "marrow",
    "marry",
    "marshland",
    "marshy",
    "marsupial",
    "marvelous",
    "marxism",
    "mascot",
    "masculine",
    "mashed",
    "mashing",
    "massager",
    "masses",
    "massive",
    "mastiff",
    "matador",
    "matchbook",
    "matchbox",
    "matcher",
    "matching",
    "matchless",
    "material",
    "maternal",
    "maternity",
    "math",
    "mating",
    "matriarch",
    "matrimony",
    "matrix",
    "matron",
    "matted",
    "matter",
    "maturely",
    "maturing",
    "maturity",
    "mauve",
    "maverick",
    "maximize",
    "maximum",
    "maybe",
    "mayday",
    "mayflower",
    "moaner",
    "moaning",
    "mobile",
    "mobility",
    "mobilize",
    "mobster",
    "mocha",
    "mocker",
    "mockup",
    "modified",
    "modify",
    "modular",
    "modulator",
    "module",
    "moisten",
    "moistness",
    "moisture",
    "molar",
    "molasses",
    "mold",
    "molecular",
    "molecule",
    "molehill",
    "mollusk",
    "mom",
    "monastery",
    "monday",
    "monetary",
    "monetize",
    "moneybags",
    "moneyless",
    "moneywise",
    "mongoose",
    "mongrel",
    "monitor",
    "monkhood",
    "monogamy",
    "monogram",
    "monologue",
    "monopoly",
    "monorail",
    "monotone",
    "monotype",
    "monoxide",
    "monsieur",
    "monsoon",
    "monstrous",
    "monthly",
    "monument",
    "moocher",
    "moodiness",
    "moody",
    "mooing",
    "moonbeam",
    "mooned",
    "moonlight",
    "moonlike",
    "moonlit",
    "moonrise",
    "moonscape",
    "moonshine",
    "moonstone",
    "moonwalk",
    "mop",
    "morale",
    "morality",
    "morally",
    "morbidity",
    "morbidly",
    "morphine",
    "morphing",
    "morse",
    "mortality",
    "mortally",
    "mortician",
    "mortified",
    "mortify",
    "mortuary",
    "mosaic",
    "mossy",
    "most",
    "mothball",
    "mothproof",
    "motion",
    "motivate",
    "motivator",
    "motive",
    "motocross",
    "motor",
    "motto",
    "mountable",
    "mountain",
    "mounted",
    "mounting",
    "mourner",
    "mournful",
    "mouse",
    "mousiness",
    "moustache",
    "mousy",
    "mouth",
    "movable",
    "move",
    "movie",
    "moving",
    "mower",
    "mowing",
    "much",
    "muck",
    "mud",
    "mug",
    "mulberry",
    "mulch",
    "mule",
    "mulled",
    "mullets",
    "multiple",
    "multiply",
    "multitask",
    "multitude",
    "mumble",
    "mumbling",
    "mumbo",
    "mummified",
    "mummify",
    "mummy",
    "mumps",
    "munchkin",
    "mundane",
    "municipal",
    "muppet",
    "mural",
    "murkiness",
    "murky",
    "murmuring",
    "muscular",
    "museum",
    "mushily",
    "mushiness",
    "mushroom",
    "mushy",
    "music",
    "musket",
    "muskiness",
    "musky",
    "mustang",
    "mustard",
    "muster",
    "mustiness",
    "musty",
    "mutable",
    "mutate",
    "mutation",
    "mute",
    "mutilated",
    "mutilator",
    "mutiny",
    "mutt",
    "mutual",
    "muzzle",
    "myself",
    "myspace",
    "mystified",
    "mystify",
    "myth",
    "nacho",
    "nag",
    "nail",
    "name",
    "naming",
    "nanny",
    "nanometer",
    "nape",
    "napkin",
    "napped",
    "napping",
    "nappy",
    "narrow",
    "nastily",
    "nastiness",
    "national",
    "native",
    "nativity",
    "natural",
    "nature",
    "naturist",
    "nautical",
    "navigate",
    "navigator",
    "navy",
    "nearby",
    "nearest",
    "nearly",
    "nearness",
    "neatly",
    "neatness",
    "nebula",
    "nebulizer",
    "nectar",
    "negate",
    "negation",
    "negative",
    "neglector",
    "negligee",
    "negligent",
    "negotiate",
    "nemeses",
    "nemesis",
    "neon",
    "nephew",
    "nerd",
    "nervous",
    "nervy",
    "nest",
    "net",
    "neurology",
    "neuron",
    "neurosis",
    "neurotic",
    "neuter",
    "neutron",
    "never",
    "next",
    "nibble",
    "nickname",
    "nicotine",
    "niece",
    "nifty",
    "nimble",
    "nimbly",
    "nineteen",
    "ninetieth",
    "ninja",
    "nintendo",
    "ninth",
    "nuclear",
    "nuclei",
    "nucleus",
    "nugget",
    "nullify",
    "number",
    "numbing",
    "numbly",
    "numbness",
    "numeral",
    "numerate",
    "numerator",
    "numeric",
    "numerous",
    "nuptials",
    "nursery",
    "nursing",
    "nurture",
    "nutcase",
    "nutlike",
    "nutmeg",
    "nutrient",
    "nutshell",
    "nuttiness",
    "nutty",
    "nuzzle",
    "nylon",
    "oaf",
    "oak",
    "oasis",
    "oat",
    "obedience",
    "obedient",
    "obituary",
    "object",
    "obligate",
    "obliged",
    "oblivion",
    "oblivious",
    "oblong",
    "obnoxious",
    "oboe",
    "obscure",
    "obscurity",
    "observant",
    "observer",
    "observing",
    "obsessed",
    "obsession",
    "obsessive",
    "obsolete",
    "obstacle",
    "obstinate",
    "obstruct",
    "obtain",
    "obtrusive",
    "obtuse",
    "obvious",
    "occultist",
    "occupancy",
    "occupant",
    "occupier",
    "occupy",
    "ocean",
    "ocelot",
    "octagon",
    "octane",
    "october",
    "octopus",
    "ogle",
    "oil",
    "oink",
    "ointment",
    "okay",
    "old",
    "olive",
    "olympics",
    "omega",
    "omen",
    "ominous",
    "omission",
    "omit",
    "omnivore",
    "onboard",
    "oncoming",
    "ongoing",
    "onion",
    "online",
    "onlooker",
    "only",
    "onscreen",
    "onset",
    "onshore",
    "onslaught",
    "onstage",
    "onto",
    "onward",
    "onyx",
    "oops",
    "ooze",
    "oozy",
    "opacity",
    "opal",
    "open",
    "operable",
    "operate",
    "operating",
    "operation",
    "operative",
    "operator",
    "opium",
    "opossum",
    "opponent",
    "oppose",
    "opposing",
    "opposite",
    "oppressed",
    "oppressor",
    "opt",
    "opulently",
    "osmosis",
    "other",
    "otter",
    "ouch",
    "ought",
    "ounce",
    "outage",
    "outback",
    "outbid",
    "outboard",
    "outbound",
    "outbreak",
    "outburst",
    "outcast",
    "outclass",
    "outcome",
    "outdated",
    "outdoors",
    "outer",
    "outfield",
    "outfit",
    "outflank",
    "outgoing",
    "outgrow",
    "outhouse",
    "outing",
    "outlast",
    "outlet",
    "outline",
    "outlook",
    "outlying",
    "outmatch",
    "outmost",
    "outnumber",
    "outplayed",
    "outpost",
    "outpour",
    "output",
    "outrage",
    "outrank",
    "outreach",
    "outright",
    "outscore",
    "outsell",
    "outshine",
    "outshoot",
    "outsider",
    "outskirts",
    "outsmart",
    "outsource",
    "outspoken",
    "outtakes",
    "outthink",
    "outward",
    "outweigh",
    "outwit",
    "oval",
    "ovary",
    "oven",
    "overact",
    "overall",
    "overarch",
    "overbid",
    "overbill",
    "overbite",
    "overblown",
    "overboard",
    "overbook",
    "overbuilt",
    "overcast",
    "overcoat",
    "overcome",
    "overcook",
    "overcrowd",
    "overdraft",
    "overdrawn",
    "overdress",
    "overdrive",
    "overdue",
    "overeager",
    "overeater",
    "overexert",
    "overfed",
    "overfeed",
    "overfill",
    "overflow",
    "overfull",
    "overgrown",
    "overhand",
    "overhang",
    "overhaul",
    "overhead",
    "overhear",
    "overheat",
    "overhung",
    "overjoyed",
    "overkill",
    "overlabor",
    "overlaid",
    "overlap",
    "overlay",
    "overload",
    "overlook",
    "overlord",
    "overlying",
    "overnight",
    "overpass",
    "overpay",
    "overplant",
    "overplay",
    "overpower",
    "overprice",
    "overrate",
    "overreach",
    "overreact",
    "override",
    "overripe",
    "overrule",
    "overrun",
    "overshoot",
    "overshot",
    "oversight",
    "oversized",
    "oversleep",
    "oversold",
    "overspend",
    "overstate",
    "overstay",
    "overstep",
    "overstock",
    "overstuff",
    "oversweet",
    "overtake",
    "overthrow",
    "overtime",
    "overtly",
    "overtone",
    "overture",
    "overturn",
    "overuse",
    "overvalue",
    "overview",
    "overwrite",
    "owl",
    "oxford",
    "oxidant",
    "oxidation",
    "oxidize",
    "oxidizing",
    "oxygen",
    "oxymoron",
    "oyster",
    "ozone",
    "paced",
    "pacemaker",
    "pacific",
    "pacifier",
    "pacifism",
    "pacifist",
    "pacify",
    "padded",
    "padding",
    "paddle",
    "paddling",
    "padlock",
    "pagan",
    "pager",
    "paging",
    "pajamas",
    "palace",
    "palatable",
    "palm",
    "palpable",
    "palpitate",
    "paltry",
    "pampered",
    "pamperer",
    "pampers",
    "pamphlet",
    "panama",
    "pancake",
    "pancreas",
    "panda",
    "pandemic",
    "pang",
    "panhandle",
    "panic",
    "panning",
    "panorama",
    "panoramic",
    "panther",
    "pantomime",
    "pantry",
    "pants",
    "pantyhose",
    "paparazzi",
    "papaya",
    "paper",
    "paprika",
    "papyrus",
    "parabola",
    "parachute",
    "parade",
    "paradox",
    "paragraph",
    "parakeet",
    "paralegal",
    "paralyses",
    "paralysis",
    "paralyze",
    "paramedic",
    "parameter",
    "paramount",
    "parasail",
    "parasite",
    "parasitic",
    "parcel",
    "parched",
    "parchment",
    "pardon",
    "parish",
    "parka",
    "parking",
    "parkway",
    "parlor",
    "parmesan",
    "parole",
    "parrot",
    "parsley",
    "parsnip",
    "partake",
    "parted",
    "parting",
    "partition",
    "partly",
    "partner",
    "partridge",
    "party",
    "passable",
    "passably",
    "passage",
    "passcode",
    "passenger",
    "passerby",
    "passing",
    "passion",
    "passive",
    "passivism",
    "passover",
    "passport",
    "password",
    "pasta",
    "pasted",
    "pastel",
    "pastime",
    "pastor",
    "pastrami",
    "pasture",
    "pasty",
    "patchwork",
    "patchy",
    "paternal",
    "paternity",
    "path",
    "patience",
    "patient",
    "patio",
    "patriarch",
    "patriot",
    "patrol",
    "patronage",
    "patronize",
    "pauper",
    "pavement",
    "paver",
    "pavestone",
    "pavilion",
    "paving",
    "pawing",
    "payable",
    "payback",
    "paycheck",
    "payday",
    "payee",
    "payer",
    "paying",
    "payment",
    "payphone",
    "payroll",
    "pebble",
    "pebbly",
    "pecan",
    "pectin",
    "peculiar",
    "peddling",
    "pediatric",
    "pedicure",
    "pedigree",
    "pedometer",
    "pegboard",
    "pelican",
    "pellet",
    "pelt",
    "pelvis",
    "penalize",
    "penalty",
    "pencil",
    "pendant",
    "pending",
    "penholder",
    "penknife",
    "pennant",
    "penniless",
    "penny",
    "penpal",
    "pension",
    "pentagon",
    "pentagram",
    "pep",
    "perceive",
    "percent",
    "perch",
    "percolate",
    "perennial",
    "perfected",
    "perfectly",
    "perfume",
    "periscope",
    "perish",
    "perjurer",
    "perjury",
    "perkiness",
    "perky",
    "perm",
    "peroxide",
    "perpetual",
    "perplexed",
    "persecute",
    "persevere",
    "persuaded",
    "persuader",
    "pesky",
    "peso",
    "pessimism",
    "pessimist",
    "pester",
    "pesticide",
    "petal",
    "petite",
    "petition",
    "petri",
    "petroleum",
    "petted",
    "petticoat",
    "pettiness",
    "petty",
    "petunia",
    "phantom",
    "phobia",
    "phoenix",
    "phonebook",
    "phoney",
    "phonics",
    "phoniness",
    "phony",
    "phosphate",
    "photo",
    "phrase",
    "phrasing",
    "placard",
    "placate",
    "placidly",
    "plank",
    "planner",
    "plant",
    "plasma",
    "plaster",
    "plastic",
    "plated",
    "platform",
    "plating",
    "platinum",
    "platonic",
    "platter",
    "platypus",
    "plausible",
    "plausibly",
    "playable",
    "playback",
    "player",
    "playful",
    "playgroup",
    "playhouse",
    "playing",
    "playlist",
    "playmaker",
    "playmate",
    "playoff",
    "playpen",
    "playroom",
    "playset",
    "plaything",
    "playtime",
    "plaza",
    "pleading",
    "pleat",
    "pledge",
    "plentiful",
    "plenty",
    "plethora",
    "plexiglas",
    "pliable",
    "plod",
    "plop",
    "plot",
    "plow",
    "ploy",
    "pluck",
    "plug",
    "plunder",
    "plunging",
    "plural",
    "plus",
    "plutonium",
    "plywood",
    "poach",
    "pod",
    "poem",
    "poet",
    "pogo",
    "pointed",
    "pointer",
    "pointing",
    "pointless",
    "pointy",
    "poise",
    "poison",
    "poker",
    "poking",
    "polar",
    "police",
    "policy",
    "polio",
    "polish",
    "politely",
    "polka",
    "polo",
    "polyester",
    "polygon",
    "polygraph",
    "polymer",
    "poncho",
    "pond",
    "pony",
    "popcorn",
    "pope",
    "poplar",
    "popper",
    "poppy",
    "popsicle",
    "populace",
    "popular",
    "populate",
    "porcupine",
    "pork",
    "porous",
    "porridge",
    "portable",
    "portal",
    "portfolio",
    "porthole",
    "portion",
    "portly",
    "portside",
    "poser",
    "posh",
    "posing",
    "possible",
    "possibly",
    "possum",
    "postage",
    "postal",
    "postbox",
    "postcard",
    "posted",
    "poster",
    "posting",
    "postnasal",
    "posture",
    "postwar",
    "pouch",
    "pounce",
    "pouncing",
    "pound",
    "pouring",
    "pout",
    "powdered",
    "powdering",
    "powdery",
    "power",
    "powwow",
    "pox",
    "praising",
    "prance",
    "prancing",
    "pranker",
    "prankish",
    "prankster",
    "prayer",
    "praying",
    "preacher",
    "preaching",
    "preachy",
    "preamble",
    "precinct",
    "precise",
    "precision",
    "precook",
    "precut",
    "predator",
    "predefine",
    "predict",
    "preface",
    "prefix",
    "preflight",
    "preformed",
    "pregame",
    "pregnancy",
    "pregnant",
    "preheated",
    "prelaunch",
    "prelaw",
    "prelude",
    "premiere",
    "premises",
    "premium",
    "prenatal",
    "preoccupy",
    "preorder",
    "prepaid",
    "prepay",
    "preplan",
    "preppy",
    "preschool",
    "prescribe",
    "preseason",
    "preset",
    "preshow",
    "president",
    "presoak",
    "press",
    "presume",
    "presuming",
    "preteen",
    "pretended",
    "pretender",
    "pretense",
    "pretext",
    "pretty",
    "pretzel",
    "prevail",
    "prevalent",
    "prevent",
    "preview",
    "previous",
    "prewar",
    "prewashed",
    "prideful",
    "pried",
    "primal",
    "primarily",
    "primary",
    "primate",
    "primer",
    "primp",
    "princess",
    "print",
    "prior",
    "prism",
    "prison",
    "prissy",
    "pristine",
    "privacy",
    "private",
    "privatize",
    "prize",
    "proactive",
    "probable",
    "probably",
    "probation",
    "probe",
    "probing",
    "probiotic",
    "problem",
    "procedure",
    "process",
    "proclaim",
    "procreate",
    "procurer",
    "prodigal",
    "prodigy",
    "produce",
    "product",
    "profane",
    "profanity",
    "professed",
    "professor",
    "profile",
    "profound",
    "profusely",
    "progeny",
    "prognosis",
    "program",
    "progress",
    "projector",
    "prologue",
    "prolonged",
    "promenade",
    "prominent",
    "promoter",
    "promotion",
    "prompter",
    "promptly",
    "prone",
    "prong",
    "pronounce",
    "pronto",
    "proofing",
    "proofread",
    "proofs",
    "propeller",
    "properly",
    "property",
    "proponent",
    "proposal",
    "propose",
    "props",
    "prorate",
    "protector",
    "protegee",
    "proton",
    "prototype",
    "protozoan",
    "protract",
    "protrude",
    "proud",
    "provable",
    "proved",
    "proven",
    "provided",
    "provider",
    "providing",
    "province",
    "proving",
    "provoke",
    "provoking",
    "provolone",
    "prowess",
    "prowler",
    "prowling",
    "proximity",
    "proxy",
    "prozac",
    "prude",
    "prudishly",
    "prune",
    "pruning",
    "pry",
    "psychic",
    "public",
    "publisher",
    "pucker",
    "pueblo",
    "pug",
    "pull",
    "pulmonary",
    "pulp",
    "pulsate",
    "pulse",
    "pulverize",
    "puma",
    "pumice",
    "pummel",
    "punch",
    "punctual",
    "punctuate",
    "punctured",
    "pungent",
    "punisher",
    "punk",
    "pupil",
    "puppet",
    "puppy",
    "purchase",
    "pureblood",
    "purebred",
    "purely",
    "pureness",
    "purgatory",
    "purge",
    "purging",
    "purifier",
    "purify",
    "purist",
    "puritan",
    "purity",
    "purple",
    "purplish",
    "purposely",
    "purr",
    "purse",
    "pursuable",
    "pursuant",
    "pursuit",
    "purveyor",
    "pushcart",
    "pushchair",
    "pusher",
    "pushiness",
    "pushing",
    "pushover",
    "pushpin",
    "pushup",
    "pushy",
    "putdown",
    "putt",
    "puzzle",
    "puzzling",
    "pyramid",
    "pyromania",
    "python",
    "quack",
    "quadrant",
    "quail",
    "quaintly",
    "quake",
    "quaking",
    "qualified",
    "qualifier",
    "qualify",
    "quality",
    "qualm",
    "quantum",
    "quarrel",
    "quarry",
    "quartered",
    "quarterly",
    "quarters",
    "quartet",
    "quench",
    "query",
    "quicken",
    "quickly",
    "quickness",
    "quicksand",
    "quickstep",
    "quiet",
    "quill",
    "quilt",
    "quintet",
    "quintuple",
    "quirk",
    "quit",
    "quiver",
    "quizzical",
    "quotable",
    "quotation",
    "quote",
    "rabid",
    "race",
    "racing",
    "racism",
    "rack",
    "racoon",
    "radar",
    "radial",
    "radiance",
    "radiantly",
    "radiated",
    "radiation",
    "radiator",
    "radio",
    "radish",
    "raffle",
    "raft",
    "rage",
    "ragged",
    "raging",
    "ragweed",
    "raider",
    "railcar",
    "railing",
    "railroad",
    "railway",
    "raisin",
    "rake",
    "raking",
    "rally",
    "ramble",
    "rambling",
    "ramp",
    "ramrod",
    "ranch",
    "rancidity",
    "random",
    "ranged",
    "ranger",
    "ranging",
    "ranked",
    "ranking",
    "ransack",
    "ranting",
    "rants",
    "rare",
    "rarity",
    "rascal",
    "rash",
    "rasping",
    "ravage",
    "raven",
    "ravine",
    "raving",
    "ravioli",
    "ravishing",
    "reabsorb",
    "reach",
    "reacquire",
    "reaction",
    "reactive",
    "reactor",
    "reaffirm",
    "ream",
    "reanalyze",
    "reappear",
    "reapply",
    "reappoint",
    "reapprove",
    "rearrange",
    "rearview",
    "reason",
    "reassign",
    "reassure",
    "reattach",
    "reawake",
    "rebalance",
    "rebate",
    "rebel",
    "rebirth",
    "reboot",
    "reborn",
    "rebound",
    "rebuff",
    "rebuild",
    "rebuilt",
    "reburial",
    "rebuttal",
    "recall",
    "recant",
    "recapture",
    "recast",
    "recede",
    "recent",
    "recess",
    "recharger",
    "recipient",
    "recital",
    "recite",
    "reckless",
    "reclaim",
    "recliner",
    "reclining",
    "recluse",
    "reclusive",
    "recognize",
    "recoil",
    "recollect",
    "recolor",
    "reconcile",
    "reconfirm",
    "reconvene",
    "recopy",
    "record",
    "recount",
    "recoup",
    "recovery",
    "recreate",
    "rectal",
    "rectangle",
    "rectified",
    "rectify",
    "recycled",
    "recycler",
    "recycling",
    "reemerge",
    "reenact",
    "reenter",
    "reentry",
    "reexamine",
    "referable",
    "referee",
    "reference",
    "refill",
    "refinance",
    "refined",
    "refinery",
    "refining",
    "refinish",
    "reflected",
    "reflector",
    "reflex",
    "reflux",
    "refocus",
    "refold",
    "reforest",
    "reformat",
    "reformed",
    "reformer",
    "reformist",
    "refract",
    "refrain",
    "refreeze",
    "refresh",
    "refried",
    "refueling",
    "refund",
    "refurbish",
    "refurnish",
    "refusal",
    "refuse",
    "refusing",
    "refutable",
    "refute",
    "regain",
    "regalia",
    "regally",
    "reggae",
    "regime",
    "region",
    "register",
    "registrar",
    "registry",
    "regress",
    "regretful",
    "regroup",
    "regular",
    "regulate",
    "regulator",
    "rehab",
    "reheat",
    "rehire",
    "rehydrate",
    "reimburse",
    "reissue",
    "reiterate",
    "rejoice",
    "rejoicing",
    "rejoin",
    "rekindle",
    "relapse",
    "relapsing",
    "relatable",
    "related",
    "relation",
    "relative",
    "relax",
    "relay",
    "relearn",
    "release",
    "relenting",
    "reliable",
    "reliably",
    "reliance",
    "reliant",
    "relic",
    "relieve",
    "relieving",
    "relight",
    "relish",
    "relive",
    "reload",
    "relocate",
    "relock",
    "reluctant",
    "rely",
    "remake",
    "remark",
    "remarry",
    "rematch",
    "remedial",
    "remedy",
    "remember",
    "reminder",
    "remindful",
    "remission",
    "remix",
    "remnant",
    "remodeler",
    "remold",
    "remorse",
    "remote",
    "removable",
    "removal",
    "removed",
    "remover",
    "removing",
    "rename",
    "renderer",
    "rendering",
    "rendition",
    "renegade",
    "renewable",
    "renewably",
    "renewal",
    "renewed",
    "renounce",
    "renovate",
    "renovator",
    "rentable",
    "rental",
    "rented",
    "renter",
    "reoccupy",
    "reoccur",
    "reopen",
    "reorder",
    "repackage",
    "repacking",
    "repaint",
    "repair",
    "repave",
    "repaying",
    "repayment",
    "repeal",
    "repeated",
    "repeater",
    "repent",
    "rephrase",
    "replace",
    "replay",
    "replica",
    "reply",
    "reporter",
    "repose",
    "repossess",
    "repost",
    "repressed",
    "reprimand",
    "reprint",
    "reprise",
    "reproach",
    "reprocess",
    "reproduce",
    "reprogram",
    "reps",
    "reptile",
    "reptilian",
    "repugnant",
    "repulsion",
    "repulsive",
    "repurpose",
    "reputable",
    "reputably",
    "request",
    "require",
    "requisite",
    "reroute",
    "rerun",
    "resale",
    "resample",
    "rescuer",
    "reseal",
    "research",
    "reselect",
    "reseller",
    "resemble",
    "resend",
    "resent",
    "reset",
    "reshape",
    "reshoot",
    "reshuffle",
    "residence",
    "residency",
    "resident",
    "residual",
    "residue",
    "resigned",
    "resilient",
    "resistant",
    "resisting",
    "resize",
    "resolute",
    "resolved",
    "resonant",
    "resonate",
    "resort",
    "resource",
    "respect",
    "resubmit",
    "result",
    "resume",
    "resupply",
    "resurface",
    "resurrect",
    "retail",
    "retainer",
    "retaining",
    "retake",
    "retaliate",
    "retention",
    "rethink",
    "retinal",
    "retired",
    "retiree",
    "retiring",
    "retold",
    "retool",
    "retorted",
    "retouch",
    "retrace",
    "retract",
    "retrain",
    "retread",
    "retreat",
    "retrial",
    "retrieval",
    "retriever",
    "retry",
    "return",
    "retying",
    "retype",
    "reunion",
    "reunite",
    "reusable",
    "reuse",
    "reveal",
    "reveler",
    "revenge",
    "revenue",
    "reverb",
    "revered",
    "reverence",
    "reverend",
    "reversal",
    "reverse",
    "reversing",
    "reversion",
    "revert",
    "revisable",
    "revise",
    "revision",
    "revisit",
    "revivable",
    "revival",
    "reviver",
    "reviving",
    "revocable",
    "revoke",
    "revolt",
    "revolver",
    "revolving",
    "reward",
    "rewash",
    "rewind",
    "rewire",
    "reword",
    "rework",
    "rewrap",
    "rewrite",
    "rhyme",
    "ribbon",
    "ribcage",
    "rice",
    "riches",
    "richly",
    "richness",
    "rickety",
    "ricotta",
    "riddance",
    "ridden",
    "ride",
    "riding",
    "rifling",
    "rift",
    "rigging",
    "rigid",
    "rigor",
    "rimless",
    "rimmed",
    "rind",
    "rink",
    "rinse",
    "rinsing",
    "riot",
    "ripcord",
    "ripeness",
    "ripening",
    "ripping",
    "ripple",
    "rippling",
    "riptide",
    "rise",
    "rising",
    "risk",
    "risotto",
    "ritalin",
    "ritzy",
    "rival",
    "riverbank",
    "riverbed",
    "riverboat",
    "riverside",
    "riveter",
    "riveting",
    "roamer",
    "roaming",
    "roast",
    "robbing",
    "robe",
    "robin",
    "robotics",
    "robust",
    "rockband",
    "rocker",
    "rocket",
    "rockfish",
    "rockiness",
    "rocking",
    "rocklike",
    "rockslide",
    "rockstar",
    "rocky",
    "rogue",
    "roman",
    "romp",
    "rope",
    "roping",
    "roster",
    "rosy",
    "rotten",
    "rotting",
    "rotunda",
    "roulette",
    "rounding",
    "roundish",
    "roundness",
    "roundup",
    "roundworm",
    "routine",
    "routing",
    "rover",
    "roving",
    "royal",
    "rubbed",
    "rubber",
    "rubbing",
    "rubble",
    "rubdown",
    "ruby",
    "ruckus",
    "rudder",
    "rug",
    "ruined",
    "rule",
    "rumble",
    "rumbling",
    "rummage",
    "rumor",
    "runaround",
    "rundown",
    "runner",
    "running",
    "runny",
    "runt",
    "runway",
    "rupture",
    "rural",
    "ruse",
    "rush",
    "rust",
    "rut",
    "sabbath",
    "sabotage",
    "sacrament",
    "sacred",
    "sacrifice",
    "sadden",
    "saddlebag",
    "saddled",
    "saddling",
    "sadly",
    "sadness",
    "safari",
    "safeguard",
    "safehouse",
    "safely",
    "safeness",
    "saffron",
    "saga",
    "sage",
    "sagging",
    "saggy",
    "said",
    "saint",
    "sake",
    "salad",
    "salami",
    "salaried",
    "salary",
    "saline",
    "salon",
    "saloon",
    "salsa",
    "salt",
    "salutary",
    "salute",
    "salvage",
    "salvaging",
    "salvation",
    "same",
    "sample",
    "sampling",
    "sanction",
    "sanctity",
    "sanctuary",
    "sandal",
    "sandbag",
    "sandbank",
    "sandbar",
    "sandblast",
    "sandbox",
    "sanded",
    "sandfish",
    "sanding",
    "sandlot",
    "sandpaper",
    "sandpit",
    "sandstone",
    "sandstorm",
    "sandworm",
    "sandy",
    "sanitary",
    "sanitizer",
    "sank",
    "santa",
    "sapling",
    "sappiness",
    "sappy",
    "sarcasm",
    "sarcastic",
    "sardine",
    "sash",
    "sasquatch",
    "sassy",
    "satchel",
    "satiable",
    "satin",
    "satirical",
    "satisfied",
    "satisfy",
    "saturate",
    "saturday",
    "sauciness",
    "saucy",
    "sauna",
    "savage",
    "savanna",
    "saved",
    "savings",
    "savior",
    "savor",
    "saxophone",
    "say",
    "scabbed",
    "scabby",
    "scalded",
    "scalding",
    "scale",
    "scaling",
    "scallion",
    "scallop",
    "scalping",
    "scam",
    "scandal",
    "scanner",
    "scanning",
    "scant",
    "scapegoat",
    "scarce",
    "scarcity",
    "scarecrow",
    "scared",
    "scarf",
    "scarily",
    "scariness",
    "scarring",
    "scary",
    "scavenger",
    "scenic",
    "schedule",
    "schematic",
    "scheme",
    "scheming",
    "schilling",
    "schnapps",
    "scholar",
    "science",
    "scientist",
    "scion",
    "scoff",
    "scolding",
    "scone",
    "scoop",
    "scooter",
    "scope",
    "scorch",
    "scorebook",
    "scorecard",
    "scored",
    "scoreless",
    "scorer",
    "scoring",
    "scorn",
    "scorpion",
    "scotch",
    "scoundrel",
    "scoured",
    "scouring",
    "scouting",
    "scouts",
    "scowling",
    "scrabble",
    "scraggly",
    "scrambled",
    "scrambler",
    "scrap",
    "scratch",
    "scrawny",
    "screen",
    "scribble",
    "scribe",
    "scribing",
    "scrimmage",
    "script",
    "scroll",
    "scrooge",
    "scrounger",
    "scrubbed",
    "scrubber",
    "scruffy",
    "scrunch",
    "scrutiny",
    "scuba",
    "scuff",
    "sculptor",
    "sculpture",
    "scurvy",
    "scuttle",
    "secluded",
    "secluding",
    "seclusion",
    "second",
    "secrecy",
    "secret",
    "sectional",
    "sector",
    "secular",
    "securely",
    "security",
    "sedan",
    "sedate",
    "sedation",
    "sedative",
    "sediment",
    "seduce",
    "seducing",
    "segment",
    "seismic",
    "seizing",
    "seldom",
    "selected",
    "selection",
    "selective",
    "selector",
    "self",
    "seltzer",
    "semantic",
    "semester",
    "semicolon",
    "semifinal",
    "seminar",
    "semisoft",
    "semisweet",
    "senate",
    "senator",
    "send",
    "senior",
    "senorita",
    "sensation",
    "sensitive",
    "sensitize",
    "sensually",
    "sensuous",
    "sepia",
    "september",
    "septic",
    "septum",
    "sequel",
    "sequence",
    "sequester",
    "series",
    "sermon",
    "serotonin",
    "serpent",
    "serrated",
    "serve",
    "service",
    "serving",
    "sesame",
    "sessions",
    "setback",
    "setting",
    "settle",
    "settling",
    "setup",
    "sevenfold",
    "seventeen",
    "seventh",
    "seventy",
    "severity",
    "shabby",
    "shack",
    "shaded",
    "shadily",
    "shadiness",
    "shading",
    "shadow",
    "shady",
    "shaft",
    "shakable",
    "shakily",
    "shakiness",
    "shaking",
    "shaky",
    "shale",
    "shallot",
    "shallow",
    "shame",
    "shampoo",
    "shamrock",
    "shank",
    "shanty",
    "shape",
    "shaping",
    "share",
    "sharpener",
    "sharper",
    "sharpie",
    "sharply",
    "sharpness",
    "shawl",
    "sheath",
    "shed",
    "sheep",
    "sheet",
    "shelf",
    "shell",
    "shelter",
    "shelve",
    "shelving",
    "sherry",
    "shield",
    "shifter",
    "shifting",
    "shiftless",
    "shifty",
    "shimmer",
    "shimmy",
    "shindig",
    "shine",
    "shingle",
    "shininess",
    "shining",
    "shiny",
    "ship",
    "shirt",
    "shivering",
    "shock",
    "shone",
    "shoplift",
    "shopper",
    "shopping",
    "shoptalk",
    "shore",
    "shortage",
    "shortcake",
    "shortcut",
    "shorten",
    "shorter",
    "shorthand",
    "shortlist",
    "shortly",
    "shortness",
    "shorts",
    "shortwave",
    "shorty",
    "shout",
    "shove",
    "showbiz",
    "showcase",
    "showdown",
    "shower",
    "showgirl",
    "showing",
    "showman",
    "shown",
    "showoff",
    "showpiece",
    "showplace",
    "showroom",
    "showy",
    "shrank",
    "shrapnel",
    "shredder",
    "shredding",
    "shrewdly",
    "shriek",
    "shrill",
    "shrimp",
    "shrine",
    "shrink",
    "shrivel",
    "shrouded",
    "shrubbery",
    "shrubs",
    "shrug",
    "shrunk",
    "shucking",
    "shudder",
    "shuffle",
    "shuffling",
    "shun",
    "shush",
    "shut",
    "shy",
    "siamese",
    "siberian",
    "sibling",
    "siding",
    "sierra",
    "siesta",
    "sift",
    "sighing",
    "silenced",
    "silencer",
    "silent",
    "silica",
    "silicon",
    "silk",
    "silliness",
    "silly",
    "silo",
    "silt",
    "silver",
    "similarly",
    "simile",
    "simmering",
    "simple",
    "simplify",
    "simply",
    "sincere",
    "sincerity",
    "singer",
    "singing",
    "single",
    "singular",
    "sinister",
    "sinless",
    "sinner",
    "sinuous",
    "sip",
    "siren",
    "sister",
    "sitcom",
    "sitter",
    "sitting",
    "situated",
    "situation",
    "sixfold",
    "sixteen",
    "sixth",
    "sixties",
    "sixtieth",
    "sixtyfold",
    "sizable",
    "sizably",
    "size",
    "sizing",
    "sizzle",
    "sizzling",
    "skater",
    "skating",
    "skedaddle",
    "skeletal",
    "skeleton",
    "skeptic",
    "sketch",
    "skewed",
    "skewer",
    "skid",
    "skied",
    "skier",
    "skies",
    "skiing",
    "skilled",
    "skillet",
    "skillful",
    "skimmed",
    "skimmer",
    "skimming",
    "skimpily",
    "skincare",
    "skinhead",
    "skinless",
    "skinning",
    "skinny",
    "skintight",
    "skipper",
    "skipping",
    "skirmish",
    "skirt",
    "skittle",
    "skydiver",
    "skylight",
    "skyline",
    "skype",
    "skyrocket",
    "skyward",
    "slab",
    "slacked",
    "slacker",
    "slacking",
    "slackness",
    "slacks",
    "slain",
    "slam",
    "slander",
    "slang",
    "slapping",
    "slapstick",
    "slashed",
    "slashing",
    "slate",
    "slather",
    "slaw",
    "sled",
    "sleek",
    "sleep",
    "sleet",
    "sleeve",
    "slept",
    "sliceable",
    "sliced",
    "slicer",
    "slicing",
    "slick",
    "slider",
    "slideshow",
    "sliding",
    "slighted",
    "slighting",
    "slightly",
    "slimness",
    "slimy",
    "slinging",
    "slingshot",
    "slinky",
    "slip",
    "slit",
    "sliver",
    "slobbery",
    "slogan",
    "sloped",
    "sloping",
    "sloppily",
    "sloppy",
    "slot",
    "slouching",
    "slouchy",
    "sludge",
    "slug",
    "slum",
    "slurp",
    "slush",
    "sly",
    "small",
    "smartly",
    "smartness",
    "smasher",
    "smashing",
    "smashup",
    "smell",
    "smelting",
    "smile",
    "smilingly",
    "smirk",
    "smite",
    "smith",
    "smitten",
    "smock",
    "smog",
    "smoked",
    "smokeless",
    "smokiness",
    "smoking",
    "smoky",
    "smolder",
    "smooth",
    "smother",
    "smudge",
    "smudgy",
    "smuggler",
    "smuggling",
    "smugly",
    "smugness",
    "snack",
    "snagged",
    "snaking",
    "snap",
    "snare",
    "snarl",
    "snazzy",
    "sneak",
    "sneer",
    "sneeze",
    "sneezing",
    "snide",
    "sniff",
    "snippet",
    "snipping",
    "snitch",
    "snooper",
    "snooze",
    "snore",
    "snoring",
    "snorkel",
    "snort",
    "snout",
    "snowbird",
    "snowboard",
    "snowbound",
    "snowcap",
    "snowdrift",
    "snowdrop",
    "snowfall",
    "snowfield",
    "snowflake",
    "snowiness",
    "snowless",
    "snowman",
    "snowplow",
    "snowshoe",
    "snowstorm",
    "snowsuit",
    "snowy",
    "snub",
    "snuff",
    "snuggle",
    "snugly",
    "snugness",
    "speak",
    "spearfish",
    "spearhead",
    "spearman",
    "spearmint",
    "species",
    "specimen",
    "specked",
    "speckled",
    "specks",
    "spectacle",
    "spectator",
    "spectrum",
    "speculate",
    "speech",
    "speed",
    "spellbind",
    "speller",
    "spelling",
    "spendable",
    "spender",
    "spending",
    "spent",
    "spew",
    "sphere",
    "spherical",
    "sphinx",
    "spider",
    "spied",
    "spiffy",
    "spill",
    "spilt",
    "spinach",
    "spinal",
    "spindle",
    "spinner",
    "spinning",
    "spinout",
    "spinster",
    "spiny",
    "spiral",
    "spirited",
    "spiritism",
    "spirits",
    "spiritual",
    "splashed",
    "splashing",
    "splashy",
    "splatter",
    "spleen",
    "splendid",
    "splendor",
    "splice",
    "splicing",
    "splinter",
    "splotchy",
    "splurge",
    "spoilage",
    "spoiled",
    "spoiler",
    "spoiling",
    "spoils",
    "spoken",
    "spokesman",
    "sponge",
    "spongy",
    "sponsor",
    "spoof",
    "spookily",
    "spooky",
    "spool",
    "spoon",
    "spore",
    "sporting",
    "sports",
    "sporty",
    "spotless",
    "spotlight",
    "spotted",
    "spotter",
    "spotting",
    "spotty",
    "spousal",
    "spouse",
    "spout",
    "sprain",
    "sprang",
    "sprawl",
    "spray",
    "spree",
    "sprig",
    "spring",
    "sprinkled",
    "sprinkler",
    "sprint",
    "sprite",
    "sprout",
    "spruce",
    "sprung",
    "spry",
    "spud",
    "spur",
    "sputter",
    "spyglass",
    "squabble",
    "squad",
    "squall",
    "squander",
    "squash",
    "squatted",
    "squatter",
    "squatting",
    "squeak",
    "squealer",
    "squealing",
    "squeamish",
    "squeegee",
    "squeeze",
    "squeezing",
    "squid",
    "squiggle",
    "squiggly",
    "squint",
    "squire",
    "squirt",
    "squishier",
    "squishy",
    "stability",
    "stabilize",
    "stable",
    "stack",
    "stadium",
    "staff",
    "stage",
    "staging",
    "stagnant",
    "stagnate",
    "stainable",
    "stained",
    "staining",
    "stainless",
    "stalemate",
    "staleness",
    "stalling",
    "stallion",
    "stamina",
    "stammer",
    "stamp",
    "stand",
    "stank",
    "staple",
    "stapling",
    "starboard",
    "starch",
    "stardom",
    "stardust",
    "starfish",
    "stargazer",
    "staring",
    "stark",
    "starless",
    "starlet",
    "starlight",
    "starlit",
    "starring",
    "starry",
    "starship",
    "starter",
    "starting",
    "startle",
    "startling",
    "startup",
    "starved",
    "starving",
    "stash",
    "state",
    "static",
    "statistic",
    "statue",
    "stature",
    "status",
    "statute",
    "statutory",
    "staunch",
    "stays",
    "steadfast",
    "steadier",
    "steadily",
    "steadying",
    "steam",
    "steed",
    "steep",
    "steerable",
    "steering",
    "steersman",
    "stegosaur",
    "stellar",
    "stem",
    "stench",
    "stencil",
    "step",
    "stereo",
    "sterile",
    "sterility",
    "sterilize",
    "sterling",
    "sternness",
    "sternum",
    "stew",
    "stick",
    "stiffen",
    "stiffly",
    "stiffness",
    "stifle",
    "stifling",
    "stillness",
    "stilt",
    "stimulant",
    "stimulate",
    "stimuli",
    "stimulus",
    "stinger",
    "stingily",
    "stinging",
    "stingray",
    "stingy",
    "stinking",
    "stinky",
    "stipend",
    "stipulate",
    "stir",
    "stitch",
    "stock",
    "stoic",
    "stoke",
    "stole",
    "stomp",
    "stonewall",
    "stoneware",
    "stonework",
    "stoning",
    "stony",
    "stood",
    "stooge",
    "stool",
    "stoop",
    "stoplight",
    "stoppable",
    "stoppage",
    "stopped",
    "stopper",
    "stopping",
    "stopwatch",
    "storable",
    "storage",
    "storeroom",
    "storewide",
    "storm",
    "stout",
    "stove",
    "stowaway",
    "stowing",
    "straddle",
    "straggler",
    "strained",
    "strainer",
    "straining",
    "strangely",
    "stranger",
    "strangle",
    "strategic",
    "strategy",
    "stratus",
    "straw",
    "stray",
    "streak",
    "stream",
    "street",
    "strength",
    "strenuous",
    "strep",
    "stress",
    "stretch",
    "strewn",
    "stricken",
    "strict",
    "stride",
    "strife",
    "strike",
    "striking",
    "strive",
    "striving",
    "strobe",
    "strode",
    "stroller",
    "strongbox",
    "strongly",
    "strongman",
    "struck",
    "structure",
    "strudel",
    "struggle",
    "strum",
    "strung",
    "strut",
    "stubbed",
    "stubble",
    "stubbly",
    "stubborn",
    "stucco",
    "stuck",
    "student",
    "studied",
    "studio",
    "study",
    "stuffed",
    "stuffing",
    "stuffy",
    "stumble",
    "stumbling",
    "stump",
    "stung",
    "stunned",
    "stunner",
    "stunning",
    "stunt",
    "stupor",
    "sturdily",
    "sturdy",
    "styling",
    "stylishly",
    "stylist",
    "stylized",
    "stylus",
    "suave",
    "subarctic",
    "subatomic",
    "subdivide",
    "subdued",
    "subduing",
    "subfloor",
    "subgroup",
    "subheader",
    "subject",
    "sublease",
    "sublet",
    "sublevel",
    "sublime",
    "submarine",
    "submerge",
    "submersed",
    "submitter",
    "subpanel",
    "subpar",
    "subplot",
    "subprime",
    "subscribe",
    "subscript",
    "subsector",
    "subside",
    "subsiding",
    "subsidize",
    "subsidy",
    "subsoil",
    "subsonic",
    "substance",
    "subsystem",
    "subtext",
    "subtitle",
    "subtly",
    "subtotal",
    "subtract",
    "subtype",
    "suburb",
    "subway",
    "subwoofer",
    "subzero",
    "succulent",
    "such",
    "suction",
    "sudden",
    "sudoku",
    "suds",
    "sufferer",
    "suffering",
    "suffice",
    "suffix",
    "suffocate",
    "suffrage",
    "sugar",
    "suggest",
    "suing",
    "suitable",
    "suitably",
    "suitcase",
    "suitor",
    "sulfate",
    "sulfide",
    "sulfite",
    "sulfur",
    "sulk",
    "sullen",
    "sulphate",
    "sulphuric",
    "sultry",
    "superbowl",
    "superglue",
    "superhero",
    "superior",
    "superjet",
    "superman",
    "supermom",
    "supernova",
    "supervise",
    "supper",
    "supplier",
    "supply",
    "support",
    "supremacy",
    "supreme",
    "surcharge",
    "surely",
    "sureness",
    "surface",
    "surfacing",
    "surfboard",
    "surfer",
    "surgery",
    "surgical",
    "surging",
    "surname",
    "surpass",
    "surplus",
    "surprise",
    "surreal",
    "surrender",
    "surrogate",
    "surround",
    "survey",
    "survival",
    "survive",
    "surviving",
    "survivor",
    "sushi",
    "suspect",
    "suspend",
    "suspense",
    "sustained",
    "sustainer",
    "swab",
    "swaddling",
    "swagger",
    "swampland",
    "swan",
    "swapping",
    "swarm",
    "sway",
    "swear",
    "sweat",
    "sweep",
    "swell",
    "swept",
    "swerve",
    "swifter",
    "swiftly",
    "swiftness",
    "swimmable",
    "swimmer",
    "swimming",
    "swimsuit",
    "swimwear",
    "swinger",
    "swinging",
    "swipe",
    "swirl",
    "switch",
    "swivel",
    "swizzle",
    "swooned",
    "swoop",
    "swoosh",
    "swore",
    "sworn",
    "swung",
    "sycamore",
    "sympathy",
    "symphonic",
    "symphony",
    "symptom",
    "synapse",
    "syndrome",
    "synergy",
    "synopses",
    "synopsis",
    "synthesis",
    "synthetic",
    "syrup",
    "system",
    "t-shirt",
    "tabasco",
    "tabby",
    "tableful",
    "tables",
    "tablet",
    "tableware",
    "tabloid",
    "tackiness",
    "tacking",
    "tackle",
    "tackling",
    "tacky",
    "taco",
    "tactful",
    "tactical",
    "tactics",
    "tactile",
    "tactless",
    "tadpole",
    "taekwondo",
    "tag",
    "tainted",
    "take",
    "taking",
    "talcum",
    "talisman",
    "tall",
    "talon",
    "tamale",
    "tameness",
    "tamer",
    "tamper",
    "tank",
    "tanned",
    "tannery",
    "tanning",
    "tantrum",
    "tapeless",
    "tapered",
    "tapering",
    "tapestry",
    "tapioca",
    "tapping",
    "taps",
    "tarantula",
    "target",
    "tarmac",
    "tarnish",
    "tarot",
    "tartar",
    "tartly",
    "tartness",
    "task",
    "tassel",
    "taste",
    "tastiness",
    "tasting",
    "tasty",
    "tattered",
    "tattle",
    "tattling",
    "tattoo",
    "taunt",
    "tavern",
    "thank",
    "that",
    "thaw",
    "theater",
    "theatrics",
    "thee",
    "theft",
    "theme",
    "theology",
    "theorize",
    "thermal",
    "thermos",
    "thesaurus",
    "these",
    "thesis",
    "thespian",
    "thicken",
    "thicket",
    "thickness",
    "thieving",
    "thievish",
    "thigh",
    "thimble",
    "thing",
    "think",
    "thinly",
    "thinner",
    "thinness",
    "thinning",
    "thirstily",
    "thirsting",
    "thirsty",
    "thirteen",
    "thirty",
    "thong",
    "thorn",
    "those",
    "thousand",
    "thrash",
    "thread",
    "threaten",
    "threefold",
    "thrift",
    "thrill",
    "thrive",
    "thriving",
    "throat",
    "throbbing",
    "throng",
    "throttle",
    "throwaway",
    "throwback",
    "thrower",
    "throwing",
    "thud",
    "thumb",
    "thumping",
    "thursday",
    "thus",
    "thwarting",
    "thyself",
    "tiara",
    "tibia",
    "tidal",
    "tidbit",
    "tidiness",
    "tidings",
    "tidy",
    "tiger",
    "tighten",
    "tightly",
    "tightness",
    "tightrope",
    "tightwad",
    "tigress",
    "tile",
    "tiling",
    "till",
    "tilt",
    "timid",
    "timing",
    "timothy",
    "tinderbox",
    "tinfoil",
    "tingle",
    "tingling",
    "tingly",
    "tinker",
    "tinkling",
    "tinsel",
    "tinsmith",
    "tint",
    "tinwork",
    "tiny",
    "tipoff",
    "tipped",
    "tipper",
    "tipping",
    "tiptoeing",
    "tiptop",
    "tiring",
    "tissue",
    "trace",
    "tracing",
    "track",
    "traction",
    "tractor",
    "trade",
    "trading",
    "tradition",
    "traffic",
    "tragedy",
    "trailing",
    "trailside",
    "train",
    "traitor",
    "trance",
    "tranquil",
    "transfer",
    "transform",
    "translate",
    "transpire",
    "transport",
    "transpose",
    "trapdoor",
    "trapeze",
    "trapezoid",
    "trapped",
    "trapper",
    "trapping",
    "traps",
    "trash",
    "travel",
    "traverse",
    "travesty",
    "tray",
    "treachery",
    "treading",
    "treadmill",
    "treason",
    "treat",
    "treble",
    "tree",
    "trekker",
    "tremble",
    "trembling",
    "tremor",
    "trench",
    "trend",
    "trespass",
    "triage",
    "trial",
    "triangle",
    "tribesman",
    "tribunal",
    "tribune",
    "tributary",
    "tribute",
    "triceps",
    "trickery",
    "trickily",
    "tricking",
    "trickle",
    "trickster",
    "tricky",
    "tricolor",
    "tricycle",
    "trident",
    "tried",
    "trifle",
    "trifocals",
    "trillion",
    "trilogy",
    "trimester",
    "trimmer",
    "trimming",
    "trimness",
    "trinity",
    "trio",
    "tripod",
    "tripping",
    "triumph",
    "trivial",
    "trodden",
    "trolling",
    "trombone",
    "trophy",
    "tropical",
    "tropics",
    "trouble",
    "troubling",
    "trough",
    "trousers",
    "trout",
    "trowel",
    "truce",
    "truck",
    "truffle",
    "trump",
    "trunks",
    "trustable",
    "trustee",
    "trustful",
    "trusting",
    "trustless",
    "truth",
    "try",
    "tubby",
    "tubeless",
    "tubular",
    "tucking",
    "tuesday",
    "tug",
    "tuition",
    "tulip",
    "tumble",
    "tumbling",
    "tummy",
    "turban",
    "turbine",
    "turbofan",
    "turbojet",
    "turbulent",
    "turf",
    "turkey",
    "turmoil",
    "turret",
    "turtle",
    "tusk",
    "tutor",
    "tutu",
    "tux",
    "tweak",
    "tweed",
    "tweet",
    "tweezers",
    "twelve",
    "twentieth",
    "twenty",
    "twerp",
    "twice",
    "twiddle",
    "twiddling",
    "twig",
    "twilight",
    "twine",
    "twins",
    "twirl",
    "twistable",
    "twisted",
    "twister",
    "twisting",
    "twisty",
    "twitch",
    "twitter",
    "tycoon",
    "tying",
    "tyke",
    "udder",
    "ultimate",
    "ultimatum",
    "ultra",
    "umbilical",
    "umbrella",
    "umpire",
    "unabashed",
    "unable",
    "unadorned",
    "unadvised",
    "unafraid",
    "unaired",
    "unaligned",
    "unaltered",
    "unarmored",
    "unashamed",
    "unaudited",
    "unawake",
    "unaware",
    "unbaked",
    "unbalance",
    "unbeaten",
    "unbend",
    "unbent",
    "unbiased",
    "unbitten",
    "unblended",
    "unblessed",
    "unblock",
    "unbolted",
    "unbounded",
    "unboxed",
    "unbraided",
    "unbridle",
    "unbroken",
    "unbuckled",
    "unbundle",
    "unburned",
    "unbutton",
    "uncanny",
    "uncapped",
    "uncaring",
    "uncertain",
    "unchain",
    "unchanged",
    "uncharted",
    "uncheck",
    "uncivil",
    "unclad",
    "unclaimed",
    "unclamped",
    "unclasp",
    "uncle",
    "unclip",
    "uncloak",
    "unclog",
    "unclothed",
    "uncoated",
    "uncoiled",
    "uncolored",
    "uncombed",
    "uncommon",
    "uncooked",
    "uncork",
    "uncorrupt",
    "uncounted",
    "uncouple",
    "uncouth",
    "uncover",
    "uncross",
    "uncrown",
    "uncrushed",
    "uncured",
    "uncurious",
    "uncurled",
    "uncut",
    "undamaged",
    "undated",
    "undaunted",
    "undead",
    "undecided",
    "undefined",
    "underage",
    "underarm",
    "undercoat",
    "undercook",
    "undercut",
    "underdog",
    "underdone",
    "underfed",
    "underfeed",
    "underfoot",
    "undergo",
    "undergrad",
    "underhand",
    "underline",
    "underling",
    "undermine",
    "undermost",
    "underpaid",
    "underpass",
    "underpay",
    "underrate",
    "undertake",
    "undertone",
    "undertook",
    "undertow",
    "underuse",
    "underwear",
    "underwent",
    "underwire",
    "undesired",
    "undiluted",
    "undivided",
    "undocked",
    "undoing",
    "undone",
    "undrafted",
    "undress",
    "undrilled",
    "undusted",
    "undying",
    "unearned",
    "unearth",
    "unease",
    "uneasily",
    "uneasy",
    "uneatable",
    "uneaten",
    "unedited",
    "unelected",
    "unending",
    "unengaged",
    "unenvied",
    "unequal",
    "unethical",
    "uneven",
    "unexpired",
    "unexposed",
    "unfailing",
    "unfair",
    "unfasten",
    "unfazed",
    "unfeeling",
    "unfiled",
    "unfilled",
    "unfitted",
    "unfitting",
    "unfixable",
    "unfixed",
    "unflawed",
    "unfocused",
    "unfold",
    "unfounded",
    "unframed",
    "unfreeze",
    "unfrosted",
    "unfrozen",
    "unfunded",
    "unglazed",
    "ungloved",
    "unglue",
    "ungodly",
    "ungraded",
    "ungreased",
    "unguarded",
    "unguided",
    "unhappily",
    "unhappy",
    "unharmed",
    "unhealthy",
    "unheard",
    "unhearing",
    "unheated",
    "unhelpful",
    "unhidden",
    "unhinge",
    "unhitched",
    "unholy",
    "unhook",
    "unicorn",
    "unicycle",
    "unified",
    "unifier",
    "uniformed",
    "uniformly",
    "unify",
    "unimpeded",
    "uninjured",
    "uninstall",
    "uninsured",
    "uninvited",
    "union",
    "uniquely",
    "unisexual",
    "unison",
    "unissued",
    "unit",
    "universal",
    "universe",
    "unjustly",
    "unkempt",
    "unkind",
    "unknotted",
    "unknowing",
    "unknown",
    "unlaced",
    "unlatch",
    "unlawful",
    "unleaded",
    "unlearned",
    "unleash",
    "unless",
    "unleveled",
    "unlighted",
    "unlikable",
    "unlimited",
    "unlined",
    "unlinked",
    "unlisted",
    "unlit",
    "unlivable",
    "unloaded",
    "unloader",
    "unlocked",
    "unlocking",
    "unlovable",
    "unloved",
    "unlovely",
    "unloving",
    "unluckily",
    "unlucky",
    "unmade",
    "unmanaged",
    "unmanned",
    "unmapped",
    "unmarked",
    "unmasked",
    "unmasking",
    "unmatched",
    "unmindful",
    "unmixable",
    "unmixed",
    "unmolded",
    "unmoral",
    "unmovable",
    "unmoved",
    "unmoving",
    "unnamable",
    "unnamed",
    "unnatural",
    "unneeded",
    "unnerve",
    "unnerving",
    "unnoticed",
    "unopened",
    "unopposed",
    "unpack",
    "unpadded",
    "unpaid",
    "unpainted",
    "unpaired",
    "unpaved",
    "unpeeled",
    "unpicked",
    "unpiloted",
    "unpinned",
    "unplanned",
    "unplanted",
    "unpleased",
    "unpledged",
    "unplowed",
    "unplug",
    "unpopular",
    "unproven",
    "unquote",
    "unranked",
    "unrated",
    "unraveled",
    "unreached",
    "unread",
    "unreal",
    "unreeling",
    "unrefined",
    "unrelated",
    "unrented",
    "unrest",
    "unretired",
    "unrevised",
    "unrigged",
    "unripe",
    "unrivaled",
    "unroasted",
    "unrobed",
    "unroll",
    "unruffled",
    "unruly",
    "unrushed",
    "unsaddle",
    "unsafe",
    "unsaid",
    "unsalted",
    "unsaved",
    "unsavory",
    "unscathed",
    "unscented",
    "unscrew",
    "unsealed",
    "unseated",
    "unsecured",
    "unseeing",
    "unseemly",
    "unseen",
    "unselect",
    "unselfish",
    "unsent",
    "unsettled",
    "unshackle",
    "unshaken",
    "unshaved",
    "unshaven",
    "unsheathe",
    "unshipped",
    "unsightly",
    "unsigned",
    "unskilled",
    "unsliced",
    "unsmooth",
    "unsnap",
    "unsocial",
    "unsoiled",
    "unsold",
    "unsolved",
    "unsorted",
    "unspoiled",
    "unspoken",
    "unstable",
    "unstaffed",
    "unstamped",
    "unsteady",
    "unsterile",
    "unstirred",
    "unstitch",
    "unstopped",
    "unstuck",
    "unstuffed",
    "unstylish",
    "unsubtle",
    "unsubtly",
    "unsuited",
    "unsure",
    "unsworn",
    "untagged",
    "untainted",
    "untaken",
    "untamed",
    "untangled",
    "untapped",
    "untaxed",
    "unthawed",
    "unthread",
    "untidy",
    "untie",
    "until",
    "untimed",
    "untimely",
    "untitled",
    "untoasted",
    "untold",
    "untouched",
    "untracked",
    "untrained",
    "untreated",
    "untried",
    "untrimmed",
    "untrue",
    "untruth",
    "unturned",
    "untwist",
    "untying",
    "unusable",
    "unused",
    "unusual",
    "unvalued",
    "unvaried",
    "unvarying",
    "unveiled",
    "unveiling",
    "unvented",
    "unviable",
    "unvisited",
    "unvocal",
    "unwanted",
    "unwarlike",
    "unwary",
    "unwashed",
    "unwatched",
    "unweave",
    "unwed",
    "unwelcome",
    "unwell",
    "unwieldy",
    "unwilling",
    "unwind",
    "unwired",
    "unwitting",
    "unwomanly",
    "unworldly",
    "unworn",
    "unworried",
    "unworthy",
    "unwound",
    "unwoven",
    "unwrapped",
    "unwritten",
    "unzip",
    "upbeat",
    "upchuck",
    "upcoming",
    "upcountry",
    "update",
    "upfront",
    "upgrade",
    "upheaval",
    "upheld",
    "uphill",
    "uphold",
    "uplifted",
    "uplifting",
    "upload",
    "upon",
    "upper",
    "upright",
    "uprising",
    "upriver",
    "uproar",
    "uproot",
    "upscale",
    "upside",
    "upstage",
    "upstairs",
    "upstart",
    "upstate",
    "upstream",
    "upstroke",
    "upswing",
    "uptake",
    "uptight",
    "uptown",
    "upturned",
    "upward",
    "upwind",
    "uranium",
    "urban",
    "urchin",
    "urethane",
    "urgency",
    "urgent",
    "urging",
    "urologist",
    "urology",
    "usable",
    "usage",
    "useable",
    "used",
    "uselessly",
    "user",
    "usher",
    "usual",
    "utensil",
    "utility",
    "utilize",
    "utmost",
    "utopia",
    "utter",
    "vacancy",
    "vacant",
    "vacate",
    "vacation",
    "vagabond",
    "vagrancy",
    "vagrantly",
    "vaguely",
    "vagueness",
    "valiant",
    "valid",
    "valium",
    "valley",
    "valuables",
    "value",
    "vanilla",
    "vanish",
    "vanity",
    "vanquish",
    "vantage",
    "vaporizer",
    "variable",
    "variably",
    "varied",
    "variety",
    "various",
    "varmint",
    "varnish",
    "varsity",
    "varying",
    "vascular",
    "vaseline",
    "vastly",
    "vastness",
    "veal",
    "vegan",
    "veggie",
    "vehicular",
    "velcro",
    "velocity",
    "velvet",
    "vendetta",
    "vending",
    "vendor",
    "veneering",
    "vengeful",
    "venomous",
    "ventricle",
    "venture",
    "venue",
    "venus",
    "verbalize",
    "verbally",
    "verbose",
    "verdict",
    "verify",
    "verse",
    "version",
    "versus",
    "vertebrae",
    "vertical",
    "vertigo",
    "very",
    "vessel",
    "vest",
    "veteran",
    "veto",
    "vexingly",
    "viability",
    "viable",
    "vibes",
    "vice",
    "vicinity",
    "victory",
    "video",
    "viewable",
    "viewer",
    "viewing",
    "viewless",
    "viewpoint",
    "vigorous",
    "village",
    "villain",
    "vindicate",
    "vineyard",
    "vintage",
    "violate",
    "violation",
    "violator",
    "violet",
    "violin",
    "viper",
    "viral",
    "virtual",
    "virtuous",
    "virus",
    "visa",
    "viscosity",
    "viscous",
    "viselike",
    "visible",
    "visibly",
    "vision",
    "visiting",
    "visitor",
    "visor",
    "vista",
    "vitality",
    "vitalize",
    "vitally",
    "vitamins",
    "vivacious",
    "vividly",
    "vividness",
    "vixen",
    "vocalist",
    "vocalize",
    "vocally",
    "vocation",
    "voice",
    "voicing",
    "void",
    "volatile",
    "volley",
    "voltage",
    "volumes",
    "voter",
    "voting",
    "voucher",
    "vowed",
    "vowel",
    "voyage",
    "wackiness",
    "wad",
    "wafer",
    "waffle",
    "waged",
    "wager",
    "wages",
    "waggle",
    "wagon",
    "wake",
    "waking",
    "walk",
    "walmart",
    "walnut",
    "walrus",
    "waltz",
    "wand",
    "wannabe",
    "wanted",
    "wanting",
    "wasabi",
    "washable",
    "washbasin",
    "washboard",
    "washbowl",
    "washcloth",
    "washday",
    "washed",
    "washer",
    "washhouse",
    "washing",
    "washout",
    "washroom",
    "washstand",
    "washtub",
    "wasp",
    "wasting",
    "watch",
    "water",
    "waviness",
    "waving",
    "wavy",
    "whacking",
    "whacky",
    "wham",
    "wharf",
    "wheat",
    "whenever",
    "whiff",
    "whimsical",
    "whinny",
    "whiny",
    "whisking",
    "whoever",
    "whole",
    "whomever",
    "whoopee",
    "whooping",
    "whoops",
    "why",
    "wick",
    "widely",
    "widen",
    "widget",
    "widow",
    "width",
    "wieldable",
    "wielder",
    "wife",
    "wifi",
    "wikipedia",
    "wildcard",
    "wildcat",
    "wilder",
    "wildfire",
    "wildfowl",
    "wildland",
    "wildlife",
    "wildly",
    "wildness",
    "willed",
    "willfully",
    "willing",
    "willow",
    "willpower",
    "wilt",
    "wimp",
    "wince",
    "wincing",
    "wind",
    "wing",
    "winking",
    "winner",
    "winnings",
    "winter",
    "wipe",
    "wired",
    "wireless",
    "wiring",
    "wiry",
    "wisdom",
    "wise",
    "wish",
    "wisplike",
    "wispy",
    "wistful",
    "wizard",
    "wobble",
    "wobbling",
    "wobbly",
    "wok",
    "wolf",
    "wolverine",
    "womanhood",
    "womankind",
    "womanless",
    "womanlike",
    "womanly",
    "womb",
    "woof",
    "wooing",
    "wool",
    "woozy",
    "word",
    "work",
    "worried",
    "worrier",
    "worrisome",
    "worry",
    "worsening",
    "worshiper",
    "worst",
    "wound",
    "woven",
    "wow",
    "wrangle",
    "wrath",
    "wreath",
    "wreckage",
    "wrecker",
    "wrecking",
    "wrench",
    "wriggle",
    "wriggly",
    "wrinkle",
    "wrinkly",
    "wrist",
    "writing",
    "written",
    "wrongdoer",
    "wronged",
    "wrongful",
    "wrongly",
    "wrongness",
    "wrought",
    "xbox",
    "xerox",
    "yahoo",
    "yam",
    "yanking",
    "yapping",
    "yard",
    "yarn",
    "yeah",
    "yearbook",
    "yearling",
    "yearly",
    "yearning",
    "yeast",
    "yelling",
    "yelp",
    "yen",
    "yesterday",
    "yiddish",
    "yield",
    "yin",
    "yippee",
    "yo-yo",
    "yodel",
    "yoga",
    "yogurt",
    "yonder",
    "yoyo",
    "yummy",
    "zap",
    "zealous",
    "zebra",
    "zen",
    "zeppelin",
    "zero",
    "zestfully",
    "zesty",
    "zigzagged",
    "zipfile",
    "zipping",
    "zippy",
    "zips",
    "zit",
    "zodiac",
    "zombie",
    "zone",
    "zoning",
    "zookeeper",
    "zoologist",
    "zoology",
    "zoom"
  ];
  return wordlist$1;
}
var hasRequiredNewSecureWords;
function requireNewSecureWords() {
  if (hasRequiredNewSecureWords) return newSecureWords;
  hasRequiredNewSecureWords = 1;
  Object.defineProperty(newSecureWords, "__esModule", { value: true });
  newSecureWords.newSecureWords = void 0;
  const getSecureRandom_1 = requireGetSecureRandom();
  const wordlist_1 = requireWordlist$1();
  async function newSecureWords$1(size = 6) {
    let words = [];
    for (let i = 0; i < size; i++) {
      words.push(wordlist_1.wordlist[await (0, getSecureRandom_1.getSecureRandomNumber)(0, wordlist_1.wordlist.length)]);
    }
    return words;
  }
  newSecureWords.newSecureWords = newSecureWords$1;
  return newSecureWords;
}
var newSecurePassphrase = {};
var hasRequiredNewSecurePassphrase;
function requireNewSecurePassphrase() {
  if (hasRequiredNewSecurePassphrase) return newSecurePassphrase;
  hasRequiredNewSecurePassphrase = 1;
  Object.defineProperty(newSecurePassphrase, "__esModule", { value: true });
  newSecurePassphrase.newSecurePassphrase = void 0;
  const __1 = requireDist$5();
  async function newSecurePassphrase$1(size = 6) {
    return (await (0, __1.newSecureWords)(size)).join("-");
  }
  newSecurePassphrase.newSecurePassphrase = newSecurePassphrase$1;
  return newSecurePassphrase;
}
var mnemonic = {};
var binary = {};
var hasRequiredBinary;
function requireBinary() {
  if (hasRequiredBinary) return binary;
  hasRequiredBinary = 1;
  Object.defineProperty(binary, "__esModule", { value: true });
  binary.bitsToBytes = binary.bytesToBits = binary.lpad = void 0;
  function lpad(str, padString, length) {
    while (str.length < length) {
      str = padString + str;
    }
    return str;
  }
  binary.lpad = lpad;
  function bytesToBits(bytes) {
    let res = "";
    for (let i = 0; i < bytes.length; i++) {
      let x2 = bytes.at(i);
      res += lpad(x2.toString(2), "0", 8);
    }
    return res;
  }
  binary.bytesToBits = bytesToBits;
  function bitsToBytes(src2) {
    if (src2.length % 8 !== 0) {
      throw Error("Uneven bits");
    }
    let res = [];
    while (src2.length > 0) {
      res.push(parseInt(src2.slice(0, 8), 2));
      src2 = src2.slice(8);
    }
    return Buffer.from(res);
  }
  binary.bitsToBytes = bitsToBytes;
  return binary;
}
var wordlist = {};
var hasRequiredWordlist;
function requireWordlist() {
  if (hasRequiredWordlist) return wordlist;
  hasRequiredWordlist = 1;
  Object.defineProperty(wordlist, "__esModule", { value: true });
  wordlist.wordlist = void 0;
  const EN = [
    "abandon",
    "ability",
    "able",
    "about",
    "above",
    "absent",
    "absorb",
    "abstract",
    "absurd",
    "abuse",
    "access",
    "accident",
    "account",
    "accuse",
    "achieve",
    "acid",
    "acoustic",
    "acquire",
    "across",
    "act",
    "action",
    "actor",
    "actress",
    "actual",
    "adapt",
    "add",
    "addict",
    "address",
    "adjust",
    "admit",
    "adult",
    "advance",
    "advice",
    "aerobic",
    "affair",
    "afford",
    "afraid",
    "again",
    "age",
    "agent",
    "agree",
    "ahead",
    "aim",
    "air",
    "airport",
    "aisle",
    "alarm",
    "album",
    "alcohol",
    "alert",
    "alien",
    "all",
    "alley",
    "allow",
    "almost",
    "alone",
    "alpha",
    "already",
    "also",
    "alter",
    "always",
    "amateur",
    "amazing",
    "among",
    "amount",
    "amused",
    "analyst",
    "anchor",
    "ancient",
    "anger",
    "angle",
    "angry",
    "animal",
    "ankle",
    "announce",
    "annual",
    "another",
    "answer",
    "antenna",
    "antique",
    "anxiety",
    "any",
    "apart",
    "apology",
    "appear",
    "apple",
    "approve",
    "april",
    "arch",
    "arctic",
    "area",
    "arena",
    "argue",
    "arm",
    "armed",
    "armor",
    "army",
    "around",
    "arrange",
    "arrest",
    "arrive",
    "arrow",
    "art",
    "artefact",
    "artist",
    "artwork",
    "ask",
    "aspect",
    "assault",
    "asset",
    "assist",
    "assume",
    "asthma",
    "athlete",
    "atom",
    "attack",
    "attend",
    "attitude",
    "attract",
    "auction",
    "audit",
    "august",
    "aunt",
    "author",
    "auto",
    "autumn",
    "average",
    "avocado",
    "avoid",
    "awake",
    "aware",
    "away",
    "awesome",
    "awful",
    "awkward",
    "axis",
    "baby",
    "bachelor",
    "bacon",
    "badge",
    "bag",
    "balance",
    "balcony",
    "ball",
    "bamboo",
    "banana",
    "banner",
    "bar",
    "barely",
    "bargain",
    "barrel",
    "base",
    "basic",
    "basket",
    "battle",
    "beach",
    "bean",
    "beauty",
    "because",
    "become",
    "beef",
    "before",
    "begin",
    "behave",
    "behind",
    "believe",
    "below",
    "belt",
    "bench",
    "benefit",
    "best",
    "betray",
    "better",
    "between",
    "beyond",
    "bicycle",
    "bid",
    "bike",
    "bind",
    "biology",
    "bird",
    "birth",
    "bitter",
    "black",
    "blade",
    "blame",
    "blanket",
    "blast",
    "bleak",
    "bless",
    "blind",
    "blood",
    "blossom",
    "blouse",
    "blue",
    "blur",
    "blush",
    "board",
    "boat",
    "body",
    "boil",
    "bomb",
    "bone",
    "bonus",
    "book",
    "boost",
    "border",
    "boring",
    "borrow",
    "boss",
    "bottom",
    "bounce",
    "box",
    "boy",
    "bracket",
    "brain",
    "brand",
    "brass",
    "brave",
    "bread",
    "breeze",
    "brick",
    "bridge",
    "brief",
    "bright",
    "bring",
    "brisk",
    "broccoli",
    "broken",
    "bronze",
    "broom",
    "brother",
    "brown",
    "brush",
    "bubble",
    "buddy",
    "budget",
    "buffalo",
    "build",
    "bulb",
    "bulk",
    "bullet",
    "bundle",
    "bunker",
    "burden",
    "burger",
    "burst",
    "bus",
    "business",
    "busy",
    "butter",
    "buyer",
    "buzz",
    "cabbage",
    "cabin",
    "cable",
    "cactus",
    "cage",
    "cake",
    "call",
    "calm",
    "camera",
    "camp",
    "can",
    "canal",
    "cancel",
    "candy",
    "cannon",
    "canoe",
    "canvas",
    "canyon",
    "capable",
    "capital",
    "captain",
    "car",
    "carbon",
    "card",
    "cargo",
    "carpet",
    "carry",
    "cart",
    "case",
    "cash",
    "casino",
    "castle",
    "casual",
    "cat",
    "catalog",
    "catch",
    "category",
    "cattle",
    "caught",
    "cause",
    "caution",
    "cave",
    "ceiling",
    "celery",
    "cement",
    "census",
    "century",
    "cereal",
    "certain",
    "chair",
    "chalk",
    "champion",
    "change",
    "chaos",
    "chapter",
    "charge",
    "chase",
    "chat",
    "cheap",
    "check",
    "cheese",
    "chef",
    "cherry",
    "chest",
    "chicken",
    "chief",
    "child",
    "chimney",
    "choice",
    "choose",
    "chronic",
    "chuckle",
    "chunk",
    "churn",
    "cigar",
    "cinnamon",
    "circle",
    "citizen",
    "city",
    "civil",
    "claim",
    "clap",
    "clarify",
    "claw",
    "clay",
    "clean",
    "clerk",
    "clever",
    "click",
    "client",
    "cliff",
    "climb",
    "clinic",
    "clip",
    "clock",
    "clog",
    "close",
    "cloth",
    "cloud",
    "clown",
    "club",
    "clump",
    "cluster",
    "clutch",
    "coach",
    "coast",
    "coconut",
    "code",
    "coffee",
    "coil",
    "coin",
    "collect",
    "color",
    "column",
    "combine",
    "come",
    "comfort",
    "comic",
    "common",
    "company",
    "concert",
    "conduct",
    "confirm",
    "congress",
    "connect",
    "consider",
    "control",
    "convince",
    "cook",
    "cool",
    "copper",
    "copy",
    "coral",
    "core",
    "corn",
    "correct",
    "cost",
    "cotton",
    "couch",
    "country",
    "couple",
    "course",
    "cousin",
    "cover",
    "coyote",
    "crack",
    "cradle",
    "craft",
    "cram",
    "crane",
    "crash",
    "crater",
    "crawl",
    "crazy",
    "cream",
    "credit",
    "creek",
    "crew",
    "cricket",
    "crime",
    "crisp",
    "critic",
    "crop",
    "cross",
    "crouch",
    "crowd",
    "crucial",
    "cruel",
    "cruise",
    "crumble",
    "crunch",
    "crush",
    "cry",
    "crystal",
    "cube",
    "culture",
    "cup",
    "cupboard",
    "curious",
    "current",
    "curtain",
    "curve",
    "cushion",
    "custom",
    "cute",
    "cycle",
    "dad",
    "damage",
    "damp",
    "dance",
    "danger",
    "daring",
    "dash",
    "daughter",
    "dawn",
    "day",
    "deal",
    "debate",
    "debris",
    "decade",
    "december",
    "decide",
    "decline",
    "decorate",
    "decrease",
    "deer",
    "defense",
    "define",
    "defy",
    "degree",
    "delay",
    "deliver",
    "demand",
    "demise",
    "denial",
    "dentist",
    "deny",
    "depart",
    "depend",
    "deposit",
    "depth",
    "deputy",
    "derive",
    "describe",
    "desert",
    "design",
    "desk",
    "despair",
    "destroy",
    "detail",
    "detect",
    "develop",
    "device",
    "devote",
    "diagram",
    "dial",
    "diamond",
    "diary",
    "dice",
    "diesel",
    "diet",
    "differ",
    "digital",
    "dignity",
    "dilemma",
    "dinner",
    "dinosaur",
    "direct",
    "dirt",
    "disagree",
    "discover",
    "disease",
    "dish",
    "dismiss",
    "disorder",
    "display",
    "distance",
    "divert",
    "divide",
    "divorce",
    "dizzy",
    "doctor",
    "document",
    "dog",
    "doll",
    "dolphin",
    "domain",
    "donate",
    "donkey",
    "donor",
    "door",
    "dose",
    "double",
    "dove",
    "draft",
    "dragon",
    "drama",
    "drastic",
    "draw",
    "dream",
    "dress",
    "drift",
    "drill",
    "drink",
    "drip",
    "drive",
    "drop",
    "drum",
    "dry",
    "duck",
    "dumb",
    "dune",
    "during",
    "dust",
    "dutch",
    "duty",
    "dwarf",
    "dynamic",
    "eager",
    "eagle",
    "early",
    "earn",
    "earth",
    "easily",
    "east",
    "easy",
    "echo",
    "ecology",
    "economy",
    "edge",
    "edit",
    "educate",
    "effort",
    "egg",
    "eight",
    "either",
    "elbow",
    "elder",
    "electric",
    "elegant",
    "element",
    "elephant",
    "elevator",
    "elite",
    "else",
    "embark",
    "embody",
    "embrace",
    "emerge",
    "emotion",
    "employ",
    "empower",
    "empty",
    "enable",
    "enact",
    "end",
    "endless",
    "endorse",
    "enemy",
    "energy",
    "enforce",
    "engage",
    "engine",
    "enhance",
    "enjoy",
    "enlist",
    "enough",
    "enrich",
    "enroll",
    "ensure",
    "enter",
    "entire",
    "entry",
    "envelope",
    "episode",
    "equal",
    "equip",
    "era",
    "erase",
    "erode",
    "erosion",
    "error",
    "erupt",
    "escape",
    "essay",
    "essence",
    "estate",
    "eternal",
    "ethics",
    "evidence",
    "evil",
    "evoke",
    "evolve",
    "exact",
    "example",
    "excess",
    "exchange",
    "excite",
    "exclude",
    "excuse",
    "execute",
    "exercise",
    "exhaust",
    "exhibit",
    "exile",
    "exist",
    "exit",
    "exotic",
    "expand",
    "expect",
    "expire",
    "explain",
    "expose",
    "express",
    "extend",
    "extra",
    "eye",
    "eyebrow",
    "fabric",
    "face",
    "faculty",
    "fade",
    "faint",
    "faith",
    "fall",
    "false",
    "fame",
    "family",
    "famous",
    "fan",
    "fancy",
    "fantasy",
    "farm",
    "fashion",
    "fat",
    "fatal",
    "father",
    "fatigue",
    "fault",
    "favorite",
    "feature",
    "february",
    "federal",
    "fee",
    "feed",
    "feel",
    "female",
    "fence",
    "festival",
    "fetch",
    "fever",
    "few",
    "fiber",
    "fiction",
    "field",
    "figure",
    "file",
    "film",
    "filter",
    "final",
    "find",
    "fine",
    "finger",
    "finish",
    "fire",
    "firm",
    "first",
    "fiscal",
    "fish",
    "fit",
    "fitness",
    "fix",
    "flag",
    "flame",
    "flash",
    "flat",
    "flavor",
    "flee",
    "flight",
    "flip",
    "float",
    "flock",
    "floor",
    "flower",
    "fluid",
    "flush",
    "fly",
    "foam",
    "focus",
    "fog",
    "foil",
    "fold",
    "follow",
    "food",
    "foot",
    "force",
    "forest",
    "forget",
    "fork",
    "fortune",
    "forum",
    "forward",
    "fossil",
    "foster",
    "found",
    "fox",
    "fragile",
    "frame",
    "frequent",
    "fresh",
    "friend",
    "fringe",
    "frog",
    "front",
    "frost",
    "frown",
    "frozen",
    "fruit",
    "fuel",
    "fun",
    "funny",
    "furnace",
    "fury",
    "future",
    "gadget",
    "gain",
    "galaxy",
    "gallery",
    "game",
    "gap",
    "garage",
    "garbage",
    "garden",
    "garlic",
    "garment",
    "gas",
    "gasp",
    "gate",
    "gather",
    "gauge",
    "gaze",
    "general",
    "genius",
    "genre",
    "gentle",
    "genuine",
    "gesture",
    "ghost",
    "giant",
    "gift",
    "giggle",
    "ginger",
    "giraffe",
    "girl",
    "give",
    "glad",
    "glance",
    "glare",
    "glass",
    "glide",
    "glimpse",
    "globe",
    "gloom",
    "glory",
    "glove",
    "glow",
    "glue",
    "goat",
    "goddess",
    "gold",
    "good",
    "goose",
    "gorilla",
    "gospel",
    "gossip",
    "govern",
    "gown",
    "grab",
    "grace",
    "grain",
    "grant",
    "grape",
    "grass",
    "gravity",
    "great",
    "green",
    "grid",
    "grief",
    "grit",
    "grocery",
    "group",
    "grow",
    "grunt",
    "guard",
    "guess",
    "guide",
    "guilt",
    "guitar",
    "gun",
    "gym",
    "habit",
    "hair",
    "half",
    "hammer",
    "hamster",
    "hand",
    "happy",
    "harbor",
    "hard",
    "harsh",
    "harvest",
    "hat",
    "have",
    "hawk",
    "hazard",
    "head",
    "health",
    "heart",
    "heavy",
    "hedgehog",
    "height",
    "hello",
    "helmet",
    "help",
    "hen",
    "hero",
    "hidden",
    "high",
    "hill",
    "hint",
    "hip",
    "hire",
    "history",
    "hobby",
    "hockey",
    "hold",
    "hole",
    "holiday",
    "hollow",
    "home",
    "honey",
    "hood",
    "hope",
    "horn",
    "horror",
    "horse",
    "hospital",
    "host",
    "hotel",
    "hour",
    "hover",
    "hub",
    "huge",
    "human",
    "humble",
    "humor",
    "hundred",
    "hungry",
    "hunt",
    "hurdle",
    "hurry",
    "hurt",
    "husband",
    "hybrid",
    "ice",
    "icon",
    "idea",
    "identify",
    "idle",
    "ignore",
    "ill",
    "illegal",
    "illness",
    "image",
    "imitate",
    "immense",
    "immune",
    "impact",
    "impose",
    "improve",
    "impulse",
    "inch",
    "include",
    "income",
    "increase",
    "index",
    "indicate",
    "indoor",
    "industry",
    "infant",
    "inflict",
    "inform",
    "inhale",
    "inherit",
    "initial",
    "inject",
    "injury",
    "inmate",
    "inner",
    "innocent",
    "input",
    "inquiry",
    "insane",
    "insect",
    "inside",
    "inspire",
    "install",
    "intact",
    "interest",
    "into",
    "invest",
    "invite",
    "involve",
    "iron",
    "island",
    "isolate",
    "issue",
    "item",
    "ivory",
    "jacket",
    "jaguar",
    "jar",
    "jazz",
    "jealous",
    "jeans",
    "jelly",
    "jewel",
    "job",
    "join",
    "joke",
    "journey",
    "joy",
    "judge",
    "juice",
    "jump",
    "jungle",
    "junior",
    "junk",
    "just",
    "kangaroo",
    "keen",
    "keep",
    "ketchup",
    "key",
    "kick",
    "kid",
    "kidney",
    "kind",
    "kingdom",
    "kiss",
    "kit",
    "kitchen",
    "kite",
    "kitten",
    "kiwi",
    "knee",
    "knife",
    "knock",
    "know",
    "lab",
    "label",
    "labor",
    "ladder",
    "lady",
    "lake",
    "lamp",
    "language",
    "laptop",
    "large",
    "later",
    "latin",
    "laugh",
    "laundry",
    "lava",
    "law",
    "lawn",
    "lawsuit",
    "layer",
    "lazy",
    "leader",
    "leaf",
    "learn",
    "leave",
    "lecture",
    "left",
    "leg",
    "legal",
    "legend",
    "leisure",
    "lemon",
    "lend",
    "length",
    "lens",
    "leopard",
    "lesson",
    "letter",
    "level",
    "liar",
    "liberty",
    "library",
    "license",
    "life",
    "lift",
    "light",
    "like",
    "limb",
    "limit",
    "link",
    "lion",
    "liquid",
    "list",
    "little",
    "live",
    "lizard",
    "load",
    "loan",
    "lobster",
    "local",
    "lock",
    "logic",
    "lonely",
    "long",
    "loop",
    "lottery",
    "loud",
    "lounge",
    "love",
    "loyal",
    "lucky",
    "luggage",
    "lumber",
    "lunar",
    "lunch",
    "luxury",
    "lyrics",
    "machine",
    "mad",
    "magic",
    "magnet",
    "maid",
    "mail",
    "main",
    "major",
    "make",
    "mammal",
    "man",
    "manage",
    "mandate",
    "mango",
    "mansion",
    "manual",
    "maple",
    "marble",
    "march",
    "margin",
    "marine",
    "market",
    "marriage",
    "mask",
    "mass",
    "master",
    "match",
    "material",
    "math",
    "matrix",
    "matter",
    "maximum",
    "maze",
    "meadow",
    "mean",
    "measure",
    "meat",
    "mechanic",
    "medal",
    "media",
    "melody",
    "melt",
    "member",
    "memory",
    "mention",
    "menu",
    "mercy",
    "merge",
    "merit",
    "merry",
    "mesh",
    "message",
    "metal",
    "method",
    "middle",
    "midnight",
    "milk",
    "million",
    "mimic",
    "mind",
    "minimum",
    "minor",
    "minute",
    "miracle",
    "mirror",
    "misery",
    "miss",
    "mistake",
    "mix",
    "mixed",
    "mixture",
    "mobile",
    "model",
    "modify",
    "mom",
    "moment",
    "monitor",
    "monkey",
    "monster",
    "month",
    "moon",
    "moral",
    "more",
    "morning",
    "mosquito",
    "mother",
    "motion",
    "motor",
    "mountain",
    "mouse",
    "move",
    "movie",
    "much",
    "muffin",
    "mule",
    "multiply",
    "muscle",
    "museum",
    "mushroom",
    "music",
    "must",
    "mutual",
    "myself",
    "mystery",
    "myth",
    "naive",
    "name",
    "napkin",
    "narrow",
    "nasty",
    "nation",
    "nature",
    "near",
    "neck",
    "need",
    "negative",
    "neglect",
    "neither",
    "nephew",
    "nerve",
    "nest",
    "net",
    "network",
    "neutral",
    "never",
    "news",
    "next",
    "nice",
    "night",
    "noble",
    "noise",
    "nominee",
    "noodle",
    "normal",
    "north",
    "nose",
    "notable",
    "note",
    "nothing",
    "notice",
    "novel",
    "now",
    "nuclear",
    "number",
    "nurse",
    "nut",
    "oak",
    "obey",
    "object",
    "oblige",
    "obscure",
    "observe",
    "obtain",
    "obvious",
    "occur",
    "ocean",
    "october",
    "odor",
    "off",
    "offer",
    "office",
    "often",
    "oil",
    "okay",
    "old",
    "olive",
    "olympic",
    "omit",
    "once",
    "one",
    "onion",
    "online",
    "only",
    "open",
    "opera",
    "opinion",
    "oppose",
    "option",
    "orange",
    "orbit",
    "orchard",
    "order",
    "ordinary",
    "organ",
    "orient",
    "original",
    "orphan",
    "ostrich",
    "other",
    "outdoor",
    "outer",
    "output",
    "outside",
    "oval",
    "oven",
    "over",
    "own",
    "owner",
    "oxygen",
    "oyster",
    "ozone",
    "pact",
    "paddle",
    "page",
    "pair",
    "palace",
    "palm",
    "panda",
    "panel",
    "panic",
    "panther",
    "paper",
    "parade",
    "parent",
    "park",
    "parrot",
    "party",
    "pass",
    "patch",
    "path",
    "patient",
    "patrol",
    "pattern",
    "pause",
    "pave",
    "payment",
    "peace",
    "peanut",
    "pear",
    "peasant",
    "pelican",
    "pen",
    "penalty",
    "pencil",
    "people",
    "pepper",
    "perfect",
    "permit",
    "person",
    "pet",
    "phone",
    "photo",
    "phrase",
    "physical",
    "piano",
    "picnic",
    "picture",
    "piece",
    "pig",
    "pigeon",
    "pill",
    "pilot",
    "pink",
    "pioneer",
    "pipe",
    "pistol",
    "pitch",
    "pizza",
    "place",
    "planet",
    "plastic",
    "plate",
    "play",
    "please",
    "pledge",
    "pluck",
    "plug",
    "plunge",
    "poem",
    "poet",
    "point",
    "polar",
    "pole",
    "police",
    "pond",
    "pony",
    "pool",
    "popular",
    "portion",
    "position",
    "possible",
    "post",
    "potato",
    "pottery",
    "poverty",
    "powder",
    "power",
    "practice",
    "praise",
    "predict",
    "prefer",
    "prepare",
    "present",
    "pretty",
    "prevent",
    "price",
    "pride",
    "primary",
    "print",
    "priority",
    "prison",
    "private",
    "prize",
    "problem",
    "process",
    "produce",
    "profit",
    "program",
    "project",
    "promote",
    "proof",
    "property",
    "prosper",
    "protect",
    "proud",
    "provide",
    "public",
    "pudding",
    "pull",
    "pulp",
    "pulse",
    "pumpkin",
    "punch",
    "pupil",
    "puppy",
    "purchase",
    "purity",
    "purpose",
    "purse",
    "push",
    "put",
    "puzzle",
    "pyramid",
    "quality",
    "quantum",
    "quarter",
    "question",
    "quick",
    "quit",
    "quiz",
    "quote",
    "rabbit",
    "raccoon",
    "race",
    "rack",
    "radar",
    "radio",
    "rail",
    "rain",
    "raise",
    "rally",
    "ramp",
    "ranch",
    "random",
    "range",
    "rapid",
    "rare",
    "rate",
    "rather",
    "raven",
    "raw",
    "razor",
    "ready",
    "real",
    "reason",
    "rebel",
    "rebuild",
    "recall",
    "receive",
    "recipe",
    "record",
    "recycle",
    "reduce",
    "reflect",
    "reform",
    "refuse",
    "region",
    "regret",
    "regular",
    "reject",
    "relax",
    "release",
    "relief",
    "rely",
    "remain",
    "remember",
    "remind",
    "remove",
    "render",
    "renew",
    "rent",
    "reopen",
    "repair",
    "repeat",
    "replace",
    "report",
    "require",
    "rescue",
    "resemble",
    "resist",
    "resource",
    "response",
    "result",
    "retire",
    "retreat",
    "return",
    "reunion",
    "reveal",
    "review",
    "reward",
    "rhythm",
    "rib",
    "ribbon",
    "rice",
    "rich",
    "ride",
    "ridge",
    "rifle",
    "right",
    "rigid",
    "ring",
    "riot",
    "ripple",
    "risk",
    "ritual",
    "rival",
    "river",
    "road",
    "roast",
    "robot",
    "robust",
    "rocket",
    "romance",
    "roof",
    "rookie",
    "room",
    "rose",
    "rotate",
    "rough",
    "round",
    "route",
    "royal",
    "rubber",
    "rude",
    "rug",
    "rule",
    "run",
    "runway",
    "rural",
    "sad",
    "saddle",
    "sadness",
    "safe",
    "sail",
    "salad",
    "salmon",
    "salon",
    "salt",
    "salute",
    "same",
    "sample",
    "sand",
    "satisfy",
    "satoshi",
    "sauce",
    "sausage",
    "save",
    "say",
    "scale",
    "scan",
    "scare",
    "scatter",
    "scene",
    "scheme",
    "school",
    "science",
    "scissors",
    "scorpion",
    "scout",
    "scrap",
    "screen",
    "script",
    "scrub",
    "sea",
    "search",
    "season",
    "seat",
    "second",
    "secret",
    "section",
    "security",
    "seed",
    "seek",
    "segment",
    "select",
    "sell",
    "seminar",
    "senior",
    "sense",
    "sentence",
    "series",
    "service",
    "session",
    "settle",
    "setup",
    "seven",
    "shadow",
    "shaft",
    "shallow",
    "share",
    "shed",
    "shell",
    "sheriff",
    "shield",
    "shift",
    "shine",
    "ship",
    "shiver",
    "shock",
    "shoe",
    "shoot",
    "shop",
    "short",
    "shoulder",
    "shove",
    "shrimp",
    "shrug",
    "shuffle",
    "shy",
    "sibling",
    "sick",
    "side",
    "siege",
    "sight",
    "sign",
    "silent",
    "silk",
    "silly",
    "silver",
    "similar",
    "simple",
    "since",
    "sing",
    "siren",
    "sister",
    "situate",
    "six",
    "size",
    "skate",
    "sketch",
    "ski",
    "skill",
    "skin",
    "skirt",
    "skull",
    "slab",
    "slam",
    "sleep",
    "slender",
    "slice",
    "slide",
    "slight",
    "slim",
    "slogan",
    "slot",
    "slow",
    "slush",
    "small",
    "smart",
    "smile",
    "smoke",
    "smooth",
    "snack",
    "snake",
    "snap",
    "sniff",
    "snow",
    "soap",
    "soccer",
    "social",
    "sock",
    "soda",
    "soft",
    "solar",
    "soldier",
    "solid",
    "solution",
    "solve",
    "someone",
    "song",
    "soon",
    "sorry",
    "sort",
    "soul",
    "sound",
    "soup",
    "source",
    "south",
    "space",
    "spare",
    "spatial",
    "spawn",
    "speak",
    "special",
    "speed",
    "spell",
    "spend",
    "sphere",
    "spice",
    "spider",
    "spike",
    "spin",
    "spirit",
    "split",
    "spoil",
    "sponsor",
    "spoon",
    "sport",
    "spot",
    "spray",
    "spread",
    "spring",
    "spy",
    "square",
    "squeeze",
    "squirrel",
    "stable",
    "stadium",
    "staff",
    "stage",
    "stairs",
    "stamp",
    "stand",
    "start",
    "state",
    "stay",
    "steak",
    "steel",
    "stem",
    "step",
    "stereo",
    "stick",
    "still",
    "sting",
    "stock",
    "stomach",
    "stone",
    "stool",
    "story",
    "stove",
    "strategy",
    "street",
    "strike",
    "strong",
    "struggle",
    "student",
    "stuff",
    "stumble",
    "style",
    "subject",
    "submit",
    "subway",
    "success",
    "such",
    "sudden",
    "suffer",
    "sugar",
    "suggest",
    "suit",
    "summer",
    "sun",
    "sunny",
    "sunset",
    "super",
    "supply",
    "supreme",
    "sure",
    "surface",
    "surge",
    "surprise",
    "surround",
    "survey",
    "suspect",
    "sustain",
    "swallow",
    "swamp",
    "swap",
    "swarm",
    "swear",
    "sweet",
    "swift",
    "swim",
    "swing",
    "switch",
    "sword",
    "symbol",
    "symptom",
    "syrup",
    "system",
    "table",
    "tackle",
    "tag",
    "tail",
    "talent",
    "talk",
    "tank",
    "tape",
    "target",
    "task",
    "taste",
    "tattoo",
    "taxi",
    "teach",
    "team",
    "tell",
    "ten",
    "tenant",
    "tennis",
    "tent",
    "term",
    "test",
    "text",
    "thank",
    "that",
    "theme",
    "then",
    "theory",
    "there",
    "they",
    "thing",
    "this",
    "thought",
    "three",
    "thrive",
    "throw",
    "thumb",
    "thunder",
    "ticket",
    "tide",
    "tiger",
    "tilt",
    "timber",
    "time",
    "tiny",
    "tip",
    "tired",
    "tissue",
    "title",
    "toast",
    "tobacco",
    "today",
    "toddler",
    "toe",
    "together",
    "toilet",
    "token",
    "tomato",
    "tomorrow",
    "tone",
    "tongue",
    "tonight",
    "tool",
    "tooth",
    "top",
    "topic",
    "topple",
    "torch",
    "tornado",
    "tortoise",
    "toss",
    "total",
    "tourist",
    "toward",
    "tower",
    "town",
    "toy",
    "track",
    "trade",
    "traffic",
    "tragic",
    "train",
    "transfer",
    "trap",
    "trash",
    "travel",
    "tray",
    "treat",
    "tree",
    "trend",
    "trial",
    "tribe",
    "trick",
    "trigger",
    "trim",
    "trip",
    "trophy",
    "trouble",
    "truck",
    "true",
    "truly",
    "trumpet",
    "trust",
    "truth",
    "try",
    "tube",
    "tuition",
    "tumble",
    "tuna",
    "tunnel",
    "turkey",
    "turn",
    "turtle",
    "twelve",
    "twenty",
    "twice",
    "twin",
    "twist",
    "two",
    "type",
    "typical",
    "ugly",
    "umbrella",
    "unable",
    "unaware",
    "uncle",
    "uncover",
    "under",
    "undo",
    "unfair",
    "unfold",
    "unhappy",
    "uniform",
    "unique",
    "unit",
    "universe",
    "unknown",
    "unlock",
    "until",
    "unusual",
    "unveil",
    "update",
    "upgrade",
    "uphold",
    "upon",
    "upper",
    "upset",
    "urban",
    "urge",
    "usage",
    "use",
    "used",
    "useful",
    "useless",
    "usual",
    "utility",
    "vacant",
    "vacuum",
    "vague",
    "valid",
    "valley",
    "valve",
    "van",
    "vanish",
    "vapor",
    "various",
    "vast",
    "vault",
    "vehicle",
    "velvet",
    "vendor",
    "venture",
    "venue",
    "verb",
    "verify",
    "version",
    "very",
    "vessel",
    "veteran",
    "viable",
    "vibrant",
    "vicious",
    "victory",
    "video",
    "view",
    "village",
    "vintage",
    "violin",
    "virtual",
    "virus",
    "visa",
    "visit",
    "visual",
    "vital",
    "vivid",
    "vocal",
    "voice",
    "void",
    "volcano",
    "volume",
    "vote",
    "voyage",
    "wage",
    "wagon",
    "wait",
    "walk",
    "wall",
    "walnut",
    "want",
    "warfare",
    "warm",
    "warrior",
    "wash",
    "wasp",
    "waste",
    "water",
    "wave",
    "way",
    "wealth",
    "weapon",
    "wear",
    "weasel",
    "weather",
    "web",
    "wedding",
    "weekend",
    "weird",
    "welcome",
    "west",
    "wet",
    "whale",
    "what",
    "wheat",
    "wheel",
    "when",
    "where",
    "whip",
    "whisper",
    "wide",
    "width",
    "wife",
    "wild",
    "will",
    "win",
    "window",
    "wine",
    "wing",
    "wink",
    "winner",
    "winter",
    "wire",
    "wisdom",
    "wise",
    "wish",
    "witness",
    "wolf",
    "woman",
    "wonder",
    "wood",
    "wool",
    "word",
    "work",
    "world",
    "worry",
    "worth",
    "wrap",
    "wreck",
    "wrestle",
    "wrist",
    "write",
    "wrong",
    "yard",
    "year",
    "yellow",
    "you",
    "young",
    "youth",
    "zebra",
    "zero",
    "zone",
    "zoo"
  ];
  wordlist.wordlist = EN;
  return wordlist;
}
var hasRequiredMnemonic;
function requireMnemonic() {
  if (hasRequiredMnemonic) return mnemonic;
  hasRequiredMnemonic = 1;
  var __importDefault = mnemonic && mnemonic.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(mnemonic, "__esModule", { value: true });
  mnemonic.mnemonicFromRandomSeed = mnemonic.mnemonicIndexesToBytes = mnemonic.bytesToMnemonics = mnemonic.bytesToMnemonicIndexes = mnemonic.mnemonicNew = mnemonic.mnemonicValidate = mnemonic.mnemonicToHDSeed = mnemonic.mnemonicToWalletKey = mnemonic.mnemonicToPrivateKey = mnemonic.mnemonicToSeed = mnemonic.mnemonicToEntropy = void 0;
  const tweetnacl_1 = __importDefault(requireNaclFast());
  const getSecureRandom_1 = requireGetSecureRandom();
  const hmac_sha512_1 = requireHmac_sha512();
  const pbkdf2_sha512_1 = requirePbkdf2_sha512();
  const binary_1 = requireBinary();
  const wordlist_1 = requireWordlist();
  const PBKDF_ITERATIONS = 1e5;
  async function isPasswordNeeded(mnemonicArray) {
    const passlessEntropy = await mnemonicToEntropy(mnemonicArray);
    return await isPasswordSeed(passlessEntropy) && !await isBasicSeed(passlessEntropy);
  }
  function normalizeMnemonic(src2) {
    return src2.map((v2) => v2.toLowerCase().trim());
  }
  async function isBasicSeed(entropy) {
    const seed = await (0, pbkdf2_sha512_1.pbkdf2_sha512)(entropy, "TON seed version", Math.max(1, Math.floor(PBKDF_ITERATIONS / 256)), 64);
    return seed[0] == 0;
  }
  async function isPasswordSeed(entropy) {
    const seed = await (0, pbkdf2_sha512_1.pbkdf2_sha512)(entropy, "TON fast seed version", 1, 64);
    return seed[0] == 1;
  }
  async function mnemonicToEntropy(mnemonicArray, password) {
    return await (0, hmac_sha512_1.hmac_sha512)(mnemonicArray.join(" "), password && password.length > 0 ? password : "");
  }
  mnemonic.mnemonicToEntropy = mnemonicToEntropy;
  async function mnemonicToSeed(mnemonicArray, seed, password) {
    const entropy = await mnemonicToEntropy(mnemonicArray, password);
    return await (0, pbkdf2_sha512_1.pbkdf2_sha512)(entropy, seed, PBKDF_ITERATIONS, 64);
  }
  mnemonic.mnemonicToSeed = mnemonicToSeed;
  async function mnemonicToPrivateKey(mnemonicArray, password) {
    mnemonicArray = normalizeMnemonic(mnemonicArray);
    const seed = await mnemonicToSeed(mnemonicArray, "TON default seed", password);
    let keyPair = tweetnacl_1.default.sign.keyPair.fromSeed(seed.slice(0, 32));
    return {
      publicKey: Buffer.from(keyPair.publicKey),
      secretKey: Buffer.from(keyPair.secretKey)
    };
  }
  mnemonic.mnemonicToPrivateKey = mnemonicToPrivateKey;
  async function mnemonicToWalletKey(mnemonicArray, password) {
    let seedPk = await mnemonicToPrivateKey(mnemonicArray, password);
    let seedSecret = seedPk.secretKey.slice(0, 32);
    const keyPair = tweetnacl_1.default.sign.keyPair.fromSeed(seedSecret);
    return {
      publicKey: Buffer.from(keyPair.publicKey),
      secretKey: Buffer.from(keyPair.secretKey)
    };
  }
  mnemonic.mnemonicToWalletKey = mnemonicToWalletKey;
  async function mnemonicToHDSeed(mnemonicArray, password) {
    mnemonicArray = normalizeMnemonic(mnemonicArray);
    return await mnemonicToSeed(mnemonicArray, "TON HD Keys seed", password);
  }
  mnemonic.mnemonicToHDSeed = mnemonicToHDSeed;
  async function mnemonicValidate(mnemonicArray, password) {
    mnemonicArray = normalizeMnemonic(mnemonicArray);
    for (let word of mnemonicArray) {
      if (wordlist_1.wordlist.indexOf(word) < 0) {
        return false;
      }
    }
    if (password && password.length > 0) {
      if (!await isPasswordNeeded(mnemonicArray)) {
        return false;
      }
    }
    return await isBasicSeed(await mnemonicToEntropy(mnemonicArray, password));
  }
  mnemonic.mnemonicValidate = mnemonicValidate;
  async function mnemonicNew(wordsCount = 24, password) {
    let mnemonicArray = [];
    while (true) {
      mnemonicArray = [];
      for (let i = 0; i < wordsCount; i++) {
        let ind = await (0, getSecureRandom_1.getSecureRandomNumber)(0, wordlist_1.wordlist.length);
        mnemonicArray.push(wordlist_1.wordlist[ind]);
      }
      if (password && password.length > 0) {
        if (!await isPasswordNeeded(mnemonicArray)) {
          continue;
        }
      }
      if (!await isBasicSeed(await mnemonicToEntropy(mnemonicArray, password))) {
        continue;
      }
      break;
    }
    return mnemonicArray;
  }
  mnemonic.mnemonicNew = mnemonicNew;
  function bytesToMnemonicIndexes(src2, wordsCount) {
    let bits = (0, binary_1.bytesToBits)(src2);
    let indexes = [];
    for (let i = 0; i < wordsCount; i++) {
      let sl = bits.slice(i * 11, i * 11 + 11);
      indexes.push(parseInt(sl, 2));
    }
    return indexes;
  }
  mnemonic.bytesToMnemonicIndexes = bytesToMnemonicIndexes;
  function bytesToMnemonics(src2, wordsCount) {
    let mnemonics2 = bytesToMnemonicIndexes(src2, wordsCount);
    let res = [];
    for (let m2 of mnemonics2) {
      res.push(wordlist_1.wordlist[m2]);
    }
    return res;
  }
  mnemonic.bytesToMnemonics = bytesToMnemonics;
  function mnemonicIndexesToBytes(src2) {
    let res = "";
    for (let s2 of src2) {
      if (!Number.isSafeInteger(s2)) {
        throw Error("Invalid input");
      }
      if (s2 < 0 || s2 >= 2028) {
        throw Error("Invalid input");
      }
      res += (0, binary_1.lpad)(s2.toString(2), "0", 11);
    }
    while (res.length % 8 !== 0) {
      res = res + "0";
    }
    return (0, binary_1.bitsToBytes)(res);
  }
  mnemonic.mnemonicIndexesToBytes = mnemonicIndexesToBytes;
  async function mnemonicFromRandomSeed(seed, wordsCount = 24, password) {
    const bytesLength = Math.ceil(wordsCount * 11 / 8);
    let currentSeed = seed;
    while (true) {
      let entropy = await (0, pbkdf2_sha512_1.pbkdf2_sha512)(currentSeed, "TON mnemonic seed", Math.max(1, Math.floor(PBKDF_ITERATIONS / 256)), bytesLength);
      let mnemonics2 = bytesToMnemonics(entropy, wordsCount);
      if (await mnemonicValidate(mnemonics2, password)) {
        return mnemonics2;
      }
      currentSeed = entropy;
    }
  }
  mnemonic.mnemonicFromRandomSeed = mnemonicFromRandomSeed;
  return mnemonic;
}
var nacl = {};
var hasRequiredNacl;
function requireNacl() {
  if (hasRequiredNacl) return nacl;
  hasRequiredNacl = 1;
  var __importDefault = nacl && nacl.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(nacl, "__esModule", { value: true });
  nacl.openBox = nacl.sealBox = nacl.signVerify = nacl.sign = nacl.keyPairFromSeed = nacl.keyPairFromSecretKey = void 0;
  const tweetnacl_1 = __importDefault(requireNaclFast());
  function keyPairFromSecretKey(secretKey) {
    let res = tweetnacl_1.default.sign.keyPair.fromSecretKey(new Uint8Array(secretKey));
    return {
      publicKey: Buffer.from(res.publicKey),
      secretKey: Buffer.from(res.secretKey)
    };
  }
  nacl.keyPairFromSecretKey = keyPairFromSecretKey;
  function keyPairFromSeed(secretKey) {
    let res = tweetnacl_1.default.sign.keyPair.fromSeed(new Uint8Array(secretKey));
    return {
      publicKey: Buffer.from(res.publicKey),
      secretKey: Buffer.from(res.secretKey)
    };
  }
  nacl.keyPairFromSeed = keyPairFromSeed;
  function sign(data, secretKey) {
    return Buffer.from(tweetnacl_1.default.sign.detached(new Uint8Array(data), new Uint8Array(secretKey)));
  }
  nacl.sign = sign;
  function signVerify(data, signature, publicKey) {
    return tweetnacl_1.default.sign.detached.verify(new Uint8Array(data), new Uint8Array(signature), new Uint8Array(publicKey));
  }
  nacl.signVerify = signVerify;
  function sealBox(data, nonce, key2) {
    return Buffer.from(tweetnacl_1.default.secretbox(data, nonce, key2));
  }
  nacl.sealBox = sealBox;
  function openBox(data, nonce, key2) {
    let res = tweetnacl_1.default.secretbox.open(data, nonce, key2);
    if (!res) {
      return null;
    }
    return Buffer.from(res);
  }
  nacl.openBox = openBox;
  return nacl;
}
var ed25519 = {};
var hasRequiredEd25519;
function requireEd25519() {
  if (hasRequiredEd25519) return ed25519;
  hasRequiredEd25519 = 1;
  Object.defineProperty(ed25519, "__esModule", { value: true });
  ed25519.deriveEd25519Path = ed25519.deriveED25519HardenedKey = ed25519.getED25519MasterKeyFromSeed = void 0;
  const hmac_sha512_1 = requireHmac_sha512();
  const ED25519_CURVE = "ed25519 seed";
  const HARDENED_OFFSET = 2147483648;
  async function getED25519MasterKeyFromSeed(seed) {
    const I2 = await (0, hmac_sha512_1.hmac_sha512)(ED25519_CURVE, seed);
    const IL = I2.slice(0, 32);
    const IR = I2.slice(32);
    return {
      key: IL,
      chainCode: IR
    };
  }
  ed25519.getED25519MasterKeyFromSeed = getED25519MasterKeyFromSeed;
  async function deriveED25519HardenedKey(parent, index) {
    if (index >= HARDENED_OFFSET) {
      throw Error("Key index must be less than offset");
    }
    const indexBuffer = Buffer.alloc(4);
    indexBuffer.writeUInt32BE(index + HARDENED_OFFSET, 0);
    const data = Buffer.concat([Buffer.alloc(1, 0), parent.key, indexBuffer]);
    const I2 = await (0, hmac_sha512_1.hmac_sha512)(parent.chainCode, data);
    const IL = I2.slice(0, 32);
    const IR = I2.slice(32);
    return {
      key: IL,
      chainCode: IR
    };
  }
  ed25519.deriveED25519HardenedKey = deriveED25519HardenedKey;
  async function deriveEd25519Path(seed, path) {
    let state = await getED25519MasterKeyFromSeed(seed);
    let remaining = [...path];
    while (remaining.length > 0) {
      let index = remaining[0];
      remaining = remaining.slice(1);
      state = await deriveED25519HardenedKey(state, index);
    }
    return state.key;
  }
  ed25519.deriveEd25519Path = deriveEd25519Path;
  return ed25519;
}
var symmetric = {};
var hasRequiredSymmetric;
function requireSymmetric() {
  if (hasRequiredSymmetric) return symmetric;
  hasRequiredSymmetric = 1;
  Object.defineProperty(symmetric, "__esModule", { value: true });
  symmetric.deriveSymmetricPath = symmetric.deriveSymmetricHardenedKey = symmetric.getSymmetricMasterKeyFromSeed = void 0;
  const hmac_sha512_1 = requireHmac_sha512();
  const SYMMETRIC_SEED = "Symmetric key seed";
  async function getSymmetricMasterKeyFromSeed(seed) {
    const I2 = await (0, hmac_sha512_1.hmac_sha512)(SYMMETRIC_SEED, seed);
    const IL = I2.slice(32);
    const IR = I2.slice(0, 32);
    return {
      key: IL,
      chainCode: IR
    };
  }
  symmetric.getSymmetricMasterKeyFromSeed = getSymmetricMasterKeyFromSeed;
  async function deriveSymmetricHardenedKey(parent, offset) {
    const data = Buffer.concat([Buffer.alloc(1, 0), Buffer.from(offset)]);
    const I2 = await (0, hmac_sha512_1.hmac_sha512)(parent.chainCode, data);
    const IL = I2.slice(32);
    const IR = I2.slice(0, 32);
    return {
      key: IL,
      chainCode: IR
    };
  }
  symmetric.deriveSymmetricHardenedKey = deriveSymmetricHardenedKey;
  async function deriveSymmetricPath(seed, path) {
    let state = await getSymmetricMasterKeyFromSeed(seed);
    let remaining = [...path];
    while (remaining.length > 0) {
      let index = remaining[0];
      remaining = remaining.slice(1);
      state = await deriveSymmetricHardenedKey(state, index);
    }
    return state.key;
  }
  symmetric.deriveSymmetricPath = deriveSymmetricPath;
  return symmetric;
}
var mnemonics = {};
var hasRequiredMnemonics;
function requireMnemonics() {
  if (hasRequiredMnemonics) return mnemonics;
  hasRequiredMnemonics = 1;
  Object.defineProperty(mnemonics, "__esModule", { value: true });
  mnemonics.deriveMnemonicsPath = mnemonics.deriveMnemonicHardenedKey = mnemonics.getMnemonicsMasterKeyFromSeed = void 0;
  const mnemonic_1 = requireMnemonic();
  const hmac_sha512_1 = requireHmac_sha512();
  const HARDENED_OFFSET = 2147483648;
  const MNEMONICS_SEED = "TON Mnemonics HD seed";
  async function getMnemonicsMasterKeyFromSeed(seed) {
    const I2 = await (0, hmac_sha512_1.hmac_sha512)(MNEMONICS_SEED, seed);
    const IL = I2.slice(0, 32);
    const IR = I2.slice(32);
    return {
      key: IL,
      chainCode: IR
    };
  }
  mnemonics.getMnemonicsMasterKeyFromSeed = getMnemonicsMasterKeyFromSeed;
  async function deriveMnemonicHardenedKey(parent, index) {
    if (index >= HARDENED_OFFSET) {
      throw Error("Key index must be less than offset");
    }
    const indexBuffer = Buffer.alloc(4);
    indexBuffer.writeUInt32BE(index + HARDENED_OFFSET, 0);
    const data = Buffer.concat([Buffer.alloc(1, 0), parent.key, indexBuffer]);
    const I2 = await (0, hmac_sha512_1.hmac_sha512)(parent.chainCode, data);
    const IL = I2.slice(0, 32);
    const IR = I2.slice(32);
    return {
      key: IL,
      chainCode: IR
    };
  }
  mnemonics.deriveMnemonicHardenedKey = deriveMnemonicHardenedKey;
  async function deriveMnemonicsPath(seed, path, wordsCount = 24, password) {
    let state = await getMnemonicsMasterKeyFromSeed(seed);
    let remaining = [...path];
    while (remaining.length > 0) {
      let index = remaining[0];
      remaining = remaining.slice(1);
      state = await deriveMnemonicHardenedKey(state, index);
    }
    return await (0, mnemonic_1.mnemonicFromRandomSeed)(state.key, wordsCount, password);
  }
  mnemonics.deriveMnemonicsPath = deriveMnemonicsPath;
  return mnemonics;
}
var hasRequiredDist$5;
function requireDist$5() {
  if (hasRequiredDist$5) return dist$4;
  hasRequiredDist$5 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMnemonicsMasterKeyFromSeed = exports.deriveMnemonicHardenedKey = exports.deriveMnemonicsPath = exports.deriveSymmetricPath = exports.deriveSymmetricHardenedKey = exports.getSymmetricMasterKeyFromSeed = exports.deriveEd25519Path = exports.deriveED25519HardenedKey = exports.getED25519MasterKeyFromSeed = exports.signVerify = exports.sign = exports.keyPairFromSecretKey = exports.keyPairFromSeed = exports.openBox = exports.sealBox = exports.mnemonicWordList = exports.mnemonicToHDSeed = exports.mnemonicToSeed = exports.mnemonicToWalletKey = exports.mnemonicToPrivateKey = exports.mnemonicValidate = exports.mnemonicNew = exports.newSecurePassphrase = exports.newSecureWords = exports.getSecureRandomNumber = exports.getSecureRandomWords = exports.getSecureRandomBytes = exports.hmac_sha512 = exports.pbkdf2_sha512 = exports.sha512_sync = exports.sha512 = exports.sha256_sync = exports.sha256 = void 0;
    var sha256_1 = requireSha256$1();
    Object.defineProperty(exports, "sha256", { enumerable: true, get: function() {
      return sha256_1.sha256;
    } });
    Object.defineProperty(exports, "sha256_sync", { enumerable: true, get: function() {
      return sha256_1.sha256_sync;
    } });
    var sha512_1 = requireSha512$1();
    Object.defineProperty(exports, "sha512", { enumerable: true, get: function() {
      return sha512_1.sha512;
    } });
    Object.defineProperty(exports, "sha512_sync", { enumerable: true, get: function() {
      return sha512_1.sha512_sync;
    } });
    var pbkdf2_sha512_1 = requirePbkdf2_sha512();
    Object.defineProperty(exports, "pbkdf2_sha512", { enumerable: true, get: function() {
      return pbkdf2_sha512_1.pbkdf2_sha512;
    } });
    var hmac_sha512_1 = requireHmac_sha512();
    Object.defineProperty(exports, "hmac_sha512", { enumerable: true, get: function() {
      return hmac_sha512_1.hmac_sha512;
    } });
    var getSecureRandom_1 = requireGetSecureRandom();
    Object.defineProperty(exports, "getSecureRandomBytes", { enumerable: true, get: function() {
      return getSecureRandom_1.getSecureRandomBytes;
    } });
    Object.defineProperty(exports, "getSecureRandomWords", { enumerable: true, get: function() {
      return getSecureRandom_1.getSecureRandomWords;
    } });
    Object.defineProperty(exports, "getSecureRandomNumber", { enumerable: true, get: function() {
      return getSecureRandom_1.getSecureRandomNumber;
    } });
    var newSecureWords_1 = requireNewSecureWords();
    Object.defineProperty(exports, "newSecureWords", { enumerable: true, get: function() {
      return newSecureWords_1.newSecureWords;
    } });
    var newSecurePassphrase_1 = requireNewSecurePassphrase();
    Object.defineProperty(exports, "newSecurePassphrase", { enumerable: true, get: function() {
      return newSecurePassphrase_1.newSecurePassphrase;
    } });
    var mnemonic_1 = requireMnemonic();
    Object.defineProperty(exports, "mnemonicNew", { enumerable: true, get: function() {
      return mnemonic_1.mnemonicNew;
    } });
    Object.defineProperty(exports, "mnemonicValidate", { enumerable: true, get: function() {
      return mnemonic_1.mnemonicValidate;
    } });
    Object.defineProperty(exports, "mnemonicToPrivateKey", { enumerable: true, get: function() {
      return mnemonic_1.mnemonicToPrivateKey;
    } });
    Object.defineProperty(exports, "mnemonicToWalletKey", { enumerable: true, get: function() {
      return mnemonic_1.mnemonicToWalletKey;
    } });
    Object.defineProperty(exports, "mnemonicToSeed", { enumerable: true, get: function() {
      return mnemonic_1.mnemonicToSeed;
    } });
    Object.defineProperty(exports, "mnemonicToHDSeed", { enumerable: true, get: function() {
      return mnemonic_1.mnemonicToHDSeed;
    } });
    var wordlist_1 = requireWordlist();
    Object.defineProperty(exports, "mnemonicWordList", { enumerable: true, get: function() {
      return wordlist_1.wordlist;
    } });
    var nacl_1 = requireNacl();
    Object.defineProperty(exports, "sealBox", { enumerable: true, get: function() {
      return nacl_1.sealBox;
    } });
    Object.defineProperty(exports, "openBox", { enumerable: true, get: function() {
      return nacl_1.openBox;
    } });
    var nacl_2 = requireNacl();
    Object.defineProperty(exports, "keyPairFromSeed", { enumerable: true, get: function() {
      return nacl_2.keyPairFromSeed;
    } });
    Object.defineProperty(exports, "keyPairFromSecretKey", { enumerable: true, get: function() {
      return nacl_2.keyPairFromSecretKey;
    } });
    Object.defineProperty(exports, "sign", { enumerable: true, get: function() {
      return nacl_2.sign;
    } });
    Object.defineProperty(exports, "signVerify", { enumerable: true, get: function() {
      return nacl_2.signVerify;
    } });
    var ed25519_1 = requireEd25519();
    Object.defineProperty(exports, "getED25519MasterKeyFromSeed", { enumerable: true, get: function() {
      return ed25519_1.getED25519MasterKeyFromSeed;
    } });
    Object.defineProperty(exports, "deriveED25519HardenedKey", { enumerable: true, get: function() {
      return ed25519_1.deriveED25519HardenedKey;
    } });
    Object.defineProperty(exports, "deriveEd25519Path", { enumerable: true, get: function() {
      return ed25519_1.deriveEd25519Path;
    } });
    var symmetric_1 = requireSymmetric();
    Object.defineProperty(exports, "getSymmetricMasterKeyFromSeed", { enumerable: true, get: function() {
      return symmetric_1.getSymmetricMasterKeyFromSeed;
    } });
    Object.defineProperty(exports, "deriveSymmetricHardenedKey", { enumerable: true, get: function() {
      return symmetric_1.deriveSymmetricHardenedKey;
    } });
    Object.defineProperty(exports, "deriveSymmetricPath", { enumerable: true, get: function() {
      return symmetric_1.deriveSymmetricPath;
    } });
    var mnemonics_1 = requireMnemonics();
    Object.defineProperty(exports, "deriveMnemonicsPath", { enumerable: true, get: function() {
      return mnemonics_1.deriveMnemonicsPath;
    } });
    Object.defineProperty(exports, "deriveMnemonicHardenedKey", { enumerable: true, get: function() {
      return mnemonics_1.deriveMnemonicHardenedKey;
    } });
    Object.defineProperty(exports, "getMnemonicsMasterKeyFromSeed", { enumerable: true, get: function() {
      return mnemonics_1.getMnemonicsMasterKeyFromSeed;
    } });
  })(dist$4);
  return dist$4;
}
var hasRequiredWonderCalculator;
function requireWonderCalculator() {
  if (hasRequiredWonderCalculator) return wonderCalculator;
  hasRequiredWonderCalculator = 1;
  Object.defineProperty(wonderCalculator, "__esModule", { value: true });
  wonderCalculator.wonderCalculator = void 0;
  const BitString_1 = requireBitString();
  const CellType_1 = requireCellType();
  const LevelMask_1 = requireLevelMask();
  const exoticPruned_1 = requireExoticPruned();
  const exoticMerkleProof_1 = requireExoticMerkleProof();
  const descriptor_1 = requireDescriptor();
  const crypto_1 = requireDist$5();
  const exoticMerkleUpdate_1 = requireExoticMerkleUpdate();
  const exoticLibrary_1 = requireExoticLibrary();
  function wonderCalculator$1(type, bits, refs) {
    let levelMask;
    let pruned = null;
    if (type === CellType_1.CellType.Ordinary) {
      let mask = 0;
      for (let r of refs) {
        mask = mask | r.mask.value;
      }
      levelMask = new LevelMask_1.LevelMask(mask);
    } else if (type === CellType_1.CellType.PrunedBranch) {
      pruned = (0, exoticPruned_1.exoticPruned)(bits, refs);
      levelMask = new LevelMask_1.LevelMask(pruned.mask);
    } else if (type === CellType_1.CellType.MerkleProof) {
      (0, exoticMerkleProof_1.exoticMerkleProof)(bits, refs);
      levelMask = new LevelMask_1.LevelMask(refs[0].mask.value >> 1);
    } else if (type === CellType_1.CellType.MerkleUpdate) {
      (0, exoticMerkleUpdate_1.exoticMerkleUpdate)(bits, refs);
      levelMask = new LevelMask_1.LevelMask((refs[0].mask.value | refs[1].mask.value) >> 1);
    } else if (type === CellType_1.CellType.Library) {
      (0, exoticLibrary_1.exoticLibrary)(bits, refs);
      levelMask = new LevelMask_1.LevelMask();
    } else {
      throw new Error("Unsupported exotic type");
    }
    let depths = [];
    let hashes = [];
    let hashCount = type === CellType_1.CellType.PrunedBranch ? 1 : levelMask.hashCount;
    let totalHashCount = levelMask.hashCount;
    let hashIOffset = totalHashCount - hashCount;
    for (let levelI = 0, hashI = 0; levelI <= levelMask.level; levelI++) {
      if (!levelMask.isSignificant(levelI)) {
        continue;
      }
      if (hashI < hashIOffset) {
        hashI++;
        continue;
      }
      let currentBits;
      if (hashI === hashIOffset) {
        if (!(levelI === 0 || type === CellType_1.CellType.PrunedBranch)) {
          throw Error("Invalid");
        }
        currentBits = bits;
      } else {
        if (!(levelI !== 0 && type !== CellType_1.CellType.PrunedBranch)) {
          throw Error("Invalid: " + levelI + ", " + type);
        }
        currentBits = new BitString_1.BitString(hashes[hashI - hashIOffset - 1], 0, 256);
      }
      let currentDepth = 0;
      for (let c of refs) {
        let childDepth;
        if (type == CellType_1.CellType.MerkleProof || type == CellType_1.CellType.MerkleUpdate) {
          childDepth = c.depth(levelI + 1);
        } else {
          childDepth = c.depth(levelI);
        }
        currentDepth = Math.max(currentDepth, childDepth);
      }
      if (refs.length > 0) {
        currentDepth++;
      }
      let repr = (0, descriptor_1.getRepr)(bits, currentBits, refs, levelI, levelMask.apply(levelI).value, type);
      let hash = (0, crypto_1.sha256_sync)(repr);
      let destI = hashI - hashIOffset;
      depths[destI] = currentDepth;
      hashes[destI] = hash;
      hashI++;
    }
    let resolvedHashes = [];
    let resolvedDepths = [];
    if (pruned) {
      for (let i = 0; i < 4; i++) {
        const { hashIndex } = levelMask.apply(i);
        const { hashIndex: thisHashIndex } = levelMask;
        if (hashIndex !== thisHashIndex) {
          resolvedHashes.push(pruned.pruned[hashIndex].hash);
          resolvedDepths.push(pruned.pruned[hashIndex].depth);
        } else {
          resolvedHashes.push(hashes[0]);
          resolvedDepths.push(depths[0]);
        }
      }
    } else {
      for (let i = 0; i < 4; i++) {
        resolvedHashes.push(hashes[levelMask.apply(i).hashIndex]);
        resolvedDepths.push(depths[levelMask.apply(i).hashIndex]);
      }
    }
    return {
      mask: levelMask,
      hashes: resolvedHashes,
      depths: resolvedDepths
    };
  }
  wonderCalculator.wonderCalculator = wonderCalculator$1;
  return wonderCalculator;
}
var serialization = {};
var topologicalSort = {};
var hasRequiredTopologicalSort;
function requireTopologicalSort() {
  if (hasRequiredTopologicalSort) return topologicalSort;
  hasRequiredTopologicalSort = 1;
  Object.defineProperty(topologicalSort, "__esModule", { value: true });
  topologicalSort.topologicalSort = void 0;
  function topologicalSort$1(src2) {
    let pending = [src2];
    let allCells = /* @__PURE__ */ new Map();
    let notPermCells = /* @__PURE__ */ new Set();
    let sorted = [];
    while (pending.length > 0) {
      const cells = [...pending];
      pending = [];
      for (let cell of cells) {
        const hash = cell.hash().toString("hex");
        if (allCells.has(hash)) {
          continue;
        }
        notPermCells.add(hash);
        allCells.set(hash, { cell, refs: cell.refs.map((v2) => v2.hash().toString("hex")) });
        for (let r of cell.refs) {
          pending.push(r);
        }
      }
    }
    let tempMark = /* @__PURE__ */ new Set();
    function visit2(hash) {
      if (!notPermCells.has(hash)) {
        return;
      }
      if (tempMark.has(hash)) {
        throw Error("Not a DAG");
      }
      tempMark.add(hash);
      let refs = allCells.get(hash).refs;
      for (let ci = refs.length - 1; ci >= 0; ci--) {
        visit2(refs[ci]);
      }
      sorted.push(hash);
      tempMark.delete(hash);
      notPermCells.delete(hash);
    }
    while (notPermCells.size > 0) {
      const id = Array.from(notPermCells)[0];
      visit2(id);
    }
    let indexes = /* @__PURE__ */ new Map();
    for (let i = 0; i < sorted.length; i++) {
      indexes.set(sorted[sorted.length - i - 1], i);
    }
    let result = [];
    for (let i = sorted.length - 1; i >= 0; i--) {
      let ent = sorted[i];
      const rrr = allCells.get(ent);
      result.push({ cell: rrr.cell, refs: rrr.refs.map((v2) => indexes.get(v2)) });
    }
    return result;
  }
  topologicalSort.topologicalSort = topologicalSort$1;
  return topologicalSort;
}
var bitsForNumber = {};
var hasRequiredBitsForNumber;
function requireBitsForNumber() {
  if (hasRequiredBitsForNumber) return bitsForNumber;
  hasRequiredBitsForNumber = 1;
  Object.defineProperty(bitsForNumber, "__esModule", { value: true });
  bitsForNumber.bitsForNumber = void 0;
  function bitsForNumber$1(src2, mode) {
    let v2 = BigInt(src2);
    if (mode === "int") {
      if (v2 === 0n || v2 === -1n) {
        return 1;
      }
      let v22 = v2 > 0 ? v2 : -v2;
      return v22.toString(2).length + 1;
    } else if (mode === "uint") {
      if (v2 < 0) {
        throw Error(`value is negative. Got ${src2}`);
      }
      return v2.toString(2).length;
    } else {
      throw Error(`invalid mode. Got ${mode}`);
    }
  }
  bitsForNumber.bitsForNumber = bitsForNumber$1;
  return bitsForNumber;
}
var crc32c = {};
var hasRequiredCrc32c;
function requireCrc32c() {
  if (hasRequiredCrc32c) return crc32c;
  hasRequiredCrc32c = 1;
  Object.defineProperty(crc32c, "__esModule", { value: true });
  crc32c.crc32c = void 0;
  const POLY = 2197175160;
  function crc32c$1(source) {
    let crc = 0 ^ 4294967295;
    for (let n = 0; n < source.length; n++) {
      crc ^= source[n];
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
    }
    crc = crc ^ 4294967295;
    let res = Buffer.alloc(4);
    res.writeInt32LE(crc);
    return res;
  }
  crc32c.crc32c = crc32c$1;
  return crc32c;
}
var hasRequiredSerialization;
function requireSerialization() {
  if (hasRequiredSerialization) return serialization;
  hasRequiredSerialization = 1;
  Object.defineProperty(serialization, "__esModule", { value: true });
  serialization.serializeBoc = serialization.deserializeBoc = serialization.parseBoc = void 0;
  const BitReader_1 = requireBitReader();
  const BitString_1 = requireBitString();
  const Cell_1 = requireCell();
  const topologicalSort_1 = requireTopologicalSort();
  const bitsForNumber_1 = requireBitsForNumber();
  const BitBuilder_1 = requireBitBuilder();
  const descriptor_1 = requireDescriptor();
  const paddedBits_1 = requirePaddedBits();
  const crc32c_1 = requireCrc32c();
  function getHashesCount(levelMask) {
    return getHashesCountFromMask(levelMask & 7);
  }
  function getHashesCountFromMask(mask) {
    let n = 0;
    for (let i = 0; i < 3; i++) {
      n += mask & 1;
      mask = mask >> 1;
    }
    return n + 1;
  }
  function readCell(reader2, sizeBytes) {
    const d1 = reader2.loadUint(8);
    const refsCount = d1 % 8;
    const exotic = !!(d1 & 8);
    const d2 = reader2.loadUint(8);
    const dataBytesize = Math.ceil(d2 / 2);
    const paddingAdded = !!(d2 % 2);
    const levelMask = d1 >> 5;
    const hasHashes = (d1 & 16) != 0;
    const hash_bytes = 32;
    const hashesSize = hasHashes ? getHashesCount(levelMask) * hash_bytes : 0;
    const depthSize = hasHashes ? getHashesCount(levelMask) * 2 : 0;
    reader2.skip(hashesSize * 8);
    reader2.skip(depthSize * 8);
    let bits = BitString_1.BitString.EMPTY;
    if (dataBytesize > 0) {
      if (paddingAdded) {
        bits = reader2.loadPaddedBits(dataBytesize * 8);
      } else {
        bits = reader2.loadBits(dataBytesize * 8);
      }
    }
    let refs = [];
    for (let i = 0; i < refsCount; i++) {
      refs.push(reader2.loadUint(sizeBytes * 8));
    }
    return {
      bits,
      refs,
      exotic
    };
  }
  function calcCellSize(cell, sizeBytes) {
    return 2 + Math.ceil(cell.bits.length / 8) + cell.refs.length * sizeBytes;
  }
  function parseBoc(src2) {
    let reader2 = new BitReader_1.BitReader(new BitString_1.BitString(src2, 0, src2.length * 8));
    let magic = reader2.loadUint(32);
    if (magic === 1761568243) {
      let size = reader2.loadUint(8);
      let offBytes = reader2.loadUint(8);
      let cells = reader2.loadUint(size * 8);
      let roots = reader2.loadUint(size * 8);
      let absent = reader2.loadUint(size * 8);
      let totalCellSize = reader2.loadUint(offBytes * 8);
      let index = reader2.loadBuffer(cells * offBytes);
      let cellData = reader2.loadBuffer(totalCellSize);
      return {
        size,
        offBytes,
        cells,
        roots,
        absent,
        totalCellSize,
        index,
        cellData,
        root: [0]
      };
    } else if (magic === 2898503464) {
      let size = reader2.loadUint(8);
      let offBytes = reader2.loadUint(8);
      let cells = reader2.loadUint(size * 8);
      let roots = reader2.loadUint(size * 8);
      let absent = reader2.loadUint(size * 8);
      let totalCellSize = reader2.loadUint(offBytes * 8);
      let index = reader2.loadBuffer(cells * offBytes);
      let cellData = reader2.loadBuffer(totalCellSize);
      let crc32 = reader2.loadBuffer(4);
      if (!(0, crc32c_1.crc32c)(src2.subarray(0, src2.length - 4)).equals(crc32)) {
        throw Error("Invalid CRC32C");
      }
      return {
        size,
        offBytes,
        cells,
        roots,
        absent,
        totalCellSize,
        index,
        cellData,
        root: [0]
      };
    } else if (magic === 3052313714) {
      let hasIdx = reader2.loadUint(1);
      let hasCrc32c = reader2.loadUint(1);
      reader2.loadUint(1);
      reader2.loadUint(2);
      let size = reader2.loadUint(3);
      let offBytes = reader2.loadUint(8);
      let cells = reader2.loadUint(size * 8);
      let roots = reader2.loadUint(size * 8);
      let absent = reader2.loadUint(size * 8);
      let totalCellSize = reader2.loadUint(offBytes * 8);
      let root = [];
      for (let i = 0; i < roots; i++) {
        root.push(reader2.loadUint(size * 8));
      }
      let index = null;
      if (hasIdx) {
        index = reader2.loadBuffer(cells * offBytes);
      }
      let cellData = reader2.loadBuffer(totalCellSize);
      if (hasCrc32c) {
        let crc32 = reader2.loadBuffer(4);
        if (!(0, crc32c_1.crc32c)(src2.subarray(0, src2.length - 4)).equals(crc32)) {
          throw Error("Invalid CRC32C");
        }
      }
      return {
        size,
        offBytes,
        cells,
        roots,
        absent,
        totalCellSize,
        index,
        cellData,
        root
      };
    } else {
      throw Error("Invalid magic");
    }
  }
  serialization.parseBoc = parseBoc;
  function deserializeBoc(src2) {
    let boc = parseBoc(src2);
    let reader2 = new BitReader_1.BitReader(new BitString_1.BitString(boc.cellData, 0, boc.cellData.length * 8));
    let cells = [];
    for (let i = 0; i < boc.cells; i++) {
      let cll = readCell(reader2, boc.size);
      cells.push({ ...cll, result: null });
    }
    for (let i = cells.length - 1; i >= 0; i--) {
      if (cells[i].result) {
        throw Error("Impossible");
      }
      let refs = [];
      for (let r of cells[i].refs) {
        if (!cells[r].result) {
          throw Error("Invalid BOC file");
        }
        refs.push(cells[r].result);
      }
      cells[i].result = new Cell_1.Cell({ bits: cells[i].bits, refs, exotic: cells[i].exotic });
    }
    let roots = [];
    for (let i = 0; i < boc.root.length; i++) {
      roots.push(cells[boc.root[i]].result);
    }
    return roots;
  }
  serialization.deserializeBoc = deserializeBoc;
  function writeCellToBuilder(cell, refs, sizeBytes, to2) {
    let d1 = (0, descriptor_1.getRefsDescriptor)(cell.refs, cell.mask.value, cell.type);
    let d2 = (0, descriptor_1.getBitsDescriptor)(cell.bits);
    to2.writeUint(d1, 8);
    to2.writeUint(d2, 8);
    to2.writeBuffer((0, paddedBits_1.bitsToPaddedBuffer)(cell.bits));
    for (let r of refs) {
      to2.writeUint(r, sizeBytes * 8);
    }
  }
  function serializeBoc(root, opts) {
    let allCells = (0, topologicalSort_1.topologicalSort)(root);
    let cellsNum = allCells.length;
    let has_idx = opts.idx;
    let has_crc32c = opts.crc32;
    let has_cache_bits = false;
    let flags = 0;
    let sizeBytes = Math.max(Math.ceil((0, bitsForNumber_1.bitsForNumber)(cellsNum, "uint") / 8), 1);
    let totalCellSize = 0;
    let index = [];
    for (let c of allCells) {
      let sz = calcCellSize(c.cell, sizeBytes);
      totalCellSize += sz;
      index.push(totalCellSize);
    }
    let offsetBytes = Math.max(Math.ceil((0, bitsForNumber_1.bitsForNumber)(totalCellSize, "uint") / 8), 1);
    let totalSize = (4 + // magic
    1 + // flags and s_bytes
    1 + // offset_bytes
    3 * sizeBytes + // cells_num, roots, complete
    offsetBytes + // full_size
    1 * sizeBytes + // root_idx
    (has_idx ? cellsNum * offsetBytes : 0) + totalCellSize + (has_crc32c ? 4 : 0)) * 8;
    let builder2 = new BitBuilder_1.BitBuilder(totalSize);
    builder2.writeUint(3052313714, 32);
    builder2.writeBit(has_idx);
    builder2.writeBit(has_crc32c);
    builder2.writeBit(has_cache_bits);
    builder2.writeUint(flags, 2);
    builder2.writeUint(sizeBytes, 3);
    builder2.writeUint(offsetBytes, 8);
    builder2.writeUint(cellsNum, sizeBytes * 8);
    builder2.writeUint(1, sizeBytes * 8);
    builder2.writeUint(0, sizeBytes * 8);
    builder2.writeUint(totalCellSize, offsetBytes * 8);
    builder2.writeUint(0, sizeBytes * 8);
    if (has_idx) {
      for (let i = 0; i < cellsNum; i++) {
        builder2.writeUint(index[i], offsetBytes * 8);
      }
    }
    for (let i = 0; i < cellsNum; i++) {
      writeCellToBuilder(allCells[i].cell, allCells[i].refs, sizeBytes, builder2);
    }
    if (has_crc32c) {
      let crc32 = (0, crc32c_1.crc32c)(builder2.buffer());
      builder2.writeBuffer(crc32);
    }
    let res = builder2.buffer();
    if (res.length !== totalSize / 8) {
      throw Error("Internal error");
    }
    return res;
  }
  serialization.serializeBoc = serializeBoc;
  return serialization;
}
var hasRequiredCell;
function requireCell() {
  if (hasRequiredCell) return Cell;
  hasRequiredCell = 1;
  var __importDefault = Cell && Cell.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  var _a2;
  Object.defineProperty(Cell, "__esModule", { value: true });
  Cell.Cell = void 0;
  const symbol_inspect_1 = __importDefault(requireSymbol_inspect());
  const BitString_1 = requireBitString();
  const CellType_1 = requireCellType();
  const Slice_1 = requireSlice();
  const resolveExotic_1 = requireResolveExotic();
  const wonderCalculator_1 = requireWonderCalculator();
  const serialization_1 = requireSerialization();
  const BitReader_1 = requireBitReader();
  const Builder_12 = requireBuilder$1();
  let Cell$1 = class Cell2 {
    /**
     * Deserialize cells from BOC
     * @param src source buffer
     * @returns array of cells
     */
    static fromBoc(src2) {
      return (0, serialization_1.deserializeBoc)(src2);
    }
    /**
     * Helper function that deserializes a single cell from BOC in base64
     * @param src source string
     */
    static fromBase64(src2) {
      let parsed = Cell2.fromBoc(Buffer.from(src2, "base64"));
      if (parsed.length !== 1) {
        throw new Error("Deserialized more than one cell");
      }
      return parsed[0];
    }
    /**
     * Helper function that deserializes a single cell from BOC in hex
     * @param src source string
     */
    static fromHex(src2) {
      let parsed = Cell2.fromBoc(Buffer.from(src2, "hex"));
      if (parsed.length !== 1) {
        throw new Error("Deserialized more than one cell");
      }
      return parsed[0];
    }
    constructor(opts) {
      this._hashes = [];
      this._depths = [];
      this.beginParse = (allowExotic = false) => {
        if (this.isExotic && !allowExotic) {
          throw new Error("Exotic cells cannot be parsed");
        }
        return new Slice_1.Slice(new BitReader_1.BitReader(this.bits), this.refs);
      };
      this.hash = (level = 3) => {
        return this._hashes[Math.min(this._hashes.length - 1, level)];
      };
      this.depth = (level = 3) => {
        return this._depths[Math.min(this._depths.length - 1, level)];
      };
      this.level = () => {
        return this.mask.level;
      };
      this.equals = (other) => {
        return this.hash().equals(other.hash());
      };
      this[_a2] = () => this.toString();
      let bits = BitString_1.BitString.EMPTY;
      if (opts && opts.bits) {
        bits = opts.bits;
      }
      let refs = [];
      if (opts && opts.refs) {
        refs = [...opts.refs];
      }
      let hashes;
      let depths;
      let mask;
      let type = CellType_1.CellType.Ordinary;
      if (opts && opts.exotic) {
        let resolved = (0, resolveExotic_1.resolveExotic)(bits, refs);
        let wonders = (0, wonderCalculator_1.wonderCalculator)(resolved.type, bits, refs);
        mask = wonders.mask;
        depths = wonders.depths;
        hashes = wonders.hashes;
        type = resolved.type;
      } else {
        if (refs.length > 4) {
          throw new Error("Invalid number of references");
        }
        if (bits.length > 1023) {
          throw new Error(`Bits overflow: ${bits.length} > 1023`);
        }
        let wonders = (0, wonderCalculator_1.wonderCalculator)(CellType_1.CellType.Ordinary, bits, refs);
        mask = wonders.mask;
        depths = wonders.depths;
        hashes = wonders.hashes;
        type = CellType_1.CellType.Ordinary;
      }
      this.type = type;
      this.bits = bits;
      this.refs = refs;
      this.mask = mask;
      this._depths = depths;
      this._hashes = hashes;
      Object.freeze(this);
      Object.freeze(this.refs);
      Object.freeze(this.bits);
      Object.freeze(this.mask);
      Object.freeze(this._depths);
      Object.freeze(this._hashes);
    }
    /**
     * Check if cell is exotic
     */
    get isExotic() {
      return this.type !== CellType_1.CellType.Ordinary;
    }
    /**
     * Serializes cell to BOC
     * @param opts options
     */
    toBoc(opts) {
      let idx = opts && opts.idx !== null && opts.idx !== void 0 ? opts.idx : false;
      let crc32 = opts && opts.crc32 !== null && opts.crc32 !== void 0 ? opts.crc32 : true;
      return (0, serialization_1.serializeBoc)(this, { idx, crc32 });
    }
    /**
     * Format cell to string
     * @param indent indentation
     * @returns string representation
     */
    toString(indent) {
      let id = indent || "";
      let t = "x";
      if (this.isExotic) {
        if (this.type === CellType_1.CellType.MerkleProof) {
          t = "p";
        } else if (this.type === CellType_1.CellType.MerkleUpdate) {
          t = "u";
        } else if (this.type === CellType_1.CellType.PrunedBranch) {
          t = "p";
        }
      }
      let s2 = id + (this.isExotic ? t : "x") + "{" + this.bits.toString() + "}";
      for (let k2 in this.refs) {
        const i = this.refs[k2];
        s2 += "\n" + i.toString(id + " ");
      }
      return s2;
    }
    /**
     * Covnert cell to slice
     * @returns slice
     */
    asSlice() {
      return this.beginParse();
    }
    /**
     * Convert cell to a builder that has this cell stored
     * @returns builder
     */
    asBuilder() {
      return (0, Builder_12.beginCell)().storeSlice(this.asSlice());
    }
  };
  Cell.Cell = Cell$1;
  _a2 = symbol_inspect_1.default;
  Cell$1.EMPTY = new Cell$1();
  return Cell;
}
var hasRequiredBuilder$1;
function requireBuilder$1() {
  if (hasRequiredBuilder$1) return Builder$3;
  hasRequiredBuilder$1 = 1;
  Object.defineProperty(Builder$3, "__esModule", { value: true });
  Builder$3.Builder = Builder$3.beginCell = void 0;
  const BitBuilder_1 = requireBitBuilder();
  const Cell_1 = requireCell();
  const strings_1 = requireStrings();
  function beginCell() {
    return new Builder2();
  }
  Builder$3.beginCell = beginCell;
  class Builder2 {
    constructor() {
      this._bits = new BitBuilder_1.BitBuilder();
      this._refs = [];
    }
    /**
     * Bits written so far
     */
    get bits() {
      return this._bits.length;
    }
    /**
     * References written so far
     */
    get refs() {
      return this._refs.length;
    }
    /**
     * Available bits
     */
    get availableBits() {
      return 1023 - this.bits;
    }
    /**
     * Available references
     */
    get availableRefs() {
      return 4 - this.refs;
    }
    /**
     * Write a single bit
     * @param value bit to write, true or positive number for 1, false or zero or negative for 0
     * @returns this builder
     */
    storeBit(value) {
      this._bits.writeBit(value);
      return this;
    }
    /**
     * Write bits from BitString
     * @param src source bits
     * @returns this builder
     */
    storeBits(src2) {
      this._bits.writeBits(src2);
      return this;
    }
    /**
     * Store Buffer
     * @param src source buffer
     * @param bytes optional number of bytes to write
     * @returns this builder
     */
    storeBuffer(src2, bytes) {
      if (bytes !== void 0 && bytes !== null) {
        if (src2.length !== bytes) {
          throw Error(`Buffer length ${src2.length} is not equal to ${bytes}`);
        }
      }
      this._bits.writeBuffer(src2);
      return this;
    }
    /**
     * Store Maybe Buffer
     * @param src source buffer or null
     * @param bytes optional number of bytes to write
     * @returns this builder
     */
    storeMaybeBuffer(src2, bytes) {
      if (src2 !== null) {
        this.storeBit(1);
        this.storeBuffer(src2, bytes);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store uint value
     * @param value value as bigint or number
     * @param bits number of bits to write
     * @returns this builder
     */
    storeUint(value, bits) {
      this._bits.writeUint(value, bits);
      return this;
    }
    /**
     * Store maybe uint value
     * @param value value as bigint or number, null or undefined
     * @param bits number of bits to write
     * @returns this builder
     */
    storeMaybeUint(value, bits) {
      if (value !== null && value !== void 0) {
        this.storeBit(1);
        this.storeUint(value, bits);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store int value
     * @param value value as bigint or number
     * @param bits number of bits to write
     * @returns this builder
     */
    storeInt(value, bits) {
      this._bits.writeInt(value, bits);
      return this;
    }
    /**
     * Store maybe int value
     * @param value value as bigint or number, null or undefined
     * @param bits number of bits to write
     * @returns this builder
     */
    storeMaybeInt(value, bits) {
      if (value !== null && value !== void 0) {
        this.storeBit(1);
        this.storeInt(value, bits);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store varuint value
     * @param value value as bigint or number
     * @param bits number of bits to write to header
     * @returns this builder
     */
    storeVarUint(value, bits) {
      this._bits.writeVarUint(value, bits);
      return this;
    }
    /**
     * Store maybe varuint value
     * @param value value as bigint or number, null or undefined
     * @param bits number of bits to write to header
     * @returns this builder
     */
    storeMaybeVarUint(value, bits) {
      if (value !== null && value !== void 0) {
        this.storeBit(1);
        this.storeVarUint(value, bits);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store varint value
     * @param value value as bigint or number
     * @param bits number of bits to write to header
     * @returns this builder
     */
    storeVarInt(value, bits) {
      this._bits.writeVarInt(value, bits);
      return this;
    }
    /**
     * Store maybe varint value
     * @param value value as bigint or number, null or undefined
     * @param bits number of bits to write to header
     * @returns this builder
     */
    storeMaybeVarInt(value, bits) {
      if (value !== null && value !== void 0) {
        this.storeBit(1);
        this.storeVarInt(value, bits);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store coins value
     * @param amount amount of coins
     * @returns this builder
     */
    storeCoins(amount) {
      this._bits.writeCoins(amount);
      return this;
    }
    /**
     * Store maybe coins value
     * @param amount amount of coins, null or undefined
     * @returns this builder
     */
    storeMaybeCoins(amount) {
      if (amount !== null && amount !== void 0) {
        this.storeBit(1);
        this.storeCoins(amount);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store address
     * @param addres address to store
     * @returns this builder
     */
    storeAddress(address) {
      this._bits.writeAddress(address);
      return this;
    }
    /**
     * Store reference
     * @param cell cell or builder to store
     * @returns this builder
     */
    storeRef(cell) {
      if (this._refs.length >= 4) {
        throw new Error("Too many references");
      }
      if (cell instanceof Cell_1.Cell) {
        this._refs.push(cell);
      } else if (cell instanceof Builder2) {
        this._refs.push(cell.endCell());
      } else {
        throw new Error("Invalid argument");
      }
      return this;
    }
    /**
     * Store reference if not null
     * @param cell cell or builder to store
     * @returns this builder
     */
    storeMaybeRef(cell) {
      if (cell) {
        this.storeBit(1);
        this.storeRef(cell);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store slice it in this builder
     * @param src source slice
     */
    storeSlice(src2) {
      let c = src2.clone();
      if (c.remainingBits > 0) {
        this.storeBits(c.loadBits(c.remainingBits));
      }
      while (c.remainingRefs > 0) {
        this.storeRef(c.loadRef());
      }
      return this;
    }
    /**
     * Store slice in this builder if not null
     * @param src source slice
     */
    storeMaybeSlice(src2) {
      if (src2) {
        this.storeBit(1);
        this.storeSlice(src2);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store builder
     * @param src builder to store
     * @returns this builder
     */
    storeBuilder(src2) {
      return this.storeSlice(src2.endCell().beginParse());
    }
    /**
     * Store builder if not null
     * @param src builder to store
     * @returns this builder
     */
    storeMaybeBuilder(src2) {
      if (src2) {
        this.storeBit(1);
        this.storeBuilder(src2);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store writer or builder
     * @param writer writer or builder to store
     * @returns this builder
     */
    storeWritable(writer) {
      if (typeof writer === "object") {
        writer.writeTo(this);
      } else {
        writer(this);
      }
      return this;
    }
    /**
     * Store writer or builder if not null
     * @param writer writer or builder to store
     * @returns this builder
     */
    storeMaybeWritable(writer) {
      if (writer) {
        this.storeBit(1);
        this.storeWritable(writer);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store object in this builder
     * @param writer Writable or writer functuin
     */
    store(writer) {
      this.storeWritable(writer);
      return this;
    }
    /**
     * Store string tail
     * @param src source string
     * @returns this builder
     */
    storeStringTail(src2) {
      (0, strings_1.writeString)(src2, this);
      return this;
    }
    /**
     * Store string tail
     * @param src source string
     * @returns this builder
     */
    storeMaybeStringTail(src2) {
      if (src2 !== null && src2 !== void 0) {
        this.storeBit(1);
        (0, strings_1.writeString)(src2, this);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store string tail in ref
     * @param src source string
     * @returns this builder
     */
    storeStringRefTail(src2) {
      this.storeRef(beginCell().storeStringTail(src2));
      return this;
    }
    /**
     * Store maybe string tail in ref
     * @param src source string
     * @returns this builder
     */
    storeMaybeStringRefTail(src2) {
      if (src2 !== null && src2 !== void 0) {
        this.storeBit(1);
        this.storeStringRefTail(src2);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store dictionary in this builder
     * @param dict dictionary to store
     * @returns this builder
     */
    storeDict(dict, key2, value) {
      if (dict) {
        dict.store(this, key2, value);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store dictionary in this builder directly
     * @param dict dictionary to store
     * @returns this builder
     */
    storeDictDirect(dict, key2, value) {
      dict.storeDirect(this, key2, value);
      return this;
    }
    /**
     * Complete cell
     * @param opts options
     * @returns cell
     */
    endCell(opts) {
      return new Cell_1.Cell({
        bits: this._bits.build(),
        refs: this._refs,
        exotic: opts?.exotic
      });
    }
    /**
     * Convert to cell
     * @returns cell
     */
    asCell() {
      return this.endCell();
    }
    /**
     * Convert to slice
     * @returns slice
     */
    asSlice() {
      return this.endCell().beginParse();
    }
  }
  Builder$3.Builder = Builder2;
  return Builder$3;
}
var StateInit = {};
var SimpleLibrary = {};
var hasRequiredSimpleLibrary;
function requireSimpleLibrary() {
  if (hasRequiredSimpleLibrary) return SimpleLibrary;
  hasRequiredSimpleLibrary = 1;
  Object.defineProperty(SimpleLibrary, "__esModule", { value: true });
  SimpleLibrary.SimpleLibraryValue = SimpleLibrary.storeSimpleLibrary = SimpleLibrary.loadSimpleLibrary = void 0;
  function loadSimpleLibrary(slice) {
    return {
      public: slice.loadBit(),
      root: slice.loadRef()
    };
  }
  SimpleLibrary.loadSimpleLibrary = loadSimpleLibrary;
  function storeSimpleLibrary(src2) {
    return (builder2) => {
      builder2.storeBit(src2.public);
      builder2.storeRef(src2.root);
    };
  }
  SimpleLibrary.storeSimpleLibrary = storeSimpleLibrary;
  SimpleLibrary.SimpleLibraryValue = {
    serialize(src2, builder2) {
      storeSimpleLibrary(src2)(builder2);
    },
    parse(src2) {
      return loadSimpleLibrary(src2);
    }
  };
  return SimpleLibrary;
}
var TickTock = {};
var hasRequiredTickTock;
function requireTickTock() {
  if (hasRequiredTickTock) return TickTock;
  hasRequiredTickTock = 1;
  Object.defineProperty(TickTock, "__esModule", { value: true });
  TickTock.storeTickTock = TickTock.loadTickTock = void 0;
  function loadTickTock(slice) {
    return {
      tick: slice.loadBit(),
      tock: slice.loadBit()
    };
  }
  TickTock.loadTickTock = loadTickTock;
  function storeTickTock(src2) {
    return (builder2) => {
      builder2.storeBit(src2.tick);
      builder2.storeBit(src2.tock);
    };
  }
  TickTock.storeTickTock = storeTickTock;
  return TickTock;
}
var hasRequiredStateInit;
function requireStateInit() {
  if (hasRequiredStateInit) return StateInit;
  hasRequiredStateInit = 1;
  Object.defineProperty(StateInit, "__esModule", { value: true });
  StateInit.storeStateInit = StateInit.loadStateInit = void 0;
  const Dictionary_1 = requireDictionary();
  const SimpleLibrary_1 = requireSimpleLibrary();
  const TickTock_1 = requireTickTock();
  function loadStateInit(slice) {
    let splitDepth;
    if (slice.loadBit()) {
      splitDepth = slice.loadUint(5);
    }
    let special;
    if (slice.loadBit()) {
      special = (0, TickTock_1.loadTickTock)(slice);
    }
    let code = slice.loadMaybeRef();
    let data = slice.loadMaybeRef();
    let libraries = slice.loadDict(Dictionary_1.Dictionary.Keys.BigUint(256), SimpleLibrary_1.SimpleLibraryValue);
    if (libraries.size === 0) {
      libraries = void 0;
    }
    return {
      splitDepth,
      special,
      code,
      data,
      libraries
    };
  }
  StateInit.loadStateInit = loadStateInit;
  function storeStateInit(src2) {
    return (builder2) => {
      if (src2.splitDepth !== null && src2.splitDepth !== void 0) {
        builder2.storeBit(true);
        builder2.storeUint(src2.splitDepth, 5);
      } else {
        builder2.storeBit(false);
      }
      if (src2.special !== null && src2.special !== void 0) {
        builder2.storeBit(true);
        builder2.store((0, TickTock_1.storeTickTock)(src2.special));
      } else {
        builder2.storeBit(false);
      }
      builder2.storeMaybeRef(src2.code);
      builder2.storeMaybeRef(src2.data);
      builder2.storeDict(src2.libraries);
    };
  }
  StateInit.storeStateInit = storeStateInit;
  return StateInit;
}
var hasRequiredContractAddress;
function requireContractAddress() {
  if (hasRequiredContractAddress) return contractAddress;
  hasRequiredContractAddress = 1;
  Object.defineProperty(contractAddress, "__esModule", { value: true });
  contractAddress.contractAddress = void 0;
  const Builder_12 = requireBuilder$1();
  const StateInit_1 = requireStateInit();
  const Address_1 = requireAddress();
  function contractAddress$1(workchain, init) {
    let hash = (0, Builder_12.beginCell)().store((0, StateInit_1.storeStateInit)(init)).endCell().hash();
    return new Address_1.Address(workchain, hash);
  }
  contractAddress.contractAddress = contractAddress$1;
  return contractAddress;
}
var tuple = {};
var hasRequiredTuple;
function requireTuple() {
  if (hasRequiredTuple) return tuple;
  hasRequiredTuple = 1;
  Object.defineProperty(tuple, "__esModule", { value: true });
  tuple.parseTuple = tuple.serializeTuple = void 0;
  const Builder_12 = requireBuilder$1();
  const INT64_MIN = BigInt("-9223372036854775808");
  const INT64_MAX = BigInt("9223372036854775807");
  function serializeTupleItem(src2, builder2) {
    if (src2.type === "null") {
      builder2.storeUint(0, 8);
    } else if (src2.type === "int") {
      if (src2.value <= INT64_MAX && src2.value >= INT64_MIN) {
        builder2.storeUint(1, 8);
        builder2.storeInt(src2.value, 64);
      } else {
        builder2.storeUint(256, 15);
        builder2.storeInt(src2.value, 257);
      }
    } else if (src2.type === "nan") {
      builder2.storeInt(767, 16);
    } else if (src2.type === "cell") {
      builder2.storeUint(3, 8);
      builder2.storeRef(src2.cell);
    } else if (src2.type === "slice") {
      builder2.storeUint(4, 8);
      builder2.storeUint(0, 10);
      builder2.storeUint(src2.cell.bits.length, 10);
      builder2.storeUint(0, 3);
      builder2.storeUint(src2.cell.refs.length, 3);
      builder2.storeRef(src2.cell);
    } else if (src2.type === "builder") {
      builder2.storeUint(5, 8);
      builder2.storeRef(src2.cell);
    } else if (src2.type === "tuple") {
      let head = null;
      let tail = null;
      for (let i = 0; i < src2.items.length; i++) {
        let s2 = head;
        head = tail;
        tail = s2;
        if (i > 1) {
          head = (0, Builder_12.beginCell)().storeRef(tail).storeRef(head).endCell();
        }
        let bc = (0, Builder_12.beginCell)();
        serializeTupleItem(src2.items[i], bc);
        tail = bc.endCell();
      }
      builder2.storeUint(7, 8);
      builder2.storeUint(src2.items.length, 16);
      if (head) {
        builder2.storeRef(head);
      }
      if (tail) {
        builder2.storeRef(tail);
      }
    } else {
      throw Error("Invalid value");
    }
  }
  function parseStackItem2(cs) {
    let kind = cs.loadUint(8);
    if (kind === 0) {
      return { type: "null" };
    } else if (kind === 1) {
      return { type: "int", value: cs.loadIntBig(64) };
    } else if (kind === 2) {
      if (cs.loadUint(7) === 0) {
        return { type: "int", value: cs.loadIntBig(257) };
      } else {
        cs.loadBit();
        return { type: "nan" };
      }
    } else if (kind === 3) {
      return { type: "cell", cell: cs.loadRef() };
    } else if (kind === 4) {
      let startBits = cs.loadUint(10);
      let endBits = cs.loadUint(10);
      let startRefs = cs.loadUint(3);
      let endRefs = cs.loadUint(3);
      let rs = cs.loadRef().beginParse();
      rs.skip(startBits);
      let dt2 = rs.loadBits(endBits - startBits);
      let builder2 = (0, Builder_12.beginCell)().storeBits(dt2);
      if (startRefs < endRefs) {
        for (let i = 0; i < startRefs; i++) {
          rs.loadRef();
        }
        for (let i = 0; i < endRefs - startRefs; i++) {
          builder2.storeRef(rs.loadRef());
        }
      }
      return { type: "slice", cell: builder2.endCell() };
    } else if (kind === 5) {
      return { type: "builder", cell: cs.loadRef() };
    } else if (kind === 7) {
      let length = cs.loadUint(16);
      let items = [];
      if (length > 1) {
        let head = cs.loadRef().beginParse();
        let tail = cs.loadRef().beginParse();
        items.unshift(parseStackItem2(tail));
        for (let i = 0; i < length - 2; i++) {
          let ohead = head;
          head = ohead.loadRef().beginParse();
          tail = ohead.loadRef().beginParse();
          items.unshift(parseStackItem2(tail));
        }
        items.unshift(parseStackItem2(head));
      } else if (length === 1) {
        items.push(parseStackItem2(cs.loadRef().beginParse()));
      }
      return { type: "tuple", items };
    } else {
      throw Error("Unsupported stack item");
    }
  }
  function serializeTupleTail(src2, builder2) {
    if (src2.length > 0) {
      let tail = (0, Builder_12.beginCell)();
      serializeTupleTail(src2.slice(0, src2.length - 1), tail);
      builder2.storeRef(tail.endCell());
      serializeTupleItem(src2[src2.length - 1], builder2);
    }
  }
  function serializeTuple(src2) {
    let builder2 = (0, Builder_12.beginCell)();
    builder2.storeUint(src2.length, 24);
    let r = [...src2];
    serializeTupleTail(r, builder2);
    return builder2.endCell();
  }
  tuple.serializeTuple = serializeTuple;
  function parseTuple(src2) {
    let res = [];
    let cs = src2.beginParse();
    let size = cs.loadUint(24);
    for (let i = 0; i < size; i++) {
      let next = cs.loadRef();
      res.unshift(parseStackItem2(cs));
      cs = next.beginParse();
    }
    return res;
  }
  tuple.parseTuple = parseTuple;
  return tuple;
}
var reader = {};
var hasRequiredReader;
function requireReader() {
  if (hasRequiredReader) return reader;
  hasRequiredReader = 1;
  Object.defineProperty(reader, "__esModule", { value: true });
  reader.TupleReader = void 0;
  class TupleReader {
    constructor(items) {
      this.items = [...items];
    }
    get remaining() {
      return this.items.length;
    }
    peek() {
      if (this.items.length === 0) {
        throw Error("EOF");
      }
      return this.items[0];
    }
    pop() {
      if (this.items.length === 0) {
        throw Error("EOF");
      }
      let res = this.items[0];
      this.items.splice(0, 1);
      return res;
    }
    skip(num = 1) {
      for (let i = 0; i < num; i++) {
        this.pop();
      }
      return this;
    }
    readBigNumber() {
      let popped = this.pop();
      if (popped.type !== "int") {
        throw Error("Not a number");
      }
      return popped.value;
    }
    readBigNumberOpt() {
      let popped = this.pop();
      if (popped.type === "null") {
        return null;
      }
      if (popped.type !== "int") {
        throw Error("Not a number");
      }
      return popped.value;
    }
    readNumber() {
      return Number(this.readBigNumber());
    }
    readNumberOpt() {
      let r = this.readBigNumberOpt();
      if (r !== null) {
        return Number(r);
      } else {
        return null;
      }
    }
    readBoolean() {
      let res = this.readNumber();
      return res === 0 ? false : true;
    }
    readBooleanOpt() {
      let res = this.readNumberOpt();
      if (res !== null) {
        return res === 0 ? false : true;
      } else {
        return null;
      }
    }
    readAddress() {
      let r = this.readCell().beginParse().loadAddress();
      if (r !== null) {
        return r;
      } else {
        throw Error("Not an address");
      }
    }
    readAddressOpt() {
      let r = this.readCellOpt();
      if (r !== null) {
        return r.beginParse().loadMaybeAddress();
      } else {
        return null;
      }
    }
    readCell() {
      let popped = this.pop();
      if (popped.type !== "cell" && popped.type !== "slice" && popped.type !== "builder") {
        throw Error("Not a cell: " + popped.type);
      }
      return popped.cell;
    }
    readCellOpt() {
      let popped = this.pop();
      if (popped.type === "null") {
        return null;
      }
      if (popped.type !== "cell" && popped.type !== "slice" && popped.type !== "builder") {
        throw Error("Not a cell");
      }
      return popped.cell;
    }
    readTuple() {
      let popped = this.pop();
      if (popped.type !== "tuple") {
        throw Error("Not a tuple");
      }
      return new TupleReader(popped.items);
    }
    readTupleOpt() {
      let popped = this.pop();
      if (popped.type === "null") {
        return null;
      }
      if (popped.type !== "tuple") {
        throw Error("Not a tuple");
      }
      return new TupleReader(popped.items);
    }
    static readLispList(reader2) {
      const result = [];
      let tail = reader2;
      while (tail !== null) {
        var head = tail.pop();
        if (tail.items.length === 0 || tail.items[0].type !== "tuple" && tail.items[0].type !== "null") {
          throw Error("Lisp list consists only from (any, tuple) elements and ends with null");
        }
        tail = tail.readTupleOpt();
        result.push(head);
      }
      return result;
    }
    readLispListDirect() {
      if (this.items.length === 1 && this.items[0].type === "null") {
        return [];
      }
      return TupleReader.readLispList(this);
    }
    readLispList() {
      return TupleReader.readLispList(this.readTupleOpt());
    }
    readBuffer() {
      let s2 = this.readCell().beginParse();
      if (s2.remainingRefs !== 0) {
        throw Error("Not a buffer");
      }
      if (s2.remainingBits % 8 !== 0) {
        throw Error("Not a buffer");
      }
      return s2.loadBuffer(s2.remainingBits / 8);
    }
    readBufferOpt() {
      let r = this.readCellOpt();
      if (r !== null) {
        let s2 = r.beginParse();
        if (s2.remainingRefs !== 0 || s2.remainingBits % 8 !== 0) {
          throw Error("Not a buffer");
        }
        return s2.loadBuffer(s2.remainingBits / 8);
      } else {
        return null;
      }
    }
    readString() {
      let s2 = this.readCell().beginParse();
      return s2.loadStringTail();
    }
    readStringOpt() {
      let r = this.readCellOpt();
      if (r !== null) {
        let s2 = r.beginParse();
        return s2.loadStringTail();
      } else {
        return null;
      }
    }
  }
  reader.TupleReader = TupleReader;
  return reader;
}
var builder = {};
var hasRequiredBuilder;
function requireBuilder() {
  if (hasRequiredBuilder) return builder;
  hasRequiredBuilder = 1;
  Object.defineProperty(builder, "__esModule", { value: true });
  builder.TupleBuilder = void 0;
  const Builder_12 = requireBuilder$1();
  const Cell_1 = requireCell();
  const Slice_1 = requireSlice();
  class TupleBuilder {
    constructor() {
      this._tuple = [];
    }
    writeNumber(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        this._tuple.push({ type: "int", value: BigInt(v2) });
      }
    }
    writeBoolean(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        this._tuple.push({ type: "int", value: v2 ? -1n : 0n });
      }
    }
    writeBuffer(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        this._tuple.push({ type: "slice", cell: (0, Builder_12.beginCell)().storeBuffer(v2).endCell() });
      }
    }
    writeString(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        this._tuple.push({ type: "slice", cell: (0, Builder_12.beginCell)().storeStringTail(v2).endCell() });
      }
    }
    writeCell(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        if (v2 instanceof Cell_1.Cell) {
          this._tuple.push({ type: "cell", cell: v2 });
        } else if (v2 instanceof Slice_1.Slice) {
          this._tuple.push({ type: "cell", cell: v2.asCell() });
        }
      }
    }
    writeSlice(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        if (v2 instanceof Cell_1.Cell) {
          this._tuple.push({ type: "slice", cell: v2 });
        } else if (v2 instanceof Slice_1.Slice) {
          this._tuple.push({ type: "slice", cell: v2.asCell() });
        }
      }
    }
    writeBuilder(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        if (v2 instanceof Cell_1.Cell) {
          this._tuple.push({ type: "builder", cell: v2 });
        } else if (v2 instanceof Slice_1.Slice) {
          this._tuple.push({ type: "builder", cell: v2.asCell() });
        }
      }
    }
    writeTuple(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        this._tuple.push({ type: "tuple", items: v2 });
      }
    }
    writeAddress(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        this._tuple.push({ type: "slice", cell: (0, Builder_12.beginCell)().storeAddress(v2).endCell() });
      }
    }
    build() {
      return [...this._tuple];
    }
  }
  builder.TupleBuilder = TupleBuilder;
  return builder;
}
var _export = {};
var _helpers = {};
var convert = {};
var hasRequiredConvert;
function requireConvert() {
  if (hasRequiredConvert) return convert;
  hasRequiredConvert = 1;
  Object.defineProperty(convert, "__esModule", { value: true });
  convert.fromNano = convert.toNano = void 0;
  function toNano(src2) {
    if (typeof src2 === "bigint") {
      return src2 * 1000000000n;
    } else {
      if (typeof src2 === "number") {
        if (!Number.isFinite(src2)) {
          throw Error("Invalid number");
        }
        if (Math.log10(src2) <= 6) {
          src2 = src2.toLocaleString("en", { minimumFractionDigits: 9, useGrouping: false });
        } else if (src2 - Math.trunc(src2) === 0) {
          src2 = src2.toLocaleString("en", { maximumFractionDigits: 0, useGrouping: false });
        } else {
          throw Error("Not enough precision for a number value. Use string value instead");
        }
      }
      let neg = false;
      while (src2.startsWith("-")) {
        neg = !neg;
        src2 = src2.slice(1);
      }
      if (src2 === ".") {
        throw Error("Invalid number");
      }
      let parts = src2.split(".");
      if (parts.length > 2) {
        throw Error("Invalid number");
      }
      let whole = parts[0];
      let frac = parts[1];
      if (!whole) {
        whole = "0";
      }
      if (!frac) {
        frac = "0";
      }
      if (frac.length > 9) {
        throw Error("Invalid number");
      }
      while (frac.length < 9) {
        frac += "0";
      }
      let r = BigInt(whole) * 1000000000n + BigInt(frac);
      if (neg) {
        r = -r;
      }
      return r;
    }
  }
  convert.toNano = toNano;
  function fromNano(src2) {
    let v2 = BigInt(src2);
    let neg = false;
    if (v2 < 0) {
      neg = true;
      v2 = -v2;
    }
    let frac = v2 % 1000000000n;
    let facStr = frac.toString();
    while (facStr.length < 9) {
      facStr = "0" + facStr;
    }
    facStr = facStr.match(/^([0-9]*[1-9]|0)(0*)/)[1];
    let whole = v2 / 1000000000n;
    let wholeStr = whole.toString();
    let value = `${wholeStr}${facStr === "0" ? "" : `.${facStr}`}`;
    if (neg) {
      value = "-" + value;
    }
    return value;
  }
  convert.fromNano = fromNano;
  return convert;
}
var ExtraCurrency = {};
var hasRequiredExtraCurrency;
function requireExtraCurrency() {
  if (hasRequiredExtraCurrency) return ExtraCurrency;
  hasRequiredExtraCurrency = 1;
  Object.defineProperty(ExtraCurrency, "__esModule", { value: true });
  ExtraCurrency.packExtraCurrencyCell = ExtraCurrency.packExtraCurrencyDict = ExtraCurrency.storeExtraCurrency = ExtraCurrency.loadMaybeExtraCurrency = ExtraCurrency.loadExtraCurrency = void 0;
  const Builder_12 = requireBuilder$1();
  const Dictionary_1 = requireDictionary();
  function loadExtraCurrency(data) {
    let ecDict = data instanceof Dictionary_1.Dictionary ? data : Dictionary_1.Dictionary.loadDirect(Dictionary_1.Dictionary.Keys.Uint(32), Dictionary_1.Dictionary.Values.BigVarUint(5), data);
    let ecMap = {};
    for (let [k2, v2] of ecDict) {
      ecMap[k2] = v2;
    }
    return ecMap;
  }
  ExtraCurrency.loadExtraCurrency = loadExtraCurrency;
  function loadMaybeExtraCurrency(data) {
    const ecData = data.loadMaybeRef();
    return ecData === null ? ecData : loadExtraCurrency(ecData);
  }
  ExtraCurrency.loadMaybeExtraCurrency = loadMaybeExtraCurrency;
  function storeExtraCurrency(extracurrency) {
    return (builder2) => {
      builder2.storeDict(packExtraCurrencyDict(extracurrency));
    };
  }
  ExtraCurrency.storeExtraCurrency = storeExtraCurrency;
  function packExtraCurrencyDict(extracurrency) {
    const resEc = Dictionary_1.Dictionary.empty(Dictionary_1.Dictionary.Keys.Uint(32), Dictionary_1.Dictionary.Values.BigVarUint(5));
    Object.entries(extracurrency).map(([k2, v2]) => resEc.set(Number(k2), v2));
    return resEc;
  }
  ExtraCurrency.packExtraCurrencyDict = packExtraCurrencyDict;
  function packExtraCurrencyCell(extracurrency) {
    return (0, Builder_12.beginCell)().storeDictDirect(packExtraCurrencyDict(extracurrency)).endCell();
  }
  ExtraCurrency.packExtraCurrencyCell = packExtraCurrencyCell;
  return ExtraCurrency;
}
var hasRequired_helpers;
function require_helpers() {
  if (hasRequired_helpers) return _helpers;
  hasRequired_helpers = 1;
  Object.defineProperty(_helpers, "__esModule", { value: true });
  _helpers.comment = _helpers.external = _helpers.internal = void 0;
  const Address_1 = requireAddress();
  const Cell_1 = requireCell();
  const Builder_12 = requireBuilder$1();
  const convert_1 = requireConvert();
  const ExtraCurrency_1 = requireExtraCurrency();
  function internal(src2) {
    let bounce = true;
    if (src2.bounce !== null && src2.bounce !== void 0) {
      bounce = src2.bounce;
    }
    let to2;
    if (typeof src2.to === "string") {
      to2 = Address_1.Address.parse(src2.to);
    } else if (Address_1.Address.isAddress(src2.to)) {
      to2 = src2.to;
    } else {
      throw new Error(`Invalid address ${src2.to}`);
    }
    let value;
    if (typeof src2.value === "string") {
      value = (0, convert_1.toNano)(src2.value);
    } else {
      value = src2.value;
    }
    let other;
    if (src2.extracurrency) {
      other = (0, ExtraCurrency_1.packExtraCurrencyDict)(src2.extracurrency);
    }
    let body = Cell_1.Cell.EMPTY;
    if (typeof src2.body === "string") {
      body = (0, Builder_12.beginCell)().storeUint(0, 32).storeStringTail(src2.body).endCell();
    } else if (src2.body) {
      body = src2.body;
    }
    return {
      info: {
        type: "internal",
        dest: to2,
        value: { coins: value, other },
        bounce,
        ihrDisabled: true,
        bounced: false,
        ihrFee: 0n,
        forwardFee: 0n,
        createdAt: 0,
        createdLt: 0n
      },
      init: src2.init ?? void 0,
      body
    };
  }
  _helpers.internal = internal;
  function external2(src2) {
    let to2;
    if (typeof src2.to === "string") {
      to2 = Address_1.Address.parse(src2.to);
    } else if (Address_1.Address.isAddress(src2.to)) {
      to2 = src2.to;
    } else {
      throw new Error(`Invalid address ${src2.to}`);
    }
    return {
      info: {
        type: "external-in",
        dest: to2,
        importFee: 0n
      },
      init: src2.init ?? void 0,
      body: src2.body || Cell_1.Cell.EMPTY
    };
  }
  _helpers.external = external2;
  function comment(src2) {
    return (0, Builder_12.beginCell)().storeUint(0, 32).storeStringTail(src2).endCell();
  }
  _helpers.comment = comment;
  return _helpers;
}
var Account = {};
var AccountStorage = {};
var AccountState = {};
var hasRequiredAccountState;
function requireAccountState() {
  if (hasRequiredAccountState) return AccountState;
  hasRequiredAccountState = 1;
  Object.defineProperty(AccountState, "__esModule", { value: true });
  AccountState.storeAccountState = AccountState.loadAccountState = void 0;
  const StateInit_1 = requireStateInit();
  function loadAccountState(cs) {
    if (cs.loadBit()) {
      return { type: "active", state: (0, StateInit_1.loadStateInit)(cs) };
    } else if (cs.loadBit()) {
      return { type: "frozen", stateHash: cs.loadUintBig(256) };
    } else {
      return { type: "uninit" };
    }
  }
  AccountState.loadAccountState = loadAccountState;
  function storeAccountState(src2) {
    return (builder2) => {
      if (src2.type === "active") {
        builder2.storeBit(true);
        builder2.store((0, StateInit_1.storeStateInit)(src2.state));
      } else if (src2.type === "frozen") {
        builder2.storeBit(false);
        builder2.storeBit(true);
        builder2.storeUint(src2.stateHash, 256);
      } else if (src2.type === "uninit") {
        builder2.storeBit(false);
        builder2.storeBit(false);
      }
    };
  }
  AccountState.storeAccountState = storeAccountState;
  return AccountState;
}
var CurrencyCollection = {};
var hasRequiredCurrencyCollection;
function requireCurrencyCollection() {
  if (hasRequiredCurrencyCollection) return CurrencyCollection;
  hasRequiredCurrencyCollection = 1;
  Object.defineProperty(CurrencyCollection, "__esModule", { value: true });
  CurrencyCollection.storeCurrencyCollection = CurrencyCollection.loadCurrencyCollection = void 0;
  const Dictionary_1 = requireDictionary();
  function loadCurrencyCollection(slice) {
    const coins = slice.loadCoins();
    const other = slice.loadDict(Dictionary_1.Dictionary.Keys.Uint(32), Dictionary_1.Dictionary.Values.BigVarUint(
      5
      /* log2(32) */
    ));
    if (other.size === 0) {
      return { coins };
    } else {
      return { other, coins };
    }
  }
  CurrencyCollection.loadCurrencyCollection = loadCurrencyCollection;
  function storeCurrencyCollection(collection) {
    return (builder2) => {
      builder2.storeCoins(collection.coins);
      if (collection.other) {
        builder2.storeDict(collection.other);
      } else {
        builder2.storeBit(0);
      }
    };
  }
  CurrencyCollection.storeCurrencyCollection = storeCurrencyCollection;
  return CurrencyCollection;
}
var hasRequiredAccountStorage;
function requireAccountStorage() {
  if (hasRequiredAccountStorage) return AccountStorage;
  hasRequiredAccountStorage = 1;
  Object.defineProperty(AccountStorage, "__esModule", { value: true });
  AccountStorage.storeAccountStorage = AccountStorage.loadAccountStorage = void 0;
  const AccountState_1 = requireAccountState();
  const CurrencyCollection_1 = requireCurrencyCollection();
  function loadAccountStorage(slice) {
    return {
      lastTransLt: slice.loadUintBig(64),
      balance: (0, CurrencyCollection_1.loadCurrencyCollection)(slice),
      state: (0, AccountState_1.loadAccountState)(slice)
    };
  }
  AccountStorage.loadAccountStorage = loadAccountStorage;
  function storeAccountStorage(src2) {
    return (builder2) => {
      builder2.storeUint(src2.lastTransLt, 64);
      builder2.store((0, CurrencyCollection_1.storeCurrencyCollection)(src2.balance));
      builder2.store((0, AccountState_1.storeAccountState)(src2.state));
    };
  }
  AccountStorage.storeAccountStorage = storeAccountStorage;
  return AccountStorage;
}
var StorageInfo = {};
var StorageExtraInfo = {};
var hasRequiredStorageExtraInfo;
function requireStorageExtraInfo() {
  if (hasRequiredStorageExtraInfo) return StorageExtraInfo;
  hasRequiredStorageExtraInfo = 1;
  Object.defineProperty(StorageExtraInfo, "__esModule", { value: true });
  StorageExtraInfo.storeStorageExtraInfo = StorageExtraInfo.loadStorageExtraInfo = void 0;
  function loadStorageExtraInfo(slice) {
    let header = slice.loadUint(3);
    if (header === 0) {
      return null;
    }
    if (header === 1) {
      return {
        dictHash: slice.loadUintBig(256)
      };
    }
    throw new Error(`Invalid storage extra info header: ${header}`);
  }
  StorageExtraInfo.loadStorageExtraInfo = loadStorageExtraInfo;
  function storeStorageExtraInfo(src2) {
    return (builder2) => {
      if (src2 === null) {
        builder2.storeUint(0, 3);
      } else {
        builder2.storeUint(1, 3);
        builder2.storeUint(src2.dictHash, 256);
      }
    };
  }
  StorageExtraInfo.storeStorageExtraInfo = storeStorageExtraInfo;
  return StorageExtraInfo;
}
var StorageUsed = {};
var hasRequiredStorageUsed;
function requireStorageUsed() {
  if (hasRequiredStorageUsed) return StorageUsed;
  hasRequiredStorageUsed = 1;
  Object.defineProperty(StorageUsed, "__esModule", { value: true });
  StorageUsed.storeStorageUsed = StorageUsed.loadStorageUsed = void 0;
  function loadStorageUsed(cs) {
    return {
      cells: cs.loadVarUintBig(3),
      bits: cs.loadVarUintBig(3)
    };
  }
  StorageUsed.loadStorageUsed = loadStorageUsed;
  function storeStorageUsed(src2) {
    return (builder2) => {
      builder2.storeVarUint(src2.cells, 3);
      builder2.storeVarUint(src2.bits, 3);
    };
  }
  StorageUsed.storeStorageUsed = storeStorageUsed;
  return StorageUsed;
}
var hasRequiredStorageInfo;
function requireStorageInfo() {
  if (hasRequiredStorageInfo) return StorageInfo;
  hasRequiredStorageInfo = 1;
  Object.defineProperty(StorageInfo, "__esModule", { value: true });
  StorageInfo.storeStorageInfo = StorageInfo.loadStorageInfo = void 0;
  const StorageExtraInfo_1 = requireStorageExtraInfo();
  const StorageUsed_1 = requireStorageUsed();
  function loadStorageInfo(slice) {
    return {
      used: (0, StorageUsed_1.loadStorageUsed)(slice),
      storageExtra: (0, StorageExtraInfo_1.loadStorageExtraInfo)(slice),
      lastPaid: slice.loadUint(32),
      duePayment: slice.loadMaybeCoins()
    };
  }
  StorageInfo.loadStorageInfo = loadStorageInfo;
  function storeStorageInfo(src2) {
    return (builder2) => {
      builder2.store((0, StorageUsed_1.storeStorageUsed)(src2.used));
      builder2.store((0, StorageExtraInfo_1.storeStorageExtraInfo)(src2.storageExtra));
      builder2.storeUint(src2.lastPaid, 32);
      builder2.storeMaybeCoins(src2.duePayment);
    };
  }
  StorageInfo.storeStorageInfo = storeStorageInfo;
  return StorageInfo;
}
var hasRequiredAccount;
function requireAccount() {
  if (hasRequiredAccount) return Account;
  hasRequiredAccount = 1;
  Object.defineProperty(Account, "__esModule", { value: true });
  Account.storeAccount = Account.loadAccount = void 0;
  const AccountStorage_1 = requireAccountStorage();
  const StorageInfo_1 = requireStorageInfo();
  function loadAccount(slice) {
    return {
      addr: slice.loadAddress(),
      storageStats: (0, StorageInfo_1.loadStorageInfo)(slice),
      storage: (0, AccountStorage_1.loadAccountStorage)(slice)
    };
  }
  Account.loadAccount = loadAccount;
  function storeAccount(src2) {
    return (builder2) => {
      builder2.storeAddress(src2.addr);
      builder2.store((0, StorageInfo_1.storeStorageInfo)(src2.storageStats));
      builder2.store((0, AccountStorage_1.storeAccountStorage)(src2.storage));
    };
  }
  Account.storeAccount = storeAccount;
  return Account;
}
var AccountStatus = {};
var hasRequiredAccountStatus;
function requireAccountStatus() {
  if (hasRequiredAccountStatus) return AccountStatus;
  hasRequiredAccountStatus = 1;
  Object.defineProperty(AccountStatus, "__esModule", { value: true });
  AccountStatus.storeAccountStatus = AccountStatus.loadAccountStatus = void 0;
  function loadAccountStatus(slice) {
    const status = slice.loadUint(2);
    if (status === 0) {
      return "uninitialized";
    }
    if (status === 1) {
      return "frozen";
    }
    if (status === 2) {
      return "active";
    }
    if (status === 3) {
      return "non-existing";
    }
    throw Error("Invalid data");
  }
  AccountStatus.loadAccountStatus = loadAccountStatus;
  function storeAccountStatus(src2) {
    return (builder2) => {
      if (src2 === "uninitialized") {
        builder2.storeUint(0, 2);
      } else if (src2 === "frozen") {
        builder2.storeUint(1, 2);
      } else if (src2 === "active") {
        builder2.storeUint(2, 2);
      } else if (src2 === "non-existing") {
        builder2.storeUint(3, 2);
      } else {
        throw Error("Invalid data");
      }
      return builder2;
    };
  }
  AccountStatus.storeAccountStatus = storeAccountStatus;
  return AccountStatus;
}
var AccountStatusChange = {};
var hasRequiredAccountStatusChange;
function requireAccountStatusChange() {
  if (hasRequiredAccountStatusChange) return AccountStatusChange;
  hasRequiredAccountStatusChange = 1;
  Object.defineProperty(AccountStatusChange, "__esModule", { value: true });
  AccountStatusChange.storeAccountStatusChange = AccountStatusChange.loadAccountStatusChange = void 0;
  function loadAccountStatusChange(slice) {
    if (!slice.loadBit()) {
      return "unchanged";
    }
    if (slice.loadBit()) {
      return "deleted";
    } else {
      return "frozen";
    }
  }
  AccountStatusChange.loadAccountStatusChange = loadAccountStatusChange;
  function storeAccountStatusChange(src2) {
    return (builder2) => {
      if (src2 == "unchanged") {
        builder2.storeBit(0);
      } else if (src2 === "frozen") {
        builder2.storeBit(1);
        builder2.storeBit(0);
      } else if (src2 === "deleted") {
        builder2.storeBit(1);
        builder2.storeBit(1);
      } else {
        throw Error("Invalid account status change");
      }
    };
  }
  AccountStatusChange.storeAccountStatusChange = storeAccountStatusChange;
  return AccountStatusChange;
}
var OutList = {};
var MessageRelaxed = {};
var CommonMessageInfoRelaxed = {};
var hasRequiredCommonMessageInfoRelaxed;
function requireCommonMessageInfoRelaxed() {
  if (hasRequiredCommonMessageInfoRelaxed) return CommonMessageInfoRelaxed;
  hasRequiredCommonMessageInfoRelaxed = 1;
  Object.defineProperty(CommonMessageInfoRelaxed, "__esModule", { value: true });
  CommonMessageInfoRelaxed.storeCommonMessageInfoRelaxed = CommonMessageInfoRelaxed.loadCommonMessageInfoRelaxed = void 0;
  const CurrencyCollection_1 = requireCurrencyCollection();
  function loadCommonMessageInfoRelaxed(slice) {
    if (!slice.loadBit()) {
      const ihrDisabled = slice.loadBit();
      const bounce = slice.loadBit();
      const bounced = slice.loadBit();
      const src3 = slice.loadMaybeAddress();
      const dest2 = slice.loadAddress();
      const value = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
      const ihrFee = slice.loadCoins();
      const forwardFee = slice.loadCoins();
      const createdLt2 = slice.loadUintBig(64);
      const createdAt2 = slice.loadUint(32);
      return {
        type: "internal",
        ihrDisabled,
        bounce,
        bounced,
        src: src3,
        dest: dest2,
        value,
        ihrFee,
        forwardFee,
        createdLt: createdLt2,
        createdAt: createdAt2
      };
    }
    if (!slice.loadBit()) {
      throw Error("External In message is not possible for CommonMessageInfoRelaxed");
    }
    const src2 = slice.loadMaybeAddress();
    const dest = slice.loadMaybeExternalAddress();
    const createdLt = slice.loadUintBig(64);
    const createdAt = slice.loadUint(32);
    return {
      type: "external-out",
      src: src2,
      dest,
      createdLt,
      createdAt
    };
  }
  CommonMessageInfoRelaxed.loadCommonMessageInfoRelaxed = loadCommonMessageInfoRelaxed;
  function storeCommonMessageInfoRelaxed(source) {
    return (builder2) => {
      if (source.type === "internal") {
        builder2.storeBit(0);
        builder2.storeBit(source.ihrDisabled);
        builder2.storeBit(source.bounce);
        builder2.storeBit(source.bounced);
        builder2.storeAddress(source.src);
        builder2.storeAddress(source.dest);
        builder2.store((0, CurrencyCollection_1.storeCurrencyCollection)(source.value));
        builder2.storeCoins(source.ihrFee);
        builder2.storeCoins(source.forwardFee);
        builder2.storeUint(source.createdLt, 64);
        builder2.storeUint(source.createdAt, 32);
      } else if (source.type === "external-out") {
        builder2.storeBit(1);
        builder2.storeBit(1);
        builder2.storeAddress(source.src);
        builder2.storeAddress(source.dest);
        builder2.storeUint(source.createdLt, 64);
        builder2.storeUint(source.createdAt, 32);
      } else {
        throw new Error("Unknown CommonMessageInfo type");
      }
    };
  }
  CommonMessageInfoRelaxed.storeCommonMessageInfoRelaxed = storeCommonMessageInfoRelaxed;
  return CommonMessageInfoRelaxed;
}
var hasRequiredMessageRelaxed;
function requireMessageRelaxed() {
  if (hasRequiredMessageRelaxed) return MessageRelaxed;
  hasRequiredMessageRelaxed = 1;
  Object.defineProperty(MessageRelaxed, "__esModule", { value: true });
  MessageRelaxed.storeMessageRelaxed = MessageRelaxed.loadMessageRelaxed = void 0;
  const Builder_12 = requireBuilder$1();
  const CommonMessageInfoRelaxed_1 = requireCommonMessageInfoRelaxed();
  const StateInit_1 = requireStateInit();
  function loadMessageRelaxed(slice) {
    const info = (0, CommonMessageInfoRelaxed_1.loadCommonMessageInfoRelaxed)(slice);
    let init = null;
    if (slice.loadBit()) {
      if (!slice.loadBit()) {
        init = (0, StateInit_1.loadStateInit)(slice);
      } else {
        init = (0, StateInit_1.loadStateInit)(slice.loadRef().beginParse());
      }
    }
    const body = slice.loadBit() ? slice.loadRef() : slice.asCell();
    return {
      info,
      init,
      body
    };
  }
  MessageRelaxed.loadMessageRelaxed = loadMessageRelaxed;
  function storeMessageRelaxed(message, opts) {
    return (builder2) => {
      builder2.store((0, CommonMessageInfoRelaxed_1.storeCommonMessageInfoRelaxed)(message.info));
      if (message.init) {
        builder2.storeBit(true);
        let initCell = (0, Builder_12.beginCell)().store((0, StateInit_1.storeStateInit)(message.init));
        let needRef2 = false;
        if (opts && opts.forceRef) {
          needRef2 = true;
        } else {
          if (builder2.availableBits - 2 >= initCell.bits) {
            needRef2 = false;
          } else {
            needRef2 = true;
          }
        }
        if (needRef2) {
          builder2.storeBit(true);
          builder2.storeRef(initCell);
        } else {
          builder2.storeBit(false);
          builder2.storeBuilder(initCell);
        }
      } else {
        builder2.storeBit(false);
      }
      let needRef = false;
      if (opts && opts.forceRef) {
        needRef = true;
      } else {
        if (builder2.availableBits - 1 >= message.body.bits.length && builder2.refs + message.body.refs.length <= 4 && !message.body.isExotic) {
          needRef = false;
        } else {
          needRef = true;
        }
      }
      if (needRef) {
        builder2.storeBit(true);
        builder2.storeRef(message.body);
      } else {
        builder2.storeBit(false);
        builder2.storeBuilder(message.body.asBuilder());
      }
    };
  }
  MessageRelaxed.storeMessageRelaxed = storeMessageRelaxed;
  return MessageRelaxed;
}
var LibRef = {};
var hasRequiredLibRef;
function requireLibRef() {
  if (hasRequiredLibRef) return LibRef;
  hasRequiredLibRef = 1;
  Object.defineProperty(LibRef, "__esModule", { value: true });
  LibRef.storeLibRef = LibRef.loadLibRef = void 0;
  function loadLibRef(slice) {
    const type = slice.loadUint(1);
    if (type === 0) {
      return {
        type: "hash",
        libHash: slice.loadBuffer(32)
      };
    } else {
      return {
        type: "ref",
        library: slice.loadRef()
      };
    }
  }
  LibRef.loadLibRef = loadLibRef;
  function storeLibRef(src2) {
    return (builder2) => {
      if (src2.type === "hash") {
        builder2.storeUint(0, 1);
        builder2.storeBuffer(src2.libHash);
      } else {
        builder2.storeUint(1, 1);
        builder2.storeRef(src2.library);
      }
    };
  }
  LibRef.storeLibRef = storeLibRef;
  return LibRef;
}
var hasRequiredOutList;
function requireOutList() {
  if (hasRequiredOutList) return OutList;
  hasRequiredOutList = 1;
  Object.defineProperty(OutList, "__esModule", { value: true });
  OutList.loadOutList = OutList.storeOutList = OutList.loadOutAction = OutList.storeOutAction = void 0;
  const MessageRelaxed_1 = requireMessageRelaxed();
  const Builder_12 = requireBuilder$1();
  const CurrencyCollection_1 = requireCurrencyCollection();
  const LibRef_1 = requireLibRef();
  function storeOutAction(action) {
    switch (action.type) {
      case "sendMsg":
        return storeOutActionSendMsg(action);
      case "setCode":
        return storeOutActionSetCode(action);
      case "reserve":
        return storeOutActionReserve(action);
      case "changeLibrary":
        return storeOutActionChangeLibrary(action);
      default:
        throw new Error(`Unknown action type ${action.type}`);
    }
  }
  OutList.storeOutAction = storeOutAction;
  const outActionSendMsgTag = 247711853;
  function storeOutActionSendMsg(action) {
    return (builder2) => {
      builder2.storeUint(outActionSendMsgTag, 32).storeUint(action.mode, 8).storeRef((0, Builder_12.beginCell)().store((0, MessageRelaxed_1.storeMessageRelaxed)(action.outMsg)).endCell());
    };
  }
  const outActionSetCodeTag = 2907562126;
  function storeOutActionSetCode(action) {
    return (builder2) => {
      builder2.storeUint(outActionSetCodeTag, 32).storeRef(action.newCode);
    };
  }
  const outActionReserveTag = 921090057;
  function storeOutActionReserve(action) {
    return (builder2) => {
      builder2.storeUint(outActionReserveTag, 32).storeUint(action.mode, 8).store((0, CurrencyCollection_1.storeCurrencyCollection)(action.currency));
    };
  }
  const outActionChangeLibraryTag = 653925844;
  function storeOutActionChangeLibrary(action) {
    return (builder2) => {
      builder2.storeUint(outActionChangeLibraryTag, 32).storeUint(action.mode, 7).store((0, LibRef_1.storeLibRef)(action.libRef));
    };
  }
  function loadOutAction(slice) {
    const tag = slice.loadUint(32);
    if (tag === outActionSendMsgTag) {
      const mode = slice.loadUint(8);
      const outMsg = (0, MessageRelaxed_1.loadMessageRelaxed)(slice.loadRef().beginParse());
      return {
        type: "sendMsg",
        mode,
        outMsg
      };
    }
    if (tag === outActionSetCodeTag) {
      const newCode = slice.loadRef();
      return {
        type: "setCode",
        newCode
      };
    }
    if (tag === outActionReserveTag) {
      const mode = slice.loadUint(8);
      const currency = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
      return {
        type: "reserve",
        mode,
        currency
      };
    }
    if (tag === outActionChangeLibraryTag) {
      const mode = slice.loadUint(7);
      const libRef = (0, LibRef_1.loadLibRef)(slice);
      return {
        type: "changeLibrary",
        mode,
        libRef
      };
    }
    throw new Error(`Unknown out action tag 0x${tag.toString(16)}`);
  }
  OutList.loadOutAction = loadOutAction;
  function storeOutList(actions) {
    const cell = actions.reduce((cell2, action) => (0, Builder_12.beginCell)().storeRef(cell2).store(storeOutAction(action)).endCell(), (0, Builder_12.beginCell)().endCell());
    return (builder2) => {
      builder2.storeSlice(cell.beginParse());
    };
  }
  OutList.storeOutList = storeOutList;
  function loadOutList(slice) {
    const actions = [];
    while (slice.remainingRefs) {
      const nextCell = slice.loadRef();
      actions.push(loadOutAction(slice));
      slice = nextCell.beginParse();
    }
    return actions.reverse();
  }
  OutList.loadOutList = loadOutList;
  return OutList;
}
var CommonMessageInfo = {};
var hasRequiredCommonMessageInfo;
function requireCommonMessageInfo() {
  if (hasRequiredCommonMessageInfo) return CommonMessageInfo;
  hasRequiredCommonMessageInfo = 1;
  Object.defineProperty(CommonMessageInfo, "__esModule", { value: true });
  CommonMessageInfo.storeCommonMessageInfo = CommonMessageInfo.loadCommonMessageInfo = void 0;
  const CurrencyCollection_1 = requireCurrencyCollection();
  function loadCommonMessageInfo(slice) {
    if (!slice.loadBit()) {
      const ihrDisabled = slice.loadBit();
      const bounce = slice.loadBit();
      const bounced = slice.loadBit();
      const src3 = slice.loadAddress();
      const dest2 = slice.loadAddress();
      const value = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
      const ihrFee = slice.loadCoins();
      const forwardFee = slice.loadCoins();
      const createdLt2 = slice.loadUintBig(64);
      const createdAt2 = slice.loadUint(32);
      return {
        type: "internal",
        ihrDisabled,
        bounce,
        bounced,
        src: src3,
        dest: dest2,
        value,
        ihrFee,
        forwardFee,
        createdLt: createdLt2,
        createdAt: createdAt2
      };
    }
    if (!slice.loadBit()) {
      const src3 = slice.loadMaybeExternalAddress();
      const dest2 = slice.loadAddress();
      const importFee = slice.loadCoins();
      return {
        type: "external-in",
        src: src3,
        dest: dest2,
        importFee
      };
    }
    const src2 = slice.loadAddress();
    const dest = slice.loadMaybeExternalAddress();
    const createdLt = slice.loadUintBig(64);
    const createdAt = slice.loadUint(32);
    return {
      type: "external-out",
      src: src2,
      dest,
      createdLt,
      createdAt
    };
  }
  CommonMessageInfo.loadCommonMessageInfo = loadCommonMessageInfo;
  function storeCommonMessageInfo(source) {
    return (builder2) => {
      if (source.type === "internal") {
        builder2.storeBit(0);
        builder2.storeBit(source.ihrDisabled);
        builder2.storeBit(source.bounce);
        builder2.storeBit(source.bounced);
        builder2.storeAddress(source.src);
        builder2.storeAddress(source.dest);
        builder2.store((0, CurrencyCollection_1.storeCurrencyCollection)(source.value));
        builder2.storeCoins(source.ihrFee);
        builder2.storeCoins(source.forwardFee);
        builder2.storeUint(source.createdLt, 64);
        builder2.storeUint(source.createdAt, 32);
      } else if (source.type === "external-in") {
        builder2.storeBit(1);
        builder2.storeBit(0);
        builder2.storeAddress(source.src);
        builder2.storeAddress(source.dest);
        builder2.storeCoins(source.importFee);
      } else if (source.type === "external-out") {
        builder2.storeBit(1);
        builder2.storeBit(1);
        builder2.storeAddress(source.src);
        builder2.storeAddress(source.dest);
        builder2.storeUint(source.createdLt, 64);
        builder2.storeUint(source.createdAt, 32);
      } else {
        throw new Error("Unknown CommonMessageInfo type");
      }
    };
  }
  CommonMessageInfo.storeCommonMessageInfo = storeCommonMessageInfo;
  return CommonMessageInfo;
}
var ComputeSkipReason = {};
var hasRequiredComputeSkipReason;
function requireComputeSkipReason() {
  if (hasRequiredComputeSkipReason) return ComputeSkipReason;
  hasRequiredComputeSkipReason = 1;
  Object.defineProperty(ComputeSkipReason, "__esModule", { value: true });
  ComputeSkipReason.storeComputeSkipReason = ComputeSkipReason.loadComputeSkipReason = void 0;
  function loadComputeSkipReason(slice) {
    let reason = slice.loadUint(2);
    if (reason === 0) {
      return "no-state";
    } else if (reason === 1) {
      return "bad-state";
    } else if (reason === 2) {
      return "no-gas";
    }
    throw new Error(`Unknown ComputeSkipReason: ${reason}`);
  }
  ComputeSkipReason.loadComputeSkipReason = loadComputeSkipReason;
  function storeComputeSkipReason(src2) {
    return (builder2) => {
      if (src2 === "no-state") {
        builder2.storeUint(0, 2);
      } else if (src2 === "bad-state") {
        builder2.storeUint(1, 2);
      } else if (src2 === "no-gas") {
        builder2.storeUint(2, 2);
      } else {
        throw new Error(`Unknown ComputeSkipReason: ${src2}`);
      }
    };
  }
  ComputeSkipReason.storeComputeSkipReason = storeComputeSkipReason;
  return ComputeSkipReason;
}
var DepthBalanceInfo = {};
var hasRequiredDepthBalanceInfo;
function requireDepthBalanceInfo() {
  if (hasRequiredDepthBalanceInfo) return DepthBalanceInfo;
  hasRequiredDepthBalanceInfo = 1;
  Object.defineProperty(DepthBalanceInfo, "__esModule", { value: true });
  DepthBalanceInfo.storeDepthBalanceInfo = DepthBalanceInfo.loadDepthBalanceInfo = void 0;
  const CurrencyCollection_1 = requireCurrencyCollection();
  function loadDepthBalanceInfo(slice) {
    let splitDepth = slice.loadUint(5);
    return {
      splitDepth,
      balance: (0, CurrencyCollection_1.loadCurrencyCollection)(slice)
    };
  }
  DepthBalanceInfo.loadDepthBalanceInfo = loadDepthBalanceInfo;
  function storeDepthBalanceInfo(src2) {
    return (builder2) => {
      builder2.storeUint(src2.splitDepth, 5);
      builder2.store((0, CurrencyCollection_1.storeCurrencyCollection)(src2.balance));
    };
  }
  DepthBalanceInfo.storeDepthBalanceInfo = storeDepthBalanceInfo;
  return DepthBalanceInfo;
}
var HashUpdate = {};
var hasRequiredHashUpdate;
function requireHashUpdate() {
  if (hasRequiredHashUpdate) return HashUpdate;
  hasRequiredHashUpdate = 1;
  Object.defineProperty(HashUpdate, "__esModule", { value: true });
  HashUpdate.storeHashUpdate = HashUpdate.loadHashUpdate = void 0;
  function loadHashUpdate(slice) {
    if (slice.loadUint(8) !== 114) {
      throw Error("Invalid data");
    }
    const oldHash = slice.loadBuffer(32);
    const newHash = slice.loadBuffer(32);
    return { oldHash, newHash };
  }
  HashUpdate.loadHashUpdate = loadHashUpdate;
  function storeHashUpdate(src2) {
    return (builder2) => {
      builder2.storeUint(114, 8);
      builder2.storeBuffer(src2.oldHash);
      builder2.storeBuffer(src2.newHash);
    };
  }
  HashUpdate.storeHashUpdate = storeHashUpdate;
  return HashUpdate;
}
var MasterchainStateExtra = {};
var hasRequiredMasterchainStateExtra;
function requireMasterchainStateExtra() {
  if (hasRequiredMasterchainStateExtra) return MasterchainStateExtra;
  hasRequiredMasterchainStateExtra = 1;
  Object.defineProperty(MasterchainStateExtra, "__esModule", { value: true });
  MasterchainStateExtra.loadMasterchainStateExtra = void 0;
  const Dictionary_1 = requireDictionary();
  const CurrencyCollection_1 = requireCurrencyCollection();
  function loadMasterchainStateExtra(cs) {
    if (cs.loadUint(16) !== 52262) {
      throw Error("Invalid data");
    }
    if (cs.loadBit()) {
      cs.loadRef();
    }
    let configAddress = cs.loadUintBig(256);
    let config = Dictionary_1.Dictionary.load(Dictionary_1.Dictionary.Keys.Int(32), Dictionary_1.Dictionary.Values.Cell(), cs);
    const globalBalance = (0, CurrencyCollection_1.loadCurrencyCollection)(cs);
    return {
      config,
      configAddress,
      globalBalance
    };
  }
  MasterchainStateExtra.loadMasterchainStateExtra = loadMasterchainStateExtra;
  return MasterchainStateExtra;
}
var Message = {};
var hasRequiredMessage;
function requireMessage() {
  if (hasRequiredMessage) return Message;
  hasRequiredMessage = 1;
  Object.defineProperty(Message, "__esModule", { value: true });
  Message.MessageValue = Message.storeMessage = Message.loadMessage = void 0;
  const Builder_12 = requireBuilder$1();
  const CommonMessageInfo_1 = requireCommonMessageInfo();
  const StateInit_1 = requireStateInit();
  function loadMessage(slice) {
    const info = (0, CommonMessageInfo_1.loadCommonMessageInfo)(slice);
    let init = null;
    if (slice.loadBit()) {
      if (!slice.loadBit()) {
        init = (0, StateInit_1.loadStateInit)(slice);
      } else {
        init = (0, StateInit_1.loadStateInit)(slice.loadRef().beginParse());
      }
    }
    const body = slice.loadBit() ? slice.loadRef() : slice.asCell();
    return {
      info,
      init,
      body
    };
  }
  Message.loadMessage = loadMessage;
  function storeMessage(message, opts) {
    return (builder2) => {
      builder2.store((0, CommonMessageInfo_1.storeCommonMessageInfo)(message.info));
      if (message.init) {
        builder2.storeBit(true);
        let initCell = (0, Builder_12.beginCell)().store((0, StateInit_1.storeStateInit)(message.init));
        let needRef2 = false;
        if (opts && opts.forceRef) {
          needRef2 = true;
        } else {
          needRef2 = builder2.availableBits - 2 < initCell.bits + message.body.bits.length;
        }
        if (needRef2) {
          builder2.storeBit(true);
          builder2.storeRef(initCell);
        } else {
          builder2.storeBit(false);
          builder2.storeBuilder(initCell);
        }
      } else {
        builder2.storeBit(false);
      }
      let needRef = false;
      if (opts && opts.forceRef) {
        needRef = true;
      } else {
        needRef = builder2.availableBits - 1 < message.body.bits.length || builder2.refs + message.body.refs.length > 4;
      }
      if (needRef) {
        builder2.storeBit(true);
        builder2.storeRef(message.body);
      } else {
        builder2.storeBit(false);
        builder2.storeBuilder(message.body.asBuilder());
      }
    };
  }
  Message.storeMessage = storeMessage;
  Message.MessageValue = {
    serialize(src2, builder2) {
      builder2.storeRef((0, Builder_12.beginCell)().store(storeMessage(src2)));
    },
    parse(slice) {
      return loadMessage(slice.loadRef().beginParse());
    }
  };
  return Message;
}
var SendMode = {};
var hasRequiredSendMode;
function requireSendMode() {
  if (hasRequiredSendMode) return SendMode;
  hasRequiredSendMode = 1;
  Object.defineProperty(SendMode, "__esModule", { value: true });
  SendMode.SendMode = void 0;
  var SendMode$1;
  (function(SendMode2) {
    SendMode2[SendMode2["CARRY_ALL_REMAINING_BALANCE"] = 128] = "CARRY_ALL_REMAINING_BALANCE";
    SendMode2[SendMode2["CARRY_ALL_REMAINING_INCOMING_VALUE"] = 64] = "CARRY_ALL_REMAINING_INCOMING_VALUE";
    SendMode2[SendMode2["DESTROY_ACCOUNT_IF_ZERO"] = 32] = "DESTROY_ACCOUNT_IF_ZERO";
    SendMode2[SendMode2["PAY_GAS_SEPARATELY"] = 1] = "PAY_GAS_SEPARATELY";
    SendMode2[SendMode2["IGNORE_ERRORS"] = 2] = "IGNORE_ERRORS";
    SendMode2[SendMode2["NONE"] = 0] = "NONE";
  })(SendMode$1 || (SendMode.SendMode = SendMode$1 = {}));
  return SendMode;
}
var ReserveMode = {};
var hasRequiredReserveMode;
function requireReserveMode() {
  if (hasRequiredReserveMode) return ReserveMode;
  hasRequiredReserveMode = 1;
  Object.defineProperty(ReserveMode, "__esModule", { value: true });
  ReserveMode.ReserveMode = void 0;
  var ReserveMode$1;
  (function(ReserveMode2) {
    ReserveMode2[ReserveMode2["THIS_AMOUNT"] = 0] = "THIS_AMOUNT";
    ReserveMode2[ReserveMode2["LEAVE_THIS_AMOUNT"] = 1] = "LEAVE_THIS_AMOUNT";
    ReserveMode2[ReserveMode2["AT_MOST_THIS_AMOUNT"] = 2] = "AT_MOST_THIS_AMOUNT";
    ReserveMode2[ReserveMode2["LEAVE_MAX_THIS_AMOUNT"] = 3] = "LEAVE_MAX_THIS_AMOUNT";
    ReserveMode2[ReserveMode2["BEFORE_BALANCE_PLUS_THIS_AMOUNT"] = 4] = "BEFORE_BALANCE_PLUS_THIS_AMOUNT";
    ReserveMode2[ReserveMode2["LEAVE_BBALANCE_PLUS_THIS_AMOUNT"] = 5] = "LEAVE_BBALANCE_PLUS_THIS_AMOUNT";
    ReserveMode2[ReserveMode2["BEFORE_BALANCE_MINUS_THIS_AMOUNT"] = 12] = "BEFORE_BALANCE_MINUS_THIS_AMOUNT";
    ReserveMode2[ReserveMode2["LEAVE_BEFORE_BALANCE_MINUS_THIS_AMOUNT"] = 13] = "LEAVE_BEFORE_BALANCE_MINUS_THIS_AMOUNT";
  })(ReserveMode$1 || (ReserveMode.ReserveMode = ReserveMode$1 = {}));
  return ReserveMode;
}
var ShardAccount = {};
var hasRequiredShardAccount;
function requireShardAccount() {
  if (hasRequiredShardAccount) return ShardAccount;
  hasRequiredShardAccount = 1;
  Object.defineProperty(ShardAccount, "__esModule", { value: true });
  ShardAccount.storeShardAccount = ShardAccount.loadShardAccount = void 0;
  const Builder_12 = requireBuilder$1();
  const Account_1 = requireAccount();
  function loadShardAccount(slice) {
    let accountRef = slice.loadRef();
    let account = void 0;
    if (!accountRef.isExotic) {
      let accountSlice = accountRef.beginParse();
      if (accountSlice.loadBit()) {
        account = (0, Account_1.loadAccount)(accountSlice);
      }
    }
    return {
      account,
      lastTransactionHash: slice.loadUintBig(256),
      lastTransactionLt: slice.loadUintBig(64)
    };
  }
  ShardAccount.loadShardAccount = loadShardAccount;
  function storeShardAccount(src2) {
    return (builder2) => {
      if (src2.account) {
        builder2.storeRef((0, Builder_12.beginCell)().storeBit(true).store((0, Account_1.storeAccount)(src2.account)));
      } else {
        builder2.storeRef((0, Builder_12.beginCell)().storeBit(false));
      }
      builder2.storeUint(src2.lastTransactionHash, 256);
      builder2.storeUint(src2.lastTransactionLt, 64);
    };
  }
  ShardAccount.storeShardAccount = storeShardAccount;
  return ShardAccount;
}
var ShardAccounts = {};
var hasRequiredShardAccounts;
function requireShardAccounts() {
  if (hasRequiredShardAccounts) return ShardAccounts;
  hasRequiredShardAccounts = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeShardAccounts = exports.loadShardAccounts = exports.ShardAccountRefValue = void 0;
    const Dictionary_1 = requireDictionary();
    const DepthBalanceInfo_1 = requireDepthBalanceInfo();
    const ShardAccount_1 = requireShardAccount();
    exports.ShardAccountRefValue = {
      parse: (cs) => {
        let depthBalanceInfo = (0, DepthBalanceInfo_1.loadDepthBalanceInfo)(cs);
        let shardAccount = (0, ShardAccount_1.loadShardAccount)(cs);
        return {
          depthBalanceInfo,
          shardAccount
        };
      },
      serialize(src2, builder2) {
        builder2.store((0, DepthBalanceInfo_1.storeDepthBalanceInfo)(src2.depthBalanceInfo));
        builder2.store((0, ShardAccount_1.storeShardAccount)(src2.shardAccount));
      }
    };
    function loadShardAccounts(cs) {
      return Dictionary_1.Dictionary.load(Dictionary_1.Dictionary.Keys.BigUint(256), exports.ShardAccountRefValue, cs);
    }
    exports.loadShardAccounts = loadShardAccounts;
    function storeShardAccounts(src2) {
      return (Builder2) => {
        Builder2.storeDict(src2);
      };
    }
    exports.storeShardAccounts = storeShardAccounts;
  })(ShardAccounts);
  return ShardAccounts;
}
var ShardIdent = {};
var hasRequiredShardIdent;
function requireShardIdent() {
  if (hasRequiredShardIdent) return ShardIdent;
  hasRequiredShardIdent = 1;
  Object.defineProperty(ShardIdent, "__esModule", { value: true });
  ShardIdent.storeShardIdent = ShardIdent.loadShardIdent = void 0;
  function loadShardIdent(slice) {
    if (slice.loadUint(2) !== 0) {
      throw Error("Invalid data");
    }
    return {
      shardPrefixBits: slice.loadUint(6),
      workchainId: slice.loadInt(32),
      shardPrefix: slice.loadUintBig(64)
    };
  }
  ShardIdent.loadShardIdent = loadShardIdent;
  function storeShardIdent(src2) {
    return (builder2) => {
      builder2.storeUint(0, 2);
      builder2.storeUint(src2.shardPrefixBits, 6);
      builder2.storeInt(src2.workchainId, 32);
      builder2.storeUint(src2.shardPrefix, 64);
    };
  }
  ShardIdent.storeShardIdent = storeShardIdent;
  return ShardIdent;
}
var ShardStateUnsplit = {};
var hasRequiredShardStateUnsplit;
function requireShardStateUnsplit() {
  if (hasRequiredShardStateUnsplit) return ShardStateUnsplit;
  hasRequiredShardStateUnsplit = 1;
  Object.defineProperty(ShardStateUnsplit, "__esModule", { value: true });
  ShardStateUnsplit.loadShardStateUnsplit = void 0;
  const MasterchainStateExtra_1 = requireMasterchainStateExtra();
  const ShardAccounts_1 = requireShardAccounts();
  const ShardIdent_1 = requireShardIdent();
  function loadShardStateUnsplit(cs) {
    if (cs.loadUint(32) !== 2418257890) {
      throw Error("Invalid data");
    }
    let globalId = cs.loadInt(32);
    let shardId = (0, ShardIdent_1.loadShardIdent)(cs);
    let seqno = cs.loadUint(32);
    let vertSeqNo = cs.loadUint(32);
    let genUtime = cs.loadUint(32);
    let genLt = cs.loadUintBig(64);
    let minRefMcSeqno = cs.loadUint(32);
    cs.loadRef();
    let beforeSplit = cs.loadBit();
    let shardAccountsRef = cs.loadRef();
    let accounts = void 0;
    if (!shardAccountsRef.isExotic) {
      accounts = (0, ShardAccounts_1.loadShardAccounts)(shardAccountsRef.beginParse());
    }
    cs.loadRef();
    let mcStateExtra = cs.loadBit();
    let extras2 = null;
    if (mcStateExtra) {
      let cell = cs.loadRef();
      if (!cell.isExotic) {
        extras2 = (0, MasterchainStateExtra_1.loadMasterchainStateExtra)(cell.beginParse());
      }
    }
    return {
      globalId,
      shardId,
      seqno,
      vertSeqNo,
      genUtime,
      genLt,
      minRefMcSeqno,
      beforeSplit,
      accounts,
      extras: extras2
    };
  }
  ShardStateUnsplit.loadShardStateUnsplit = loadShardStateUnsplit;
  return ShardStateUnsplit;
}
var SplitMergeInfo = {};
var hasRequiredSplitMergeInfo;
function requireSplitMergeInfo() {
  if (hasRequiredSplitMergeInfo) return SplitMergeInfo;
  hasRequiredSplitMergeInfo = 1;
  Object.defineProperty(SplitMergeInfo, "__esModule", { value: true });
  SplitMergeInfo.storeSplitMergeInfo = SplitMergeInfo.loadSplitMergeInfo = void 0;
  function loadSplitMergeInfo(slice) {
    let currentShardPrefixLength = slice.loadUint(6);
    let accountSplitDepth = slice.loadUint(6);
    let thisAddress = slice.loadUintBig(256);
    let siblingAddress = slice.loadUintBig(256);
    return {
      currentShardPrefixLength,
      accountSplitDepth,
      thisAddress,
      siblingAddress
    };
  }
  SplitMergeInfo.loadSplitMergeInfo = loadSplitMergeInfo;
  function storeSplitMergeInfo(src2) {
    return (builder2) => {
      builder2.storeUint(src2.currentShardPrefixLength, 6);
      builder2.storeUint(src2.accountSplitDepth, 6);
      builder2.storeUint(src2.thisAddress, 256);
      builder2.storeUint(src2.siblingAddress, 256);
    };
  }
  SplitMergeInfo.storeSplitMergeInfo = storeSplitMergeInfo;
  return SplitMergeInfo;
}
var Transaction = {};
var TransactionDescription = {};
var TransactionActionPhase = {};
var hasRequiredTransactionActionPhase;
function requireTransactionActionPhase() {
  if (hasRequiredTransactionActionPhase) return TransactionActionPhase;
  hasRequiredTransactionActionPhase = 1;
  Object.defineProperty(TransactionActionPhase, "__esModule", { value: true });
  TransactionActionPhase.storeTransactionActionPhase = TransactionActionPhase.loadTransactionActionPhase = void 0;
  const AccountStatusChange_1 = requireAccountStatusChange();
  const StorageUsed_1 = requireStorageUsed();
  function loadTransactionActionPhase(slice) {
    let success = slice.loadBit();
    let valid = slice.loadBit();
    let noFunds = slice.loadBit();
    let statusChange = (0, AccountStatusChange_1.loadAccountStatusChange)(slice);
    let totalFwdFees = slice.loadBit() ? slice.loadCoins() : void 0;
    let totalActionFees = slice.loadBit() ? slice.loadCoins() : void 0;
    let resultCode = slice.loadInt(32);
    let resultArg = slice.loadBit() ? slice.loadInt(32) : void 0;
    let totalActions = slice.loadUint(16);
    let specActions = slice.loadUint(16);
    let skippedActions = slice.loadUint(16);
    let messagesCreated = slice.loadUint(16);
    let actionListHash = slice.loadUintBig(256);
    let totalMessageSize = (0, StorageUsed_1.loadStorageUsed)(slice);
    return {
      success,
      valid,
      noFunds,
      statusChange,
      totalFwdFees,
      totalActionFees,
      resultCode,
      resultArg,
      totalActions,
      specActions,
      skippedActions,
      messagesCreated,
      actionListHash,
      totalMessageSize
    };
  }
  TransactionActionPhase.loadTransactionActionPhase = loadTransactionActionPhase;
  function storeTransactionActionPhase(src2) {
    return (builder2) => {
      builder2.storeBit(src2.success);
      builder2.storeBit(src2.valid);
      builder2.storeBit(src2.noFunds);
      builder2.store((0, AccountStatusChange_1.storeAccountStatusChange)(src2.statusChange));
      builder2.storeMaybeCoins(src2.totalFwdFees);
      builder2.storeMaybeCoins(src2.totalActionFees);
      builder2.storeInt(src2.resultCode, 32);
      builder2.storeMaybeInt(src2.resultArg, 32);
      builder2.storeUint(src2.totalActions, 16);
      builder2.storeUint(src2.specActions, 16);
      builder2.storeUint(src2.skippedActions, 16);
      builder2.storeUint(src2.messagesCreated, 16);
      builder2.storeUint(src2.actionListHash, 256);
      builder2.store((0, StorageUsed_1.storeStorageUsed)(src2.totalMessageSize));
    };
  }
  TransactionActionPhase.storeTransactionActionPhase = storeTransactionActionPhase;
  return TransactionActionPhase;
}
var TransactionBouncePhase = {};
var hasRequiredTransactionBouncePhase;
function requireTransactionBouncePhase() {
  if (hasRequiredTransactionBouncePhase) return TransactionBouncePhase;
  hasRequiredTransactionBouncePhase = 1;
  Object.defineProperty(TransactionBouncePhase, "__esModule", { value: true });
  TransactionBouncePhase.storeTransactionBouncePhase = TransactionBouncePhase.loadTransactionBouncePhase = void 0;
  const StorageUsed_1 = requireStorageUsed();
  function loadTransactionBouncePhase(slice) {
    if (slice.loadBit()) {
      let messageSize = (0, StorageUsed_1.loadStorageUsed)(slice);
      let messageFees = slice.loadCoins();
      let forwardFees = slice.loadCoins();
      return {
        type: "ok",
        messageSize,
        messageFees,
        forwardFees
      };
    }
    if (slice.loadBit()) {
      let messageSize = (0, StorageUsed_1.loadStorageUsed)(slice);
      let requiredForwardFees = slice.loadCoins();
      return {
        type: "no-funds",
        messageSize,
        requiredForwardFees
      };
    }
    return {
      type: "negative-funds"
    };
  }
  TransactionBouncePhase.loadTransactionBouncePhase = loadTransactionBouncePhase;
  function storeTransactionBouncePhase(src2) {
    return (builder2) => {
      if (src2.type === "ok") {
        builder2.storeBit(true);
        builder2.store((0, StorageUsed_1.storeStorageUsed)(src2.messageSize));
        builder2.storeCoins(src2.messageFees);
        builder2.storeCoins(src2.forwardFees);
      } else if (src2.type === "negative-funds") {
        builder2.storeBit(false);
        builder2.storeBit(false);
      } else if (src2.type === "no-funds") {
        builder2.storeBit(false);
        builder2.storeBit(true);
        builder2.store((0, StorageUsed_1.storeStorageUsed)(src2.messageSize));
        builder2.storeCoins(src2.requiredForwardFees);
      } else {
        throw new Error("Invalid TransactionBouncePhase type");
      }
    };
  }
  TransactionBouncePhase.storeTransactionBouncePhase = storeTransactionBouncePhase;
  return TransactionBouncePhase;
}
var TransactionComputePhase = {};
var hasRequiredTransactionComputePhase;
function requireTransactionComputePhase() {
  if (hasRequiredTransactionComputePhase) return TransactionComputePhase;
  hasRequiredTransactionComputePhase = 1;
  Object.defineProperty(TransactionComputePhase, "__esModule", { value: true });
  TransactionComputePhase.storeTransactionComputePhase = TransactionComputePhase.loadTransactionComputePhase = void 0;
  const Builder_12 = requireBuilder$1();
  const ComputeSkipReason_1 = requireComputeSkipReason();
  function loadTransactionComputePhase(slice) {
    if (!slice.loadBit()) {
      let reason = (0, ComputeSkipReason_1.loadComputeSkipReason)(slice);
      return {
        type: "skipped",
        reason
      };
    }
    let success = slice.loadBit();
    let messageStateUsed = slice.loadBit();
    let accountActivated = slice.loadBit();
    let gasFees = slice.loadCoins();
    const vmState = slice.loadRef().beginParse();
    let gasUsed = vmState.loadVarUintBig(3);
    let gasLimit = vmState.loadVarUintBig(3);
    let gasCredit = vmState.loadBit() ? vmState.loadVarUintBig(2) : void 0;
    let mode = vmState.loadUint(8);
    let exitCode = vmState.loadInt(32);
    let exitArg = vmState.loadBit() ? vmState.loadInt(32) : void 0;
    let vmSteps = vmState.loadUint(32);
    let vmInitStateHash = vmState.loadUintBig(256);
    let vmFinalStateHash = vmState.loadUintBig(256);
    return {
      type: "vm",
      success,
      messageStateUsed,
      accountActivated,
      gasFees,
      gasUsed,
      gasLimit,
      gasCredit,
      mode,
      exitCode,
      exitArg,
      vmSteps,
      vmInitStateHash,
      vmFinalStateHash
    };
  }
  TransactionComputePhase.loadTransactionComputePhase = loadTransactionComputePhase;
  function storeTransactionComputePhase(src2) {
    return (builder2) => {
      if (src2.type === "skipped") {
        builder2.storeBit(0);
        builder2.store((0, ComputeSkipReason_1.storeComputeSkipReason)(src2.reason));
        return;
      }
      builder2.storeBit(1);
      builder2.storeBit(src2.success);
      builder2.storeBit(src2.messageStateUsed);
      builder2.storeBit(src2.accountActivated);
      builder2.storeCoins(src2.gasFees);
      builder2.storeRef((0, Builder_12.beginCell)().storeVarUint(src2.gasUsed, 3).storeVarUint(src2.gasLimit, 3).store((b2) => src2.gasCredit !== void 0 && src2.gasCredit !== null ? b2.storeBit(1).storeVarUint(src2.gasCredit, 2) : b2.storeBit(0)).storeUint(src2.mode, 8).storeInt(src2.exitCode, 32).store((b2) => src2.exitArg !== void 0 && src2.exitArg !== null ? b2.storeBit(1).storeInt(src2.exitArg, 32) : b2.storeBit(0)).storeUint(src2.vmSteps, 32).storeUint(src2.vmInitStateHash, 256).storeUint(src2.vmFinalStateHash, 256).endCell());
    };
  }
  TransactionComputePhase.storeTransactionComputePhase = storeTransactionComputePhase;
  return TransactionComputePhase;
}
var TransactionCreditPhase = {};
var hasRequiredTransactionCreditPhase;
function requireTransactionCreditPhase() {
  if (hasRequiredTransactionCreditPhase) return TransactionCreditPhase;
  hasRequiredTransactionCreditPhase = 1;
  Object.defineProperty(TransactionCreditPhase, "__esModule", { value: true });
  TransactionCreditPhase.storeTransactionCreditPhase = TransactionCreditPhase.loadTransactionCreditPhase = void 0;
  const CurrencyCollection_1 = requireCurrencyCollection();
  function loadTransactionCreditPhase(slice) {
    const dueFeesColelcted = slice.loadBit() ? slice.loadCoins() : void 0;
    const credit = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
    return {
      dueFeesColelcted,
      credit
    };
  }
  TransactionCreditPhase.loadTransactionCreditPhase = loadTransactionCreditPhase;
  function storeTransactionCreditPhase(src2) {
    return (builder2) => {
      if (src2.dueFeesColelcted === null || src2.dueFeesColelcted === void 0) {
        builder2.storeBit(false);
      } else {
        builder2.storeBit(true);
        builder2.storeCoins(src2.dueFeesColelcted);
      }
      builder2.store((0, CurrencyCollection_1.storeCurrencyCollection)(src2.credit));
    };
  }
  TransactionCreditPhase.storeTransactionCreditPhase = storeTransactionCreditPhase;
  return TransactionCreditPhase;
}
var TransactionStoragePhase = {};
var hasRequiredTransactionStoragePhase;
function requireTransactionStoragePhase() {
  if (hasRequiredTransactionStoragePhase) return TransactionStoragePhase;
  hasRequiredTransactionStoragePhase = 1;
  Object.defineProperty(TransactionStoragePhase, "__esModule", { value: true });
  TransactionStoragePhase.storeTransactionsStoragePhase = TransactionStoragePhase.loadTransactionStoragePhase = void 0;
  const AccountStatusChange_1 = requireAccountStatusChange();
  function loadTransactionStoragePhase(slice) {
    const storageFeesCollected = slice.loadCoins();
    let storageFeesDue = void 0;
    if (slice.loadBit()) {
      storageFeesDue = slice.loadCoins();
    }
    const statusChange = (0, AccountStatusChange_1.loadAccountStatusChange)(slice);
    return {
      storageFeesCollected,
      storageFeesDue,
      statusChange
    };
  }
  TransactionStoragePhase.loadTransactionStoragePhase = loadTransactionStoragePhase;
  function storeTransactionsStoragePhase(src2) {
    return (builder2) => {
      builder2.storeCoins(src2.storageFeesCollected);
      if (src2.storageFeesDue === null || src2.storageFeesDue === void 0) {
        builder2.storeBit(false);
      } else {
        builder2.storeBit(true);
        builder2.storeCoins(src2.storageFeesDue);
      }
      builder2.store((0, AccountStatusChange_1.storeAccountStatusChange)(src2.statusChange));
    };
  }
  TransactionStoragePhase.storeTransactionsStoragePhase = storeTransactionsStoragePhase;
  return TransactionStoragePhase;
}
var hasRequiredTransactionDescription;
function requireTransactionDescription() {
  if (hasRequiredTransactionDescription) return TransactionDescription;
  hasRequiredTransactionDescription = 1;
  Object.defineProperty(TransactionDescription, "__esModule", { value: true });
  TransactionDescription.storeTransactionDescription = TransactionDescription.loadTransactionDescription = void 0;
  const Builder_12 = requireBuilder$1();
  const SplitMergeInfo_1 = requireSplitMergeInfo();
  const Transaction_1 = requireTransaction();
  const TransactionActionPhase_1 = requireTransactionActionPhase();
  const TransactionBouncePhase_1 = requireTransactionBouncePhase();
  const TransactionComputePhase_1 = requireTransactionComputePhase();
  const TransactionCreditPhase_1 = requireTransactionCreditPhase();
  const TransactionStoragePhase_1 = requireTransactionStoragePhase();
  function loadTransactionDescription(slice) {
    let type = slice.loadUint(4);
    if (type === 0) {
      const creditFirst = slice.loadBit();
      let storagePhase = void 0;
      if (slice.loadBit()) {
        storagePhase = (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice);
      }
      let creditPhase = void 0;
      if (slice.loadBit()) {
        creditPhase = (0, TransactionCreditPhase_1.loadTransactionCreditPhase)(slice);
      }
      let computePhase = (0, TransactionComputePhase_1.loadTransactionComputePhase)(slice);
      let actionPhase = void 0;
      if (slice.loadBit()) {
        actionPhase = (0, TransactionActionPhase_1.loadTransactionActionPhase)(slice.loadRef().beginParse());
      }
      let aborted = slice.loadBit();
      let bouncePhase = void 0;
      if (slice.loadBit()) {
        bouncePhase = (0, TransactionBouncePhase_1.loadTransactionBouncePhase)(slice);
      }
      const destroyed = slice.loadBit();
      return {
        type: "generic",
        creditFirst,
        storagePhase,
        creditPhase,
        computePhase,
        actionPhase,
        bouncePhase,
        aborted,
        destroyed
      };
    }
    if (type === 1) {
      return {
        type: "storage",
        storagePhase: (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice)
      };
    }
    if (type === 2 || type === 3) {
      const isTock = type === 3;
      let storagePhase = (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice);
      let computePhase = (0, TransactionComputePhase_1.loadTransactionComputePhase)(slice);
      let actionPhase = void 0;
      if (slice.loadBit()) {
        actionPhase = (0, TransactionActionPhase_1.loadTransactionActionPhase)(slice.loadRef().beginParse());
      }
      const aborted = slice.loadBit();
      const destroyed = slice.loadBit();
      return {
        type: "tick-tock",
        isTock,
        storagePhase,
        computePhase,
        actionPhase,
        aborted,
        destroyed
      };
    }
    if (type === 4) {
      let splitInfo = (0, SplitMergeInfo_1.loadSplitMergeInfo)(slice);
      let storagePhase = void 0;
      if (slice.loadBit()) {
        storagePhase = (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice);
      }
      let computePhase = (0, TransactionComputePhase_1.loadTransactionComputePhase)(slice);
      let actionPhase = void 0;
      if (slice.loadBit()) {
        actionPhase = (0, TransactionActionPhase_1.loadTransactionActionPhase)(slice.loadRef().beginParse());
      }
      const aborted = slice.loadBit();
      const destroyed = slice.loadBit();
      return {
        type: "split-prepare",
        splitInfo,
        storagePhase,
        computePhase,
        actionPhase,
        aborted,
        destroyed
      };
    }
    if (type === 5) {
      let splitInfo = (0, SplitMergeInfo_1.loadSplitMergeInfo)(slice);
      let prepareTransaction = (0, Transaction_1.loadTransaction)(slice.loadRef().beginParse());
      const installed = slice.loadBit();
      return {
        type: "split-install",
        splitInfo,
        prepareTransaction,
        installed
      };
    }
    throw Error(`Unsupported transaction description type ${type}`);
  }
  TransactionDescription.loadTransactionDescription = loadTransactionDescription;
  function storeTransactionDescription(src2) {
    return (builder2) => {
      if (src2.type === "generic") {
        builder2.storeUint(0, 4);
        builder2.storeBit(src2.creditFirst);
        if (src2.storagePhase) {
          builder2.storeBit(true);
          builder2.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src2.storagePhase));
        } else {
          builder2.storeBit(false);
        }
        if (src2.creditPhase) {
          builder2.storeBit(true);
          builder2.store((0, TransactionCreditPhase_1.storeTransactionCreditPhase)(src2.creditPhase));
        } else {
          builder2.storeBit(false);
        }
        builder2.store((0, TransactionComputePhase_1.storeTransactionComputePhase)(src2.computePhase));
        if (src2.actionPhase) {
          builder2.storeBit(true);
          builder2.storeRef((0, Builder_12.beginCell)().store((0, TransactionActionPhase_1.storeTransactionActionPhase)(src2.actionPhase)));
        } else {
          builder2.storeBit(false);
        }
        builder2.storeBit(src2.aborted);
        if (src2.bouncePhase) {
          builder2.storeBit(true);
          builder2.store((0, TransactionBouncePhase_1.storeTransactionBouncePhase)(src2.bouncePhase));
        } else {
          builder2.storeBit(false);
        }
        builder2.storeBit(src2.destroyed);
      } else if (src2.type === "storage") {
        builder2.storeUint(1, 4);
        builder2.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src2.storagePhase));
      } else if (src2.type === "tick-tock") {
        builder2.storeUint(src2.isTock ? 3 : 2, 4);
        builder2.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src2.storagePhase));
        builder2.store((0, TransactionComputePhase_1.storeTransactionComputePhase)(src2.computePhase));
        if (src2.actionPhase) {
          builder2.storeBit(true);
          builder2.storeRef((0, Builder_12.beginCell)().store((0, TransactionActionPhase_1.storeTransactionActionPhase)(src2.actionPhase)));
        } else {
          builder2.storeBit(false);
        }
        builder2.storeBit(src2.aborted);
        builder2.storeBit(src2.destroyed);
      } else if (src2.type === "split-prepare") {
        builder2.storeUint(4, 4);
        builder2.store((0, SplitMergeInfo_1.storeSplitMergeInfo)(src2.splitInfo));
        if (src2.storagePhase) {
          builder2.storeBit(true);
          builder2.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src2.storagePhase));
        } else {
          builder2.storeBit(false);
        }
        builder2.store((0, TransactionComputePhase_1.storeTransactionComputePhase)(src2.computePhase));
        if (src2.actionPhase) {
          builder2.storeBit(true);
          builder2.store((0, TransactionActionPhase_1.storeTransactionActionPhase)(src2.actionPhase));
        } else {
          builder2.storeBit(false);
        }
        builder2.storeBit(src2.aborted);
        builder2.storeBit(src2.destroyed);
      } else if (src2.type === "split-install") {
        builder2.storeUint(5, 4);
        builder2.store((0, SplitMergeInfo_1.storeSplitMergeInfo)(src2.splitInfo));
        builder2.storeRef((0, Builder_12.beginCell)().store((0, Transaction_1.storeTransaction)(src2.prepareTransaction)));
        builder2.storeBit(src2.installed);
      } else {
        throw Error(`Unsupported transaction description type ${src2.type}`);
      }
    };
  }
  TransactionDescription.storeTransactionDescription = storeTransactionDescription;
  return TransactionDescription;
}
var hasRequiredTransaction;
function requireTransaction() {
  if (hasRequiredTransaction) return Transaction;
  hasRequiredTransaction = 1;
  Object.defineProperty(Transaction, "__esModule", { value: true });
  Transaction.storeTransaction = Transaction.loadTransaction = void 0;
  const Builder_12 = requireBuilder$1();
  const Dictionary_1 = requireDictionary();
  const AccountStatus_1 = requireAccountStatus();
  const CurrencyCollection_1 = requireCurrencyCollection();
  const HashUpdate_1 = requireHashUpdate();
  const Message_1 = requireMessage();
  const TransactionDescription_1 = requireTransactionDescription();
  function loadTransaction(slice) {
    let raw = slice.asCell();
    if (slice.loadUint(4) !== 7) {
      throw Error("Invalid data");
    }
    let address = slice.loadUintBig(256);
    let lt2 = slice.loadUintBig(64);
    let prevTransactionHash = slice.loadUintBig(256);
    let prevTransactionLt = slice.loadUintBig(64);
    let now = slice.loadUint(32);
    let outMessagesCount = slice.loadUint(15);
    let oldStatus = (0, AccountStatus_1.loadAccountStatus)(slice);
    let endStatus = (0, AccountStatus_1.loadAccountStatus)(slice);
    let msgRef = slice.loadRef();
    let msgSlice = msgRef.beginParse();
    let inMessage = msgSlice.loadBit() ? (0, Message_1.loadMessage)(msgSlice.loadRef().beginParse()) : void 0;
    let outMessages = msgSlice.loadDict(Dictionary_1.Dictionary.Keys.Uint(15), Message_1.MessageValue);
    msgSlice.endParse();
    let totalFees = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
    let stateUpdate = (0, HashUpdate_1.loadHashUpdate)(slice.loadRef().beginParse());
    let description = (0, TransactionDescription_1.loadTransactionDescription)(slice.loadRef().beginParse());
    return {
      address,
      lt: lt2,
      prevTransactionHash,
      prevTransactionLt,
      now,
      outMessagesCount,
      oldStatus,
      endStatus,
      inMessage,
      outMessages,
      totalFees,
      stateUpdate,
      description,
      raw,
      hash: () => raw.hash()
    };
  }
  Transaction.loadTransaction = loadTransaction;
  function storeTransaction(src2) {
    return (builder2) => {
      builder2.storeUint(7, 4);
      builder2.storeUint(src2.address, 256);
      builder2.storeUint(src2.lt, 64);
      builder2.storeUint(src2.prevTransactionHash, 256);
      builder2.storeUint(src2.prevTransactionLt, 64);
      builder2.storeUint(src2.now, 32);
      builder2.storeUint(src2.outMessagesCount, 15);
      builder2.store((0, AccountStatus_1.storeAccountStatus)(src2.oldStatus));
      builder2.store((0, AccountStatus_1.storeAccountStatus)(src2.endStatus));
      let msgBuilder = (0, Builder_12.beginCell)();
      if (src2.inMessage) {
        msgBuilder.storeBit(true);
        msgBuilder.storeRef((0, Builder_12.beginCell)().store((0, Message_1.storeMessage)(src2.inMessage)));
      } else {
        msgBuilder.storeBit(false);
      }
      msgBuilder.storeDict(src2.outMessages);
      builder2.storeRef(msgBuilder);
      builder2.store((0, CurrencyCollection_1.storeCurrencyCollection)(src2.totalFees));
      builder2.storeRef((0, Builder_12.beginCell)().store((0, HashUpdate_1.storeHashUpdate)(src2.stateUpdate)));
      builder2.storeRef((0, Builder_12.beginCell)().store((0, TransactionDescription_1.storeTransactionDescription)(src2.description)));
    };
  }
  Transaction.storeTransaction = storeTransaction;
  return Transaction;
}
var hasRequired_export;
function require_export() {
  if (hasRequired_export) return _export;
  hasRequired_export = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadSimpleLibrary = exports.loadShardStateUnsplit = exports.storeShardIdent = exports.loadShardIdent = exports.storeShardAccounts = exports.loadShardAccounts = exports.ShardAccountRefValue = exports.storeShardAccount = exports.loadShardAccount = exports.ReserveMode = exports.SendMode = exports.storeMessageRelaxed = exports.loadMessageRelaxed = exports.storeMessage = exports.loadMessage = exports.loadMasterchainStateExtra = exports.storeHashUpdate = exports.loadHashUpdate = exports.storeExtraCurrency = exports.loadMaybeExtraCurrency = exports.loadExtraCurrency = exports.packExtraCurrencyDict = exports.packExtraCurrencyCell = exports.storeDepthBalanceInfo = exports.loadDepthBalanceInfo = exports.storeCurrencyCollection = exports.loadCurrencyCollection = exports.storeComputeSkipReason = exports.loadComputeSkipReason = exports.storeCommonMessageInfoRelaxed = exports.loadCommonMessageInfoRelaxed = exports.storeCommonMessageInfo = exports.loadCommonMessageInfo = exports.storeOutList = exports.loadOutList = exports.storeOutAction = exports.loadOutAction = exports.storeAccountStorage = exports.loadAccountStorage = exports.storeAccountStatusChange = exports.loadAccountStatusChange = exports.storeAccountStatus = exports.loadAccountStatus = exports.storeAccountState = exports.loadAccountState = exports.storeAccount = exports.loadAccount = exports.comment = exports.external = exports.internal = void 0;
    exports.storeTransactionsStoragePhase = exports.loadTransactionStoragePhase = exports.storeTransactionDescription = exports.loadTransactionDescription = exports.storeTransactionCreditPhase = exports.loadTransactionCreditPhase = exports.storeTransactionComputePhase = exports.loadTransactionComputePhase = exports.storeTransactionBouncePhase = exports.loadTransactionBouncePhase = exports.storeTransactionActionPhase = exports.loadTransactionActionPhase = exports.storeTransaction = exports.loadTransaction = exports.storeTickTock = exports.loadTickTock = exports.storeStorageUsed = exports.loadStorageUsed = exports.storeStorageInfo = exports.loadStorageInfo = exports.storeStateInit = exports.loadStateInit = exports.storeSplitMergeInfo = exports.loadSplitMergeInfo = exports.storeLibRef = exports.loadLibRef = exports.storeSimpleLibrary = void 0;
    var _helpers_1 = require_helpers();
    Object.defineProperty(exports, "internal", { enumerable: true, get: function() {
      return _helpers_1.internal;
    } });
    Object.defineProperty(exports, "external", { enumerable: true, get: function() {
      return _helpers_1.external;
    } });
    Object.defineProperty(exports, "comment", { enumerable: true, get: function() {
      return _helpers_1.comment;
    } });
    var Account_1 = requireAccount();
    Object.defineProperty(exports, "loadAccount", { enumerable: true, get: function() {
      return Account_1.loadAccount;
    } });
    Object.defineProperty(exports, "storeAccount", { enumerable: true, get: function() {
      return Account_1.storeAccount;
    } });
    var AccountState_1 = requireAccountState();
    Object.defineProperty(exports, "loadAccountState", { enumerable: true, get: function() {
      return AccountState_1.loadAccountState;
    } });
    Object.defineProperty(exports, "storeAccountState", { enumerable: true, get: function() {
      return AccountState_1.storeAccountState;
    } });
    var AccountStatus_1 = requireAccountStatus();
    Object.defineProperty(exports, "loadAccountStatus", { enumerable: true, get: function() {
      return AccountStatus_1.loadAccountStatus;
    } });
    Object.defineProperty(exports, "storeAccountStatus", { enumerable: true, get: function() {
      return AccountStatus_1.storeAccountStatus;
    } });
    var AccountStatusChange_1 = requireAccountStatusChange();
    Object.defineProperty(exports, "loadAccountStatusChange", { enumerable: true, get: function() {
      return AccountStatusChange_1.loadAccountStatusChange;
    } });
    Object.defineProperty(exports, "storeAccountStatusChange", { enumerable: true, get: function() {
      return AccountStatusChange_1.storeAccountStatusChange;
    } });
    var AccountStorage_1 = requireAccountStorage();
    Object.defineProperty(exports, "loadAccountStorage", { enumerable: true, get: function() {
      return AccountStorage_1.loadAccountStorage;
    } });
    Object.defineProperty(exports, "storeAccountStorage", { enumerable: true, get: function() {
      return AccountStorage_1.storeAccountStorage;
    } });
    var OutList_1 = requireOutList();
    Object.defineProperty(exports, "loadOutAction", { enumerable: true, get: function() {
      return OutList_1.loadOutAction;
    } });
    Object.defineProperty(exports, "storeOutAction", { enumerable: true, get: function() {
      return OutList_1.storeOutAction;
    } });
    Object.defineProperty(exports, "loadOutList", { enumerable: true, get: function() {
      return OutList_1.loadOutList;
    } });
    Object.defineProperty(exports, "storeOutList", { enumerable: true, get: function() {
      return OutList_1.storeOutList;
    } });
    var CommonMessageInfo_1 = requireCommonMessageInfo();
    Object.defineProperty(exports, "loadCommonMessageInfo", { enumerable: true, get: function() {
      return CommonMessageInfo_1.loadCommonMessageInfo;
    } });
    Object.defineProperty(exports, "storeCommonMessageInfo", { enumerable: true, get: function() {
      return CommonMessageInfo_1.storeCommonMessageInfo;
    } });
    var CommonMessageInfoRelaxed_1 = requireCommonMessageInfoRelaxed();
    Object.defineProperty(exports, "loadCommonMessageInfoRelaxed", { enumerable: true, get: function() {
      return CommonMessageInfoRelaxed_1.loadCommonMessageInfoRelaxed;
    } });
    Object.defineProperty(exports, "storeCommonMessageInfoRelaxed", { enumerable: true, get: function() {
      return CommonMessageInfoRelaxed_1.storeCommonMessageInfoRelaxed;
    } });
    var ComputeSkipReason_1 = requireComputeSkipReason();
    Object.defineProperty(exports, "loadComputeSkipReason", { enumerable: true, get: function() {
      return ComputeSkipReason_1.loadComputeSkipReason;
    } });
    Object.defineProperty(exports, "storeComputeSkipReason", { enumerable: true, get: function() {
      return ComputeSkipReason_1.storeComputeSkipReason;
    } });
    var CurrencyCollection_1 = requireCurrencyCollection();
    Object.defineProperty(exports, "loadCurrencyCollection", { enumerable: true, get: function() {
      return CurrencyCollection_1.loadCurrencyCollection;
    } });
    Object.defineProperty(exports, "storeCurrencyCollection", { enumerable: true, get: function() {
      return CurrencyCollection_1.storeCurrencyCollection;
    } });
    var DepthBalanceInfo_1 = requireDepthBalanceInfo();
    Object.defineProperty(exports, "loadDepthBalanceInfo", { enumerable: true, get: function() {
      return DepthBalanceInfo_1.loadDepthBalanceInfo;
    } });
    Object.defineProperty(exports, "storeDepthBalanceInfo", { enumerable: true, get: function() {
      return DepthBalanceInfo_1.storeDepthBalanceInfo;
    } });
    var ExtraCurrency_1 = requireExtraCurrency();
    Object.defineProperty(exports, "packExtraCurrencyCell", { enumerable: true, get: function() {
      return ExtraCurrency_1.packExtraCurrencyCell;
    } });
    Object.defineProperty(exports, "packExtraCurrencyDict", { enumerable: true, get: function() {
      return ExtraCurrency_1.packExtraCurrencyDict;
    } });
    Object.defineProperty(exports, "loadExtraCurrency", { enumerable: true, get: function() {
      return ExtraCurrency_1.loadExtraCurrency;
    } });
    Object.defineProperty(exports, "loadMaybeExtraCurrency", { enumerable: true, get: function() {
      return ExtraCurrency_1.loadMaybeExtraCurrency;
    } });
    Object.defineProperty(exports, "storeExtraCurrency", { enumerable: true, get: function() {
      return ExtraCurrency_1.storeExtraCurrency;
    } });
    var HashUpdate_1 = requireHashUpdate();
    Object.defineProperty(exports, "loadHashUpdate", { enumerable: true, get: function() {
      return HashUpdate_1.loadHashUpdate;
    } });
    Object.defineProperty(exports, "storeHashUpdate", { enumerable: true, get: function() {
      return HashUpdate_1.storeHashUpdate;
    } });
    var MasterchainStateExtra_1 = requireMasterchainStateExtra();
    Object.defineProperty(exports, "loadMasterchainStateExtra", { enumerable: true, get: function() {
      return MasterchainStateExtra_1.loadMasterchainStateExtra;
    } });
    var Message_1 = requireMessage();
    Object.defineProperty(exports, "loadMessage", { enumerable: true, get: function() {
      return Message_1.loadMessage;
    } });
    Object.defineProperty(exports, "storeMessage", { enumerable: true, get: function() {
      return Message_1.storeMessage;
    } });
    var MessageRelaxed_1 = requireMessageRelaxed();
    Object.defineProperty(exports, "loadMessageRelaxed", { enumerable: true, get: function() {
      return MessageRelaxed_1.loadMessageRelaxed;
    } });
    Object.defineProperty(exports, "storeMessageRelaxed", { enumerable: true, get: function() {
      return MessageRelaxed_1.storeMessageRelaxed;
    } });
    var SendMode_1 = requireSendMode();
    Object.defineProperty(exports, "SendMode", { enumerable: true, get: function() {
      return SendMode_1.SendMode;
    } });
    var ReserveMode_1 = requireReserveMode();
    Object.defineProperty(exports, "ReserveMode", { enumerable: true, get: function() {
      return ReserveMode_1.ReserveMode;
    } });
    var ShardAccount_1 = requireShardAccount();
    Object.defineProperty(exports, "loadShardAccount", { enumerable: true, get: function() {
      return ShardAccount_1.loadShardAccount;
    } });
    Object.defineProperty(exports, "storeShardAccount", { enumerable: true, get: function() {
      return ShardAccount_1.storeShardAccount;
    } });
    var ShardAccounts_1 = requireShardAccounts();
    Object.defineProperty(exports, "ShardAccountRefValue", { enumerable: true, get: function() {
      return ShardAccounts_1.ShardAccountRefValue;
    } });
    Object.defineProperty(exports, "loadShardAccounts", { enumerable: true, get: function() {
      return ShardAccounts_1.loadShardAccounts;
    } });
    Object.defineProperty(exports, "storeShardAccounts", { enumerable: true, get: function() {
      return ShardAccounts_1.storeShardAccounts;
    } });
    var ShardIdent_1 = requireShardIdent();
    Object.defineProperty(exports, "loadShardIdent", { enumerable: true, get: function() {
      return ShardIdent_1.loadShardIdent;
    } });
    Object.defineProperty(exports, "storeShardIdent", { enumerable: true, get: function() {
      return ShardIdent_1.storeShardIdent;
    } });
    var ShardStateUnsplit_1 = requireShardStateUnsplit();
    Object.defineProperty(exports, "loadShardStateUnsplit", { enumerable: true, get: function() {
      return ShardStateUnsplit_1.loadShardStateUnsplit;
    } });
    var SimpleLibrary_1 = requireSimpleLibrary();
    Object.defineProperty(exports, "loadSimpleLibrary", { enumerable: true, get: function() {
      return SimpleLibrary_1.loadSimpleLibrary;
    } });
    Object.defineProperty(exports, "storeSimpleLibrary", { enumerable: true, get: function() {
      return SimpleLibrary_1.storeSimpleLibrary;
    } });
    var LibRef_1 = requireLibRef();
    Object.defineProperty(exports, "loadLibRef", { enumerable: true, get: function() {
      return LibRef_1.loadLibRef;
    } });
    Object.defineProperty(exports, "storeLibRef", { enumerable: true, get: function() {
      return LibRef_1.storeLibRef;
    } });
    var SplitMergeInfo_1 = requireSplitMergeInfo();
    Object.defineProperty(exports, "loadSplitMergeInfo", { enumerable: true, get: function() {
      return SplitMergeInfo_1.loadSplitMergeInfo;
    } });
    Object.defineProperty(exports, "storeSplitMergeInfo", { enumerable: true, get: function() {
      return SplitMergeInfo_1.storeSplitMergeInfo;
    } });
    var StateInit_1 = requireStateInit();
    Object.defineProperty(exports, "loadStateInit", { enumerable: true, get: function() {
      return StateInit_1.loadStateInit;
    } });
    Object.defineProperty(exports, "storeStateInit", { enumerable: true, get: function() {
      return StateInit_1.storeStateInit;
    } });
    var StorageInfo_1 = requireStorageInfo();
    Object.defineProperty(exports, "loadStorageInfo", { enumerable: true, get: function() {
      return StorageInfo_1.loadStorageInfo;
    } });
    Object.defineProperty(exports, "storeStorageInfo", { enumerable: true, get: function() {
      return StorageInfo_1.storeStorageInfo;
    } });
    var StorageUsed_1 = requireStorageUsed();
    Object.defineProperty(exports, "loadStorageUsed", { enumerable: true, get: function() {
      return StorageUsed_1.loadStorageUsed;
    } });
    Object.defineProperty(exports, "storeStorageUsed", { enumerable: true, get: function() {
      return StorageUsed_1.storeStorageUsed;
    } });
    var TickTock_1 = requireTickTock();
    Object.defineProperty(exports, "loadTickTock", { enumerable: true, get: function() {
      return TickTock_1.loadTickTock;
    } });
    Object.defineProperty(exports, "storeTickTock", { enumerable: true, get: function() {
      return TickTock_1.storeTickTock;
    } });
    var Transaction_1 = requireTransaction();
    Object.defineProperty(exports, "loadTransaction", { enumerable: true, get: function() {
      return Transaction_1.loadTransaction;
    } });
    Object.defineProperty(exports, "storeTransaction", { enumerable: true, get: function() {
      return Transaction_1.storeTransaction;
    } });
    var TransactionActionPhase_1 = requireTransactionActionPhase();
    Object.defineProperty(exports, "loadTransactionActionPhase", { enumerable: true, get: function() {
      return TransactionActionPhase_1.loadTransactionActionPhase;
    } });
    Object.defineProperty(exports, "storeTransactionActionPhase", { enumerable: true, get: function() {
      return TransactionActionPhase_1.storeTransactionActionPhase;
    } });
    var TransactionBouncePhase_1 = requireTransactionBouncePhase();
    Object.defineProperty(exports, "loadTransactionBouncePhase", { enumerable: true, get: function() {
      return TransactionBouncePhase_1.loadTransactionBouncePhase;
    } });
    Object.defineProperty(exports, "storeTransactionBouncePhase", { enumerable: true, get: function() {
      return TransactionBouncePhase_1.storeTransactionBouncePhase;
    } });
    var TransactionComputePhase_1 = requireTransactionComputePhase();
    Object.defineProperty(exports, "loadTransactionComputePhase", { enumerable: true, get: function() {
      return TransactionComputePhase_1.loadTransactionComputePhase;
    } });
    Object.defineProperty(exports, "storeTransactionComputePhase", { enumerable: true, get: function() {
      return TransactionComputePhase_1.storeTransactionComputePhase;
    } });
    var TransactionCreditPhase_1 = requireTransactionCreditPhase();
    Object.defineProperty(exports, "loadTransactionCreditPhase", { enumerable: true, get: function() {
      return TransactionCreditPhase_1.loadTransactionCreditPhase;
    } });
    Object.defineProperty(exports, "storeTransactionCreditPhase", { enumerable: true, get: function() {
      return TransactionCreditPhase_1.storeTransactionCreditPhase;
    } });
    var TransactionDescription_1 = requireTransactionDescription();
    Object.defineProperty(exports, "loadTransactionDescription", { enumerable: true, get: function() {
      return TransactionDescription_1.loadTransactionDescription;
    } });
    Object.defineProperty(exports, "storeTransactionDescription", { enumerable: true, get: function() {
      return TransactionDescription_1.storeTransactionDescription;
    } });
    var TransactionStoragePhase_1 = requireTransactionStoragePhase();
    Object.defineProperty(exports, "loadTransactionStoragePhase", { enumerable: true, get: function() {
      return TransactionStoragePhase_1.loadTransactionStoragePhase;
    } });
    Object.defineProperty(exports, "storeTransactionsStoragePhase", { enumerable: true, get: function() {
      return TransactionStoragePhase_1.storeTransactionsStoragePhase;
    } });
  })(_export);
  return _export;
}
var openContract = {};
var hasRequiredOpenContract;
function requireOpenContract() {
  if (hasRequiredOpenContract) return openContract;
  hasRequiredOpenContract = 1;
  Object.defineProperty(openContract, "__esModule", { value: true });
  openContract.openContract = void 0;
  const Address_1 = requireAddress();
  const Cell_1 = requireCell();
  function openContract$1(src2, factory) {
    let address;
    let init = null;
    if (!Address_1.Address.isAddress(src2.address)) {
      throw Error("Invalid address");
    }
    address = src2.address;
    if (src2.init) {
      if (!(src2.init.code instanceof Cell_1.Cell)) {
        throw Error("Invalid init.code");
      }
      if (!(src2.init.data instanceof Cell_1.Cell)) {
        throw Error("Invalid init.data");
      }
      init = src2.init;
    }
    let executor = factory({ address, init });
    return new Proxy(src2, {
      get(target, prop) {
        const value = target[prop];
        if (typeof prop === "string" && (prop.startsWith("get") || prop.startsWith("send") || prop.startsWith("is"))) {
          if (typeof value === "function") {
            return (...args) => value.apply(target, [executor, ...args]);
          }
        }
        return value;
      }
    });
  }
  openContract.openContract = openContract$1;
  return openContract;
}
var ComputeError = {};
var hasRequiredComputeError;
function requireComputeError() {
  if (hasRequiredComputeError) return ComputeError;
  hasRequiredComputeError = 1;
  Object.defineProperty(ComputeError, "__esModule", { value: true });
  ComputeError.ComputeError = void 0;
  let ComputeError$1 = class ComputeError2 extends Error {
    constructor(message, exitCode, opts) {
      super(message);
      this.exitCode = exitCode;
      this.debugLogs = opts && opts.debugLogs ? opts.debugLogs : null;
      this.logs = opts && opts.logs ? opts.logs : null;
      Object.setPrototypeOf(this, ComputeError2.prototype);
    }
  };
  ComputeError.ComputeError = ComputeError$1;
  return ComputeError;
}
var getMethodId = {};
var hasRequiredGetMethodId;
function requireGetMethodId() {
  if (hasRequiredGetMethodId) return getMethodId;
  hasRequiredGetMethodId = 1;
  Object.defineProperty(getMethodId, "__esModule", { value: true });
  getMethodId.getMethodId = void 0;
  const TABLE = new Int16Array([
    0,
    4129,
    8258,
    12387,
    16516,
    20645,
    24774,
    28903,
    33032,
    37161,
    41290,
    45419,
    49548,
    53677,
    57806,
    61935,
    4657,
    528,
    12915,
    8786,
    21173,
    17044,
    29431,
    25302,
    37689,
    33560,
    45947,
    41818,
    54205,
    50076,
    62463,
    58334,
    9314,
    13379,
    1056,
    5121,
    25830,
    29895,
    17572,
    21637,
    42346,
    46411,
    34088,
    38153,
    58862,
    62927,
    50604,
    54669,
    13907,
    9842,
    5649,
    1584,
    30423,
    26358,
    22165,
    18100,
    46939,
    42874,
    38681,
    34616,
    63455,
    59390,
    55197,
    51132,
    18628,
    22757,
    26758,
    30887,
    2112,
    6241,
    10242,
    14371,
    51660,
    55789,
    59790,
    63919,
    35144,
    39273,
    43274,
    47403,
    23285,
    19156,
    31415,
    27286,
    6769,
    2640,
    14899,
    10770,
    56317,
    52188,
    64447,
    60318,
    39801,
    35672,
    47931,
    43802,
    27814,
    31879,
    19684,
    23749,
    11298,
    15363,
    3168,
    7233,
    60846,
    64911,
    52716,
    56781,
    44330,
    48395,
    36200,
    40265,
    32407,
    28342,
    24277,
    20212,
    15891,
    11826,
    7761,
    3696,
    65439,
    61374,
    57309,
    53244,
    48923,
    44858,
    40793,
    36728,
    37256,
    33193,
    45514,
    41451,
    53516,
    49453,
    61774,
    57711,
    4224,
    161,
    12482,
    8419,
    20484,
    16421,
    28742,
    24679,
    33721,
    37784,
    41979,
    46042,
    49981,
    54044,
    58239,
    62302,
    689,
    4752,
    8947,
    13010,
    16949,
    21012,
    25207,
    29270,
    46570,
    42443,
    38312,
    34185,
    62830,
    58703,
    54572,
    50445,
    13538,
    9411,
    5280,
    1153,
    29798,
    25671,
    21540,
    17413,
    42971,
    47098,
    34713,
    38840,
    59231,
    63358,
    50973,
    55100,
    9939,
    14066,
    1681,
    5808,
    26199,
    30326,
    17941,
    22068,
    55628,
    51565,
    63758,
    59695,
    39368,
    35305,
    47498,
    43435,
    22596,
    18533,
    30726,
    26663,
    6336,
    2273,
    14466,
    10403,
    52093,
    56156,
    60223,
    64286,
    35833,
    39896,
    43963,
    48026,
    19061,
    23124,
    27191,
    31254,
    2801,
    6864,
    10931,
    14994,
    64814,
    60687,
    56684,
    52557,
    48554,
    44427,
    40424,
    36297,
    31782,
    27655,
    23652,
    19525,
    15522,
    11395,
    7392,
    3265,
    61215,
    65342,
    53085,
    57212,
    44955,
    49082,
    36825,
    40952,
    28183,
    32310,
    20053,
    24180,
    11923,
    16050,
    3793,
    7920
  ]);
  function crc162(data) {
    if (!(data instanceof Buffer)) {
      data = Buffer.from(data);
    }
    let crc = 0;
    for (let index = 0; index < data.length; index++) {
      const byte = data[index];
      crc = (TABLE[(crc >> 8 ^ byte) & 255] ^ crc << 8) & 65535;
    }
    return crc;
  }
  function getMethodId$1(name) {
    return crc162(name) & 65535 | 65536;
  }
  getMethodId.getMethodId = getMethodId$1;
  return getMethodId;
}
var safeSign = {};
var hasRequiredSafeSign;
function requireSafeSign() {
  if (hasRequiredSafeSign) return safeSign;
  hasRequiredSafeSign = 1;
  Object.defineProperty(safeSign, "__esModule", { value: true });
  safeSign.safeSignVerify = safeSign.safeSign = void 0;
  const crypto_1 = requireDist$5();
  const MIN_SEED_LENGTH = 8;
  const MAX_SEED_LENGTH = 64;
  function createSafeSignHash(cell, seed) {
    let seedData = Buffer.from(seed);
    if (seedData.length > MAX_SEED_LENGTH) {
      throw Error("Seed can	 be longer than 64 bytes");
    }
    if (seedData.length < MIN_SEED_LENGTH) {
      throw Error("Seed must be at least 8 bytes");
    }
    return (0, crypto_1.sha256_sync)(Buffer.concat([Buffer.from([255, 255]), seedData, cell.hash()]));
  }
  function safeSign$1(cell, secretKey, seed = "ton-safe-sign-magic") {
    return (0, crypto_1.sign)(createSafeSignHash(cell, seed), secretKey);
  }
  safeSign.safeSign = safeSign$1;
  function safeSignVerify(cell, signature, publicKey, seed = "ton-safe-sign-magic") {
    return (0, crypto_1.signVerify)(createSafeSignHash(cell, seed), signature, publicKey);
  }
  safeSign.safeSignVerify = safeSignVerify;
  return safeSign;
}
var hasRequiredDist$4;
function requireDist$4() {
  if (hasRequiredDist$4) return dist$5;
  hasRequiredDist$4 = 1;
  (function(exports) {
    var __createBinding = dist$5 && dist$5.__createBinding || (Object.create ? (function(o4, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o4, k22, desc);
    }) : (function(o4, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o4[k22] = m2[k2];
    }));
    var __exportStar = dist$5 && dist$5.__exportStar || function(m2, exports2) {
      for (var p2 in m2) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.safeSignVerify = exports.safeSign = exports.getMethodId = exports.base32Encode = exports.base32Decode = exports.crc32c = exports.crc16 = exports.fromNano = exports.toNano = exports.ComputeError = exports.openContract = exports.TupleBuilder = exports.TupleReader = exports.serializeTuple = exports.parseTuple = exports.generateMerkleUpdate = exports.generateMerkleProofDirect = exports.generateMerkleProof = exports.exoticPruned = exports.exoticMerkleUpdate = exports.convertToMerkleProof = exports.exoticMerkleProof = exports.Dictionary = exports.Cell = exports.CellType = exports.Slice = exports.beginCell = exports.Builder = exports.BitBuilder = exports.BitReader = exports.BitString = exports.contractAddress = exports.ADNLAddress = exports.ExternalAddress = exports.address = exports.Address = void 0;
    var Address_1 = requireAddress();
    Object.defineProperty(exports, "Address", { enumerable: true, get: function() {
      return Address_1.Address;
    } });
    Object.defineProperty(exports, "address", { enumerable: true, get: function() {
      return Address_1.address;
    } });
    var ExternalAddress_1 = requireExternalAddress();
    Object.defineProperty(exports, "ExternalAddress", { enumerable: true, get: function() {
      return ExternalAddress_1.ExternalAddress;
    } });
    var ADNLAddress_1 = requireADNLAddress();
    Object.defineProperty(exports, "ADNLAddress", { enumerable: true, get: function() {
      return ADNLAddress_1.ADNLAddress;
    } });
    var contractAddress_1 = requireContractAddress();
    Object.defineProperty(exports, "contractAddress", { enumerable: true, get: function() {
      return contractAddress_1.contractAddress;
    } });
    var BitString_1 = requireBitString();
    Object.defineProperty(exports, "BitString", { enumerable: true, get: function() {
      return BitString_1.BitString;
    } });
    var BitReader_1 = requireBitReader();
    Object.defineProperty(exports, "BitReader", { enumerable: true, get: function() {
      return BitReader_1.BitReader;
    } });
    var BitBuilder_1 = requireBitBuilder();
    Object.defineProperty(exports, "BitBuilder", { enumerable: true, get: function() {
      return BitBuilder_1.BitBuilder;
    } });
    var Builder_12 = requireBuilder$1();
    Object.defineProperty(exports, "Builder", { enumerable: true, get: function() {
      return Builder_12.Builder;
    } });
    Object.defineProperty(exports, "beginCell", { enumerable: true, get: function() {
      return Builder_12.beginCell;
    } });
    var Slice_1 = requireSlice();
    Object.defineProperty(exports, "Slice", { enumerable: true, get: function() {
      return Slice_1.Slice;
    } });
    var CellType_1 = requireCellType();
    Object.defineProperty(exports, "CellType", { enumerable: true, get: function() {
      return CellType_1.CellType;
    } });
    var Cell_1 = requireCell();
    Object.defineProperty(exports, "Cell", { enumerable: true, get: function() {
      return Cell_1.Cell;
    } });
    var Dictionary_1 = requireDictionary();
    Object.defineProperty(exports, "Dictionary", { enumerable: true, get: function() {
      return Dictionary_1.Dictionary;
    } });
    var exoticMerkleProof_1 = requireExoticMerkleProof();
    Object.defineProperty(exports, "exoticMerkleProof", { enumerable: true, get: function() {
      return exoticMerkleProof_1.exoticMerkleProof;
    } });
    Object.defineProperty(exports, "convertToMerkleProof", { enumerable: true, get: function() {
      return exoticMerkleProof_1.convertToMerkleProof;
    } });
    var exoticMerkleUpdate_1 = requireExoticMerkleUpdate();
    Object.defineProperty(exports, "exoticMerkleUpdate", { enumerable: true, get: function() {
      return exoticMerkleUpdate_1.exoticMerkleUpdate;
    } });
    var exoticPruned_1 = requireExoticPruned();
    Object.defineProperty(exports, "exoticPruned", { enumerable: true, get: function() {
      return exoticPruned_1.exoticPruned;
    } });
    var generateMerkleProof_1 = requireGenerateMerkleProof();
    Object.defineProperty(exports, "generateMerkleProof", { enumerable: true, get: function() {
      return generateMerkleProof_1.generateMerkleProof;
    } });
    Object.defineProperty(exports, "generateMerkleProofDirect", { enumerable: true, get: function() {
      return generateMerkleProof_1.generateMerkleProofDirect;
    } });
    var generateMerkleUpdate_1 = requireGenerateMerkleUpdate();
    Object.defineProperty(exports, "generateMerkleUpdate", { enumerable: true, get: function() {
      return generateMerkleUpdate_1.generateMerkleUpdate;
    } });
    var tuple_1 = requireTuple();
    Object.defineProperty(exports, "parseTuple", { enumerable: true, get: function() {
      return tuple_1.parseTuple;
    } });
    Object.defineProperty(exports, "serializeTuple", { enumerable: true, get: function() {
      return tuple_1.serializeTuple;
    } });
    var reader_1 = requireReader();
    Object.defineProperty(exports, "TupleReader", { enumerable: true, get: function() {
      return reader_1.TupleReader;
    } });
    var builder_1 = requireBuilder();
    Object.defineProperty(exports, "TupleBuilder", { enumerable: true, get: function() {
      return builder_1.TupleBuilder;
    } });
    __exportStar(require_export(), exports);
    var openContract_1 = requireOpenContract();
    Object.defineProperty(exports, "openContract", { enumerable: true, get: function() {
      return openContract_1.openContract;
    } });
    var ComputeError_1 = requireComputeError();
    Object.defineProperty(exports, "ComputeError", { enumerable: true, get: function() {
      return ComputeError_1.ComputeError;
    } });
    var convert_1 = requireConvert();
    Object.defineProperty(exports, "toNano", { enumerable: true, get: function() {
      return convert_1.toNano;
    } });
    Object.defineProperty(exports, "fromNano", { enumerable: true, get: function() {
      return convert_1.fromNano;
    } });
    var crc16_1 = requireCrc16();
    Object.defineProperty(exports, "crc16", { enumerable: true, get: function() {
      return crc16_1.crc16;
    } });
    var crc32c_1 = requireCrc32c();
    Object.defineProperty(exports, "crc32c", { enumerable: true, get: function() {
      return crc32c_1.crc32c;
    } });
    var base32_1 = requireBase32();
    Object.defineProperty(exports, "base32Decode", { enumerable: true, get: function() {
      return base32_1.base32Decode;
    } });
    Object.defineProperty(exports, "base32Encode", { enumerable: true, get: function() {
      return base32_1.base32Encode;
    } });
    var getMethodId_1 = requireGetMethodId();
    Object.defineProperty(exports, "getMethodId", { enumerable: true, get: function() {
      return getMethodId_1.getMethodId;
    } });
    var safeSign_1 = requireSafeSign();
    Object.defineProperty(exports, "safeSign", { enumerable: true, get: function() {
      return safeSign_1.safeSign;
    } });
    Object.defineProperty(exports, "safeSignVerify", { enumerable: true, get: function() {
      return safeSign_1.safeSignVerify;
    } });
  })(dist$5);
  return dist$5;
}
var distExports$3 = requireDist$4();
const DEFAULT_DURABLE_EVENTS_CONFIG = {
  recoveryIntervalMs: 10 * 1e3,
  // 10 seconds
  processingTimeoutMs: 60 * 1e3,
  // 1 minute
  cleanupIntervalMs: 60 * 1e3,
  // 1 minute
  retentionMs: 60 * 10 * 1e3
  // 10 minutes
};
class JettonError extends Error {
  code;
  details;
  constructor(message, code, details) {
    super(message);
    this.code = code;
    this.details = details;
    this.name = "JettonError";
  }
}
var JettonErrorCode;
(function(JettonErrorCode2) {
  JettonErrorCode2["INVALID_ADDRESS"] = "INVALID_ADDRESS";
  JettonErrorCode2["JETTON_NOT_FOUND"] = "JETTON_NOT_FOUND";
  JettonErrorCode2["INSUFFICIENT_BALANCE"] = "INSUFFICIENT_BALANCE";
  JettonErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
  JettonErrorCode2["INVALID_AMOUNT"] = "INVALID_AMOUNT";
  JettonErrorCode2["PREPARATION_FAILED"] = "PREPARATION_FAILED";
})(JettonErrorCode || (JettonErrorCode = {}));
var LogLevel;
(function(LogLevel2) {
  LogLevel2[LogLevel2["DEBUG"] = 0] = "DEBUG";
  LogLevel2[LogLevel2["INFO"] = 1] = "INFO";
  LogLevel2[LogLevel2["WARN"] = 2] = "WARN";
  LogLevel2[LogLevel2["ERROR"] = 3] = "ERROR";
  LogLevel2[LogLevel2["NONE"] = 4] = "NONE";
})(LogLevel || (LogLevel = {}));
class Logger {
  config;
  parent;
  static defaultConfig = {
    level: LogLevel.INFO,
    prefix: "TonWalletKit",
    enableTimestamp: true,
    enableStackTrace: false
  };
  constructor(config) {
    this.parent = config?.parent;
    this.config = { ...Logger.defaultConfig, ...config };
    if (this.parent) {
      this.config = {
        ...this.parent.config,
        ...config,
        // Build hierarchical prefix
        prefix: this.buildHierarchicalPrefix(config?.prefix)
      };
    }
  }
  /**
   * Update logger configuration
   */
  configure(config) {
    this.config = { ...this.config, ...config };
  }
  /**
   * Create a child logger with a prefix that inherits from this logger
   */
  createChild(prefix, config) {
    return new Logger({
      ...config,
      parent: this,
      prefix
    });
  }
  /**
   * Build hierarchical prefix by combining parent prefix with current prefix
   */
  buildHierarchicalPrefix(currentPrefix) {
    if (!this.parent || !currentPrefix) {
      return currentPrefix || this.parent?.config.prefix || "";
    }
    const parentPrefix = this.parent.config.prefix;
    if (!parentPrefix) {
      return currentPrefix;
    }
    return `${parentPrefix}:${currentPrefix}`;
  }
  /**
   * Get the full hierarchical prefix for this logger
   */
  getPrefix() {
    return this.config.prefix || "";
  }
  /**
   * Get the parent logger if it exists
   */
  getParent() {
    return this.parent;
  }
  /**
   * Log debug messages
   */
  debug(message, context) {
    if (this.config.level <= LogLevel.DEBUG) {
      this.log("DEBUG", message, context);
    }
  }
  /**
   * Log info messages
   */
  info(message, context) {
    if (this.config.level <= LogLevel.INFO) {
      this.log("INFO", message, context);
    }
  }
  /**
   * Log warning messages
   */
  warn(message, context) {
    if (this.config.level <= LogLevel.WARN) {
      this.log("WARN", message, context);
    }
  }
  /**
   * Log error messages
   */
  error(message, context) {
    if (this.config.level <= LogLevel.ERROR) {
      this.log("ERROR", message, context);
    }
  }
  /**
   * Internal logging method
   */
  log(level, message, context) {
    const timestamp = this.config.enableTimestamp ? (/* @__PURE__ */ new Date()).toISOString() : "";
    const prefix = this.config.prefix ? `[${this.config.prefix}]` : "";
    let logMessage = "";
    if (timestamp) {
      logMessage += `${timestamp} `;
    }
    if (prefix) {
      logMessage += `${prefix} `;
    }
    logMessage += `${level}: ${message}`;
    const logArgs = [logMessage];
    if (context && Object.keys(context).length > 0) {
      logArgs.push(context);
    }
    switch (level) {
      case "DEBUG":
        console.debug(...logArgs);
        break;
      case "INFO":
        console.info(...logArgs);
        break;
      case "WARN":
        console.warn(...logArgs);
        break;
      case "ERROR":
        console.error(...logArgs);
        if (this.config.enableStackTrace) {
          console.trace();
        }
        break;
    }
  }
}
const globalLogger = new Logger({
  level: LogLevel.DEBUG,
  enableStackTrace: true
});
function delay(ms) {
  return new Promise((resolve) => setTimeout(() => {
    resolve();
  }, ms));
}
async function CallForSuccess(toCall, attempts = 20, delayMs = 100) {
  if (typeof toCall !== "function") {
    throw new Error("unknown input");
  }
  let i = 0;
  let lastError;
  while (i < attempts) {
    try {
      const res = await toCall();
      return res;
    } catch (err) {
      lastError = err;
      i++;
      await delay(delayMs);
    }
  }
  throw lastError;
}
class LocalStorageAdapter {
  prefix;
  maxRetries;
  retryDelay;
  localStorage;
  constructor(config = {}, _localStorage) {
    this.prefix = config.prefix || "tonwallet:";
    this.maxRetries = config.maxRetries || 3;
    this.retryDelay = config.retryDelay || 100;
    if (_localStorage) {
      this.localStorage = _localStorage;
    } else {
      this.localStorage = window.localStorage;
    }
  }
  async get(key2) {
    return this.withRetry(async () => {
      const fullKey = this.prefix + key2;
      const item = this.localStorage.getItem(fullKey);
      return item ? JSON.parse(item) : null;
    });
  }
  async set(key2, value) {
    return this.withRetry(async () => {
      const fullKey = this.prefix + key2;
      this.localStorage.setItem(fullKey, JSON.stringify(value));
    });
  }
  async remove(key2) {
    return this.withRetry(async () => {
      const fullKey = this.prefix + key2;
      this.localStorage.removeItem(fullKey);
    });
  }
  async clear() {
    return this.withRetry(async () => {
      const keysToRemove = this.getPrefixedKeys();
      keysToRemove.forEach((key2) => this.localStorage.removeItem(key2));
    });
  }
  getPrefixedKeys() {
    const keys = [];
    for (let i = 0; i < this.localStorage.length; i++) {
      const key2 = this.localStorage.key(i);
      if (key2 && key2.startsWith(this.prefix)) {
        keys.push(key2);
      }
    }
    return keys;
  }
  async withRetry(operation) {
    return CallForSuccess(operation, this.maxRetries, this.retryDelay);
  }
}
class MemoryStorageAdapter {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  store = /* @__PURE__ */ new Map();
  prefix;
  constructor(config = {}) {
    this.prefix = config.prefix || "";
  }
  async get(key2) {
    const fullKey = this.prefix + key2;
    return this.store.get(fullKey) || null;
  }
  async set(key2, value) {
    const fullKey = this.prefix + key2;
    this.store.set(fullKey, value);
  }
  async remove(key2) {
    const fullKey = this.prefix + key2;
    this.store.delete(fullKey);
  }
  async clear() {
    if (this.prefix) {
      const keysToDelete = Array.from(this.store.keys()).filter((key2) => key2.startsWith(this.prefix));
      keysToDelete.forEach((key2) => this.store.delete(key2));
    } else {
      this.store.clear();
    }
  }
  /**
   * Get current store size (for testing/debugging)
   */
  getSize() {
    return this.store.size;
  }
  /**
   * Get all keys (for testing/debugging)
   */
  getKeys() {
    return Array.from(this.store.keys());
  }
}
const log$i = globalLogger.createChild("StorageAdapter");
function createStorageAdapter(config = {}) {
  if (typeof localStorage !== "undefined") {
    try {
      return new LocalStorageAdapter(config);
    } catch (error2) {
      log$i.warn("Failed to create LocalStorageAdapter, falling back to memory", { error: error2 });
    }
  }
  if (config.allowMemory) {
    return new MemoryStorageAdapter(config);
  } else {
    throw new Error("No storage adapter available");
  }
}
function validateWallet(_wallet, _context = {}) {
  const errors2 = [];
  const warnings = [];
  return {
    isValid: errors2.length === 0,
    errors: errors2,
    warnings: warnings.length > 0 ? warnings : void 0
  };
}
function validateBridgeEvent(event, context = {}) {
  const errors2 = [];
  if (!event || typeof event !== "object") {
    errors2.push("event must be an object");
    return { isValid: false, errors: errors2 };
  }
  if (!event.id || typeof event.id !== "string") {
    errors2.push("event.id must be a non-empty string");
  }
  if (!event.method || typeof event.method !== "string") {
    errors2.push("event.method must be a non-empty string");
  } else if (!isValidEventMethod(event.method)) {
    if (context.strict) {
      errors2.push(`unsupported event method: ${event.method}`);
    }
  }
  if (event.params && typeof event.params !== "object") {
    errors2.push("event.params must be an object if provided");
  }
  if (event.sessionId && typeof event.sessionId !== "string") {
    errors2.push("event.sessionId must be a string if provided");
  }
  if (event.timestamp && typeof event.timestamp !== "number") {
    errors2.push("event.timestamp must be a number if provided");
  }
  return {
    isValid: errors2.length === 0,
    errors: errors2
  };
}
function isValidEventMethod(method) {
  const supportedMethods = [
    "connect",
    "sendTransaction",
    "signData",
    "disconnect",
    "tonconnect_connect",
    "tonconnect_sendTransaction",
    "tonconnect_signData",
    "tonconnect_disconnect",
    "wallet_connect",
    "wallet_disconnect",
    "personal_sign"
  ];
  return supportedMethods.includes(method);
}
function formatWalletAddress(address, isTestnet = false) {
  if (typeof address === "string") {
    return distExports$3.Address.parse(address).toString({ bounceable: false, testOnly: isTestnet });
  }
  return address.toString({ bounceable: false, testOnly: isTestnet });
}
function isValidAddress(address) {
  if (typeof address !== "string") {
    return false;
  }
  try {
    distExports$3.Address.parse(address);
  } catch (_) {
    return false;
  }
  return true;
}
function isFriendlyTonAddress(address) {
  try {
    distExports$3.Address.parseFriendly(address);
  } catch (_) {
    return false;
  }
  return true;
}
function validateTransactionMessages(messages, isTonConnect = true) {
  const errors2 = [];
  if (!Array.isArray(messages)) {
    errors2.push("messages must be an array");
    return { isValid: false, errors: errors2 };
  }
  if (messages.length === 0) {
    errors2.push("messages array cannot be empty");
    return { isValid: false, errors: errors2 };
  }
  messages.forEach((msg, index) => {
    const msgErrors = validateTransactionMessage(msg, isTonConnect).errors;
    msgErrors.forEach((error2) => {
      errors2.push(`message[${index}]: ${error2}`);
    });
  });
  return {
    isValid: errors2.length === 0,
    errors: errors2
  };
}
function validateTransactionMessage(message, isTonConnect = true) {
  const errors2 = [];
  if (typeof message !== "object") {
    return { isValid: false, errors: ["Invalid message"] };
  }
  if (message === null || message === void 0) {
    return { isValid: false, errors: ["Invalid message"] };
  }
  if (isTonConnect && typeof message.mode !== "undefined") {
    errors2.push("mode must be undefined for tonconnect!");
  }
  const objErrors = validateMessageObject(message).errors;
  errors2.push(...objErrors);
  return {
    isValid: errors2.length === 0,
    errors: errors2
  };
}
function validateMessageObject(message) {
  const errors2 = [];
  if (!message.address || typeof message.address !== "string") {
    errors2.push("to address is required and must be a string");
  } else {
    if (!isFriendlyTonAddress(message.address)) {
      errors2.push("to address must be a valid friendly TON address");
    }
  }
  if (message.amount !== void 0) {
    if (!isValidNanotonAmount(message.amount)) {
      errors2.push("value must be a valid nanonton amount (string of digits)");
    }
  } else {
    errors2.push("value must be a valid nanonton amount (string of digits)");
  }
  if (message.payload) {
    if (typeof message.payload !== "string") {
      errors2.push("payload must be a string if provided");
    } else {
      if (!isValidBOC(message.payload)) {
        errors2.push("payload must be a valid base64 string if provided");
      }
    }
  }
  if (message.stateInit) {
    if (typeof message.stateInit !== "string") {
      errors2.push("stateInit must be a string if provided");
    } else {
      if (!isValidBOC(message.stateInit)) {
        errors2.push("stateInit must be a valid base64 string if provided");
      }
    }
  }
  return {
    isValid: errors2.length === 0,
    errors: errors2
  };
}
function isValidNanotonAmount(amount) {
  if (typeof amount !== "string") {
    return false;
  }
  const amountStr = String(amount);
  const parsed = BigInt(amountStr);
  return parsed >= 0 && parsed.toString() === amountStr;
}
function isValidBOC(bocString) {
  try {
    distExports$3.Cell.fromBase64(bocString);
    return true;
  } catch {
    return false;
  }
}
const log$h = globalLogger.createChild("WalletManager");
class WalletManager {
  wallets = /* @__PURE__ */ new Map();
  storageAdapter;
  // private storageKey = 'wallets';
  constructor(storageAdapter) {
    this.storageAdapter = storageAdapter;
  }
  /**
   * Initialize manager and load persisted wallets
   */
  async initialize() {
  }
  /**
   * Get all wallets as array
   */
  getWallets() {
    return Array.from(this.wallets.values());
  }
  /**
   * Get wallet by public key
   */
  getWallet(address) {
    return this.wallets.get(address) || void 0;
  }
  /**
   * Add a wallet with validation
   */
  async addWallet(wallet) {
    const validation = validateWallet();
    if (!validation.isValid) {
      throw new Error(`Invalid wallet: ${validation.errors.join(", ")}`);
    }
    if (this.wallets.has(wallet.getAddress())) {
      return true;
    }
    this.wallets.set(wallet.getAddress(), wallet);
    return true;
  }
  /**
   * Remove wallet by public key
   */
  async removeWallet(addressOrWallet) {
    const address = typeof addressOrWallet === "string" ? addressOrWallet : addressOrWallet.getAddress();
    const removed = this.wallets.delete(address);
    return removed;
  }
  /**
   * Update existing wallet
   */
  async updateWallet(wallet) {
    if (!this.wallets.has(wallet.getAddress())) {
      throw new Error(`Wallet with address ${wallet.getAddress()} not found`);
    }
    const validation = validateWallet();
    if (!validation.isValid) {
      throw new Error(`Invalid wallet: ${validation.errors.join(", ")}`);
    }
    this.wallets.set(wallet.getAddress(), wallet);
  }
  /**
   * Clear all wallets
   */
  async clearWallets() {
    this.wallets.clear();
  }
  /**
   * Find wallet by address (async since getAddress is async)
   */
  async findWalletByAddress(address) {
    for (const wallet of this.wallets.values()) {
      try {
        const walletAddress = wallet.getAddress();
        if (walletAddress === address) {
          return wallet;
        }
      } catch (error2) {
        log$h.warn("Failed to get address for wallet", { publicKey: wallet.publicKey, error: error2 });
      }
    }
    return null;
  }
  /**
   * Get wallet count
   */
  getWalletCount() {
    return this.wallets.size;
  }
  /**
   * Check if wallet exists
   */
  hasWallet(publicKey) {
    return this.wallets.has(publicKey);
  }
}
const log$g = globalLogger.createChild("SessionManager");
class SessionManager {
  sessions = /* @__PURE__ */ new Map();
  storageAdapter;
  walletManager;
  storageKey = "sessions";
  constructor(storageAdapter, walletManager) {
    this.storageAdapter = storageAdapter;
    this.walletManager = walletManager;
  }
  /**
   * Initialize manager and load persisted sessions
   */
  async initialize() {
    await this.loadSessions();
  }
  /**
   * Create new session
   */
  async createSession(sessionId, dAppName, domain, dAppIconUrl, dAppDescription, wallet, { disablePersist = false } = {}) {
    const now = /* @__PURE__ */ new Date();
    const randomKeyPair = new SessionCrypto().stringifyKeypair();
    const sessionData = {
      sessionId,
      dAppName,
      domain,
      walletAddress: wallet?.getAddress() ?? "",
      createdAt: now.toISOString(),
      lastActivityAt: now.toISOString(),
      privateKey: randomKeyPair.secretKey,
      publicKey: randomKeyPair.publicKey,
      dAppIconUrl,
      dAppDescription
    };
    if (disablePersist) {
      return SessionManager.toSessionData(sessionData);
    }
    this.sessions.set(sessionId, sessionData);
    await this.persistSessions();
    return await this.getSession(sessionId);
  }
  static toSessionData(session) {
    return {
      sessionId: session.sessionId,
      dAppName: session.dAppName,
      walletAddress: session.walletAddress,
      // wallet: thiscc.walletManager.getWallet(session.walletAddress),
      privateKey: session.privateKey,
      publicKey: session.publicKey,
      createdAt: session.createdAt,
      lastActivityAt: session.lastActivityAt,
      domain: session.domain,
      dAppIconUrl: session.dAppIconUrl,
      dAppDescription: session.dAppDescription
    };
  }
  // async getSessionData(sessionId: string): Promise<SessionData | undefined> {}
  /**
   * Get session by ID
   */
  async getSession(sessionId) {
    const session = this.sessions.get(sessionId);
    if (session) {
      return {
        sessionId: session.sessionId,
        dAppName: session.dAppName,
        walletAddress: session.walletAddress,
        privateKey: session.privateKey,
        publicKey: session.publicKey,
        createdAt: session.createdAt,
        lastActivityAt: session.lastActivityAt,
        domain: session.domain,
        dAppIconUrl: session.dAppIconUrl,
        dAppDescription: session.dAppDescription
      };
    }
    return void 0;
  }
  async getSessionByDomain(domain) {
    for (const session of this.sessions.values()) {
      if (session.domain === domain) {
        return this.getSession(session.sessionId);
      }
    }
    return void 0;
  }
  /**
   * Get all sessions as array
   */
  getSessions() {
    return Array.from(this.sessions.values());
  }
  /**
   * Get sessions for specific wallet
   */
  getSessionsForWallet(wallet) {
    return this.getSessions().filter((session) => session.walletAddress === wallet.getAddress());
  }
  /**
   * Update session activity timestamp
   */
  async updateSessionActivity(sessionId) {
    const session = this.sessions.get(sessionId);
    if (session) {
      session.lastActivityAt = (/* @__PURE__ */ new Date()).toISOString();
      await this.persistSessions();
    }
  }
  /**
   * Remove session by ID
   */
  async removeSession(sessionId) {
    const removed = this.sessions.delete(sessionId);
    if (removed) {
      await this.persistSessions();
    }
    return removed;
  }
  /**
   * Remove all sessions for a wallet
   */
  async removeSessionsForWallet(wallet) {
    const sessionsToRemove = this.getSessionsForWallet(wallet);
    let removedCount = 0;
    for (const session of sessionsToRemove) {
      if (this.sessions.delete(session.sessionId)) {
        removedCount++;
      }
    }
    if (removedCount > 0) {
      await this.persistSessions();
    }
    return removedCount;
  }
  /**
   * Clear all sessions
   */
  async clearSessions() {
    this.sessions.clear();
    await this.persistSessions();
  }
  /**
   * Get session count
   */
  getSessionCount() {
    return this.sessions.size;
  }
  /**
   * Check if session exists
   */
  hasSession(sessionId) {
    return this.sessions.has(sessionId);
  }
  /**
   * Clean up expired sessions (optional cleanup based on inactivity)
   */
  async cleanupInactiveSessions(maxInactiveHours = 24) {
    const cutoffTime = /* @__PURE__ */ new Date();
    cutoffTime.setHours(cutoffTime.getHours() - maxInactiveHours);
    const sessionsToRemove = [];
    for (const [sessionId, session] of this.sessions.entries()) {
      if (new Date(session.lastActivityAt) < cutoffTime) {
        sessionsToRemove.push(sessionId);
      }
    }
    for (const sessionId of sessionsToRemove) {
      this.sessions.delete(sessionId);
    }
    if (sessionsToRemove.length > 0) {
      await this.persistSessions();
    }
    return sessionsToRemove.length;
  }
  /**
   * Get sessions as the format expected by the main API
   */
  getSessionsForAPI() {
    return this.getSessions().map((session) => ({
      sessionId: session.sessionId,
      dAppName: session.dAppName,
      walletAddress: session.walletAddress,
      dAppUrl: session.domain,
      dAppIconUrl: session.dAppIconUrl
    }));
  }
  /**
   * Load sessions from storage
   */
  async loadSessions() {
    try {
      const sessionData = await this.storageAdapter.get(this.storageKey);
      if (sessionData && Array.isArray(sessionData)) {
        for (const session of sessionData) {
          this.sessions.set(session.sessionId, {
            ...session
            // wallet,
            // createdAt: session.createdAt,
            // lastActivityAt: session.lastActivityAt,
          });
        }
        log$g.debug("Loaded session metadata", { count: sessionData.length });
      }
    } catch (error2) {
      log$g.warn("Failed to load sessions from storage", { error: error2 });
    }
  }
  /**
   * Persist session metadata to storage
   */
  async persistSessions() {
    try {
      const sessionMetadata = this.getSessions().map((session) => ({
        sessionId: session.sessionId,
        dAppName: session.dAppName,
        domain: session.domain,
        walletAddress: session.walletAddress,
        createdAt: session.createdAt,
        lastActivityAt: session.lastActivityAt,
        privateKey: session.privateKey,
        publicKey: session.publicKey,
        dAppIconUrl: session.dAppIconUrl,
        dAppDescription: session.dAppDescription
      }));
      await this.storageAdapter.set(this.storageKey, sessionMetadata);
    } catch (error2) {
      log$g.warn("Failed to persist sessions to storage", { error: error2 });
    }
  }
}
var util$9;
var hasRequiredUtil$1;
function requireUtil$1() {
  if (hasRequiredUtil$1) return util$9;
  hasRequiredUtil$1 = 1;
  const ERROR_MSG_INPUT = "Input must be an string, Buffer or Uint8Array";
  function normalizeInput(input) {
    let ret;
    if (input instanceof Uint8Array) {
      ret = input;
    } else if (typeof input === "string") {
      const encoder = new TextEncoder();
      ret = encoder.encode(input);
    } else {
      throw new Error(ERROR_MSG_INPUT);
    }
    return ret;
  }
  function toHex(bytes) {
    return Array.prototype.map.call(bytes, function(n) {
      return (n < 16 ? "0" : "") + n.toString(16);
    }).join("");
  }
  function uint32ToHex(val) {
    return (4294967296 + val).toString(16).substring(1);
  }
  function debugPrint(label, arr, size) {
    let msg = "\n" + label + " = ";
    for (let i = 0; i < arr.length; i += 2) {
      if (size === 32) {
        msg += uint32ToHex(arr[i]).toUpperCase();
        msg += " ";
        msg += uint32ToHex(arr[i + 1]).toUpperCase();
      } else if (size === 64) {
        msg += uint32ToHex(arr[i + 1]).toUpperCase();
        msg += uint32ToHex(arr[i]).toUpperCase();
      } else throw new Error("Invalid size " + size);
      if (i % 6 === 4) {
        msg += "\n" + new Array(label.length + 4).join(" ");
      } else if (i < arr.length - 2) {
        msg += " ";
      }
    }
    console.log(msg);
  }
  function testSpeed(hashFn, N2, M2) {
    let startMs = (/* @__PURE__ */ new Date()).getTime();
    const input = new Uint8Array(N2);
    for (let i = 0; i < N2; i++) {
      input[i] = i % 256;
    }
    const genMs = (/* @__PURE__ */ new Date()).getTime();
    console.log("Generated random input in " + (genMs - startMs) + "ms");
    startMs = genMs;
    for (let i = 0; i < M2; i++) {
      const hashHex = hashFn(input);
      const hashMs = (/* @__PURE__ */ new Date()).getTime();
      const ms = hashMs - startMs;
      startMs = hashMs;
      console.log("Hashed in " + ms + "ms: " + hashHex.substring(0, 20) + "...");
      console.log(
        Math.round(N2 / (1 << 20) / (ms / 1e3) * 100) / 100 + " MB PER SECOND"
      );
    }
  }
  util$9 = {
    normalizeInput,
    toHex,
    debugPrint,
    testSpeed
  };
  return util$9;
}
var blake2b_1;
var hasRequiredBlake2b;
function requireBlake2b() {
  if (hasRequiredBlake2b) return blake2b_1;
  hasRequiredBlake2b = 1;
  const util2 = requireUtil$1();
  function ADD64AA(v3, a2, b2) {
    const o0 = v3[a2] + v3[b2];
    let o1 = v3[a2 + 1] + v3[b2 + 1];
    if (o0 >= 4294967296) {
      o1++;
    }
    v3[a2] = o0;
    v3[a2 + 1] = o1;
  }
  function ADD64AC(v3, a2, b0, b1) {
    let o0 = v3[a2] + b0;
    if (b0 < 0) {
      o0 += 4294967296;
    }
    let o1 = v3[a2 + 1] + b1;
    if (o0 >= 4294967296) {
      o1++;
    }
    v3[a2] = o0;
    v3[a2 + 1] = o1;
  }
  function B2B_GET32(arr, i) {
    return arr[i] ^ arr[i + 1] << 8 ^ arr[i + 2] << 16 ^ arr[i + 3] << 24;
  }
  function B2B_G(a2, b2, c, d, ix, iy) {
    const x0 = m2[ix];
    const x1 = m2[ix + 1];
    const y0 = m2[iy];
    const y1 = m2[iy + 1];
    ADD64AA(v2, a2, b2);
    ADD64AC(v2, a2, x0, x1);
    let xor0 = v2[d] ^ v2[a2];
    let xor1 = v2[d + 1] ^ v2[a2 + 1];
    v2[d] = xor1;
    v2[d + 1] = xor0;
    ADD64AA(v2, c, d);
    xor0 = v2[b2] ^ v2[c];
    xor1 = v2[b2 + 1] ^ v2[c + 1];
    v2[b2] = xor0 >>> 24 ^ xor1 << 8;
    v2[b2 + 1] = xor1 >>> 24 ^ xor0 << 8;
    ADD64AA(v2, a2, b2);
    ADD64AC(v2, a2, y0, y1);
    xor0 = v2[d] ^ v2[a2];
    xor1 = v2[d + 1] ^ v2[a2 + 1];
    v2[d] = xor0 >>> 16 ^ xor1 << 16;
    v2[d + 1] = xor1 >>> 16 ^ xor0 << 16;
    ADD64AA(v2, c, d);
    xor0 = v2[b2] ^ v2[c];
    xor1 = v2[b2 + 1] ^ v2[c + 1];
    v2[b2] = xor1 >>> 31 ^ xor0 << 1;
    v2[b2 + 1] = xor0 >>> 31 ^ xor1 << 1;
  }
  const BLAKE2B_IV32 = new Uint32Array([
    4089235720,
    1779033703,
    2227873595,
    3144134277,
    4271175723,
    1013904242,
    1595750129,
    2773480762,
    2917565137,
    1359893119,
    725511199,
    2600822924,
    4215389547,
    528734635,
    327033209,
    1541459225
  ]);
  const SIGMA8 = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3,
    11,
    8,
    12,
    0,
    5,
    2,
    15,
    13,
    10,
    14,
    3,
    6,
    7,
    1,
    9,
    4,
    7,
    9,
    3,
    1,
    13,
    12,
    11,
    14,
    2,
    6,
    5,
    10,
    4,
    0,
    15,
    8,
    9,
    0,
    5,
    7,
    2,
    4,
    10,
    15,
    14,
    1,
    11,
    12,
    6,
    8,
    3,
    13,
    2,
    12,
    6,
    10,
    0,
    11,
    8,
    3,
    4,
    13,
    7,
    5,
    15,
    14,
    1,
    9,
    12,
    5,
    1,
    15,
    14,
    13,
    4,
    10,
    0,
    7,
    6,
    3,
    9,
    2,
    8,
    11,
    13,
    11,
    7,
    14,
    12,
    1,
    3,
    9,
    5,
    0,
    15,
    4,
    8,
    6,
    2,
    10,
    6,
    15,
    14,
    9,
    11,
    3,
    0,
    8,
    12,
    2,
    13,
    7,
    1,
    4,
    10,
    5,
    10,
    2,
    8,
    4,
    7,
    6,
    1,
    5,
    15,
    11,
    9,
    14,
    3,
    12,
    13,
    0,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3
  ];
  const SIGMA82 = new Uint8Array(
    SIGMA8.map(function(x2) {
      return x2 * 2;
    })
  );
  const v2 = new Uint32Array(32);
  const m2 = new Uint32Array(32);
  function blake2bCompress(ctx, last) {
    let i = 0;
    for (i = 0; i < 16; i++) {
      v2[i] = ctx.h[i];
      v2[i + 16] = BLAKE2B_IV32[i];
    }
    v2[24] = v2[24] ^ ctx.t;
    v2[25] = v2[25] ^ ctx.t / 4294967296;
    if (last) {
      v2[28] = ~v2[28];
      v2[29] = ~v2[29];
    }
    for (i = 0; i < 32; i++) {
      m2[i] = B2B_GET32(ctx.b, 4 * i);
    }
    for (i = 0; i < 12; i++) {
      B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1]);
      B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3]);
      B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5]);
      B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7]);
      B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9]);
      B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11]);
      B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13]);
      B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15]);
    }
    for (i = 0; i < 16; i++) {
      ctx.h[i] = ctx.h[i] ^ v2[i] ^ v2[i + 16];
    }
  }
  const parameterBlock = new Uint8Array([
    0,
    0,
    0,
    0,
    //  0: outlen, keylen, fanout, depth
    0,
    0,
    0,
    0,
    //  4: leaf length, sequential mode
    0,
    0,
    0,
    0,
    //  8: node offset
    0,
    0,
    0,
    0,
    // 12: node offset
    0,
    0,
    0,
    0,
    // 16: node depth, inner length, rfu
    0,
    0,
    0,
    0,
    // 20: rfu
    0,
    0,
    0,
    0,
    // 24: rfu
    0,
    0,
    0,
    0,
    // 28: rfu
    0,
    0,
    0,
    0,
    // 32: salt
    0,
    0,
    0,
    0,
    // 36: salt
    0,
    0,
    0,
    0,
    // 40: salt
    0,
    0,
    0,
    0,
    // 44: salt
    0,
    0,
    0,
    0,
    // 48: personal
    0,
    0,
    0,
    0,
    // 52: personal
    0,
    0,
    0,
    0,
    // 56: personal
    0,
    0,
    0,
    0
    // 60: personal
  ]);
  function blake2bInit(outlen, key2, salt, personal) {
    if (outlen === 0 || outlen > 64) {
      throw new Error("Illegal output length, expected 0 < length <= 64");
    }
    if (key2 && key2.length > 64) {
      throw new Error("Illegal key, expected Uint8Array with 0 < length <= 64");
    }
    if (salt && salt.length !== 16) {
      throw new Error("Illegal salt, expected Uint8Array with length is 16");
    }
    if (personal && personal.length !== 16) {
      throw new Error("Illegal personal, expected Uint8Array with length is 16");
    }
    const ctx = {
      b: new Uint8Array(128),
      h: new Uint32Array(16),
      t: 0,
      // input count
      c: 0,
      // pointer within buffer
      outlen
      // output length in bytes
    };
    parameterBlock.fill(0);
    parameterBlock[0] = outlen;
    if (key2) parameterBlock[1] = key2.length;
    parameterBlock[2] = 1;
    parameterBlock[3] = 1;
    if (salt) parameterBlock.set(salt, 32);
    if (personal) parameterBlock.set(personal, 48);
    for (let i = 0; i < 16; i++) {
      ctx.h[i] = BLAKE2B_IV32[i] ^ B2B_GET32(parameterBlock, i * 4);
    }
    if (key2) {
      blake2bUpdate(ctx, key2);
      ctx.c = 128;
    }
    return ctx;
  }
  function blake2bUpdate(ctx, input) {
    for (let i = 0; i < input.length; i++) {
      if (ctx.c === 128) {
        ctx.t += ctx.c;
        blake2bCompress(ctx, false);
        ctx.c = 0;
      }
      ctx.b[ctx.c++] = input[i];
    }
  }
  function blake2bFinal(ctx) {
    ctx.t += ctx.c;
    while (ctx.c < 128) {
      ctx.b[ctx.c++] = 0;
    }
    blake2bCompress(ctx, true);
    const out = new Uint8Array(ctx.outlen);
    for (let i = 0; i < ctx.outlen; i++) {
      out[i] = ctx.h[i >> 2] >> 8 * (i & 3);
    }
    return out;
  }
  function blake2b(input, key2, outlen, salt, personal) {
    outlen = outlen || 64;
    input = util2.normalizeInput(input);
    if (salt) {
      salt = util2.normalizeInput(salt);
    }
    if (personal) {
      personal = util2.normalizeInput(personal);
    }
    const ctx = blake2bInit(outlen, key2, salt, personal);
    blake2bUpdate(ctx, input);
    return blake2bFinal(ctx);
  }
  function blake2bHex(input, key2, outlen, salt, personal) {
    const output = blake2b(input, key2, outlen, salt, personal);
    return util2.toHex(output);
  }
  blake2b_1 = {
    blake2b,
    blake2bHex,
    blake2bInit,
    blake2bUpdate,
    blake2bFinal
  };
  return blake2b_1;
}
var blake2s_1;
var hasRequiredBlake2s;
function requireBlake2s() {
  if (hasRequiredBlake2s) return blake2s_1;
  hasRequiredBlake2s = 1;
  const util2 = requireUtil$1();
  function B2S_GET32(v3, i) {
    return v3[i] ^ v3[i + 1] << 8 ^ v3[i + 2] << 16 ^ v3[i + 3] << 24;
  }
  function B2S_G(a2, b2, c, d, x2, y2) {
    v2[a2] = v2[a2] + v2[b2] + x2;
    v2[d] = ROTR32(v2[d] ^ v2[a2], 16);
    v2[c] = v2[c] + v2[d];
    v2[b2] = ROTR32(v2[b2] ^ v2[c], 12);
    v2[a2] = v2[a2] + v2[b2] + y2;
    v2[d] = ROTR32(v2[d] ^ v2[a2], 8);
    v2[c] = v2[c] + v2[d];
    v2[b2] = ROTR32(v2[b2] ^ v2[c], 7);
  }
  function ROTR32(x2, y2) {
    return x2 >>> y2 ^ x2 << 32 - y2;
  }
  const BLAKE2S_IV = new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  const SIGMA = new Uint8Array([
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3,
    11,
    8,
    12,
    0,
    5,
    2,
    15,
    13,
    10,
    14,
    3,
    6,
    7,
    1,
    9,
    4,
    7,
    9,
    3,
    1,
    13,
    12,
    11,
    14,
    2,
    6,
    5,
    10,
    4,
    0,
    15,
    8,
    9,
    0,
    5,
    7,
    2,
    4,
    10,
    15,
    14,
    1,
    11,
    12,
    6,
    8,
    3,
    13,
    2,
    12,
    6,
    10,
    0,
    11,
    8,
    3,
    4,
    13,
    7,
    5,
    15,
    14,
    1,
    9,
    12,
    5,
    1,
    15,
    14,
    13,
    4,
    10,
    0,
    7,
    6,
    3,
    9,
    2,
    8,
    11,
    13,
    11,
    7,
    14,
    12,
    1,
    3,
    9,
    5,
    0,
    15,
    4,
    8,
    6,
    2,
    10,
    6,
    15,
    14,
    9,
    11,
    3,
    0,
    8,
    12,
    2,
    13,
    7,
    1,
    4,
    10,
    5,
    10,
    2,
    8,
    4,
    7,
    6,
    1,
    5,
    15,
    11,
    9,
    14,
    3,
    12,
    13,
    0
  ]);
  const v2 = new Uint32Array(16);
  const m2 = new Uint32Array(16);
  function blake2sCompress(ctx, last) {
    let i = 0;
    for (i = 0; i < 8; i++) {
      v2[i] = ctx.h[i];
      v2[i + 8] = BLAKE2S_IV[i];
    }
    v2[12] ^= ctx.t;
    v2[13] ^= ctx.t / 4294967296;
    if (last) {
      v2[14] = ~v2[14];
    }
    for (i = 0; i < 16; i++) {
      m2[i] = B2S_GET32(ctx.b, 4 * i);
    }
    for (i = 0; i < 10; i++) {
      B2S_G(0, 4, 8, 12, m2[SIGMA[i * 16 + 0]], m2[SIGMA[i * 16 + 1]]);
      B2S_G(1, 5, 9, 13, m2[SIGMA[i * 16 + 2]], m2[SIGMA[i * 16 + 3]]);
      B2S_G(2, 6, 10, 14, m2[SIGMA[i * 16 + 4]], m2[SIGMA[i * 16 + 5]]);
      B2S_G(3, 7, 11, 15, m2[SIGMA[i * 16 + 6]], m2[SIGMA[i * 16 + 7]]);
      B2S_G(0, 5, 10, 15, m2[SIGMA[i * 16 + 8]], m2[SIGMA[i * 16 + 9]]);
      B2S_G(1, 6, 11, 12, m2[SIGMA[i * 16 + 10]], m2[SIGMA[i * 16 + 11]]);
      B2S_G(2, 7, 8, 13, m2[SIGMA[i * 16 + 12]], m2[SIGMA[i * 16 + 13]]);
      B2S_G(3, 4, 9, 14, m2[SIGMA[i * 16 + 14]], m2[SIGMA[i * 16 + 15]]);
    }
    for (i = 0; i < 8; i++) {
      ctx.h[i] ^= v2[i] ^ v2[i + 8];
    }
  }
  function blake2sInit(outlen, key2) {
    if (!(outlen > 0 && outlen <= 32)) {
      throw new Error("Incorrect output length, should be in [1, 32]");
    }
    const keylen = key2 ? key2.length : 0;
    if (key2 && !(keylen > 0 && keylen <= 32)) {
      throw new Error("Incorrect key length, should be in [1, 32]");
    }
    const ctx = {
      h: new Uint32Array(BLAKE2S_IV),
      // hash state
      b: new Uint8Array(64),
      // input block
      c: 0,
      // pointer within block
      t: 0,
      // input count
      outlen
      // output length in bytes
    };
    ctx.h[0] ^= 16842752 ^ keylen << 8 ^ outlen;
    if (keylen > 0) {
      blake2sUpdate(ctx, key2);
      ctx.c = 64;
    }
    return ctx;
  }
  function blake2sUpdate(ctx, input) {
    for (let i = 0; i < input.length; i++) {
      if (ctx.c === 64) {
        ctx.t += ctx.c;
        blake2sCompress(ctx, false);
        ctx.c = 0;
      }
      ctx.b[ctx.c++] = input[i];
    }
  }
  function blake2sFinal(ctx) {
    ctx.t += ctx.c;
    while (ctx.c < 64) {
      ctx.b[ctx.c++] = 0;
    }
    blake2sCompress(ctx, true);
    const out = new Uint8Array(ctx.outlen);
    for (let i = 0; i < ctx.outlen; i++) {
      out[i] = ctx.h[i >> 2] >> 8 * (i & 3) & 255;
    }
    return out;
  }
  function blake2s(input, key2, outlen) {
    outlen = outlen || 32;
    input = util2.normalizeInput(input);
    const ctx = blake2sInit(outlen, key2);
    blake2sUpdate(ctx, input);
    return blake2sFinal(ctx);
  }
  function blake2sHex(input, key2, outlen) {
    const output = blake2s(input, key2, outlen);
    return util2.toHex(output);
  }
  blake2s_1 = {
    blake2s,
    blake2sHex,
    blake2sInit,
    blake2sUpdate,
    blake2sFinal
  };
  return blake2s_1;
}
var blakejs;
var hasRequiredBlakejs;
function requireBlakejs() {
  if (hasRequiredBlakejs) return blakejs;
  hasRequiredBlakejs = 1;
  const b2b = requireBlake2b();
  const b2s = requireBlake2s();
  blakejs = {
    blake2b: b2b.blake2b,
    blake2bHex: b2b.blake2bHex,
    blake2bInit: b2b.blake2bInit,
    blake2bUpdate: b2b.blake2bUpdate,
    blake2bFinal: b2b.blake2bFinal,
    blake2s: b2s.blake2s,
    blake2sHex: b2s.blake2sHex,
    blake2sInit: b2s.blake2sInit,
    blake2sUpdate: b2s.blake2sUpdate,
    blake2sFinal: b2s.blake2sFinal
  };
  return blakejs;
}
var blakejsExports = requireBlakejs();
const h = /* @__PURE__ */ getDefaultExportFromCjs(blakejsExports);
function P() {
  return typeof process < "u" && !!process.env;
}
function B(o4) {
  return process?.env?.[o4];
}
var O$1 = P() && !B("TONBRIDGE_DEBUG"), s = (...o4) => {
  O$1 || console.debug("[TON_CONNECT_BRIDGE_SDK]", ...o4);
}, b$1 = (...o4) => {
  console.error("[TON_CONNECT_BRIDGE_SDK]", ...o4);
};
var a = class o extends Error {
  static prefix = "[BRIDGE_SDK_ERROR]";
  constructor(e, t) {
    super(e, t), this.message = `${o.prefix} ${e ? `
` + e : ""}`, s(this.message), Object.setPrototypeOf(this, o.prototype);
  }
};
function k(o4) {
  return o4.slice(-1) === "/" ? o4.slice(0, -1) : o4;
}
function E(o4, e) {
  return k(o4) + "/" + e;
}
function p(o4) {
  let e = new AbortController();
  return o4?.aborted ? e.abort() : o4?.addEventListener("abort", () => e.abort(), { once: true }), e;
}
function D(o4, e) {
  let t = null, r = null, n = null;
  return { create: async (d, ...u) => {
    if (n?.abort(), n = p(d), n.signal.aborted) throw new a("Resource creation was aborted");
    let m2 = o4(n.signal, ...u);
    r = m2;
    let g2 = await m2;
    if (r !== m2 && g2 !== t) throw await e(g2), new a("Resource creation was aborted by a new resource creation");
    return t = g2, t;
  }, current: () => t ?? null, dispose: async () => {
    try {
      let d = t;
      t = null;
      let u = r;
      r = null;
      try {
        n?.abort();
      } catch {
      }
      await Promise.allSettled([d ? e(d) : Promise.resolve(), u ? e(await u) : Promise.resolve()]);
    } catch {
    }
  } };
}
function M$1(o4, e) {
  let t = e?.timeout, r = e?.signal, n = p(r);
  return new Promise(async (i, c) => {
    if (r?.aborted) {
      c(new a("Timeout aborted before setTimeout"));
      return;
    }
    let l;
    typeof t < "u" && (l = setTimeout(() => {
      n.abort(), c(new a(`Timeout after ${t}ms`));
    }, t)), n.signal.addEventListener("abort", () => {
      l && (clearTimeout(l), l = void 0, c(new a("Timeout aborted after setTimeout")));
    }, { once: true }), await o4((...d) => {
      clearTimeout(l), l = void 0, i(...d);
    }, (d) => {
      clearTimeout(l), l = void 0, c(d);
    }, { timeout: t, signal: n.signal });
  });
}
var v$1 = class o2 {
  constructor(e, t, r, n, i, c, l) {
    this.bridgeUrl = e;
    this.sessionIds = t;
    this.listener = r;
    this.errorsListener = n;
    this.lastEventId = i;
    this.heartbeatFormat = c;
    this.enableQueueDoneEvent = l;
  }
  static ssePath = "events";
  static postPath = "message";
  static defaultTtl = 300;
  eventSource = D(async (e, t) => await U({ bridgeUrl: this.bridgeUrl, ssePath: o2.ssePath, sessionIds: this.sessionIds, errorHandler: this.errorsHandler.bind(this), messageHandler: this.messagesHandler.bind(this), signal: e, connectingDeadlineMS: t, lastEventId: this.lastEventId, heartbeatFormat: this.heartbeatFormat, enableQueueDoneEvent: this.enableQueueDoneEvent }), async (e) => {
    e.close();
  });
  get isReady() {
    return this.eventSource.current()?.readyState === EventSource.OPEN;
  }
  get isClosed() {
    return this.eventSource.current()?.readyState !== EventSource.OPEN;
  }
  get isConnecting() {
    return this.eventSource.current()?.readyState === EventSource.CONNECTING;
  }
  static async open(e) {
    let t = new o2(e.bridgeUrl, e.sessionIds, e.listener, e.errorsListener, e.lastEventId, e.heartbeatFormat, e.enableQueueDoneEvent);
    try {
      return await t.registerSession(e.options), t;
    } catch (r) {
      throw await t.close(), r;
    }
  }
  async registerSession(e) {
    await this.eventSource.create(e?.signal, e?.connectingDeadlineMS);
  }
  static async sendRequest(e, t, r, n, i) {
    let c = new URL(E(e, this.postPath));
    c.searchParams.append("client_id", r), c.searchParams.append("to", n), c.searchParams.append("ttl", (i?.ttl ?? o2.defaultTtl).toString()), i?.topic && c.searchParams.append("topic", i.topic), i?.traceId && c.searchParams.append("trace_id", i.traceId);
    let l = Base64.encode(t), d = await this.post(c, l, i?.signal);
    if (!d.ok) throw new a(`Bridge send failed, status ${d.status}`);
  }
  async send(e, t, r, n) {
    return o2.sendRequest(this.bridgeUrl, e, t, r, n);
  }
  async close() {
    await this.eventSource.dispose().catch((e) => {
      b$1("[BridgeGateway] Failed to close connection:", e);
    });
  }
  setListener(e) {
    this.listener = e;
  }
  setErrorsListener(e) {
    this.errorsListener = e;
  }
  static async post(e, t, r) {
    let n = await fetch(e, { method: "post", body: t, signal: r });
    if (!n.ok) throw new a(`Bridge send failed, status ${n.status}`);
    return n;
  }
  async errorsHandler(e, t) {
    this.errorsListener(t);
  }
  async messagesHandler(e) {
    this.listener(e);
  }
};
async function U(o4) {
  let { lastEventId: e, heartbeatFormat: t, enableQueueDoneEvent: r } = o4;
  return await M$1(async (n, i, c) => {
    let { signal: l } = c;
    if (s("[BridgeGateway] Connecting to bridge SSE..."), l?.aborted) {
      i(new a("Bridge connection aborted before connection"));
      return;
    }
    let d = new URL(E(o4.bridgeUrl, o4.ssePath));
    if (d.searchParams.append("client_id", o4.sessionIds.join(",")), e && d.searchParams.append("last_event_id", e), t && d.searchParams.append("heartbeat", t), r && d.searchParams.append("enable_queue_done_event", "true"), l?.aborted) {
      i(new a("Bridge connection aborted after building url"));
      return;
    }
    s("[BridgeGateway] Initializing EventSource instance...");
    let u = new EventSource(d.toString()), m2 = false;
    u.onerror = async (g2) => {
      if (s("[BridgeGateway] EventSource error occurred:", JSON.stringify(g2)), l?.aborted) {
        u.close(), i(new a("Bridge connection aborted on error callback"));
        return;
      }
      if (!m2) {
        u.close(), i(new a("Bridge error before connecting"));
        return;
      }
      try {
        u.close(), await o4.errorHandler(u, g2);
      } catch (A2) {
        u.close(), i(A2);
      }
    }, u.onopen = () => {
      if (l?.aborted) {
        u.close(), i(new a("Bridge connection aborted on open"));
        return;
      }
      m2 = true, s("[BridgeGateway] EventSource connection established."), n(u);
    }, u.onmessage = (g2) => {
      if (l?.aborted) {
        u.close(), i(new a("Bridge connection aborted on message"));
        return;
      }
      e = g2.lastEventId, o4.messageHandler(g2);
    }, o4.signal?.addEventListener("abort", () => {
      u.close(), i(new a("Bridge connection aborted"));
    }, { once: true });
  }, { timeout: o4.connectingDeadlineMS, signal: o4.signal });
}
async function y(o4, e) {
  if (e?.signal?.aborted) throw new a("Delay aborted before setTimeout");
  return new Promise((t, r) => {
    let n = setTimeout(t, o4);
    e?.signal?.addEventListener("abort", () => {
      clearTimeout(n), r(new a("Delay aborted after setTimeout"));
    }, { once: true });
  });
}
async function S$1(o4, e) {
  let { signal: t, attempts: r = 10, delayMs: n = 100 } = e ?? {};
  if (typeof o4 != "function") throw new a(`Expected a function, got ${typeof o4}`);
  let i = 0, c;
  for (; i < r; ) {
    if (s(`[callForSuccess] Attempt: ${i}`), t?.aborted) throw new a(`Aborted after attempts ${i}`);
    try {
      return await o4({ signal: t });
    } catch (l) {
      s(`[callForSuccess], error after attempt ${i}, ${/* @__PURE__ */ new Date()}: ${JSON.stringify(l)}`, l), c = l, i++, i < r && (await y(n, { signal: t }), e?.exponential && (n = Math.min(n * 2, e.maxDelayMs ?? Number.MAX_SAFE_INTEGER)));
    }
  }
  throw c;
}
function T$1(o4) {
  return [...new Set(o4)];
}
function x(o4, e) {
  let t = new Set(o4), r = new Set(e);
  if (t.size !== r.size) return false;
  for (let n of t) if (!r.has(n)) return false;
  return true;
}
function G(o4, e) {
  let t = h.blake2bInit(f.box.nonceLength);
  return h.blake2bUpdate(t, o4), h.blake2bUpdate(t, e), h.blake2bFinal(t);
}
function I$1(o4, e, t) {
  let r = o4.subarray(0, f.box.publicKeyLength), n = G(r, e), i = o4.subarray(f.box.publicKeyLength);
  return f.box.open(i, n, r, t);
}
var C$1 = class o3 {
  constructor(e, t = null, r = null, n = void 0) {
    this.bridgeUrl = e;
    this.listener = t;
    this.errorListener = r;
    this.heartbeatReconnectIntervalMs = n;
  }
  clients = [];
  lastEventId;
  abortController;
  gateway = null;
  onConnectingCallback;
  onQueueDoneCallback;
  heartbeatMessage = "heartbeat";
  queueEndMessage = "queue_done";
  defaultConnectingDeadlineMS = 14e3;
  defaultRetryDelayMs = 1e3;
  defaultMaxExponentialDelayMS = 7e3;
  missedHeartbeatDelay = 100;
  lastHeartbeatAt = Date.now();
  heartbeatTimer = null;
  connectionOptions = {};
  static async open(e) {
    let t = new o3(e.bridgeUrl, e.listener, e.errorListener, e.options?.heartbeatReconnectIntervalMs);
    e.onConnecting && (t.onConnecting = e.onConnecting), e.onQueueDone && (t.onQueueDone = e.onQueueDone);
    try {
      return await t.restoreConnection(e.clients, e.options), t;
    } catch (r) {
      throw await t.close(), r;
    }
  }
  get isReady() {
    return this.gateway?.isReady || false;
  }
  get isConnecting() {
    return this.gateway?.isConnecting ?? false;
  }
  get isClosed() {
    return this.gateway?.isClosed ?? false;
  }
  startHeartbeatWatcher(e) {
    if (!this.heartbeatReconnectIntervalMs) return;
    this.stopHeartbeatWatcher();
    let t = p(e), { signal: r } = t;
    this.lastHeartbeatAt = Date.now();
    let n = (c) => {
      this.heartbeatTimer = setTimeout(i, c);
    }, i = async () => {
      if (r.aborted) {
        this.stopHeartbeatWatcher();
        return;
      }
      if (Date.now() - this.lastHeartbeatAt < this.heartbeatReconnectIntervalMs) {
        n(this.heartbeatReconnectIntervalMs / 2);
        return;
      }
      if (await y(this.missedHeartbeatDelay, { signal: r }), r.aborted) {
        this.stopHeartbeatWatcher();
        return;
      }
      let l = Date.now() - this.lastHeartbeatAt;
      if (l <= this.heartbeatReconnectIntervalMs) {
        n(this.heartbeatReconnectIntervalMs / 2);
        return;
      }
      s(`[BridgeProvider] No heartbeat for ${l}ms, reconnecting...`);
      try {
        await this.reconnect(r);
      } catch (d) {
        b$1("[BridgeProvider] Failed to reconnect after missed heartbeat:", d), this.errorListener?.(d);
      }
    };
    n(this.heartbeatReconnectIntervalMs);
  }
  stopHeartbeatWatcher() {
    this.heartbeatTimer && (clearTimeout(this.heartbeatTimer), this.heartbeatTimer = null);
  }
  async restoreConnection(e, t) {
    if (e.length === 0) {
      s("[BridgeProvider] No clients passed");
      return;
    }
    this.clients = e, this.lastEventId = t?.lastEventId, this.connectionOptions = { connectingDeadlineMs: t?.connectingDeadlineMs, delayMs: t?.delayMs, maxDelayMs: t?.maxDelayMs, exponential: t?.exponential }, s("[BridgeProvider] Restoring connection...");
    let r = p(t?.signal);
    this.abortController?.abort(), this.abortController = r;
    let n = r.signal;
    if (n.aborted) {
      s("[BridgeProvider] Restore aborted before start.");
      return;
    }
    if (await this.reconnect(n), r.signal.aborted) {
      s("[BridgeProvider] Restore aborted after connecting.");
      return;
    }
    this.startHeartbeatWatcher(t?.signal);
  }
  async updateClients(e, t) {
    let r = this.clients.map((i) => i.session.sessionId), n = e.map((i) => i.session.sessionId);
    x(r, n) || (this.clients = e, await this.restoreConnection(e, { ...this.connectionOptions, signal: t?.signal }));
  }
  async reconnect(e) {
    try {
      await this.closeGateway();
    } catch (r) {
      s("[BridgeProvider] Error closing gateway:", JSON.stringify(r)), this.errorListener?.(r);
    }
    if (e.aborted) {
      s("[BridgeProvider] Reconnect aborted after closing gateway.");
      return;
    }
    let t = this.connectionOptions;
    await S$1(({ signal: r }) => this.openGateway(this.clients.map((n) => n.session), { lastEventId: this.lastEventId, connectingDeadlineMS: t?.connectingDeadlineMs ?? this.defaultConnectingDeadlineMS, signal: r }), { attempts: Number.MAX_SAFE_INTEGER, delayMs: t?.delayMs ?? this.defaultRetryDelayMs, signal: e, exponential: t?.exponential ?? true, maxDelayMs: t?.maxDelayMs ?? this.defaultMaxExponentialDelayMS });
  }
  async send(e, t, r, n) {
    if (n?.signal?.aborted) {
      s("[BridgeProvider] Send aborted before encryption.");
      return;
    }
    let i = t.encrypt(JSON.stringify(e), hexToByteArray(r)), c = n?.topic ?? ("method" in e ? e.method : void 0);
    await S$1(async ({ signal: l }) => {
      await v$1.sendRequest(this.bridgeUrl, i, t.sessionId, r, { traceId: n?.traceId, topic: c, signal: l, ttl: n?.ttl });
    }, { attempts: n?.attempts ?? Number.MAX_SAFE_INTEGER, delayMs: n?.delayMs ?? this.defaultRetryDelayMs, signal: n?.signal, exponential: n?.exponential ?? true, maxDelayMs: n?.maxDelayMs ?? this.defaultMaxExponentialDelayMS });
  }
  async close() {
    s("[BridgeProvider] Closing provider and gateway..."), await this.closeGateway(), this.stopHeartbeatWatcher(), this.lastEventId = void 0, this.clients = [], s("[BridgeProvider] Closed.");
  }
  listen(e) {
    this.listener = e;
  }
  set onQueueDone(e) {
    this.onQueueDoneCallback = () => {
      try {
        e();
      } catch (t) {
        b$1(`[BridgeProvider] Error during onQueueDone callback: ${JSON.stringify(t)}`, t), this.errorListener?.(t);
      }
    };
  }
  set onConnecting(e) {
    this.onConnectingCallback = () => {
      try {
        e();
      } catch (t) {
        b$1(`[BridgeProvider] Error during onConnecting callback: ${JSON.stringify(t)}`, t), this.errorListener?.(t);
      }
    };
  }
  getCryptoSession(e) {
    let t = this.clients.find(({ clientId: r }) => r === e);
    if (!t) throw new a("Client session does not exist");
    return t.session;
  }
  loadMaybeSource(e, t) {
    if (!t) return;
    let r = I$1(Base64.decode(t).toUint8Array(), hexToByteArray(e.sessionId), hexToByteArray(e.stringifyKeypair().secretKey));
    if (!r) throw new Error("Decrypt error ");
    let n = JSON.parse(new TextDecoder().decode(r));
    return { origin: n.origin, ip: n.ip, time: n.time, userAgent: n.user_agent };
  }
  async gatewayListener(e) {
    if (e.data === this.heartbeatMessage) {
      this.lastHeartbeatAt = Date.now();
      return;
    }
    if (e.data === this.queueEndMessage) {
      this.onQueueDoneCallback?.();
      return;
    }
    s(`[BridgeProvider] Message received. Event ID: ${e.lastEventId}`);
    let t;
    try {
      t = JSON.parse(e.data);
    } catch {
      this.errorListener?.(new a(`Failed to parse message: ${e.data}`));
      return;
    }
    let r = this.getCryptoSession(t.from), n = JSON.parse(r.decrypt(Base64.decode(t.message).toUint8Array(), hexToByteArray(t.from))), i = this.loadMaybeSource(r, t.request_source);
    s("[BridgeProvider] Incoming message decrypted:", n), this.lastEventId = e.lastEventId, this.listener?.({ lastEventId: e.lastEventId, traceId: t.trace_id, ...n, from: t.from, requestSource: i, connectSource: t.connect_source });
  }
  async gatewayErrorsListener(e) {
    if (this.gateway?.isClosed || this.gateway?.isConnecting) {
      let r = p(this.abortController?.signal);
      try {
        return s("[BridgeProvider] Error in gatewayErrorsListener, trying to reconnect:", e), this.onConnectingCallback?.(), this.reconnect(r.signal);
      } catch (n) {
        r.abort(), s("[BridgeProvider] Error in gatewayErrorsListener after reconnect:", n), this.errorListener?.(n);
      }
    }
    let t = new a(`Bridge error ${JSON.stringify(e)}`);
    b$1("[BridgeProvider] Gateway error:", t), this.errorListener?.(t);
  }
  async openGateway(e, t) {
    if (t?.signal?.aborted) {
      s("[BridgeProvider] Open gateway aborted before start.");
      return;
    }
    if (this.gateway && (s("[BridgeProvider] Existing gateway detected. Closing it..."), await this.closeGateway()), s("[BridgeProvider] Creating new BridgeGateway instance..."), t?.signal?.aborted) {
      s("[BridgeProvider] Open gateway aborted after close.");
      return;
    }
    this.gateway = new v$1(this.bridgeUrl, T$1(e.map(({ sessionId: r }) => r)), this.gatewayListener.bind(this), this.gatewayErrorsListener.bind(this), this.lastEventId, "message", true), s("[BridgeProvider] BridgeGateway created. Connecting to bridge..."), this.onConnectingCallback?.(), await this.gateway.registerSession({ connectingDeadlineMS: t?.connectingDeadlineMS, signal: t?.signal }), s("[BridgeProvider] Connected to bridge successfully.");
  }
  async closeGateway() {
    this.gateway && (s("[BridgeProvider] Closing previous gateway..."), await this.gateway.close(), this.gateway = null, s("[BridgeProvider] Gateway closed."));
  }
};
/**
 * uuidv7: A JavaScript implementation of UUID version 7
 *
 * Copyright 2021-2024 LiosK
 *
 * @license Apache-2.0
 * @packageDocumentation
 */
const DIGITS = "0123456789abcdef";
class UUID {
  bytes;
  /** @param bytes - The 16-byte byte array representation. */
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  constructor(bytes) {
    this.bytes = bytes;
  }
  /**
   * Creates an object from the internal representation, a 16-byte byte array
   * containing the binary UUID representation in the big-endian byte order.
   *
   * This method does NOT shallow-copy the argument, and thus the created object
   * holds the reference to the underlying buffer.
   *
   * @throws TypeError if the length of the argument is not 16.
   */
  static ofInner(bytes) {
    if (bytes.length !== 16) {
      throw new TypeError("not 128-bit length");
    } else {
      return new UUID(bytes);
    }
  }
  /**
   * Builds a byte array from UUIDv7 field values.
   *
   * @param unixTsMs - A 48-bit `unix_ts_ms` field value.
   * @param randA - A 12-bit `rand_a` field value.
   * @param randBHi - The higher 30 bits of 62-bit `rand_b` field value.
   * @param randBLo - The lower 32 bits of 62-bit `rand_b` field value.
   * @throws RangeError if any field value is out of the specified range.
   */
  static fromFieldsV7(unixTsMs, randA, randBHi, randBLo) {
    if (!Number.isInteger(unixTsMs) || !Number.isInteger(randA) || !Number.isInteger(randBHi) || !Number.isInteger(randBLo) || unixTsMs < 0 || randA < 0 || randBHi < 0 || randBLo < 0 || unixTsMs > 281474976710655 || randA > 4095 || randBHi > 1073741823 || randBLo > 4294967295) {
      throw new RangeError("invalid field value");
    }
    const bytes = new Uint8Array(16);
    bytes[0] = unixTsMs / 2 ** 40;
    bytes[1] = unixTsMs / 2 ** 32;
    bytes[2] = unixTsMs / 2 ** 24;
    bytes[3] = unixTsMs / 2 ** 16;
    bytes[4] = unixTsMs / 2 ** 8;
    bytes[5] = unixTsMs;
    bytes[6] = 112 | randA >>> 8;
    bytes[7] = randA;
    bytes[8] = 128 | randBHi >>> 24;
    bytes[9] = randBHi >>> 16;
    bytes[10] = randBHi >>> 8;
    bytes[11] = randBHi;
    bytes[12] = randBLo >>> 24;
    bytes[13] = randBLo >>> 16;
    bytes[14] = randBLo >>> 8;
    bytes[15] = randBLo;
    return new UUID(bytes);
  }
  /**
   * Builds a byte array from a string representation.
   *
   * This method accepts the following formats:
   *
   * - 32-digit hexadecimal format without hyphens: `0189dcd553117d408db09496a2eef37b`
   * - 8-4-4-4-12 hyphenated format: `0189dcd5-5311-7d40-8db0-9496a2eef37b`
   * - Hyphenated format with surrounding braces: `{0189dcd5-5311-7d40-8db0-9496a2eef37b}`
   * - RFC 9562 URN format: `urn:uuid:0189dcd5-5311-7d40-8db0-9496a2eef37b`
   *
   * Leading and trailing whitespaces represents an error.
   *
   * @throws SyntaxError if the argument could not parse as a valid UUID string.
   */
  static parse(uuid) {
    let hex = void 0;
    switch (uuid.length) {
      case 32:
        hex = /^[0-9a-f]{32}$/i.exec(uuid)?.[0];
        break;
      case 36:
        hex = /^([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/i.exec(uuid)?.slice(1, 6).join("");
        break;
      case 38:
        hex = /^\{([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})\}$/i.exec(uuid)?.slice(1, 6).join("");
        break;
      case 45:
        hex = /^urn:uuid:([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/i.exec(uuid)?.slice(1, 6).join("");
        break;
    }
    if (hex) {
      const inner = new Uint8Array(16);
      for (let i = 0; i < 16; i += 4) {
        const n = parseInt(hex.substring(2 * i, 2 * i + 8), 16);
        inner[i + 0] = n >>> 24;
        inner[i + 1] = n >>> 16;
        inner[i + 2] = n >>> 8;
        inner[i + 3] = n;
      }
      return new UUID(inner);
    } else {
      throw new SyntaxError("could not parse UUID string");
    }
  }
  /**
   * @returns The 8-4-4-4-12 canonical hexadecimal string representation
   * (`0189dcd5-5311-7d40-8db0-9496a2eef37b`).
   */
  toString() {
    let text = "";
    for (let i = 0; i < this.bytes.length; i++) {
      text += DIGITS.charAt(this.bytes[i] >>> 4);
      text += DIGITS.charAt(this.bytes[i] & 15);
      if (i === 3 || i === 5 || i === 7 || i === 9) {
        text += "-";
      }
    }
    return text;
  }
  /**
   * @returns The 32-digit hexadecimal representation without hyphens
   * (`0189dcd553117d408db09496a2eef37b`).
   */
  toHex() {
    let text = "";
    for (let i = 0; i < this.bytes.length; i++) {
      text += DIGITS.charAt(this.bytes[i] >>> 4);
      text += DIGITS.charAt(this.bytes[i] & 15);
    }
    return text;
  }
  /** @returns The 8-4-4-4-12 canonical hexadecimal string representation. */
  toJSON() {
    return this.toString();
  }
  /**
   * Reports the variant field value of the UUID or, if appropriate, "NIL" or
   * "MAX".
   *
   * For convenience, this method reports "NIL" or "MAX" if `this` represents
   * the Nil or Max UUID, although the Nil and Max UUIDs are technically
   * subsumed under the variants `0b0` and `0b111`, respectively.
   */
  getVariant() {
    const n = this.bytes[8] >>> 4;
    if (n < 0) {
      throw new Error("unreachable");
    } else if (n <= 7) {
      return this.bytes.every((e) => e === 0) ? "NIL" : "VAR_0";
    } else if (n <= 11) {
      return "VAR_10";
    } else if (n <= 13) {
      return "VAR_110";
    } else if (n <= 15) {
      return this.bytes.every((e) => e === 255) ? "MAX" : "VAR_RESERVED";
    } else {
      throw new Error("unreachable");
    }
  }
  /**
   * Returns the version field value of the UUID or `undefined` if the UUID does
   * not have the variant field value of `0b10`.
   */
  getVersion() {
    return this.getVariant() === "VAR_10" ? this.bytes[6] >>> 4 : void 0;
  }
  /** Creates an object from `this`. */
  clone() {
    return new UUID(this.bytes.slice(0));
  }
  /** Returns true if `this` is equivalent to `other`. */
  equals(other) {
    return this.compareTo(other) === 0;
  }
  /**
   * Returns a negative integer, zero, or positive integer if `this` is less
   * than, equal to, or greater than `other`, respectively.
   */
  compareTo(other) {
    for (let i = 0; i < 16; i++) {
      const diff = this.bytes[i] - other.bytes[i];
      if (diff !== 0) {
        return Math.sign(diff);
      }
    }
    return 0;
  }
}
class V7Generator {
  timestamp = 0;
  counter = 0;
  /** The random number generator used by the generator. */
  random;
  /**
   * Creates a generator object with the default random number generator, or
   * with the specified one if passed as an argument. The specified random
   * number generator should be cryptographically strong and securely seeded.
   */
  constructor(randomNumberGenerator) {
    this.random = randomNumberGenerator ?? getDefaultRandom();
  }
  /**
   * Generates a new UUIDv7 object from the current timestamp, or resets the
   * generator upon significant timestamp rollback.
   *
   * This method returns a monotonically increasing UUID by reusing the previous
   * timestamp even if the up-to-date timestamp is smaller than the immediately
   * preceding UUID's. However, when such a clock rollback is considered
   * significant (i.e., by more than ten seconds), this method resets the
   * generator and returns a new UUID based on the given timestamp, breaking the
   * increasing order of UUIDs.
   *
   * See {@link generateOrAbort} for the other mode of generation and
   * {@link generateOrResetCore} for the low-level primitive.
   */
  generate() {
    return this.generateOrResetCore(Date.now(), 1e4);
  }
  /**
   * Generates a new UUIDv7 object from the current timestamp, or returns
   * `undefined` upon significant timestamp rollback.
   *
   * This method returns a monotonically increasing UUID by reusing the previous
   * timestamp even if the up-to-date timestamp is smaller than the immediately
   * preceding UUID's. However, when such a clock rollback is considered
   * significant (i.e., by more than ten seconds), this method aborts and
   * returns `undefined` immediately.
   *
   * See {@link generate} for the other mode of generation and
   * {@link generateOrAbortCore} for the low-level primitive.
   */
  generateOrAbort() {
    return this.generateOrAbortCore(Date.now(), 1e4);
  }
  /**
   * Generates a new UUIDv7 object from the `unixTsMs` passed, or resets the
   * generator upon significant timestamp rollback.
   *
   * This method is equivalent to {@link generate} except that it takes a custom
   * timestamp and clock rollback allowance.
   *
   * @param rollbackAllowance - The amount of `unixTsMs` rollback that is
   * considered significant. A suggested value is `10_000` (milliseconds).
   * @throws RangeError if `unixTsMs` is not a 48-bit positive integer.
   */
  generateOrResetCore(unixTsMs, rollbackAllowance) {
    let value = this.generateOrAbortCore(unixTsMs, rollbackAllowance);
    if (value === void 0) {
      this.timestamp = 0;
      value = this.generateOrAbortCore(unixTsMs, rollbackAllowance);
    }
    return value;
  }
  /**
   * Generates a new UUIDv7 object from the `unixTsMs` passed, or returns
   * `undefined` upon significant timestamp rollback.
   *
   * This method is equivalent to {@link generateOrAbort} except that it takes a
   * custom timestamp and clock rollback allowance.
   *
   * @param rollbackAllowance - The amount of `unixTsMs` rollback that is
   * considered significant. A suggested value is `10_000` (milliseconds).
   * @throws RangeError if `unixTsMs` is not a 48-bit positive integer.
   */
  generateOrAbortCore(unixTsMs, rollbackAllowance) {
    const MAX_COUNTER = 4398046511103;
    if (!Number.isInteger(unixTsMs) || unixTsMs < 1 || unixTsMs > 281474976710655) {
      throw new RangeError("`unixTsMs` must be a 48-bit positive integer");
    } else if (rollbackAllowance < 0 || rollbackAllowance > 281474976710655) {
      throw new RangeError("`rollbackAllowance` out of reasonable range");
    }
    if (unixTsMs > this.timestamp) {
      this.timestamp = unixTsMs;
      this.resetCounter();
    } else if (unixTsMs + rollbackAllowance >= this.timestamp) {
      this.counter++;
      if (this.counter > MAX_COUNTER) {
        this.timestamp++;
        this.resetCounter();
      }
    } else {
      return void 0;
    }
    return UUID.fromFieldsV7(this.timestamp, Math.trunc(this.counter / 2 ** 30), this.counter & 2 ** 30 - 1, this.random.nextUint32());
  }
  /** Initializes the counter at a 42-bit random integer. */
  resetCounter() {
    this.counter = this.random.nextUint32() * 1024 + (this.random.nextUint32() & 1023);
  }
  /**
   * Generates a new UUIDv4 object utilizing the random number generator inside.
   *
   * @internal
   */
  generateV4() {
    const bytes = new Uint8Array(Uint32Array.of(this.random.nextUint32(), this.random.nextUint32(), this.random.nextUint32(), this.random.nextUint32()).buffer);
    bytes[6] = 64 | bytes[6] >>> 4;
    bytes[8] = 128 | bytes[8] >>> 2;
    return UUID.ofInner(bytes);
  }
}
const getDefaultRandom = () => {
  if (typeof crypto !== "undefined" && typeof crypto.getRandomValues !== "undefined") {
    return new BufferedCryptoRandom();
  } else {
    if (typeof UUIDV7_DENY_WEAK_RNG !== "undefined" && UUIDV7_DENY_WEAK_RNG) {
      throw new Error("no cryptographically strong RNG available");
    }
    return {
      nextUint32: () => Math.trunc(Math.random() * 65536) * 65536 + Math.trunc(Math.random() * 65536)
    };
  }
};
class BufferedCryptoRandom {
  buffer = new Uint32Array(8);
  cursor = 65535;
  nextUint32() {
    if (this.cursor >= this.buffer.length) {
      crypto.getRandomValues(this.buffer);
      this.cursor = 0;
    }
    return this.buffer[this.cursor++];
  }
}
let defaultGenerator;
const uuidv7 = () => uuidv7obj().toString();
const uuidv7obj = () => (defaultGenerator || (defaultGenerator = new V7Generator())).generate();
const ERROR_CODES = {
  // Bridge Manager Errors (7000-7099)
  BRIDGE_NOT_INITIALIZED: 7e3,
  BRIDGE_CONNECTION_FAILED: 7001,
  BRIDGE_EVENT_PROCESSING_FAILED: 7002,
  BRIDGE_RESPONSE_SEND_FAILED: 7003,
  // Session Errors (7100-7199)
  SESSION_NOT_FOUND: 7100,
  SESSION_ID_REQUIRED: 7101,
  SESSION_CREATION_FAILED: 7102,
  SESSION_DOMAIN_REQUIRED: 7103,
  SESSION_RESTORATION_FAILED: 7104,
  // Event Store Errors (7200-7299)
  EVENT_STORE_NOT_INITIALIZED: 7200,
  EVENT_STORE_OPERATION_FAILED: 7201,
  // Storage Errors (7300-7399)
  STORAGE_READ_FAILED: 7300,
  STORAGE_WRITE_FAILED: 7301,
  // Wallet Errors (7400-7499)
  WALLET_NOT_FOUND: 7400,
  WALLET_REQUIRED: 7401,
  WALLET_INVALID: 7402,
  WALLET_CREATION_FAILED: 7403,
  WALLET_INITIALIZATION_FAILED: 7404,
  LEDGER_DEVICE_ERROR: 7405,
  // Request Processing Errors (7500-7599)
  INVALID_REQUEST_EVENT: 7500,
  REQUEST_PROCESSING_FAILED: 7501,
  RESPONSE_CREATION_FAILED: 7502,
  APPROVAL_FAILED: 7503,
  REJECTION_FAILED: 7504,
  // API Client Errors (7600-7699)
  API_CLIENT_ERROR: 7600,
  TON_CLIENT_INITIALIZATION_FAILED: 7601,
  API_REQUEST_FAILED: 7602,
  ACCOUNT_NOT_FOUND: 7603,
  // Jetton/NFT Errors (7700-7799)
  JETTONS_MANAGER_ERROR: 7700,
  NFT_MANAGER_ERROR: 7701,
  // Contract Errors (7800-7899)
  CONTRACT_DEPLOYMENT_FAILED: 7800,
  CONTRACT_EXECUTION_FAILED: 7801,
  CONTRACT_VALIDATION_FAILED: 7802,
  // Generic Errors (7900-7999)
  UNKNOWN_ERROR: 7900,
  VALIDATION_ERROR: 7901,
  INITIALIZATION_ERROR: 7902,
  CONFIGURATION_ERROR: 7903,
  NETWORK_ERROR: 7904,
  UNKNOWN_EMULATION_ERROR: 7905
};
function getErrorCodeName(code) {
  const entry = Object.entries(ERROR_CODES).find(([, value]) => value === code);
  return entry ? entry[0] : `UNKNOWN_CODE_${code}`;
}
class WalletKitError extends Error {
  code;
  codeName;
  originalError;
  context;
  constructor(code, message, originalError, context) {
    const fullMessage = originalError ? `${message}: ${originalError.message}` : message;
    super(fullMessage);
    this.name = "WalletKitError";
    this.code = code;
    this.codeName = getErrorCodeName(code);
    this.originalError = originalError;
    this.context = context;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, WalletKitError);
    }
    if (originalError?.stack) {
      this.stack = `${this.stack}
Caused by: ${originalError.stack}`;
    }
  }
  /**
   * Create a WalletKitError from an unknown error
   */
  static fromError(code, message, error2, context) {
    if (error2 instanceof Error) {
      return new WalletKitError(code, message, error2, context);
    }
    const errorMessage = error2 && typeof error2 === "object" && "message" in error2 ? String(error2.message) : String(error2);
    return new WalletKitError(code, `${message}: ${errorMessage}`, void 0, { ...context, originalValue: error2 });
  }
  /**
   * Check if an error is a WalletKitError with a specific code
   */
  static isWalletKitError(error2, code) {
    if (!(error2 instanceof WalletKitError)) {
      return false;
    }
    if (code !== void 0) {
      return error2.code === code;
    }
    return true;
  }
  /**
   * Serialize error to JSON
   */
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      code: this.code,
      codeName: this.codeName,
      context: this.context,
      stack: this.stack,
      originalError: this.originalError ? {
        name: this.originalError.name,
        message: this.originalError.message,
        stack: this.originalError.stack
      } : void 0
    };
  }
}
function getUnixtime() {
  return Math.floor(Date.now() / 1e3);
}
const VERSION = "0.1.0";
function getVersion() {
  return VERSION;
}
function getEventsSubsystem() {
  return "wallet";
}
const log$f = globalLogger.createChild("BridgeManager");
class BridgeManager {
  config;
  bridgeProvider;
  sessionManager;
  storageAdapter;
  isConnected = false;
  reconnectAttempts = 0;
  lastEventId;
  storageKey = "bridge_last_event_id";
  walletKitConfig;
  // Event processing queue and concurrency control
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  eventQueue = [];
  isProcessing = false;
  // Durable events support
  eventStore;
  eventRouter;
  eventEmitter;
  analyticsApi;
  requestProcessingTimeoutId;
  constructor(walletManifest, config, sessionManager, storageAdapter, eventStore, eventRouter, walletKitConfig, eventEmitter, analyticsApi) {
    const isManifestJsBridge = walletManifest && "jsBridgeKey" in walletManifest ? true : false;
    const manifestJsBridgeKey = walletManifest && "jsBridgeKey" in walletManifest ? walletManifest.jsBridgeKey : void 0;
    const manifestBridgeUrl = walletManifest && "bridgeUrl" in walletManifest ? walletManifest.bridgeUrl : void 0;
    this.config = {
      heartbeatInterval: 5e3,
      reconnectInterval: 15e3,
      maxReconnectAttempts: 5,
      ...{
        enableJsBridge: isManifestJsBridge,
        jsBridgeKey: manifestJsBridgeKey,
        bridgeUrl: manifestBridgeUrl
      },
      ...config
    };
    this.sessionManager = sessionManager;
    this.storageAdapter = storageAdapter;
    this.eventStore = eventStore;
    this.eventEmitter = eventEmitter;
    this.eventRouter = eventRouter;
    this.analyticsApi = analyticsApi;
    this.walletKitConfig = walletKitConfig;
  }
  /**
   * Initialize bridge connection
   */
  async start() {
    if (this.bridgeProvider) {
      log$f.warn("Bridge already initialized");
      return;
    }
    try {
      await this.loadLastEventId();
      if (!this.config?.disableHttpConnection) {
        await this.connectToSSEBridge();
      } else {
        this.isConnected = true;
        this.reconnectAttempts = 0;
      }
    } catch (error2) {
      log$f.error("Failed to start bridge", { error: error2 });
      throw error2;
    }
    const requestProcessing = () => {
      this.processBridgeEvents();
      this.requestProcessingTimeoutId = setTimeout(requestProcessing, 1e3);
    };
    requestProcessing();
  }
  /**
   * Create new session for a dApp connection
   */
  async createSession(appSessionId) {
    log$f.info("[BRIDGE] Creating session", { appSessionId });
    const session = this.sessionManager.getSession(appSessionId);
    if (!session) {
      throw new WalletKitError(ERROR_CODES.SESSION_NOT_FOUND, `Session not found`, void 0, {
        appSessionId
      });
    }
    if (this.bridgeProvider && this.isConnected) {
      log$f.info("[BRIDGE] Updating clients");
      await this.updateClients();
    }
  }
  /**
   * Remove session
   */
  async removeSession(appSessionId) {
    if (this.bridgeProvider && this.isConnected) {
      await this.updateClients();
    }
    log$f.debug("Session removed", { appSessionId });
  }
  /**
   * Send response to dApp
   */
  async sendResponse(event, response, _session) {
    if (event.isLocal) {
      return;
    }
    if (event.isJsBridge) {
      return this.sendJsBridgeResponse(event.tabId?.toString() || "", event.isJsBridge, event.messageId ?? null, response, {
        traceId: event?.traceId
      });
    }
    if (!this.bridgeProvider) {
      throw new WalletKitError(ERROR_CODES.BRIDGE_NOT_INITIALIZED, "Bridge not initialized for sending response");
    }
    const sessionId = event.from || event.sessionId;
    if (!sessionId) {
      throw new WalletKitError(ERROR_CODES.SESSION_ID_REQUIRED, "Session ID is required for sending response", void 0, { event: { id: event.id } });
    }
    const session = _session ?? await this.sessionManager.getSession(sessionId);
    if (!session) {
      throw new WalletKitError(ERROR_CODES.SESSION_NOT_FOUND, `Session not found for response`, void 0, {
        sessionId,
        eventId: event.id
      });
    }
    try {
      const sessionCrypto = new SessionCrypto({
        publicKey: session.publicKey,
        secretKey: session.privateKey
      });
      await this.bridgeProvider.send(response, sessionCrypto, sessionId, {
        traceId: event?.traceId
      });
      log$f.debug("Response sent successfully", { sessionId, requestId: event.id });
    } catch (error2) {
      log$f.error("Failed to send response through bridge", {
        sessionId,
        requestId: event.id,
        error: error2
      });
      throw WalletKitError.fromError(ERROR_CODES.BRIDGE_RESPONSE_SEND_FAILED, "Failed to send response through bridge", error2, { sessionId, requestId: event.id });
    }
  }
  async sendJsBridgeResponse(sessionId, _isJsBridge, requestId, response, options) {
    const source = this.config.jsBridgeKey + "-tonconnect";
    chrome.tabs.sendMessage(parseInt(sessionId), {
      type: "TONCONNECT_BRIDGE_RESPONSE",
      source,
      messageId: requestId,
      success: true,
      payload: response,
      traceId: options?.traceId
    });
  }
  /**
   * Close bridge connection
   */
  async close() {
    if (this.bridgeProvider) {
      await this.bridgeProvider.close();
      this.bridgeProvider = void 0;
    }
    this.eventQueue = [];
    this.isProcessing = false;
    this.isConnected = false;
    this.reconnectAttempts = 0;
    if (this.requestProcessingTimeoutId) {
      clearTimeout(this.requestProcessingTimeoutId);
      this.requestProcessingTimeoutId = void 0;
    }
  }
  /**
   * Get connection status
   */
  isConnectedToBridge() {
    return this.isConnected;
  }
  /**
   * Get active session count
   */
  // getSessionCount(): number {
  //     return this.sessions.size;
  // }
  async getClients() {
    return this.sessionManager.getSessions().map((session) => ({
      session: new SessionCrypto({
        publicKey: session.publicKey,
        secretKey: session.privateKey.length > 64 ? session.privateKey.slice(0, 64) : session.privateKey
      }),
      clientId: session.sessionId
    }));
  }
  /**
   * Connect to TON Connect bridge
   */
  async connectToSSEBridge() {
    if (!this.config.bridgeUrl) {
      return;
    }
    const connectTraceId = uuidv7();
    try {
      const clients = await this.getClients();
      if (clients.length === 0) {
        clients.push({
          clientId: "0",
          session: new SessionCrypto()
        });
      }
      this.analyticsApi?.sendEvents([
        {
          event_name: "bridge-connect-started",
          client_environment: "wallet",
          subsystem: getEventsSubsystem(),
          bridge_url: this.config.bridgeUrl,
          client_timestamp: getUnixtime(),
          event_id: uuidv7(),
          network_id: this.walletKitConfig.network,
          trace_id: connectTraceId,
          version: getVersion()
        }
      ]);
      this.bridgeProvider = await C$1.open({
        bridgeUrl: this.config.bridgeUrl,
        clients,
        listener: this.queueBridgeEvent.bind(this),
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        errorListener: (error2) => {
          log$f.error("Bridge listener error", { error: error2.toString() });
          this.analyticsApi?.sendEvents([
            {
              event_name: "bridge-connect-error",
              client_environment: "wallet",
              subsystem: getEventsSubsystem(),
              bridge_url: this.config.bridgeUrl,
              error_message: error2?.toString() || "Unknown error",
              event_id: uuidv7(),
              trace_id: error2?.traceId ?? connectTraceId,
              version: getVersion(),
              client_id: error2?.clientId,
              client_timestamp: getUnixtime(),
              error_code: error2?.errorCode,
              network_id: this.walletKitConfig.network
            }
          ]);
        },
        options: {
          lastEventId: this.lastEventId
          // heartbeatReconnectIntervalMs: this.config.reconnectInterval,
        }
      });
      this.isConnected = true;
      this.reconnectAttempts = 0;
      log$f.info("Bridge connected successfully");
      this.analyticsApi?.sendEvents([
        {
          event_name: "bridge-connect-established",
          client_environment: "wallet",
          subsystem: getEventsSubsystem(),
          bridge_url: this.config.bridgeUrl,
          client_timestamp: getUnixtime(),
          event_id: uuidv7(),
          network_id: this.walletKitConfig.network,
          trace_id: connectTraceId,
          version: getVersion()
        }
      ]);
    } catch (error2) {
      log$f.error("Bridge connection failed", { error: error2?.toString() });
      this.analyticsApi?.sendEvents([
        {
          event_name: "bridge-connect-error",
          client_environment: "wallet",
          subsystem: getEventsSubsystem(),
          bridge_url: this.config.bridgeUrl,
          error_message: error2?.toString() || "Unknown error",
          event_id: uuidv7(),
          trace_id: error2?.traceId ?? connectTraceId,
          version: getVersion(),
          client_id: error2?.clientId,
          client_timestamp: getUnixtime(),
          error_code: error2?.errorCode,
          network_id: this.walletKitConfig.network
        }
      ]);
      if (!this.config.disableHttpConnection) {
        if (this.reconnectAttempts < (this.config.maxReconnectAttempts || 5)) {
          this.reconnectAttempts++;
          log$f.info("Bridge reconnection attempt", { attempt: this.reconnectAttempts });
          setTimeout(() => {
            this.connectToSSEBridge().catch((error3) => log$f.error("Bridge reconnection failed", { error: error3 }));
          }, this.config.reconnectInterval);
        }
      }
      throw WalletKitError.fromError(ERROR_CODES.BRIDGE_CONNECTION_FAILED, "Failed to connect to bridge", error2, {
        reconnectAttempts: this.reconnectAttempts,
        bridgeUrl: this.config.bridgeUrl
      });
    }
  }
  /**
   * Restart bridge connection in case of error, so we can receive events again
   */
  async restartConnection() {
    await this.close();
    await this.start();
  }
  /**
   * Add client to existing bridge connection
   */
  async updateClients() {
    log$f.debug("Updating clients");
    if (this.bridgeProvider) {
      const clients = await this.getClients();
      log$f.info("[BRIDGE] Restoring connection", { clients: clients.length });
      await this.bridgeProvider.restoreConnection(clients, {
        lastEventId: this.lastEventId
      });
    }
  }
  /**
   * Queue incoming bridge events for processing
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  queueBridgeEvent(event) {
    log$f.debug("Bridge event queued", { eventId: event?.id, event });
    this.eventQueue.push(event);
    this.processBridgeEvents().catch((error2) => {
      log$f.error("Error in background event processing", { error: error2 });
    });
  }
  queueJsBridgeEvent(messageInfo, event) {
    log$f.debug("JS Bridge event queued", { eventId: messageInfo?.messageId });
    if (!event) {
      return;
    }
    if (!event.traceId) {
      event.traceId = uuidv7();
    }
    if (event.method == "connect") {
      this.eventQueue.push({
        ...event,
        isJsBridge: true,
        tabId: messageInfo.tabId,
        domain: messageInfo.domain,
        messageId: messageInfo.messageId
      });
    } else if (event.method == "restoreConnection") {
      this.eventEmitter?.emit("restoreConnection", {
        ...event,
        tabId: messageInfo.tabId,
        domain: messageInfo.domain,
        messageId: messageInfo.messageId
      });
    } else if (event.method == "send" && event?.params?.length === 1) {
      this.eventQueue.push({
        ...event,
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        ...event.params[0],
        isJsBridge: true,
        tabId: messageInfo.tabId,
        domain: messageInfo.domain,
        messageId: messageInfo.messageId
      });
    }
    this.processBridgeEvents().catch((error2) => {
      log$f.error("Error in background event processing", { error: error2 });
    });
  }
  /**
   * Process events from the queue with concurrency control
   * New events from the bridge added to eventQueue to avoid concurrency
   * processBridgeEvents takes events from queue one by one and tries to store them durably
   * if event stored successfully, we will update lastEventId and proceed to the next event
   * if we've encountered error, bridge connection we be restarted from last success id, so we should try to process same event again
   */
  async processBridgeEvents() {
    if (this.isProcessing) {
      log$f.debug("Event processing already in progress, skipping");
      return;
    }
    this.isProcessing = true;
    try {
      while (this.eventQueue.length > 0) {
        const event = this.eventQueue.shift();
        if (event) {
          event.isLocal = false;
          await this.handleBridgeEvent(event);
        }
      }
    } catch (error2) {
      log$f.error("Error during event processing", { error: error2 });
      this.isProcessing = false;
      this.restartConnection();
      return;
    } finally {
      this.isProcessing = false;
    }
  }
  /**
   * Handle individual bridge event (original processing logic)
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async handleBridgeEvent(event) {
    try {
      log$f.info("Bridge event received", { event });
      const rawEvent = {
        id: event.id || crypto.randomUUID(),
        method: event.method || "unknown",
        params: event.params || event,
        // sessionId: event.from,
        timestamp: Date.now(),
        from: event?.from,
        domain: event?.domain,
        isJsBridge: event?.isJsBridge,
        tabId: event?.tabId,
        messageId: event?.messageId,
        traceId: event?.traceId
      };
      if (!rawEvent.traceId) {
        rawEvent.traceId = uuidv7();
      }
      await this.sessionManager.initialize();
      if (rawEvent.from) {
        const session = await this.sessionManager.getSession(rawEvent.from);
        rawEvent.domain = session?.domain || "";
        if (session) {
          if (session?.walletAddress) {
            rawEvent.walletAddress = session.walletAddress;
          }
          rawEvent.dAppInfo = {
            name: session.dAppName,
            description: session.dAppDescription,
            url: session.dAppIconUrl,
            iconUrl: session.dAppIconUrl
          };
        }
      } else if (rawEvent.domain) {
        const session = await this.sessionManager.getSessionByDomain(rawEvent.domain);
        if (session?.walletAddress) {
          rawEvent.walletAddress = session.walletAddress;
        }
        if (session?.sessionId) {
          rawEvent.from = session.sessionId;
        }
        if (session) {
          rawEvent.dAppInfo = {
            name: session.dAppName,
            description: session.dAppDescription,
            url: session.dAppIconUrl,
            iconUrl: session.dAppIconUrl
          };
          if (!rawEvent.from) {
            rawEvent.from = session.sessionId;
          }
        }
      }
      if (!this.eventStore) {
        throw new WalletKitError(ERROR_CODES.EVENT_STORE_NOT_INITIALIZED, "Event store is not initialized");
      }
      try {
        await this.eventStore.storeEvent(rawEvent);
        if (this.eventEmitter) {
          this.eventEmitter.emit("bridge-storage-updated");
        }
        log$f.info("Event stored durably", { eventId: rawEvent.id, method: rawEvent.method });
        if (rawEvent.method == "connect") {
          await this.eventRouter.routeEvent(rawEvent);
        }
      } catch (error2) {
        log$f.error("Failed to store event durably", {
          eventId: rawEvent.id,
          error: error2.message
        });
        throw WalletKitError.fromError(ERROR_CODES.EVENT_STORE_OPERATION_FAILED, "Failed to store event durably", error2, { eventId: rawEvent.id, method: rawEvent.method });
      }
      log$f.info("Bridge event processed", { rawEvent });
      if (event?.lastEventId && event.lastEventId !== this.lastEventId) {
        this.lastEventId = event.lastEventId;
        await this.saveLastEventId();
      }
    } catch (error2) {
      log$f.error("Error handling bridge event", { error: error2 });
    }
  }
  /**
   * Load last event ID from storage
   */
  async loadLastEventId() {
    try {
      const savedEventId = await this.storageAdapter.get(this.storageKey);
      if (savedEventId) {
        this.lastEventId = savedEventId;
        log$f.debug("Loaded last event ID from storage", { lastEventId: this.lastEventId });
      }
    } catch (error2) {
      const storageError = WalletKitError.fromError(ERROR_CODES.STORAGE_READ_FAILED, "Failed to load last event ID from storage", error2);
      log$f.warn("Failed to load last event ID from storage", { error: storageError });
    }
  }
  /**
   * Save last event ID to storage
   */
  async saveLastEventId() {
    try {
      if (this.lastEventId) {
        await this.storageAdapter.set(this.storageKey, this.lastEventId);
        log$f.debug("Saved last event ID to storage", { lastEventId: this.lastEventId });
      }
    } catch (error2) {
      const storageError = WalletKitError.fromError(ERROR_CODES.STORAGE_WRITE_FAILED, "Failed to save last event ID to storage", error2);
      log$f.warn("Failed to save last event ID to storage", { error: storageError });
    }
  }
}
class BasicHandler {
  _notifyHandler;
  constructor(notify) {
    this._notifyHandler = notify;
  }
  async notify(event) {
    if (this._notifyHandler) {
      return await this._notifyHandler(event);
    }
    return Promise.resolve();
  }
}
const log$e = globalLogger.createChild("ConnectHandler");
class ConnectHandler extends BasicHandler {
  analyticsApi;
  walletKitConfig;
  constructor(notify, walletKitConfig, analyticsApi) {
    super(notify);
    this.analyticsApi = analyticsApi;
    this.walletKitConfig = walletKitConfig;
  }
  canHandle(event) {
    return event.method === "connect";
  }
  async handle(event) {
    const manifestUrl = this.extractManifestUrl(event);
    let manifest = null;
    if (manifestUrl) {
      try {
        manifest = await this.fetchManifest(manifestUrl);
      } catch (error2) {
        log$e.warn("Failed to fetch manifest", { error: error2 });
      }
    }
    const preview = this.createPreview(event, manifestUrl, manifest);
    const connectEvent = {
      ...event,
      id: event.id,
      request: event.params?.items || [],
      preview,
      dAppInfo: {
        name: preview?.manifest?.name,
        description: preview?.manifest?.description,
        url: preview?.manifest?.url,
        iconUrl: preview?.manifest?.iconUrl
      },
      isJsBridge: event.isJsBridge,
      tabId: event.tabId
    };
    this.analyticsApi?.sendEvents([
      {
        event_name: "wallet-connect-request-received",
        trace_id: event.traceId ?? uuidv7(),
        client_environment: "wallet",
        subsystem: getEventsSubsystem(),
        client_id: event.from,
        manifest_json_url: manifestUrl || preview?.manifest?.url,
        is_ton_addr: event.params?.items?.some((item) => item.name === "ton_addr") || false,
        is_ton_proof: event.params?.items?.some((item) => item.name === "ton_proof") || false,
        client_timestamp: getUnixtime(),
        event_id: uuidv7(),
        // network_id: event.network,
        version: getVersion(),
        proof_payload_size: event.params?.items?.some((item) => item.name === "ton_proof") ? event.params?.items?.find((item) => item.name === "ton_proof")?.payload?.length : 0,
        wallet_app_name: this.walletKitConfig.deviceInfo?.appName,
        wallet_app_version: this.walletKitConfig.deviceInfo?.appVersion,
        network_id: this.walletKitConfig.network
      }
    ]);
    return connectEvent;
  }
  /**
   * Extract dApp name from bridge event or manifest
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  extractDAppName(event, manifest) {
    const name = manifest?.name || // eslint-disable-next-line @typescript-eslint/no-explicit-any
    event.params?.manifest?.name || "Unknown dApp";
    return name?.toString()?.trim();
  }
  /**
   * Extract manifest URL from bridge event
   */
  extractManifestUrl(event) {
    const url = event.params?.manifest?.url ?? event.params?.manifestUrl ?? "";
    return url.trim();
  }
  /**
   * Create preview object for connect request
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  createPreview(event, manifestUrl, fetchedManifest) {
    const eventManifest = event.params?.manifest;
    const manifest = fetchedManifest || eventManifest;
    const dAppUrl = manifest?.url || manifestUrl || "";
    const sanitizedManifest = manifest && {
      name: manifest.name?.toString()?.trim() || "",
      description: manifest.description?.toString()?.trim() || "",
      url: manifest.url?.toString()?.trim() || "",
      iconUrl: manifest.iconUrl?.toString()?.trim() || "",
      dAppName: this.extractDAppName(event, manifest),
      dAppUrl,
      manifestUrl: manifestUrl || ""
    };
    const requestedItems = event.params?.items || [];
    const permissions = [];
    const addrItem = requestedItems.find((item) => item.name === "ton_addr");
    if (addrItem) {
      permissions.push({
        name: "ton_addr",
        title: "TON Address",
        description: "Gives dApp information about your TON address"
      });
    }
    const proofItem = requestedItems.find((item) => item.name === "ton_proof");
    if (proofItem) {
      permissions.push({
        name: "ton_proof",
        title: "TON Proof",
        description: "Gives dApp signature, that can be used to verify your access to private key"
      });
    }
    return {
      manifest: sanitizedManifest,
      requestedItems: event.params?.items || [],
      permissions
    };
  }
  /**
   * Fetch manifest from URL
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async fetchManifest(manifestUrl) {
    const response = await fetch(manifestUrl);
    if (!response.ok) {
      throw new WalletKitError(ERROR_CODES.API_REQUEST_FAILED, `Failed to fetch manifest: ${response.statusText}`, void 0, { manifestUrl, status: response.status, statusText: response.statusText });
    }
    return response.json();
  }
}
function ot(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var T = { exports: {} }, A, v;
function nt() {
  if (v) return A;
  v = 1;
  var t = 1e3, e = t * 60, o4 = e * 60, n = o4 * 24, a2 = n * 7, r = n * 365.25;
  A = function(u, s2) {
    s2 = s2 || {};
    var p2 = typeof u;
    if (p2 === "string" && u.length > 0)
      return d(u);
    if (p2 === "number" && isFinite(u))
      return s2.long ? l(u) : i(u);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(u)
    );
  };
  function d(u) {
    if (u = String(u), !(u.length > 100)) {
      var s2 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        u
      );
      if (s2) {
        var p2 = parseFloat(s2[1]), _ = (s2[2] || "ms").toLowerCase();
        switch (_) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return p2 * r;
          case "weeks":
          case "week":
          case "w":
            return p2 * a2;
          case "days":
          case "day":
          case "d":
            return p2 * n;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return p2 * o4;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return p2 * e;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return p2 * t;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return p2;
          default:
            return;
        }
      }
    }
  }
  function i(u) {
    var s2 = Math.abs(u);
    return s2 >= n ? Math.round(u / n) + "d" : s2 >= o4 ? Math.round(u / o4) + "h" : s2 >= e ? Math.round(u / e) + "m" : s2 >= t ? Math.round(u / t) + "s" : u + "ms";
  }
  function l(u) {
    var s2 = Math.abs(u);
    return s2 >= n ? f2(u, s2, n, "day") : s2 >= o4 ? f2(u, s2, o4, "hour") : s2 >= e ? f2(u, s2, e, "minute") : s2 >= t ? f2(u, s2, t, "second") : u + " ms";
  }
  function f2(u, s2, p2, _) {
    var U2 = s2 >= p2 * 1.5;
    return Math.round(u / p2) + " " + _ + (U2 ? "s" : "");
  }
  return A;
}
function at(t) {
  o4.debug = o4, o4.default = o4, o4.coerce = l, o4.disable = d, o4.enable = a2, o4.enabled = i, o4.humanize = nt(), o4.destroy = f2, Object.keys(t).forEach((u) => {
    o4[u] = t[u];
  }), o4.names = [], o4.skips = [], o4.formatters = {};
  function e(u) {
    let s2 = 0;
    for (let p2 = 0; p2 < u.length; p2++)
      s2 = (s2 << 5) - s2 + u.charCodeAt(p2), s2 |= 0;
    return o4.colors[Math.abs(s2) % o4.colors.length];
  }
  o4.selectColor = e;
  function o4(u) {
    let s2, p2 = null, _, U2;
    function y2(...h2) {
      if (!y2.enabled)
        return;
      const c = y2, B2 = Number(/* @__PURE__ */ new Date()), P2 = B2 - (s2 || B2);
      c.diff = P2, c.prev = s2, c.curr = B2, s2 = B2, h2[0] = o4.coerce(h2[0]), typeof h2[0] != "string" && h2.unshift("%O");
      let k2 = 0;
      h2[0] = h2[0].replace(/%([a-zA-Z%])/g, (E2, tt) => {
        if (E2 === "%%")
          return "%";
        k2++;
        const L = o4.formatters[tt];
        if (typeof L == "function") {
          const et = h2[k2];
          E2 = L.call(c, et), h2.splice(k2, 1), k2--;
        }
        return E2;
      }), o4.formatArgs.call(c, h2), (c.log || o4.log).apply(c, h2);
    }
    return y2.namespace = u, y2.useColors = o4.useColors(), y2.color = o4.selectColor(u), y2.extend = n, y2.destroy = o4.destroy, Object.defineProperty(y2, "enabled", {
      enumerable: true,
      configurable: false,
      get: () => p2 !== null ? p2 : (_ !== o4.namespaces && (_ = o4.namespaces, U2 = o4.enabled(u)), U2),
      set: (h2) => {
        p2 = h2;
      }
    }), typeof o4.init == "function" && o4.init(y2), y2;
  }
  function n(u, s2) {
    const p2 = o4(this.namespace + (typeof s2 > "u" ? ":" : s2) + u);
    return p2.log = this.log, p2;
  }
  function a2(u) {
    o4.save(u), o4.namespaces = u, o4.names = [], o4.skips = [];
    const s2 = (typeof u == "string" ? u : "").trim().replace(" ", ",").split(",").filter(Boolean);
    for (const p2 of s2)
      p2[0] === "-" ? o4.skips.push(p2.slice(1)) : o4.names.push(p2);
  }
  function r(u, s2) {
    let p2 = 0, _ = 0, U2 = -1, y2 = 0;
    for (; p2 < u.length; )
      if (_ < s2.length && (s2[_] === u[p2] || s2[_] === "*"))
        s2[_] === "*" ? (U2 = _, y2 = p2, _++) : (p2++, _++);
      else if (U2 !== -1)
        _ = U2 + 1, y2++, p2 = y2;
      else
        return false;
    for (; _ < s2.length && s2[_] === "*"; )
      _++;
    return _ === s2.length;
  }
  function d() {
    const u = [
      ...o4.names,
      ...o4.skips.map((s2) => "-" + s2)
    ].join(",");
    return o4.enable(""), u;
  }
  function i(u) {
    for (const s2 of o4.skips)
      if (r(u, s2))
        return false;
    for (const s2 of o4.names)
      if (r(u, s2))
        return true;
    return false;
  }
  function l(u) {
    return u instanceof Error ? u.stack || u.message : u;
  }
  function f2() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return o4.enable(o4.load()), o4;
}
var rt = at;
(function(t, e) {
  e.formatArgs = n, e.save = a2, e.load = r, e.useColors = o4, e.storage = d(), e.destroy = /* @__PURE__ */ (() => {
    let l = false;
    return () => {
      l || (l = true, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), e.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function o4() {
    if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
      return true;
    if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
      return false;
    let l;
    return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && (l = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(l[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function n(l) {
    if (l[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + l[0] + (this.useColors ? "%c " : " ") + "+" + t.exports.humanize(this.diff), !this.useColors)
      return;
    const f2 = "color: " + this.color;
    l.splice(1, 0, f2, "color: inherit");
    let u = 0, s2 = 0;
    l[0].replace(/%[a-zA-Z%]/g, (p2) => {
      p2 !== "%%" && (u++, p2 === "%c" && (s2 = u));
    }), l.splice(s2, 0, f2);
  }
  e.log = console.debug || console.log || (() => {
  });
  function a2(l) {
    try {
      l ? e.storage.setItem("debug", l) : e.storage.removeItem("debug");
    } catch {
    }
  }
  function r() {
    let l;
    try {
      l = e.storage.getItem("debug");
    } catch {
    }
    return !l && typeof process < "u" && "env" in process && (l = process.env.DEBUG), l;
  }
  function d() {
    try {
      return localStorage;
    } catch {
    }
  }
  t.exports = rt(e);
  const { formatters: i } = t.exports;
  i.j = function(l) {
    try {
      return JSON.stringify(l);
    } catch (f2) {
      return "[UnexpectedJSONParseError]: " + f2.message;
    }
  };
})(T, T.exports);
var dt = T.exports;
const $ = /* @__PURE__ */ ot(dt);
function g$1(t) {
  return t.toString(2).length;
}
function C(t) {
  if (t.remainingBits >= 1)
    return {
      kind: "Bool",
      value: t.loadUint(1) == 1
    };
  throw new Error('Expected one of "BoolFalse" in loading "BoolFalse", but data does not satisfy any constructor');
}
function b(t) {
  let e = t.loadUint(8), o4 = Array.from(Array(e).keys()).map((n) => t.loadUint(8));
  return {
    kind: "FixedLengthText",
    n: e,
    value: o4
  };
}
function m(t, e) {
  if (t.remainingBits >= 1 && t.preloadUint(1) == 0)
    return t.loadUint(1), {
      kind: "Maybe_nothing"
    };
  if (t.remainingBits >= 1 && t.preloadUint(1) == 1)
    return t.loadUint(1), {
      kind: "Maybe_just",
      value: e(t)
    };
  throw new Error('Expected one of "Maybe_nothing", "Maybe_just" in loading "Maybe", but data does not satisfy any constructor');
}
function S(t, e, o4) {
  if (t.remainingBits >= 1 && t.preloadUint(1) == 0)
    return t.loadUint(1), {
      kind: "Either_left",
      value: e(t)
    };
  if (t.remainingBits >= 1 && t.preloadUint(1) == 1)
    return t.loadUint(1), {
      kind: "Either_right",
      value: o4(t)
    };
  throw new Error('Expected one of "Either_left", "Either_right" in loading "Either", but data does not satisfy any constructor');
}
function w(t) {
  return {
    kind: "JettonPayload",
    data: t.asCell()
  };
}
function N(t) {
  return {
    kind: "NFTPayload",
    data: t.asCell()
  };
}
function H(t) {
  return {
    kind: "Bytes",
    data: t.asCell()
  };
}
function R(t) {
  return {
    kind: "Text"
  };
}
function it(t) {
  if (t.remainingBits >= 16 && t.preloadUint(16) == 18516)
    return t.loadUint(16), {
      kind: "Protocol"
    };
  throw new Error('Expected one of "Protocol" in loading "Protocol", but data does not satisfy any constructor');
}
function K(t) {
  if (t.remainingBits >= 1 && t.preloadUint(1) == 0)
    return t.loadUint(1), {
      kind: "ProtoList_proto_list_nil"
    };
  if (t.remainingBits >= 1 && t.preloadUint(1) == 1) {
    t.loadUint(1);
    let e = it(t), o4 = K(t);
    return {
      kind: "ProtoList_proto_list_next",
      head: e,
      tail: o4
    };
  }
  throw new Error('Expected one of "ProtoList_proto_list_nil", "ProtoList_proto_list_next" in loading "ProtoList", but data does not satisfy any constructor');
}
function lt(t) {
  if (t.remainingBits >= 16 && t.preloadUint(16) == 8567)
    return t.loadUint(16), {
      kind: "SmcCapability"
    };
  throw new Error('Expected one of "SmcCapability" in loading "SmcCapability", but data does not satisfy any constructor');
}
function z(t) {
  if (t.remainingBits >= 1 && t.preloadUint(1) == 0)
    return t.loadUint(1), {
      kind: "SmcCapList_cap_list_nil"
    };
  if (t.remainingBits >= 1 && t.preloadUint(1) == 1) {
    t.loadUint(1);
    let e = lt(t), o4 = z(t);
    return {
      kind: "SmcCapList_cap_list_next",
      head: e,
      tail: o4
    };
  }
  throw new Error('Expected one of "SmcCapList_cap_list_nil", "SmcCapList_cap_list_next" in loading "SmcCapList", but data does not satisfy any constructor');
}
function st(t) {
  if (t.remainingBits >= 16 && t.preloadUint(16) == 40915) {
    t.loadUint(16);
    let e = t.loadAddress(), o4 = t.loadUint(8), n = o4 & 1 ? z(t) : void 0;
    if (!(o4 <= 1))
      throw new Error('Condition (flags <= 1) is not satisfied while loading "DNSRecord_dns_smc_address" for type "DNSRecord"');
    return {
      kind: "DNSRecord_dns_smc_address",
      smc_addr: e,
      flags: o4,
      cap_list: n
    };
  }
  if (t.remainingBits >= 16 && t.preloadUint(16) == 47763)
    return t.loadUint(16), {
      kind: "DNSRecord_dns_next_resolver",
      resolver: t.loadAddress()
    };
  if (t.remainingBits >= 16 && t.preloadUint(16) == 44289) {
    t.loadUint(16);
    let e = t.loadBuffer(256 / 8), o4 = t.loadUint(8), n = o4 & 1 ? K(t) : void 0;
    if (!(o4 <= 1))
      throw new Error('Condition (flags <= 1) is not satisfied while loading "DNSRecord_dns_adnl_address" for type "DNSRecord"');
    return {
      kind: "DNSRecord_dns_adnl_address",
      adnl_addr: e,
      flags: o4,
      proto_list: n
    };
  }
  if (t.remainingBits >= 16 && t.preloadUint(16) == 29811)
    return t.loadUint(16), {
      kind: "DNSRecord_dns_storage_address",
      bag_id: t.loadBuffer(256 / 8)
    };
  throw new Error('Expected one of "DNSRecord_dns_smc_address", "DNSRecord_dns_next_resolver", "DNSRecord_dns_adnl_address", "DNSRecord_dns_storage_address" in loading "DNSRecord", but data does not satisfy any constructor');
}
function ut(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1112786133) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadVarUintBig(g$1(15)), n = m(t, (a2) => a2.loadRef().beginParse(true).asCell());
    return {
      kind: "BemoStake",
      query_id: e,
      forward_ton_amount: o4,
      forward_payload: n
    };
  }
  throw new Error('Expected one of "BemoStake" in loading "BemoStake", but data does not satisfy any constructor');
}
function ft(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1227534771) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadAddressAny(), n = t.loadVarUintBig(g$1(15)), a2 = t.loadVarUintBig(g$1(15)), r = m(t, (d) => d.loadRef().beginParse(true).asCell());
    return {
      kind: "BemoUnstake",
      index: e,
      owner: o4,
      ton_amount: n,
      jetton_amount: a2,
      forward_payload: r
    };
  }
  throw new Error('Expected one of "BemoUnstake" in loading "BemoUnstake", but data does not satisfy any constructor');
}
function pt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 279039605) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadAddressAny(), n = t.loadVarUintBig(g$1(15)), a2 = t.loadVarUintBig(g$1(15)), r = m(t, (i) => i.loadRef().beginParse(true).asCell()), d = t.loadUint(32);
    return {
      kind: "BemoDeployUnstakeRequest",
      query_id: e,
      owner_address: o4,
      withdraw_ton_amount: n,
      withdraw_jetton_amount: a2,
      forward_payload: r,
      lockup_timestamp: d
    };
  }
  throw new Error('Expected one of "BemoDeployUnstakeRequest" in loading "BemoDeployUnstakeRequest", but data does not satisfy any constructor');
}
function mt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2429028871) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = m(t, (n) => n.loadRef().beginParse(true).asCell());
    return {
      kind: "BemoUnstakeNotification",
      query_id: e,
      forward_payload: o4
    };
  }
  throw new Error('Expected one of "BemoUnstakeNotification" in loading "BemoUnstakeNotification", but data does not satisfy any constructor');
}
function gt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 946025784)
    return t.loadUint(32), {
      kind: "BemoReturnUnstakeRequest",
      lockup_timestamp: t.loadUint(32)
    };
  throw new Error('Expected one of "BemoReturnUnstakeRequest" in loading "BemoReturnUnstakeRequest", but data does not satisfy any constructor');
}
function _t(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1544662441)
    return t.loadUint(32), {
      kind: "DaolamaVaultSupply",
      amount: t.loadCoins()
    };
  throw new Error('Expected one of "DaolamaVaultSupply" in loading "DaolamaVaultSupply", but data does not satisfy any constructor');
}
function yt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2078119902) {
    t.loadUint(32);
    let e = t.loadCoins(), o4 = t.loadAddressAny();
    return {
      kind: "DaolamaVaultWithdraw",
      jetton_amount: e,
      user_address: o4
    };
  }
  throw new Error('Expected one of "DaolamaVaultWithdraw" in loading "DaolamaVaultWithdraw", but data does not satisfy any constructor');
}
function V(t) {
  if (t.remainingBits >= 4 && t.preloadUint(4) == 0)
    return t.loadUint(4), {
      kind: "DedustAsset_native"
    };
  if (t.remainingBits >= 4 && t.preloadUint(4) == 1) {
    t.loadUint(4);
    let e = t.loadInt(8), o4 = t.loadBuffer(256 / 8);
    return {
      kind: "DedustAsset_jetton",
      workchain_id: e,
      address: o4
    };
  }
  if (t.remainingBits >= 4 && t.preloadUint(4) == 2)
    return t.loadUint(4), {
      kind: "DedustAsset_extra_currency",
      currency_id: t.loadInt(32)
    };
  throw new Error('Expected one of "DedustAsset_native", "DedustAsset_jetton", "DedustAsset_extra_currency" in loading "DedustAsset", but data does not satisfy any constructor');
}
function Ut(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3043726744) {
    t.loadUint(32);
    let e = t.loadUintBig(64), n = t.loadRef().beginParse(true).asCell(), a2 = t.loadAddressAny(), r = t.loadVarUintBig(g$1(15)), d = t.loadRef().beginParse(true), i = V(d), l = d.loadVarUintBig(g$1(15)), f2 = V(d), u = d.loadVarUintBig(g$1(15)), s2 = m(t, (_) => _.loadRef().beginParse(true).asCell()), p2 = m(t, (_) => _.loadRef().beginParse(true).asCell());
    return {
      kind: "DedustDepositLiquidityAll",
      query_id: e,
      proof: n,
      owner_addr: a2,
      min_lp_amount: r,
      asset0: i,
      asset0_amount: l,
      asset1: f2,
      asset1_amount: u,
      fulfill_payload: s2,
      reject_payload: p2
    };
  }
  throw new Error('Expected one of "DedustDepositLiquidityAll" in loading "DedustDepositLiquidityAll", but data does not satisfy any constructor');
}
function ht(t) {
  let e = t.loadUint(32), o4 = t.loadAddressAny(), n = t.loadAddressAny(), a2 = m(t, (d) => d.loadRef().beginParse(true).asCell()), r = m(t, (d) => d.loadRef().beginParse(true).asCell());
  return {
    kind: "DedustSwapParams",
    deadline: e,
    recipient_addr: o4,
    referral_addr: n,
    fulfill_payload: a2,
    reject_payload: r
  };
}
function Q(t) {
  let e = C(t), o4 = t.loadVarUintBig(g$1(15)), n = m(t, (a2) => {
    let r = a2.loadRef().beginParse(true);
    return Ct(r);
  });
  return {
    kind: "DedustSwapStepParams",
    kind_out: e,
    limit: o4,
    next: n
  };
}
function Ct(t) {
  let e = t.loadAddressAny(), o4 = Q(t);
  return {
    kind: "DedustSwapStep",
    pool_addr: e,
    params: o4
  };
}
function ct(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1643009069) {
    t.loadUint(32);
    let e = t.loadUintBig(64), n = t.loadRef().beginParse(true).asCell(), a2 = t.loadVarUintBig(g$1(15)), r = t.loadAddressAny(), d = Q(t), i = t.loadRef().beginParse(true), l = ht(i);
    return {
      kind: "DedustSwapExternal",
      query_id: e,
      proof: n,
      amount: a2,
      sender_addr: r,
      current: d,
      swap_params: l
    };
  }
  throw new Error('Expected one of "DedustSwapExternal" in loading "DedustSwapExternal", but data does not satisfy any constructor');
}
function wt(t) {
  if (t.remainingBits >= 4 && t.preloadUint(4) == 0)
    return t.loadUint(4), {
      kind: "DedustAsset_native"
    };
  if (t.remainingBits >= 4 && t.preloadUint(4) == 1) {
    t.loadUint(4);
    let e = t.loadInt(8), o4 = t.loadBuffer(256 / 8);
    return {
      kind: "DedustAsset_jetton",
      workchain_id: e,
      address: o4
    };
  }
  if (t.remainingBits >= 4 && t.preloadUint(4) == 2)
    return t.loadUint(4), {
      kind: "DedustAsset_extra_currency",
      currency_id: t.loadInt(32)
    };
  throw new Error('Expected one of "DedustAsset_native", "DedustAsset_jetton", "DedustAsset_extra_currency" in loading "DedustAsset", but data does not satisfy any constructor');
}
function kt(t) {
  let e = t.loadUint(32), o4 = t.loadAddressAny(), n = t.loadAddressAny(), a2 = m(t, (d) => d.loadRef().beginParse(true).asCell()), r = m(t, (d) => d.loadRef().beginParse(true).asCell());
  return {
    kind: "DedustSwapParams",
    deadline: e,
    recipient_addr: o4,
    referral_addr: n,
    fulfill_payload: a2,
    reject_payload: r
  };
}
function Z(t) {
  let e = C(t), o4 = t.loadVarUintBig(g$1(15)), n = m(t, (a2) => {
    let r = a2.loadRef().beginParse(true);
    return St(r);
  });
  return {
    kind: "DedustSwapStepParams",
    kind_out: e,
    limit: o4,
    next: n
  };
}
function St(t) {
  let e = t.loadAddressAny(), o4 = Z(t);
  return {
    kind: "DedustSwapStep",
    pool_addr: e,
    params: o4
  };
}
function Bt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1923917994) {
    t.loadUint(32);
    let e = t.loadUintBig(64), n = t.loadRef().beginParse(true).asCell(), a2 = wt(t), r = t.loadVarUintBig(g$1(15)), d = t.loadAddressAny(), i = Z(t), l = t.loadRef().beginParse(true), f2 = kt(l);
    return {
      kind: "DedustSwapPeer",
      query_id: e,
      proof: n,
      asset: a2,
      amount: r,
      sender_addr: d,
      current: i,
      swap_params: f2
    };
  }
  throw new Error('Expected one of "DedustSwapPeer" in loading "DedustSwapPeer", but data does not satisfy any constructor');
}
function xt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2907617013) {
    t.loadUint(32);
    let e = t.loadUintBig(64), n = t.loadRef().beginParse(true).asCell(), a2 = t.loadVarUintBig(g$1(15)), r = t.loadAddressAny(), d = m(t, (i) => i.loadRef().beginParse(true).asCell());
    return {
      kind: "DedustPayoutFromPool",
      query_id: e,
      proof: n,
      amount: a2,
      recipient_addr: r,
      payload: d
    };
  }
  throw new Error('Expected one of "DedustPayoutFromPool" in loading "DedustPayoutFromPool", but data does not satisfy any constructor');
}
function bt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1196394191) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = m(t, (n) => n.loadRef().beginParse(true).asCell());
    return {
      kind: "DedustPayout",
      query_id: e,
      payload: o4
    };
  }
  throw new Error('Expected one of "DedustPayout" in loading "DedustPayout", but data does not satisfy any constructor');
}
function Nt(t) {
  let e = t.loadUint(32), o4 = t.loadAddressAny(), n = t.loadAddressAny(), a2 = m(t, (d) => d.loadRef().beginParse(true).asCell()), r = m(t, (d) => d.loadRef().beginParse(true).asCell());
  return {
    kind: "DedustSwapParams",
    deadline: e,
    recipient_addr: o4,
    referral_addr: n,
    fulfill_payload: a2,
    reject_payload: r
  };
}
function Pt(t) {
  let e = C(t), o4 = t.loadVarUintBig(g$1(15)), n = m(t, (a2) => {
    let r = a2.loadRef().beginParse(true);
    return X(r);
  });
  return {
    kind: "DedustSwapStepParams",
    kind_out: e,
    limit: o4,
    next: n
  };
}
function X(t) {
  let e = t.loadAddressAny(), o4 = Pt(t);
  return {
    kind: "DedustSwapStep",
    pool_addr: e,
    params: o4
  };
}
function Et(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3926267997) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadCoins(), n = X(t), a2 = t.loadRef().beginParse(true), r = Nt(a2);
    return {
      kind: "DedustSwap",
      query_id: e,
      amount: o4,
      step: n,
      swap_params: r
    };
  }
  throw new Error('Expected one of "DedustSwap" in loading "DedustSwap", but data does not satisfy any constructor');
}
function F(t) {
  if (t.remainingBits >= 4 && t.preloadUint(4) == 0)
    return t.loadUint(4), {
      kind: "DedustAsset_native"
    };
  if (t.remainingBits >= 4 && t.preloadUint(4) == 1) {
    t.loadUint(4);
    let e = t.loadInt(8), o4 = t.loadBuffer(256 / 8);
    return {
      kind: "DedustAsset_jetton",
      workchain_id: e,
      address: o4
    };
  }
  if (t.remainingBits >= 4 && t.preloadUint(4) == 2)
    return t.loadUint(4), {
      kind: "DedustAsset_extra_currency",
      currency_id: t.loadInt(32)
    };
  throw new Error('Expected one of "DedustAsset_native", "DedustAsset_jetton", "DedustAsset_extra_currency" in loading "DedustAsset", but data does not satisfy any constructor');
}
function At(t) {
  if (t.remainingBits >= 1 && t.preloadUint(1) == 0)
    return t.loadUint(1), {
      kind: "DedustPoolType_volatile"
    };
  if (t.remainingBits >= 1 && t.preloadUint(1) == 1)
    return t.loadUint(1), {
      kind: "DedustPoolType_stable"
    };
  throw new Error('Expected one of "DedustPoolType_volatile", "DedustPoolType_stable" in loading "DedustPoolType", but data does not satisfy any constructor');
}
function Tt(t) {
  let e = At(t), o4 = F(t), n = F(t);
  return {
    kind: "DedustPoolParams",
    pool_type: e,
    asset0: o4,
    asset1: n
  };
}
function Dt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3579725446) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadCoins(), n = Tt(t), a2 = t.loadRef().beginParse(true), r = a2.loadCoins(), d = a2.loadCoins(), i = a2.loadCoins(), l = m(t, (u) => u.loadRef().beginParse(true).asCell()), f2 = m(t, (u) => u.loadRef().beginParse(true).asCell());
    return {
      kind: "DedustDepositLiquidity",
      query_id: e,
      amount: o4,
      pool_params: n,
      min_lp_amount: r,
      asset0_target_balance: d,
      asset1_target_balance: i,
      fulfill_payload: l,
      reject_payload: f2
    };
  }
  throw new Error('Expected one of "DedustDepositLiquidity" in loading "DedustDepositLiquidity", but data does not satisfy any constructor');
}
function Rt(t) {
  if (t.remainingBits >= 4 && t.preloadUint(4) == 0)
    return t.loadUint(4), {
      kind: "DedustAsset_native"
    };
  if (t.remainingBits >= 4 && t.preloadUint(4) == 1) {
    t.loadUint(4);
    let e = t.loadInt(8), o4 = t.loadBuffer(256 / 8);
    return {
      kind: "DedustAsset_jetton",
      workchain_id: e,
      address: o4
    };
  }
  if (t.remainingBits >= 4 && t.preloadUint(4) == 2)
    return t.loadUint(4), {
      kind: "DedustAsset_extra_currency",
      currency_id: t.loadInt(32)
    };
  throw new Error('Expected one of "DedustAsset_native", "DedustAsset_jetton", "DedustAsset_extra_currency" in loading "DedustAsset", but data does not satisfy any constructor');
}
function qt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 567271467) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = Rt(t);
    return {
      kind: "DedustCreateVault",
      query_id: e,
      asset: o4
    };
  }
  throw new Error('Expected one of "DedustCreateVault" in loading "DedustCreateVault", but data does not satisfy any constructor');
}
function W(t) {
  if (t.remainingBits >= 4 && t.preloadUint(4) == 0)
    return t.loadUint(4), {
      kind: "DedustAsset_native"
    };
  if (t.remainingBits >= 4 && t.preloadUint(4) == 1) {
    t.loadUint(4);
    let e = t.loadInt(8), o4 = t.loadBuffer(256 / 8);
    return {
      kind: "DedustAsset_jetton",
      workchain_id: e,
      address: o4
    };
  }
  if (t.remainingBits >= 4 && t.preloadUint(4) == 2)
    return t.loadUint(4), {
      kind: "DedustAsset_extra_currency",
      currency_id: t.loadInt(32)
    };
  throw new Error('Expected one of "DedustAsset_native", "DedustAsset_jetton", "DedustAsset_extra_currency" in loading "DedustAsset", but data does not satisfy any constructor');
}
function Lt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2547326767) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = W(t), n = W(t);
    return {
      kind: "DedustCreateVolatilePool",
      query_id: e,
      asset0: o4,
      asset1: n
    };
  }
  throw new Error('Expected one of "DedustCreateVolatilePool" in loading "DedustCreateVolatilePool", but data does not satisfy any constructor');
}
function vt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 376237550) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = m(t, (n) => n.loadRef().beginParse(true).asCell());
    return {
      kind: "DedustCancelDeposit",
      query_id: e,
      payload: o4
    };
  }
  throw new Error('Expected one of "DedustCancelDeposit" in loading "DedustCancelDeposit", but data does not satisfy any constructor');
}
function Vt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1322339173)
    return t.loadUint(32), {
      kind: "DnsBalanceRelease",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "DnsBalanceRelease" in loading "DnsBalanceRelease", but data does not satisfy any constructor');
}
function Ft(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1320284409) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadBuffer(256 / 8);
    return {
      kind: "DeleteDnsRecord",
      query_id: e,
      key: o4
    };
  }
  throw new Error('Expected one of "DeleteDnsRecord" in loading "DeleteDnsRecord", but data does not satisfy any constructor');
}
function Wt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1320284409) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadBuffer(256 / 8), n = t.loadRef().beginParse(true), a2 = st(n);
    return {
      kind: "ChangeDnsRecord",
      query_id: e,
      key: o4,
      value: a2
    };
  }
  throw new Error('Expected one of "ChangeDnsRecord" in loading "ChangeDnsRecord", but data does not satisfy any constructor');
}
function Jt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1153347137)
    return t.loadUint(32), {
      kind: "ProcessGovernanceDecision",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "ProcessGovernanceDecision" in loading "ProcessGovernanceDecision", but data does not satisfy any constructor');
}
function It(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 923790417)
    return t.loadUint(32), {
      kind: "AuctionFillUp",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "AuctionFillUp" in loading "AuctionFillUp", but data does not satisfy any constructor');
}
function Ot(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1434249760)
    return t.loadUint(32), {
      kind: "OutbidNotification",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "OutbidNotification" in loading "OutbidNotification", but data does not satisfy any constructor');
}
function Mt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1298755173) {
    t.loadUint(32);
    let e = t.loadUint(8), o4 = t.loadUint(32), n = t.loadBuffer(256 / 8), a2 = t.loadBuffer(256 / 8), r = t.loadUintBig(128), d = t.loadBuffer(256 / 8);
    return {
      kind: "GramSubmitProofOfWork",
      flags: e,
      expire: o4,
      whom: n,
      rdata1: a2,
      rseed: r,
      rdata2: d
    };
  }
  throw new Error('Expected one of "GramSubmitProofOfWork" in loading "GramSubmitProofOfWork", but data does not satisfy any constructor');
}
function jt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1027039654) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadAddressAny(), n = t.loadVarUintBig(g$1(15)), a2 = t.loadVarUintBig(g$1(15)), r = t.loadAddressAny();
    return {
      kind: "HipoFinanceDepositCoins",
      query_id: e,
      owner: o4,
      coins: n,
      ownership_assigned_amount: a2,
      referrer: r
    };
  }
  throw new Error('Expected one of "HipoFinanceDepositCoins" in loading "HipoFinanceDepositCoins", but data does not satisfy any constructor');
}
function Gt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1541764646) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadVarUintBig(g$1(15)), n = t.loadVarUintBig(g$1(15)), a2 = t.loadAddressAny(), r = t.loadUint(32);
    return {
      kind: "HipoFinanceProxyTokensMinted",
      query_id: e,
      tokens: o4,
      coins: n,
      owner: a2,
      round_since: r
    };
  }
  throw new Error('Expected one of "HipoFinanceProxyTokensMinted" in loading "HipoFinanceProxyTokensMinted", but data does not satisfy any constructor');
}
function $t(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1413869550) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadVarUintBig(g$1(15)), n = t.loadVarUintBig(g$1(15)), a2 = t.loadAddressAny(), r = t.loadUint(32);
    return {
      kind: "HipoFinanceTokensMinted",
      query_id: e,
      tokens: o4,
      coins: n,
      owner: a2,
      round_since: r
    };
  }
  throw new Error('Expected one of "HipoFinanceTokensMinted" in loading "HipoFinanceTokensMinted", but data does not satisfy any constructor');
}
function Ht(t) {
  if (t.remainingBits >= 8 && t.preloadUint(8) == 0)
    return t.loadUint(8), {
      kind: "PaymentProviderUrl_none"
    };
  if (t.remainingBits >= 8 && t.preloadUint(8) == 1)
    return t.loadUint(8), {
      kind: "PaymentProviderUrl_tonsite",
      address: t.loadBuffer(256 / 8)
    };
  throw new Error('Expected one of "PaymentProviderUrl_none", "PaymentProviderUrl_tonsite" in loading "PaymentProviderUrl", but data does not satisfy any constructor');
}
function Kt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2057453237) {
    t.loadUint(32);
    let e = t.loadBuffer(128 / 8), o4 = Ht(t);
    return {
      kind: "InvoicePayload",
      id: e,
      url: o4
    };
  }
  throw new Error('Expected one of "InvoicePayload" in loading "InvoicePayload", but data does not satisfy any constructor');
}
function zt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 260734629) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadVarUintBig(g$1(15)), n = t.loadAddressAny(), a2 = t.loadAddressAny(), r = m(t, (l) => l.loadRef().beginParse(true).asCell()), d = t.loadVarUintBig(g$1(15)), i = S(t, w, (l) => {
      let f2 = l.loadRef().beginParse(true);
      return w(f2);
    });
    return {
      kind: "JettonTransfer",
      query_id: e,
      amount: o4,
      destination: n,
      response_destination: a2,
      custom_payload: r,
      forward_ton_amount: d,
      forward_payload: i
    };
  }
  throw new Error('Expected one of "JettonTransfer" in loading "JettonTransfer", but data does not satisfy any constructor');
}
function Qt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 395134233) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadVarUintBig(g$1(15)), n = t.loadAddressAny(), a2 = t.loadAddressAny(), r = t.loadVarUintBig(g$1(15)), d = S(t, w, (i) => {
      let l = i.loadRef().beginParse(true);
      return w(l);
    });
    return {
      kind: "JettonInternalTransfer",
      query_id: e,
      amount: o4,
      from: n,
      response_address: a2,
      forward_ton_amount: r,
      forward_payload: d
    };
  }
  throw new Error('Expected one of "JettonInternalTransfer" in loading "JettonInternalTransfer", but data does not satisfy any constructor');
}
function Zt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1499400124) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadVarUintBig(g$1(15)), n = t.loadAddressAny(), a2 = m(t, (r) => {
      let d = r.loadRef().beginParse(true);
      return w(d);
    });
    return {
      kind: "JettonBurn",
      query_id: e,
      amount: o4,
      response_destination: n,
      custom_payload: a2
    };
  }
  throw new Error('Expected one of "JettonBurn" in loading "JettonBurn", but data does not satisfy any constructor');
}
function Xt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2078119902) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadVarUintBig(g$1(15)), n = t.loadAddressAny(), a2 = t.loadAddressAny();
    return {
      kind: "JettonBurnNotification",
      query_id: e,
      amount: o4,
      sender: n,
      response_destination: a2
    };
  }
  throw new Error('Expected one of "JettonBurnNotification" in loading "JettonBurnNotification", but data does not satisfy any constructor');
}
function Yt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1935855772) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadVarUintBig(g$1(15)), n = t.loadAddressAny(), a2 = S(t, w, (r) => {
      let d = r.loadRef().beginParse(true);
      return w(d);
    });
    return {
      kind: "JettonNotify",
      query_id: e,
      amount: o4,
      sender: n,
      forward_payload: a2
    };
  }
  throw new Error('Expected one of "JettonNotify" in loading "JettonNotify", but data does not satisfy any constructor');
}
function te(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 4006754003) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadUint(4);
    return {
      kind: "JettonSetStatus",
      query_id: e,
      status: o4
    };
  }
  throw new Error('Expected one of "JettonSetStatus" in loading "JettonSetStatus", but data does not satisfy any constructor');
}
function ee(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1680571655) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadAddress(), n = t.loadCoins();
    return {
      kind: "JettonMint",
      query_id: e,
      to_address: o4,
      ton_amount: n
    };
  }
  throw new Error('Expected one of "JettonMint" in loading "JettonMint", but data does not satisfy any constructor');
}
function oe(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1694626644) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadAddressAny();
    return {
      kind: "JettonChangeAdmin",
      query_id: e,
      new_admin_address: o4
    };
  }
  throw new Error('Expected one of "JettonChangeAdmin" in loading "JettonChangeAdmin", but data does not satisfy any constructor');
}
function ne(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 4220051737)
    return t.loadUint(32), {
      kind: "JettonClaimAdmin",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "JettonClaimAdmin" in loading "JettonClaimAdmin", but data does not satisfy any constructor');
}
function ae(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 4006754003) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadUint(4);
    return {
      kind: "JettonForceAction_set_status",
      query_id: e,
      status: o4
    };
  }
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1499400124) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadVarUintBig(g$1(15)), n = t.loadAddressAny(), a2 = m(t, (r) => {
      let d = r.loadRef().beginParse(true);
      return w(d);
    });
    return {
      kind: "JettonForceAction_burn",
      query_id: e,
      amount: o4,
      response_destination: n,
      custom_payload: a2
    };
  }
  if (t.remainingBits >= 32 && t.preloadUint(32) == 260734629) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadVarUintBig(g$1(15)), n = t.loadAddressAny(), a2 = t.loadAddressAny(), r = m(t, (l) => l.loadRef().beginParse(true).asCell()), d = t.loadVarUintBig(g$1(15)), i = S(t, w, (l) => {
      let f2 = l.loadRef().beginParse(true);
      return w(f2);
    });
    return {
      kind: "JettonForceAction_transfer",
      query_id: e,
      amount: o4,
      destination: n,
      response_destination: a2,
      custom_payload: r,
      forward_ton_amount: d,
      forward_payload: i
    };
  }
  throw new Error('Expected one of "JettonForceAction_set_status", "JettonForceAction_burn", "JettonForceAction_transfer" in loading "JettonForceAction", but data does not satisfy any constructor');
}
function re(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 593276754) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadAddress(), n = t.loadCoins(), a2 = t.loadRef().beginParse(true), r = ae(a2);
    return {
      kind: "JettonCallTo",
      query_id: e,
      to_address: o4,
      ton_amount: n,
      master_msg: r
    };
  }
  throw new Error('Expected one of "JettonCallTo" in loading "JettonCallTo", but data does not satisfy any constructor');
}
function de(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 621336170) {
    t.loadUint(32);
    let e = t.loadUintBig(64), n = t.loadRef().beginParse(true).asCell(), r = t.loadRef().beginParse(true).asCell();
    return {
      kind: "JettonUpgrade",
      query_id: e,
      new_data: n,
      new_code: r
    };
  }
  throw new Error('Expected one of "JettonUpgrade" in loading "JettonUpgrade", but data does not satisfy any constructor');
}
function ie(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3414567170) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.asCell();
    return {
      kind: "JettonChangeMetadata",
      query_id: e,
      metadata: o4
    };
  }
  throw new Error('Expected one of "JettonChangeMetadata" in loading "JettonChangeMetadata", but data does not satisfy any constructor');
}
function le(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 4294967295)
    return t.loadUint(32), {
      kind: "Bounce",
      payload: t.asCell()
    };
  throw new Error('Expected one of "Bounce" in loading "Bounce", but data does not satisfy any constructor');
}
function se(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 0)
    return t.loadUint(32), {
      kind: "TextComment",
      text: R()
    };
  throw new Error('Expected one of "TextComment" in loading "TextComment", but data does not satisfy any constructor');
}
function ue(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 560454219)
    return t.loadUint(32), {
      kind: "EncryptedTextComment",
      cipher_text: H(t)
    };
  throw new Error('Expected one of "EncryptedTextComment" in loading "EncryptedTextComment", but data does not satisfy any constructor');
}
function fe(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3576854235)
    return t.loadUint(32), {
      kind: "Excess",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "Excess" in loading "Excess", but data does not satisfy any constructor');
}
function pe(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3547469196)
    return t.loadUint(32), {
      kind: "TopUp",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "TopUp" in loading "TopUp", but data does not satisfy any constructor');
}
function me(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 378586628) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadCoins();
    return {
      kind: "Credit",
      query_id: e,
      amount: o4
    };
  }
  throw new Error('Expected one of "Credit" in loading "Credit", but data does not satisfy any constructor');
}
function ge(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2068529894)
    return t.loadUint(32), {
      kind: "Approve",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "Approve" in loading "Approve", but data does not satisfy any constructor');
}
function _e(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3902843902)
    return t.loadUint(32), {
      kind: "Disapprove",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "Disapprove" in loading "Disapprove", but data does not satisfy any constructor');
}
function ye(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1316189259) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadBuffer(256 / 8), n = t.loadUint(32), a2 = t.loadUint(32), r = t.loadBuffer(256 / 8), i = t.loadRef().beginParse(true).loadBuffer(512 / 8);
    return {
      kind: "ElectorNewStake",
      query_id: e,
      validator_pubkey: o4,
      stake_at: n,
      max_factor: a2,
      adnl_addr: r,
      signature: i
    };
  }
  throw new Error('Expected one of "ElectorNewStake" in loading "ElectorNewStake", but data does not satisfy any constructor');
}
function Ue(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 4084484172)
    return t.loadUint(32), {
      kind: "ElectorNewStakeConfirmation",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "ElectorNewStakeConfirmation" in loading "ElectorNewStakeConfirmation", but data does not satisfy any constructor');
}
function he(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1197831204)
    return t.loadUint(32), {
      kind: "ElectorRecoverStakeRequest",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "ElectorRecoverStakeRequest" in loading "ElectorRecoverStakeRequest", but data does not satisfy any constructor');
}
function Ce(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 4184830756)
    return t.loadUint(32), {
      kind: "ElectorRecoverStakeResponse",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "ElectorRecoverStakeResponse" in loading "ElectorRecoverStakeResponse", but data does not satisfy any constructor');
}
function ce(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3946265093)
    return t.loadUint(32), {
      kind: "TonstakeControllerRecoverStake",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "TonstakeControllerRecoverStake" in loading "TonstakeControllerRecoverStake", but data does not satisfy any constructor');
}
function we(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 4043121232)
    return t.loadUint(32), {
      kind: "TonstakeControllerUpdateValidatorHash",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "TonstakeControllerUpdateValidatorHash" in loading "TonstakeControllerUpdateValidatorHash", but data does not satisfy any constructor');
}
function ke(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2399065977) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadCoins();
    return {
      kind: "TonstakeControllerWithdrawValidator",
      query_id: e,
      value: o4
    };
  }
  throw new Error('Expected one of "TonstakeControllerWithdrawValidator" in loading "TonstakeControllerWithdrawValidator", but data does not satisfy any constructor');
}
function Se(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 805462823) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadCoins();
    return {
      kind: "TonstakeControllerValidatorWithdrawal",
      query_id: e,
      amount: o4
    };
  }
  throw new Error('Expected one of "TonstakeControllerValidatorWithdrawal" in loading "TonstakeControllerValidatorWithdrawal", but data does not satisfy any constructor');
}
function Be(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3763363086) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadCoins(), n = t.loadUintBig(256), a2 = t.loadUint(32), r = t.loadUint(32), d = t.loadUintBig(256), l = t.loadRef().beginParse(true).loadBuffer(512 / 8);
    return {
      kind: "TonstakeControllerNewStake",
      query_id: e,
      value: o4,
      validator_pubkey: n,
      stake_at: a2,
      max_factor: r,
      adnl_addr: d,
      signature: l
    };
  }
  throw new Error('Expected one of "TonstakeControllerNewStake" in loading "TonstakeControllerNewStake", but data does not satisfy any constructor');
}
function xe(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1664463130) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadCoins(), n = t.loadCoins(), a2 = t.loadUint(24);
    return {
      kind: "TonstakeControllerSendRequestLoan",
      query_id: e,
      min_loan: o4,
      max_loan: n,
      max_interst: a2
    };
  }
  throw new Error('Expected one of "TonstakeControllerSendRequestLoan" in loading "TonstakeControllerSendRequestLoan", but data does not satisfy any constructor');
}
function be(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3983767718)
    return t.loadUint(32), {
      kind: "TonstakeControllerReturnUnusedLoan",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "TonstakeControllerReturnUnusedLoan" in loading "TonstakeControllerReturnUnusedLoan", but data does not satisfy any constructor');
}
function Ne(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1438805205)
    return t.loadUint(32), {
      kind: "TonstakeControllerReturnAvailableFunds",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "TonstakeControllerReturnAvailableFunds" in loading "TonstakeControllerReturnAvailableFunds", but data does not satisfy any constructor');
}
function Pe(t) {
  let e = t.loadUint(32), o4 = t.loadAddressAny(), n = t.loadAddressAny(), a2 = t.loadAddressAny(), r = t.loadRef().beginParse(true), d = r.loadAddressAny(), i = r.loadAddressAny();
  return {
    kind: "TonstakersControllerData",
    controller_id: e,
    validator: o4,
    pool: n,
    governor: a2,
    approver: d,
    halter: i
  };
}
function Ee(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3863136613) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadCoins(), n = t.loadCoins(), a2 = t.loadUint(24), r = t.loadRef().beginParse(true), d = Pe(r);
    return {
      kind: "TonstakePoolRequestLoan",
      query_id: e,
      min_loan: o4,
      max_loan: n,
      max_interest: a2,
      controller_data: d
    };
  }
  throw new Error('Expected one of "TonstakePoolRequestLoan" in loading "TonstakePoolRequestLoan", but data does not satisfy any constructor');
}
function Ae(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3755778683)
    return t.loadUint(32), {
      kind: "TonstakePoolLoanRepayment",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "TonstakePoolLoanRepayment" in loading "TonstakePoolLoanRepayment", but data does not satisfy any constructor');
}
function Te$1(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1205158801) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.asCell();
    return {
      kind: "TonstakePoolDeposit",
      query_id: e,
      referral: o4
    };
  }
  throw new Error('Expected one of "TonstakePoolDeposit" in loading "TonstakePoolDeposit", but data does not satisfy any constructor');
}
function De(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1271382751)
    return t.loadUint(32), {
      kind: "TonstakePoolTouch",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "TonstakePoolTouch" in loading "TonstakePoolTouch", but data does not satisfy any constructor');
}
function Re(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 715822752) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadUint(16);
    return {
      kind: "TonstakePoolSetGovernanceFee",
      query_id: e,
      governance_fee: o4
    };
  }
  throw new Error('Expected one of "TonstakePoolSetGovernanceFee" in loading "TonstakePoolSetGovernanceFee", but data does not satisfy any constructor');
}
function qe(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 832244956) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadCoins(), n = t.loadAddressAny(), a2 = t.loadAddressAny();
    return {
      kind: "TonstakePoolWithdraw",
      query_id: e,
      jetton_amount: o4,
      from_address: n,
      response_address: a2
    };
  }
  throw new Error('Expected one of "TonstakePoolWithdraw" in loading "TonstakePoolWithdraw", but data does not satisfy any constructor');
}
function Le(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 175592284)
    return t.loadUint(32), {
      kind: "TonstakePoolWithdrawal",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "TonstakePoolWithdrawal" in loading "TonstakePoolWithdrawal", but data does not satisfy any constructor');
}
function ve(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1582399286) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = m(t, (r) => r.loadAddressAny()), n = m(t, (r) => r.loadAddressAny()), a2 = m(t, (r) => r.loadAddressAny());
    return {
      kind: "TonstakePoolSetRoles",
      query_id: e,
      governor: o4,
      interest_manager: n,
      halter: a2
    };
  }
  throw new Error('Expected one of "TonstakePoolSetRoles" in loading "TonstakePoolSetRoles", but data does not satisfy any constructor');
}
function Ve(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2616546844) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = C(t), n = C(t);
    return {
      kind: "TonstakePoolSetDepositSettings",
      query_id: e,
      optimistic_deposit_withdrawals: o4,
      deposits_open: n
    };
  }
  throw new Error('Expected one of "TonstakePoolSetDepositSettings" in loading "TonstakePoolSetDepositSettings", but data does not satisfy any constructor');
}
function Fe(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2994658477) {
    t.loadUint(32);
    let e = t.loadUint(32), o4 = t.loadUintBig(64);
    return {
      kind: "TonstakePoolDeployController",
      controller_id: e,
      query_id: o4
    };
  }
  throw new Error('Expected one of "TonstakePoolDeployController" in loading "TonstakePoolDeployController", but data does not satisfy any constructor');
}
function We(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2574354460) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadUintBig(48);
    return {
      kind: "TonstakePoolPrepareGovernanceMigration",
      query_id: e,
      governor_update_after: o4
    };
  }
  throw new Error('Expected one of "TonstakePoolPrepareGovernanceMigration" in loading "TonstakePoolPrepareGovernanceMigration", but data does not satisfy any constructor');
}
function Je(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 654743035) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadUint(8), a2 = t.loadRef().beginParse(true).asCell();
    return {
      kind: "TonstakeControllerPoolSendMessage",
      query_id: e,
      mode: o4,
      msg: a2
    };
  }
  throw new Error('Expected one of "TonstakeControllerPoolSendMessage" in loading "TonstakeControllerPoolSendMessage", but data does not satisfy any constructor');
}
function Ie(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2531783976) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = m(t, (r) => r.loadRef().beginParse(true).asCell()), n = m(t, (r) => r.loadRef().beginParse(true).asCell()), a2 = m(t, (r) => r.loadRef().beginParse(true).asCell());
    return {
      kind: "TonstakeControllerPoolUpgrade",
      query_id: e,
      data: o4,
      code: n,
      after_upgrade: a2
    };
  }
  throw new Error('Expected one of "TonstakeControllerPoolUpgrade" in loading "TonstakeControllerPoolUpgrade", but data does not satisfy any constructor');
}
function Oe(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2045231126) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadAddressAny();
    return {
      kind: "TonstakeControllerPoolSetSudoer",
      query_id: e,
      sudoer: o4
    };
  }
  throw new Error('Expected one of "TonstakeControllerPoolSetSudoer" in loading "TonstakeControllerPoolSetSudoer", but data does not satisfy any constructor');
}
function Me(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1917314981)
    return t.loadUint(32), {
      kind: "TonstakeControllerPoolUnhalt",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "TonstakeControllerPoolUnhalt" in loading "TonstakeControllerPoolUnhalt", but data does not satisfy any constructor');
}
function je(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 328866638)
    return t.loadUint(32), {
      kind: "TonstakeControllerPoolHalt",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "TonstakeControllerPoolHalt" in loading "TonstakeControllerPoolHalt", but data does not satisfy any constructor');
}
function Ge(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3387966597) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadUint(16);
    return {
      kind: "TonstakeImanagerSetInterest",
      query_id: e,
      interest_rate: o4
    };
  }
  throw new Error('Expected one of "TonstakeImanagerSetInterest" in loading "TonstakeImanagerSetInterest", but data does not satisfy any constructor');
}
function $e(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1423144071)
    return t.loadUint(32), {
      kind: "TonstakeImanagerOperationFee",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "TonstakeImanagerOperationFee" in loading "TonstakeImanagerOperationFee", but data does not satisfy any constructor');
}
function He(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2985012742) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadCoins(), n = t.loadCoins(), a2 = t.loadUint(16);
    return {
      kind: "TonstakeImanagerRequestNotification",
      query_id: e,
      min_loan: o4,
      max_loan: n,
      max_interest: a2
    };
  }
  throw new Error('Expected one of "TonstakeImanagerRequestNotification" in loading "TonstakeImanagerRequestNotification", but data does not satisfy any constructor');
}
function Ke(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3241429248) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadCoins(), n = t.loadCoins(), a2 = t.loadCoins(), r = t.loadInt(1), d = t.loadCoins(), i = t.loadCoins();
    return {
      kind: "TonstakeImanagerStats",
      query_id: e,
      borrowed: o4,
      expected: n,
      returned: a2,
      profit_sign: r,
      profit: d,
      total_balance: i
    };
  }
  throw new Error('Expected one of "TonstakeImanagerStats" in loading "TonstakeImanagerStats", but data does not satisfy any constructor');
}
function ze(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 4045930062)
    return t.loadUint(32), {
      kind: "TonstakeNftBurn",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "TonstakeNftBurn" in loading "TonstakeNftBurn", but data does not satisfy any constructor');
}
function Qe(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3982012594) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadCoins(), n = t.loadAddressAny(), a2 = t.loadUintBig(64);
    return {
      kind: "TonstakeNftBurnNotification",
      query_id: e,
      amount: o4,
      owner: n,
      index: a2
    };
  }
  throw new Error('Expected one of "TonstakeNftBurnNotification" in loading "TonstakeNftBurnNotification", but data does not satisfy any constructor');
}
function Ze(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 321886789) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadAddressAny(), n = t.loadCoins(), a2 = t.loadAddressAny(), r = t.loadAddressAny();
    return {
      kind: "TonstakeNftInit",
      query_id: e,
      owner: o4,
      amount: n,
      prev: a2,
      next: r
    };
  }
  throw new Error('Expected one of "TonstakeNftInit" in loading "TonstakeNftInit", but data does not satisfy any constructor');
}
function Xe(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3678112445)
    return t.loadUint(32), {
      kind: "TonstakeNftPayout",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "TonstakeNftPayout" in loading "TonstakeNftPayout", but data does not satisfy any constructor');
}
function Ye(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 376746144) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadAddressAny(), n = t.loadCoins(), a2 = t.loadCoins(), r = t.loadCoins();
    return {
      kind: "TonstakePayoutMintJettons",
      query_id: e,
      destination: o4,
      amount: n,
      notification: a2,
      forward: r
    };
  }
  throw new Error('Expected one of "TonstakePayoutMintJettons" in loading "TonstakePayoutMintJettons", but data does not satisfy any constructor');
}
function to(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2007184673) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadCoins();
    return {
      kind: "MegatonWtonMint",
      query_id: e,
      amount: o4
    };
  }
  throw new Error('Expected one of "MegatonWtonMint" in loading "MegatonWtonMint", but data does not satisfy any constructor');
}
function eo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1607220500) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadAddressAny(), n = t.loadAddressAny(), a2 = m(t, (i) => i.loadRef().beginParse(true).asCell()), r = t.loadVarUintBig(g$1(15)), d = S(t, N, (i) => {
      let l = i.loadRef().beginParse(true);
      return N(l);
    });
    return {
      kind: "NftTransfer",
      query_id: e,
      new_owner: o4,
      response_destination: n,
      custom_payload: a2,
      forward_amount: r,
      forward_payload: d
    };
  }
  throw new Error('Expected one of "NftTransfer" in loading "NftTransfer", but data does not satisfy any constructor');
}
function oo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 85167505) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadAddressAny(), n = S(t, N, (a2) => {
      let r = a2.loadRef().beginParse(true);
      return N(r);
    });
    return {
      kind: "NftOwnershipAssigned",
      query_id: e,
      prev_owner: o4,
      forward_payload: n
    };
  }
  throw new Error('Expected one of "NftOwnershipAssigned" in loading "NftOwnershipAssigned", but data does not satisfy any constructor');
}
function no(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 801842850)
    return t.loadUint(32), {
      kind: "GetStaticData",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "GetStaticData" in loading "GetStaticData", but data does not satisfy any constructor');
}
function ao(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2339837749) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadUintBig(256), n = t.loadAddressAny();
    return {
      kind: "ReportStaticData",
      query_id: e,
      index: o4,
      collection: n
    };
  }
  throw new Error('Expected one of "ReportStaticData" in loading "ReportStaticData", but data does not satisfy any constructor');
}
function ro(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1765620048)
    return t.loadUint(32), {
      kind: "GetRoyaltyParams",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "GetRoyaltyParams" in loading "GetRoyaltyParams", but data does not satisfy any constructor');
}
function io(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2831876269) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadUint(16), n = t.loadUint(16), a2 = t.loadAddressAny();
    return {
      kind: "ReportRoyaltyParams",
      query_id: e,
      numerator: o4,
      denominator: n,
      destination: a2
    };
  }
  throw new Error('Expected one of "ReportRoyaltyParams" in loading "ReportRoyaltyParams", but data does not satisfy any constructor');
}
function lo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 81711432) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadAddressAny(), a2 = t.loadRef().beginParse(true).asCell(), r = C(t);
    return {
      kind: "ProveOwnership",
      query_id: e,
      dest: o4,
      forward_payload: a2,
      with_content: r
    };
  }
  throw new Error('Expected one of "ProveOwnership" in loading "ProveOwnership", but data does not satisfy any constructor');
}
function so(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 86296494) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadUintBig(256), n = t.loadAddressAny(), r = t.loadRef().beginParse(true).asCell(), d = t.loadUintBig(64), i = m(t, (l) => l.loadRef().beginParse(true).asCell());
    return {
      kind: "OwnershipProof",
      query_id: e,
      item_id: o4,
      owner: n,
      data: r,
      revoked_at: d,
      content: i
    };
  }
  throw new Error('Expected one of "OwnershipProof" in loading "OwnershipProof", but data does not satisfy any constructor');
}
function uo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3502489578) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadAddressAny(), a2 = t.loadRef().beginParse(true).asCell(), r = C(t);
    return {
      kind: "SbtRequestOwner",
      query_id: e,
      dest: o4,
      forward_payload: a2,
      with_content: r
    };
  }
  throw new Error('Expected one of "SbtRequestOwner" in loading "SbtRequestOwner", but data does not satisfy any constructor');
}
function fo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 232130531) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadUintBig(256), n = t.loadAddressAny(), a2 = t.loadAddressAny(), d = t.loadRef().beginParse(true).asCell(), i = t.loadUintBig(64), l = m(t, (f2) => f2.loadRef().beginParse(true).asCell());
    return {
      kind: "SbtOwnerInfo",
      query_id: e,
      item_id: o4,
      initiator: n,
      owner: a2,
      data: d,
      revoked_at: i,
      content: l
    };
  }
  throw new Error('Expected one of "SbtOwnerInfo" in loading "SbtOwnerInfo", but data does not satisfy any constructor');
}
function po(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 520377210)
    return t.loadUint(32), {
      kind: "SbtDestroy",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "SbtDestroy" in loading "SbtDestroy", but data does not satisfy any constructor');
}
function mo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1871312355)
    return t.loadUint(32), {
      kind: "SbtRevoke",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "SbtRevoke" in loading "SbtRevoke", but data does not satisfy any constructor');
}
function go(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1741148801) {
    t.loadUint(32);
    let e = t.loadCoins(), o4 = t.loadCoins();
    return {
      kind: "TopUpChannelBalance",
      add_A: e,
      add_B: o4
    };
  }
  throw new Error('Expected one of "TopUpChannelBalance" in loading "TopUpChannelBalance", but data does not satisfy any constructor');
}
function _o(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 235282626) {
    t.loadUint(32);
    let e = C(t), o4 = t.loadBuffer(512 / 8), n = t.loadUint(32), a2 = t.loadUintBig(128), r = t.loadCoins(), d = t.loadCoins();
    return {
      kind: "InitPaymentChannel",
      is_A: e,
      signature: o4,
      tag: n,
      channel_id: a2,
      balance_A: r,
      balance_B: d
    };
  }
  throw new Error('Expected one of "InitPaymentChannel" in loading "InitPaymentChannel", but data does not satisfy any constructor');
}
function yo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1433884798) {
    t.loadUint(32);
    let o4 = t.loadRef().beginParse(true).loadBuffer(512 / 8), a2 = t.loadRef().beginParse(true).loadBuffer(512 / 8), r = t.loadUint(32), d = t.loadUintBig(128), i = t.loadCoins(), l = t.loadCoins(), f2 = t.loadUintBig(64), u = t.loadUintBig(64);
    return {
      kind: "ChannelCooperativeClose",
      sig_A: o4,
      sig_B: a2,
      tag: r,
      channel_id: d,
      balance_A: i,
      balance_B: l,
      seqno_A: f2,
      seqno_B: u
    };
  }
  throw new Error('Expected one of "ChannelCooperativeClose" in loading "ChannelCooperativeClose", but data does not satisfy any constructor');
}
function Uo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2040604399) {
    t.loadUint(32);
    let o4 = t.loadRef().beginParse(true).loadBuffer(512 / 8), a2 = t.loadRef().beginParse(true).loadBuffer(512 / 8), r = t.loadUint(32), d = t.loadUintBig(128), i = t.loadUintBig(64), l = t.loadUintBig(64);
    return {
      kind: "ChannelCooperativeCommit",
      sig_A: o4,
      sig_B: a2,
      tag: r,
      channel_id: d,
      seqno_A: i,
      seqno_B: l
    };
  }
  throw new Error('Expected one of "ChannelCooperativeCommit" in loading "ChannelCooperativeCommit", but data does not satisfy any constructor');
}
function ho(t) {
  let e = t.loadCoins(), o4 = t.asCell();
  return {
    kind: "ConditionalPayment",
    amount: e,
    condition: o4
  };
}
function J(t) {
  let e = t.loadUintBig(64), o4 = t.loadCoins(), n = distExports$3.Dictionary.load(distExports$3.Dictionary.Keys.Uint(32), {
    serialize: () => {
      throw new Error("Not implemented");
    },
    parse: ho
  }, t);
  return {
    kind: "SemiChannelBody",
    seqno: e,
    sent: o4,
    conditionals: n
  };
}
function Co(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1130910580) {
    t.loadUint(32);
    let e = t.loadUintBig(128), o4 = J(t), n = m(t, (a2) => {
      let r = a2.loadRef().beginParse(true);
      return J(r);
    });
    return {
      kind: "SemiChannel",
      channel_id: e,
      data: o4,
      counterparty_data: n
    };
  }
  throw new Error('Expected one of "SemiChannel" in loading "SemiChannel", but data does not satisfy any constructor');
}
function I(t) {
  let e = t.loadBuffer(64), o4 = Co(t);
  return {
    kind: "SignedSemiChannel",
    signature: e,
    state: o4
  };
}
function co(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 521476815) {
    t.loadUint(32);
    let e = C(t), o4 = t.loadBuffer(512 / 8), n = t.loadUint(32), a2 = t.loadUintBig(128), r = t.loadRef().beginParse(true), d = I(r), i = t.loadRef().beginParse(true), l = I(i);
    return {
      kind: "StartUncooperativeChannelClose",
      signed_by_A: e,
      signature: o4,
      tag: n,
      channel_id: a2,
      sch_A: d,
      sch_B: l
    };
  }
  throw new Error('Expected one of "StartUncooperativeChannelClose" in loading "StartUncooperativeChannelClose", but data does not satisfy any constructor');
}
function wo(t) {
  let e = t.loadCoins(), o4 = t.asCell();
  return {
    kind: "ConditionalPayment",
    amount: e,
    condition: o4
  };
}
function O(t) {
  let e = t.loadUintBig(64), o4 = t.loadCoins(), n = distExports$3.Dictionary.load(distExports$3.Dictionary.Keys.Uint(32), {
    serialize: () => {
      throw new Error("Not implemented");
    },
    parse: wo
  }, t);
  return {
    kind: "SemiChannelBody",
    seqno: e,
    sent: o4,
    conditionals: n
  };
}
function ko(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1130910580) {
    t.loadUint(32);
    let e = t.loadUintBig(128), o4 = O(t), n = m(t, (a2) => {
      let r = a2.loadRef().beginParse(true);
      return O(r);
    });
    return {
      kind: "SemiChannel",
      channel_id: e,
      data: o4,
      counterparty_data: n
    };
  }
  throw new Error('Expected one of "SemiChannel" in loading "SemiChannel", but data does not satisfy any constructor');
}
function M(t) {
  let e = t.loadBuffer(64), o4 = ko(t);
  return {
    kind: "SignedSemiChannel",
    signature: e,
    state: o4
  };
}
function So(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 143567410) {
    t.loadUint(32);
    let e = C(t), o4 = t.loadBuffer(512 / 8), n = t.loadUint(32), a2 = t.loadUintBig(128), r = t.loadRef().beginParse(true), d = M(r), i = t.loadRef().beginParse(true), l = M(i);
    return {
      kind: "ChallengeQuarantinedChannelState",
      challenged_by_A: e,
      signature: o4,
      tag: n,
      channel_id: a2,
      sch_A: d,
      sch_B: l
    };
  }
  throw new Error('Expected one of "ChallengeQuarantinedChannelState" in loading "ChallengeQuarantinedChannelState", but data does not satisfy any constructor');
}
function Bo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1727459433) {
    t.loadUint(32);
    let e = C(t), o4 = t.loadBuffer(512 / 8), n = t.loadUint(32), a2 = t.loadUintBig(128), r = distExports$3.Dictionary.load(distExports$3.Dictionary.Keys.Uint(32), {
      serialize: () => {
        throw new Error("Not implemented");
      },
      parse: (d) => d.asCell()
    }, t);
    return {
      kind: "SettleChannelConditionals",
      from_A: e,
      signature: o4,
      tag: n,
      channel_id: a2,
      conditionals_to_settle: r
    };
  }
  throw new Error('Expected one of "SettleChannelConditionals" in loading "SettleChannelConditionals", but data does not satisfy any constructor');
}
function xo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 625158801)
    return t.loadUint(32), {
      kind: "FinishUncooperativeChannelClose"
    };
  throw new Error('Expected one of "FinishUncooperativeChannelClose" in loading "FinishUncooperativeChannelClose", but data does not satisfy any constructor');
}
function bo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3722217658)
    return t.loadUint(32), {
      kind: "ChannelClosed",
      channel_id: t.loadUintBig(128)
    };
  throw new Error('Expected one of "ChannelClosed" in loading "ChannelClosed", but data does not satisfy any constructor');
}
function No(t) {
  return {
    kind: "StonfiSwapAddrs",
    from_user: t.loadAddressAny()
  };
}
function Po(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 630424929) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadAddressAny(), n = t.loadAddressAny(), a2 = t.loadVarUintBig(g$1(15)), r = t.loadVarUintBig(g$1(15)), d = C(t), i = t.loadRef().beginParse(true), l = No(i);
    return {
      kind: "StonfiSwap",
      query_id: e,
      to_address: o4,
      sender_address: n,
      jetton_amount: a2,
      min_out: r,
      has_ref_address: d,
      addrs: l
    };
  }
  throw new Error('Expected one of "StonfiSwap" in loading "StonfiSwap", but data does not satisfy any constructor');
}
function j(t) {
  let e = t.loadVarUintBig(g$1(15)), o4 = t.loadAddressAny(), n = t.loadVarUintBig(g$1(15)), a2 = t.loadAddressAny();
  return {
    kind: "StonfiPayToParams",
    amount0_out: e,
    token0_address: o4,
    amount1_out: n,
    token1_address: a2
  };
}
function Eo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 4181439551) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadAddressAny(), n = t.loadUint(32), a2 = S(t, j, (r) => {
      let d = r.loadRef().beginParse(true);
      return j(d);
    });
    return {
      kind: "StonfiPaymentRequest",
      query_id: e,
      owner: o4,
      exit_code: n,
      params: a2
    };
  }
  throw new Error('Expected one of "StonfiPaymentRequest" in loading "StonfiPaymentRequest", but data does not satisfy any constructor');
}
function Ao(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 32736093) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadCoins(), n = t.loadAddressAny(), a2 = S(t, (r) => r.asCell(), (r) => r.loadRef().beginParse(true).asCell());
    return {
      kind: "PtonTonTransfer",
      query_id: e,
      ton_amount: o4,
      refund_address: n,
      forward_payload: a2
    };
  }
  throw new Error('Expected one of "PtonTonTransfer" in loading "PtonTonTransfer", but data does not satisfy any constructor');
}
function To(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2921715614)
    return t.loadUint(32), {
      kind: "PtonTonRefund",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "PtonTonRefund" in loading "PtonTonRefund", but data does not satisfy any constructor');
}
function Do(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 701638965)
    return t.loadUint(32), {
      kind: "PtonResetGas",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "PtonResetGas" in loading "PtonResetGas", but data does not satisfy any constructor');
}
function Ro(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1331643155) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadAddressAny(), n = t.loadAddressAny();
    return {
      kind: "PtonDeployWallet",
      query_id: e,
      owner_address: o4,
      excesses_address: n
    };
  }
  throw new Error('Expected one of "PtonDeployWallet" in loading "PtonDeployWallet", but data does not satisfy any constructor');
}
function qo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1698746245) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadAddressAny();
    return {
      kind: "PtonInternalDeploy",
      query_id: e,
      excesses_address: o4
    };
  }
  throw new Error('Expected one of "PtonInternalDeploy" in loading "PtonInternalDeploy", but data does not satisfy any constructor');
}
function Lo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 116184359) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadVarUintBig(g$1(15)), n = t.loadVarUintBig(g$1(15)), a2 = t.loadAddressAny(), r = t.loadVarUintBig(g$1(15)), d = t.loadCoins(), i = m(t, (p2) => p2.loadRef().beginParse(true).asCell()), l = t.loadRef().beginParse(true), f2 = l.loadAddressAny(), u = l.loadAddressAny(), s2 = l.loadAddressAny();
    return {
      kind: "StonfiCbAddLiquidityV2",
      query_id: e,
      tot_am0: o4,
      tot_am1: n,
      user_address: a2,
      min_lp_out: r,
      fwd_amount: d,
      custom_payload_cs: i,
      to_user_address: f2,
      refund_address: u,
      excess_address: s2
    };
  }
  throw new Error('Expected one of "StonfiCbAddLiquidityV2" in loading "StonfiCbAddLiquidityV2", but data does not satisfy any constructor');
}
function vo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 935368415) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadAddressAny(), n = t.loadVarUintBig(g$1(15)), a2 = t.loadVarUintBig(g$1(15)), r = t.loadRef().beginParse(true), d = r.loadUint(32), i = r.loadAddressAny(), l = r.loadAddressAny(), f2 = r.loadAddressAny(), u = r.loadUintBig(64), s2 = r.loadRef().beginParse(true), p2 = s2.loadVarUintBig(g$1(15)), _ = s2.loadAddressAny(), U2 = s2.loadUint(1), y2 = s2.loadCoins(), h2 = m(s2, (c) => c.loadRef().beginParse(true).asCell());
    return {
      kind: "StonfiProvideLpV2",
      query_id: e,
      from_user: o4,
      left_amount: n,
      right_amount: a2,
      transferred_op: d,
      token_wallet1: i,
      refund_address: l,
      excesses_address: f2,
      tx_deadline: u,
      min_lp_out: p2,
      to_address: _,
      both_positive: U2,
      fwd_amount: y2,
      custom_payload: h2
    };
  }
  throw new Error('Expected one of "StonfiProvideLpV2" in loading "StonfiProvideLpV2", but data does not satisfy any constructor');
}
function Vo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1355195988) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadVarUintBig(g$1(15)), n = t.loadVarUintBig(g$1(15)), a2 = t.loadVarUintBig(g$1(15)), r = t.loadCoins(), d = t.loadUint(1), i = t.loadAddressAny(), l = m(t, (p2) => p2.loadRef().beginParse(true).asCell()), f2 = t.loadRef().beginParse(true), u = f2.loadAddressAny(), s2 = f2.loadAddressAny();
    return {
      kind: "StonfiAddLiquidityV2",
      query_id: e,
      new_amount0: o4,
      new_amount1: n,
      min_lp_out: a2,
      fwd_amount: r,
      both_positive: d,
      to_user: i,
      custom_payload_cs: l,
      refund_address: u,
      excess_address: s2
    };
  }
  throw new Error('Expected one of "StonfiAddLiquidityV2" in loading "StonfiAddLiquidityV2", but data does not satisfy any constructor');
}
function Fo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1702581493) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadAddressAny(), n = t.loadAddressAny(), a2 = t.loadAddressAny(), r = t.loadUint(32), d = m(t, (_) => _.loadRef().beginParse(true).asCell()), i = t.loadRef().beginParse(true), l = i.loadCoins(), f2 = i.loadVarUintBig(g$1(15)), u = i.loadAddressAny(), s2 = i.loadVarUintBig(g$1(15)), p2 = i.loadAddressAny();
    return {
      kind: "StonfiPayToV2",
      query_id: e,
      to_address: o4,
      excesses_address: n,
      original_caller: a2,
      exit_code: r,
      custom_payload: d,
      fwd_ton_amount: l,
      amount0_out: f2,
      token0_address: u,
      amount1_out: s2,
      token1_address: p2
    };
  }
  throw new Error('Expected one of "StonfiPayToV2" in loading "StonfiPayToV2", but data does not satisfy any constructor');
}
function Wo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1717886506) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadAddressAny(), n = t.loadVarUintBig(g$1(15)), a2 = t.loadVarUintBig(g$1(15)), r = t.loadRef().beginParse(true), d = r.loadUint(32), i = r.loadAddressAny(), l = r.loadAddressAny(), f2 = r.loadAddressAny(), u = r.loadUintBig(64), s2 = r.loadRef().beginParse(true), p2 = s2.loadVarUintBig(g$1(15)), _ = s2.loadAddressAny(), U2 = s2.loadCoins(), y2 = m(s2, (k2) => k2.loadRef().beginParse(true).asCell()), h2 = s2.loadCoins(), c = m(s2, (k2) => k2.loadRef().beginParse(true).asCell()), B2 = s2.loadUint(16), P2 = s2.loadAddressAny();
    return {
      kind: "StonfiSwapV2",
      query_id: e,
      from_user: o4,
      left_amount: n,
      right_amount: a2,
      transferred_op: d,
      token_wallet1: i,
      refund_address: l,
      excesses_address: f2,
      tx_deadline: u,
      min_out: p2,
      receiver: _,
      fwd_gas: U2,
      custom_payload: y2,
      refund_fwd_gas: h2,
      refund_payload: c,
      ref_fee: B2,
      ref_address: P2
    };
  }
  throw new Error('Expected one of "StonfiSwapV2" in loading "StonfiSwapV2", but data does not satisfy any constructor');
}
function Jo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 894160372)
    return t.loadUint(32), {
      kind: "StonfiWithdrawFeeV2",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "StonfiWithdrawFeeV2" in loading "StonfiWithdrawFeeV2", but data does not satisfy any constructor');
}
function Io(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 76607643) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadVarUintBig(g$1(15)), n = t.loadAddressAny();
    return {
      kind: "StonfiDepositRefFeeV2",
      query_id: e,
      jetton_amount: o4,
      excesses_address: n
    };
  }
  throw new Error('Expected one of "StonfiDepositRefFeeV2" in loading "StonfiDepositRefFeeV2", but data does not satisfy any constructor');
}
function Oo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 553699618) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadVarUintBig(g$1(15)), n = t.loadAddressAny(), a2 = t.loadAddressAny();
    return {
      kind: "StonfiVaultPayToV2",
      query_id: e,
      amount_out: o4,
      token_address: n,
      to_address: a2
    };
  }
  throw new Error('Expected one of "StonfiVaultPayToV2" in loading "StonfiVaultPayToV2", but data does not satisfy any constructor');
}
function Mo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1664620082) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadAddressAny(), n = t.loadAddressAny(), a2 = t.loadRef().beginParse(true), r = a2.loadVarUintBig(g$1(15)), d = a2.loadAddressAny(), i = a2.loadVarUintBig(g$1(15)), l = a2.loadAddressAny();
    return {
      kind: "StonfiPayVaultV2",
      query_id: e,
      owner: o4,
      excesses_address: n,
      amount0_out: r,
      token0_address: d,
      amount1_out: i,
      token1_address: l
    };
  }
  throw new Error('Expected one of "StonfiPayVaultV2" in loading "StonfiPayVaultV2", but data does not satisfy any constructor');
}
function jo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 695482319) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadVarUintBig(g$1(15)), n = t.loadAddressAny(), a2 = t.loadAddressAny(), r = m(t, (d) => d.loadRef().beginParse(true).asCell());
    return {
      kind: "StonfiBurnNotificationExtV2",
      query_id: e,
      jetton_amount: o4,
      from_address: n,
      response_address: a2,
      maybe_custom_payload: r
    };
  }
  throw new Error('Expected one of "StonfiBurnNotificationExtV2" in loading "StonfiBurnNotificationExtV2", but data does not satisfy any constructor');
}
function Go(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 5358900) {
    t.loadUint(32);
    let e = t.loadUint(32), o4 = t.loadUintBig(64), n = t.loadUintBig(256), a2 = t.loadUintBig(64), r = t.loadUintBig(256), d = m(t, (l) => l.loadUintBig(256)), i = R();
    return {
      kind: "TorrentInfo",
      piece_size: e,
      file_size: o4,
      root_hash: n,
      header_size: a2,
      header_hash: r,
      microchunk_hash: d,
      description: i
    };
  }
  throw new Error('Expected one of "TorrentInfo" in loading "TorrentInfo", but data does not satisfy any constructor');
}
function $o(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3832843761) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadRef().beginParse(true), n = Go(o4), a2 = t.loadBuffer(256 / 8), r = t.loadCoins(), d = t.loadUint(32);
    return {
      kind: "DeployStorageContract",
      query_id: e,
      info: n,
      merkle_hash: a2,
      expected_rate: r,
      expected_max_span: d
    };
  }
  throw new Error('Expected one of "DeployStorageContract" in loading "DeployStorageContract", but data does not satisfy any constructor');
}
function Ho(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1408453846) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadBuffer(256 / 8);
    return {
      kind: "UpdatePubkey",
      query_id: e,
      new_pubkey: o4
    };
  }
  throw new Error('Expected one of "UpdatePubkey" in loading "UpdatePubkey", but data does not satisfy any constructor');
}
function Ko(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1422651803) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = C(t), n = t.loadCoins(), a2 = t.loadUint(32), r = t.loadUintBig(64), d = t.loadUintBig(64);
    return {
      kind: "UpdateStorageParams",
      query_id: e,
      accept_new_contracts: o4,
      rate_per_mb_day: n,
      max_span: a2,
      minimal_file_size: r,
      maximal_file_size: d
    };
  }
  throw new Error('Expected one of "UpdateStorageParams" in loading "UpdateStorageParams", but data does not satisfy any constructor');
}
function zo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 276580847)
    return t.loadUint(32), {
      kind: "OfferStorageContract",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "OfferStorageContract" in loading "OfferStorageContract", but data does not satisfy any constructor');
}
function Qo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2050365064)
    return t.loadUint(32), {
      kind: "AcceptStorageContract",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "AcceptStorageContract" in loading "AcceptStorageContract", but data does not satisfy any constructor');
}
function Zo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3570068941) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadBuffer(256 / 8);
    return {
      kind: "StorageContractConfirmed",
      cur_lt: e,
      torrent_hash: o4
    };
  }
  throw new Error('Expected one of "StorageContractConfirmed" in loading "StorageContractConfirmed", but data does not satisfy any constructor');
}
function Xo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2046375914)
    return t.loadUint(32), {
      kind: "CloseStorageContract",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "CloseStorageContract" in loading "CloseStorageContract", but data does not satisfy any constructor');
}
function Yo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3055775075) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadBuffer(256 / 8);
    return {
      kind: "StorageContractTerminated",
      cur_lt: e,
      torrent_hash: o4
    };
  }
  throw new Error('Expected one of "StorageContractTerminated" in loading "StorageContractTerminated", but data does not satisfy any constructor');
}
function tn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1189949076)
    return t.loadUint(32), {
      kind: "StorageWithdraw",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "StorageWithdraw" in loading "StorageWithdraw", but data does not satisfy any constructor');
}
function en$1(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2837163862)
    return t.loadUint(32), {
      kind: "StorageRewardWithdrawal",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "StorageRewardWithdrawal" in loading "StorageRewardWithdrawal", but data does not satisfy any constructor');
}
function on(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1100832077) {
    t.loadUint(32);
    let e = t.loadUintBig(64), n = t.loadRef().beginParse(true).asCell();
    return {
      kind: "ProofStorage",
      query_id: e,
      file_dict_proof: n
    };
  }
  throw new Error('Expected one of "ProofStorage" in loading "ProofStorage", but data does not satisfy any constructor');
}
function nn(t) {
  let e = t.loadUint(32), o4 = t.loadUint(32), n = t.loadUint(32), a2 = t.loadUint(32), r = t.loadUint(32), d = t.loadUint(32), i = t.loadUint(32), l = t.loadUint(32), f2 = t.loadUint(32), u = t.loadUint(32), s2 = t.loadUint(32), p2 = t.loadUint(32), _ = t.loadUint(2), U2 = t.loadCoins(), y2 = t.loadUint(32);
  return {
    kind: "AmmSettings",
    fee: e,
    rollover_fee: o4,
    funding_period: n,
    init_margin_ratio: a2,
    maintenance_margin_ratio: r,
    liquidation_fee_ratio: d,
    partial_liquidation_ratio: i,
    spread_limit: l,
    max_price_impact: f2,
    max_price_spread: u,
    max_open_notional: s2,
    fee_to_stakers_percent: p2,
    funding_mode: _,
    min_partial_liquidation_notional: U2,
    min_leverage: y2
  };
}
function an(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3989649062) {
    t.loadUint(32);
    let e = t.loadAddressAny(), o4 = t.loadRef().beginParse(true), n = nn(o4);
    return {
      kind: "StormChangeSettings",
      redirect_addr: e,
      settings: n
    };
  }
  throw new Error('Expected one of "StormChangeSettings" in loading "StormChangeSettings", but data does not satisfy any constructor');
}
function rn(t) {
  let e = t.loadCoins(), o4 = t.loadCoins(), n = t.loadUint(32), a2 = t.loadUint(16);
  return {
    kind: "UpdateMsg",
    price: e,
    spread: o4,
    timestamp: n,
    asset_index: a2
  };
}
function dn(t) {
  let e = t.loadRef().beginParse(true), o4 = rn(e), a2 = t.loadRef().beginParse(true).asCell();
  return {
    kind: "OracleData",
    update_msg: o4,
    signatures: a2
  };
}
function ln(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3058877505) {
    t.loadUint(32);
    let e = t.loadRef().beginParse(true);
    return {
      kind: "StormPayFunding",
      oracle_ref: dn(e)
    };
  }
  throw new Error('Expected one of "StormPayFunding" in loading "StormPayFunding", but data does not satisfy any constructor');
}
function sn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 700515025) {
    t.loadUint(32);
    let e = t.loadAddressAny(), n = t.loadRef().beginParse(true).asCell(), r = t.loadRef().beginParse(true).asCell();
    return {
      kind: "StormVammInit",
      redirect_addr: e,
      code: n,
      data: r
    };
  }
  throw new Error('Expected one of "StormVammInit" in loading "StormVammInit", but data does not satisfy any constructor');
}
function un(t) {
  let e = t.loadUint(32), o4 = t.loadUint(32);
  return {
    kind: "Parameters",
    discount: e,
    rebate: o4
  };
}
function fn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3410877500) {
    t.loadUint(32);
    let e = t.loadAddressAny(), o4 = t.loadUint(2), n = t.loadAddressAny(), a2 = t.loadRef().beginParse(true), r = un(a2), i = t.loadRef().beginParse(true).asCell();
    return {
      kind: "StormMintReferral",
      nft_owner: e,
      ref_type: o4,
      redirect_address: n,
      parameters: r,
      balances_dict: i
    };
  }
  throw new Error('Expected one of "StormMintReferral" in loading "StormMintReferral", but data does not satisfy any constructor');
}
function pn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2229071226) {
    t.loadUint(32);
    let e = t.loadCoins(), o4 = t.loadAddressAny();
    return {
      kind: "StormAddReferralAmount",
      referral_amount: e,
      origin_addr: o4
    };
  }
  throw new Error('Expected one of "StormAddReferralAmount" in loading "StormAddReferralAmount", but data does not satisfy any constructor');
}
function mn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 4124371794) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadCoins(), n = t.loadAddressAny();
    return {
      kind: "StormWithdrawReferralAmount",
      index: e,
      referral_amount: o4,
      owner_addr: n
    };
  }
  throw new Error('Expected one of "StormWithdrawReferralAmount" in loading "StormWithdrawReferralAmount", but data does not satisfy any constructor');
}
function gn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1329122024) {
    t.loadUint(32);
    let e = t.loadAddressAny(), o4 = t.loadAddressAny(), a2 = t.loadRef().beginParse(true).asCell();
    return {
      kind: "StormMintExecutor",
      nft_owner: e,
      redirect_address: o4,
      balances_dict: a2
    };
  }
  throw new Error('Expected one of "StormMintExecutor" in loading "StormMintExecutor", but data does not satisfy any constructor');
}
function _n(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1574331769) {
    t.loadUint(32);
    let e = t.loadCoins(), o4 = t.loadAddressAny();
    return {
      kind: "StormAddExecutorAmount",
      referral_amount: e,
      origin_addr: o4
    };
  }
  throw new Error('Expected one of "StormAddExecutorAmount" in loading "StormAddExecutorAmount", but data does not satisfy any constructor');
}
function yn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 752771921) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadCoins(), n = t.loadAddressAny();
    return {
      kind: "StormWithdrawExecutorAmount",
      index: e,
      executor_amount: o4,
      owner_addr: n
    };
  }
  throw new Error('Expected one of "StormWithdrawExecutorAmount" in loading "StormWithdrawExecutorAmount", but data does not satisfy any constructor');
}
function Un(t) {
  let e = t.loadCoins(), o4 = t.loadUint(32);
  return {
    kind: "ReferralData",
    amount: e,
    index: o4
  };
}
function hn(t) {
  let e = t.loadUint(8), o4 = t.loadCoins(), n = t.loadUint(32);
  return {
    kind: "ExecutorData",
    split_executor_rewards: e,
    amount: o4,
    index: n
  };
}
function Cn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 880147922) {
    t.loadUint(32);
    let e = t.loadUint(16), o4 = t.loadUint(16), n = t.loadIntBig(64), a2 = t.loadIntBig(64), r = t.loadIntBig(64), d = t.loadIntBig(64), i = t.loadIntBig(64), l = t.loadAddressAny(), f2 = m(t, (s2) => {
      let p2 = s2.loadRef().beginParse(true);
      return Un(p2);
    }), u = m(t, (s2) => {
      let p2 = s2.loadRef().beginParse(true);
      return hn(p2);
    });
    return {
      kind: "StormVaultTradeNotification",
      amm_index: e,
      free_amount: o4,
      locked_amount: n,
      exchange_amount: a2,
      withdraw_locked_amount: r,
      fee_to_stakers: d,
      withdraw_amount: i,
      trader_addr: l,
      referral_params: f2,
      executor_params: u
    };
  }
  throw new Error('Expected one of "StormVaultTradeNotification" in loading "StormVaultTradeNotification", but data does not satisfy any constructor');
}
function cn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3365551844)
    return t.loadUint(32), {
      kind: "StormVaultStake",
      amount: t.loadCoins()
    };
  throw new Error('Expected one of "StormVaultStake" in loading "StormVaultStake", but data does not satisfy any constructor');
}
function wn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3585468845) {
    t.loadUint(32);
    let e = t.loadCoins(), o4 = t.loadAddressAny();
    return {
      kind: "StormVaultUnstake",
      jetton_amount: e,
      user_address: o4
    };
  }
  throw new Error('Expected one of "StormVaultUnstake" in loading "StormVaultUnstake", but data does not satisfy any constructor');
}
function kn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 700515025)
    return t.loadUint(32), {
      kind: "StormVaultInit",
      jetton_address: t.loadAddressAny()
    };
  throw new Error('Expected one of "StormVaultInit" in loading "StormVaultInit", but data does not satisfy any constructor');
}
function Sn(t) {
  let e = t.loadUint(32), o4 = t.loadUint(32);
  return {
    kind: "Parameters",
    discount: e,
    rebate: o4
  };
}
function Bn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 316235805) {
    t.loadUint(32);
    let e = t.loadRef().beginParse(true);
    return {
      kind: "StormTakeReferralFees",
      referral_fees: Sn(e)
    };
  }
  throw new Error('Expected one of "StormTakeReferralFees" in loading "StormTakeReferralFees", but data does not satisfy any constructor');
}
function xn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1729316393) {
    t.loadUint(32);
    let e = t.loadUint(4), o4 = t.loadUint(3), n = t.loadUint(1), a2 = t.loadAddressAny();
    return {
      kind: "StormCancelOrder",
      order_type: e,
      order_index: o4,
      direction: n,
      gas_to_address: a2
    };
  }
  throw new Error('Expected one of "StormCancelOrder" in loading "StormCancelOrder", but data does not satisfy any constructor');
}
function bn(t) {
  let e = t.loadUint(4), o4 = t.loadUint(3), n = t.loadUint(1);
  return {
    kind: "OrderPayload",
    order_type: e,
    order_index: o4,
    direction: n
  };
}
function Nn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2744665076) {
    t.loadUint(32);
    let e = t.loadRef().beginParse(true);
    return {
      kind: "StormCreateOrder",
      order_payload: bn(e)
    };
  }
  throw new Error('Expected one of "StormCreateOrder" in loading "StormCreateOrder", but data does not satisfy any constructor');
}
function Pn(t) {
  let e = t.loadUintBig(128), o4 = t.loadUint(1), n = t.loadCoins(), a2 = t.loadCoins(), r = t.loadUintBig(64), d = t.loadUint(32), i = t.loadUint(32), l = t.loadUint(32), f2 = t.loadUint(32);
  return {
    kind: "PositionChange",
    size: e,
    direction: o4,
    margin: n,
    open_notional: a2,
    last_updated_cumulative_premium: r,
    fee: d,
    discount: i,
    rebate: l,
    last_updated_timestamp: f2
  };
}
function En(t) {
  let e = t.loadCoins(), o4 = t.loadCoins(), n = t.loadCoins(), a2 = t.loadCoins(), r = t.loadCoins(), d = t.loadCoins(), i = t.loadCoins();
  return {
    kind: "AmmChange",
    quote_asset_reserve: e,
    quote_asset_reserve_weight: o4,
    base_asset_reserve: n,
    total_long_position_size: a2,
    total_short_position_size: r,
    open_interest_long: d,
    open_interest_short: i
  };
}
function An(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3482375704) {
    t.loadUint(32);
    let e = t.loadUint(4), o4 = t.loadUint(3), n = t.loadUint(1), a2 = t.loadUint(32), r = t.loadCoins(), d = m(t, (s2) => s2.loadCoins()), i = t.loadRef().beginParse(true), l = Pn(i), f2 = t.loadRef().beginParse(true), u = En(f2);
    return {
      kind: "StormCompleteOrder",
      order_type: e,
      order_index: o4,
      direction: n,
      origin_opcode: a2,
      index_price: r,
      settlement_oracle_price: d,
      position: l,
      amm: u
    };
  }
  throw new Error('Expected one of "StormCompleteOrder" in loading "StormCompleteOrder", but data does not satisfy any constructor');
}
function Tn(t) {
  let e = t.loadUint(4), o4 = t.loadUint(3), n = t.loadUint(1);
  return {
    kind: "OrderPayload",
    order_type: e,
    order_index: o4,
    direction: n
  };
}
function Dn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2637088320) {
    t.loadUint(32);
    let e = t.loadUint(3), o4 = t.loadRef().beginParse(true), n = Tn(o4);
    return {
      kind: "StormActivateOrder",
      order_index: e,
      activated_order: n
    };
  }
  throw new Error('Expected one of "StormActivateOrder" in loading "StormActivateOrder", but data does not satisfy any constructor');
}
function Rn(t) {
  let e = t.loadUintBig(128), o4 = t.loadUint(1), n = t.loadCoins(), a2 = t.loadCoins(), r = t.loadUintBig(64), d = t.loadUint(32), i = t.loadUint(32), l = t.loadUint(32), f2 = t.loadUint(32);
  return {
    kind: "PositionChange",
    size: e,
    direction: o4,
    margin: n,
    open_notional: a2,
    last_updated_cumulative_premium: r,
    fee: d,
    discount: i,
    rebate: l,
    last_updated_timestamp: f2
  };
}
function qn(t) {
  let e = t.loadCoins(), o4 = t.loadCoins(), n = t.loadCoins(), a2 = t.loadCoins(), r = t.loadCoins(), d = t.loadCoins(), i = t.loadCoins();
  return {
    kind: "AmmChange",
    quote_asset_reserve: e,
    quote_asset_reserve_weight: o4,
    base_asset_reserve: n,
    total_long_position_size: a2,
    total_short_position_size: r,
    open_interest_long: d,
    open_interest_short: i
  };
}
function Ln(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1625278071) {
    t.loadUint(32);
    let e = t.loadUint(1), o4 = t.loadUint(32), n = t.loadCoins(), a2 = m(t, (f2) => f2.loadCoins()), r = t.loadRef().beginParse(true), d = Rn(r), i = t.loadRef().beginParse(true), l = qn(i);
    return {
      kind: "StormUpdatePosition",
      direction: e,
      origin_opcode: o4,
      index_price: n,
      settlement_oracle_price: a2,
      position: d,
      amm: l
    };
  }
  throw new Error('Expected one of "StormUpdatePosition" in loading "StormUpdatePosition", but data does not satisfy any constructor');
}
function vn(t) {
  let e = t.loadUintBig(128), o4 = t.loadUint(1), n = t.loadCoins(), a2 = t.loadCoins(), r = t.loadUintBig(64), d = t.loadUint(32), i = t.loadUint(32), l = t.loadUint(32), f2 = t.loadUint(32);
  return {
    kind: "PositionChange",
    size: e,
    direction: o4,
    margin: n,
    open_notional: a2,
    last_updated_cumulative_premium: r,
    fee: d,
    discount: i,
    rebate: l,
    last_updated_timestamp: f2
  };
}
function Vn(t) {
  let e = t.loadCoins(), o4 = t.loadCoins(), n = t.loadCoins(), a2 = t.loadCoins(), r = t.loadCoins(), d = t.loadCoins(), i = t.loadCoins();
  return {
    kind: "AmmChange",
    quote_asset_reserve: e,
    quote_asset_reserve_weight: o4,
    base_asset_reserve: n,
    total_long_position_size: a2,
    total_short_position_size: r,
    open_interest_long: d,
    open_interest_short: i
  };
}
function Fn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1562056632) {
    t.loadUint(32);
    let e = t.loadUint(1), o4 = t.loadCoins(), n = t.loadCoins(), a2 = t.loadUint(32), r = t.loadCoins(), d = m(t, (s2) => s2.loadCoins()), i = t.loadRef().beginParse(true), l = vn(i), f2 = t.loadRef().beginParse(true), u = Vn(f2);
    return {
      kind: "StormUpdatePositionWithStopLoss",
      direction: e,
      stop_trigger_price: o4,
      take_trigger_price: n,
      origin_opcode: a2,
      index_price: r,
      settlement_oracle_price: d,
      position: l,
      amm: u
    };
  }
  throw new Error('Expected one of "StormUpdatePositionWithStopLoss" in loading "StormUpdatePositionWithStopLoss", but data does not satisfy any constructor');
}
function Wn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 982793446)
    return t.loadUint(32), {
      kind: "StormOrderCreated"
    };
  throw new Error('Expected one of "StormOrderCreated" in loading "StormOrderCreated", but data does not satisfy any constructor');
}
function Jn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1775273593)
    return t.loadUint(32), {
      kind: "StormOrderCanceled"
    };
  throw new Error('Expected one of "StormOrderCanceled" in loading "StormOrderCanceled", but data does not satisfy any constructor');
}
function In(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 36101990) {
    t.loadUint(32);
    let e = t.loadAddressAny(), o4 = t.loadAddressAny(), n = t.loadCoins(), a2 = t.loadAddressAny(), r = t.loadUint(32);
    return {
      kind: "StormVaultRequestWithdrawPosition",
      trader_addr: e,
      vamm_addr: o4,
      amount: n,
      gas_to_addr: a2,
      withdraw_reason: r
    };
  }
  throw new Error('Expected one of "StormVaultRequestWithdrawPosition" in loading "StormVaultRequestWithdrawPosition", but data does not satisfy any constructor');
}
function On(t) {
  return {
    kind: "Signatures",
    data: t.asCell()
  };
}
function Mn(t) {
  let e = t.loadCoins(), o4 = t.loadCoins(), n = t.loadUint(32), a2 = t.loadUint(16);
  return {
    kind: "OraclePriceData",
    price: e,
    spread: o4,
    another_spread: n,
    asset_id: a2
  };
}
function jn(t) {
  let e = t.loadRef().beginParse(true), o4 = Mn(e), n = t.loadRef().beginParse(true), a2 = On(n);
  return {
    kind: "OraclePayload",
    price_data: o4,
    signatures: a2
  };
}
function Gn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2288366594) {
    t.loadUint(32);
    let e = t.loadUint(4), o4 = t.loadUint(3), n = t.loadUint(1), a2 = t.loadUint(32), r = t.loadRef().beginParse(true), d = jn(r);
    return {
      kind: "StormProvidePosition",
      order_type: e,
      order_index: o4,
      direction: n,
      executor_index: a2,
      oracle_payload: d
    };
  }
  throw new Error('Expected one of "StormProvidePosition" in loading "StormProvidePosition", but data does not satisfy any constructor');
}
function $n(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 4145513419) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadUint(32), n = t.loadCoins(), a2 = t.loadUint(32), r = t.loadUint(32), d = t.loadCoins(), l = t.loadRef().beginParse(true).asCell();
    return {
      kind: "SubscriptionV2Deploy",
      query_id: e,
      first_charging_date: o4,
      payment_per_period: n,
      period: a2,
      grace_period: r,
      caller_fee: d,
      metadata: l
    };
  }
  throw new Error('Expected one of "SubscriptionV2Deploy" in loading "SubscriptionV2Deploy", but data does not satisfy any constructor');
}
function Hn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1685288050)
    return t.loadUint(32), {
      kind: "SubscriptionV2Destruct",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "SubscriptionV2Destruct" in loading "SubscriptionV2Destruct", but data does not satisfy any constructor');
}
function Kn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1350711532) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadCoins();
    return {
      kind: "SubscriptionV2ReducePayment",
      query_id: e,
      new_payment: o4
    };
  }
  throw new Error('Expected one of "SubscriptionV2ReducePayment" in loading "SubscriptionV2ReducePayment", but data does not satisfy any constructor');
}
function zn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 4033639783)
    return t.loadUint(32), {
      kind: "SubscriptionV2PaymentConfirmed"
    };
  throw new Error('Expected one of "SubscriptionV2PaymentConfirmed" in loading "SubscriptionV2PaymentConfirmed", but data does not satisfy any constructor');
}
function Qn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 4166133070)
    return t.loadUint(32), {
      kind: "SubscriptionV2WithdrawToBeneficiary",
      subscription_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "SubscriptionV2WithdrawToBeneficiary" in loading "SubscriptionV2WithdrawToBeneficiary", but data does not satisfy any constructor');
}
function Zn(t) {
  let e = t.loadUint(16), o4 = t.loadUint(16), n = t.loadAddressAny();
  return {
    kind: "NftRoyaltyParams",
    numerator: e,
    denominator: o4,
    destination: n
  };
}
function Xn(t) {
  let e = t.loadAddressAny(), o4 = t.loadCoins(), n = t.loadCoins(), a2 = t.loadUint(8), r = t.loadUint(32), d = t.loadUint(32);
  return {
    kind: "TeleitemAuctionConfig",
    beneficiar_address: e,
    initial_min_bid: o4,
    max_bid: n,
    min_bid_step: a2,
    min_extend_time: r,
    duration: d
  };
}
function Yn(t) {
  let e = t.loadUint(32), o4 = t.loadUint(32), n = t.loadUint(32), a2 = b(t), d = t.loadRef().beginParse(true).asCell(), i = t.loadRef().beginParse(true), l = Xn(i), f2 = m(t, (u) => {
    let s2 = u.loadRef().beginParse(true);
    return Zn(s2);
  });
  return {
    kind: "TelemintUnsignedDeploy",
    subwallet_id: e,
    valid_since: o4,
    valid_till: n,
    username: a2,
    content: d,
    auction_config: l,
    royalty_params: f2
  };
}
function ta(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1178019994) {
    t.loadUint(32);
    let e = t.loadBuffer(512 / 8), o4 = Yn(t);
    return {
      kind: "TelemintDeploy",
      sig: e,
      msg: o4
    };
  }
  throw new Error('Expected one of "TelemintDeploy" in loading "TelemintDeploy", but data does not satisfy any constructor');
}
function ea(t) {
  let e = t.loadUint(16), o4 = t.loadUint(16), n = t.loadAddressAny();
  return {
    kind: "NftRoyaltyParams",
    numerator: e,
    denominator: o4,
    destination: n
  };
}
function oa(t) {
  let e = t.loadAddressAny(), o4 = t.loadCoins(), n = t.loadCoins(), a2 = t.loadUint(8), r = t.loadUint(32), d = t.loadUint(32);
  return {
    kind: "TeleitemAuctionConfig",
    beneficiar_address: e,
    initial_min_bid: o4,
    max_bid: n,
    min_bid_step: a2,
    min_extend_time: r,
    duration: d
  };
}
function na(t) {
  let e = m(t, (n) => n.loadAddressAny()), o4 = m(t, (n) => n.loadAddressAny());
  return {
    kind: "TelemintRestrictions",
    force_sender_address: e,
    rewrite_sender_address: o4
  };
}
function aa(t) {
  let e = t.loadUint(32), o4 = t.loadUint(32), n = t.loadUint(32), a2 = b(t), d = t.loadRef().beginParse(true).asCell(), i = t.loadRef().beginParse(true), l = oa(i), f2 = m(t, (s2) => {
    let p2 = s2.loadRef().beginParse(true);
    return ea(p2);
  }), u = m(t, (s2) => {
    let p2 = s2.loadRef().beginParse(true);
    return na(p2);
  });
  return {
    kind: "TelemintUnsignedDeployV2",
    subwallet_id: e,
    valid_since: o4,
    valid_till: n,
    token_name: a2,
    content: d,
    auction_config: l,
    royalty_params: f2,
    restrictions: u
  };
}
function ra(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1178019995) {
    t.loadUint(32);
    let e = t.loadBuffer(512 / 8), o4 = aa(t);
    return {
      kind: "TelemintDeployV2",
      sig: e,
      msg: o4
    };
  }
  throw new Error('Expected one of "TelemintDeployV2" in loading "TelemintDeployV2", but data does not satisfy any constructor');
}
function da(t) {
  let e = t.loadUint(16), o4 = t.loadUint(16), n = t.loadAddressAny();
  return {
    kind: "NftRoyaltyParams",
    numerator: e,
    denominator: o4,
    destination: n
  };
}
function ia(t) {
  let e = t.loadAddressAny(), o4 = t.loadCoins(), n = t.loadCoins(), a2 = t.loadUint(8), r = t.loadUint(32), d = t.loadUint(32);
  return {
    kind: "TeleitemAuctionConfig",
    beneficiar_address: e,
    initial_min_bid: o4,
    max_bid: n,
    min_bid_step: a2,
    min_extend_time: r,
    duration: d
  };
}
function la(t) {
  let e = b(t), o4 = b(t);
  return {
    kind: "TelemintTokenInfo",
    name: e,
    domain: o4
  };
}
function sa(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 697974293) {
    t.loadUint(32);
    let e = t.loadAddressAny(), o4 = t.loadCoins(), n = t.loadRef().beginParse(true), a2 = la(n), d = t.loadRef().beginParse(true).asCell(), i = t.loadRef().beginParse(true), l = ia(i), f2 = t.loadRef().beginParse(true), u = da(f2);
    return {
      kind: "TeleitemDeploy",
      sender_address: e,
      bid: o4,
      token_info: a2,
      nft_content: d,
      auction_config: l,
      royalty_params: u
    };
  }
  throw new Error('Expected one of "TeleitemDeploy" in loading "TeleitemDeploy", but data does not satisfy any constructor');
}
function ua(t) {
  let e = t.loadAddressAny(), o4 = t.loadCoins(), n = t.loadCoins(), a2 = t.loadUint(8), r = t.loadUint(32), d = t.loadUint(32);
  return {
    kind: "TeleitemAuctionConfig",
    beneficiar_address: e,
    initial_min_bid: o4,
    max_bid: n,
    min_bid_step: a2,
    min_extend_time: r,
    duration: d
  };
}
function fa(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1215991425) {
    t.loadUint(32);
    let e = t.loadIntBig(64), o4 = t.loadRef().beginParse(true), n = ua(o4);
    return {
      kind: "TeleitemStartAuction",
      query_id: e,
      auction_config: n
    };
  }
  throw new Error('Expected one of "TeleitemStartAuction" in loading "TeleitemStartAuction", but data does not satisfy any constructor');
}
function pa(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 924203182)
    return t.loadUint(32), {
      kind: "TeleitemCancelAuction",
      query_id: t.loadIntBig(64)
    };
  throw new Error('Expected one of "TeleitemCancelAuction" in loading "TeleitemCancelAuction", but data does not satisfy any constructor');
}
function ma(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2742684035)
    return t.loadUint(32), {
      kind: "TeleitemOk",
      query_id: t.loadIntBig(64)
    };
  throw new Error('Expected one of "TeleitemOk" in loading "TeleitemOk", but data does not satisfy any constructor');
}
function ga(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2754750433)
    return t.loadUint(32), {
      kind: "TeleitemReturnBid",
      cur_lt: t.loadIntBig(64)
    };
  throw new Error('Expected one of "TeleitemReturnBid" in loading "TeleitemReturnBid", but data does not satisfy any constructor');
}
function _a(t) {
  let e = t.loadUintBig(64), o4 = t.loadBuffer(256 / 8);
  return {
    kind: "CertificateData2Fa",
    valid_until: e,
    pubkey: o4
  };
}
function ya(t) {
  let e = _a(t), o4 = t.loadBuffer(512 / 8);
  return {
    kind: "Certificate2Fa",
    data: e,
    signature: o4
  };
}
function Ua(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2975804556) {
    t.loadUint(32);
    let e = t.loadUint(32), o4 = t.loadUintBig(64), a2 = t.loadRef().beginParse(true).asCell(), r = t.loadUint(8);
    return {
      kind: "Payload2Fa_send_actions",
      seqno: e,
      valid_until: o4,
      msg: a2,
      mode: r
    };
  }
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2642445526) {
    t.loadUint(32);
    let e = t.loadUint(32), o4 = t.loadUintBig(64);
    return {
      kind: "Payload2Fa_remove_extension",
      seqno: e,
      valid_until: o4
    };
  }
  if (t.remainingBits >= 32 && t.preloadUint(32) == 601473372) {
    t.loadUint(32);
    let e = t.loadUint(32), o4 = t.loadUintBig(64), a2 = t.loadRef().beginParse(true).asCell(), r = t.loadCoins();
    return {
      kind: "Payload2Fa_delegation",
      seqno: e,
      valid_until: o4,
      new_state_init: a2,
      forward_amount: r
    };
  }
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3733107969) {
    t.loadUint(32);
    let e = t.loadUint(32), o4 = t.loadUintBig(64);
    return {
      kind: "Payload2Fa_cancel_delegation",
      seqno: e,
      valid_until: o4
    };
  }
  throw new Error('Expected one of "Payload2Fa_send_actions", "Payload2Fa_remove_extension", "Payload2Fa_delegation", "Payload2Fa_cancel_delegation" in loading "Payload2Fa", but data does not satisfy any constructor');
}
function ha(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1399341111) {
    t.loadUint(32);
    let e = t.loadRef().beginParse(true), o4 = ya(e), a2 = t.loadRef().beginParse(true).loadBuffer(512 / 8), r = Ua(t), d = t.loadBuffer(512 / 8);
    return {
      kind: "Tonkeeper2faSigned",
      ref_with_certificate: o4,
      seed_signature: a2,
      payload: r,
      certificate_signature: d
    };
  }
  throw new Error('Expected one of "Tonkeeper2faSigned" in loading "Tonkeeper2faSigned", but data does not satisfy any constructor');
}
function Ca(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3665837821) {
    t.loadUint(32);
    let e = t.loadIntBig(64), o4 = t.loadCoins(), n = t.loadCoins();
    return {
      kind: "WhalesNominatorsWithdraw",
      query_id: e,
      gas: o4,
      amount: n
    };
  }
  throw new Error('Expected one of "WhalesNominatorsWithdraw" in loading "WhalesNominatorsWithdraw", but data does not satisfy any constructor');
}
function ca(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2077040623) {
    t.loadUint(32);
    let e = t.loadIntBig(64), o4 = t.loadCoins();
    return {
      kind: "WhalesNominatorsDeposit",
      query_id: e,
      gas: o4
    };
  }
  throw new Error('Expected one of "WhalesNominatorsDeposit" in loading "WhalesNominatorsDeposit", but data does not satisfy any constructor');
}
function wa(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 362189324)
    return t.loadUint(32), {
      kind: "WhalesNominatorsForceKick",
      query_id: t.loadIntBig(64)
    };
  throw new Error('Expected one of "WhalesNominatorsForceKick" in loading "WhalesNominatorsForceKick", but data does not satisfy any constructor');
}
function ka(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1958425639)
    return t.loadUint(32), {
      kind: "WhalesNominatorsStakeWithdrawDelayed",
      query_id: t.loadIntBig(64)
    };
  throw new Error('Expected one of "WhalesNominatorsStakeWithdrawDelayed" in loading "WhalesNominatorsStakeWithdrawDelayed", but data does not satisfy any constructor');
}
function Sa(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 601104865)
    return t.loadUint(32), {
      kind: "WhalesNominatorsStakeWithdrawCompleted",
      query_id: t.loadIntBig(64)
    };
  throw new Error('Expected one of "WhalesNominatorsStakeWithdrawCompleted" in loading "WhalesNominatorsStakeWithdrawCompleted", but data does not satisfy any constructor');
}
function Ba(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2718326572) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadCoins(), n = t.loadCoins(), a2 = t.loadBuffer(256 / 8), r = t.loadUint(32), d = t.loadUint(32), i = t.loadBuffer(256 / 8), f2 = t.loadRef().beginParse(true).loadBuffer(512 / 8);
    return {
      kind: "WhalesNominatorsSendStake",
      query_id: e,
      gas_limit: o4,
      stake: n,
      validator_pubkey: a2,
      stake_at: r,
      max_factor: d,
      adnl_addr: i,
      signature: f2
    };
  }
  throw new Error('Expected one of "WhalesNominatorsSendStake" in loading "WhalesNominatorsSendStake", but data does not satisfy any constructor');
}
function xa(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 622684824) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.loadCoins();
    return {
      kind: "WhalesNominatorsWithdrawUnowned",
      query_id: e,
      gas_limit: o4
    };
  }
  throw new Error('Expected one of "WhalesNominatorsWithdrawUnowned" in loading "WhalesNominatorsWithdrawUnowned", but data does not satisfy any constructor');
}
function ba(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 488052159)
    return t.loadUint(32), {
      kind: "WhalesNominatorsWithdrawUnownedResponse",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "WhalesNominatorsWithdrawUnownedResponse" in loading "WhalesNominatorsWithdrawUnownedResponse", but data does not satisfy any constructor');
}
function Na(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2577928699) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.asCell();
    return {
      kind: "WhalesNominatorsAcceptStake",
      query_id: e,
      members: o4
    };
  }
  throw new Error('Expected one of "WhalesNominatorsAcceptStake" in loading "WhalesNominatorsAcceptStake", but data does not satisfy any constructor');
}
function Pa(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2711607604) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o4 = t.asCell();
    return {
      kind: "WhalesNominatorsAcceptWithdraws",
      query_id: e,
      members: o4
    };
  }
  throw new Error('Expected one of "WhalesNominatorsAcceptWithdraws" in loading "WhalesNominatorsAcceptWithdraws", but data does not satisfy any constructor');
}
const Ga = [
  {
    opCode: 1112786133,
    parse: ut,
    fixedLength: false,
    folderName: "bemo",
    internalName: "bemo_stake"
  },
  {
    opCode: 1227534771,
    parse: ft,
    fixedLength: false,
    folderName: "bemo",
    internalName: "bemo_unstake"
  },
  {
    opCode: 279039605,
    parse: pt,
    fixedLength: false,
    folderName: "bemo",
    internalName: "bemo_deploy_unstake_request"
  },
  {
    opCode: 2429028871,
    parse: mt,
    fixedLength: false,
    folderName: "bemo",
    internalName: "bemo_unstake_notification"
  },
  {
    opCode: 946025784,
    parse: gt,
    fixedLength: false,
    folderName: "bemo",
    internalName: "bemo_return_unstake_request"
  },
  {
    opCode: 1544662441,
    parse: _t,
    fixedLength: false,
    folderName: "daolama",
    internalName: "daolama_vault_supply"
  },
  {
    opCode: 2078119902,
    parse: yt,
    fixedLength: false,
    folderName: "daolama",
    internalName: "daolama_vault_withdraw"
  },
  {
    opCode: 3043726744,
    parse: Ut,
    fixedLength: false,
    folderName: "dedust",
    internalName: "dedust_deposit_liquidity_all"
  },
  {
    opCode: 1643009069,
    parse: ct,
    fixedLength: false,
    folderName: "dedust",
    internalName: "dedust_swap_external"
  },
  {
    opCode: 1923917994,
    parse: Bt,
    fixedLength: false,
    folderName: "dedust",
    internalName: "dedust_swap_peer"
  },
  {
    opCode: 2907617013,
    parse: xt,
    fixedLength: false,
    folderName: "dedust",
    internalName: "dedust_payout_from_pool"
  },
  {
    opCode: 1196394191,
    parse: bt,
    fixedLength: false,
    folderName: "dedust",
    internalName: "dedust_payout"
  },
  {
    opCode: 3926267997,
    parse: Et,
    fixedLength: false,
    folderName: "dedust",
    internalName: "dedust_swap"
  },
  {
    opCode: 3579725446,
    parse: Dt,
    fixedLength: false,
    folderName: "dedust",
    internalName: "dedust_deposit_liquidity"
  },
  {
    opCode: 567271467,
    parse: qt,
    fixedLength: false,
    folderName: "dedust",
    internalName: "dedust_create_vault"
  },
  {
    opCode: 2547326767,
    parse: Lt,
    fixedLength: false,
    folderName: "dedust",
    internalName: "dedust_create_volatile_pool"
  },
  {
    opCode: 376237550,
    parse: vt,
    fixedLength: false,
    folderName: "dedust",
    internalName: "dedust_cancel_deposit"
  },
  {
    opCode: 1322339173,
    parse: Vt,
    fixedLength: false,
    folderName: "dns",
    internalName: "dns_balance_release"
  },
  {
    opCode: 1320284409,
    parse: Ft,
    fixedLength: true,
    folderName: "dns",
    internalName: "delete_dns_record"
  },
  {
    opCode: 1320284409,
    parse: Wt,
    fixedLength: false,
    folderName: "dns",
    internalName: "change_dns_record"
  },
  {
    opCode: 1153347137,
    parse: Jt,
    fixedLength: false,
    folderName: "dns",
    internalName: "process_governance_decision"
  },
  {
    opCode: 923790417,
    parse: It,
    fixedLength: false,
    folderName: "dns",
    internalName: "auction_fill_up"
  },
  {
    opCode: 1434249760,
    parse: Ot,
    fixedLength: false,
    folderName: "dns",
    internalName: "outbid_notification"
  },
  {
    opCode: 1298755173,
    parse: Mt,
    fixedLength: false,
    folderName: "gram",
    internalName: "gram_submit_proof_of_work"
  },
  {
    opCode: 1027039654,
    parse: jt,
    fixedLength: false,
    folderName: "hipo_finance",
    internalName: "hipo_finance_deposit_coins"
  },
  {
    opCode: 1541764646,
    parse: Gt,
    fixedLength: false,
    folderName: "hipo_finance",
    internalName: "hipo_finance_proxy_tokens_minted"
  },
  {
    opCode: 1413869550,
    parse: $t,
    fixedLength: false,
    folderName: "hipo_finance",
    internalName: "hipo_finance_tokens_minted"
  },
  {
    opCode: 2057453237,
    parse: Kt,
    fixedLength: false,
    folderName: "invoices",
    internalName: "invoice_payload"
  },
  {
    opCode: 260734629,
    parse: zt,
    fixedLength: false,
    folderName: "jettons",
    internalName: "jetton_transfer"
  },
  {
    opCode: 395134233,
    parse: Qt,
    fixedLength: false,
    folderName: "jettons",
    internalName: "jetton_internal_transfer"
  },
  {
    opCode: 1499400124,
    parse: Zt,
    fixedLength: false,
    folderName: "jettons",
    internalName: "jetton_burn"
  },
  {
    opCode: 2078119902,
    parse: Xt,
    fixedLength: false,
    folderName: "jettons",
    internalName: "jetton_burn_notification"
  },
  {
    opCode: 1935855772,
    parse: Yt,
    fixedLength: false,
    folderName: "jettons",
    internalName: "jetton_notify"
  },
  {
    opCode: 4006754003,
    parse: te,
    fixedLength: false,
    folderName: "jettons",
    internalName: "jetton_set_status"
  },
  {
    opCode: 1680571655,
    parse: ee,
    fixedLength: false,
    folderName: "jettons",
    internalName: "jetton_mint"
  },
  {
    opCode: 1694626644,
    parse: oe,
    fixedLength: false,
    folderName: "jettons",
    internalName: "jetton_change_admin"
  },
  {
    opCode: 4220051737,
    parse: ne,
    fixedLength: false,
    folderName: "jettons",
    internalName: "jetton_claim_admin"
  },
  {
    opCode: 593276754,
    parse: re,
    fixedLength: false,
    folderName: "jettons",
    internalName: "jetton_call_to"
  },
  {
    opCode: 621336170,
    parse: de,
    fixedLength: false,
    folderName: "jettons",
    internalName: "jetton_upgrade"
  },
  {
    opCode: 3414567170,
    parse: ie,
    fixedLength: false,
    folderName: "jettons",
    internalName: "jetton_change_metadata"
  },
  {
    opCode: 4294967295,
    parse: le,
    fixedLength: false,
    folderName: "known",
    internalName: "bounce"
  },
  {
    opCode: 0,
    parse: se,
    fixedLength: false,
    folderName: "known",
    internalName: "text_comment"
  },
  {
    opCode: 560454219,
    parse: ue,
    fixedLength: false,
    folderName: "known",
    internalName: "encrypted_text_comment"
  },
  {
    opCode: 3576854235,
    parse: fe,
    fixedLength: false,
    folderName: "known",
    internalName: "excess"
  },
  {
    opCode: 3547469196,
    parse: pe,
    fixedLength: true,
    folderName: "known",
    internalName: "top_up"
  },
  {
    opCode: 378586628,
    parse: me,
    fixedLength: true,
    folderName: "known",
    internalName: "credit"
  },
  {
    opCode: 2068529894,
    parse: ge,
    fixedLength: true,
    folderName: "known",
    internalName: "approve"
  },
  {
    opCode: 3902843902,
    parse: _e,
    fixedLength: true,
    folderName: "known",
    internalName: "disapprove"
  },
  {
    opCode: 1316189259,
    parse: ye,
    fixedLength: false,
    folderName: "known",
    internalName: "elector_new_stake"
  },
  {
    opCode: 4084484172,
    parse: Ue,
    fixedLength: false,
    folderName: "known",
    internalName: "elector_new_stake_confirmation"
  },
  {
    opCode: 1197831204,
    parse: he,
    fixedLength: false,
    folderName: "known",
    internalName: "elector_recover_stake_request"
  },
  {
    opCode: 4184830756,
    parse: Ce,
    fixedLength: false,
    folderName: "known",
    internalName: "elector_recover_stake_response"
  },
  {
    opCode: 3946265093,
    parse: ce,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_controller_recover_stake"
  },
  {
    opCode: 4043121232,
    parse: we,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_controller_update_validator_hash"
  },
  {
    opCode: 2399065977,
    parse: ke,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_controller_withdraw_validator"
  },
  {
    opCode: 805462823,
    parse: Se,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_controller_validator_withdrawal"
  },
  {
    opCode: 3763363086,
    parse: Be,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_controller_new_stake"
  },
  {
    opCode: 1664463130,
    parse: xe,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_controller_send_request_loan"
  },
  {
    opCode: 3983767718,
    parse: be,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_controller_return_unused_loan"
  },
  {
    opCode: 1438805205,
    parse: Ne,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_controller_return_available_funds"
  },
  {
    opCode: 3863136613,
    parse: Ee,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_pool_request_loan"
  },
  {
    opCode: 3755778683,
    parse: Ae,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_pool_loan_repayment"
  },
  {
    opCode: 1205158801,
    parse: Te$1,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_pool_deposit"
  },
  {
    opCode: 1271382751,
    parse: De,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_pool_touch"
  },
  {
    opCode: 715822752,
    parse: Re,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_pool_set_governance_fee"
  },
  {
    opCode: 832244956,
    parse: qe,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_pool_withdraw"
  },
  {
    opCode: 175592284,
    parse: Le,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_pool_withdrawal"
  },
  {
    opCode: 1582399286,
    parse: ve,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_pool_set_roles"
  },
  {
    opCode: 2616546844,
    parse: Ve,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_pool_set_deposit_settings"
  },
  {
    opCode: 2994658477,
    parse: Fe,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_pool_deploy_controller"
  },
  {
    opCode: 2574354460,
    parse: We,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_pool_prepare_governance_migration"
  },
  {
    opCode: 654743035,
    parse: Je,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_controller_pool_send_message"
  },
  {
    opCode: 2531783976,
    parse: Ie,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_controller_pool_upgrade"
  },
  {
    opCode: 2045231126,
    parse: Oe,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_controller_pool_set_sudoer"
  },
  {
    opCode: 1917314981,
    parse: Me,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_controller_pool_unhalt"
  },
  {
    opCode: 328866638,
    parse: je,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_controller_pool_halt"
  },
  {
    opCode: 3387966597,
    parse: Ge,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_imanager_set_interest"
  },
  {
    opCode: 1423144071,
    parse: $e,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_imanager_operation_fee"
  },
  {
    opCode: 2985012742,
    parse: He,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_imanager_request_notification"
  },
  {
    opCode: 3241429248,
    parse: Ke,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_imanager_stats"
  },
  {
    opCode: 4045930062,
    parse: ze,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_nft_burn"
  },
  {
    opCode: 3982012594,
    parse: Qe,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_nft_burn_notification"
  },
  {
    opCode: 321886789,
    parse: Ze,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_nft_init"
  },
  {
    opCode: 3678112445,
    parse: Xe,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_nft_payout"
  },
  {
    opCode: 376746144,
    parse: Ye,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_payout_mint_jettons"
  },
  {
    opCode: 2007184673,
    parse: to,
    fixedLength: false,
    folderName: "megaton_fi",
    internalName: "megaton_wton_mint"
  },
  {
    opCode: 1607220500,
    parse: eo,
    fixedLength: false,
    folderName: "nfts",
    internalName: "nft_transfer"
  },
  {
    opCode: 85167505,
    parse: oo,
    fixedLength: false,
    folderName: "nfts",
    internalName: "nft_ownership_assigned"
  },
  {
    opCode: 801842850,
    parse: no,
    fixedLength: false,
    folderName: "nfts",
    internalName: "get_static_data"
  },
  {
    opCode: 2339837749,
    parse: ao,
    fixedLength: false,
    folderName: "nfts",
    internalName: "report_static_data"
  },
  {
    opCode: 1765620048,
    parse: ro,
    fixedLength: false,
    folderName: "nfts",
    internalName: "get_royalty_params"
  },
  {
    opCode: 2831876269,
    parse: io,
    fixedLength: false,
    folderName: "nfts",
    internalName: "report_royalty_params"
  },
  {
    opCode: 81711432,
    parse: lo,
    fixedLength: false,
    folderName: "nfts",
    internalName: "prove_ownership"
  },
  {
    opCode: 86296494,
    parse: so,
    fixedLength: false,
    folderName: "nfts",
    internalName: "ownership_proof"
  },
  {
    opCode: 3502489578,
    parse: uo,
    fixedLength: false,
    folderName: "nfts",
    internalName: "sbt_request_owner"
  },
  {
    opCode: 232130531,
    parse: fo,
    fixedLength: false,
    folderName: "nfts",
    internalName: "sbt_owner_info"
  },
  {
    opCode: 520377210,
    parse: po,
    fixedLength: false,
    folderName: "nfts",
    internalName: "sbt_destroy"
  },
  {
    opCode: 1871312355,
    parse: mo,
    fixedLength: false,
    folderName: "nfts",
    internalName: "sbt_revoke"
  },
  {
    opCode: 1741148801,
    parse: go,
    fixedLength: false,
    folderName: "payment_channels",
    internalName: "top_up_channel_balance"
  },
  {
    opCode: 235282626,
    parse: _o,
    fixedLength: false,
    folderName: "payment_channels",
    internalName: "init_payment_channel"
  },
  {
    opCode: 1433884798,
    parse: yo,
    fixedLength: false,
    folderName: "payment_channels",
    internalName: "channel_cooperative_close"
  },
  {
    opCode: 2040604399,
    parse: Uo,
    fixedLength: false,
    folderName: "payment_channels",
    internalName: "channel_cooperative_commit"
  },
  {
    opCode: 521476815,
    parse: co,
    fixedLength: false,
    folderName: "payment_channels",
    internalName: "start_uncooperative_channel_close"
  },
  {
    opCode: 143567410,
    parse: So,
    fixedLength: false,
    folderName: "payment_channels",
    internalName: "challenge_quarantined_channel_state"
  },
  {
    opCode: 1727459433,
    parse: Bo,
    fixedLength: false,
    folderName: "payment_channels",
    internalName: "settle_channel_conditionals"
  },
  {
    opCode: 625158801,
    parse: xo,
    fixedLength: false,
    folderName: "payment_channels",
    internalName: "finish_uncooperative_channel_close"
  },
  {
    opCode: 3722217658,
    parse: bo,
    fixedLength: false,
    folderName: "payment_channels",
    internalName: "channel_closed"
  },
  {
    opCode: 630424929,
    parse: Po,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "stonfi_swap"
  },
  {
    opCode: 4181439551,
    parse: Eo,
    fixedLength: true,
    folderName: "ston_fi",
    internalName: "stonfi_payment_request"
  },
  {
    opCode: 32736093,
    parse: Ao,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "pton_ton_transfer"
  },
  {
    opCode: 2921715614,
    parse: To,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "pton_ton_refund"
  },
  {
    opCode: 701638965,
    parse: Do,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "pton_reset_gas"
  },
  {
    opCode: 1331643155,
    parse: Ro,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "pton_deploy_wallet"
  },
  {
    opCode: 1698746245,
    parse: qo,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "pton_internal_deploy"
  },
  {
    opCode: 116184359,
    parse: Lo,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "stonfi_cb_add_liquidity_v2"
  },
  {
    opCode: 935368415,
    parse: vo,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "stonfi_provide_lp_v2"
  },
  {
    opCode: 1355195988,
    parse: Vo,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "stonfi_add_liquidity_v2"
  },
  {
    opCode: 1702581493,
    parse: Fo,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "stonfi_pay_to_v2"
  },
  {
    opCode: 1717886506,
    parse: Wo,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "stonfi_swap_v2"
  },
  {
    opCode: 894160372,
    parse: Jo,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "stonfi_withdraw_fee_v2"
  },
  {
    opCode: 76607643,
    parse: Io,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "stonfi_deposit_ref_fee_v2"
  },
  {
    opCode: 553699618,
    parse: Oo,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "stonfi_vault_pay_to_v2"
  },
  {
    opCode: 1664620082,
    parse: Mo,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "stonfi_pay_vault_v2"
  },
  {
    opCode: 695482319,
    parse: jo,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "stonfi_burn_notification_ext_v2"
  },
  {
    opCode: 3832843761,
    parse: $o,
    fixedLength: false,
    folderName: "storages",
    internalName: "deploy_storage_contract"
  },
  {
    opCode: 1408453846,
    parse: Ho,
    fixedLength: false,
    folderName: "storages",
    internalName: "update_pubkey"
  },
  {
    opCode: 1422651803,
    parse: Ko,
    fixedLength: false,
    folderName: "storages",
    internalName: "update_storage_params"
  },
  {
    opCode: 276580847,
    parse: zo,
    fixedLength: false,
    folderName: "storages",
    internalName: "offer_storage_contract"
  },
  {
    opCode: 2050365064,
    parse: Qo,
    fixedLength: false,
    folderName: "storages",
    internalName: "accept_storage_contract"
  },
  {
    opCode: 3570068941,
    parse: Zo,
    fixedLength: false,
    folderName: "storages",
    internalName: "storage_contract_confirmed"
  },
  {
    opCode: 2046375914,
    parse: Xo,
    fixedLength: false,
    folderName: "storages",
    internalName: "close_storage_contract"
  },
  {
    opCode: 3055775075,
    parse: Yo,
    fixedLength: false,
    folderName: "storages",
    internalName: "storage_contract_terminated"
  },
  {
    opCode: 1189949076,
    parse: tn,
    fixedLength: false,
    folderName: "storages",
    internalName: "storage_withdraw"
  },
  {
    opCode: 2837163862,
    parse: en$1,
    fixedLength: false,
    folderName: "storages",
    internalName: "storage_reward_withdrawal"
  },
  {
    opCode: 1100832077,
    parse: on,
    fixedLength: false,
    folderName: "storages",
    internalName: "proof_storage"
  },
  {
    opCode: 3989649062,
    parse: an,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_change_settings"
  },
  {
    opCode: 3058877505,
    parse: ln,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_pay_funding"
  },
  {
    opCode: 700515025,
    parse: sn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_vamm_init"
  },
  {
    opCode: 3410877500,
    parse: fn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_mint_referral"
  },
  {
    opCode: 2229071226,
    parse: pn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_add_referral_amount"
  },
  {
    opCode: 4124371794,
    parse: mn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_withdraw_referral_amount"
  },
  {
    opCode: 1329122024,
    parse: gn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_mint_executor"
  },
  {
    opCode: 1574331769,
    parse: _n,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_add_executor_amount"
  },
  {
    opCode: 752771921,
    parse: yn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_withdraw_executor_amount"
  },
  {
    opCode: 880147922,
    parse: Cn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_vault_trade_notification"
  },
  {
    opCode: 3365551844,
    parse: cn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_vault_stake"
  },
  {
    opCode: 3585468845,
    parse: wn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_vault_unstake"
  },
  {
    opCode: 700515025,
    parse: kn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_vault_init"
  },
  {
    opCode: 316235805,
    parse: Bn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_take_referral_fees"
  },
  {
    opCode: 1729316393,
    parse: xn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_cancel_order"
  },
  {
    opCode: 2744665076,
    parse: Nn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_create_order"
  },
  {
    opCode: 3482375704,
    parse: An,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_complete_order"
  },
  {
    opCode: 2637088320,
    parse: Dn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_activate_order"
  },
  {
    opCode: 1625278071,
    parse: Ln,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_update_position"
  },
  {
    opCode: 1562056632,
    parse: Fn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_update_position_with_stop_loss"
  },
  {
    opCode: 982793446,
    parse: Wn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_order_created"
  },
  {
    opCode: 1775273593,
    parse: Jn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_order_canceled"
  },
  {
    opCode: 36101990,
    parse: In,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_vault_request_withdraw_position"
  },
  {
    opCode: 2288366594,
    parse: Gn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_provide_position"
  },
  {
    opCode: 4145513419,
    parse: $n,
    fixedLength: false,
    folderName: "subscriptions_v2",
    internalName: "subscription_v2_deploy"
  },
  {
    opCode: 1685288050,
    parse: Hn,
    fixedLength: false,
    folderName: "subscriptions_v2",
    internalName: "subscription_v2_destruct"
  },
  {
    opCode: 1350711532,
    parse: Kn,
    fixedLength: false,
    folderName: "subscriptions_v2",
    internalName: "subscription_v2_reduce_payment"
  },
  {
    opCode: 4033639783,
    parse: zn,
    fixedLength: false,
    folderName: "subscriptions_v2",
    internalName: "subscription_v2_payment_confirmed"
  },
  {
    opCode: 4166133070,
    parse: Qn,
    fixedLength: false,
    folderName: "subscriptions_v2",
    internalName: "subscription_v2_withdraw_to_beneficiary"
  },
  {
    opCode: 1178019994,
    parse: ta,
    fixedLength: false,
    folderName: "telegram",
    internalName: "telemint_deploy"
  },
  {
    opCode: 1178019995,
    parse: ra,
    fixedLength: false,
    folderName: "telegram",
    internalName: "telemint_deploy_v2"
  },
  {
    opCode: 697974293,
    parse: sa,
    fixedLength: false,
    folderName: "telegram",
    internalName: "teleitem_deploy"
  },
  {
    opCode: 1215991425,
    parse: fa,
    fixedLength: false,
    folderName: "telegram",
    internalName: "teleitem_start_auction"
  },
  {
    opCode: 924203182,
    parse: pa,
    fixedLength: false,
    folderName: "telegram",
    internalName: "teleitem_cancel_auction"
  },
  {
    opCode: 2742684035,
    parse: ma,
    fixedLength: false,
    folderName: "telegram",
    internalName: "teleitem_ok"
  },
  {
    opCode: 2754750433,
    parse: ga,
    fixedLength: false,
    folderName: "telegram",
    internalName: "teleitem_return_bid"
  },
  {
    opCode: 1399341111,
    parse: ha,
    fixedLength: false,
    folderName: "tonkeeper_2fa",
    internalName: "tonkeeper_2fa_signed"
  },
  {
    opCode: 3665837821,
    parse: Ca,
    fixedLength: false,
    folderName: "whales",
    internalName: "whales_nominators_withdraw"
  },
  {
    opCode: 2077040623,
    parse: ca,
    fixedLength: false,
    folderName: "whales",
    internalName: "whales_nominators_deposit"
  },
  {
    opCode: 362189324,
    parse: wa,
    fixedLength: false,
    folderName: "whales",
    internalName: "whales_nominators_force_kick"
  },
  {
    opCode: 1958425639,
    parse: ka,
    fixedLength: true,
    folderName: "whales",
    internalName: "whales_nominators_stake_withdraw_delayed"
  },
  {
    opCode: 601104865,
    parse: Sa,
    fixedLength: true,
    folderName: "whales",
    internalName: "whales_nominators_stake_withdraw_completed"
  },
  {
    opCode: 2718326572,
    parse: Ba,
    fixedLength: true,
    folderName: "whales",
    internalName: "whales_nominators_send_stake"
  },
  {
    opCode: 622684824,
    parse: xa,
    fixedLength: true,
    folderName: "whales",
    internalName: "whales_nominators_withdraw_unowned"
  },
  {
    opCode: 488052159,
    parse: ba,
    fixedLength: false,
    folderName: "whales",
    internalName: "whales_nominators_withdraw_unowned_response"
  },
  {
    opCode: 2577928699,
    parse: Na,
    fixedLength: false,
    folderName: "whales",
    internalName: "whales_nominators_accept_stake"
  },
  {
    opCode: 2711607604,
    parse: Pa,
    fixedLength: false,
    folderName: "whales",
    internalName: "whales_nominators_accept_withdraws"
  }
], Ha = $("tlb-abi:internal");
$("tlb-abi:jetton");
const za = {
  1112786133: [0],
  1227534771: [1],
  279039605: [2],
  2429028871: [3],
  946025784: [4],
  1544662441: [5],
  2078119902: [6, 31],
  3043726744: [7],
  1643009069: [8],
  1923917994: [9],
  2907617013: [10],
  1196394191: [11],
  3926267997: [12],
  3579725446: [13],
  567271467: [14],
  2547326767: [15],
  376237550: [16],
  1322339173: [17],
  1320284409: [18, 19],
  1153347137: [20],
  923790417: [21],
  1434249760: [22],
  1298755173: [23],
  1027039654: [24],
  1541764646: [25],
  1413869550: [26],
  2057453237: [27],
  260734629: [28],
  395134233: [29],
  1499400124: [30],
  1935855772: [32],
  4006754003: [33],
  1680571655: [34],
  1694626644: [35],
  4220051737: [36],
  593276754: [37],
  621336170: [38],
  3414567170: [39],
  4294967295: [40],
  0: [41],
  560454219: [42],
  3576854235: [43],
  3547469196: [44],
  378586628: [45],
  2068529894: [46],
  3902843902: [47],
  1316189259: [48],
  4084484172: [49],
  1197831204: [50],
  4184830756: [51],
  3946265093: [52],
  4043121232: [53],
  2399065977: [54],
  805462823: [55],
  3763363086: [56],
  1664463130: [57],
  3983767718: [58],
  1438805205: [59],
  3863136613: [60],
  3755778683: [61],
  1205158801: [62],
  1271382751: [63],
  715822752: [64],
  832244956: [65],
  175592284: [66],
  1582399286: [67],
  2616546844: [68],
  2994658477: [69],
  2574354460: [70],
  654743035: [71],
  2531783976: [72],
  2045231126: [73],
  1917314981: [74],
  328866638: [75],
  3387966597: [76],
  1423144071: [77],
  2985012742: [78],
  3241429248: [79],
  4045930062: [80],
  3982012594: [81],
  321886789: [82],
  3678112445: [83],
  376746144: [84],
  2007184673: [85],
  1607220500: [86],
  85167505: [87],
  801842850: [88],
  2339837749: [89],
  1765620048: [90],
  2831876269: [91],
  81711432: [92],
  86296494: [93],
  3502489578: [94],
  232130531: [95],
  520377210: [96],
  1871312355: [97],
  1741148801: [98],
  235282626: [99],
  1433884798: [100],
  2040604399: [101],
  521476815: [102],
  143567410: [103],
  1727459433: [104],
  625158801: [105],
  3722217658: [106],
  630424929: [107],
  4181439551: [108],
  32736093: [109],
  2921715614: [110],
  701638965: [111],
  1331643155: [112],
  1698746245: [113],
  116184359: [114],
  935368415: [115],
  1355195988: [116],
  1702581493: [117],
  1717886506: [118],
  894160372: [119],
  76607643: [120],
  553699618: [121],
  1664620082: [122],
  695482319: [123],
  3832843761: [124],
  1408453846: [125],
  1422651803: [126],
  276580847: [127],
  2050365064: [128],
  3570068941: [129],
  2046375914: [130],
  3055775075: [131],
  1189949076: [132],
  2837163862: [133],
  1100832077: [134],
  3989649062: [135],
  3058877505: [136],
  700515025: [137, 147],
  3410877500: [138],
  2229071226: [139],
  4124371794: [140],
  1329122024: [141],
  1574331769: [142],
  752771921: [143],
  880147922: [144],
  3365551844: [145],
  3585468845: [146],
  316235805: [148],
  1729316393: [149],
  2744665076: [150],
  3482375704: [151],
  2637088320: [152],
  1625278071: [153],
  1562056632: [154],
  982793446: [155],
  1775273593: [156],
  36101990: [157],
  2288366594: [158],
  4145513419: [159],
  1685288050: [160],
  1350711532: [161],
  4033639783: [162],
  4166133070: [163],
  1178019994: [164],
  1178019995: [165],
  697974293: [166],
  1215991425: [167],
  924203182: [168],
  2742684035: [169],
  2754750433: [170],
  1399341111: [171],
  3665837821: [172],
  2077040623: [173],
  362189324: [174],
  1958425639: [175],
  601104865: [176],
  2718326572: [177],
  622684824: [178],
  488052159: [179],
  2577928699: [180],
  2711607604: [181]
};
function Za(t) {
  if (t.remainingBits < 32)
    return;
  const e = t.preloadUint(32), o4 = za[e];
  if (o4)
    for (const n of o4) {
      const a2 = Ga[n];
      try {
        const r = t.asCell().toBoc(), d = a2.parse(t);
        if (a2.fixedLength && (t.remainingBits !== 0 || t.remainingRefs !== 0))
          throw new Error("Invalid data length");
        return {
          opCode: a2.opCode,
          schema: a2.folderName,
          internal: a2.internalName,
          boc: r,
          data: d
        };
      } catch (r) {
        Ha("Failed to parse internal: %s", r);
      }
    }
}
const TON_PROXY_ADDRESSES = [
  "0:8CDC1D7640AD5EE326527FC1AD0514F468B30DC84B0173F0E155F451B4E11F7C",
  "0:671963027F7F85659AB55B821671688601CDCF1EE674FC7FBBB1A776A18D34A3"
];
function createToncenterMessage(walletAddress, messages) {
  return {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      from: walletAddress,
      valid_until: Math.floor(Date.now() / 1e3) + 60,
      include_code_data: true,
      include_address_book: true,
      include_metadata: true,
      with_actions: true,
      messages
    })
  };
}
class FetchToncenterEmulationError extends Error {
  response;
  constructor(message, response) {
    super(message);
    this.name = "fetchToncenterEmulationError";
    this.response = response;
  }
}
async function fetchToncenterEmulation(message) {
  const response = await fetch("https://toncenter.com/api/emulate/v1/emulateTonConnect", message);
  if (!response.ok) {
    try {
      const errorMessage = await response.json();
      if (errorMessage.error === "Failed to fetch account state: Account not found in accounts_dict") {
        return {
          result: "error",
          emulationError: {
            code: ERROR_CODES.ACCOUNT_NOT_FOUND,
            message: "Account not found"
          }
        };
      }
    } catch (_) {
      throw new FetchToncenterEmulationError("Failed to fetch toncenter emulation result", response);
    }
    throw new FetchToncenterEmulationError("Failed to fetch toncenter emulation result", response);
  }
  const result = await response.json();
  return { result: "success", emulationResult: result };
}
function processToncenterMoneyFlow(emulation) {
  if (!emulation || !emulation.transactions) {
    return {
      outputs: "0",
      inputs: "0",
      allJettonTransfers: [],
      ourTransfers: [],
      ourAddress: null
    };
  }
  const firstTx = emulation.transactions[emulation.trace.tx_hash];
  const ourTxes = Object.values(emulation.transactions).filter((t) => t.account === firstTx.account);
  const messagesFrom = ourTxes.flatMap((t) => t.out_msgs);
  const messagesTo = ourTxes.flatMap((t) => t.in_msg).filter((m2) => m2 !== null);
  const outputs = messagesFrom.reduce((acc, m2) => {
    if (m2.value) {
      return acc + BigInt(m2.value);
    }
    return acc + 0n;
  }, 0n).toString();
  const inputs = messagesTo.reduce((acc, m2) => {
    if (m2.value) {
      return acc + BigInt(m2.value);
    }
    return acc + 0n;
  }, 0n).toString();
  const jettonTransfers = [];
  for (const t of Object.values(emulation.transactions)) {
    if (!t.in_msg?.source) {
      continue;
    }
    const parsed = Za(distExports$3.Cell.fromBase64(t.in_msg.message_content.body).beginParse());
    if (parsed?.internal !== "jetton_transfer") {
      continue;
    }
    const from = distExports$3.Address.parse(t.in_msg.source);
    const to2 = parsed.data.destination instanceof distExports$3.Address ? parsed.data.destination : null;
    if (!to2) {
      continue;
    }
    const jettonAmount = parsed.data.amount;
    const metadata = emulation.metadata[t.account];
    if (!metadata || !metadata?.token_info) {
      continue;
    }
    const tokenInfo = metadata.token_info.find((t2) => t2.valid && t2.type === "jetton_wallets");
    if (!tokenInfo) {
      continue;
    }
    const jettonAddress = distExports$3.Address.parse(tokenInfo.extra.jetton);
    jettonTransfers.push({
      from: from.toRawString().toUpperCase(),
      to: to2.toRawString().toUpperCase(),
      jetton: jettonAddress.toRawString().toUpperCase(),
      amount: jettonAmount.toString(),
      type: "jetton"
    });
  }
  const ourAddress = distExports$3.Address.parse(firstTx.account);
  const selfTransfers = [];
  const ourJettonTransfersByAddress = jettonTransfers.reduce((acc, transfer) => {
    if (transfer.type !== "jetton") {
      return acc;
    }
    const jettonKey = transfer.jetton?.toString() || "unknown";
    if (TON_PROXY_ADDRESSES.includes(jettonKey)) {
      return acc;
    }
    const rawKey = distExports$3.Address.parse(jettonKey).toRawString().toUpperCase();
    if (!acc[rawKey]) {
      acc[rawKey] = 0n;
    }
    if (ourAddress && transfer.to === ourAddress.toRawString().toUpperCase()) {
      acc[rawKey] += BigInt(transfer.amount);
    }
    if (ourAddress && transfer.from === ourAddress.toRawString().toUpperCase()) {
      acc[rawKey] -= BigInt(transfer.amount);
    }
    return acc;
  }, {});
  const ourJettonTransfers = Object.entries(ourJettonTransfersByAddress).map(([jettonKey, amount]) => ({
    type: "jetton",
    jetton: distExports$3.Address.parse(jettonKey).toRawString().toUpperCase(),
    amount: amount.toString()
  }));
  selfTransfers.push({
    type: "ton",
    amount: (BigInt(inputs) - BigInt(outputs)).toString()
  });
  selfTransfers.push(...ourJettonTransfers);
  return {
    outputs,
    inputs,
    allJettonTransfers: jettonTransfers,
    ourTransfers: selfTransfers,
    ourAddress: ourAddress.toRawString().toUpperCase()
  };
}
function asHex(data) {
  if (!/^0x[0-9a-fA-F]+$/.test(data) || data.length % 2 !== 0) {
    throw new Error("Not a valid hex");
  }
  return data;
}
function asMaybeAddressFriendly(data) {
  try {
    return asAddressFriendly(data);
  } catch {
  }
  return null;
}
function asAddressFriendly(data) {
  try {
    if (data)
      return distExports$3.Address.parse(data).toString();
  } catch {
  }
  throw new Error(`Can not convert to AddressFriendly from "${data}"`);
}
function limitString(data, limit) {
  return data.length > limit ? data.substring(0, limit) : data;
}
function toStringTail(data) {
  return distExports$3.beginCell().storeStringTail(limitString(data, 127)).endCell();
}
function Base64Normalize(data) {
  return data.replace(/\s+/g, "").replace(/-/g, "+").replace(/_/g, "/");
}
function ParseBase64(data) {
  if (typeof atob === "undefined" && typeof Buffer === "undefined") {
    throw new WalletKitError(ERROR_CODES.CONFIGURATION_ERROR, "atob function is not available in this environment");
  }
  data = Base64Normalize(data);
  return typeof atob === "function" ? atob(data) : Buffer.from(data, "base64").toString("utf-8");
}
function Base64ToHex(data) {
  if (!data)
    throw new WalletKitError(ERROR_CODES.VALIDATION_ERROR, "Invalid hash: data is required");
  const binary2 = Base64ToUint8Array(data);
  if (!binary2)
    throw new WalletKitError(ERROR_CODES.VALIDATION_ERROR, "Invalid hash: binary is required");
  return Uint8ArrayToHex(binary2);
}
function Uint8ArrayToHex(data) {
  return asHex(`0x${[...data].map((b2) => {
    if (b2 < 0 || b2 > 255)
      throw new WalletKitError(ERROR_CODES.VALIDATION_ERROR, "Invalid byte: expected 0-255", void 0, {
        actualByte: b2
      });
    return b2.toString(16).padStart(2, "0");
  }).join("")}`);
}
function Base64ToUint8Array(data) {
  if (!data)
    return null;
  const binary2 = ParseBase64(data);
  const len = binary2.length;
  const bytes = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    bytes[i] = binary2.charCodeAt(i);
  }
  return bytes;
}
function Uint8ArrayToBase64(data) {
  if (typeof btoa === "undefined" && typeof Buffer === "undefined") {
    throw new Error("btoa is not available in this environment");
  }
  let binary2 = "";
  for (let i = 0; i < data.length; i++) {
    binary2 += String.fromCharCode(data[i]);
  }
  return typeof btoa === "function" ? btoa(binary2) : Buffer.from(data).toString("base64");
}
function Base64ToBigInt(data) {
  if (!data || data === "")
    return 0n;
  const binary2 = ParseBase64(data);
  const len = binary2.length;
  let result = 0n;
  for (let i = 0; i < len; i++) {
    result = (result << 8n) + BigInt(binary2.charCodeAt(i));
  }
  return result;
}
function HexToBigInt(data) {
  return BigInt(data);
}
function HexToUint8Array(data) {
  const hex = data.slice(2);
  const bytes = new Uint8Array(hex.length / 2);
  for (let i = 0; i < hex.length; i += 2) {
    bytes[i / 2] = parseInt(hex.slice(i, i + 2), 16);
  }
  return bytes;
}
const log$d = globalLogger.createChild("TransactionHandler");
class TransactionHandler extends BasicHandler {
  walletManager;
  eventEmitter;
  analyticsApi;
  walletKitConfig;
  constructor(notify, eventEmitter, walletKitConfig, walletManager, analyticsApi) {
    super(notify);
    this.walletManager = walletManager;
    this.eventEmitter = eventEmitter;
    this.analyticsApi = analyticsApi;
    this.walletKitConfig = walletKitConfig;
  }
  canHandle(event) {
    return event.method === "sendTransaction";
  }
  async handle(event) {
    if (!event.walletAddress) {
      log$d.error("Wallet address not found", { event });
      return {
        error: {
          code: SEND_TRANSACTION_ERROR_CODES.UNKNOWN_APP_ERROR,
          message: "Wallet address not found"
        },
        id: event.id
      };
    }
    const wallet = this.walletManager.getWallet(event.walletAddress);
    if (!wallet) {
      log$d.error("Wallet not found", { event });
      return {
        error: {
          code: SEND_TRANSACTION_ERROR_CODES.UNKNOWN_APP_ERROR,
          message: "Wallet address not found"
        },
        id: event.id
      };
    }
    const requestValidation = this.parseTonConnectTransactionRequest(event, wallet);
    if (!requestValidation.result || !requestValidation?.validation?.isValid) {
      log$d.error("Failed to parse transaction request", { event, requestValidation });
      this.eventEmitter.emit("event:error", event);
      return {
        error: {
          code: SEND_TRANSACTION_ERROR_CODES.BAD_REQUEST_ERROR,
          message: "Failed to parse transaction request"
        },
        id: event.id
      };
    }
    const request = requestValidation.result;
    let preview;
    try {
      preview = await CallForSuccess(() => this.createTransactionPreview(request, wallet));
    } catch (error2) {
      log$d.error("Failed to create transaction preview", { error: error2 });
      preview = {
        emulationError: {
          code: ERROR_CODES.UNKNOWN_EMULATION_ERROR,
          message: "Unknown emulation error"
        },
        result: "error"
      };
    }
    const txEvent = {
      ...event,
      request,
      preview,
      dAppInfo: event.dAppInfo ?? {},
      walletAddress: event.walletAddress
    };
    this.analyticsApi?.sendEvents([
      {
        event_name: "wallet-transaction-request-received",
        trace_id: event.traceId ?? uuidv7(),
        client_environment: "wallet",
        subsystem: getEventsSubsystem(),
        client_id: event.from,
        client_timestamp: getUnixtime(),
        dapp_name: event.dAppInfo?.name,
        version: getVersion(),
        network_id: this.walletKitConfig.network,
        wallet_app_name: this.walletKitConfig.deviceInfo?.appName,
        wallet_app_version: this.walletKitConfig.deviceInfo?.appVersion,
        event_id: uuidv7(),
        // manifest_json_url: event.dAppInfo?.url, // todo
        origin_url: event.dAppInfo?.url,
        wallet_id: Base64Normalize(event.walletAddress)
      }
    ]);
    return txEvent;
  }
  /**
   * Parse raw transaction request from bridge event
   */
  parseTonConnectTransactionRequest(event, wallet) {
    let errors2 = [];
    try {
      if (event.params.length !== 1) {
        throw new WalletKitError(ERROR_CODES.INVALID_REQUEST_EVENT, "Invalid transaction request - expected exactly 1 parameter", void 0, { paramCount: event.params.length, eventId: event.id });
      }
      const params = JSON.parse(event.params[0]);
      const validUntilValidation = this.validateValidUntil(params.valid_until);
      if (!validUntilValidation.isValid) {
        errors2 = errors2.concat(validUntilValidation.errors);
      } else {
        params.valid_until = validUntilValidation.result;
      }
      const networkValidation = this.validateNetwork(params.network, wallet);
      if (!networkValidation.isValid) {
        errors2 = errors2.concat(networkValidation.errors);
      } else {
        params.network = networkValidation.result;
      }
      const fromValidation = this.validateFrom(params.from, wallet);
      if (!fromValidation.isValid) {
        errors2 = errors2.concat(fromValidation.errors);
      } else {
        params.from = fromValidation.result;
      }
      const isTonConnect = !event.isLocal;
      const messagesValidation = validateTransactionMessages(params.messages, isTonConnect);
      if (!messagesValidation.isValid) {
        errors2 = errors2.concat(messagesValidation.errors);
      }
      return {
        result: params,
        validation: { isValid: errors2.length === 0, errors: errors2 }
      };
    } catch (error2) {
      log$d.error("Failed to parse transaction request", { error: error2 });
      errors2.push("Failed to parse transaction request");
      return {
        result: void 0,
        validation: { isValid: errors2.length === 0, errors: errors2 }
      };
    }
  }
  /**
   * Parse network from various possible formats
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  validateNetwork(network, wallet) {
    let errors2 = [];
    if (typeof network === "string") {
      if (network === "-3" || network === "-239") {
        const chain = network === "-3" ? CHAIN.TESTNET : CHAIN.MAINNET;
        const walletNetwork = wallet.getNetwork();
        if (chain !== walletNetwork) {
          errors2.push("Invalid network not equal to wallet network");
        } else {
          return { result: chain, isValid: errors2.length === 0, errors: errors2 };
        }
      } else {
        errors2.push("Invalid network not a valid network");
      }
    } else {
      errors2.push("Invalid network not a string");
    }
    return { result: void 0, isValid: errors2.length === 0, errors: errors2 };
  }
  validateFrom(from, wallet) {
    let errors2 = [];
    if (typeof from !== "string") {
      errors2.push("Invalid from address not a string");
      return { result: "", isValid: errors2.length === 0, errors: errors2 };
    }
    if (!isValidAddress(from)) {
      errors2.push("Invalid from address");
      return { result: "", isValid: errors2.length === 0, errors: errors2 };
    }
    const fromAddress = distExports$3.Address.parse(from);
    const walletAddress = distExports$3.Address.parse(wallet.getAddress());
    if (!fromAddress.equals(walletAddress)) {
      errors2.push("Invalid from address not equal to wallet address");
      return { result: "", isValid: errors2.length === 0, errors: errors2 };
    }
    return { result: from, isValid: errors2.length === 0, errors: errors2 };
  }
  /**
   * Parse validUntil timestamp
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  validateValidUntil(validUntil) {
    let errors2 = [];
    if (typeof validUntil === "undefined") {
      return { result: 0, isValid: errors2.length === 0, errors: errors2 };
    }
    if (typeof validUntil !== "number" || isNaN(validUntil)) {
      errors2.push("Invalid validUntil timestamp not a number");
      return { result: 0, isValid: errors2.length === 0, errors: errors2 };
    }
    const now = Math.floor(Date.now() / 1e3);
    if (validUntil < now) {
      errors2.push("Invalid validUntil timestamp");
      return { result: 0, isValid: errors2.length === 0, errors: errors2 };
    }
    return { result: validUntil, isValid: errors2.length === 0, errors: errors2 };
  }
  /**
   * Create human-readable transaction preview
   */
  async createTransactionPreview(request, wallet) {
    const emulationResult = await this.emulateTransaction(request, wallet);
    log$d.info("Emulation result", { emulationResult });
    return emulationResult;
  }
  /**
   * Emulate transaction to get fees and balance changes
   */
  async emulateTransaction(request, wallet) {
    const message = createToncenterMessage(wallet?.getAddress(), request.messages);
    let emulationResult;
    try {
      const emulatedResult = await CallForSuccess(() => fetchToncenterEmulation(message));
      if (emulatedResult.result === "success") {
        emulationResult = emulatedResult.emulationResult;
      } else {
        return emulatedResult;
      }
    } catch (_error) {
      return {
        result: "error",
        emulationError: {
          code: ERROR_CODES.UNKNOWN_EMULATION_ERROR,
          message: "Unknown emulation error"
        }
      };
    }
    const moneyFlow = processToncenterMoneyFlow(emulationResult);
    if (emulationResult) {
      try {
        this.eventEmitter.emit("emulation:result", emulationResult);
      } catch (error2) {
        log$d.warn("Error emitting emulation result event", { error: error2 });
      }
    }
    return {
      result: "success",
      emulationResult,
      moneyFlow
    };
  }
}
var dist$3 = {};
var parser = {};
var TLBRuntime = {};
var build = {};
var ast = {};
var hasRequiredAst;
function requireAst() {
  if (hasRequiredAst) return ast;
  hasRequiredAst = 1;
  Object.defineProperty(ast, "__esModule", { value: true });
  ast.TLBCode = ast.TLBType = ast.TLBConstructor = ast.TLBParameter = ast.TLBVariable = ast.TLBVarExpr = ast.TLBUnaryOp = ast.TLBNumberExpr = ast.TLBBinaryOp = void 0;
  class TLBBinaryOp {
    constructor(left, right, operation, variables = /* @__PURE__ */ new Set([...left.variables, ...right.variables]), hasNeg = left.hasNeg || right.hasNeg) {
      this.left = left;
      this.right = right;
      this.operation = operation;
      this.variables = variables;
      this.hasNeg = hasNeg;
    }
  }
  ast.TLBBinaryOp = TLBBinaryOp;
  class TLBNumberExpr {
    constructor(n, variables = /* @__PURE__ */ new Set(), hasNeg = false) {
      this.n = n;
      this.variables = variables;
      this.hasNeg = hasNeg;
    }
  }
  ast.TLBNumberExpr = TLBNumberExpr;
  class TLBUnaryOp {
    constructor(value, operation, variables = value.variables, hasNeg = value.hasNeg) {
      this.value = value;
      this.operation = operation;
      this.variables = variables;
      this.hasNeg = hasNeg;
    }
  }
  ast.TLBUnaryOp = TLBUnaryOp;
  class TLBVarExpr {
    constructor(x2, variables = /* @__PURE__ */ new Set(), hasNeg = false) {
      this.x = x2;
      this.variables = variables;
      this.hasNeg = hasNeg;
      if (variables.size == 0) {
        variables.add(x2);
      }
    }
  }
  ast.TLBVarExpr = TLBVarExpr;
  class TLBVariable {
    constructor(isConst, negated, type, name, isField, deriveExpr, initialExpr) {
      this.isConst = isConst;
      this.negated = negated;
      this.type = type;
      this.name = name;
      this.isField = isField;
      this.deriveExpr = deriveExpr;
      this.initialExpr = initialExpr;
    }
  }
  ast.TLBVariable = TLBVariable;
  class TLBParameter {
    constructor(variable, paramExpr, argName) {
      this.variable = variable;
      this.paramExpr = paramExpr;
      this.argName = argName;
    }
  }
  ast.TLBParameter = TLBParameter;
  class TLBConstructor {
    constructor(parameters, variables, variablesMap, parametersMap, name, fields, tag, constraints, declaration, tlbType) {
      this.parameters = parameters;
      this.variables = variables;
      this.variablesMap = variablesMap;
      this.parametersMap = parametersMap;
      this.name = name;
      this.fields = fields;
      this.tag = tag;
      this.constraints = constraints;
      this.declaration = declaration;
      this.tlbType = tlbType;
    }
  }
  ast.TLBConstructor = TLBConstructor;
  class TLBType {
    constructor(name, constructors) {
      this.name = name;
      this.constructors = constructors;
    }
  }
  ast.TLBType = TLBType;
  class TLBCode {
    constructor(types2) {
      this.types = types2;
    }
  }
  ast.TLBCode = TLBCode;
  return ast;
}
var main$2 = {};
var dist$2 = {};
var intermediate = {};
var main$1 = { exports: {} };
function isValidType(type) {
  return type === "description" || type === "string" || type === "code";
}
function Failure$2(pexpr, text, type) {
  if (!isValidType(type)) {
    throw new Error("invalid Failure type: " + type);
  }
  this.pexpr = pexpr;
  this.text = text;
  this.type = type;
  this.fluffy = false;
}
Failure$2.prototype.getPExpr = function() {
  return this.pexpr;
};
Failure$2.prototype.getText = function() {
  return this.text;
};
Failure$2.prototype.getType = function() {
  return this.type;
};
Failure$2.prototype.isDescription = function() {
  return this.type === "description";
};
Failure$2.prototype.isStringTerminal = function() {
  return this.type === "string";
};
Failure$2.prototype.isCode = function() {
  return this.type === "code";
};
Failure$2.prototype.isFluffy = function() {
  return this.fluffy;
};
Failure$2.prototype.makeFluffy = function() {
  this.fluffy = true;
};
Failure$2.prototype.clearFluffy = function() {
  this.fluffy = false;
};
Failure$2.prototype.subsumes = function(that) {
  return this.getText() === that.getText() && this.type === that.type && (!this.isFluffy() || this.isFluffy() && that.isFluffy());
};
Failure$2.prototype.toString = function() {
  return this.type === "string" ? JSON.stringify(this.getText()) : this.getText();
};
Failure$2.prototype.clone = function() {
  const failure = new Failure$2(this.pexpr, this.text, this.type);
  if (this.isFluffy()) {
    failure.makeFluffy();
  }
  return failure;
};
Failure$2.prototype.toKey = function() {
  return this.toString() + "#" + this.type;
};
var Failure_1 = Failure$2;
var common$l = {};
(function(exports) {
  exports.abstract = function(optMethodName) {
    const methodName = optMethodName || "";
    return function() {
      throw new Error(
        "this method " + methodName + " is abstract! (it has no implementation in class " + this.constructor.name + ")"
      );
    };
  };
  exports.assert = function(cond, message) {
    if (!cond) {
      throw new Error(message || "Assertion failed");
    }
  };
  exports.defineLazyProperty = function(obj, propName, getterFn) {
    let memo;
    Object.defineProperty(obj, propName, {
      get() {
        if (!memo) {
          memo = getterFn.call(this);
        }
        return memo;
      }
    });
  };
  exports.clone = function(obj) {
    if (obj) {
      return Object.assign({}, obj);
    }
    return obj;
  };
  exports.repeatFn = function(fn2, n) {
    const arr = [];
    while (n-- > 0) {
      arr.push(fn2());
    }
    return arr;
  };
  exports.repeatStr = function(str, n) {
    return new Array(n + 1).join(str);
  };
  exports.repeat = function(x2, n) {
    return exports.repeatFn(() => x2, n);
  };
  exports.getDuplicates = function(array) {
    const duplicates = [];
    for (let idx = 0; idx < array.length; idx++) {
      const x2 = array[idx];
      if (array.lastIndexOf(x2) !== idx && duplicates.indexOf(x2) < 0) {
        duplicates.push(x2);
      }
    }
    return duplicates;
  };
  exports.copyWithoutDuplicates = function(array) {
    const noDuplicates = [];
    array.forEach((entry) => {
      if (noDuplicates.indexOf(entry) < 0) {
        noDuplicates.push(entry);
      }
    });
    return noDuplicates;
  };
  exports.isSyntactic = function(ruleName) {
    const firstChar = ruleName[0];
    return firstChar === firstChar.toUpperCase();
  };
  exports.isLexical = function(ruleName) {
    return !exports.isSyntactic(ruleName);
  };
  exports.padLeft = function(str, len, optChar) {
    const ch = optChar || " ";
    if (str.length < len) {
      return exports.repeatStr(ch, len - str.length) + str;
    }
    return str;
  };
  exports.StringBuffer = function() {
    this.strings = [];
  };
  exports.StringBuffer.prototype.append = function(str) {
    this.strings.push(str);
  };
  exports.StringBuffer.prototype.contents = function() {
    return this.strings.join("");
  };
  const escapeUnicode = (str) => String.fromCodePoint(parseInt(str, 16));
  exports.unescapeCodePoint = function(s2) {
    if (s2.charAt(0) === "\\") {
      switch (s2.charAt(1)) {
        case "b":
          return "\b";
        case "f":
          return "\f";
        case "n":
          return "\n";
        case "r":
          return "\r";
        case "t":
          return "	";
        case "v":
          return "\v";
        case "x":
          return escapeUnicode(s2.slice(2, 4));
        case "u":
          return s2.charAt(2) === "{" ? escapeUnicode(s2.slice(3, -1)) : escapeUnicode(s2.slice(2, 6));
        default:
          return s2.charAt(1);
      }
    } else {
      return s2;
    }
  };
  exports.unexpectedObjToString = function(obj) {
    if (obj == null) {
      return String(obj);
    }
    const baseToString = Object.prototype.toString.call(obj);
    try {
      let typeName;
      if (obj.constructor && obj.constructor.name) {
        typeName = obj.constructor.name;
      } else if (baseToString.indexOf("[object ") === 0) {
        typeName = baseToString.slice(8, -1);
      } else {
        typeName = typeof obj;
      }
      return typeName + ": " + JSON.stringify(String(obj));
    } catch (e) {
      return baseToString;
    }
  };
})(common$l);
const common$k = common$l;
let Node$1 = class Node2 {
  constructor(matchLength) {
    this.matchLength = matchLength;
  }
  get ctorName() {
    throw new Error("subclass responsibility");
  }
  numChildren() {
    return this.children ? this.children.length : 0;
  }
  childAt(idx) {
    if (this.children) {
      return this.children[idx];
    }
  }
  indexOfChild(arg) {
    return this.children.indexOf(arg);
  }
  hasChildren() {
    return this.numChildren() > 0;
  }
  hasNoChildren() {
    return !this.hasChildren();
  }
  onlyChild() {
    if (this.numChildren() !== 1) {
      throw new Error(
        "cannot get only child of a node of type " + this.ctorName + " (it has " + this.numChildren() + " children)"
      );
    } else {
      return this.firstChild();
    }
  }
  firstChild() {
    if (this.hasNoChildren()) {
      throw new Error(
        "cannot get first child of a " + this.ctorName + " node, which has no children"
      );
    } else {
      return this.childAt(0);
    }
  }
  lastChild() {
    if (this.hasNoChildren()) {
      throw new Error(
        "cannot get last child of a " + this.ctorName + " node, which has no children"
      );
    } else {
      return this.childAt(this.numChildren() - 1);
    }
  }
  childBefore(child) {
    const childIdx = this.indexOfChild(child);
    if (childIdx < 0) {
      throw new Error("Node.childBefore() called w/ an argument that is not a child");
    } else if (childIdx === 0) {
      throw new Error("cannot get child before first child");
    } else {
      return this.childAt(childIdx - 1);
    }
  }
  childAfter(child) {
    const childIdx = this.indexOfChild(child);
    if (childIdx < 0) {
      throw new Error("Node.childAfter() called w/ an argument that is not a child");
    } else if (childIdx === this.numChildren() - 1) {
      throw new Error("cannot get child after last child");
    } else {
      return this.childAt(childIdx + 1);
    }
  }
  isTerminal() {
    return false;
  }
  isNonterminal() {
    return false;
  }
  isIteration() {
    return false;
  }
  isOptional() {
    return false;
  }
};
class TerminalNode$2 extends Node$1 {
  get ctorName() {
    return "_terminal";
  }
  isTerminal() {
    return true;
  }
  get primitiveValue() {
    throw new Error("The `primitiveValue` property was removed in Ohm v17.");
  }
}
class NonterminalNode$1 extends Node$1 {
  constructor(ruleName, children, childOffsets, matchLength) {
    super(matchLength);
    this.ruleName = ruleName;
    this.children = children;
    this.childOffsets = childOffsets;
  }
  get ctorName() {
    return this.ruleName;
  }
  isNonterminal() {
    return true;
  }
  isLexical() {
    return common$k.isLexical(this.ctorName);
  }
  isSyntactic() {
    return common$k.isSyntactic(this.ctorName);
  }
}
class IterationNode$2 extends Node$1 {
  constructor(children, childOffsets, matchLength, isOptional) {
    super(matchLength);
    this.children = children;
    this.childOffsets = childOffsets;
    this.optional = isOptional;
  }
  get ctorName() {
    return "_iter";
  }
  isIteration() {
    return true;
  }
  isOptional() {
    return this.optional;
  }
}
var nodes$1$1 = {
  TerminalNode: TerminalNode$2,
  NonterminalNode: NonterminalNode$1,
  IterationNode: IterationNode$2
};
var pexprsMain = {};
var UnicodeCategories$1 = {
  // Letters
  Lu: /[A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AE\uA7B0-\uA7B4\uA7B6\uFF21-\uFF3A]|\uD801[\uDC00-\uDC27\uDCB0-\uDCD3]|\uD803[\uDC80-\uDCB2]|\uD806[\uDCA0-\uDCBF]|\uD835[\uDC00-\uDC19\uDC34-\uDC4D\uDC68-\uDC81\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB5\uDCD0-\uDCE9\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD38\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD6C-\uDD85\uDDA0-\uDDB9\uDDD4-\uDDED\uDE08-\uDE21\uDE3C-\uDE55\uDE70-\uDE89\uDEA8-\uDEC0\uDEE2-\uDEFA\uDF1C-\uDF34\uDF56-\uDF6E\uDF90-\uDFA8\uDFCA]|\uD83A[\uDD00-\uDD21]/,
  Ll: /[a-z\xB5\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0561-\u0587\u13F8-\u13FD\u1C80-\u1C88\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7B5\uA7B7\uA7FA\uAB30-\uAB5A\uAB60-\uAB65\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A]|\uD801[\uDC28-\uDC4F\uDCD8-\uDCFB]|\uD803[\uDCC0-\uDCF2]|\uD806[\uDCC0-\uDCDF]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]|\uD83A[\uDD22-\uDD43]/,
  Lt: /[\u01C5\u01C8\u01CB\u01F2\u1F88-\u1F8F\u1F98-\u1F9F\u1FA8-\u1FAF\u1FBC\u1FCC\u1FFC]/,
  Lm: /[\u02B0-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0374\u037A\u0559\u0640\u06E5\u06E6\u07F4\u07F5\u07FA\u081A\u0824\u0828\u0971\u0E46\u0EC6\u10FC\u17D7\u1843\u1AA7\u1C78-\u1C7D\u1D2C-\u1D6A\u1D78\u1D9B-\u1DBF\u2071\u207F\u2090-\u209C\u2C7C\u2C7D\u2D6F\u2E2F\u3005\u3031-\u3035\u303B\u309D\u309E\u30FC-\u30FE\uA015\uA4F8-\uA4FD\uA60C\uA67F\uA69C\uA69D\uA717-\uA71F\uA770\uA788\uA7F8\uA7F9\uA9CF\uA9E6\uAA70\uAADD\uAAF3\uAAF4\uAB5C-\uAB5F\uFF70\uFF9E\uFF9F]|\uD81A[\uDF40-\uDF43]|\uD81B[\uDF93-\uDF9F\uDFE0]/,
  Lo: /[\xAA\xBA\u01BB\u01C0-\u01C3\u0294\u05D0-\u05EA\u05F0-\u05F2\u0620-\u063F\u0641-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u0800-\u0815\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0972-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E45\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10D0-\u10FA\u10FD-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17DC\u1820-\u1842\u1844-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C77\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u2135-\u2138\u2D30-\u2D67\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3006\u303C\u3041-\u3096\u309F\u30A1-\u30FA\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA014\uA016-\uA48C\uA4D0-\uA4F7\uA500-\uA60B\uA610-\uA61F\uA62A\uA62B\uA66E\uA6A0-\uA6E5\uA78F\uA7F7\uA7FB-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9E0-\uA9E4\uA9E7-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA6F\uAA71-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB\uAADC\uAAE0-\uAAEA\uAAF2\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF66-\uFF6F\uFF71-\uFF9D\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC50-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
  // Numbers
  Nl: /[\u16EE-\u16F0\u2160-\u2182\u2185-\u2188\u3007\u3021-\u3029\u3038-\u303A\uA6E6-\uA6EF]|\uD800[\uDD40-\uDD74\uDF41\uDF4A\uDFD1-\uDFD5]|\uD809[\uDC00-\uDC6E]/,
  Nd: /[0-9\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19]|\uD801[\uDCA0-\uDCA9]|\uD804[\uDC66-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDEF0-\uDEF9]|[\uD805\uD807][\uDC50-\uDC59\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDF30-\uDF39]|\uD806[\uDCE0-\uDCE9]|\uD81A[\uDE60-\uDE69\uDF50-\uDF59]|\uD835[\uDFCE-\uDFFF]|\uD83A[\uDD50-\uDD59]/,
  // Marks
  Mn: /[\u0300-\u036F\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D4-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D01\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ABD\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFB-\u1DFF\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA8C4\uA8C5\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC01\uDC38-\uDC46\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDCA-\uDDCC\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3C\uDF40\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDCB3-\uDCB8\uDCBA\uDCBF\uDCC0\uDCC2\uDCC3\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD67-\uDD69\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uDB40[\uDD00-\uDDEF]/,
  Mc: /[\u0903-\u0903]|[\u093E-\u0940]|[\u0949-\u094C]|[\u0982-\u0983]|[\u09BE-\u09C0]|[\u09C7-\u09C8]|[\u09CB-\u09CC]|[\u09D7-\u09D7]|[\u0A3E-\u0A40]|[\u0A83-\u0A83]|[\u0ABE-\u0AC0]|[\u0AC9-\u0AC9]|[\u0ACB-\u0ACC]|[\u0B02-\u0B03]|[\u0B3E-\u0B3E]|[\u0B40-\u0B40]|[\u0B47-\u0B48]|[\u0B4B-\u0B4C]|[\u0B57-\u0B57]|[\u0B83-\u0B83]|[\u0BBE-\u0BBF]|[\u0BC1-\u0BC2]|[\u0BC6-\u0BC8]|[\u0BCA-\u0BCC]|[\u0BD7-\u0BD7]|[\u0C01-\u0C03]|[\u0C41-\u0C44]|[\u0C82-\u0C83]|[\u0CBE-\u0CBE]|[\u0CC0-\u0CC4]|[\u0CC7-\u0CC8]|[\u0CCA-\u0CCB]|[\u0CD5-\u0CD6]|[\u0D02-\u0D03]|[\u0D3E-\u0D40]|[\u0D46-\u0D48]|[\u0D4A-\u0D4C]|[\u0D57-\u0D57]|[\u0F3E-\u0F3F]|[\u0F7F-\u0F7F]/,
  // Punctuation, Connector
  Pc: /[_\u203F\u2040\u2054\uFE33\uFE34\uFE4D-\uFE4F\uFF3F]/,
  // Separator, Space
  Zs: /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/,
  // These two are not real Unicode categories, but our useful for Ohm.
  // L is a combination of all the letter categories.
  // Ltmo is a combination of Lt, Lm, and Lo.
  L: /[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
  Ltmo: /[\u01C5\u01C8\u01CB\u01F2\u1F88-\u1F8F\u1F98-\u1F9F\u1FA8-\u1FAF\u1FBC\u1FCC\u1FFC]|[\u02B0-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0374\u037A\u0559\u0640\u06E5\u06E6\u07F4\u07F5\u07FA\u081A\u0824\u0828\u0971\u0E46\u0EC6\u10FC\u17D7\u1843\u1AA7\u1C78-\u1C7D\u1D2C-\u1D6A\u1D78\u1D9B-\u1DBF\u2071\u207F\u2090-\u209C\u2C7C\u2C7D\u2D6F\u2E2F\u3005\u3031-\u3035\u303B\u309D\u309E\u30FC-\u30FE\uA015\uA4F8-\uA4FD\uA60C\uA67F\uA69C\uA69D\uA717-\uA71F\uA770\uA788\uA7F8\uA7F9\uA9CF\uA9E6\uAA70\uAADD\uAAF3\uAAF4\uAB5C-\uAB5F\uFF70\uFF9E\uFF9F]|\uD81A[\uDF40-\uDF43]|\uD81B[\uDF93-\uDF9F\uDFE0]|[\xAA\xBA\u01BB\u01C0-\u01C3\u0294\u05D0-\u05EA\u05F0-\u05F2\u0620-\u063F\u0641-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u0800-\u0815\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0972-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E45\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10D0-\u10FA\u10FD-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17DC\u1820-\u1842\u1844-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C77\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u2135-\u2138\u2D30-\u2D67\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3006\u303C\u3041-\u3096\u309F\u30A1-\u30FA\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA014\uA016-\uA48C\uA4D0-\uA4F7\uA500-\uA60B\uA610-\uA61F\uA62A\uA62B\uA66E\uA6A0-\uA6E5\uA78F\uA7F7\uA7FB-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9E0-\uA9E4\uA9E7-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA6F\uAA71-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB\uAADC\uAAE0-\uAAEA\uAAF2\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF66-\uFF6F\uFF71-\uFF9D\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC50-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/
};
const UnicodeCategories = UnicodeCategories$1;
const common$j = common$l;
class PExpr$1 {
  constructor() {
    if (this.constructor === PExpr$1) {
      throw new Error("PExpr cannot be instantiated -- it's abstract");
    }
  }
  // Set the `source` property to the interval containing the source for this expression.
  withSource(interval) {
    if (interval) {
      this.source = interval.trimmed();
    }
    return this;
  }
}
const any = Object.create(PExpr$1.prototype);
const end = Object.create(PExpr$1.prototype);
class Terminal$1 extends PExpr$1 {
  constructor(obj) {
    super();
    this.obj = obj;
  }
}
class Range extends PExpr$1 {
  constructor(from, to2) {
    super();
    this.from = from;
    this.to = to2;
    this.matchCodePoint = from.length > 1 || to2.length > 1;
  }
}
class Param extends PExpr$1 {
  constructor(index) {
    super();
    this.index = index;
  }
}
class Alt extends PExpr$1 {
  constructor(terms) {
    super();
    this.terms = terms;
  }
}
class Extend extends Alt {
  constructor(superGrammar, name, body) {
    const origBody = superGrammar.rules[name].body;
    super([body, origBody]);
    this.superGrammar = superGrammar;
    this.name = name;
    this.body = body;
  }
}
class Splice extends Alt {
  constructor(superGrammar, ruleName, beforeTerms, afterTerms) {
    const origBody = superGrammar.rules[ruleName].body;
    super([...beforeTerms, origBody, ...afterTerms]);
    this.superGrammar = superGrammar;
    this.ruleName = ruleName;
    this.expansionPos = beforeTerms.length;
  }
}
class Seq extends PExpr$1 {
  constructor(factors) {
    super();
    this.factors = factors;
  }
}
class Iter extends PExpr$1 {
  constructor(expr) {
    super();
    this.expr = expr;
  }
}
class Star extends Iter {
}
class Plus extends Iter {
}
class Opt extends Iter {
}
Star.prototype.operator = "*";
Plus.prototype.operator = "+";
Opt.prototype.operator = "?";
Star.prototype.minNumMatches = 0;
Plus.prototype.minNumMatches = 1;
Opt.prototype.minNumMatches = 0;
Star.prototype.maxNumMatches = Number.POSITIVE_INFINITY;
Plus.prototype.maxNumMatches = Number.POSITIVE_INFINITY;
Opt.prototype.maxNumMatches = 1;
class Not extends PExpr$1 {
  constructor(expr) {
    super();
    this.expr = expr;
  }
}
class Lookahead extends PExpr$1 {
  constructor(expr) {
    super();
    this.expr = expr;
  }
}
class Lex extends PExpr$1 {
  constructor(expr) {
    super();
    this.expr = expr;
  }
}
class Apply extends PExpr$1 {
  constructor(ruleName, args = []) {
    super();
    this.ruleName = ruleName;
    this.args = args;
  }
  isSyntactic() {
    return common$j.isSyntactic(this.ruleName);
  }
  // This method just caches the result of `this.toString()` in a non-enumerable property.
  toMemoKey() {
    if (!this._memoKey) {
      Object.defineProperty(this, "_memoKey", { value: this.toString() });
    }
    return this._memoKey;
  }
}
class UnicodeChar extends PExpr$1 {
  constructor(category) {
    super();
    this.category = category;
    this.pattern = UnicodeCategories[category];
  }
}
pexprsMain.PExpr = PExpr$1;
pexprsMain.any = any;
pexprsMain.end = end;
pexprsMain.Terminal = Terminal$1;
pexprsMain.Range = Range;
pexprsMain.Param = Param;
pexprsMain.Alt = Alt;
pexprsMain.Extend = Extend;
pexprsMain.Splice = Splice;
pexprsMain.Seq = Seq;
pexprsMain.Iter = Iter;
pexprsMain.Star = Star;
pexprsMain.Plus = Plus;
pexprsMain.Opt = Opt;
pexprsMain.Not = Not;
pexprsMain.Lookahead = Lookahead;
pexprsMain.Lex = Lex;
pexprsMain.Apply = Apply;
pexprsMain.UnicodeChar = UnicodeChar;
const common$i = common$l;
const pexprs$l = pexprsMain;
pexprs$l.PExpr.prototype.allowsSkippingPrecedingSpace = common$i.abstract(
  "allowsSkippingPrecedingSpace"
);
pexprs$l.any.allowsSkippingPrecedingSpace = pexprs$l.end.allowsSkippingPrecedingSpace = pexprs$l.Apply.prototype.allowsSkippingPrecedingSpace = pexprs$l.Terminal.prototype.allowsSkippingPrecedingSpace = pexprs$l.Range.prototype.allowsSkippingPrecedingSpace = pexprs$l.UnicodeChar.prototype.allowsSkippingPrecedingSpace = function() {
  return true;
};
pexprs$l.Alt.prototype.allowsSkippingPrecedingSpace = pexprs$l.Iter.prototype.allowsSkippingPrecedingSpace = pexprs$l.Lex.prototype.allowsSkippingPrecedingSpace = pexprs$l.Lookahead.prototype.allowsSkippingPrecedingSpace = pexprs$l.Not.prototype.allowsSkippingPrecedingSpace = pexprs$l.Param.prototype.allowsSkippingPrecedingSpace = pexprs$l.Seq.prototype.allowsSkippingPrecedingSpace = function() {
  return false;
};
function Namespace$2() {
}
Namespace$2.prototype = /* @__PURE__ */ Object.create(null);
Namespace$2.asNamespace = function(objOrNamespace) {
  if (objOrNamespace instanceof Namespace$2) {
    return objOrNamespace;
  }
  return Namespace$2.createNamespace(objOrNamespace);
};
Namespace$2.createNamespace = function(optProps) {
  return Namespace$2.extend(Namespace$2.prototype, optProps);
};
Namespace$2.extend = function(namespace, optProps) {
  if (namespace !== Namespace$2.prototype && !(namespace instanceof Namespace$2)) {
    throw new TypeError("not a Namespace object: " + namespace);
  }
  const ns = Object.create(namespace, {
    constructor: {
      value: Namespace$2,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  return Object.assign(ns, optProps);
};
Namespace$2.toString = function(ns) {
  return Object.prototype.toString.call(ns);
};
var Namespace_1 = Namespace$2;
const { assert: assert$3 } = common$l;
const Namespace$1 = Namespace_1;
const pexprs$k = pexprsMain;
function createError(message, optInterval) {
  let e;
  if (optInterval) {
    e = new Error(optInterval.getLineAndColumnMessage() + message);
    e.shortMessage = message;
    e.interval = optInterval;
  } else {
    e = new Error(message);
  }
  return e;
}
function intervalSourcesDontMatch() {
  return createError("Interval sources don't match");
}
function grammarSyntaxError(matchFailure) {
  const e = new Error();
  Object.defineProperty(e, "message", {
    enumerable: true,
    get() {
      return matchFailure.message;
    }
  });
  Object.defineProperty(e, "shortMessage", {
    enumerable: true,
    get() {
      return "Expected " + matchFailure.getExpectedText();
    }
  });
  e.interval = matchFailure.getInterval();
  return e;
}
function undeclaredGrammar(grammarName, namespace, interval) {
  const message = namespace ? "Grammar " + grammarName + " is not declared in namespace " + Namespace$1.toString(namespace) : "Undeclared grammar " + grammarName;
  return createError(message, interval);
}
function duplicateGrammarDeclaration(grammar2, namespace) {
  return createError("Grammar " + grammar2.name + " is already declared in this namespace");
}
function undeclaredRule(ruleName, grammarName, optInterval) {
  return createError(
    "Rule " + ruleName + " is not declared in grammar " + grammarName,
    optInterval
  );
}
function cannotOverrideUndeclaredRule(ruleName, grammarName, optSource) {
  return createError(
    "Cannot override rule " + ruleName + " because it is not declared in " + grammarName,
    optSource
  );
}
function cannotExtendUndeclaredRule(ruleName, grammarName, optSource) {
  return createError(
    "Cannot extend rule " + ruleName + " because it is not declared in " + grammarName,
    optSource
  );
}
function duplicateRuleDeclaration(ruleName, grammarName, declGrammarName, optSource) {
  let message = "Duplicate declaration for rule '" + ruleName + "' in grammar '" + grammarName + "'";
  if (grammarName !== declGrammarName) {
    message += " (originally declared in '" + declGrammarName + "')";
  }
  return createError(message, optSource);
}
function wrongNumberOfParameters(ruleName, expected, actual, source) {
  return createError(
    "Wrong number of parameters for rule " + ruleName + " (expected " + expected + ", got " + actual + ")",
    source
  );
}
function wrongNumberOfArguments(ruleName, expected, actual, expr) {
  return createError(
    "Wrong number of arguments for rule " + ruleName + " (expected " + expected + ", got " + actual + ")",
    expr
  );
}
function duplicateParameterNames(ruleName, duplicates, source) {
  return createError(
    "Duplicate parameter names in rule " + ruleName + ": " + duplicates.join(", "),
    source
  );
}
function invalidParameter(ruleName, expr) {
  return createError(
    "Invalid parameter to rule " + ruleName + ": " + expr + " has arity " + expr.getArity() + ", but parameter expressions must have arity 1",
    expr.source
  );
}
const syntacticVsLexicalNote = "NOTE: A _syntactic rule_ is a rule whose name begins with a capital letter. See https://ohmjs.org/d/svl for more details.";
function applicationOfSyntacticRuleFromLexicalContext(ruleName, applyExpr) {
  return createError(
    "Cannot apply syntactic rule " + ruleName + " from here (inside a lexical context)",
    applyExpr.source
  );
}
function applySyntacticWithLexicalRuleApplication(applyExpr) {
  const { ruleName } = applyExpr;
  return createError(
    `applySyntactic is for syntactic rules, but '${ruleName}' is a lexical rule. ` + syntacticVsLexicalNote,
    applyExpr.source
  );
}
function unnecessaryExperimentalApplySyntactic(applyExpr) {
  return createError(
    "applySyntactic is not required here (in a syntactic context)",
    applyExpr.source
  );
}
function incorrectArgumentType(expectedType, expr) {
  return createError("Incorrect argument type: expected " + expectedType, expr.source);
}
function multipleSuperSplices(expr) {
  return createError("'...' can appear at most once in a rule body", expr.source);
}
function invalidCodePoint(applyWrapper) {
  const node = applyWrapper._node;
  assert$3(node && node.isNonterminal() && node.ctorName === "escapeChar_unicodeCodePoint");
  const digitIntervals = applyWrapper.children.slice(1, -1).map((d) => d.source);
  const fullInterval = digitIntervals[0].coverageWith(...digitIntervals.slice(1));
  return createError(
    `U+${fullInterval.contents} is not a valid Unicode code point`,
    fullInterval
  );
}
function kleeneExprHasNullableOperand(kleeneExpr, applicationStack) {
  const actuals = applicationStack.length > 0 ? applicationStack[applicationStack.length - 1].args : [];
  const expr = kleeneExpr.expr.substituteParams(actuals);
  let message = "Nullable expression " + expr + " is not allowed inside '" + kleeneExpr.operator + "' (possible infinite loop)";
  if (applicationStack.length > 0) {
    const stackTrace = applicationStack.map((app) => new pexprs$k.Apply(app.ruleName, app.args)).join("\n");
    message += "\nApplication stack (most recent application last):\n" + stackTrace;
  }
  return createError(message, kleeneExpr.expr.source);
}
function inconsistentArity(ruleName, expected, actual, expr) {
  return createError(
    "Rule " + ruleName + " involves an alternation which has inconsistent arity (expected " + expected + ", got " + actual + ")",
    expr.source
  );
}
function duplicatePropertyNames(duplicates) {
  return createError("Object pattern has duplicate property names: " + duplicates.join(", "));
}
function invalidConstructorCall(grammar2, ctorName, children) {
  return createError(
    "Attempt to invoke constructor " + ctorName + " with invalid or unexpected arguments"
  );
}
function multipleErrors(errors2) {
  const messages = errors2.map((e) => e.message);
  return createError(["Errors:"].concat(messages).join("\n- "), errors2[0].interval);
}
function missingSemanticAction(ctorName, name, type, stack) {
  let stackTrace = stack.slice(0, -1).map((info) => {
    const ans = "  " + info[0].name + " > " + info[1];
    return info.length === 3 ? ans + " for '" + info[2] + "'" : ans;
  }).join("\n");
  stackTrace += "\n  " + name + " > " + ctorName;
  let moreInfo = "";
  if (ctorName === "_iter") {
    moreInfo = [
      "\nNOTE: as of Ohm v16, there is no default action for iteration nodes  see ",
      "  https://ohmjs.org/d/dsa for details."
    ].join("\n");
  }
  const message = [
    `Missing semantic action for '${ctorName}' in ${type} '${name}'.${moreInfo}`,
    "Action stack (most recent call last):",
    stackTrace
  ].join("\n");
  const e = createError(message);
  e.name = "missingSemanticAction";
  return e;
}
var errors$9 = {
  applicationOfSyntacticRuleFromLexicalContext,
  applySyntacticWithLexicalRuleApplication,
  cannotExtendUndeclaredRule,
  cannotOverrideUndeclaredRule,
  duplicateGrammarDeclaration,
  duplicateParameterNames,
  duplicatePropertyNames,
  duplicateRuleDeclaration,
  inconsistentArity,
  incorrectArgumentType,
  intervalSourcesDontMatch,
  invalidCodePoint,
  invalidConstructorCall,
  invalidParameter,
  grammarSyntaxError,
  kleeneExprHasNullableOperand,
  missingSemanticAction,
  multipleSuperSplices,
  undeclaredGrammar,
  undeclaredRule,
  unnecessaryExperimentalApplySyntactic,
  wrongNumberOfArguments,
  wrongNumberOfParameters,
  throwErrors(errors2) {
    if (errors2.length === 1) {
      throw errors2[0];
    }
    if (errors2.length > 1) {
      throw multipleErrors(errors2);
    }
  }
};
var util$7 = {};
(function(exports) {
  const common2 = common$l;
  function padNumbersToEqualLength(arr) {
    let maxLen = 0;
    const strings2 = arr.map((n) => {
      const str = n.toString();
      maxLen = Math.max(maxLen, str.length);
      return str;
    });
    return strings2.map((s2) => common2.padLeft(s2, maxLen));
  }
  function strcpy(dest, src2, offset) {
    const origDestLen = dest.length;
    const start = dest.slice(0, offset);
    const end2 = dest.slice(offset + src2.length);
    return (start + src2 + end2).substr(0, origDestLen);
  }
  function lineAndColumnToMessage(...ranges) {
    const lineAndCol = this;
    const { offset } = lineAndCol;
    const { repeatStr } = common2;
    const sb = new common2.StringBuffer();
    sb.append("Line " + lineAndCol.lineNum + ", col " + lineAndCol.colNum + ":\n");
    const lineNumbers = padNumbersToEqualLength([
      lineAndCol.prevLine == null ? 0 : lineAndCol.lineNum - 1,
      lineAndCol.lineNum,
      lineAndCol.nextLine == null ? 0 : lineAndCol.lineNum + 1
    ]);
    const appendLine = (num, content2, prefix) => {
      sb.append(prefix + lineNumbers[num] + " | " + content2 + "\n");
    };
    if (lineAndCol.prevLine != null) {
      appendLine(0, lineAndCol.prevLine, "  ");
    }
    appendLine(1, lineAndCol.line, "> ");
    const lineLen = lineAndCol.line.length;
    let indicationLine = repeatStr(" ", lineLen + 1);
    for (let i = 0; i < ranges.length; ++i) {
      let startIdx = ranges[i][0];
      let endIdx = ranges[i][1];
      common2.assert(startIdx >= 0 && startIdx <= endIdx, "range start must be >= 0 and <= end");
      const lineStartOffset = offset - lineAndCol.colNum + 1;
      startIdx = Math.max(0, startIdx - lineStartOffset);
      endIdx = Math.min(endIdx - lineStartOffset, lineLen);
      indicationLine = strcpy(indicationLine, repeatStr("~", endIdx - startIdx), startIdx);
    }
    const gutterWidth = 2 + lineNumbers[1].length + 3;
    sb.append(repeatStr(" ", gutterWidth));
    indicationLine = strcpy(indicationLine, "^", lineAndCol.colNum - 1);
    sb.append(indicationLine.replace(/ +$/, "") + "\n");
    if (lineAndCol.nextLine != null) {
      appendLine(2, lineAndCol.nextLine, "  ");
    }
    return sb.contents();
  }
  let builtInRulesCallbacks = [];
  exports.awaitBuiltInRules = (cb) => {
    builtInRulesCallbacks.push(cb);
  };
  exports.announceBuiltInRules = (grammar2) => {
    builtInRulesCallbacks.forEach((cb) => {
      cb(grammar2);
    });
    builtInRulesCallbacks = null;
  };
  exports.getLineAndColumn = (str, offset) => {
    let lineNum = 1;
    let colNum = 1;
    let currOffset = 0;
    let lineStartOffset = 0;
    let nextLine = null;
    let prevLine = null;
    let prevLineStartOffset = -1;
    while (currOffset < offset) {
      const c = str.charAt(currOffset++);
      if (c === "\n") {
        lineNum++;
        colNum = 1;
        prevLineStartOffset = lineStartOffset;
        lineStartOffset = currOffset;
      } else if (c !== "\r") {
        colNum++;
      }
    }
    let lineEndOffset = str.indexOf("\n", lineStartOffset);
    if (lineEndOffset === -1) {
      lineEndOffset = str.length;
    } else {
      const nextLineEndOffset = str.indexOf("\n", lineEndOffset + 1);
      nextLine = nextLineEndOffset === -1 ? str.slice(lineEndOffset) : str.slice(lineEndOffset, nextLineEndOffset);
      nextLine = nextLine.replace(/^\r?\n/, "").replace(/\r$/, "");
    }
    if (prevLineStartOffset >= 0) {
      prevLine = str.slice(prevLineStartOffset, lineStartOffset).replace(/\r?\n$/, "");
    }
    const line = str.slice(lineStartOffset, lineEndOffset).replace(/\r$/, "");
    return {
      offset,
      lineNum,
      colNum,
      line,
      prevLine,
      nextLine,
      toString: lineAndColumnToMessage
    };
  };
  exports.getLineAndColumnMessage = function(str, offset, ...ranges) {
    return exports.getLineAndColumn(str, offset).toString(...ranges);
  };
  exports.uniqueId = /* @__PURE__ */ (() => {
    let idCounter = 0;
    return (prefix) => "" + prefix + idCounter++;
  })();
})(util$7);
const { abstract, isSyntactic } = common$l;
const errors$8 = errors$9;
const pexprs$j = pexprsMain;
const util$6 = util$7;
let BuiltInRules;
util$6.awaitBuiltInRules((g2) => {
  BuiltInRules = g2;
});
let lexifyCount;
pexprs$j.PExpr.prototype.assertAllApplicationsAreValid = function(ruleName, grammar2) {
  lexifyCount = 0;
  this._assertAllApplicationsAreValid(ruleName, grammar2);
};
pexprs$j.PExpr.prototype._assertAllApplicationsAreValid = abstract(
  "_assertAllApplicationsAreValid"
);
pexprs$j.any._assertAllApplicationsAreValid = pexprs$j.end._assertAllApplicationsAreValid = pexprs$j.Terminal.prototype._assertAllApplicationsAreValid = pexprs$j.Range.prototype._assertAllApplicationsAreValid = pexprs$j.Param.prototype._assertAllApplicationsAreValid = pexprs$j.UnicodeChar.prototype._assertAllApplicationsAreValid = function(ruleName, grammar2) {
};
pexprs$j.Lex.prototype._assertAllApplicationsAreValid = function(ruleName, grammar2) {
  lexifyCount++;
  this.expr._assertAllApplicationsAreValid(ruleName, grammar2);
  lexifyCount--;
};
pexprs$j.Alt.prototype._assertAllApplicationsAreValid = function(ruleName, grammar2) {
  for (let idx = 0; idx < this.terms.length; idx++) {
    this.terms[idx]._assertAllApplicationsAreValid(ruleName, grammar2);
  }
};
pexprs$j.Seq.prototype._assertAllApplicationsAreValid = function(ruleName, grammar2) {
  for (let idx = 0; idx < this.factors.length; idx++) {
    this.factors[idx]._assertAllApplicationsAreValid(ruleName, grammar2);
  }
};
pexprs$j.Iter.prototype._assertAllApplicationsAreValid = pexprs$j.Not.prototype._assertAllApplicationsAreValid = pexprs$j.Lookahead.prototype._assertAllApplicationsAreValid = function(ruleName, grammar2) {
  this.expr._assertAllApplicationsAreValid(ruleName, grammar2);
};
pexprs$j.Apply.prototype._assertAllApplicationsAreValid = function(ruleName, grammar2, skipSyntacticCheck = false) {
  const ruleInfo = grammar2.rules[this.ruleName];
  const isContextSyntactic = isSyntactic(ruleName) && lexifyCount === 0;
  if (!ruleInfo) {
    throw errors$8.undeclaredRule(this.ruleName, grammar2.name, this.source);
  }
  if (!skipSyntacticCheck && isSyntactic(this.ruleName) && !isContextSyntactic) {
    throw errors$8.applicationOfSyntacticRuleFromLexicalContext(this.ruleName, this);
  }
  const actual = this.args.length;
  const expected = ruleInfo.formals.length;
  if (actual !== expected) {
    throw errors$8.wrongNumberOfArguments(this.ruleName, expected, actual, this.source);
  }
  const isBuiltInApplySyntactic = BuiltInRules && ruleInfo === BuiltInRules.rules.applySyntactic;
  const isBuiltInCaseInsensitive = BuiltInRules && ruleInfo === BuiltInRules.rules.caseInsensitive;
  if (isBuiltInCaseInsensitive) {
    if (!(this.args[0] instanceof pexprs$j.Terminal)) {
      throw errors$8.incorrectArgumentType('a Terminal (e.g. "abc")', this.args[0]);
    }
  }
  if (isBuiltInApplySyntactic) {
    const arg = this.args[0];
    if (!(arg instanceof pexprs$j.Apply)) {
      throw errors$8.incorrectArgumentType("a syntactic rule application", arg);
    }
    if (!isSyntactic(arg.ruleName)) {
      throw errors$8.applySyntacticWithLexicalRuleApplication(arg);
    }
    if (isContextSyntactic) {
      throw errors$8.unnecessaryExperimentalApplySyntactic(this);
    }
  }
  this.args.forEach((arg) => {
    arg._assertAllApplicationsAreValid(ruleName, grammar2, isBuiltInApplySyntactic);
    if (arg.getArity() !== 1) {
      throw errors$8.invalidParameter(this.ruleName, arg);
    }
  });
};
const common$h = common$l;
const errors$7 = errors$9;
const pexprs$i = pexprsMain;
pexprs$i.PExpr.prototype.assertChoicesHaveUniformArity = common$h.abstract(
  "assertChoicesHaveUniformArity"
);
pexprs$i.any.assertChoicesHaveUniformArity = pexprs$i.end.assertChoicesHaveUniformArity = pexprs$i.Terminal.prototype.assertChoicesHaveUniformArity = pexprs$i.Range.prototype.assertChoicesHaveUniformArity = pexprs$i.Param.prototype.assertChoicesHaveUniformArity = pexprs$i.Lex.prototype.assertChoicesHaveUniformArity = pexprs$i.UnicodeChar.prototype.assertChoicesHaveUniformArity = function(ruleName) {
};
pexprs$i.Alt.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  if (this.terms.length === 0) {
    return;
  }
  const arity = this.terms[0].getArity();
  for (let idx = 0; idx < this.terms.length; idx++) {
    const term = this.terms[idx];
    term.assertChoicesHaveUniformArity();
    const otherArity = term.getArity();
    if (arity !== otherArity) {
      throw errors$7.inconsistentArity(ruleName, arity, otherArity, term);
    }
  }
};
pexprs$i.Extend.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  const actualArity = this.terms[0].getArity();
  const expectedArity = this.terms[1].getArity();
  if (actualArity !== expectedArity) {
    throw errors$7.inconsistentArity(ruleName, expectedArity, actualArity, this.terms[0]);
  }
};
pexprs$i.Seq.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  for (let idx = 0; idx < this.factors.length; idx++) {
    this.factors[idx].assertChoicesHaveUniformArity(ruleName);
  }
};
pexprs$i.Iter.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  this.expr.assertChoicesHaveUniformArity(ruleName);
};
pexprs$i.Not.prototype.assertChoicesHaveUniformArity = function(ruleName) {
};
pexprs$i.Lookahead.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  this.expr.assertChoicesHaveUniformArity(ruleName);
};
pexprs$i.Apply.prototype.assertChoicesHaveUniformArity = function(ruleName) {
};
const common$g = common$l;
const errors$6 = errors$9;
const pexprs$h = pexprsMain;
pexprs$h.PExpr.prototype.assertIteratedExprsAreNotNullable = common$g.abstract(
  "assertIteratedExprsAreNotNullable"
);
pexprs$h.any.assertIteratedExprsAreNotNullable = pexprs$h.end.assertIteratedExprsAreNotNullable = pexprs$h.Terminal.prototype.assertIteratedExprsAreNotNullable = pexprs$h.Range.prototype.assertIteratedExprsAreNotNullable = pexprs$h.Param.prototype.assertIteratedExprsAreNotNullable = pexprs$h.UnicodeChar.prototype.assertIteratedExprsAreNotNullable = function(grammar2) {
};
pexprs$h.Alt.prototype.assertIteratedExprsAreNotNullable = function(grammar2) {
  for (let idx = 0; idx < this.terms.length; idx++) {
    this.terms[idx].assertIteratedExprsAreNotNullable(grammar2);
  }
};
pexprs$h.Seq.prototype.assertIteratedExprsAreNotNullable = function(grammar2) {
  for (let idx = 0; idx < this.factors.length; idx++) {
    this.factors[idx].assertIteratedExprsAreNotNullable(grammar2);
  }
};
pexprs$h.Iter.prototype.assertIteratedExprsAreNotNullable = function(grammar2) {
  this.expr.assertIteratedExprsAreNotNullable(grammar2);
  if (this.expr.isNullable(grammar2)) {
    throw errors$6.kleeneExprHasNullableOperand(this, []);
  }
};
pexprs$h.Opt.prototype.assertIteratedExprsAreNotNullable = pexprs$h.Not.prototype.assertIteratedExprsAreNotNullable = pexprs$h.Lookahead.prototype.assertIteratedExprsAreNotNullable = pexprs$h.Lex.prototype.assertIteratedExprsAreNotNullable = function(grammar2) {
  this.expr.assertIteratedExprsAreNotNullable(grammar2);
};
pexprs$h.Apply.prototype.assertIteratedExprsAreNotNullable = function(grammar2) {
  this.args.forEach((arg) => {
    arg.assertIteratedExprsAreNotNullable(grammar2);
  });
};
const { assert: assert$2 } = common$l;
const errors$5 = errors$9;
const util$5 = util$7;
function Interval$3(sourceString, startIdx, endIdx) {
  this.sourceString = sourceString;
  this.startIdx = startIdx;
  this.endIdx = endIdx;
}
Interval$3.coverage = function(firstInterval, ...intervals) {
  let { startIdx, endIdx } = firstInterval;
  for (const interval of intervals) {
    if (interval.sourceString !== firstInterval.sourceString) {
      throw errors$5.intervalSourcesDontMatch();
    } else {
      startIdx = Math.min(startIdx, interval.startIdx);
      endIdx = Math.max(endIdx, interval.endIdx);
    }
  }
  return new Interval$3(firstInterval.sourceString, startIdx, endIdx);
};
Interval$3.prototype = {
  coverageWith(...intervals) {
    return Interval$3.coverage(...intervals, this);
  },
  collapsedLeft() {
    return new Interval$3(this.sourceString, this.startIdx, this.startIdx);
  },
  collapsedRight() {
    return new Interval$3(this.sourceString, this.endIdx, this.endIdx);
  },
  getLineAndColumn() {
    return util$5.getLineAndColumn(this.sourceString, this.startIdx);
  },
  getLineAndColumnMessage() {
    const range = [this.startIdx, this.endIdx];
    return util$5.getLineAndColumnMessage(this.sourceString, this.startIdx, range);
  },
  // Returns an array of 0, 1, or 2 intervals that represents the result of the
  // interval difference operation.
  minus(that) {
    if (this.sourceString !== that.sourceString) {
      throw errors$5.intervalSourcesDontMatch();
    } else if (this.startIdx === that.startIdx && this.endIdx === that.endIdx) {
      return [];
    } else if (this.startIdx < that.startIdx && that.endIdx < this.endIdx) {
      return [
        new Interval$3(this.sourceString, this.startIdx, that.startIdx),
        new Interval$3(this.sourceString, that.endIdx, this.endIdx)
      ];
    } else if (this.startIdx < that.endIdx && that.endIdx < this.endIdx) {
      return [new Interval$3(this.sourceString, that.endIdx, this.endIdx)];
    } else if (this.startIdx < that.startIdx && that.startIdx < this.endIdx) {
      return [new Interval$3(this.sourceString, this.startIdx, that.startIdx)];
    } else {
      return [this];
    }
  },
  // Returns a new Interval that has the same extent as this one, but which is relative
  // to `that`, an Interval that fully covers this one.
  relativeTo(that) {
    if (this.sourceString !== that.sourceString) {
      throw errors$5.intervalSourcesDontMatch();
    }
    assert$2(
      this.startIdx >= that.startIdx && this.endIdx <= that.endIdx,
      "other interval does not cover this one"
    );
    return new Interval$3(
      this.sourceString,
      this.startIdx - that.startIdx,
      this.endIdx - that.startIdx
    );
  },
  // Returns a new Interval which contains the same contents as this one,
  // but with whitespace trimmed from both ends.
  trimmed() {
    const { contents } = this;
    const startIdx = this.startIdx + contents.match(/^\s*/)[0].length;
    const endIdx = this.endIdx - contents.match(/\s*$/)[0].length;
    return new Interval$3(this.sourceString, startIdx, endIdx);
  },
  subInterval(offset, len) {
    const newStartIdx = this.startIdx + offset;
    return new Interval$3(this.sourceString, newStartIdx, newStartIdx + len);
  }
};
Object.defineProperties(Interval$3.prototype, {
  contents: {
    get() {
      if (this._contents === void 0) {
        this._contents = this.sourceString.slice(this.startIdx, this.endIdx);
      }
      return this._contents;
    },
    enumerable: true
  },
  length: {
    get() {
      return this.endIdx - this.startIdx;
    },
    enumerable: true
  }
});
var Interval_1 = Interval$3;
const Interval$2 = Interval_1;
const common$f = common$l;
const BALLOT_X = "";
const CHECK_MARK = "";
const DOT_OPERATOR = "";
const RIGHTWARDS_DOUBLE_ARROW = "";
const SYMBOL_FOR_HORIZONTAL_TABULATION = "";
const SYMBOL_FOR_LINE_FEED = "";
const SYMBOL_FOR_CARRIAGE_RETURN = "";
const Flags = {
  succeeded: 1 << 0,
  isRootNode: 1 << 1,
  isImplicitSpaces: 1 << 2,
  isMemoized: 1 << 3,
  isHeadOfLeftRecursion: 1 << 4,
  terminatesLR: 1 << 5
};
function spaces(n) {
  return common$f.repeat(" ", n).join("");
}
function getInputExcerpt(input, pos, len) {
  const excerpt = asEscapedString(input.slice(pos, pos + len));
  if (excerpt.length < len) {
    return excerpt + common$f.repeat(" ", len - excerpt.length).join("");
  }
  return excerpt;
}
function asEscapedString(obj) {
  if (typeof obj === "string") {
    return obj.replace(/ /g, DOT_OPERATOR).replace(/\t/g, SYMBOL_FOR_HORIZONTAL_TABULATION).replace(/\n/g, SYMBOL_FOR_LINE_FEED).replace(/\r/g, SYMBOL_FOR_CARRIAGE_RETURN);
  }
  return String(obj);
}
function Trace$2(input, pos1, pos2, expr, succeeded, bindings, optChildren) {
  this.input = input;
  this.pos = this.pos1 = pos1;
  this.pos2 = pos2;
  this.source = new Interval$2(input, pos1, pos2);
  this.expr = expr;
  this.bindings = bindings;
  this.children = optChildren || [];
  this.terminatingLREntry = null;
  this._flags = succeeded ? Flags.succeeded : 0;
}
Trace$2.prototype.SKIP = {};
Object.defineProperty(Trace$2.prototype, "displayString", {
  get() {
    return this.expr.toDisplayString();
  }
});
Object.keys(Flags).forEach((name) => {
  const mask = Flags[name];
  Object.defineProperty(Trace$2.prototype, name, {
    get() {
      return (this._flags & mask) !== 0;
    },
    set(val) {
      if (val) {
        this._flags |= mask;
      } else {
        this._flags &= ~mask;
      }
    }
  });
});
Trace$2.prototype.clone = function() {
  return this.cloneWithExpr(this.expr);
};
Trace$2.prototype.cloneWithExpr = function(expr) {
  const ans = new Trace$2(
    this.input,
    this.pos,
    this.pos2,
    expr,
    this.succeeded,
    this.bindings,
    this.children
  );
  ans.isHeadOfLeftRecursion = this.isHeadOfLeftRecursion;
  ans.isImplicitSpaces = this.isImplicitSpaces;
  ans.isMemoized = this.isMemoized;
  ans.isRootNode = this.isRootNode;
  ans.terminatesLR = this.terminatesLR;
  ans.terminatingLREntry = this.terminatingLREntry;
  return ans;
};
Trace$2.prototype.recordLRTermination = function(ruleBodyTrace, value) {
  this.terminatingLREntry = new Trace$2(
    this.input,
    this.pos,
    this.pos2,
    this.expr,
    false,
    [value],
    [ruleBodyTrace]
  );
  this.terminatingLREntry.terminatesLR = true;
};
Trace$2.prototype.walk = function(visitorObjOrFn, optThisArg) {
  let visitor = visitorObjOrFn;
  if (typeof visitor === "function") {
    visitor = { enter: visitor };
  }
  function _walk(node, parent, depth) {
    let recurse = true;
    if (visitor.enter) {
      if (visitor.enter.call(optThisArg, node, parent, depth) === Trace$2.prototype.SKIP) {
        recurse = false;
      }
    }
    if (recurse) {
      node.children.forEach((child) => {
        _walk(child, node, depth + 1);
      });
      if (visitor.exit) {
        visitor.exit.call(optThisArg, node, parent, depth);
      }
    }
  }
  if (this.isRootNode) {
    this.children.forEach((c) => {
      _walk(c, null, 0);
    });
  } else {
    _walk(this, null, 0);
  }
};
Trace$2.prototype.toString = function() {
  const sb = new common$f.StringBuffer();
  this.walk((node, parent, depth) => {
    if (!node) {
      return this.SKIP;
    }
    const ctorName = node.expr.constructor.name;
    if (ctorName === "Alt") {
      return;
    }
    sb.append(getInputExcerpt(node.input, node.pos, 10) + spaces(depth * 2 + 1));
    sb.append((node.succeeded ? CHECK_MARK : BALLOT_X) + " " + node.displayString);
    if (node.isHeadOfLeftRecursion) {
      sb.append(" (LR)");
    }
    if (node.succeeded) {
      const contents = asEscapedString(node.source.contents);
      sb.append(" " + RIGHTWARDS_DOUBLE_ARROW + "  ");
      sb.append(typeof contents === "string" ? '"' + contents + '"' : contents);
    }
    sb.append("\n");
  });
  return sb.contents();
};
var Trace_1 = Trace$2;
const Trace$1 = Trace_1;
const common$e = common$l;
const errors$4 = errors$9;
const nodes$2 = nodes$1$1;
const pexprs$g = pexprsMain;
const { TerminalNode: TerminalNode$1 } = nodes$2;
const { NonterminalNode } = nodes$2;
const { IterationNode: IterationNode$1 } = nodes$2;
pexprs$g.PExpr.prototype.eval = common$e.abstract("eval");
pexprs$g.any.eval = function(state) {
  const { inputStream } = state;
  const origPos = inputStream.pos;
  const ch = inputStream.next();
  if (ch) {
    state.pushBinding(new TerminalNode$1(ch.length), origPos);
    return true;
  } else {
    state.processFailure(origPos, this);
    return false;
  }
};
pexprs$g.end.eval = function(state) {
  const { inputStream } = state;
  const origPos = inputStream.pos;
  if (inputStream.atEnd()) {
    state.pushBinding(new TerminalNode$1(0), origPos);
    return true;
  } else {
    state.processFailure(origPos, this);
    return false;
  }
};
pexprs$g.Terminal.prototype.eval = function(state) {
  const { inputStream } = state;
  const origPos = inputStream.pos;
  if (!inputStream.matchString(this.obj)) {
    state.processFailure(origPos, this);
    return false;
  } else {
    state.pushBinding(new TerminalNode$1(this.obj.length), origPos);
    return true;
  }
};
pexprs$g.Range.prototype.eval = function(state) {
  const { inputStream } = state;
  const origPos = inputStream.pos;
  const cp = this.matchCodePoint ? inputStream.nextCodePoint() : inputStream.nextCharCode();
  if (cp !== void 0 && this.from.codePointAt(0) <= cp && cp <= this.to.codePointAt(0)) {
    state.pushBinding(new TerminalNode$1(String.fromCodePoint(cp).length), origPos);
    return true;
  } else {
    state.processFailure(origPos, this);
    return false;
  }
};
pexprs$g.Param.prototype.eval = function(state) {
  return state.eval(state.currentApplication().args[this.index]);
};
pexprs$g.Lex.prototype.eval = function(state) {
  state.enterLexifiedContext();
  const ans = state.eval(this.expr);
  state.exitLexifiedContext();
  return ans;
};
pexprs$g.Alt.prototype.eval = function(state) {
  for (let idx = 0; idx < this.terms.length; idx++) {
    if (state.eval(this.terms[idx])) {
      return true;
    }
  }
  return false;
};
pexprs$g.Seq.prototype.eval = function(state) {
  for (let idx = 0; idx < this.factors.length; idx++) {
    const factor = this.factors[idx];
    if (!state.eval(factor)) {
      return false;
    }
  }
  return true;
};
pexprs$g.Iter.prototype.eval = function(state) {
  const { inputStream } = state;
  const origPos = inputStream.pos;
  const arity = this.getArity();
  const cols = [];
  const colOffsets = [];
  while (cols.length < arity) {
    cols.push([]);
    colOffsets.push([]);
  }
  let numMatches = 0;
  let prevPos = origPos;
  let idx;
  while (numMatches < this.maxNumMatches && state.eval(this.expr)) {
    if (inputStream.pos === prevPos) {
      throw errors$4.kleeneExprHasNullableOperand(this, state._applicationStack);
    }
    prevPos = inputStream.pos;
    numMatches++;
    const row = state._bindings.splice(state._bindings.length - arity, arity);
    const rowOffsets = state._bindingOffsets.splice(
      state._bindingOffsets.length - arity,
      arity
    );
    for (idx = 0; idx < row.length; idx++) {
      cols[idx].push(row[idx]);
      colOffsets[idx].push(rowOffsets[idx]);
    }
  }
  if (numMatches < this.minNumMatches) {
    return false;
  }
  let offset = state.posToOffset(origPos);
  let matchLength = 0;
  if (numMatches > 0) {
    const lastCol = cols[arity - 1];
    const lastColOffsets = colOffsets[arity - 1];
    const endOffset = lastColOffsets[lastColOffsets.length - 1] + lastCol[lastCol.length - 1].matchLength;
    offset = colOffsets[0][0];
    matchLength = endOffset - offset;
  }
  const isOptional = this instanceof pexprs$g.Opt;
  for (idx = 0; idx < cols.length; idx++) {
    state._bindings.push(
      new IterationNode$1(cols[idx], colOffsets[idx], matchLength, isOptional)
    );
    state._bindingOffsets.push(offset);
  }
  return true;
};
pexprs$g.Not.prototype.eval = function(state) {
  const { inputStream } = state;
  const origPos = inputStream.pos;
  state.pushFailuresInfo();
  const ans = state.eval(this.expr);
  state.popFailuresInfo();
  if (ans) {
    state.processFailure(origPos, this);
    return false;
  }
  inputStream.pos = origPos;
  return true;
};
pexprs$g.Lookahead.prototype.eval = function(state) {
  const { inputStream } = state;
  const origPos = inputStream.pos;
  if (state.eval(this.expr)) {
    inputStream.pos = origPos;
    return true;
  } else {
    return false;
  }
};
pexprs$g.Apply.prototype.eval = function(state) {
  const caller = state.currentApplication();
  const actuals = caller ? caller.args : [];
  const app = this.substituteParams(actuals);
  const posInfo = state.getCurrentPosInfo();
  if (posInfo.isActive(app)) {
    return app.handleCycle(state);
  }
  const memoKey = app.toMemoKey();
  const memoRec = posInfo.memo[memoKey];
  if (memoRec && posInfo.shouldUseMemoizedResult(memoRec)) {
    if (state.hasNecessaryInfo(memoRec)) {
      return state.useMemoizedResult(state.inputStream.pos, memoRec);
    }
    delete posInfo.memo[memoKey];
  }
  return app.reallyEval(state);
};
pexprs$g.Apply.prototype.handleCycle = function(state) {
  const posInfo = state.getCurrentPosInfo();
  const { currentLeftRecursion } = posInfo;
  const memoKey = this.toMemoKey();
  let memoRec = posInfo.memo[memoKey];
  if (currentLeftRecursion && currentLeftRecursion.headApplication.toMemoKey() === memoKey) {
    memoRec.updateInvolvedApplicationMemoKeys();
  } else if (!memoRec) {
    memoRec = posInfo.memoize(memoKey, {
      matchLength: 0,
      examinedLength: 0,
      value: false,
      rightmostFailureOffset: -1
    });
    posInfo.startLeftRecursion(this, memoRec);
  }
  return state.useMemoizedResult(state.inputStream.pos, memoRec);
};
pexprs$g.Apply.prototype.reallyEval = function(state) {
  const { inputStream } = state;
  const origPos = inputStream.pos;
  const origPosInfo = state.getCurrentPosInfo();
  const ruleInfo = state.grammar.rules[this.ruleName];
  const { body } = ruleInfo;
  const { description } = ruleInfo;
  state.enterApplication(origPosInfo, this);
  if (description) {
    state.pushFailuresInfo();
  }
  const origInputStreamExaminedLength = inputStream.examinedLength;
  inputStream.examinedLength = 0;
  let value = this.evalOnce(body, state);
  const currentLR = origPosInfo.currentLeftRecursion;
  const memoKey = this.toMemoKey();
  const isHeadOfLeftRecursion = currentLR && currentLR.headApplication.toMemoKey() === memoKey;
  let memoRec;
  if (isHeadOfLeftRecursion) {
    value = this.growSeedResult(body, state, origPos, currentLR, value);
    origPosInfo.endLeftRecursion();
    memoRec = currentLR;
    memoRec.examinedLength = inputStream.examinedLength - origPos;
    memoRec.rightmostFailureOffset = state._getRightmostFailureOffset();
    origPosInfo.memoize(memoKey, memoRec);
  } else if (!currentLR || !currentLR.isInvolved(memoKey)) {
    memoRec = origPosInfo.memoize(memoKey, {
      matchLength: inputStream.pos - origPos,
      examinedLength: inputStream.examinedLength - origPos,
      value,
      failuresAtRightmostPosition: state.cloneRecordedFailures(),
      rightmostFailureOffset: state._getRightmostFailureOffset()
    });
  }
  const succeeded = !!value;
  if (description) {
    state.popFailuresInfo();
    if (!succeeded) {
      state.processFailure(origPos, this);
    }
    if (memoRec) {
      memoRec.failuresAtRightmostPosition = state.cloneRecordedFailures();
    }
  }
  if (state.isTracing() && memoRec) {
    const entry = state.getTraceEntry(origPos, this, succeeded, succeeded ? [value] : []);
    if (isHeadOfLeftRecursion) {
      common$e.assert(entry.terminatingLREntry != null || !succeeded);
      entry.isHeadOfLeftRecursion = true;
    }
    memoRec.traceEntry = entry;
  }
  inputStream.examinedLength = Math.max(
    inputStream.examinedLength,
    origInputStreamExaminedLength
  );
  state.exitApplication(origPosInfo, value);
  return succeeded;
};
pexprs$g.Apply.prototype.evalOnce = function(expr, state) {
  const { inputStream } = state;
  const origPos = inputStream.pos;
  if (state.eval(expr)) {
    const arity = expr.getArity();
    const bindings = state._bindings.splice(state._bindings.length - arity, arity);
    const offsets = state._bindingOffsets.splice(state._bindingOffsets.length - arity, arity);
    const matchLength = inputStream.pos - origPos;
    return new NonterminalNode(this.ruleName, bindings, offsets, matchLength);
  } else {
    return false;
  }
};
pexprs$g.Apply.prototype.growSeedResult = function(body, state, origPos, lrMemoRec, newValue) {
  if (!newValue) {
    return false;
  }
  const { inputStream } = state;
  while (true) {
    lrMemoRec.matchLength = inputStream.pos - origPos;
    lrMemoRec.value = newValue;
    lrMemoRec.failuresAtRightmostPosition = state.cloneRecordedFailures();
    if (state.isTracing()) {
      const seedTrace = state.trace[state.trace.length - 1];
      lrMemoRec.traceEntry = new Trace$1(
        state.input,
        origPos,
        inputStream.pos,
        this,
        true,
        [newValue],
        [seedTrace.clone()]
      );
    }
    inputStream.pos = origPos;
    newValue = this.evalOnce(body, state);
    if (inputStream.pos - origPos <= lrMemoRec.matchLength) {
      break;
    }
    if (state.isTracing()) {
      state.trace.splice(-2, 1);
    }
  }
  if (state.isTracing()) {
    lrMemoRec.traceEntry.recordLRTermination(state.trace.pop(), newValue);
  }
  inputStream.pos = origPos + lrMemoRec.matchLength;
  return lrMemoRec.value;
};
pexprs$g.UnicodeChar.prototype.eval = function(state) {
  const { inputStream } = state;
  const origPos = inputStream.pos;
  const ch = inputStream.next();
  if (ch && this.pattern.test(ch)) {
    state.pushBinding(new TerminalNode$1(ch.length), origPos);
    return true;
  } else {
    state.processFailure(origPos, this);
    return false;
  }
};
const common$d = common$l;
const pexprs$f = pexprsMain;
pexprs$f.PExpr.prototype.getArity = common$d.abstract("getArity");
pexprs$f.any.getArity = pexprs$f.end.getArity = pexprs$f.Terminal.prototype.getArity = pexprs$f.Range.prototype.getArity = pexprs$f.Param.prototype.getArity = pexprs$f.Apply.prototype.getArity = pexprs$f.UnicodeChar.prototype.getArity = function() {
  return 1;
};
pexprs$f.Alt.prototype.getArity = function() {
  return this.terms.length === 0 ? 0 : this.terms[0].getArity();
};
pexprs$f.Seq.prototype.getArity = function() {
  let arity = 0;
  for (let idx = 0; idx < this.factors.length; idx++) {
    arity += this.factors[idx].getArity();
  }
  return arity;
};
pexprs$f.Iter.prototype.getArity = function() {
  return this.expr.getArity();
};
pexprs$f.Not.prototype.getArity = function() {
  return 0;
};
pexprs$f.Lookahead.prototype.getArity = pexprs$f.Lex.prototype.getArity = function() {
  return this.expr.getArity();
};
const common$c = common$l;
const pexprs$e = pexprsMain;
function getMetaInfo(expr, grammarInterval) {
  const metaInfo = {};
  if (expr.source && grammarInterval) {
    const adjusted = expr.source.relativeTo(grammarInterval);
    metaInfo.sourceInterval = [adjusted.startIdx, adjusted.endIdx];
  }
  return metaInfo;
}
pexprs$e.PExpr.prototype.outputRecipe = common$c.abstract("outputRecipe");
pexprs$e.any.outputRecipe = function(formals, grammarInterval) {
  return ["any", getMetaInfo(this, grammarInterval)];
};
pexprs$e.end.outputRecipe = function(formals, grammarInterval) {
  return ["end", getMetaInfo(this, grammarInterval)];
};
pexprs$e.Terminal.prototype.outputRecipe = function(formals, grammarInterval) {
  return ["terminal", getMetaInfo(this, grammarInterval), this.obj];
};
pexprs$e.Range.prototype.outputRecipe = function(formals, grammarInterval) {
  return ["range", getMetaInfo(this, grammarInterval), this.from, this.to];
};
pexprs$e.Param.prototype.outputRecipe = function(formals, grammarInterval) {
  return ["param", getMetaInfo(this, grammarInterval), this.index];
};
pexprs$e.Alt.prototype.outputRecipe = function(formals, grammarInterval) {
  return ["alt", getMetaInfo(this, grammarInterval)].concat(
    this.terms.map((term) => term.outputRecipe(formals, grammarInterval))
  );
};
pexprs$e.Extend.prototype.outputRecipe = function(formals, grammarInterval) {
  const extension = this.terms[0];
  return extension.outputRecipe(formals, grammarInterval);
};
pexprs$e.Splice.prototype.outputRecipe = function(formals, grammarInterval) {
  const beforeTerms = this.terms.slice(0, this.expansionPos);
  const afterTerms = this.terms.slice(this.expansionPos + 1);
  return [
    "splice",
    getMetaInfo(this, grammarInterval),
    beforeTerms.map((term) => term.outputRecipe(formals, grammarInterval)),
    afterTerms.map((term) => term.outputRecipe(formals, grammarInterval))
  ];
};
pexprs$e.Seq.prototype.outputRecipe = function(formals, grammarInterval) {
  return ["seq", getMetaInfo(this, grammarInterval)].concat(
    this.factors.map((factor) => factor.outputRecipe(formals, grammarInterval))
  );
};
pexprs$e.Star.prototype.outputRecipe = pexprs$e.Plus.prototype.outputRecipe = pexprs$e.Opt.prototype.outputRecipe = pexprs$e.Not.prototype.outputRecipe = pexprs$e.Lookahead.prototype.outputRecipe = pexprs$e.Lex.prototype.outputRecipe = function(formals, grammarInterval) {
  return [
    this.constructor.name.toLowerCase(),
    getMetaInfo(this, grammarInterval),
    this.expr.outputRecipe(formals, grammarInterval)
  ];
};
pexprs$e.Apply.prototype.outputRecipe = function(formals, grammarInterval) {
  return [
    "app",
    getMetaInfo(this, grammarInterval),
    this.ruleName,
    this.args.map((arg) => arg.outputRecipe(formals, grammarInterval))
  ];
};
pexprs$e.UnicodeChar.prototype.outputRecipe = function(formals, grammarInterval) {
  return ["unicodeChar", getMetaInfo(this, grammarInterval), this.category];
};
const common$b = common$l;
const pexprs$d = pexprsMain;
pexprs$d.PExpr.prototype.introduceParams = common$b.abstract("introduceParams");
pexprs$d.any.introduceParams = pexprs$d.end.introduceParams = pexprs$d.Terminal.prototype.introduceParams = pexprs$d.Range.prototype.introduceParams = pexprs$d.Param.prototype.introduceParams = pexprs$d.UnicodeChar.prototype.introduceParams = function(formals) {
  return this;
};
pexprs$d.Alt.prototype.introduceParams = function(formals) {
  this.terms.forEach((term, idx, terms) => {
    terms[idx] = term.introduceParams(formals);
  });
  return this;
};
pexprs$d.Seq.prototype.introduceParams = function(formals) {
  this.factors.forEach((factor, idx, factors) => {
    factors[idx] = factor.introduceParams(formals);
  });
  return this;
};
pexprs$d.Iter.prototype.introduceParams = pexprs$d.Not.prototype.introduceParams = pexprs$d.Lookahead.prototype.introduceParams = pexprs$d.Lex.prototype.introduceParams = function(formals) {
  this.expr = this.expr.introduceParams(formals);
  return this;
};
pexprs$d.Apply.prototype.introduceParams = function(formals) {
  const index = formals.indexOf(this.ruleName);
  if (index >= 0) {
    if (this.args.length > 0) {
      throw new Error("Parameterized rules cannot be passed as arguments to another rule.");
    }
    return new pexprs$d.Param(index).withSource(this.source);
  } else {
    this.args.forEach((arg, idx, args) => {
      args[idx] = arg.introduceParams(formals);
    });
    return this;
  }
};
const common$a = common$l;
const pexprs$c = pexprsMain;
pexprs$c.PExpr.prototype.isNullable = function(grammar2) {
  return this._isNullable(grammar2, /* @__PURE__ */ Object.create(null));
};
pexprs$c.PExpr.prototype._isNullable = common$a.abstract("_isNullable");
pexprs$c.any._isNullable = pexprs$c.Range.prototype._isNullable = pexprs$c.Param.prototype._isNullable = pexprs$c.Plus.prototype._isNullable = pexprs$c.UnicodeChar.prototype._isNullable = function(grammar2, memo) {
  return false;
};
pexprs$c.end._isNullable = function(grammar2, memo) {
  return true;
};
pexprs$c.Terminal.prototype._isNullable = function(grammar2, memo) {
  if (typeof this.obj === "string") {
    return this.obj === "";
  } else {
    return false;
  }
};
pexprs$c.Alt.prototype._isNullable = function(grammar2, memo) {
  return this.terms.length === 0 || this.terms.some((term) => term._isNullable(grammar2, memo));
};
pexprs$c.Seq.prototype._isNullable = function(grammar2, memo) {
  return this.factors.every((factor) => factor._isNullable(grammar2, memo));
};
pexprs$c.Star.prototype._isNullable = pexprs$c.Opt.prototype._isNullable = pexprs$c.Not.prototype._isNullable = pexprs$c.Lookahead.prototype._isNullable = function(grammar2, memo) {
  return true;
};
pexprs$c.Lex.prototype._isNullable = function(grammar2, memo) {
  return this.expr._isNullable(grammar2, memo);
};
pexprs$c.Apply.prototype._isNullable = function(grammar2, memo) {
  const key2 = this.toMemoKey();
  if (!Object.prototype.hasOwnProperty.call(memo, key2)) {
    const { body } = grammar2.rules[this.ruleName];
    const inlined = body.substituteParams(this.args);
    memo[key2] = false;
    memo[key2] = inlined._isNullable(grammar2, memo);
  }
  return memo[key2];
};
const common$9 = common$l;
const pexprs$b = pexprsMain;
pexprs$b.PExpr.prototype.substituteParams = common$9.abstract("substituteParams");
pexprs$b.any.substituteParams = pexprs$b.end.substituteParams = pexprs$b.Terminal.prototype.substituteParams = pexprs$b.Range.prototype.substituteParams = pexprs$b.UnicodeChar.prototype.substituteParams = function(actuals) {
  return this;
};
pexprs$b.Param.prototype.substituteParams = function(actuals) {
  return actuals[this.index];
};
pexprs$b.Alt.prototype.substituteParams = function(actuals) {
  return new pexprs$b.Alt(this.terms.map((term) => term.substituteParams(actuals)));
};
pexprs$b.Seq.prototype.substituteParams = function(actuals) {
  return new pexprs$b.Seq(this.factors.map((factor) => factor.substituteParams(actuals)));
};
pexprs$b.Iter.prototype.substituteParams = pexprs$b.Not.prototype.substituteParams = pexprs$b.Lookahead.prototype.substituteParams = pexprs$b.Lex.prototype.substituteParams = function(actuals) {
  return new this.constructor(this.expr.substituteParams(actuals));
};
pexprs$b.Apply.prototype.substituteParams = function(actuals) {
  if (this.args.length === 0) {
    return this;
  } else {
    const args = this.args.map((arg) => arg.substituteParams(actuals));
    return new pexprs$b.Apply(this.ruleName, args);
  }
};
const common$8 = common$l;
const pexprs$a = pexprsMain;
const { copyWithoutDuplicates } = common$8;
function isRestrictedJSIdentifier(str) {
  return /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(str);
}
function resolveDuplicatedNames(argumentNameList) {
  const count = /* @__PURE__ */ Object.create(null);
  argumentNameList.forEach((argName) => {
    count[argName] = (count[argName] || 0) + 1;
  });
  Object.keys(count).forEach((dupArgName) => {
    if (count[dupArgName] <= 1) {
      return;
    }
    let subscript = 1;
    argumentNameList.forEach((argName, idx) => {
      if (argName === dupArgName) {
        argumentNameList[idx] = argName + "_" + subscript++;
      }
    });
  });
}
pexprs$a.PExpr.prototype.toArgumentNameList = common$8.abstract("toArgumentNameList");
pexprs$a.any.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return ["any"];
};
pexprs$a.end.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return ["end"];
};
pexprs$a.Terminal.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  if (typeof this.obj === "string" && /^[_a-zA-Z0-9]+$/.test(this.obj)) {
    return ["_" + this.obj];
  } else {
    return ["$" + firstArgIndex];
  }
};
pexprs$a.Range.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  let argName = this.from + "_to_" + this.to;
  if (!isRestrictedJSIdentifier(argName)) {
    argName = "_" + argName;
  }
  if (!isRestrictedJSIdentifier(argName)) {
    argName = "$" + firstArgIndex;
  }
  return [argName];
};
pexprs$a.Alt.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  const termArgNameLists = this.terms.map(
    (term) => term.toArgumentNameList(firstArgIndex, true)
  );
  const argumentNameList = [];
  const numArgs = termArgNameLists[0].length;
  for (let colIdx = 0; colIdx < numArgs; colIdx++) {
    const col = [];
    for (let rowIdx = 0; rowIdx < this.terms.length; rowIdx++) {
      col.push(termArgNameLists[rowIdx][colIdx]);
    }
    const uniqueNames = copyWithoutDuplicates(col);
    argumentNameList.push(uniqueNames.join("_or_"));
  }
  if (!noDupCheck) {
    resolveDuplicatedNames(argumentNameList);
  }
  return argumentNameList;
};
pexprs$a.Seq.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  let argumentNameList = [];
  this.factors.forEach((factor) => {
    const factorArgumentNameList = factor.toArgumentNameList(firstArgIndex, true);
    argumentNameList = argumentNameList.concat(factorArgumentNameList);
    firstArgIndex += factorArgumentNameList.length;
  });
  if (!noDupCheck) {
    resolveDuplicatedNames(argumentNameList);
  }
  return argumentNameList;
};
pexprs$a.Iter.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  const argumentNameList = this.expr.toArgumentNameList(firstArgIndex, noDupCheck).map(
    (exprArgumentString) => exprArgumentString[exprArgumentString.length - 1] === "s" ? exprArgumentString + "es" : exprArgumentString + "s"
  );
  if (!noDupCheck) {
    resolveDuplicatedNames(argumentNameList);
  }
  return argumentNameList;
};
pexprs$a.Opt.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return this.expr.toArgumentNameList(firstArgIndex, noDupCheck).map((argName) => {
    return "opt" + argName[0].toUpperCase() + argName.slice(1);
  });
};
pexprs$a.Not.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return [];
};
pexprs$a.Lookahead.prototype.toArgumentNameList = pexprs$a.Lex.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return this.expr.toArgumentNameList(firstArgIndex, noDupCheck);
};
pexprs$a.Apply.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return [this.ruleName];
};
pexprs$a.UnicodeChar.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return ["$" + firstArgIndex];
};
pexprs$a.Param.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return ["param" + this.index];
};
const common$7 = common$l;
const pexprs$9 = pexprsMain;
pexprs$9.PExpr.prototype.toDisplayString = common$7.abstract("toDisplayString");
pexprs$9.Alt.prototype.toDisplayString = pexprs$9.Seq.prototype.toDisplayString = function() {
  if (this.source) {
    return this.source.trimmed().contents;
  }
  return "[" + this.constructor.name + "]";
};
pexprs$9.any.toDisplayString = pexprs$9.end.toDisplayString = pexprs$9.Iter.prototype.toDisplayString = pexprs$9.Not.prototype.toDisplayString = pexprs$9.Lookahead.prototype.toDisplayString = pexprs$9.Lex.prototype.toDisplayString = pexprs$9.Terminal.prototype.toDisplayString = pexprs$9.Range.prototype.toDisplayString = pexprs$9.Param.prototype.toDisplayString = function() {
  return this.toString();
};
pexprs$9.Apply.prototype.toDisplayString = function() {
  if (this.args.length > 0) {
    const ps = this.args.map((arg) => arg.toDisplayString());
    return this.ruleName + "<" + ps.join(",") + ">";
  } else {
    return this.ruleName;
  }
};
pexprs$9.UnicodeChar.prototype.toDisplayString = function() {
  return "Unicode [" + this.category + "] character";
};
const Failure$1 = Failure_1;
const common$6 = common$l;
const pexprs$8 = pexprsMain;
pexprs$8.PExpr.prototype.toFailure = common$6.abstract("toFailure");
pexprs$8.any.toFailure = function(grammar2) {
  return new Failure$1(this, "any object", "description");
};
pexprs$8.end.toFailure = function(grammar2) {
  return new Failure$1(this, "end of input", "description");
};
pexprs$8.Terminal.prototype.toFailure = function(grammar2) {
  return new Failure$1(this, this.obj, "string");
};
pexprs$8.Range.prototype.toFailure = function(grammar2) {
  return new Failure$1(this, JSON.stringify(this.from) + ".." + JSON.stringify(this.to), "code");
};
pexprs$8.Not.prototype.toFailure = function(grammar2) {
  const description = this.expr === pexprs$8.any ? "nothing" : "not " + this.expr.toFailure(grammar2);
  return new Failure$1(this, description, "description");
};
pexprs$8.Lookahead.prototype.toFailure = function(grammar2) {
  return this.expr.toFailure(grammar2);
};
pexprs$8.Apply.prototype.toFailure = function(grammar2) {
  let { description } = grammar2.rules[this.ruleName];
  if (!description) {
    const article = /^[aeiouAEIOU]/.test(this.ruleName) ? "an" : "a";
    description = article + " " + this.ruleName;
  }
  return new Failure$1(this, description, "description");
};
pexprs$8.UnicodeChar.prototype.toFailure = function(grammar2) {
  return new Failure$1(this, "a Unicode [" + this.category + "] character", "description");
};
pexprs$8.Alt.prototype.toFailure = function(grammar2) {
  const fs = this.terms.map((t) => t.toFailure(grammar2));
  const description = "(" + fs.join(" or ") + ")";
  return new Failure$1(this, description, "description");
};
pexprs$8.Seq.prototype.toFailure = function(grammar2) {
  const fs = this.factors.map((f2) => f2.toFailure(grammar2));
  const description = "(" + fs.join(" ") + ")";
  return new Failure$1(this, description, "description");
};
pexprs$8.Iter.prototype.toFailure = function(grammar2) {
  const description = "(" + this.expr.toFailure(grammar2) + this.operator + ")";
  return new Failure$1(this, description, "description");
};
const common$5 = common$l;
const pexprs$7 = pexprsMain;
pexprs$7.PExpr.prototype.toString = common$5.abstract("toString");
pexprs$7.any.toString = function() {
  return "any";
};
pexprs$7.end.toString = function() {
  return "end";
};
pexprs$7.Terminal.prototype.toString = function() {
  return JSON.stringify(this.obj);
};
pexprs$7.Range.prototype.toString = function() {
  return JSON.stringify(this.from) + ".." + JSON.stringify(this.to);
};
pexprs$7.Param.prototype.toString = function() {
  return "$" + this.index;
};
pexprs$7.Lex.prototype.toString = function() {
  return "#(" + this.expr.toString() + ")";
};
pexprs$7.Alt.prototype.toString = function() {
  return this.terms.length === 1 ? this.terms[0].toString() : "(" + this.terms.map((term) => term.toString()).join(" | ") + ")";
};
pexprs$7.Seq.prototype.toString = function() {
  return this.factors.length === 1 ? this.factors[0].toString() : "(" + this.factors.map((factor) => factor.toString()).join(" ") + ")";
};
pexprs$7.Iter.prototype.toString = function() {
  return this.expr + this.operator;
};
pexprs$7.Not.prototype.toString = function() {
  return "~" + this.expr;
};
pexprs$7.Lookahead.prototype.toString = function() {
  return "&" + this.expr;
};
pexprs$7.Apply.prototype.toString = function() {
  if (this.args.length > 0) {
    const ps = this.args.map((arg) => arg.toString());
    return this.ruleName + "<" + ps.join(",") + ">";
  } else {
    return this.ruleName;
  }
};
pexprs$7.UnicodeChar.prototype.toString = function() {
  return "\\p{" + this.category + "}";
};
var pexprs$6 = pexprsMain;
const Failure = Failure_1;
const { TerminalNode } = nodes$1$1;
const { assert: assert$1 } = common$l;
const { PExpr, Terminal } = pexprs$6;
class CaseInsensitiveTerminal$1 extends PExpr {
  constructor(param) {
    super();
    this.obj = param;
  }
  _getString(state) {
    const terminal = state.currentApplication().args[this.obj.index];
    assert$1(terminal instanceof Terminal, "expected a Terminal expression");
    return terminal.obj;
  }
  // Implementation of the PExpr API
  allowsSkippingPrecedingSpace() {
    return true;
  }
  eval(state) {
    const { inputStream } = state;
    const origPos = inputStream.pos;
    const matchStr = this._getString(state);
    if (!inputStream.matchString(matchStr, true)) {
      state.processFailure(origPos, this);
      return false;
    } else {
      state.pushBinding(new TerminalNode(matchStr.length), origPos);
      return true;
    }
  }
  getArity() {
    return 1;
  }
  substituteParams(actuals) {
    return new CaseInsensitiveTerminal$1(this.obj.substituteParams(actuals));
  }
  toDisplayString() {
    return this.obj.toDisplayString() + " (case-insensitive)";
  }
  toFailure(grammar2) {
    return new Failure(
      this,
      this.obj.toFailure(grammar2) + " (case-insensitive)",
      "description"
    );
  }
  _isNullable(grammar2, memo) {
    return this.obj._isNullable(grammar2, memo);
  }
}
var CaseInsensitiveTerminal_1 = CaseInsensitiveTerminal$1;
const Interval$1 = Interval_1;
function InputStream$3(source) {
  this.source = source;
  this.pos = 0;
  this.examinedLength = 0;
}
InputStream$3.prototype = {
  atEnd() {
    const ans = this.pos === this.source.length;
    this.examinedLength = Math.max(this.examinedLength, this.pos + 1);
    return ans;
  },
  next() {
    const ans = this.source[this.pos++];
    this.examinedLength = Math.max(this.examinedLength, this.pos);
    return ans;
  },
  nextCharCode() {
    const nextChar = this.next();
    return nextChar && nextChar.charCodeAt(0);
  },
  nextCodePoint() {
    const cp = this.source.slice(this.pos++).codePointAt(0);
    if (cp > 65535) {
      this.pos += 1;
    }
    this.examinedLength = Math.max(this.examinedLength, this.pos);
    return cp;
  },
  matchString(s2, optIgnoreCase) {
    let idx;
    if (optIgnoreCase) {
      for (idx = 0; idx < s2.length; idx++) {
        const actual = this.next();
        const expected = s2[idx];
        if (actual == null || actual.toUpperCase() !== expected.toUpperCase()) {
          return false;
        }
      }
      return true;
    }
    for (idx = 0; idx < s2.length; idx++) {
      if (this.next() !== s2[idx]) {
        return false;
      }
    }
    return true;
  },
  sourceSlice(startIdx, endIdx) {
    return this.source.slice(startIdx, endIdx);
  },
  interval(startIdx, optEndIdx) {
    return new Interval$1(this.source, startIdx, optEndIdx ? optEndIdx : this.pos);
  }
};
var InputStream_1 = InputStream$3;
const common$4 = common$l;
const util$4 = util$7;
const Interval = Interval_1;
function MatchResult$2(matcher, input, startExpr, cst, cstOffset, rightmostFailurePosition, optRecordedFailures) {
  this.matcher = matcher;
  this.input = input;
  this.startExpr = startExpr;
  this._cst = cst;
  this._cstOffset = cstOffset;
  this._rightmostFailurePosition = rightmostFailurePosition;
  this._rightmostFailures = optRecordedFailures;
  if (this.failed()) {
    common$4.defineLazyProperty(this, "message", function() {
      const detail = "Expected " + this.getExpectedText();
      return util$4.getLineAndColumnMessage(this.input, this.getRightmostFailurePosition()) + detail;
    });
    common$4.defineLazyProperty(this, "shortMessage", function() {
      const detail = "expected " + this.getExpectedText();
      const errorInfo = util$4.getLineAndColumn(this.input, this.getRightmostFailurePosition());
      return "Line " + errorInfo.lineNum + ", col " + errorInfo.colNum + ": " + detail;
    });
  }
}
MatchResult$2.prototype.succeeded = function() {
  return !!this._cst;
};
MatchResult$2.prototype.failed = function() {
  return !this.succeeded();
};
MatchResult$2.prototype.getRightmostFailurePosition = function() {
  return this._rightmostFailurePosition;
};
MatchResult$2.prototype.getRightmostFailures = function() {
  if (!this._rightmostFailures) {
    this.matcher.setInput(this.input);
    const matchResultWithFailures = this.matcher._match(
      this.startExpr,
      false,
      this.getRightmostFailurePosition()
    );
    this._rightmostFailures = matchResultWithFailures.getRightmostFailures();
  }
  return this._rightmostFailures;
};
MatchResult$2.prototype.toString = function() {
  return this.succeeded() ? "[match succeeded]" : "[match failed at position " + this.getRightmostFailurePosition() + "]";
};
MatchResult$2.prototype.getExpectedText = function() {
  if (this.succeeded()) {
    throw new Error("cannot get expected text of a successful MatchResult");
  }
  const sb = new common$4.StringBuffer();
  let failures = this.getRightmostFailures();
  failures = failures.filter((failure) => !failure.isFluffy());
  for (let idx = 0; idx < failures.length; idx++) {
    if (idx > 0) {
      if (idx === failures.length - 1) {
        sb.append(failures.length > 2 ? ", or " : " or ");
      } else {
        sb.append(", ");
      }
    }
    sb.append(failures[idx].toString());
  }
  return sb.contents();
};
MatchResult$2.prototype.getInterval = function() {
  const pos = this.getRightmostFailurePosition();
  return new Interval(this.input, pos, pos);
};
var MatchResult_1 = MatchResult$2;
function PosInfo$1() {
  this.applicationMemoKeyStack = [];
  this.memo = {};
  this.maxExaminedLength = 0;
  this.maxRightmostFailureOffset = -1;
  this.currentLeftRecursion = void 0;
}
PosInfo$1.prototype = {
  isActive(application) {
    return this.applicationMemoKeyStack.indexOf(application.toMemoKey()) >= 0;
  },
  enter(application) {
    this.applicationMemoKeyStack.push(application.toMemoKey());
  },
  exit() {
    this.applicationMemoKeyStack.pop();
  },
  startLeftRecursion(headApplication, memoRec) {
    memoRec.isLeftRecursion = true;
    memoRec.headApplication = headApplication;
    memoRec.nextLeftRecursion = this.currentLeftRecursion;
    this.currentLeftRecursion = memoRec;
    const { applicationMemoKeyStack } = this;
    const indexOfFirstInvolvedRule = applicationMemoKeyStack.indexOf(headApplication.toMemoKey()) + 1;
    const involvedApplicationMemoKeys = applicationMemoKeyStack.slice(
      indexOfFirstInvolvedRule
    );
    memoRec.isInvolved = function(applicationMemoKey) {
      return involvedApplicationMemoKeys.indexOf(applicationMemoKey) >= 0;
    };
    memoRec.updateInvolvedApplicationMemoKeys = function() {
      for (let idx = indexOfFirstInvolvedRule; idx < applicationMemoKeyStack.length; idx++) {
        const applicationMemoKey = applicationMemoKeyStack[idx];
        if (!this.isInvolved(applicationMemoKey)) {
          involvedApplicationMemoKeys.push(applicationMemoKey);
        }
      }
    };
  },
  endLeftRecursion() {
    this.currentLeftRecursion = this.currentLeftRecursion.nextLeftRecursion;
  },
  // Note: this method doesn't get called for the "head" of a left recursion -- for LR heads,
  // the memoized result (which starts out being a failure) is always used.
  shouldUseMemoizedResult(memoRec) {
    if (!memoRec.isLeftRecursion) {
      return true;
    }
    const { applicationMemoKeyStack } = this;
    for (let idx = 0; idx < applicationMemoKeyStack.length; idx++) {
      const applicationMemoKey = applicationMemoKeyStack[idx];
      if (memoRec.isInvolved(applicationMemoKey)) {
        return false;
      }
    }
    return true;
  },
  memoize(memoKey, memoRec) {
    this.memo[memoKey] = memoRec;
    this.maxExaminedLength = Math.max(this.maxExaminedLength, memoRec.examinedLength);
    this.maxRightmostFailureOffset = Math.max(
      this.maxRightmostFailureOffset,
      memoRec.rightmostFailureOffset
    );
    return memoRec;
  },
  clearObsoleteEntries(pos, invalidatedIdx) {
    if (pos + this.maxExaminedLength <= invalidatedIdx) {
      return;
    }
    const { memo } = this;
    this.maxExaminedLength = 0;
    this.maxRightmostFailureOffset = -1;
    Object.keys(memo).forEach((k2) => {
      const memoRec = memo[k2];
      if (pos + memoRec.examinedLength > invalidatedIdx) {
        delete memo[k2];
      } else {
        this.maxExaminedLength = Math.max(this.maxExaminedLength, memoRec.examinedLength);
        this.maxRightmostFailureOffset = Math.max(
          this.maxRightmostFailureOffset,
          memoRec.rightmostFailureOffset
        );
      }
    });
  }
};
var PosInfo_1 = PosInfo$1;
const InputStream$2 = InputStream_1;
const MatchResult$1 = MatchResult_1;
const PosInfo = PosInfo_1;
const Trace = Trace_1;
const pexprs$5 = pexprs$6;
const util$3 = util$7;
let builtInApplySyntacticBody;
util$3.awaitBuiltInRules((builtInRules2) => {
  builtInApplySyntacticBody = builtInRules2.rules.applySyntactic.body;
});
const applySpaces = new pexprs$5.Apply("spaces");
function MatchState$1(matcher, startExpr, optPositionToRecordFailures) {
  this.matcher = matcher;
  this.startExpr = startExpr;
  this.grammar = matcher.grammar;
  this.input = matcher.input;
  this.inputStream = new InputStream$2(matcher.input);
  this.memoTable = matcher.memoTable;
  this._bindings = [];
  this._bindingOffsets = [];
  this._applicationStack = [];
  this._posStack = [0];
  this.inLexifiedContextStack = [false];
  this.rightmostFailurePosition = -1;
  this._rightmostFailurePositionStack = [];
  this._recordedFailuresStack = [];
  if (optPositionToRecordFailures !== void 0) {
    this.positionToRecordFailures = optPositionToRecordFailures;
    this.recordedFailures = /* @__PURE__ */ Object.create(null);
  }
}
MatchState$1.prototype = {
  posToOffset(pos) {
    return pos - this._posStack[this._posStack.length - 1];
  },
  enterApplication(posInfo, app) {
    this._posStack.push(this.inputStream.pos);
    this._applicationStack.push(app);
    this.inLexifiedContextStack.push(false);
    posInfo.enter(app);
    this._rightmostFailurePositionStack.push(this.rightmostFailurePosition);
    this.rightmostFailurePosition = -1;
  },
  exitApplication(posInfo, optNode) {
    const origPos = this._posStack.pop();
    this._applicationStack.pop();
    this.inLexifiedContextStack.pop();
    posInfo.exit();
    this.rightmostFailurePosition = Math.max(
      this.rightmostFailurePosition,
      this._rightmostFailurePositionStack.pop()
    );
    if (optNode) {
      this.pushBinding(optNode, origPos);
    }
  },
  enterLexifiedContext() {
    this.inLexifiedContextStack.push(true);
  },
  exitLexifiedContext() {
    this.inLexifiedContextStack.pop();
  },
  currentApplication() {
    return this._applicationStack[this._applicationStack.length - 1];
  },
  inSyntacticContext() {
    const currentApplication = this.currentApplication();
    if (currentApplication) {
      return currentApplication.isSyntactic() && !this.inLexifiedContext();
    } else {
      return this.startExpr.factors[0].isSyntactic();
    }
  },
  inLexifiedContext() {
    return this.inLexifiedContextStack[this.inLexifiedContextStack.length - 1];
  },
  skipSpaces() {
    this.pushFailuresInfo();
    this.eval(applySpaces);
    this.popBinding();
    this.popFailuresInfo();
    return this.inputStream.pos;
  },
  skipSpacesIfInSyntacticContext() {
    return this.inSyntacticContext() ? this.skipSpaces() : this.inputStream.pos;
  },
  maybeSkipSpacesBefore(expr) {
    if (expr.allowsSkippingPrecedingSpace() && expr !== applySpaces) {
      return this.skipSpacesIfInSyntacticContext();
    } else {
      return this.inputStream.pos;
    }
  },
  pushBinding(node, origPos) {
    this._bindings.push(node);
    this._bindingOffsets.push(this.posToOffset(origPos));
  },
  popBinding() {
    this._bindings.pop();
    this._bindingOffsets.pop();
  },
  numBindings() {
    return this._bindings.length;
  },
  truncateBindings(newLength) {
    while (this._bindings.length > newLength) {
      this.popBinding();
    }
  },
  getCurrentPosInfo() {
    return this.getPosInfo(this.inputStream.pos);
  },
  getPosInfo(pos) {
    let posInfo = this.memoTable[pos];
    if (!posInfo) {
      posInfo = this.memoTable[pos] = new PosInfo();
    }
    return posInfo;
  },
  processFailure(pos, expr) {
    this.rightmostFailurePosition = Math.max(this.rightmostFailurePosition, pos);
    if (this.recordedFailures && pos === this.positionToRecordFailures) {
      const app = this.currentApplication();
      if (app) {
        expr = expr.substituteParams(app.args);
      }
      this.recordFailure(expr.toFailure(this.grammar), false);
    }
  },
  recordFailure(failure, shouldCloneIfNew) {
    const key2 = failure.toKey();
    if (!this.recordedFailures[key2]) {
      this.recordedFailures[key2] = shouldCloneIfNew ? failure.clone() : failure;
    } else if (this.recordedFailures[key2].isFluffy() && !failure.isFluffy()) {
      this.recordedFailures[key2].clearFluffy();
    }
  },
  recordFailures(failures, shouldCloneIfNew) {
    Object.keys(failures).forEach((key2) => {
      this.recordFailure(failures[key2], shouldCloneIfNew);
    });
  },
  cloneRecordedFailures() {
    if (!this.recordedFailures) {
      return void 0;
    }
    const ans = /* @__PURE__ */ Object.create(null);
    Object.keys(this.recordedFailures).forEach((key2) => {
      ans[key2] = this.recordedFailures[key2].clone();
    });
    return ans;
  },
  getRightmostFailurePosition() {
    return this.rightmostFailurePosition;
  },
  _getRightmostFailureOffset() {
    return this.rightmostFailurePosition >= 0 ? this.posToOffset(this.rightmostFailurePosition) : -1;
  },
  // Returns the memoized trace entry for `expr` at `pos`, if one exists, `null` otherwise.
  getMemoizedTraceEntry(pos, expr) {
    const posInfo = this.memoTable[pos];
    if (posInfo && expr instanceof pexprs$5.Apply) {
      const memoRec = posInfo.memo[expr.toMemoKey()];
      if (memoRec && memoRec.traceEntry) {
        const entry = memoRec.traceEntry.cloneWithExpr(expr);
        entry.isMemoized = true;
        return entry;
      }
    }
    return null;
  },
  // Returns a new trace entry, with the currently active trace array as its children.
  getTraceEntry(pos, expr, succeeded, bindings) {
    if (expr instanceof pexprs$5.Apply) {
      const app = this.currentApplication();
      const actuals = app ? app.args : [];
      expr = expr.substituteParams(actuals);
    }
    return this.getMemoizedTraceEntry(pos, expr) || new Trace(this.input, pos, this.inputStream.pos, expr, succeeded, bindings, this.trace);
  },
  isTracing() {
    return !!this.trace;
  },
  hasNecessaryInfo(memoRec) {
    if (this.trace && !memoRec.traceEntry) {
      return false;
    }
    if (this.recordedFailures && this.inputStream.pos + memoRec.rightmostFailureOffset === this.positionToRecordFailures) {
      return !!memoRec.failuresAtRightmostPosition;
    }
    return true;
  },
  useMemoizedResult(origPos, memoRec) {
    if (this.trace) {
      this.trace.push(memoRec.traceEntry);
    }
    const memoRecRightmostFailurePosition = this.inputStream.pos + memoRec.rightmostFailureOffset;
    this.rightmostFailurePosition = Math.max(
      this.rightmostFailurePosition,
      memoRecRightmostFailurePosition
    );
    if (this.recordedFailures && this.positionToRecordFailures === memoRecRightmostFailurePosition && memoRec.failuresAtRightmostPosition) {
      this.recordFailures(memoRec.failuresAtRightmostPosition, true);
    }
    this.inputStream.examinedLength = Math.max(
      this.inputStream.examinedLength,
      memoRec.examinedLength + origPos
    );
    if (memoRec.value) {
      this.inputStream.pos += memoRec.matchLength;
      this.pushBinding(memoRec.value, origPos);
      return true;
    }
    return false;
  },
  // Evaluate `expr` and return `true` if it succeeded, `false` otherwise. On success, `bindings`
  // will have `expr.getArity()` more elements than before, and the input stream's position may
  // have increased. On failure, `bindings` and position will be unchanged.
  eval(expr) {
    const { inputStream } = this;
    const origNumBindings = this._bindings.length;
    let origRecordedFailures;
    if (this.recordedFailures) {
      origRecordedFailures = this.recordedFailures;
      this.recordedFailures = /* @__PURE__ */ Object.create(null);
    }
    const origPos = inputStream.pos;
    const memoPos = this.maybeSkipSpacesBefore(expr);
    let origTrace;
    if (this.trace) {
      origTrace = this.trace;
      this.trace = [];
    }
    const ans = expr.eval(this);
    if (this.trace) {
      const bindings = this._bindings.slice(origNumBindings);
      const traceEntry = this.getTraceEntry(memoPos, expr, ans, bindings);
      traceEntry.isImplicitSpaces = expr === applySpaces;
      traceEntry.isRootNode = expr === this.startExpr;
      origTrace.push(traceEntry);
      this.trace = origTrace;
    }
    if (ans) {
      if (this.recordedFailures && inputStream.pos === this.positionToRecordFailures) {
        Object.keys(this.recordedFailures).forEach((key2) => {
          this.recordedFailures[key2].makeFluffy();
        });
      }
    } else {
      inputStream.pos = origPos;
      this.truncateBindings(origNumBindings);
    }
    if (this.recordedFailures) {
      this.recordFailures(origRecordedFailures, false);
    }
    if (expr === builtInApplySyntacticBody) {
      this.skipSpaces();
    }
    return ans;
  },
  getMatchResult() {
    this.eval(this.startExpr);
    let rightmostFailures;
    if (this.recordedFailures) {
      rightmostFailures = Object.keys(this.recordedFailures).map(
        (key2) => this.recordedFailures[key2]
      );
    }
    const cst = this._bindings[0];
    if (cst) {
      cst.grammar = this.grammar;
    }
    return new MatchResult$1(
      this.matcher,
      this.input,
      this.startExpr,
      cst,
      this._bindingOffsets[0],
      this.rightmostFailurePosition,
      rightmostFailures
    );
  },
  getTrace() {
    this.trace = [];
    const matchResult = this.getMatchResult();
    const rootTrace = this.trace[this.trace.length - 1];
    rootTrace.result = matchResult;
    return rootTrace;
  },
  pushFailuresInfo() {
    this._rightmostFailurePositionStack.push(this.rightmostFailurePosition);
    this._recordedFailuresStack.push(this.recordedFailures);
  },
  popFailuresInfo() {
    this.rightmostFailurePosition = this._rightmostFailurePositionStack.pop();
    this.recordedFailures = this._recordedFailuresStack.pop();
  }
};
var MatchState_1 = MatchState$1;
const MatchState = MatchState_1;
const pexprs$4 = pexprs$6;
function Matcher$1(grammar2) {
  this.grammar = grammar2;
  this.memoTable = [];
  this.input = "";
}
Matcher$1.prototype.getInput = function() {
  return this.input;
};
Matcher$1.prototype.setInput = function(str) {
  if (this.input !== str) {
    this.replaceInputRange(0, this.input.length, str);
  }
  return this;
};
Matcher$1.prototype.replaceInputRange = function(startIdx, endIdx, str) {
  const currentInput = this.input;
  if (startIdx < 0 || startIdx > currentInput.length || endIdx < 0 || endIdx > currentInput.length || startIdx > endIdx) {
    throw new Error("Invalid indices: " + startIdx + " and " + endIdx);
  }
  this.input = currentInput.slice(0, startIdx) + str + currentInput.slice(endIdx);
  const restOfMemoTable = this.memoTable.slice(endIdx);
  this.memoTable.length = startIdx;
  for (let idx = 0; idx < str.length; idx++) {
    this.memoTable.push(void 0);
  }
  restOfMemoTable.forEach(function(posInfo) {
    this.memoTable.push(posInfo);
  }, this);
  for (let pos = 0; pos < startIdx; pos++) {
    const posInfo = this.memoTable[pos];
    if (posInfo) {
      posInfo.clearObsoleteEntries(pos, startIdx);
    }
  }
  return this;
};
Matcher$1.prototype.match = function(optStartApplicationStr) {
  return this._match(this._getStartExpr(optStartApplicationStr), false);
};
Matcher$1.prototype.trace = function(optStartApplicationStr) {
  return this._match(this._getStartExpr(optStartApplicationStr), true);
};
Matcher$1.prototype._match = function(startExpr, tracing, optPositionToRecordFailures) {
  const state = new MatchState(this, startExpr, optPositionToRecordFailures);
  return tracing ? state.getTrace() : state.getMatchResult();
};
Matcher$1.prototype._getStartExpr = function(optStartApplicationStr) {
  const applicationStr = optStartApplicationStr || this.grammar.defaultStartRule;
  if (!applicationStr) {
    throw new Error("Missing start rule argument -- the grammar has no default start rule.");
  }
  const startApp = this.grammar.parseApplication(applicationStr);
  return new pexprs$4.Seq([startApp, pexprs$4.end]);
};
var Matcher_1 = Matcher$1;
const InputStream$1 = InputStream_1;
const { IterationNode } = nodes$1$1;
const MatchResult = MatchResult_1;
const common$3 = common$l;
const errors$3 = errors$9;
const util$2 = util$7;
const globalActionStack = [];
const hasOwnProperty = (x2, prop) => Object.prototype.hasOwnProperty.call(x2, prop);
class Wrapper {
  constructor(node, sourceInterval, baseInterval) {
    this._node = node;
    this.source = sourceInterval;
    this._baseInterval = baseInterval;
    if (node.isNonterminal()) {
      common$3.assert(sourceInterval === baseInterval);
    }
    this._childWrappers = [];
  }
  toString() {
    return "[semantics wrapper for " + this._node.grammar.name + "]";
  }
  _forgetMemoizedResultFor(attributeName) {
    delete this._node[this._semantics.attributeKeys[attributeName]];
    this.children.forEach((child) => {
      child._forgetMemoizedResultFor(attributeName);
    });
  }
  // Returns the wrapper of the specified child node. Child wrappers are created lazily and
  // cached in the parent wrapper's `_childWrappers` instance variable.
  child(idx) {
    if (!(0 <= idx && idx < this._node.numChildren())) {
      return void 0;
    }
    let childWrapper = this._childWrappers[idx];
    if (!childWrapper) {
      const childNode = this._node.childAt(idx);
      const offset = this._node.childOffsets[idx];
      const source = this._baseInterval.subInterval(offset, childNode.matchLength);
      const base2 = childNode.isNonterminal() ? source : this._baseInterval;
      childWrapper = this._childWrappers[idx] = this._semantics.wrap(childNode, source, base2);
    }
    return childWrapper;
  }
  // Returns an array containing the wrappers of all of the children of the node associated
  // with this wrapper.
  _children() {
    for (let idx = 0; idx < this._node.numChildren(); idx++) {
      this.child(idx);
    }
    return this._childWrappers;
  }
  // Returns `true` if the CST node associated with this wrapper corresponds to an iteration
  // expression, i.e., a Kleene-*, Kleene-+, or an optional. Returns `false` otherwise.
  isIteration() {
    return this._node.isIteration();
  }
  // Returns `true` if the CST node associated with this wrapper is a terminal node, `false`
  // otherwise.
  isTerminal() {
    return this._node.isTerminal();
  }
  // Returns `true` if the CST node associated with this wrapper is a nonterminal node, `false`
  // otherwise.
  isNonterminal() {
    return this._node.isNonterminal();
  }
  // Returns `true` if the CST node associated with this wrapper is a nonterminal node
  // corresponding to a syntactic rule, `false` otherwise.
  isSyntactic() {
    return this.isNonterminal() && this._node.isSyntactic();
  }
  // Returns `true` if the CST node associated with this wrapper is a nonterminal node
  // corresponding to a lexical rule, `false` otherwise.
  isLexical() {
    return this.isNonterminal() && this._node.isLexical();
  }
  // Returns `true` if the CST node associated with this wrapper is an iterator node
  // having either one or no child (? operator), `false` otherwise.
  // Otherwise, throws an exception.
  isOptional() {
    return this._node.isOptional();
  }
  // Create a new _iter wrapper in the same semantics as this wrapper.
  iteration(optChildWrappers) {
    const childWrappers = optChildWrappers || [];
    const childNodes = childWrappers.map((c) => c._node);
    const iter = new IterationNode(childNodes, [], -1, false);
    const wrapper = this._semantics.wrap(iter, null, null);
    wrapper._childWrappers = childWrappers;
    return wrapper;
  }
  // Returns an array containing the children of this CST node.
  get children() {
    return this._children();
  }
  // Returns the name of grammar rule that created this CST node.
  get ctorName() {
    return this._node.ctorName;
  }
  // TODO: Remove this eventually (deprecated in v0.12).
  get interval() {
    throw new Error("The `interval` property is deprecated -- use `source` instead");
  }
  // Returns the number of children of this CST node.
  get numChildren() {
    return this._node.numChildren();
  }
  // Returns the contents of the input stream consumed by this CST node.
  get sourceString() {
    return this.source.contents;
  }
}
function Semantics$2(grammar2, superSemantics) {
  const self2 = this;
  this.grammar = grammar2;
  this.checkedActionDicts = false;
  this.Wrapper = class extends (superSemantics ? superSemantics.Wrapper : Wrapper) {
    constructor(node, sourceInterval, baseInterval) {
      super(node, sourceInterval, baseInterval);
      self2.checkActionDictsIfHaventAlready();
      this._semantics = self2;
    }
  };
  this.super = superSemantics;
  if (superSemantics) {
    if (!(grammar2.equals(this.super.grammar) || grammar2._inheritsFrom(this.super.grammar))) {
      throw new Error(
        "Cannot extend a semantics for grammar '" + this.super.grammar.name + "' for use with grammar '" + grammar2.name + "' (not a sub-grammar)"
      );
    }
    this.operations = Object.create(this.super.operations);
    this.attributes = Object.create(this.super.attributes);
    this.attributeKeys = /* @__PURE__ */ Object.create(null);
    for (const attributeName in this.attributes) {
      Object.defineProperty(this.attributeKeys, attributeName, {
        value: util$2.uniqueId(attributeName)
      });
    }
  } else {
    this.operations = /* @__PURE__ */ Object.create(null);
    this.attributes = /* @__PURE__ */ Object.create(null);
    this.attributeKeys = /* @__PURE__ */ Object.create(null);
  }
}
Semantics$2.prototype.toString = function() {
  return "[semantics for " + this.grammar.name + "]";
};
Semantics$2.prototype.checkActionDictsIfHaventAlready = function() {
  if (!this.checkedActionDicts) {
    this.checkActionDicts();
    this.checkedActionDicts = true;
  }
};
Semantics$2.prototype.checkActionDicts = function() {
  let name;
  for (name in this.operations) {
    this.operations[name].checkActionDict(this.grammar);
  }
  for (name in this.attributes) {
    this.attributes[name].checkActionDict(this.grammar);
  }
};
Semantics$2.prototype.toRecipe = function(semanticsOnly) {
  function hasSuperSemantics(s2) {
    return s2.super !== Semantics$2.BuiltInSemantics._getSemantics();
  }
  let str = "(function(g) {\n";
  if (hasSuperSemantics(this)) {
    str += "  var semantics = " + this.super.toRecipe(true) + "(g";
    const superSemanticsGrammar = this.super.grammar;
    let relatedGrammar = this.grammar;
    while (relatedGrammar !== superSemanticsGrammar) {
      str += ".superGrammar";
      relatedGrammar = relatedGrammar.superGrammar;
    }
    str += ");\n";
    str += "  return g.extendSemantics(semantics)";
  } else {
    str += "  return g.createSemantics()";
  }
  ["Operation", "Attribute"].forEach((type) => {
    const semanticOperations = this[type.toLowerCase() + "s"];
    Object.keys(semanticOperations).forEach((name) => {
      const { actionDict, formals, builtInDefault } = semanticOperations[name];
      let signature = name;
      if (formals.length > 0) {
        signature += "(" + formals.join(", ") + ")";
      }
      let method;
      if (hasSuperSemantics(this) && this.super[type.toLowerCase() + "s"][name]) {
        method = "extend" + type;
      } else {
        method = "add" + type;
      }
      str += "\n    ." + method + "(" + JSON.stringify(signature) + ", {";
      const srcArray = [];
      Object.keys(actionDict).forEach((actionName) => {
        if (actionDict[actionName] !== builtInDefault) {
          let source = actionDict[actionName].toString().trim();
          source = source.replace(/^.*\(/, "function(");
          srcArray.push("\n      " + JSON.stringify(actionName) + ": " + source);
        }
      });
      str += srcArray.join(",") + "\n    })";
    });
  });
  str += ";\n  })";
  if (!semanticsOnly) {
    str = "(function() {\n  var grammar = this.fromRecipe(" + this.grammar.toRecipe() + ");\n  var semantics = " + str + "(grammar);\n  return semantics;\n});\n";
  }
  return str;
};
function parseSignature$1(signature, type) {
  if (!Semantics$2.prototypeGrammar) {
    common$3.assert(signature.indexOf("(") === -1);
    return {
      name: signature,
      formals: []
    };
  }
  const r = Semantics$2.prototypeGrammar.match(
    signature,
    type === "operation" ? "OperationSignature" : "AttributeSignature"
  );
  if (r.failed()) {
    throw new Error(r.message);
  }
  return Semantics$2.prototypeGrammarSemantics(r).parse();
}
function newDefaultAction(type, name, doIt) {
  return function(...children) {
    const thisThing = this._semantics.operations[name] || this._semantics.attributes[name];
    const args = thisThing.formals.map((formal) => this.args[formal]);
    if (!this.isIteration() && children.length === 1) {
      return doIt.apply(children[0], args);
    } else {
      throw errors$3.missingSemanticAction(this.ctorName, name, type, globalActionStack);
    }
  };
}
Semantics$2.prototype.addOperationOrAttribute = function(type, signature, actionDict) {
  const typePlural = type + "s";
  const parsedNameAndFormalArgs = parseSignature$1(signature, type);
  const { name } = parsedNameAndFormalArgs;
  const { formals } = parsedNameAndFormalArgs;
  this.assertNewName(name, type);
  const builtInDefault = newDefaultAction(type, name, doIt);
  const realActionDict = { _default: builtInDefault };
  Object.keys(actionDict).forEach((name2) => {
    realActionDict[name2] = actionDict[name2];
  });
  const entry = type === "operation" ? new Operation(name, formals, realActionDict, builtInDefault) : new Attribute(name, realActionDict, builtInDefault);
  entry.checkActionDict(this.grammar);
  this[typePlural][name] = entry;
  function doIt(...args) {
    const thisThing = this._semantics[typePlural][name];
    if (arguments.length !== thisThing.formals.length) {
      throw new Error(
        "Invalid number of arguments passed to " + name + " " + type + " (expected " + thisThing.formals.length + ", got " + arguments.length + ")"
      );
    }
    const argsObj = /* @__PURE__ */ Object.create(null);
    for (const [idx, val] of Object.entries(args)) {
      const formal = thisThing.formals[idx];
      argsObj[formal] = val;
    }
    const oldArgs = this.args;
    this.args = argsObj;
    const ans = thisThing.execute(this._semantics, this);
    this.args = oldArgs;
    return ans;
  }
  if (type === "operation") {
    this.Wrapper.prototype[name] = doIt;
    this.Wrapper.prototype[name].toString = function() {
      return "[" + name + " operation]";
    };
  } else {
    Object.defineProperty(this.Wrapper.prototype, name, {
      get: doIt,
      configurable: true
      // So the property can be deleted.
    });
    Object.defineProperty(this.attributeKeys, name, {
      value: util$2.uniqueId(name)
    });
  }
};
Semantics$2.prototype.extendOperationOrAttribute = function(type, name, actionDict) {
  const typePlural = type + "s";
  parseSignature$1(name, "attribute");
  if (!(this.super && name in this.super[typePlural])) {
    throw new Error(
      "Cannot extend " + type + " '" + name + "': did not inherit an " + type + " with that name"
    );
  }
  if (hasOwnProperty(this[typePlural], name)) {
    throw new Error("Cannot extend " + type + " '" + name + "' again");
  }
  const inheritedFormals = this[typePlural][name].formals;
  const inheritedActionDict = this[typePlural][name].actionDict;
  const newActionDict = Object.create(inheritedActionDict);
  Object.keys(actionDict).forEach((name2) => {
    newActionDict[name2] = actionDict[name2];
  });
  this[typePlural][name] = type === "operation" ? new Operation(name, inheritedFormals, newActionDict) : new Attribute(name, newActionDict);
  this[typePlural][name].checkActionDict(this.grammar);
};
Semantics$2.prototype.assertNewName = function(name, type) {
  if (hasOwnProperty(Wrapper.prototype, name)) {
    throw new Error("Cannot add " + type + " '" + name + "': that's a reserved name");
  }
  if (name in this.operations) {
    throw new Error(
      "Cannot add " + type + " '" + name + "': an operation with that name already exists"
    );
  }
  if (name in this.attributes) {
    throw new Error(
      "Cannot add " + type + " '" + name + "': an attribute with that name already exists"
    );
  }
};
Semantics$2.prototype.wrap = function(node, source, optBaseInterval) {
  const baseInterval = optBaseInterval || source;
  return node instanceof this.Wrapper ? node : new this.Wrapper(node, source, baseInterval);
};
Semantics$2.createSemantics = function(grammar2, optSuperSemantics) {
  const s2 = new Semantics$2(
    grammar2,
    optSuperSemantics !== void 0 ? optSuperSemantics : Semantics$2.BuiltInSemantics._getSemantics()
  );
  const proxy = function ASemantics(matchResult) {
    if (!(matchResult instanceof MatchResult)) {
      throw new TypeError(
        "Semantics expected a MatchResult, but got " + common$3.unexpectedObjToString(matchResult)
      );
    }
    if (matchResult.failed()) {
      throw new TypeError("cannot apply Semantics to " + matchResult.toString());
    }
    const cst = matchResult._cst;
    if (cst.grammar !== grammar2) {
      throw new Error(
        "Cannot use a MatchResult from grammar '" + cst.grammar.name + "' with a semantics for '" + grammar2.name + "'"
      );
    }
    const inputStream = new InputStream$1(matchResult.input);
    return s2.wrap(cst, inputStream.interval(matchResult._cstOffset, matchResult.input.length));
  };
  proxy.addOperation = function(signature, actionDict) {
    s2.addOperationOrAttribute("operation", signature, actionDict);
    return proxy;
  };
  proxy.extendOperation = function(name, actionDict) {
    s2.extendOperationOrAttribute("operation", name, actionDict);
    return proxy;
  };
  proxy.addAttribute = function(name, actionDict) {
    s2.addOperationOrAttribute("attribute", name, actionDict);
    return proxy;
  };
  proxy.extendAttribute = function(name, actionDict) {
    s2.extendOperationOrAttribute("attribute", name, actionDict);
    return proxy;
  };
  proxy._getActionDict = function(operationOrAttributeName) {
    const action = s2.operations[operationOrAttributeName] || s2.attributes[operationOrAttributeName];
    if (!action) {
      throw new Error(
        '"' + operationOrAttributeName + '" is not a valid operation or attribute name in this semantics for "' + grammar2.name + '"'
      );
    }
    return action.actionDict;
  };
  proxy._remove = function(operationOrAttributeName) {
    let semantic;
    if (operationOrAttributeName in s2.operations) {
      semantic = s2.operations[operationOrAttributeName];
      delete s2.operations[operationOrAttributeName];
    } else if (operationOrAttributeName in s2.attributes) {
      semantic = s2.attributes[operationOrAttributeName];
      delete s2.attributes[operationOrAttributeName];
    }
    delete s2.Wrapper.prototype[operationOrAttributeName];
    return semantic;
  };
  proxy.getOperationNames = function() {
    return Object.keys(s2.operations);
  };
  proxy.getAttributeNames = function() {
    return Object.keys(s2.attributes);
  };
  proxy.getGrammar = function() {
    return s2.grammar;
  };
  proxy.toRecipe = function(semanticsOnly) {
    return s2.toRecipe(semanticsOnly);
  };
  proxy.toString = s2.toString.bind(s2);
  proxy._getSemantics = function() {
    return s2;
  };
  return proxy;
};
class Operation {
  constructor(name, formals, actionDict, builtInDefault) {
    this.name = name;
    this.formals = formals;
    this.actionDict = actionDict;
    this.builtInDefault = builtInDefault;
  }
  checkActionDict(grammar2) {
    grammar2._checkTopDownActionDict(this.typeName, this.name, this.actionDict);
  }
  // Execute this operation on the CST node associated with `nodeWrapper` in the context of the
  // given Semantics instance.
  execute(semantics, nodeWrapper) {
    try {
      const { ctorName } = nodeWrapper._node;
      let actionFn = this.actionDict[ctorName];
      if (actionFn) {
        globalActionStack.push([this, ctorName]);
        return actionFn.apply(nodeWrapper, nodeWrapper._children());
      }
      if (nodeWrapper.isNonterminal()) {
        actionFn = this.actionDict._nonterminal;
        if (actionFn) {
          globalActionStack.push([this, "_nonterminal", ctorName]);
          return actionFn.apply(nodeWrapper, nodeWrapper._children());
        }
      }
      globalActionStack.push([this, "default action", ctorName]);
      return this.actionDict._default.apply(nodeWrapper, nodeWrapper._children());
    } finally {
      globalActionStack.pop();
    }
  }
}
Operation.prototype.typeName = "operation";
class Attribute extends Operation {
  constructor(name, actionDict, builtInDefault) {
    super(name, [], actionDict, builtInDefault);
  }
  execute(semantics, nodeWrapper) {
    const node = nodeWrapper._node;
    const key2 = semantics.attributeKeys[this.name];
    if (!hasOwnProperty(node, key2)) {
      node[key2] = Operation.prototype.execute.call(this, semantics, nodeWrapper);
    }
    return node[key2];
  }
}
Attribute.prototype.typeName = "attribute";
var Semantics_1 = Semantics$2;
const CaseInsensitiveTerminal = CaseInsensitiveTerminal_1;
const Matcher = Matcher_1;
const Semantics$1 = Semantics_1;
const common$2 = common$l;
const errors$2 = errors$9;
const pexprs$3 = pexprs$6;
const SPECIAL_ACTION_NAMES = ["_iter", "_terminal", "_nonterminal", "_default"];
function getSortedRuleValues(grammar2) {
  return Object.keys(grammar2.rules).sort().map((name) => grammar2.rules[name]);
}
const jsonToJS = (str) => str.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
function Grammar$4(name, superGrammar, rules, optDefaultStartRule) {
  this.name = name;
  this.superGrammar = superGrammar;
  this.rules = rules;
  if (optDefaultStartRule) {
    if (!(optDefaultStartRule in rules)) {
      throw new Error(
        "Invalid start rule: '" + optDefaultStartRule + "' is not a rule in grammar '" + name + "'"
      );
    }
    this.defaultStartRule = optDefaultStartRule;
  }
}
let ohmGrammar$2;
let buildGrammar$1;
Grammar$4.initApplicationParser = function(grammar2, builderFn) {
  ohmGrammar$2 = grammar2;
  buildGrammar$1 = builderFn;
};
Grammar$4.prototype = {
  matcher() {
    return new Matcher(this);
  },
  // Return true if the grammar is a built-in grammar, otherwise false.
  // NOTE: This might give an unexpected result if called before BuiltInRules is defined!
  isBuiltIn() {
    return this === Grammar$4.ProtoBuiltInRules || this === Grammar$4.BuiltInRules;
  },
  equals(g2) {
    if (this === g2) {
      return true;
    }
    if (g2 == null || this.name !== g2.name || this.defaultStartRule !== g2.defaultStartRule || !(this.superGrammar === g2.superGrammar || this.superGrammar.equals(g2.superGrammar))) {
      return false;
    }
    const myRules = getSortedRuleValues(this);
    const otherRules = getSortedRuleValues(g2);
    return myRules.length === otherRules.length && myRules.every((rule, i) => {
      return rule.description === otherRules[i].description && rule.formals.join(",") === otherRules[i].formals.join(",") && rule.body.toString() === otherRules[i].body.toString();
    });
  },
  match(input, optStartApplication) {
    const m2 = this.matcher();
    m2.replaceInputRange(0, 0, input);
    return m2.match(optStartApplication);
  },
  trace(input, optStartApplication) {
    const m2 = this.matcher();
    m2.replaceInputRange(0, 0, input);
    return m2.trace(optStartApplication);
  },
  createSemantics() {
    return Semantics$1.createSemantics(this);
  },
  extendSemantics(superSemantics) {
    return Semantics$1.createSemantics(this, superSemantics._getSemantics());
  },
  // Check that every key in `actionDict` corresponds to a semantic action, and that it maps to
  // a function of the correct arity. If not, throw an exception.
  _checkTopDownActionDict(what, name, actionDict) {
    const problems = [];
    for (const k2 in actionDict) {
      const v2 = actionDict[k2];
      const isSpecialAction = SPECIAL_ACTION_NAMES.includes(k2);
      if (!isSpecialAction && !(k2 in this.rules)) {
        problems.push(`'${k2}' is not a valid semantic action for '${this.name}'`);
        continue;
      }
      if (typeof v2 !== "function") {
        problems.push(`'${k2}' must be a function in an action dictionary for '${this.name}'`);
        continue;
      }
      const actual = v2.length;
      const expected = this._topDownActionArity(k2);
      if (actual !== expected) {
        let details;
        if (k2 === "_iter" || k2 === "_nonterminal") {
          details = `it should use a rest parameter, e.g. \`${k2}(...children) {}\`. NOTE: this is new in Ohm v16  see https://ohmjs.org/d/ati for details.`;
        } else {
          details = `expected ${expected}, got ${actual}`;
        }
        problems.push(`Semantic action '${k2}' has the wrong arity: ${details}`);
      }
    }
    if (problems.length > 0) {
      const prettyProblems = problems.map((problem) => "- " + problem);
      const error2 = new Error(
        [
          `Found errors in the action dictionary of the '${name}' ${what}:`,
          ...prettyProblems
        ].join("\n")
      );
      error2.problems = problems;
      throw error2;
    }
  },
  // Return the expected arity for a semantic action named `actionName`, which
  // is either a rule name or a special action name like '_nonterminal'.
  _topDownActionArity(actionName) {
    return SPECIAL_ACTION_NAMES.includes(actionName) ? 0 : this.rules[actionName].body.getArity();
  },
  _inheritsFrom(grammar2) {
    let g2 = this.superGrammar;
    while (g2) {
      if (g2.equals(grammar2, true)) {
        return true;
      }
      g2 = g2.superGrammar;
    }
    return false;
  },
  toRecipe(superGrammarExpr = void 0) {
    const metaInfo = {};
    if (this.source) {
      metaInfo.source = this.source.contents;
    }
    let startRule = null;
    if (this.defaultStartRule) {
      startRule = this.defaultStartRule;
    }
    const rules = {};
    Object.keys(this.rules).forEach((ruleName) => {
      const ruleInfo = this.rules[ruleName];
      const { body } = ruleInfo;
      const isDefinition = !this.superGrammar || !this.superGrammar.rules[ruleName];
      let operation;
      if (isDefinition) {
        operation = "define";
      } else {
        operation = body instanceof pexprs$3.Extend ? "extend" : "override";
      }
      const metaInfo2 = {};
      if (ruleInfo.source && this.source) {
        const adjusted = ruleInfo.source.relativeTo(this.source);
        metaInfo2.sourceInterval = [adjusted.startIdx, adjusted.endIdx];
      }
      const description = isDefinition ? ruleInfo.description : null;
      const bodyRecipe = body.outputRecipe(ruleInfo.formals, this.source);
      rules[ruleName] = [
        operation,
        // "define"/"extend"/"override"
        metaInfo2,
        description,
        ruleInfo.formals,
        bodyRecipe
      ];
    });
    let superGrammarOutput = "null";
    if (superGrammarExpr) {
      superGrammarOutput = superGrammarExpr;
    } else if (this.superGrammar && !this.superGrammar.isBuiltIn()) {
      superGrammarOutput = this.superGrammar.toRecipe();
    }
    const recipeElements = [
      ...["grammar", metaInfo, this.name].map(JSON.stringify),
      superGrammarOutput,
      ...[startRule, rules].map(JSON.stringify)
    ];
    return jsonToJS(`[${recipeElements.join(",")}]`);
  },
  // TODO: Come up with better names for these methods.
  // TODO: Write the analog of these methods for inherited attributes.
  toOperationActionDictionaryTemplate() {
    return this._toOperationOrAttributeActionDictionaryTemplate();
  },
  toAttributeActionDictionaryTemplate() {
    return this._toOperationOrAttributeActionDictionaryTemplate();
  },
  _toOperationOrAttributeActionDictionaryTemplate() {
    const sb = new common$2.StringBuffer();
    sb.append("{");
    let first = true;
    for (const ruleName in this.rules) {
      const { body } = this.rules[ruleName];
      if (first) {
        first = false;
      } else {
        sb.append(",");
      }
      sb.append("\n");
      sb.append("  ");
      this.addSemanticActionTemplate(ruleName, body, sb);
    }
    sb.append("\n}");
    return sb.contents();
  },
  addSemanticActionTemplate(ruleName, body, sb) {
    sb.append(ruleName);
    sb.append(": function(");
    const arity = this._topDownActionArity(ruleName);
    sb.append(common$2.repeat("_", arity).join(", "));
    sb.append(") {\n");
    sb.append("  }");
  },
  // Parse a string which expresses a rule application in this grammar, and return the
  // resulting Apply node.
  parseApplication(str) {
    let app;
    if (str.indexOf("<") === -1) {
      app = new pexprs$3.Apply(str);
    } else {
      const cst = ohmGrammar$2.match(str, "Base_application");
      app = buildGrammar$1(cst, {});
    }
    if (!(app.ruleName in this.rules)) {
      throw errors$2.undeclaredRule(app.ruleName, this.name);
    }
    const { formals } = this.rules[app.ruleName];
    if (formals.length !== app.args.length) {
      const { source } = this.rules[app.ruleName];
      throw errors$2.wrongNumberOfParameters(
        app.ruleName,
        formals.length,
        app.args.length,
        source
      );
    }
    return app;
  }
};
Grammar$4.ProtoBuiltInRules = new Grammar$4(
  "ProtoBuiltInRules",
  // name
  void 0,
  // supergrammar
  {
    any: {
      body: pexprs$3.any,
      formals: [],
      description: "any character",
      primitive: true
    },
    end: {
      body: pexprs$3.end,
      formals: [],
      description: "end of input",
      primitive: true
    },
    caseInsensitive: {
      body: new CaseInsensitiveTerminal(new pexprs$3.Param(0)),
      formals: ["str"],
      primitive: true
    },
    lower: {
      body: new pexprs$3.UnicodeChar("Ll"),
      formals: [],
      description: "a lowercase letter",
      primitive: true
    },
    upper: {
      body: new pexprs$3.UnicodeChar("Lu"),
      formals: [],
      description: "an uppercase letter",
      primitive: true
    },
    // Union of Lt (titlecase), Lm (modifier), and Lo (other), i.e. any letter not in Ll or Lu.
    unicodeLtmo: {
      body: new pexprs$3.UnicodeChar("Ltmo"),
      formals: [],
      description: "a Unicode character in Lt, Lm, or Lo",
      primitive: true
    },
    // These rules are not truly primitive (they could be written in userland) but are defined
    // here for bootstrapping purposes.
    spaces: {
      body: new pexprs$3.Star(new pexprs$3.Apply("space")),
      formals: []
    },
    space: {
      body: new pexprs$3.Range("\0", " "),
      formals: [],
      description: "a space"
    }
  }
);
var Grammar_1 = Grammar$4;
const Grammar$3 = Grammar_1;
const InputStream = InputStream_1;
const common$1$1 = common$l;
const errors$1 = errors$9;
const pexprs$2 = pexprs$6;
function GrammarDecl$1(name) {
  this.name = name;
}
GrammarDecl$1.prototype.sourceInterval = function(startIdx, endIdx) {
  return this.source.subInterval(startIdx, endIdx - startIdx);
};
GrammarDecl$1.prototype.ensureSuperGrammar = function() {
  if (!this.superGrammar) {
    this.withSuperGrammar(
      // TODO: The conditional expression below is an ugly hack. It's kind of ok because
      // I doubt anyone will ever try to declare a grammar called `BuiltInRules`. Still,
      // we should try to find a better way to do this.
      this.name === "BuiltInRules" ? Grammar$3.ProtoBuiltInRules : Grammar$3.BuiltInRules
    );
  }
  return this.superGrammar;
};
GrammarDecl$1.prototype.ensureSuperGrammarRuleForOverriding = function(name, source) {
  const ruleInfo = this.ensureSuperGrammar().rules[name];
  if (!ruleInfo) {
    throw errors$1.cannotOverrideUndeclaredRule(name, this.superGrammar.name, source);
  }
  return ruleInfo;
};
GrammarDecl$1.prototype.installOverriddenOrExtendedRule = function(name, formals, body, source) {
  const duplicateParameterNames2 = common$1$1.getDuplicates(formals);
  if (duplicateParameterNames2.length > 0) {
    throw errors$1.duplicateParameterNames(name, duplicateParameterNames2, source);
  }
  const ruleInfo = this.ensureSuperGrammar().rules[name];
  const expectedFormals = ruleInfo.formals;
  const expectedNumFormals = expectedFormals ? expectedFormals.length : 0;
  if (formals.length !== expectedNumFormals) {
    throw errors$1.wrongNumberOfParameters(name, expectedNumFormals, formals.length, source);
  }
  return this.install(name, formals, body, ruleInfo.description, source);
};
GrammarDecl$1.prototype.install = function(name, formals, body, description, source) {
  this.rules[name] = {
    body: body.introduceParams(formals),
    formals,
    description,
    source
  };
  return this;
};
GrammarDecl$1.prototype.withSuperGrammar = function(superGrammar) {
  if (this.superGrammar) {
    throw new Error("the super grammar of a GrammarDecl cannot be set more than once");
  }
  this.superGrammar = superGrammar;
  this.rules = Object.create(superGrammar.rules);
  if (!superGrammar.isBuiltIn()) {
    this.defaultStartRule = superGrammar.defaultStartRule;
  }
  return this;
};
GrammarDecl$1.prototype.withDefaultStartRule = function(ruleName) {
  this.defaultStartRule = ruleName;
  return this;
};
GrammarDecl$1.prototype.withSource = function(source) {
  this.source = new InputStream(source).interval(0, source.length);
  return this;
};
GrammarDecl$1.prototype.build = function() {
  const grammar2 = new Grammar$3(
    this.name,
    this.ensureSuperGrammar(),
    this.rules,
    this.defaultStartRule
  );
  const grammarErrors = [];
  let grammarHasInvalidApplications = false;
  Object.keys(grammar2.rules).forEach((ruleName) => {
    const { body } = grammar2.rules[ruleName];
    try {
      body.assertChoicesHaveUniformArity(ruleName);
    } catch (e) {
      grammarErrors.push(e);
    }
    try {
      body.assertAllApplicationsAreValid(ruleName, grammar2);
    } catch (e) {
      grammarErrors.push(e);
      grammarHasInvalidApplications = true;
    }
  });
  if (!grammarHasInvalidApplications) {
    Object.keys(grammar2.rules).forEach((ruleName) => {
      const { body } = grammar2.rules[ruleName];
      try {
        body.assertIteratedExprsAreNotNullable(grammar2, []);
      } catch (e) {
        grammarErrors.push(e);
      }
    });
  }
  if (grammarErrors.length > 0) {
    errors$1.throwErrors(grammarErrors);
  }
  if (this.source) {
    grammar2.source = this.source;
  }
  return grammar2;
};
GrammarDecl$1.prototype.define = function(name, formals, body, description, source) {
  this.ensureSuperGrammar();
  if (this.superGrammar.rules[name]) {
    throw errors$1.duplicateRuleDeclaration(name, this.name, this.superGrammar.name, source);
  } else if (this.rules[name]) {
    throw errors$1.duplicateRuleDeclaration(name, this.name, this.name, source);
  }
  const duplicateParameterNames2 = common$1$1.getDuplicates(formals);
  if (duplicateParameterNames2.length > 0) {
    throw errors$1.duplicateParameterNames(name, duplicateParameterNames2, source);
  }
  return this.install(name, formals, body, description, source);
};
GrammarDecl$1.prototype.override = function(name, formals, body, descIgnored, source) {
  this.ensureSuperGrammarRuleForOverriding(name, source);
  this.installOverriddenOrExtendedRule(name, formals, body, source);
  return this;
};
GrammarDecl$1.prototype.extend = function(name, formals, fragment, descIgnored, source) {
  const ruleInfo = this.ensureSuperGrammar().rules[name];
  if (!ruleInfo) {
    throw errors$1.cannotExtendUndeclaredRule(name, this.superGrammar.name, source);
  }
  const body = new pexprs$2.Extend(this.superGrammar, name, fragment);
  body.source = fragment.source;
  this.installOverriddenOrExtendedRule(name, formals, body, source);
  return this;
};
var GrammarDecl_1 = GrammarDecl$1;
const Grammar$2 = Grammar_1;
const GrammarDecl = GrammarDecl_1;
const pexprs$1 = pexprs$6;
function Builder$2() {
}
Builder$2.prototype = {
  currentDecl: null,
  currentRuleName: null,
  newGrammar(name) {
    return new GrammarDecl(name);
  },
  grammar(metaInfo, name, superGrammar, defaultStartRule, rules) {
    const gDecl = new GrammarDecl(name);
    if (superGrammar) {
      gDecl.withSuperGrammar(
        superGrammar instanceof Grammar$2 ? superGrammar : this.fromRecipe(superGrammar)
      );
    }
    if (defaultStartRule) {
      gDecl.withDefaultStartRule(defaultStartRule);
    }
    if (metaInfo && metaInfo.source) {
      gDecl.withSource(metaInfo.source);
    }
    this.currentDecl = gDecl;
    Object.keys(rules).forEach((ruleName) => {
      this.currentRuleName = ruleName;
      const ruleRecipe = rules[ruleName];
      const action = ruleRecipe[0];
      const metaInfo2 = ruleRecipe[1];
      const description = ruleRecipe[2];
      const formals = ruleRecipe[3];
      const body = this.fromRecipe(ruleRecipe[4]);
      let source;
      if (gDecl.source && metaInfo2 && metaInfo2.sourceInterval) {
        source = gDecl.source.subInterval(
          metaInfo2.sourceInterval[0],
          metaInfo2.sourceInterval[1] - metaInfo2.sourceInterval[0]
        );
      }
      gDecl[action](ruleName, formals, body, description, source);
    });
    this.currentRuleName = this.currentDecl = null;
    return gDecl.build();
  },
  terminal(x2) {
    return new pexprs$1.Terminal(x2);
  },
  range(from, to2) {
    return new pexprs$1.Range(from, to2);
  },
  param(index) {
    return new pexprs$1.Param(index);
  },
  alt(...termArgs) {
    let terms = [];
    for (let arg of termArgs) {
      if (!(arg instanceof pexprs$1.PExpr)) {
        arg = this.fromRecipe(arg);
      }
      if (arg instanceof pexprs$1.Alt) {
        terms = terms.concat(arg.terms);
      } else {
        terms.push(arg);
      }
    }
    return terms.length === 1 ? terms[0] : new pexprs$1.Alt(terms);
  },
  seq(...factorArgs) {
    let factors = [];
    for (let arg of factorArgs) {
      if (!(arg instanceof pexprs$1.PExpr)) {
        arg = this.fromRecipe(arg);
      }
      if (arg instanceof pexprs$1.Seq) {
        factors = factors.concat(arg.factors);
      } else {
        factors.push(arg);
      }
    }
    return factors.length === 1 ? factors[0] : new pexprs$1.Seq(factors);
  },
  star(expr) {
    if (!(expr instanceof pexprs$1.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs$1.Star(expr);
  },
  plus(expr) {
    if (!(expr instanceof pexprs$1.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs$1.Plus(expr);
  },
  opt(expr) {
    if (!(expr instanceof pexprs$1.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs$1.Opt(expr);
  },
  not(expr) {
    if (!(expr instanceof pexprs$1.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs$1.Not(expr);
  },
  la(expr) {
    return this.lookahead(expr);
  },
  lookahead(expr) {
    if (!(expr instanceof pexprs$1.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs$1.Lookahead(expr);
  },
  lex(expr) {
    if (!(expr instanceof pexprs$1.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs$1.Lex(expr);
  },
  app(ruleName, optParams) {
    if (optParams && optParams.length > 0) {
      optParams = optParams.map(function(param) {
        return param instanceof pexprs$1.PExpr ? param : this.fromRecipe(param);
      }, this);
    }
    return new pexprs$1.Apply(ruleName, optParams);
  },
  // Note that unlike other methods in this class, this method cannot be used as a
  // convenience constructor. It only works with recipes, because it relies on
  // `this.currentDecl` and `this.currentRuleName` being set.
  splice(beforeTerms, afterTerms) {
    return new pexprs$1.Splice(
      this.currentDecl.superGrammar,
      this.currentRuleName,
      beforeTerms.map((term) => this.fromRecipe(term)),
      afterTerms.map((term) => this.fromRecipe(term))
    );
  },
  fromRecipe(recipe) {
    const args = recipe[0] === "grammar" ? recipe.slice(1) : recipe.slice(2);
    const result = this[recipe[0]](...args);
    const metaInfo = recipe[1];
    if (metaInfo) {
      if (metaInfo.sourceInterval && this.currentDecl) {
        result.withSource(this.currentDecl.sourceInterval(...metaInfo.sourceInterval));
      }
    }
    return result;
  }
};
var Builder_1 = Builder$2;
var version$2 = "16.6.0";
var require$$0$2 = {
  version: version$2
};
var version$1$1 = typeof __GLOBAL_OHM_VERSION__ === "string" ? __GLOBAL_OHM_VERSION__ : require$$0$2.version;
var makeRecipe$5 = {};
const Builder$1 = Builder_1;
function makeRecipe$4(recipe) {
  if (typeof recipe === "function") {
    return recipe.call(new Builder$1());
  } else {
    if (typeof recipe === "string") {
      recipe = JSON.parse(recipe);
    }
    return new Builder$1().fromRecipe(recipe);
  }
}
makeRecipe$5.makeRecipe = makeRecipe$4;
var { makeRecipe: makeRecipe$3 } = makeRecipe$5;
var builtInRules = makeRecipe$3(["grammar", { "source": 'BuiltInRules {\n\n  alnum  (an alpha-numeric character)\n    = letter\n    | digit\n\n  letter  (a letter)\n    = lower\n    | upper\n    | unicodeLtmo\n\n  digit  (a digit)\n    = "0".."9"\n\n  hexDigit  (a hexadecimal digit)\n    = digit\n    | "a".."f"\n    | "A".."F"\n\n  ListOf<elem, sep>\n    = NonemptyListOf<elem, sep>\n    | EmptyListOf<elem, sep>\n\n  NonemptyListOf<elem, sep>\n    = elem (sep elem)*\n\n  EmptyListOf<elem, sep>\n    = /* nothing */\n\n  listOf<elem, sep>\n    = nonemptyListOf<elem, sep>\n    | emptyListOf<elem, sep>\n\n  nonemptyListOf<elem, sep>\n    = elem (sep elem)*\n\n  emptyListOf<elem, sep>\n    = /* nothing */\n\n  // Allows a syntactic rule application within a lexical context.\n  applySyntactic<app> = app\n}' }, "BuiltInRules", null, null, { "alnum": ["define", { "sourceInterval": [18, 78] }, "an alpha-numeric character", [], ["alt", { "sourceInterval": [60, 78] }, ["app", { "sourceInterval": [60, 66] }, "letter", []], ["app", { "sourceInterval": [73, 78] }, "digit", []]]], "letter": ["define", { "sourceInterval": [82, 142] }, "a letter", [], ["alt", { "sourceInterval": [107, 142] }, ["app", { "sourceInterval": [107, 112] }, "lower", []], ["app", { "sourceInterval": [119, 124] }, "upper", []], ["app", { "sourceInterval": [131, 142] }, "unicodeLtmo", []]]], "digit": ["define", { "sourceInterval": [146, 177] }, "a digit", [], ["range", { "sourceInterval": [169, 177] }, "0", "9"]], "hexDigit": ["define", { "sourceInterval": [181, 254] }, "a hexadecimal digit", [], ["alt", { "sourceInterval": [219, 254] }, ["app", { "sourceInterval": [219, 224] }, "digit", []], ["range", { "sourceInterval": [231, 239] }, "a", "f"], ["range", { "sourceInterval": [246, 254] }, "A", "F"]]], "ListOf": ["define", { "sourceInterval": [258, 336] }, null, ["elem", "sep"], ["alt", { "sourceInterval": [282, 336] }, ["app", { "sourceInterval": [282, 307] }, "NonemptyListOf", [["param", { "sourceInterval": [297, 301] }, 0], ["param", { "sourceInterval": [303, 306] }, 1]]], ["app", { "sourceInterval": [314, 336] }, "EmptyListOf", [["param", { "sourceInterval": [326, 330] }, 0], ["param", { "sourceInterval": [332, 335] }, 1]]]]], "NonemptyListOf": ["define", { "sourceInterval": [340, 388] }, null, ["elem", "sep"], ["seq", { "sourceInterval": [372, 388] }, ["param", { "sourceInterval": [372, 376] }, 0], ["star", { "sourceInterval": [377, 388] }, ["seq", { "sourceInterval": [378, 386] }, ["param", { "sourceInterval": [378, 381] }, 1], ["param", { "sourceInterval": [382, 386] }, 0]]]]], "EmptyListOf": ["define", { "sourceInterval": [392, 434] }, null, ["elem", "sep"], ["seq", { "sourceInterval": [438, 438] }]], "listOf": ["define", { "sourceInterval": [438, 516] }, null, ["elem", "sep"], ["alt", { "sourceInterval": [462, 516] }, ["app", { "sourceInterval": [462, 487] }, "nonemptyListOf", [["param", { "sourceInterval": [477, 481] }, 0], ["param", { "sourceInterval": [483, 486] }, 1]]], ["app", { "sourceInterval": [494, 516] }, "emptyListOf", [["param", { "sourceInterval": [506, 510] }, 0], ["param", { "sourceInterval": [512, 515] }, 1]]]]], "nonemptyListOf": ["define", { "sourceInterval": [520, 568] }, null, ["elem", "sep"], ["seq", { "sourceInterval": [552, 568] }, ["param", { "sourceInterval": [552, 556] }, 0], ["star", { "sourceInterval": [557, 568] }, ["seq", { "sourceInterval": [558, 566] }, ["param", { "sourceInterval": [558, 561] }, 1], ["param", { "sourceInterval": [562, 566] }, 0]]]]], "emptyListOf": ["define", { "sourceInterval": [572, 682] }, null, ["elem", "sep"], ["seq", { "sourceInterval": [685, 685] }]], "applySyntactic": ["define", { "sourceInterval": [685, 710] }, null, ["app"], ["param", { "sourceInterval": [707, 710] }, 0]] }]);
const Grammar$1 = Grammar_1;
Grammar$1.BuiltInRules = builtInRules;
var { makeRecipe: makeRecipe$2 } = makeRecipe$5;
var operationsAndAttributes = makeRecipe$2(["grammar", { "source": 'OperationsAndAttributes {\n\n  AttributeSignature =\n    name\n\n  OperationSignature =\n    name Formals?\n\n  Formals\n    = "(" ListOf<name, ","> ")"\n\n  name  (a name)\n    = nameFirst nameRest*\n\n  nameFirst\n    = "_"\n    | letter\n\n  nameRest\n    = "_"\n    | alnum\n\n}' }, "OperationsAndAttributes", null, "AttributeSignature", { "AttributeSignature": ["define", { "sourceInterval": [29, 58] }, null, [], ["app", { "sourceInterval": [54, 58] }, "name", []]], "OperationSignature": ["define", { "sourceInterval": [62, 100] }, null, [], ["seq", { "sourceInterval": [87, 100] }, ["app", { "sourceInterval": [87, 91] }, "name", []], ["opt", { "sourceInterval": [92, 100] }, ["app", { "sourceInterval": [92, 99] }, "Formals", []]]]], "Formals": ["define", { "sourceInterval": [104, 143] }, null, [], ["seq", { "sourceInterval": [118, 143] }, ["terminal", { "sourceInterval": [118, 121] }, "("], ["app", { "sourceInterval": [122, 139] }, "ListOf", [["app", { "sourceInterval": [129, 133] }, "name", []], ["terminal", { "sourceInterval": [135, 138] }, ","]]], ["terminal", { "sourceInterval": [140, 143] }, ")"]]], "name": ["define", { "sourceInterval": [147, 187] }, "a name", [], ["seq", { "sourceInterval": [168, 187] }, ["app", { "sourceInterval": [168, 177] }, "nameFirst", []], ["star", { "sourceInterval": [178, 187] }, ["app", { "sourceInterval": [178, 186] }, "nameRest", []]]]], "nameFirst": ["define", { "sourceInterval": [191, 223] }, null, [], ["alt", { "sourceInterval": [207, 223] }, ["terminal", { "sourceInterval": [207, 210] }, "_"], ["app", { "sourceInterval": [217, 223] }, "letter", []]]], "nameRest": ["define", { "sourceInterval": [227, 257] }, null, [], ["alt", { "sourceInterval": [242, 257] }, ["terminal", { "sourceInterval": [242, 245] }, "_"], ["app", { "sourceInterval": [252, 257] }, "alnum", []]]] }]);
const Semantics = Semantics_1;
const util$1 = util$7;
util$1.awaitBuiltInRules((builtInRules2) => {
  const operationsAndAttributesGrammar = operationsAndAttributes;
  initBuiltInSemantics(builtInRules2);
  initPrototypeParser(operationsAndAttributesGrammar);
});
function initBuiltInSemantics(builtInRules2) {
  const actions = {
    empty() {
      return this.iteration();
    },
    nonEmpty(first, _, rest) {
      return this.iteration([first].concat(rest.children));
    }
  };
  Semantics.BuiltInSemantics = Semantics.createSemantics(builtInRules2, null).addOperation(
    "asIteration",
    {
      emptyListOf: actions.empty,
      nonemptyListOf: actions.nonEmpty,
      EmptyListOf: actions.empty,
      NonemptyListOf: actions.nonEmpty
    }
  );
}
function initPrototypeParser(grammar2) {
  Semantics.prototypeGrammarSemantics = grammar2.createSemantics().addOperation("parse", {
    AttributeSignature(name) {
      return {
        name: name.parse(),
        formals: []
      };
    },
    OperationSignature(name, optFormals) {
      return {
        name: name.parse(),
        formals: optFormals.children.map((c) => c.parse())[0] || []
      };
    },
    Formals(oparen, fs, cparen) {
      return fs.asIteration().children.map((c) => c.parse());
    },
    name(first, rest) {
      return this.sourceString;
    }
  });
  Semantics.prototypeGrammar = grammar2;
}
var { makeRecipe: makeRecipe$1 } = makeRecipe$5;
var ohmGrammar$1 = makeRecipe$1(["grammar", { "source": `Ohm {

  Grammars
    = Grammar*

  Grammar
    = ident SuperGrammar? "{" Rule* "}"

  SuperGrammar
    = "<:" ident

  Rule
    = ident Formals? ruleDescr? "="  RuleBody  -- define
    | ident Formals?            ":=" OverrideRuleBody  -- override
    | ident Formals?            "+=" RuleBody  -- extend

  RuleBody
    = "|"? NonemptyListOf<TopLevelTerm, "|">

  TopLevelTerm
    = Seq caseName  -- inline
    | Seq

  OverrideRuleBody
    = "|"? NonemptyListOf<OverrideTopLevelTerm, "|">

  OverrideTopLevelTerm
    = "..."  -- superSplice
    | TopLevelTerm

  Formals
    = "<" ListOf<ident, ","> ">"

  Params
    = "<" ListOf<Seq, ","> ">"

  Alt
    = NonemptyListOf<Seq, "|">

  Seq
    = Iter*

  Iter
    = Pred "*"  -- star
    | Pred "+"  -- plus
    | Pred "?"  -- opt
    | Pred

  Pred
    = "~" Lex  -- not
    | "&" Lex  -- lookahead
    | Lex

  Lex
    = "#" Base  -- lex
    | Base

  Base
    = ident Params? ~(ruleDescr? "=" | ":=" | "+=")  -- application
    | oneCharTerminal ".." oneCharTerminal           -- range
    | terminal                                       -- terminal
    | "(" Alt ")"                                    -- paren

  ruleDescr  (a rule description)
    = "(" ruleDescrText ")"

  ruleDescrText
    = (~")" any)*

  caseName
    = "--" (~"\\n" space)* name (~"\\n" space)* ("\\n" | &"}")

  name  (a name)
    = nameFirst nameRest*

  nameFirst
    = "_"
    | letter

  nameRest
    = "_"
    | alnum

  ident  (an identifier)
    = name

  terminal
    = "\\"" terminalChar* "\\""

  oneCharTerminal
    = "\\"" terminalChar "\\""

  terminalChar
    = escapeChar
      | ~"\\\\" ~"\\"" ~"\\n" "\\u{0}".."\\u{10FFFF}"

  escapeChar  (an escape sequence)
    = "\\\\\\\\"                                     -- backslash
    | "\\\\\\""                                     -- doubleQuote
    | "\\\\\\'"                                     -- singleQuote
    | "\\\\b"                                      -- backspace
    | "\\\\n"                                      -- lineFeed
    | "\\\\r"                                      -- carriageReturn
    | "\\\\t"                                      -- tab
    | "\\\\u{" hexDigit hexDigit? hexDigit?
             hexDigit? hexDigit? hexDigit? "}"   -- unicodeCodePoint
    | "\\\\u" hexDigit hexDigit hexDigit hexDigit  -- unicodeEscape
    | "\\\\x" hexDigit hexDigit                    -- hexEscape

  space
   += comment

  comment
    = "//" (~"\\n" any)* &("\\n" | end)  -- singleLine
    | "/*" (~"*/" any)* "*/"  -- multiLine

  tokens = token*

  token = caseName | comment | ident | operator | punctuation | terminal | any

  operator = "<:" | "=" | ":=" | "+=" | "*" | "+" | "?" | "~" | "&"

  punctuation = "<" | ">" | "," | "--"
}` }, "Ohm", null, "Grammars", { "Grammars": ["define", { "sourceInterval": [9, 32] }, null, [], ["star", { "sourceInterval": [24, 32] }, ["app", { "sourceInterval": [24, 31] }, "Grammar", []]]], "Grammar": ["define", { "sourceInterval": [36, 83] }, null, [], ["seq", { "sourceInterval": [50, 83] }, ["app", { "sourceInterval": [50, 55] }, "ident", []], ["opt", { "sourceInterval": [56, 69] }, ["app", { "sourceInterval": [56, 68] }, "SuperGrammar", []]], ["terminal", { "sourceInterval": [70, 73] }, "{"], ["star", { "sourceInterval": [74, 79] }, ["app", { "sourceInterval": [74, 78] }, "Rule", []]], ["terminal", { "sourceInterval": [80, 83] }, "}"]]], "SuperGrammar": ["define", { "sourceInterval": [87, 116] }, null, [], ["seq", { "sourceInterval": [106, 116] }, ["terminal", { "sourceInterval": [106, 110] }, "<:"], ["app", { "sourceInterval": [111, 116] }, "ident", []]]], "Rule_define": ["define", { "sourceInterval": [131, 181] }, null, [], ["seq", { "sourceInterval": [131, 170] }, ["app", { "sourceInterval": [131, 136] }, "ident", []], ["opt", { "sourceInterval": [137, 145] }, ["app", { "sourceInterval": [137, 144] }, "Formals", []]], ["opt", { "sourceInterval": [146, 156] }, ["app", { "sourceInterval": [146, 155] }, "ruleDescr", []]], ["terminal", { "sourceInterval": [157, 160] }, "="], ["app", { "sourceInterval": [162, 170] }, "RuleBody", []]]], "Rule_override": ["define", { "sourceInterval": [188, 248] }, null, [], ["seq", { "sourceInterval": [188, 235] }, ["app", { "sourceInterval": [188, 193] }, "ident", []], ["opt", { "sourceInterval": [194, 202] }, ["app", { "sourceInterval": [194, 201] }, "Formals", []]], ["terminal", { "sourceInterval": [214, 218] }, ":="], ["app", { "sourceInterval": [219, 235] }, "OverrideRuleBody", []]]], "Rule_extend": ["define", { "sourceInterval": [255, 305] }, null, [], ["seq", { "sourceInterval": [255, 294] }, ["app", { "sourceInterval": [255, 260] }, "ident", []], ["opt", { "sourceInterval": [261, 269] }, ["app", { "sourceInterval": [261, 268] }, "Formals", []]], ["terminal", { "sourceInterval": [281, 285] }, "+="], ["app", { "sourceInterval": [286, 294] }, "RuleBody", []]]], "Rule": ["define", { "sourceInterval": [120, 305] }, null, [], ["alt", { "sourceInterval": [131, 305] }, ["app", { "sourceInterval": [131, 170] }, "Rule_define", []], ["app", { "sourceInterval": [188, 235] }, "Rule_override", []], ["app", { "sourceInterval": [255, 294] }, "Rule_extend", []]]], "RuleBody": ["define", { "sourceInterval": [309, 362] }, null, [], ["seq", { "sourceInterval": [324, 362] }, ["opt", { "sourceInterval": [324, 328] }, ["terminal", { "sourceInterval": [324, 327] }, "|"]], ["app", { "sourceInterval": [329, 362] }, "NonemptyListOf", [["app", { "sourceInterval": [344, 356] }, "TopLevelTerm", []], ["terminal", { "sourceInterval": [358, 361] }, "|"]]]]], "TopLevelTerm_inline": ["define", { "sourceInterval": [385, 408] }, null, [], ["seq", { "sourceInterval": [385, 397] }, ["app", { "sourceInterval": [385, 388] }, "Seq", []], ["app", { "sourceInterval": [389, 397] }, "caseName", []]]], "TopLevelTerm": ["define", { "sourceInterval": [366, 418] }, null, [], ["alt", { "sourceInterval": [385, 418] }, ["app", { "sourceInterval": [385, 397] }, "TopLevelTerm_inline", []], ["app", { "sourceInterval": [415, 418] }, "Seq", []]]], "OverrideRuleBody": ["define", { "sourceInterval": [422, 491] }, null, [], ["seq", { "sourceInterval": [445, 491] }, ["opt", { "sourceInterval": [445, 449] }, ["terminal", { "sourceInterval": [445, 448] }, "|"]], ["app", { "sourceInterval": [450, 491] }, "NonemptyListOf", [["app", { "sourceInterval": [465, 485] }, "OverrideTopLevelTerm", []], ["terminal", { "sourceInterval": [487, 490] }, "|"]]]]], "OverrideTopLevelTerm_superSplice": ["define", { "sourceInterval": [522, 543] }, null, [], ["terminal", { "sourceInterval": [522, 527] }, "..."]], "OverrideTopLevelTerm": ["define", { "sourceInterval": [495, 562] }, null, [], ["alt", { "sourceInterval": [522, 562] }, ["app", { "sourceInterval": [522, 527] }, "OverrideTopLevelTerm_superSplice", []], ["app", { "sourceInterval": [550, 562] }, "TopLevelTerm", []]]], "Formals": ["define", { "sourceInterval": [566, 606] }, null, [], ["seq", { "sourceInterval": [580, 606] }, ["terminal", { "sourceInterval": [580, 583] }, "<"], ["app", { "sourceInterval": [584, 602] }, "ListOf", [["app", { "sourceInterval": [591, 596] }, "ident", []], ["terminal", { "sourceInterval": [598, 601] }, ","]]], ["terminal", { "sourceInterval": [603, 606] }, ">"]]], "Params": ["define", { "sourceInterval": [610, 647] }, null, [], ["seq", { "sourceInterval": [623, 647] }, ["terminal", { "sourceInterval": [623, 626] }, "<"], ["app", { "sourceInterval": [627, 643] }, "ListOf", [["app", { "sourceInterval": [634, 637] }, "Seq", []], ["terminal", { "sourceInterval": [639, 642] }, ","]]], ["terminal", { "sourceInterval": [644, 647] }, ">"]]], "Alt": ["define", { "sourceInterval": [651, 685] }, null, [], ["app", { "sourceInterval": [661, 685] }, "NonemptyListOf", [["app", { "sourceInterval": [676, 679] }, "Seq", []], ["terminal", { "sourceInterval": [681, 684] }, "|"]]]], "Seq": ["define", { "sourceInterval": [689, 704] }, null, [], ["star", { "sourceInterval": [699, 704] }, ["app", { "sourceInterval": [699, 703] }, "Iter", []]]], "Iter_star": ["define", { "sourceInterval": [719, 736] }, null, [], ["seq", { "sourceInterval": [719, 727] }, ["app", { "sourceInterval": [719, 723] }, "Pred", []], ["terminal", { "sourceInterval": [724, 727] }, "*"]]], "Iter_plus": ["define", { "sourceInterval": [743, 760] }, null, [], ["seq", { "sourceInterval": [743, 751] }, ["app", { "sourceInterval": [743, 747] }, "Pred", []], ["terminal", { "sourceInterval": [748, 751] }, "+"]]], "Iter_opt": ["define", { "sourceInterval": [767, 783] }, null, [], ["seq", { "sourceInterval": [767, 775] }, ["app", { "sourceInterval": [767, 771] }, "Pred", []], ["terminal", { "sourceInterval": [772, 775] }, "?"]]], "Iter": ["define", { "sourceInterval": [708, 794] }, null, [], ["alt", { "sourceInterval": [719, 794] }, ["app", { "sourceInterval": [719, 727] }, "Iter_star", []], ["app", { "sourceInterval": [743, 751] }, "Iter_plus", []], ["app", { "sourceInterval": [767, 775] }, "Iter_opt", []], ["app", { "sourceInterval": [790, 794] }, "Pred", []]]], "Pred_not": ["define", { "sourceInterval": [809, 824] }, null, [], ["seq", { "sourceInterval": [809, 816] }, ["terminal", { "sourceInterval": [809, 812] }, "~"], ["app", { "sourceInterval": [813, 816] }, "Lex", []]]], "Pred_lookahead": ["define", { "sourceInterval": [831, 852] }, null, [], ["seq", { "sourceInterval": [831, 838] }, ["terminal", { "sourceInterval": [831, 834] }, "&"], ["app", { "sourceInterval": [835, 838] }, "Lex", []]]], "Pred": ["define", { "sourceInterval": [798, 862] }, null, [], ["alt", { "sourceInterval": [809, 862] }, ["app", { "sourceInterval": [809, 816] }, "Pred_not", []], ["app", { "sourceInterval": [831, 838] }, "Pred_lookahead", []], ["app", { "sourceInterval": [859, 862] }, "Lex", []]]], "Lex_lex": ["define", { "sourceInterval": [876, 892] }, null, [], ["seq", { "sourceInterval": [876, 884] }, ["terminal", { "sourceInterval": [876, 879] }, "#"], ["app", { "sourceInterval": [880, 884] }, "Base", []]]], "Lex": ["define", { "sourceInterval": [866, 903] }, null, [], ["alt", { "sourceInterval": [876, 903] }, ["app", { "sourceInterval": [876, 884] }, "Lex_lex", []], ["app", { "sourceInterval": [899, 903] }, "Base", []]]], "Base_application": ["define", { "sourceInterval": [918, 979] }, null, [], ["seq", { "sourceInterval": [918, 963] }, ["app", { "sourceInterval": [918, 923] }, "ident", []], ["opt", { "sourceInterval": [924, 931] }, ["app", { "sourceInterval": [924, 930] }, "Params", []]], ["not", { "sourceInterval": [932, 963] }, ["alt", { "sourceInterval": [934, 962] }, ["seq", { "sourceInterval": [934, 948] }, ["opt", { "sourceInterval": [934, 944] }, ["app", { "sourceInterval": [934, 943] }, "ruleDescr", []]], ["terminal", { "sourceInterval": [945, 948] }, "="]], ["terminal", { "sourceInterval": [951, 955] }, ":="], ["terminal", { "sourceInterval": [958, 962] }, "+="]]]]], "Base_range": ["define", { "sourceInterval": [986, 1041] }, null, [], ["seq", { "sourceInterval": [986, 1022] }, ["app", { "sourceInterval": [986, 1001] }, "oneCharTerminal", []], ["terminal", { "sourceInterval": [1002, 1006] }, ".."], ["app", { "sourceInterval": [1007, 1022] }, "oneCharTerminal", []]]], "Base_terminal": ["define", { "sourceInterval": [1048, 1106] }, null, [], ["app", { "sourceInterval": [1048, 1056] }, "terminal", []]], "Base_paren": ["define", { "sourceInterval": [1113, 1168] }, null, [], ["seq", { "sourceInterval": [1113, 1124] }, ["terminal", { "sourceInterval": [1113, 1116] }, "("], ["app", { "sourceInterval": [1117, 1120] }, "Alt", []], ["terminal", { "sourceInterval": [1121, 1124] }, ")"]]], "Base": ["define", { "sourceInterval": [907, 1168] }, null, [], ["alt", { "sourceInterval": [918, 1168] }, ["app", { "sourceInterval": [918, 963] }, "Base_application", []], ["app", { "sourceInterval": [986, 1022] }, "Base_range", []], ["app", { "sourceInterval": [1048, 1056] }, "Base_terminal", []], ["app", { "sourceInterval": [1113, 1124] }, "Base_paren", []]]], "ruleDescr": ["define", { "sourceInterval": [1172, 1231] }, "a rule description", [], ["seq", { "sourceInterval": [1210, 1231] }, ["terminal", { "sourceInterval": [1210, 1213] }, "("], ["app", { "sourceInterval": [1214, 1227] }, "ruleDescrText", []], ["terminal", { "sourceInterval": [1228, 1231] }, ")"]]], "ruleDescrText": ["define", { "sourceInterval": [1235, 1266] }, null, [], ["star", { "sourceInterval": [1255, 1266] }, ["seq", { "sourceInterval": [1256, 1264] }, ["not", { "sourceInterval": [1256, 1260] }, ["terminal", { "sourceInterval": [1257, 1260] }, ")"]], ["app", { "sourceInterval": [1261, 1264] }, "any", []]]]], "caseName": ["define", { "sourceInterval": [1270, 1338] }, null, [], ["seq", { "sourceInterval": [1285, 1338] }, ["terminal", { "sourceInterval": [1285, 1289] }, "--"], ["star", { "sourceInterval": [1290, 1304] }, ["seq", { "sourceInterval": [1291, 1302] }, ["not", { "sourceInterval": [1291, 1296] }, ["terminal", { "sourceInterval": [1292, 1296] }, "\n"]], ["app", { "sourceInterval": [1297, 1302] }, "space", []]]], ["app", { "sourceInterval": [1305, 1309] }, "name", []], ["star", { "sourceInterval": [1310, 1324] }, ["seq", { "sourceInterval": [1311, 1322] }, ["not", { "sourceInterval": [1311, 1316] }, ["terminal", { "sourceInterval": [1312, 1316] }, "\n"]], ["app", { "sourceInterval": [1317, 1322] }, "space", []]]], ["alt", { "sourceInterval": [1326, 1337] }, ["terminal", { "sourceInterval": [1326, 1330] }, "\n"], ["lookahead", { "sourceInterval": [1333, 1337] }, ["terminal", { "sourceInterval": [1334, 1337] }, "}"]]]]], "name": ["define", { "sourceInterval": [1342, 1382] }, "a name", [], ["seq", { "sourceInterval": [1363, 1382] }, ["app", { "sourceInterval": [1363, 1372] }, "nameFirst", []], ["star", { "sourceInterval": [1373, 1382] }, ["app", { "sourceInterval": [1373, 1381] }, "nameRest", []]]]], "nameFirst": ["define", { "sourceInterval": [1386, 1418] }, null, [], ["alt", { "sourceInterval": [1402, 1418] }, ["terminal", { "sourceInterval": [1402, 1405] }, "_"], ["app", { "sourceInterval": [1412, 1418] }, "letter", []]]], "nameRest": ["define", { "sourceInterval": [1422, 1452] }, null, [], ["alt", { "sourceInterval": [1437, 1452] }, ["terminal", { "sourceInterval": [1437, 1440] }, "_"], ["app", { "sourceInterval": [1447, 1452] }, "alnum", []]]], "ident": ["define", { "sourceInterval": [1456, 1489] }, "an identifier", [], ["app", { "sourceInterval": [1485, 1489] }, "name", []]], "terminal": ["define", { "sourceInterval": [1493, 1531] }, null, [], ["seq", { "sourceInterval": [1508, 1531] }, ["terminal", { "sourceInterval": [1508, 1512] }, '"'], ["star", { "sourceInterval": [1513, 1526] }, ["app", { "sourceInterval": [1513, 1525] }, "terminalChar", []]], ["terminal", { "sourceInterval": [1527, 1531] }, '"']]], "oneCharTerminal": ["define", { "sourceInterval": [1535, 1579] }, null, [], ["seq", { "sourceInterval": [1557, 1579] }, ["terminal", { "sourceInterval": [1557, 1561] }, '"'], ["app", { "sourceInterval": [1562, 1574] }, "terminalChar", []], ["terminal", { "sourceInterval": [1575, 1579] }, '"']]], "terminalChar": ["define", { "sourceInterval": [1583, 1660] }, null, [], ["alt", { "sourceInterval": [1602, 1660] }, ["app", { "sourceInterval": [1602, 1612] }, "escapeChar", []], ["seq", { "sourceInterval": [1621, 1660] }, ["not", { "sourceInterval": [1621, 1626] }, ["terminal", { "sourceInterval": [1622, 1626] }, "\\"]], ["not", { "sourceInterval": [1627, 1632] }, ["terminal", { "sourceInterval": [1628, 1632] }, '"']], ["not", { "sourceInterval": [1633, 1638] }, ["terminal", { "sourceInterval": [1634, 1638] }, "\n"]], ["range", { "sourceInterval": [1639, 1660] }, "\0", ""]]]], "escapeChar_backslash": ["define", { "sourceInterval": [1703, 1758] }, null, [], ["terminal", { "sourceInterval": [1703, 1709] }, "\\\\"]], "escapeChar_doubleQuote": ["define", { "sourceInterval": [1765, 1822] }, null, [], ["terminal", { "sourceInterval": [1765, 1771] }, '\\"']], "escapeChar_singleQuote": ["define", { "sourceInterval": [1829, 1886] }, null, [], ["terminal", { "sourceInterval": [1829, 1835] }, "\\'"]], "escapeChar_backspace": ["define", { "sourceInterval": [1893, 1948] }, null, [], ["terminal", { "sourceInterval": [1893, 1898] }, "\\b"]], "escapeChar_lineFeed": ["define", { "sourceInterval": [1955, 2009] }, null, [], ["terminal", { "sourceInterval": [1955, 1960] }, "\\n"]], "escapeChar_carriageReturn": ["define", { "sourceInterval": [2016, 2076] }, null, [], ["terminal", { "sourceInterval": [2016, 2021] }, "\\r"]], "escapeChar_tab": ["define", { "sourceInterval": [2083, 2132] }, null, [], ["terminal", { "sourceInterval": [2083, 2088] }, "\\t"]], "escapeChar_unicodeCodePoint": ["define", { "sourceInterval": [2139, 2243] }, null, [], ["seq", { "sourceInterval": [2139, 2221] }, ["terminal", { "sourceInterval": [2139, 2145] }, "\\u{"], ["app", { "sourceInterval": [2146, 2154] }, "hexDigit", []], ["opt", { "sourceInterval": [2155, 2164] }, ["app", { "sourceInterval": [2155, 2163] }, "hexDigit", []]], ["opt", { "sourceInterval": [2165, 2174] }, ["app", { "sourceInterval": [2165, 2173] }, "hexDigit", []]], ["opt", { "sourceInterval": [2188, 2197] }, ["app", { "sourceInterval": [2188, 2196] }, "hexDigit", []]], ["opt", { "sourceInterval": [2198, 2207] }, ["app", { "sourceInterval": [2198, 2206] }, "hexDigit", []]], ["opt", { "sourceInterval": [2208, 2217] }, ["app", { "sourceInterval": [2208, 2216] }, "hexDigit", []]], ["terminal", { "sourceInterval": [2218, 2221] }, "}"]]], "escapeChar_unicodeEscape": ["define", { "sourceInterval": [2250, 2309] }, null, [], ["seq", { "sourceInterval": [2250, 2291] }, ["terminal", { "sourceInterval": [2250, 2255] }, "\\u"], ["app", { "sourceInterval": [2256, 2264] }, "hexDigit", []], ["app", { "sourceInterval": [2265, 2273] }, "hexDigit", []], ["app", { "sourceInterval": [2274, 2282] }, "hexDigit", []], ["app", { "sourceInterval": [2283, 2291] }, "hexDigit", []]]], "escapeChar_hexEscape": ["define", { "sourceInterval": [2316, 2371] }, null, [], ["seq", { "sourceInterval": [2316, 2339] }, ["terminal", { "sourceInterval": [2316, 2321] }, "\\x"], ["app", { "sourceInterval": [2322, 2330] }, "hexDigit", []], ["app", { "sourceInterval": [2331, 2339] }, "hexDigit", []]]], "escapeChar": ["define", { "sourceInterval": [1664, 2371] }, "an escape sequence", [], ["alt", { "sourceInterval": [1703, 2371] }, ["app", { "sourceInterval": [1703, 1709] }, "escapeChar_backslash", []], ["app", { "sourceInterval": [1765, 1771] }, "escapeChar_doubleQuote", []], ["app", { "sourceInterval": [1829, 1835] }, "escapeChar_singleQuote", []], ["app", { "sourceInterval": [1893, 1898] }, "escapeChar_backspace", []], ["app", { "sourceInterval": [1955, 1960] }, "escapeChar_lineFeed", []], ["app", { "sourceInterval": [2016, 2021] }, "escapeChar_carriageReturn", []], ["app", { "sourceInterval": [2083, 2088] }, "escapeChar_tab", []], ["app", { "sourceInterval": [2139, 2221] }, "escapeChar_unicodeCodePoint", []], ["app", { "sourceInterval": [2250, 2291] }, "escapeChar_unicodeEscape", []], ["app", { "sourceInterval": [2316, 2339] }, "escapeChar_hexEscape", []]]], "space": ["extend", { "sourceInterval": [2375, 2394] }, null, [], ["app", { "sourceInterval": [2387, 2394] }, "comment", []]], "comment_singleLine": ["define", { "sourceInterval": [2412, 2458] }, null, [], ["seq", { "sourceInterval": [2412, 2443] }, ["terminal", { "sourceInterval": [2412, 2416] }, "//"], ["star", { "sourceInterval": [2417, 2429] }, ["seq", { "sourceInterval": [2418, 2427] }, ["not", { "sourceInterval": [2418, 2423] }, ["terminal", { "sourceInterval": [2419, 2423] }, "\n"]], ["app", { "sourceInterval": [2424, 2427] }, "any", []]]], ["lookahead", { "sourceInterval": [2430, 2443] }, ["alt", { "sourceInterval": [2432, 2442] }, ["terminal", { "sourceInterval": [2432, 2436] }, "\n"], ["app", { "sourceInterval": [2439, 2442] }, "end", []]]]]], "comment_multiLine": ["define", { "sourceInterval": [2465, 2501] }, null, [], ["seq", { "sourceInterval": [2465, 2487] }, ["terminal", { "sourceInterval": [2465, 2469] }, "/*"], ["star", { "sourceInterval": [2470, 2482] }, ["seq", { "sourceInterval": [2471, 2480] }, ["not", { "sourceInterval": [2471, 2476] }, ["terminal", { "sourceInterval": [2472, 2476] }, "*/"]], ["app", { "sourceInterval": [2477, 2480] }, "any", []]]], ["terminal", { "sourceInterval": [2483, 2487] }, "*/"]]], "comment": ["define", { "sourceInterval": [2398, 2501] }, null, [], ["alt", { "sourceInterval": [2412, 2501] }, ["app", { "sourceInterval": [2412, 2443] }, "comment_singleLine", []], ["app", { "sourceInterval": [2465, 2487] }, "comment_multiLine", []]]], "tokens": ["define", { "sourceInterval": [2505, 2520] }, null, [], ["star", { "sourceInterval": [2514, 2520] }, ["app", { "sourceInterval": [2514, 2519] }, "token", []]]], "token": ["define", { "sourceInterval": [2524, 2600] }, null, [], ["alt", { "sourceInterval": [2532, 2600] }, ["app", { "sourceInterval": [2532, 2540] }, "caseName", []], ["app", { "sourceInterval": [2543, 2550] }, "comment", []], ["app", { "sourceInterval": [2553, 2558] }, "ident", []], ["app", { "sourceInterval": [2561, 2569] }, "operator", []], ["app", { "sourceInterval": [2572, 2583] }, "punctuation", []], ["app", { "sourceInterval": [2586, 2594] }, "terminal", []], ["app", { "sourceInterval": [2597, 2600] }, "any", []]]], "operator": ["define", { "sourceInterval": [2604, 2669] }, null, [], ["alt", { "sourceInterval": [2615, 2669] }, ["terminal", { "sourceInterval": [2615, 2619] }, "<:"], ["terminal", { "sourceInterval": [2622, 2625] }, "="], ["terminal", { "sourceInterval": [2628, 2632] }, ":="], ["terminal", { "sourceInterval": [2635, 2639] }, "+="], ["terminal", { "sourceInterval": [2642, 2645] }, "*"], ["terminal", { "sourceInterval": [2648, 2651] }, "+"], ["terminal", { "sourceInterval": [2654, 2657] }, "?"], ["terminal", { "sourceInterval": [2660, 2663] }, "~"], ["terminal", { "sourceInterval": [2666, 2669] }, "&"]]], "punctuation": ["define", { "sourceInterval": [2673, 2709] }, null, [], ["alt", { "sourceInterval": [2687, 2709] }, ["terminal", { "sourceInterval": [2687, 2690] }, "<"], ["terminal", { "sourceInterval": [2693, 2696] }, ">"], ["terminal", { "sourceInterval": [2699, 2702] }, ","], ["terminal", { "sourceInterval": [2705, 2709] }, "--"]]] }]);
const Builder = Builder_1;
const Grammar = Grammar_1;
const Namespace = Namespace_1;
const common$m = common$l;
const errors$a = errors$9;
const pexprs = pexprs$6;
const util$8 = util$7;
const version$3 = version$1$1;
const { makeRecipe } = makeRecipe$5;
let ohmGrammar;
const superSplicePlaceholder = Object.create(pexprs.PExpr.prototype);
const isBuffer = (obj) => !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
function buildGrammar(match, namespace, optOhmGrammarForTesting) {
  const builder2 = new Builder();
  let decl;
  let currentRuleName;
  let currentRuleFormals;
  let overriding = false;
  const metaGrammar = optOhmGrammarForTesting || ohmGrammar;
  const helpers = metaGrammar.createSemantics().addOperation("visit", {
    Grammars(grammarIter) {
      return grammarIter.children.map((c) => c.visit());
    },
    Grammar(id, s2, _open, rules, _close) {
      const grammarName = id.visit();
      decl = builder2.newGrammar(grammarName, namespace);
      s2.child(0) && s2.child(0).visit();
      rules.children.map((c) => c.visit());
      const g2 = decl.build();
      g2.source = this.source.trimmed();
      if (grammarName in namespace) {
        throw errors$a.duplicateGrammarDeclaration(g2, namespace);
      }
      namespace[grammarName] = g2;
      return g2;
    },
    SuperGrammar(_, n) {
      const superGrammarName = n.visit();
      if (superGrammarName === "null") {
        decl.withSuperGrammar(null);
      } else {
        if (!namespace || !(superGrammarName in namespace)) {
          throw errors$a.undeclaredGrammar(superGrammarName, namespace, n.source);
        }
        decl.withSuperGrammar(namespace[superGrammarName]);
      }
    },
    Rule_define(n, fs, d, _, b2) {
      currentRuleName = n.visit();
      currentRuleFormals = fs.children.map((c) => c.visit())[0] || [];
      if (!decl.defaultStartRule && decl.ensureSuperGrammar() !== Grammar.ProtoBuiltInRules) {
        decl.withDefaultStartRule(currentRuleName);
      }
      const body = b2.visit();
      const description = d.children.map((c) => c.visit())[0];
      const source = this.source.trimmed();
      return decl.define(currentRuleName, currentRuleFormals, body, description, source);
    },
    Rule_override(n, fs, _, b2) {
      currentRuleName = n.visit();
      currentRuleFormals = fs.children.map((c) => c.visit())[0] || [];
      const source = this.source.trimmed();
      decl.ensureSuperGrammarRuleForOverriding(currentRuleName, source);
      overriding = true;
      const body = b2.visit();
      overriding = false;
      return decl.override(currentRuleName, currentRuleFormals, body, null, source);
    },
    Rule_extend(n, fs, _, b2) {
      currentRuleName = n.visit();
      currentRuleFormals = fs.children.map((c) => c.visit())[0] || [];
      const body = b2.visit();
      const source = this.source.trimmed();
      return decl.extend(currentRuleName, currentRuleFormals, body, null, source);
    },
    RuleBody(_, terms) {
      return builder2.alt(...terms.visit()).withSource(this.source);
    },
    OverrideRuleBody(_, terms) {
      const args = terms.visit();
      const expansionPos = args.indexOf(superSplicePlaceholder);
      if (expansionPos >= 0) {
        const beforeTerms = args.slice(0, expansionPos);
        const afterTerms = args.slice(expansionPos + 1);
        afterTerms.forEach((t) => {
          if (t === superSplicePlaceholder) throw errors$a.multipleSuperSplices(t);
        });
        return new pexprs.Splice(
          decl.superGrammar,
          currentRuleName,
          beforeTerms,
          afterTerms
        ).withSource(this.source);
      } else {
        return builder2.alt(...args).withSource(this.source);
      }
    },
    Formals(opointy, fs, cpointy) {
      return fs.visit();
    },
    Params(opointy, ps, cpointy) {
      return ps.visit();
    },
    Alt(seqs) {
      return builder2.alt(...seqs.visit()).withSource(this.source);
    },
    TopLevelTerm_inline(b2, n) {
      const inlineRuleName = currentRuleName + "_" + n.visit();
      const body = b2.visit();
      const source = this.source.trimmed();
      const isNewRuleDeclaration = !(decl.superGrammar && decl.superGrammar.rules[inlineRuleName]);
      if (overriding && !isNewRuleDeclaration) {
        decl.override(inlineRuleName, currentRuleFormals, body, null, source);
      } else {
        decl.define(inlineRuleName, currentRuleFormals, body, null, source);
      }
      const params = currentRuleFormals.map((formal) => builder2.app(formal));
      return builder2.app(inlineRuleName, params).withSource(body.source);
    },
    OverrideTopLevelTerm_superSplice(_) {
      return superSplicePlaceholder;
    },
    Seq(expr) {
      return builder2.seq(...expr.children.map((c) => c.visit())).withSource(this.source);
    },
    Iter_star(x2, _) {
      return builder2.star(x2.visit()).withSource(this.source);
    },
    Iter_plus(x2, _) {
      return builder2.plus(x2.visit()).withSource(this.source);
    },
    Iter_opt(x2, _) {
      return builder2.opt(x2.visit()).withSource(this.source);
    },
    Pred_not(_, x2) {
      return builder2.not(x2.visit()).withSource(this.source);
    },
    Pred_lookahead(_, x2) {
      return builder2.lookahead(x2.visit()).withSource(this.source);
    },
    Lex_lex(_, x2) {
      return builder2.lex(x2.visit()).withSource(this.source);
    },
    Base_application(rule, ps) {
      const params = ps.children.map((c) => c.visit())[0] || [];
      return builder2.app(rule.visit(), params).withSource(this.source);
    },
    Base_range(from, _, to2) {
      return builder2.range(from.visit(), to2.visit()).withSource(this.source);
    },
    Base_terminal(expr) {
      return builder2.terminal(expr.visit()).withSource(this.source);
    },
    Base_paren(open, x2, close) {
      return x2.visit();
    },
    ruleDescr(open, t, close) {
      return t.visit();
    },
    ruleDescrText(_) {
      return this.sourceString.trim();
    },
    caseName(_, space1, n, space2, end2) {
      return n.visit();
    },
    name(first, rest) {
      return this.sourceString;
    },
    nameFirst(expr) {
    },
    nameRest(expr) {
    },
    terminal(open, cs, close) {
      return cs.children.map((c) => c.visit()).join("");
    },
    oneCharTerminal(open, c, close) {
      return c.visit();
    },
    escapeChar(c) {
      try {
        return common$m.unescapeCodePoint(this.sourceString);
      } catch (err) {
        if (err instanceof RangeError && err.message.startsWith("Invalid code point ")) {
          throw errors$a.invalidCodePoint(c);
        }
        throw err;
      }
    },
    NonemptyListOf(x2, _, xs) {
      return [x2.visit()].concat(xs.children.map((c) => c.visit()));
    },
    EmptyListOf() {
      return [];
    },
    _terminal() {
      return this.sourceString;
    }
  });
  return helpers(match).visit();
}
function compileAndLoad(source, namespace) {
  const m2 = ohmGrammar.match(source, "Grammars");
  if (m2.failed()) {
    throw errors$a.grammarSyntaxError(m2);
  }
  return buildGrammar(m2, namespace);
}
function grammar(source, optNamespace) {
  const ns = grammars(source, optNamespace);
  const grammarNames = Object.keys(ns);
  if (grammarNames.length === 0) {
    throw new Error("Missing grammar definition");
  } else if (grammarNames.length > 1) {
    const secondGrammar = ns[grammarNames[1]];
    const interval = secondGrammar.source;
    throw new Error(
      util$8.getLineAndColumnMessage(interval.sourceString, interval.startIdx) + "Found more than one grammar definition -- use ohm.grammars() instead."
    );
  }
  return ns[grammarNames[0]];
}
function grammars(source, optNamespace) {
  const ns = Namespace.extend(Namespace.asNamespace(optNamespace));
  if (typeof source !== "string") {
    if (isBuffer(source)) {
      source = source.toString();
    } else {
      throw new TypeError(
        "Expected string as first argument, got " + common$m.unexpectedObjToString(source)
      );
    }
  }
  compileAndLoad(source, ns);
  return ns;
}
function grammarFromScriptElement(optNode) {
  throw new Error(
    "grammarFromScriptElement was removed in Ohm v16.0. See https://ohmjs.org/d/gfs for more info."
  );
}
function grammarsFromScriptElements(optNodeOrNodeList) {
  throw new Error(
    "grammarsFromScriptElements was removed in Ohm v16.0. See https://ohmjs.org/d/gfs for more info."
  );
}
main$1.exports = {
  createNamespace: Namespace.createNamespace,
  grammar,
  grammars,
  grammarFromScriptElement,
  grammarsFromScriptElements,
  makeRecipe,
  ohmGrammar: null,
  // Initialized below, after Grammar.BuiltInRules.
  pexprs,
  util: util$8,
  version: version$3
};
main$1.exports._buildGrammar = buildGrammar;
util$8.announceBuiltInRules(Grammar.BuiltInRules);
main$1.exports.ohmGrammar = ohmGrammar = ohmGrammar$1;
Grammar.initApplicationParser(ohmGrammar, buildGrammar);
var ohm = main$1.exports;
const { assert } = common$l;
function getProp(name, thing, fn2) {
  return fn2(thing[name]);
}
function mapProp(name, thing, fn2) {
  return thing[name].map(fn2);
}
function getPropWalkFn(descriptor2) {
  const parts = descriptor2.split(/ ?\[\]/);
  if (parts.length === 2) {
    return mapProp.bind(null, parts[0]);
  }
  return getProp.bind(null, descriptor2);
}
function getProps(walkFns, thing, fn2) {
  return walkFns.map((walkFn) => walkFn(thing, fn2));
}
function getWalkFn(shape) {
  if (typeof shape === "string") {
    return getProps.bind(null, [getPropWalkFn(shape)]);
  } else if (Array.isArray(shape)) {
    return getProps.bind(null, shape.map(getPropWalkFn));
  } else {
    assert(typeof shape === "function", "Expected a string, Array, or function");
    assert(shape.length === 2, "Expected a function of arity 2, got " + shape.length);
    return shape;
  }
}
function isRestrictedIdentifier(str) {
  return /^[a-zA-Z_][0-9a-zA-Z_]*$/.test(str);
}
function trim(s2) {
  return s2.trim();
}
function parseSignature(sig) {
  const parts = sig.split(/[()]/).map(trim);
  if (parts.length === 3 && parts[2] === "") {
    const name = parts[0];
    let params = [];
    if (parts[1].length > 0) {
      params = parts[1].split(",").map(trim);
    }
    if (isRestrictedIdentifier(name) && params.every(isRestrictedIdentifier)) {
      return { name, formals: params };
    }
  }
  throw new Error("Invalid operation signature: " + sig);
}
function VisitorFamily(config) {
  this._shapes = config.shapes;
  this._getTag = config.getTag;
  this.Adapter = function(thing, family) {
    this._adaptee = thing;
    this._family = family;
  };
  this.Adapter.prototype.valueOf = function() {
    throw new Error("heeey!");
  };
  this.operations = {};
  this._arities = /* @__PURE__ */ Object.create(null);
  this._getChildren = /* @__PURE__ */ Object.create(null);
  Object.keys(this._shapes).forEach((k2) => {
    const shape = this._shapes[k2];
    this._getChildren[k2] = getWalkFn(shape);
    if (typeof shape !== "function") {
      this._arities[k2] = Array.isArray(shape) ? shape.length : 1;
    }
  });
  this._wrap = (thing) => new this.Adapter(thing, this);
}
VisitorFamily.prototype.wrap = function(thing) {
  return this._wrap(thing);
};
VisitorFamily.prototype._checkActionDict = function(dict) {
  Object.keys(dict).forEach((k2) => {
    assert(k2 in this._getChildren, "Unrecognized action name '" + k2 + "'");
    const action = dict[k2];
    assert(typeof action === "function", "Key '" + k2 + "': expected function, got " + action);
    if (k2 in this._arities) {
      const expected = this._arities[k2];
      const actual = dict[k2].length;
      assert(
        actual === expected,
        "Action '" + k2 + "' has the wrong arity: expected " + expected + ", got " + actual
      );
    }
  });
};
VisitorFamily.prototype.addOperation = function(signature, actions) {
  const sig = parseSignature(signature);
  const { name } = sig;
  this._checkActionDict(actions);
  this.operations[name] = {
    name,
    formals: sig.formals,
    actions
  };
  const family = this;
  this.Adapter.prototype[name] = function(...args) {
    const tag = family._getTag(this._adaptee);
    assert(tag in family._getChildren, "getTag returned unrecognized tag '" + tag + "'");
    assert(tag in actions, "No action for '" + tag + "' in operation '" + name + "'");
    const argsObj = /* @__PURE__ */ Object.create(null);
    for (const [i, val] of Object.entries(args)) {
      argsObj[sig.formals[i]] = val;
    }
    const oldArgs = this.args;
    this.args = argsObj;
    const ans = actions[tag].apply(
      this,
      family._getChildren[tag](this._adaptee, family._wrap)
    );
    this.args = oldArgs;
    return ans;
  };
  return this;
};
var VisitorFamily_1 = VisitorFamily;
const defaultOperation = {
  _terminal() {
    return this.sourceString;
  },
  _nonterminal(...children) {
    const { ctorName } = this._node;
    const { mapping } = this.args;
    if (!Object.prototype.hasOwnProperty.call(mapping, ctorName)) {
      if (this.isLexical()) {
        return this.sourceString;
      }
      const realChildren = children.filter((child) => !child.isTerminal());
      if (realChildren.length === 1) {
        return realChildren[0].toAST(mapping);
      }
    }
    if (typeof mapping[ctorName] === "number") {
      return children[mapping[ctorName]].toAST(mapping);
    }
    const propMap = mapping[ctorName] || children;
    const node = {
      type: ctorName
    };
    for (const prop in propMap) {
      const mappedProp = mapping[ctorName] && mapping[ctorName][prop];
      if (typeof mappedProp === "number") {
        node[prop] = children[mappedProp].toAST(mapping);
      } else if (typeof mappedProp === "string" || typeof mappedProp === "boolean" || mappedProp === null) {
        node[prop] = mappedProp;
      } else if (typeof mappedProp === "object" && mappedProp instanceof Number) {
        node[prop] = Number(mappedProp);
      } else if (typeof mappedProp === "function") {
        node[prop] = mappedProp.call(this, children);
      } else if (mappedProp === void 0) {
        if (children[prop] && !children[prop].isTerminal()) {
          node[prop] = children[prop].toAST(mapping);
        } else {
          delete node[prop];
        }
      }
    }
    return node;
  },
  _iter(...children) {
    if (this._node.isOptional()) {
      if (this.numChildren === 0) {
        return null;
      } else {
        return children[0].toAST(this.args.mapping);
      }
    }
    return children.map(function(child) {
      return child.toAST(this.args.mapping);
    }, this);
  },
  NonemptyListOf(first, sep, rest) {
    return [first.toAST(this.args.mapping)].concat(rest.toAST(this.args.mapping));
  },
  EmptyListOf() {
    return [];
  }
};
function toAST(res, mapping) {
  if (typeof res.failed !== "function" || res.failed()) {
    throw new Error("toAST() expects a succesful MatchResult as first parameter");
  }
  mapping = Object.assign({}, mapping);
  const operation = Object.assign({}, defaultOperation);
  for (const termName in mapping) {
    if (typeof mapping[termName] === "function") {
      operation[termName] = mapping[termName];
      delete mapping[termName];
    }
  }
  const g2 = res._cst.grammar;
  const s2 = g2.createSemantics().addOperation("toAST(mapping)", operation);
  return s2(res).toAST(mapping);
}
function semanticsForToAST(g2) {
  if (typeof g2.createSemantics !== "function") {
    throw new Error("semanticsToAST() expects a Grammar as parameter");
  }
  return g2.createSemantics().addOperation("toAST(mapping)", defaultOperation);
}
var semanticsToAST = {
  helper: toAST,
  semantics: semanticsForToAST
};
var extras = {
  VisitorFamily: VisitorFamily_1,
  semanticsForToAST: semanticsToAST.semantics,
  toAST: semanticsToAST.helper
};
const ohm_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: ohm,
  extras
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(ohm_esm);
var parents = {};
var visit = {};
var nodes$1 = {};
var hasRequiredNodes$1;
function requireNodes$1() {
  if (hasRequiredNodes$1) return nodes$1;
  hasRequiredNodes$1 = 1;
  Object.defineProperty(nodes$1, "__esModule", { value: true });
  nodes$1.NumberExpr = nodes$1.NameExpr = nodes$1.RefExpr = nodes$1.NegateExpr = nodes$1.MathExpr = nodes$1.MathOperator = nodes$1.CombinatorExpr = nodes$1.BuiltinZeroArgs = nodes$1.BuiltinZeroArgsOperators = nodes$1.BuiltinOneArgExpr = nodes$1.BuiltinOneArgOperators = nodes$1.BuiltinExpr = nodes$1.CellRefExpr = nodes$1.CompareExpr = nodes$1.CompareOperator = nodes$1.CondExpr = nodes$1.Expression = nodes$1.Combinator = nodes$1.FieldExprDef = nodes$1.FieldNamedDef = nodes$1.FieldAnonymousDef = nodes$1.FieldCurlyExprDef = nodes$1.FieldBuiltinDef = nodes$1.FieldBuiltinType = nodes$1.Field = nodes$1.Constructor = nodes$1.Declaration = nodes$1.Program = nodes$1.ASTBase = nodes$1.ASTRootBase = void 0;
  class ASTRootBase {
  }
  nodes$1.ASTRootBase = ASTRootBase;
  ASTRootBase._attributes = [];
  class ASTBase extends ASTRootBase {
  }
  nodes$1.ASTBase = ASTBase;
  class Program extends ASTRootBase {
    constructor(declarations) {
      super();
      this.declarations = declarations;
      this.parent = null;
    }
  }
  nodes$1.Program = Program;
  Program._attributes = ["declarations"];
  class Declaration extends ASTBase {
    constructor(constructorDef, fields, combinator) {
      super();
      this.constructorDef = constructorDef;
      this.fields = fields;
      this.combinator = combinator;
    }
  }
  nodes$1.Declaration = Declaration;
  Declaration._attributes = ["constructorDef", "fields", "combinator"];
  class Constructor extends ASTBase {
    constructor(name, tag) {
      super();
      this.name = name;
      this.tag = tag;
    }
    getTagType() {
      if (this.tag === null) {
        return null;
      }
      return this.tag.startsWith("$") ? "binary" : "hex";
    }
  }
  nodes$1.Constructor = Constructor;
  class Field extends ASTBase {
  }
  nodes$1.Field = Field;
  nodes$1.FieldBuiltinType = ["#", "Type"];
  class FieldBuiltinDef extends Field {
    constructor(name, type) {
      super();
      this.name = name;
      this.type = type;
    }
  }
  nodes$1.FieldBuiltinDef = FieldBuiltinDef;
  class FieldCurlyExprDef extends Field {
    constructor(expr) {
      super();
      this.expr = expr;
    }
  }
  nodes$1.FieldCurlyExprDef = FieldCurlyExprDef;
  FieldCurlyExprDef._attributes = ["expr"];
  class FieldAnonymousDef extends Field {
    constructor(name, isRef, fields) {
      super();
      this.name = name;
      this.isRef = isRef;
      this.fields = fields;
    }
  }
  nodes$1.FieldAnonymousDef = FieldAnonymousDef;
  FieldAnonymousDef._attributes = ["fields"];
  class FieldNamedDef extends Field {
    constructor(name, expr) {
      super();
      this.name = name;
      this.expr = expr;
    }
  }
  nodes$1.FieldNamedDef = FieldNamedDef;
  FieldNamedDef._attributes = ["expr"];
  class FieldExprDef extends Field {
    constructor(expr) {
      super();
      this.expr = expr;
    }
  }
  nodes$1.FieldExprDef = FieldExprDef;
  FieldExprDef._attributes = ["expr"];
  class Combinator extends ASTBase {
    constructor(name, args) {
      super();
      this.name = name;
      this.args = args;
    }
  }
  nodes$1.Combinator = Combinator;
  Combinator._attributes = ["args"];
  class Expression extends ASTBase {
  }
  nodes$1.Expression = Expression;
  class CondExpr extends Expression {
    constructor(left, dotExpr, condExpr) {
      super();
      this.left = left;
      this.dotExpr = dotExpr;
      this.condExpr = condExpr;
    }
  }
  nodes$1.CondExpr = CondExpr;
  CondExpr._attributes = ["left", "condExpr"];
  nodes$1.CompareOperator = ["<=", ">=", "!=", "=", "<", ">"];
  class CompareExpr extends Expression {
    constructor(left, op, right) {
      super();
      this.left = left;
      this.op = op;
      this.right = right;
    }
  }
  nodes$1.CompareExpr = CompareExpr;
  CompareExpr._attributes = ["left", "right"];
  class CellRefExpr extends Expression {
    constructor(expr) {
      super();
      this.expr = expr;
    }
  }
  nodes$1.CellRefExpr = CellRefExpr;
  CellRefExpr._attributes = ["expr"];
  class BuiltinExpr extends Expression {
  }
  nodes$1.BuiltinExpr = BuiltinExpr;
  nodes$1.BuiltinOneArgOperators = ["#<=", "#<", "##"];
  class BuiltinOneArgExpr extends BuiltinExpr {
    constructor(name, arg) {
      super();
      this.name = name;
      this.arg = arg;
    }
  }
  nodes$1.BuiltinOneArgExpr = BuiltinOneArgExpr;
  BuiltinOneArgExpr._attributes = ["arg"];
  nodes$1.BuiltinZeroArgsOperators = ["#"];
  class BuiltinZeroArgs extends BuiltinExpr {
    constructor(name) {
      super();
      this.name = name;
    }
  }
  nodes$1.BuiltinZeroArgs = BuiltinZeroArgs;
  class CombinatorExpr extends Expression {
    constructor(name, args) {
      super();
      this.name = name;
      this.args = args;
    }
  }
  nodes$1.CombinatorExpr = CombinatorExpr;
  CombinatorExpr._attributes = ["args"];
  nodes$1.MathOperator = ["*", "+"];
  class MathExpr extends Expression {
    // TODO: narrower type for `left` and `right`?
    // TODO: use `SimpleExpr` and `number`?
    constructor(left, op, right) {
      super();
      this.left = left;
      this.op = op;
      this.right = right;
    }
  }
  nodes$1.MathExpr = MathExpr;
  MathExpr._attributes = ["left", "right"];
  class NegateExpr extends Expression {
    constructor(expr) {
      super();
      this.expr = expr;
    }
  }
  nodes$1.NegateExpr = NegateExpr;
  NegateExpr._attributes = ["expr"];
  class RefExpr extends Expression {
  }
  nodes$1.RefExpr = RefExpr;
  class NameExpr extends RefExpr {
    constructor(name) {
      super();
      this.name = name;
    }
  }
  nodes$1.NameExpr = NameExpr;
  class NumberExpr extends RefExpr {
    constructor(num) {
      super();
      this.num = num;
    }
  }
  nodes$1.NumberExpr = NumberExpr;
  return nodes$1;
}
var hasRequiredVisit;
function requireVisit() {
  if (hasRequiredVisit) return visit;
  hasRequiredVisit = 1;
  Object.defineProperty(visit, "__esModule", { value: true });
  visit.NodeVisitor = void 0;
  visit.iterChildNodes = iterChildNodes;
  visit.walk = walk;
  const nodes_1 = requireNodes$1();
  function* iterChildNodes(node) {
    const item = Object.getPrototypeOf(node).constructor;
    for (const attributeName of item._attributes) {
      const raw = node[attributeName];
      if (Array.isArray(raw)) {
        for (const child of raw) {
          yield child;
        }
      } else if (raw instanceof nodes_1.ASTRootBase) {
        yield raw;
      }
    }
  }
  function* walk(node) {
    const todo = [node];
    while (todo.length > 0) {
      const current = todo.shift();
      todo.push(...iterChildNodes(current));
      yield current;
    }
  }
  class NodeVisitor {
    visit(node) {
      const constructorName = node.constructor.name;
      const handlerName = `visit${constructorName}`;
      const handler = this[handlerName];
      if (typeof handler === "function") {
        return handler.call(this, node);
      } else {
        return this.genericVisit(node);
      }
    }
    genericVisit(node) {
      for (let attribute of iterChildNodes(node)) {
        this.visit(attribute);
      }
    }
  }
  visit.NodeVisitor = NodeVisitor;
  return visit;
}
var hasRequiredParents;
function requireParents() {
  if (hasRequiredParents) return parents;
  hasRequiredParents = 1;
  Object.defineProperty(parents, "__esModule", { value: true });
  parents.withParents = withParents;
  const visit_1 = requireVisit();
  function withParents(tree) {
    for (let parent of (0, visit_1.walk)(tree)) {
      for (let child of (0, visit_1.iterChildNodes)(parent)) {
        if (parent) {
          child.parent = parent;
        } else {
          child.parent = parent;
        }
      }
    }
    return tree;
  }
  return parents;
}
var tlb = {};
var hasRequiredTlb;
function requireTlb() {
  if (hasRequiredTlb) return tlb;
  hasRequiredTlb = 1;
  Object.defineProperty(tlb, "__esModule", { value: true });
  const grammar2 = String.raw`
TLB {
  // See:
  // https://github.com/andreypfau/TL-B-docs

  // Root definition
  Program = SourceElement*

  // Utilities
  // Override Ohm's built-in definition of space.
  space := whitespace | lineTerminator | comment

  whitespace =
    | "\t"
    | "\x0B"    -- verticalTab
    | "\x0C"    -- formFeed
    | " "
    | "\u00A0"  -- noBreakSpace
    | "\uFEFF"  -- byteOrderMark
    | "\u2000".."\u200B"
    | "\u3000"

  sourceCharacter = any
  lineTerminator = "\n" | "\r" | "\u2028" | "\u2029"

  // Comments
  comment = multiLineComment | singleLineComment
  multiLineComment = "/*" (~"*/" sourceCharacter)* "*/"
  singleLineComment = "//" (~lineTerminator sourceCharacter)*

  // Data types
  binaryDigit = "0" | "1"
  decimalDigit = "0".."9"
  hex = hexChar* "_"?
  hexChar = decimalDigit | letter

  // Identifiers
  identifier = identifierStart identifierPart*
  identifierStart = "_" | letter
  identifierPart = identifierStart | digit

  // Primitives
  number = digit+

  // Builtins
  builtins_one_arg = "#<=" | "#<" | "##"
  builtins_zero_args = "#"
  builtins_field = "#" | "Type"


  // ----------
  // Base rules
  // ----------
  SourceElement = Declaration | comment
  Declaration = Constructor Fields "=" Combinator ";"


  // Constructors
  // ~~~~~~~~~~~~
  Constructor = ConstructorStart ConstructorTag?
  ConstructorStart = "!"? ("_" | identifier)
  ConstructorTag =
  	| "$" ("_" | binaryDigit+)  -- binary
    | "#" ("_" | hex)           -- hex


  // Fields
  // ~~~~~~
  Fields = FieldDefinition*
  FieldDefinition =
    | FieldBuiltinDef
    | FieldCurlyExprDef
    | FieldAnonymousDef
    | FieldNamedDef
    | FieldExprDef

  FieldBuiltinDef = "{" identifier ":" builtins_field "}"
  FieldCurlyExprDef = "{" CurlyExpression "}"
  FieldAnonymousDef = FieldAnonRef | FieldNamedAnonRef
  FieldNamedDef = identifier ":" CondExpr
  FieldExprDef = CondExpr

  FieldAnonRef = "^"? "[" FieldDefinition* "]"
  FieldNamedAnonRef = identifier ":" FieldAnonRef


  // Combinators
  // ~~~~~~~~~~~

  Combinator = identifier SimpleExpr*


  // Expressions
  // ~~~~~~~~~~~

  // First come the complex rules we only use to define fields.
  // The line between fields definition and expressions is blury at this point.
  CurlyExpression = CompareExpr
  CondExpr =
    | CondDotAndQuestionExpr
    | CondQuestionExpr
    | CondTypeExpr

  CondDotted = TypeExpr "." number
  CondDotAndQuestionExpr = ( CondDotted | Parens<CondDotted> ) "?" TypeExpr
  CondQuestionExpr = TypeExpr "?" TypeExpr
  CondTypeExpr = TypeExpr

  // Compares:
  CompareExpr =
    | CompareOperatorExpr
    | Parens<CompareExpr>
    | MathExpr

  CompareOperatorExpr =
    | MathExpr "<=" MathExpr
    | MathExpr ">=" MathExpr
    | MathExpr "!=" MathExpr
    | MathExpr "=" MathExpr
    | MathExpr "<" MathExpr
    | MathExpr ">" MathExpr

  // Base rule for field defining expressions:
  TypeExpr =
    | CellRefExpr
    | BuiltinExpr
    | CombinatorExpr
    | SimpleExpr
    | Parens<TypeExpr>

  // Math:
  MathExpr = MulExpr ("+" MulExpr)*
  // You can multiply by constant values only: 'Bit' and numbers, basically
  MulExpr = SimpleExpr ("*" RefExpr)*

  // TypeExpr's items:
  CellRefExpr = "^" ( CellRefInner | Parens<CellRefInner> )
  CellRefInner = TypeExpr

  BuiltinExpr = BuiltinOneArg | BuiltinZeroArgs
  // This needs extra 'Parens' because of '(##)' expr:
  BuiltinOneArg = "(" ( builtins_one_arg | Parens<builtins_one_arg> ) RefExpr ")"
  BuiltinZeroArgs = builtins_zero_args

  // It is different from 'Combinator' only in the quantity part:
  // we always need at least one argument here and it can be complex.
  CombinatorExpr = "(" identifier TypeExpr+ ")"

  SimpleExpr =
    | NegateExpr
    | MathExpr
    | RefExpr
    | Parens<SimpleExpr>

  NegateExpr = "~" SimpleExpr
  RefExpr = RefInner | Parens<RefInner>
  RefInner = identifier | number


  // Helpers
  // ~~~~~~~

  // Generic rule to allow parens around some expressions:
  Parens<expr> = "(" expr ")"
}
`;
  tlb.default = grammar2;
  return tlb;
}
var parsing = {};
var locations = {};
var hasRequiredLocations;
function requireLocations() {
  if (hasRequiredLocations) return locations;
  hasRequiredLocations = 1;
  Object.defineProperty(locations, "__esModule", { value: true });
  locations.withLocations = withLocations;
  function withLocations(astNode, intermediateNode) {
    const lineAndColumn = intermediateNode.source.getLineAndColumn();
    astNode.locations = {
      line: lineAndColumn.lineNum,
      column: lineAndColumn.colNum
    };
    return astNode;
  }
  return locations;
}
var hasRequiredParsing;
function requireParsing() {
  if (hasRequiredParsing) return parsing;
  hasRequiredParsing = 1;
  var __createBinding = parsing && parsing.__createBinding || (Object.create ? (function(o4, m2, k2, k22) {
    if (k22 === void 0) k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o4, k22, desc);
  }) : (function(o4, m2, k2, k22) {
    if (k22 === void 0) k22 = k2;
    o4[k22] = m2[k2];
  }));
  var __setModuleDefault = parsing && parsing.__setModuleDefault || (Object.create ? (function(o4, v2) {
    Object.defineProperty(o4, "default", { enumerable: true, value: v2 });
  }) : function(o4, v2) {
    o4["default"] = v2;
  });
  var __importStar = parsing && parsing.__importStar || /* @__PURE__ */ (function() {
    var ownKeys = function(o4) {
      ownKeys = Object.getOwnPropertyNames || function(o5) {
        var ar = [];
        for (var k2 in o5) if (Object.prototype.hasOwnProperty.call(o5, k2)) ar[ar.length] = k2;
        return ar;
      };
      return ownKeys(o4);
    };
    return function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 = ownKeys(mod), i = 0; i < k2.length; i++) if (k2[i] !== "default") __createBinding(result, mod, k2[i]);
      }
      __setModuleDefault(result, mod);
      return result;
    };
  })();
  Object.defineProperty(parsing, "__esModule", { value: true });
  parsing.exprNodes = parsing.combinatorNodes = parsing.fieldNodes = parsing.constructorNodes = parsing.rootNodes = void 0;
  const ast2 = __importStar(requireNodes$1());
  const locations_1 = requireLocations();
  parsing.rootNodes = {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Program(node) {
      return (0, locations_1.withLocations)(new ast2.Program(node.children.map((child) => child["root"]())), node);
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    SourceElement(node) {
      return (0, locations_1.withLocations)(new ast2.Declaration(node.child(0)["Constructor"](), node.child(1)["Field"](), node.child(3)["Combinator"]()), node);
    }
  };
  parsing.constructorNodes = {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Constructor(name, tag) {
      const nameValue = name.sourceString;
      let tagValue = null;
      if (tag.numChildren !== 0) {
        tagValue = tag.child(0)["Constructor"]();
      }
      return (0, locations_1.withLocations)(new ast2.Constructor(nameValue, tagValue), name);
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ConstructorTag(node) {
      return node.sourceString;
    }
  };
  parsing.fieldNodes = {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Fields(node) {
      return node.children.map((child) => child["Field"]());
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    FieldDefinition(node) {
      return node["Field"]();
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    FieldBuiltinDef(lpar, name, _sep, type, _rpar) {
      return (0, locations_1.withLocations)(new ast2.FieldBuiltinDef(name.sourceString, type.sourceString), lpar);
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    FieldCurlyExprDef(lpar, expr, _rpar) {
      return (0, locations_1.withLocations)(new ast2.FieldCurlyExprDef(expr["expr"]()), lpar);
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    FieldAnonymousDef(node) {
      const { name, isRef, fields } = node["Field"]();
      return (0, locations_1.withLocations)(new ast2.FieldAnonymousDef(name, isRef, fields), node);
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    FieldNamedDef(name, _sep, expr) {
      return (0, locations_1.withLocations)(new ast2.FieldNamedDef(name.sourceString, expr["expr"]()), name);
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    FieldExprDef(node) {
      return (0, locations_1.withLocations)(new ast2.FieldExprDef(node["expr"]()), node);
    },
    // Helpers to parse complex anonymous fields:
    // TODO: move out of this semantics
    FieldAnonRef(ref, _lpar, fields, _rpar) {
      return {
        name: null,
        isRef: ref.numChildren !== 0,
        fields: fields.children.map((field) => field["Field"]())
      };
    },
    FieldNamedAnonRef(name, _sep, fields) {
      return Object.assign(Object.assign({}, fields["Field"]()), { name: name.sourceString });
    }
  };
  parsing.combinatorNodes = {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Combinator(name, exprs) {
      return (0, locations_1.withLocations)(new ast2.Combinator(name.sourceString, exprs.children.map((typeExpr) => typeExpr["expr"]())), name);
    }
  };
  parsing.exprNodes = {
    // Math
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    MathExpr(left, ops, rights) {
      return parseMath(left, ops, rights);
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    MulExpr(left, ops, rights) {
      return parseMath(left, ops, rights);
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    CompareExpr(node) {
      return node["expr"]();
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    CompareOperatorExpr(left, op, right) {
      return (0, locations_1.withLocations)(new ast2.CompareExpr(left["expr"](), op.sourceString, right["expr"]()), op);
    },
    // Conditional types
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    CondExpr(expr) {
      const { leftExpr, dotExpr, condExpr } = expr["expr"]();
      if (dotExpr === void 0 && condExpr === void 0) {
        return leftExpr;
      }
      return (0, locations_1.withLocations)(new ast2.CondExpr(leftExpr, dotExpr, condExpr), expr);
    },
    // TODO: move out of this semantics
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    CondDotAndQuestionExpr(dotNode, _sep, condNode) {
      return Object.assign(Object.assign({}, dotNode["expr"]()), { condExpr: condNode["expr"]() });
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    CondQuestionExpr(left, _sep, condNode) {
      return {
        leftExpr: left["expr"](),
        dotExpr: null,
        condExpr: condNode["expr"]()
      };
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    CondTypeExpr(node) {
      return {
        leftExpr: node["expr"]()
      };
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    CondDotted(left, _sep, number) {
      return {
        leftExpr: left["expr"](),
        dotExpr: new Number(number.sourceString)
      };
    },
    // TypeExpr
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    CombinatorExpr(lpar, name, args, _rpar) {
      return (0, locations_1.withLocations)(new ast2.CombinatorExpr(name.sourceString, args.children.map((arg) => arg["expr"]())), lpar);
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    CellRefExpr(ref, node) {
      return (0, locations_1.withLocations)(new ast2.CellRefExpr(node["expr"]()), ref);
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    BuiltinExpr(node) {
      return (0, locations_1.withLocations)(node["expr"](), node);
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    NegateExpr(op, node) {
      return (0, locations_1.withLocations)(new ast2.NegateExpr(node["expr"]()), op);
    },
    // Builtins
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    BuiltinOneArg(lpar, expr, arg, _rpar) {
      return (0, locations_1.withLocations)(new ast2.BuiltinOneArgExpr(expr.sourceString, arg["expr"]()), lpar);
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    BuiltinZeroArgs(expr) {
      return (0, locations_1.withLocations)(new ast2.BuiltinZeroArgs(expr.sourceString), expr);
    },
    // Base rules
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    identifier(start, rest) {
      return (0, locations_1.withLocations)(new ast2.NameExpr(start.sourceString + rest.sourceString), start);
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    number(node) {
      return (0, locations_1.withLocations)(new ast2.NumberExpr(parseInt(node.sourceString)), node);
    },
    // Helpers
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Parens(lpar, node, _rpar) {
      return (0, locations_1.withLocations)(node["expr"](), lpar);
    }
  };
  function parseMath(left, ops, rights) {
    const leftExpr = left["expr"]();
    const opsSigns = [];
    for (let child of ops.children) {
      opsSigns.push(child.sourceString);
    }
    const rightExprs = [];
    for (let child of rights.children) {
      const rightExpr = child["expr"]();
      if (rightExpr !== void 0) {
        rightExprs.push(rightExpr);
      }
    }
    if (opsSigns.length !== rightExprs.length) {
      throw new Error("Invalid math operation");
    }
    if (opsSigns.length === 0) {
      return (0, locations_1.withLocations)(leftExpr, left);
    }
    let expr = (0, locations_1.withLocations)(new ast2.MathExpr(leftExpr, opsSigns[0], rightExprs[0]), left);
    for (let index = 1; index < opsSigns.length; index++) {
      expr = (0, locations_1.withLocations)(new ast2.MathExpr(
        expr,
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        opsSigns[index],
        // validated earlier
        rightExprs[index]
      ), left);
    }
    return expr;
  }
  return parsing;
}
var hasRequiredIntermediate;
function requireIntermediate() {
  if (hasRequiredIntermediate) return intermediate;
  hasRequiredIntermediate = 1;
  var __importDefault = intermediate && intermediate.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(intermediate, "__esModule", { value: true });
  intermediate.buildGrammar = buildGrammar2;
  intermediate.buildAST = buildAST;
  const ohm_js_1 = __importDefault(require$$0$1);
  const parents_1 = requireParents();
  const tlb_1 = __importDefault(requireTlb());
  const parsing_1 = requireParsing();
  function buildGrammar2() {
    return ohm_js_1.default.grammar(tlb_1.default);
  }
  function buildAST(input, grammar2) {
    const semantics = grammar2.createSemantics();
    semantics.addOperation("root", parsing_1.rootNodes);
    semantics.addOperation("Constructor", parsing_1.constructorNodes);
    semantics.addOperation("Field", parsing_1.fieldNodes);
    semantics.addOperation("Combinator", parsing_1.combinatorNodes);
    semantics.addOperation("expr", parsing_1.exprNodes);
    const matchResult = grammar2.match(input);
    const ast2 = semantics(matchResult)["root"]();
    return (0, parents_1.withParents)(ast2);
  }
  return intermediate;
}
var hasRequiredDist$3;
function requireDist$3() {
  if (hasRequiredDist$3) return dist$2;
  hasRequiredDist$3 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MathOperator = exports.BuiltinZeroArgsOperators = exports.BuiltinOneArgOperators = exports.CompareOperator = exports.FieldBuiltinType = exports.NumberExpr = exports.NameExpr = exports.RefExpr = exports.NegateExpr = exports.MathExpr = exports.CombinatorExpr = exports.BuiltinZeroArgs = exports.BuiltinOneArgExpr = exports.BuiltinExpr = exports.CellRefExpr = exports.CompareExpr = exports.CondExpr = exports.Expression = exports.Combinator = exports.FieldExprDef = exports.FieldNamedDef = exports.FieldAnonymousDef = exports.FieldCurlyExprDef = exports.FieldBuiltinDef = exports.Field = exports.Constructor = exports.Declaration = exports.Program = exports.ASTBase = exports.ASTRootBase = exports.NodeVisitor = void 0;
    exports.parse = parse;
    exports.ast = ast2;
    const intermediate_1 = requireIntermediate();
    function parse(input, grammar2 = void 0) {
      if (grammar2 === void 0) {
        grammar2 = (0, intermediate_1.buildGrammar)();
      }
      return grammar2.match(input);
    }
    function ast2(input) {
      return (0, intermediate_1.buildAST)(input, (0, intermediate_1.buildGrammar)());
    }
    var visit_1 = requireVisit();
    Object.defineProperty(exports, "NodeVisitor", { enumerable: true, get: function() {
      return visit_1.NodeVisitor;
    } });
    var nodes_1 = requireNodes$1();
    Object.defineProperty(exports, "ASTRootBase", { enumerable: true, get: function() {
      return nodes_1.ASTRootBase;
    } });
    Object.defineProperty(exports, "ASTBase", { enumerable: true, get: function() {
      return nodes_1.ASTBase;
    } });
    Object.defineProperty(exports, "Program", { enumerable: true, get: function() {
      return nodes_1.Program;
    } });
    Object.defineProperty(exports, "Declaration", { enumerable: true, get: function() {
      return nodes_1.Declaration;
    } });
    Object.defineProperty(exports, "Constructor", { enumerable: true, get: function() {
      return nodes_1.Constructor;
    } });
    Object.defineProperty(exports, "Field", { enumerable: true, get: function() {
      return nodes_1.Field;
    } });
    Object.defineProperty(exports, "FieldBuiltinDef", { enumerable: true, get: function() {
      return nodes_1.FieldBuiltinDef;
    } });
    Object.defineProperty(exports, "FieldCurlyExprDef", { enumerable: true, get: function() {
      return nodes_1.FieldCurlyExprDef;
    } });
    Object.defineProperty(exports, "FieldAnonymousDef", { enumerable: true, get: function() {
      return nodes_1.FieldAnonymousDef;
    } });
    Object.defineProperty(exports, "FieldNamedDef", { enumerable: true, get: function() {
      return nodes_1.FieldNamedDef;
    } });
    Object.defineProperty(exports, "FieldExprDef", { enumerable: true, get: function() {
      return nodes_1.FieldExprDef;
    } });
    Object.defineProperty(exports, "Combinator", { enumerable: true, get: function() {
      return nodes_1.Combinator;
    } });
    Object.defineProperty(exports, "Expression", { enumerable: true, get: function() {
      return nodes_1.Expression;
    } });
    Object.defineProperty(exports, "CondExpr", { enumerable: true, get: function() {
      return nodes_1.CondExpr;
    } });
    Object.defineProperty(exports, "CompareExpr", { enumerable: true, get: function() {
      return nodes_1.CompareExpr;
    } });
    Object.defineProperty(exports, "CellRefExpr", { enumerable: true, get: function() {
      return nodes_1.CellRefExpr;
    } });
    Object.defineProperty(exports, "BuiltinExpr", { enumerable: true, get: function() {
      return nodes_1.BuiltinExpr;
    } });
    Object.defineProperty(exports, "BuiltinOneArgExpr", { enumerable: true, get: function() {
      return nodes_1.BuiltinOneArgExpr;
    } });
    Object.defineProperty(exports, "BuiltinZeroArgs", { enumerable: true, get: function() {
      return nodes_1.BuiltinZeroArgs;
    } });
    Object.defineProperty(exports, "CombinatorExpr", { enumerable: true, get: function() {
      return nodes_1.CombinatorExpr;
    } });
    Object.defineProperty(exports, "MathExpr", { enumerable: true, get: function() {
      return nodes_1.MathExpr;
    } });
    Object.defineProperty(exports, "NegateExpr", { enumerable: true, get: function() {
      return nodes_1.NegateExpr;
    } });
    Object.defineProperty(exports, "RefExpr", { enumerable: true, get: function() {
      return nodes_1.RefExpr;
    } });
    Object.defineProperty(exports, "NameExpr", { enumerable: true, get: function() {
      return nodes_1.NameExpr;
    } });
    Object.defineProperty(exports, "NumberExpr", { enumerable: true, get: function() {
      return nodes_1.NumberExpr;
    } });
    Object.defineProperty(exports, "FieldBuiltinType", { enumerable: true, get: function() {
      return nodes_1.FieldBuiltinType;
    } });
    Object.defineProperty(exports, "CompareOperator", { enumerable: true, get: function() {
      return nodes_1.CompareOperator;
    } });
    Object.defineProperty(exports, "BuiltinOneArgOperators", { enumerable: true, get: function() {
      return nodes_1.BuiltinOneArgOperators;
    } });
    Object.defineProperty(exports, "BuiltinZeroArgsOperators", { enumerable: true, get: function() {
      return nodes_1.BuiltinZeroArgsOperators;
    } });
    Object.defineProperty(exports, "MathOperator", { enumerable: true, get: function() {
      return nodes_1.MathOperator;
    } });
  })(dist$2);
  return dist$2;
}
var fill_constructors = {};
var utils$4 = {};
var hasRequiredUtils$4;
function requireUtils$4() {
  if (hasRequiredUtils$4) return utils$4;
  hasRequiredUtils$4 = 1;
  Object.defineProperty(utils$4, "__esModule", { value: true });
  utils$4.crc32 = utils$4.getSubStructName = utils$4.findNotReservedName = utils$4.isNameReserved = utils$4.bitLen = utils$4.getCurrentSlice = utils$4.firstLower = void 0;
  function firstLower(structName) {
    return structName.charAt(0).toLowerCase() + structName.slice(1);
  }
  utils$4.firstLower = firstLower;
  function getCurrentSlice(slicePrefix, name) {
    let result = name;
    slicePrefix = slicePrefix.slice(0, slicePrefix.length - 1);
    slicePrefix.forEach((element) => {
      result += element.toString();
    });
    if (result == "cell") {
      return "builder";
    }
    return result;
  }
  utils$4.getCurrentSlice = getCurrentSlice;
  function bitLen(n) {
    return n.toString(2).length;
  }
  utils$4.bitLen = bitLen;
  function isNameReserved(name) {
    let tsReserved = [
      "abstract",
      "arguments",
      "await",
      "boolean",
      "break",
      "byte",
      "case",
      "catch",
      "char",
      "class",
      "const",
      "continue",
      "debugger",
      "default",
      "delete",
      "do",
      "double",
      "else",
      "enum",
      "eval",
      "export",
      "extends",
      "false",
      "final",
      "finally",
      "float",
      "for",
      "function",
      "goto",
      "if",
      "implements",
      "import",
      "in",
      "instanceof",
      "int",
      "interface",
      "let",
      "long",
      "native",
      "new",
      "null",
      "package",
      "private",
      "protected",
      "public",
      "return",
      "short",
      "static",
      "super",
      "switch",
      "synchronized",
      "this",
      "throw",
      "throws",
      "transient",
      "true",
      "try",
      "typeof",
      "var",
      "void",
      "volatile",
      "while",
      "with",
      "yield"
    ];
    if (tsReserved.includes(name)) {
      return true;
    }
    if (name.startsWith("slice")) {
      return true;
    }
    if (name.startsWith("cell")) {
      return true;
    }
    if (name == "builder") {
      return true;
    }
    return false;
  }
  utils$4.isNameReserved = isNameReserved;
  function findNotReservedName(name, possibleSuffix = "0") {
    if (name.startsWith("slice") || name.startsWith("cell")) {
      name = "_" + name;
    }
    while (isNameReserved(name)) {
      name += possibleSuffix;
    }
    return name;
  }
  utils$4.findNotReservedName = findNotReservedName;
  function getSubStructName(tlbType, constructor) {
    if (tlbType.constructors.length > 1) {
      return tlbType.name + "_" + constructor.name;
    } else {
      return tlbType.name;
    }
  }
  utils$4.getSubStructName = getSubStructName;
  const POLYNOMIAL = -306674912;
  function crc32(bytes, crc = 4294967295) {
    let result = crc;
    for (let n = 0; n < bytes.length; n++) {
      result ^= bytes[n];
      result = result & 1 ? result >>> 1 ^ POLYNOMIAL : result >>> 1;
      result = result & 1 ? result >>> 1 ^ POLYNOMIAL : result >>> 1;
      result = result & 1 ? result >>> 1 ^ POLYNOMIAL : result >>> 1;
      result = result & 1 ? result >>> 1 ^ POLYNOMIAL : result >>> 1;
      result = result & 1 ? result >>> 1 ^ POLYNOMIAL : result >>> 1;
      result = result & 1 ? result >>> 1 ^ POLYNOMIAL : result >>> 1;
      result = result & 1 ? result >>> 1 ^ POLYNOMIAL : result >>> 1;
      result = result & 1 ? result >>> 1 ^ POLYNOMIAL : result >>> 1;
    }
    return (result ^ -1) >>> 0;
  }
  utils$4.crc32 = crc32;
  return utils$4;
}
var handle_field = {};
var handle_type = {};
var utils$3 = {};
var hasRequiredUtils$3;
function requireUtils$3() {
  if (hasRequiredUtils$3) return utils$3;
  hasRequiredUtils$3 = 1;
  Object.defineProperty(utils$3, "__esModule", { value: true });
  utils$3.convertToMathExpr = utils$3.getNegatedVariable = utils$3.reorganizeExpression = utils$3.getVariableName = utils$3.deriveMathExpression = utils$3.splitForTypeValue = utils$3.getCalculatedExpression = utils$3.calculateVariable = utils$3.opCodeSetsEqual = void 0;
  const tlb_parser_1 = requireDist$3();
  const ast_1 = requireAst();
  function opCodeSetsEqual(a2, b2) {
    if (a2 === b2)
      return true;
    if (a2 == null || b2 == null)
      return false;
    if (a2.length !== b2.length)
      return false;
    a2 = a2.sort();
    b2 = b2.sort();
    for (var i = 0; i < a2.length; ++i) {
      if (a2[i] !== b2[i])
        return false;
    }
    return true;
  }
  utils$3.opCodeSetsEqual = opCodeSetsEqual;
  function calculateVariable(variable, constructor) {
    if (variable.calculated) {
      return;
    }
    if (!variable.deriveExpr) {
      return;
    }
    variable.calculated = true;
    variable.deriveExpr = getCalculatedExpression(variable.deriveExpr, constructor);
  }
  utils$3.calculateVariable = calculateVariable;
  function getCalculatedExpression(expr, constructor) {
    if (expr instanceof ast_1.TLBVarExpr) {
      let variable = constructor.variablesMap.get(expr.x);
      if (variable) {
        calculateVariable(variable, constructor);
        if (variable.deriveExpr) {
          return variable.deriveExpr;
        }
      }
    }
    if (expr instanceof ast_1.TLBBinaryOp) {
      let left = getCalculatedExpression(expr.left, constructor);
      let right = getCalculatedExpression(expr.right, constructor);
      return new ast_1.TLBBinaryOp(left, right, expr.operation, expr.variables, expr.hasNeg);
    }
    return expr;
  }
  utils$3.getCalculatedExpression = getCalculatedExpression;
  function splitForTypeValue(name, typeName) {
    if (!name.startsWith(typeName)) {
      return void 0;
    }
    let num = parseInt(name.slice(typeName.length));
    if (num == void 0) {
      return void 0;
    }
    if (name != typeName + num.toString()) {
      return void 0;
    }
    return num;
  }
  utils$3.splitForTypeValue = splitForTypeValue;
  function deriveMathExpression(mathExpr) {
    let myMathExpr = convertToMathExpr(mathExpr);
    return {
      name: getVariableName(myMathExpr),
      derived: myMathExpr
    };
  }
  utils$3.deriveMathExpression = deriveMathExpression;
  function getVariableName(myMathExpr) {
    if (myMathExpr instanceof ast_1.TLBVarExpr) {
      return myMathExpr.x;
    }
    if (myMathExpr instanceof ast_1.TLBBinaryOp) {
      if (myMathExpr.left.variables.size) {
        return getVariableName(myMathExpr.left);
      } else {
        return getVariableName(myMathExpr.right);
      }
    }
    return void 0;
  }
  utils$3.getVariableName = getVariableName;
  function reorganizeExpression(mathExpr, variable) {
    if (mathExpr instanceof ast_1.TLBBinaryOp && mathExpr.operation == "=") {
      if (mathExpr.left.variables.has(variable)) {
        mathExpr = new ast_1.TLBBinaryOp(mathExpr.right, mathExpr.left, "=", mathExpr.variables, mathExpr.hasNeg);
      }
      if (mathExpr.right instanceof ast_1.TLBVarExpr) {
        return new ast_1.TLBBinaryOp(mathExpr.right, mathExpr.left, "=", mathExpr.variables, mathExpr.hasNeg);
      }
      let rightSide = mathExpr.right;
      if (rightSide instanceof ast_1.TLBBinaryOp) {
        let op = "";
        if (rightSide.operation == "*") {
          op = "/";
        } else if (rightSide.operation == "+") {
          op = "-";
        } else {
          throw new Error("invalid operation");
        }
        let withVariable = void 0;
        let other = void 0;
        if (rightSide.left.variables.has(variable)) {
          withVariable = rightSide.left;
          other = rightSide.right;
        } else {
          other = rightSide.left;
          withVariable = rightSide.right;
        }
        let leftSide = new ast_1.TLBBinaryOp(mathExpr.left, other, op);
        mathExpr = new ast_1.TLBBinaryOp(leftSide, withVariable, "=", /* @__PURE__ */ new Set([...leftSide.variables, ...withVariable.variables]), leftSide.hasNeg || rightSide.hasNeg);
        return reorganizeExpression(mathExpr, variable);
      }
    }
    throw new Error(`Couldn't reogranize expression: ${mathExpr}`);
  }
  utils$3.reorganizeExpression = reorganizeExpression;
  function getNegatedVariable(mathExpr) {
    if (mathExpr.hasNeg) {
      if (mathExpr instanceof ast_1.TLBBinaryOp) {
        if (mathExpr.left.hasNeg) {
          return getNegatedVariable(mathExpr.left);
        }
        if (mathExpr.right.hasNeg) {
          return getNegatedVariable(mathExpr.right);
        }
      }
      if (mathExpr instanceof ast_1.TLBVarExpr) {
        return mathExpr.x;
      }
    }
    return void 0;
  }
  utils$3.getNegatedVariable = getNegatedVariable;
  function convertToMathExpr(mathExpr, negated = false) {
    if (mathExpr instanceof tlb_parser_1.NameExpr) {
      let variables = /* @__PURE__ */ new Set();
      variables.add(mathExpr.name);
      return new ast_1.TLBVarExpr(mathExpr.name, variables, negated);
    }
    if (mathExpr instanceof tlb_parser_1.NumberExpr) {
      return new ast_1.TLBNumberExpr(mathExpr.num, /* @__PURE__ */ new Set(), false);
    }
    if (mathExpr instanceof tlb_parser_1.MathExpr) {
      let left = convertToMathExpr(mathExpr.left, negated);
      let right = convertToMathExpr(mathExpr.right, negated);
      return new ast_1.TLBBinaryOp(left, right, mathExpr.op);
    }
    if (mathExpr instanceof tlb_parser_1.CompareExpr) {
      let left = convertToMathExpr(mathExpr.left, negated);
      let right = convertToMathExpr(mathExpr.right, negated);
      let operation = mathExpr.op;
      return new ast_1.TLBBinaryOp(left, right, operation);
    }
    if (mathExpr instanceof tlb_parser_1.NegateExpr) {
      if (mathExpr.expr instanceof tlb_parser_1.MathExpr || mathExpr.expr instanceof tlb_parser_1.NameExpr || mathExpr.expr instanceof tlb_parser_1.NumberExpr) {
        let expression = convertToMathExpr(mathExpr.expr, true);
        if (expression instanceof ast_1.TLBBinaryOp) {
          return new ast_1.TLBBinaryOp(expression.left, expression.right, expression.operation, expression.variables, true);
        }
        if (expression instanceof ast_1.TLBVarExpr) {
          return new ast_1.TLBVarExpr(expression.x, expression.variables, true);
        }
        if (expression instanceof ast_1.TLBNumberExpr) {
          return new ast_1.TLBNumberExpr(expression.n, expression.variables, true);
        }
      }
    }
    throw new Error(`Could not convert expression: ${mathExpr}`);
  }
  utils$3.convertToMathExpr = convertToMathExpr;
  return utils$3;
}
var hasRequiredHandle_type;
function requireHandle_type() {
  if (hasRequiredHandle_type) return handle_type;
  hasRequiredHandle_type = 1;
  Object.defineProperty(handle_type, "__esModule", { value: true });
  handle_type.getType = void 0;
  const tlb_parser_1 = requireDist$3();
  const ast_1 = requireAst();
  const utils_1 = requireUtils$3();
  function getType(expr, constructor, fieldTypeName) {
    var _a2;
    if (expr instanceof tlb_parser_1.BuiltinZeroArgs) {
      if (expr.name == "#") {
        return {
          kind: "TLBNumberType",
          bits: new ast_1.TLBNumberExpr(32),
          storeBits: new ast_1.TLBNumberExpr(32),
          signed: false,
          maxBits: 32
        };
      } else {
        throw new Error("Expression not supported" + expr);
      }
    } else if (expr instanceof tlb_parser_1.BuiltinOneArgExpr) {
      if (expr.name.toString() == "##" || expr.name.toString() == "(##)") {
        if (expr.arg instanceof tlb_parser_1.NumberExpr) {
          return {
            kind: "TLBNumberType",
            bits: new ast_1.TLBNumberExpr(expr.arg.num),
            storeBits: new ast_1.TLBNumberExpr(expr.arg.num),
            signed: false,
            maxBits: expr.arg.num
          };
        }
        if (expr.arg instanceof tlb_parser_1.NameExpr) {
          let parameter = constructor.parametersMap.get(expr.arg.name);
          if (!parameter || !parameter.variable.deriveExpr || !parameter.variable.initialExpr) {
            throw new Error(`Couldn't handle expression ${expr}`);
          }
          return {
            kind: "TLBNumberType",
            bits: (0, utils_1.getCalculatedExpression)(parameter.variable.deriveExpr, constructor),
            storeBits: parameter.variable.initialExpr,
            signed: false,
            maxBits: void 0
          };
        } else {
          throw new Error(`Couldn't handle expression ${expr}`);
        }
      } else if (expr.name == "#<") {
        if (expr.arg instanceof tlb_parser_1.NumberExpr || expr.arg instanceof tlb_parser_1.NameExpr) {
          let bits = new ast_1.TLBUnaryOp(new ast_1.TLBBinaryOp((0, utils_1.getCalculatedExpression)((0, utils_1.convertToMathExpr)(expr.arg), constructor), new ast_1.TLBNumberExpr(1), "-"), ".");
          return {
            kind: "TLBNumberType",
            bits,
            storeBits: bits,
            signed: false,
            maxBits: 32
          };
        } else {
          throw new Error(`Couldn't handle expression ${expr}`);
        }
      } else if (expr.name == "#<=") {
        if (expr.arg instanceof tlb_parser_1.NumberExpr || expr.arg instanceof tlb_parser_1.NameExpr) {
          let bits = new ast_1.TLBUnaryOp((0, utils_1.getCalculatedExpression)((0, utils_1.convertToMathExpr)(expr.arg), constructor), ".");
          return {
            kind: "TLBNumberType",
            bits,
            storeBits: bits,
            signed: false,
            maxBits: 32
          };
        } else {
          throw new Error(`Couldn't handle expression ${expr}`);
        }
      }
    } else if (expr instanceof tlb_parser_1.CombinatorExpr) {
      if (expr.name == "int" && expr.args.length == 1 && (expr.args[0] instanceof tlb_parser_1.MathExpr || expr.args[0] instanceof tlb_parser_1.NumberExpr || expr.args[0] instanceof tlb_parser_1.NameExpr)) {
        return {
          kind: "TLBNumberType",
          bits: (0, utils_1.getCalculatedExpression)((0, utils_1.convertToMathExpr)(expr.args[0]), constructor),
          storeBits: (0, utils_1.convertToMathExpr)(expr.args[0]),
          signed: true,
          maxBits: void 0
        };
      } else if (expr.name == "uint" && expr.args.length == 1 && (expr.args[0] instanceof tlb_parser_1.MathExpr || expr.args[0] instanceof tlb_parser_1.NumberExpr || expr.args[0] instanceof tlb_parser_1.NameExpr)) {
        return {
          kind: "TLBNumberType",
          bits: (0, utils_1.getCalculatedExpression)((0, utils_1.convertToMathExpr)(expr.args[0]), constructor),
          storeBits: (0, utils_1.convertToMathExpr)(expr.args[0]),
          signed: false,
          maxBits: void 0
        };
      } else if (expr.name == "bits" && expr.args.length == 1 && (expr.args[0] instanceof tlb_parser_1.MathExpr || expr.args[0] instanceof tlb_parser_1.NumberExpr || expr.args[0] instanceof tlb_parser_1.NameExpr)) {
        return {
          kind: "TLBBitsType",
          bits: (0, utils_1.getCalculatedExpression)((0, utils_1.convertToMathExpr)(expr.args[0]), constructor)
        };
      } else if (expr.name == "HashmapE") {
        if (expr.args.length != 2) {
          throw new Error("");
        }
        let key2 = getType(expr.args[0], constructor, fieldTypeName);
        let value = getType(expr.args[1], constructor, fieldTypeName);
        if (key2.kind != "TLBExprMathType") {
          throw new Error("Hashmap key should be number");
        }
        return { kind: "TLBHashmapType", key: key2, value, directStore: false };
      } else if (expr.name == "HashmapAugE") {
        if (expr.args.length != 3) {
          throw new Error("Not enough arguments for HashmapAugE");
        }
        let key2 = getType(expr.args[0], constructor, fieldTypeName);
        let value = getType(expr.args[1], constructor, fieldTypeName);
        let extra = getType(expr.args[2], constructor, fieldTypeName);
        if (key2.kind != "TLBExprMathType") {
          throw new Error("Hashmap key should be number");
        }
        return { kind: "TLBHashmapType", key: key2, value, extra, directStore: false };
      } else if (expr.name == "Hashmap" && constructor.tlbType != "HashmapNode") {
        let key2 = getType(expr.args[0], constructor, fieldTypeName);
        let value = getType(expr.args[1], constructor, fieldTypeName);
        if (key2.kind != "TLBExprMathType") {
          throw new Error("Hashmap key should be number");
        }
        return { kind: "TLBHashmapType", key: key2, value, directStore: true };
      } else if (expr.name == "VarUInteger" && (expr.args[0] instanceof tlb_parser_1.MathExpr || expr.args[0] instanceof tlb_parser_1.NumberExpr || expr.args[0] instanceof tlb_parser_1.NameExpr)) {
        return {
          kind: "TLBVarIntegerType",
          n: new ast_1.TLBUnaryOp(new ast_1.TLBBinaryOp((0, utils_1.convertToMathExpr)(expr.args[0]), new ast_1.TLBNumberExpr(1), "-"), "."),
          signed: false
        };
      } else if (expr.name == "VarInteger" && (expr.args[0] instanceof tlb_parser_1.MathExpr || expr.args[0] instanceof tlb_parser_1.NumberExpr || expr.args[0] instanceof tlb_parser_1.NameExpr)) {
        return {
          kind: "TLBVarIntegerType",
          n: (0, utils_1.convertToMathExpr)(expr.args[0]),
          signed: true
        };
      } else {
        let argumentTypes = [];
        expr.args.forEach((arg) => {
          let thefield = getType(arg, constructor, fieldTypeName);
          argumentTypes.push(thefield);
        });
        return {
          kind: "TLBNamedType",
          name: expr.name,
          arguments: argumentTypes
        };
      }
    } else if (expr instanceof tlb_parser_1.NameExpr) {
      let theNum;
      if (expr.name == "Int") {
        return {
          kind: "TLBNumberType",
          bits: new ast_1.TLBNumberExpr(257),
          storeBits: new ast_1.TLBNumberExpr(257),
          signed: true,
          maxBits: 257
        };
      } else if (expr.name == "VmStack") {
        return {
          kind: "TLBTupleType"
        };
      } else if (expr.name == "Bits") {
        return { kind: "TLBBitsType", bits: new ast_1.TLBNumberExpr(1023) };
      } else if (expr.name == "Bit") {
        return { kind: "TLBBitsType", bits: new ast_1.TLBNumberExpr(1) };
      } else if (expr.name == "Uint") {
        return {
          kind: "TLBNumberType",
          bits: new ast_1.TLBNumberExpr(257),
          storeBits: new ast_1.TLBNumberExpr(257),
          signed: false,
          maxBits: 257
        };
      } else if (expr.name == "Any" || expr.name == "Cell") {
        return { kind: "TLBCellType" };
      } else if ((theNum = (0, utils_1.splitForTypeValue)(expr.name, "int")) != void 0) {
        return {
          kind: "TLBNumberType",
          bits: new ast_1.TLBNumberExpr(theNum),
          storeBits: new ast_1.TLBNumberExpr(theNum),
          signed: true,
          maxBits: theNum
        };
      } else if ((theNum = (0, utils_1.splitForTypeValue)(expr.name, "uint")) != void 0) {
        return {
          kind: "TLBNumberType",
          bits: new ast_1.TLBNumberExpr(theNum),
          storeBits: new ast_1.TLBNumberExpr(theNum),
          signed: false,
          maxBits: theNum
        };
      } else if ((theNum = (0, utils_1.splitForTypeValue)(expr.name, "bits")) != void 0) {
        return { kind: "TLBBitsType", bits: new ast_1.TLBNumberExpr(theNum) };
      } else if (expr.name == "MsgAddressInt") {
        return { kind: "TLBAddressType", addrType: "Internal" };
      } else if (expr.name == "MsgAddressExt") {
        return { kind: "TLBAddressType", addrType: "External" };
      } else if (expr.name == "MsgAddress") {
        return { kind: "TLBAddressType", addrType: "Any" };
      } else if (expr.name == "Grams" || expr.name == "Coins") {
        return { kind: "TLBCoinsType" };
      } else if (expr.name == "Bool") {
        return { kind: "TLBBoolType", value: void 0 };
      } else if (expr.name == "BoolFalse") {
        return { kind: "TLBBoolType", value: false };
      } else if (expr.name == "BoolTrue") {
        return { kind: "TLBBoolType", value: true };
      } else {
        if (((_a2 = constructor.variablesMap.get(expr.name)) === null || _a2 === void 0 ? void 0 : _a2.type) == "#") {
          return {
            kind: "TLBExprMathType",
            expr: (0, utils_1.getCalculatedExpression)(new ast_1.TLBVarExpr(expr.name), constructor),
            initialExpr: new ast_1.TLBVarExpr(expr.name)
          };
        } else {
          return { kind: "TLBNamedType", name: expr.name, arguments: [] };
        }
      }
    } else if (expr instanceof tlb_parser_1.NumberExpr) {
      return { kind: "TLBExprMathType", expr: new ast_1.TLBNumberExpr(expr.num), initialExpr: new ast_1.TLBNumberExpr(expr.num) };
    } else if (expr instanceof tlb_parser_1.NegateExpr && expr.expr instanceof tlb_parser_1.NameExpr) {
      return { kind: "TLBNegatedType", variableName: expr.expr.name };
    } else if (expr instanceof tlb_parser_1.CellRefExpr) {
      let subExprInfo = getType(expr.expr, constructor, fieldTypeName);
      return { kind: "TLBCellInsideType", value: subExprInfo };
    } else if (expr instanceof tlb_parser_1.MathExpr) {
      if (fieldTypeName == "") {
        if (expr.op == "*") {
          let subExprInfo = getType(expr.right, constructor, fieldTypeName);
          return {
            kind: "TLBMultipleType",
            times: (0, utils_1.getCalculatedExpression)((0, utils_1.convertToMathExpr)(expr.left), constructor),
            value: subExprInfo
          };
        } else {
          throw new Error(`Couldn't handle expression ${expr}`);
        }
      } else {
        return {
          kind: "TLBExprMathType",
          expr: (0, utils_1.getCalculatedExpression)((0, utils_1.convertToMathExpr)(expr), constructor),
          initialExpr: (0, utils_1.convertToMathExpr)(expr)
        };
      }
    } else if (expr instanceof tlb_parser_1.CondExpr) {
      let subExprInfo = getType(expr.condExpr, constructor, fieldTypeName);
      if (expr.left instanceof tlb_parser_1.NameExpr) {
        let condition = (0, utils_1.getCalculatedExpression)((0, utils_1.convertToMathExpr)(expr.left), constructor);
        if (expr.dotExpr != null) {
          condition = new ast_1.TLBBinaryOp(condition, new ast_1.TLBBinaryOp(new ast_1.TLBNumberExpr(1), new ast_1.TLBNumberExpr(expr.dotExpr), "<<"), "&");
        }
        return { kind: "TLBCondType", value: subExprInfo, condition };
      }
    } else {
      throw new Error(`Couldn't handle expression ${expr}`);
    }
    throw new Error(`Couldn't handle expression ${expr}`);
  }
  handle_type.getType = getType;
  return handle_type;
}
var hasRequiredHandle_field;
function requireHandle_field() {
  if (hasRequiredHandle_field) return handle_field;
  hasRequiredHandle_field = 1;
  Object.defineProperty(handle_field, "__esModule", { value: true });
  handle_field.fillFields = void 0;
  const tlb_parser_1 = requireDist$3();
  const handle_type_1 = requireHandle_type();
  function getField(field, constructor, fieldIndex) {
    if (field instanceof tlb_parser_1.FieldAnonymousDef) {
      let result = {
        name: "",
        anonymous: true,
        fieldType: { kind: "TLBNamedType", name: "Bool", arguments: [] },
        subFields: []
      };
      let currentFieldIndex = 0;
      field.fields.forEach((field2) => {
        let subField = getField(field2, constructor, fieldIndex + "_" + currentFieldIndex.toString());
        if (subField) {
          result.subFields.push(subField);
        }
        currentFieldIndex++;
      });
      return result;
    }
    if (field instanceof tlb_parser_1.FieldNamedDef || field instanceof tlb_parser_1.FieldExprDef) {
      let fieldName;
      if (field instanceof tlb_parser_1.FieldNamedDef) {
        fieldName = field.name;
      } else {
        fieldName = "anon" + fieldIndex;
      }
      if (field instanceof tlb_parser_1.FieldExprDef && field.expr instanceof tlb_parser_1.NameExpr && field.expr.name == "_") {
        return void 0;
      }
      if (field.expr instanceof tlb_parser_1.CellRefExpr) {
        if (field.expr.expr instanceof tlb_parser_1.CombinatorExpr && (field.expr.expr.name == "MERKLE_UPDATE" || field.expr.expr.name == "MERKLE_ROOT")) {
          return {
            name: fieldName,
            anonymous: true,
            fieldType: { kind: "TLBExoticType" },
            subFields: []
          };
        } else {
          let subField = getField(new tlb_parser_1.FieldNamedDef(fieldName, field.expr.expr), constructor, fieldIndex + "_0");
          if (subField) {
            let result = {
              name: fieldName,
              anonymous: true,
              fieldType: { kind: "TLBNamedType", name: "Bool", arguments: [] },
              subFields: [subField]
            };
            return result;
          }
          return subField;
        }
      }
      if (field.expr instanceof tlb_parser_1.CombinatorExpr || field.expr instanceof tlb_parser_1.NameExpr || field.expr instanceof tlb_parser_1.BuiltinZeroArgs || field.expr instanceof tlb_parser_1.BuiltinOneArgExpr || field.expr instanceof tlb_parser_1.MathExpr || field.expr instanceof tlb_parser_1.CondExpr) {
        let fieldTypeName;
        if (field.expr instanceof tlb_parser_1.MathExpr || field.expr instanceof tlb_parser_1.CondExpr) {
          fieldTypeName = "";
        } else {
          fieldTypeName = field.expr.name;
        }
        let fieldInfo = (0, handle_type_1.getType)(field.expr, constructor, fieldTypeName);
        return {
          name: fieldName,
          anonymous: !(field instanceof tlb_parser_1.FieldNamedDef),
          fieldType: fieldInfo,
          subFields: []
        };
      }
    }
    return void 0;
  }
  function fillFields(typeItem, _tlbType) {
    let constructor = typeItem.constructor;
    let declaration = typeItem.declaration;
    let fieldIndex = -1;
    declaration.fields.forEach((fieldDecl) => {
      fieldIndex++;
      let field = getField(fieldDecl, constructor, fieldIndex.toString());
      if (field != void 0) {
        constructor.fields.push(field);
      }
    });
  }
  handle_field.fillFields = fillFields;
  return handle_field;
}
var hasRequiredFill_constructors;
function requireFill_constructors() {
  if (hasRequiredFill_constructors) return fill_constructors;
  hasRequiredFill_constructors = 1;
  Object.defineProperty(fill_constructors, "__esModule", { value: true });
  fill_constructors.convertCodeToReadonly = fill_constructors.fillConstructors = void 0;
  const tlb_parser_1 = requireDist$3();
  const ast_1 = requireAst();
  const utils_1 = requireUtils$4();
  const handle_field_1 = requireHandle_field();
  const utils_2 = requireUtils$3();
  function fillConstructors(declarations, tlbCode, input) {
    let typeDeclarations = /* @__PURE__ */ new Map();
    declarations.forEach((declaration) => {
      let tlbType = tlbCode.types.get(declaration.combinator.name);
      if (tlbType == void 0) {
        tlbType = { name: declaration.combinator.name, constructors: [] };
      }
      let constructor = {
        parameters: [],
        parametersMap: /* @__PURE__ */ new Map(),
        name: declaration.constructorDef.name,
        variables: new Array(),
        variablesMap: /* @__PURE__ */ new Map(),
        tag: getConstructorTag(declaration),
        constraints: [],
        fields: [],
        declaration: "",
        tlbType: tlbType.name
      };
      tlbType.constructors.push(constructor);
      tlbCode.types.set(tlbType.name, tlbType);
      let currentDecls = typeDeclarations.get(tlbType.name);
      if (!currentDecls) {
        currentDecls = [];
      }
      currentDecls.push({ declaration, constructor });
      typeDeclarations.set(tlbType.name, currentDecls);
    });
    tlbCode.types.forEach((tlbType) => {
      var _a2;
      (_a2 = typeDeclarations.get(tlbType.name)) === null || _a2 === void 0 ? void 0 : _a2.forEach((typeItem) => {
        let declaration = typeItem.declaration;
        let constructor = typeItem.constructor;
        declaration.fields.forEach((field) => {
          if (field instanceof tlb_parser_1.FieldBuiltinDef) {
            constructor.variables.push({
              name: field.name,
              isConst: false,
              negated: false,
              type: field.type,
              calculated: false,
              isField: false
            });
          }
          if (field instanceof tlb_parser_1.FieldNamedDef) {
            constructor.variables.push({
              name: field.name,
              isConst: false,
              negated: false,
              type: "#",
              calculated: false,
              isField: true
            });
          }
        });
        constructor.variables.forEach((variable) => {
          if (variable.name) {
            constructor.variablesMap.set(variable.name, variable);
          }
        });
        let argumentIndex = -1;
        declaration.combinator.args.forEach((element) => {
          argumentIndex++;
          let parameter = void 0;
          if (element instanceof tlb_parser_1.NameExpr) {
            let variable = constructor.variablesMap.get(element.name);
            if (variable) {
              if (variable.type == "#") {
                variable.deriveExpr = new ast_1.TLBVarExpr(element.name);
                variable.initialExpr = variable.deriveExpr;
              }
              parameter = {
                variable,
                paramExpr: new ast_1.TLBVarExpr(element.name)
              };
            } else {
              throw new Error("Field not known before using (should be tagged as implicit): " + element);
            }
          } else if (element instanceof tlb_parser_1.MathExpr) {
            let derivedExpr = (0, utils_2.deriveMathExpression)(element);
            if (!derivedExpr.name) {
              throw new Error(`Expression should contain variable ${element}`);
            }
            let variable = constructor.variablesMap.get(derivedExpr.name);
            if (variable && variable.name) {
              parameter = { variable, paramExpr: derivedExpr.derived };
              parameter.argName = "arg" + argumentIndex;
              parameter.variable.deriveExpr = reorganizeWithArg((0, utils_2.convertToMathExpr)(element), parameter.argName, variable.name);
              parameter.variable.initialExpr = new ast_1.TLBVarExpr(variable.name);
            } else {
              throw new Error(`Variable should have name ${variable}`);
            }
          } else if (element instanceof tlb_parser_1.NegateExpr && (element.expr instanceof tlb_parser_1.MathExpr || element.expr instanceof tlb_parser_1.NumberExpr || element.expr instanceof tlb_parser_1.NameExpr)) {
            let derivedExpr = (0, utils_2.deriveMathExpression)(element.expr);
            let toBeConst = false;
            if (element.expr instanceof tlb_parser_1.NumberExpr) {
              toBeConst = true;
            }
            if (derivedExpr.name == void 0) {
              if (toBeConst) {
                parameter = {
                  variable: {
                    negated: true,
                    isConst: toBeConst,
                    type: "#",
                    name: void 0,
                    deriveExpr: derivedExpr.derived,
                    initialExpr: derivedExpr.derived,
                    calculated: false,
                    isField: false
                  },
                  paramExpr: derivedExpr.derived
                };
              } else {
                throw new Error("Cannot identify combinator arg " + element);
              }
            } else {
              let variable = constructor.variablesMap.get(derivedExpr.name);
              if (variable) {
                variable.negated = true;
                variable.isConst = toBeConst;
                variable.initialExpr = derivedExpr.derived;
                parameter = {
                  variable,
                  paramExpr: derivedExpr.derived
                };
              } else {
                throw new Error("Cannot identify combinator arg " + element);
              }
            }
          } else if (element instanceof tlb_parser_1.NumberExpr) {
            parameter = {
              variable: {
                negated: false,
                isConst: true,
                type: "#",
                name: void 0,
                deriveExpr: new ast_1.TLBNumberExpr(element.num),
                initialExpr: new ast_1.TLBNumberExpr(element.num),
                calculated: false,
                isField: false
              },
              paramExpr: new ast_1.TLBNumberExpr(element.num)
            };
          } else {
            throw new Error("Cannot identify combinator arg: " + element);
          }
          constructor.parameters.push(parameter);
          if (parameter.variable.name != void 0) {
            constructor.parametersMap.set(parameter.variable.name, parameter);
          }
        });
        constructor.declaration = getStringDeclaration(declaration, input);
        fillConstraintsAndNegationVars(constructor, declaration);
        (0, handle_field_1.fillFields)(typeItem, tlbType);
        calculateVariables(constructor);
      });
      fillParameterNames(tlbType);
      fillArgNames(tlbType);
      findConstructorsNaming(tlbType);
      tlbType.constructors.sort(compareConstructors);
    });
    checkAndRemovePrimitives(tlbCode, input, typeDeclarations);
    findAvailableVarNamesForCode(tlbCode);
  }
  fill_constructors.fillConstructors = fillConstructors;
  function fillConstraintsAndNegationVars(constructor, declaration) {
    declaration.fields.forEach((field) => {
      if (field instanceof tlb_parser_1.FieldCurlyExprDef && field.expr instanceof tlb_parser_1.CompareExpr) {
        if (field.expr.op == "=") {
          let myMathExpr = (0, utils_2.convertToMathExpr)(field.expr);
          let negatedVariable = (0, utils_2.getNegatedVariable)(myMathExpr);
          if (negatedVariable) {
            myMathExpr = (0, utils_2.reorganizeExpression)(myMathExpr, negatedVariable);
            if (myMathExpr instanceof ast_1.TLBBinaryOp) {
              myMathExpr = myMathExpr.right;
            }
            let variable = constructor.variablesMap.get(negatedVariable);
            if (variable) {
              variable.negated = true;
              variable.deriveExpr = myMathExpr;
            } else {
              throw new Error(`Variable ${negatedVariable} not defined`);
            }
          } else {
            constructor.constraints.push(myMathExpr);
          }
        } else {
          constructor.constraints.push((0, utils_2.convertToMathExpr)(field.expr));
        }
      }
    });
  }
  function fillParameterNames(tlbType) {
    var _a2;
    let parameterNames = [];
    (_a2 = tlbType.constructors[0]) === null || _a2 === void 0 ? void 0 : _a2.parameters.forEach((element) => {
      parameterNames.push(element.variable.name);
    });
    tlbType.constructors.forEach((constructor) => {
      var _a3;
      for (let i = 0; i < constructor.parameters.length; i++) {
        if (parameterNames[i] == void 0) {
          let parameterName = (_a3 = constructor.parameters[i]) === null || _a3 === void 0 ? void 0 : _a3.variable.name;
          if (parameterName != void 0) {
            parameterNames[i] = parameterName;
          }
        }
      }
    });
    for (let i = 0; i < parameterNames.length; i++) {
      if (parameterNames[i] == void 0) {
        parameterNames[i] = "arg" + i;
      }
    }
    tlbType.constructors.forEach((constructor) => {
      var _a3;
      for (let i = 0; i < constructor.parameters.length; i++) {
        let parameterName = parameterNames[i];
        if (parameterName != void 0 && ((_a3 = constructor.parameters[i]) === null || _a3 === void 0 ? void 0 : _a3.variable.name) == void 0) {
          constructor.parameters[i].variable.name = parameterName;
        }
      }
    });
  }
  function fillArgNames(tlbType) {
    var _a2;
    let argNames = [];
    (_a2 = tlbType.constructors[0]) === null || _a2 === void 0 ? void 0 : _a2.parameters.forEach((_element) => {
      argNames.push(void 0);
    });
    tlbType.constructors.forEach((constructor) => {
      var _a3;
      for (let i = 0; i < constructor.parameters.length; i++) {
        let argName = (_a3 = constructor.parameters[i]) === null || _a3 === void 0 ? void 0 : _a3.argName;
        if (argName) {
          argNames[i] = argName;
        }
      }
    });
    tlbType.constructors.forEach((constructor) => {
      for (let i = 0; i < constructor.parameters.length; i++) {
        let argName = argNames[i];
        let parameter = constructor.parameters[i];
        if (argName != void 0 && parameter != void 0) {
          parameter.argName = argName;
          if (parameter.paramExpr instanceof ast_1.TLBVarExpr) {
            parameter.variable.deriveExpr = new ast_1.TLBVarExpr(parameter.argName);
            parameter.paramExpr = parameter.variable.deriveExpr;
          }
        }
      }
    });
  }
  function compareConstructors(a2, b2) {
    let aPriority = constructorPriority(a2);
    let bPriority = constructorPriority(b2);
    if (aPriority < bPriority) {
      return 1;
    }
    if (aPriority > bPriority) {
      return -1;
    }
    return 0;
  }
  function constructorPriority(c) {
    let result = 0;
    if (c.tag.bitLen > 0) {
      result++;
    }
    c.parameters.forEach((parameter) => {
      if (parameter.variable.isConst) {
        result++;
      }
    });
    return result;
  }
  function reorganizeWithArg(mathExpr, argName, varName) {
    let reorganized = (0, utils_2.reorganizeExpression)(new ast_1.TLBBinaryOp(new ast_1.TLBVarExpr(argName), mathExpr, "=", /* @__PURE__ */ new Set(), false), varName);
    if (reorganized instanceof ast_1.TLBBinaryOp) {
      return reorganized.right;
    }
    throw new Error(`Couldn't reorganize expression ${mathExpr}`);
  }
  function getConstructorTag(declaration, _input) {
    let tag = declaration.constructorDef.tag;
    if (tag == null && declaration.constructorDef.name == "_" || tag && tag.length > 1 && tag[1] == "_") {
      return {
        bitLen: 0,
        binary: ""
      };
    }
    if (tag == null) {
      let calculatedTag = calculateTag(declaration);
      return {
        bitLen: 32,
        binary: "0x" + calculatedTag
      };
    }
    if (tag[0] == "$") {
      return {
        bitLen: (tag === null || tag === void 0 ? void 0 : tag.length) - 1,
        binary: "0b" + tag.slice(1)
      };
    }
    if (tag[0] == "#") {
      const hasTrailingUnderscore = tag.endsWith("_");
      const hexPart = tag.slice(1, hasTrailingUnderscore ? -1 : void 0);
      if (hasTrailingUnderscore) {
        const binary2 = parseInt(hexPart, 16).toString(2).padStart(hexPart.length * 4, "0");
        const truncatedBinary = binary2.slice(0, -1);
        const truncatedHex = parseInt(truncatedBinary, 2).toString(16).padStart(Math.ceil(truncatedBinary.length / 4), "0");
        return {
          bitLen: truncatedBinary.length,
          binary: "0x" + truncatedHex
        };
      }
      return {
        bitLen: hexPart.length * 4,
        binary: "0x" + hexPart
      };
    }
    throw new Error("Unknown tag " + tag);
  }
  function findConstructorsNaming(tlbType) {
    let constructorNames = /* @__PURE__ */ new Set();
    let constructorIndex = 0;
    tlbType.constructors.forEach((current) => {
      while (constructorNames.has(current.name)) {
        current.name += constructorIndex.toString();
      }
      constructorNames.add(current.name);
      constructorIndex++;
    });
  }
  function checkAndRemovePrimitives(tlbCode, _input, typeDeclarations) {
    let toDelete = [];
    let typesToDelete = /* @__PURE__ */ new Map();
    typesToDelete.set("Bool", ["b814e002", "e95dd78d"]);
    typesToDelete.set("MsgAddressInt", ["9bb90082", "ca70d9f6"]);
    typesToDelete.set("Bit", ["12acf7f6"]);
    typesToDelete.set("Grams", ["31468450"]);
    typesToDelete.set("MsgAddressExt", ["9ccb7139", "ee7b72a3"]);
    typesToDelete.set("MsgAddress", ["21d0382b", "e06aa05e"]);
    typesToDelete.set("VarUInteger", ["988e36b3"]);
    typesToDelete.set("VarInteger", ["225aaee0"]);
    typesToDelete.set("HashmapE", ["1cc05be9", "40b92161"]);
    typesToDelete.set("HashmapAugE", ["af55dae6", "e135d248"]);
    typesToDelete.set("BoolTrue", ["b5311773"]);
    typesToDelete.set("BoolFalse", ["f3214771"]);
    typesToDelete.forEach((opCodesExpected, typeName) => {
      let typeItems = typeDeclarations.get(typeName);
      if (typeItems) {
        let opCodesActual = [];
        typeItems.forEach((typeItem) => {
          opCodesActual.push(calculateTag(typeItem.declaration));
        });
        if (!(0, utils_2.opCodeSetsEqual)(opCodesExpected, opCodesActual)) {
          throw new Error("Bool primitive type is not correct in scheme");
        }
        toDelete.push(typeName);
      }
    });
    toDelete.forEach((name) => {
      tlbCode.types.delete(name);
    });
  }
  function findAvailableVarNamesForCode(tlbCode) {
    tlbCode.types.forEach((tlbType) => {
      tlbType.constructors.forEach((constructor) => {
        let variablesSet = /* @__PURE__ */ new Set();
        findAvailableFieldsNames(constructor.fields, variablesSet);
      });
    });
  }
  function findAvailableFieldsNames(fields, variablesSet) {
    fields.forEach((field) => {
      if (field.subFields.length == 0) {
        findAvailableFieldName(field, variablesSet);
      }
      findAvailableFieldsNames(field.subFields, variablesSet);
    });
  }
  function findAvailableFieldName(field, variablesSet) {
    let index = 0;
    field.name = (0, utils_1.findNotReservedName)(field.name);
    while (variablesSet.has(field.name)) {
      field.name = (0, utils_1.findNotReservedName)(field.name + "_" + index);
      index++;
    }
    variablesSet.add(field.name);
  }
  function convertCodeToReadonly(tlbCode) {
    let newTypes = /* @__PURE__ */ new Map();
    tlbCode.types.forEach((value, key2) => {
      let newConstructors = new Array();
      value.constructors.forEach((value2) => {
        let newVariablesMap = /* @__PURE__ */ new Map();
        value2.variablesMap.forEach((value3, key3) => {
          newVariablesMap.set(key3, convertVariableToReadonly(value3));
        });
        let newParametersMap = /* @__PURE__ */ new Map();
        value2.parametersMap.forEach((value3, key3) => {
          newParametersMap.set(key3, convertParameterToReadonly(value3));
        });
        let newConstructor = new ast_1.TLBConstructor(value2.parameters.map(convertParameterToReadonly), value2.variables.map(convertVariableToReadonly), newVariablesMap, newParametersMap, value2.name, value2.fields, value2.tag, value2.constraints, value2.declaration, value2.tlbType);
        newConstructors.push(newConstructor);
      });
      let newType = new ast_1.TLBType(value.name, newConstructors);
      newTypes.set(key2, newType);
    });
    return new ast_1.TLBCode(newTypes);
  }
  fill_constructors.convertCodeToReadonly = convertCodeToReadonly;
  function convertParameterToReadonly(tlbParameter) {
    return new ast_1.TLBParameter(convertVariableToReadonly(tlbParameter.variable), tlbParameter.paramExpr, tlbParameter.argName);
  }
  function convertVariableToReadonly(tlbVariable) {
    if (tlbVariable.name == void 0) {
      throw new Error("Variable is undefined");
    }
    return new ast_1.TLBVariable(tlbVariable.isConst, tlbVariable.negated, tlbVariable.type, tlbVariable.name, tlbVariable.isField, tlbVariable.deriveExpr, tlbVariable.initialExpr);
  }
  function getStringDeclaration(declaration, input) {
    var _a2, _b;
    let result = "";
    let splittedInput = input;
    let currentLine = declaration.locations.line - 1;
    let currentColumn = 0;
    while (!((_a2 = splittedInput[currentLine]) === null || _a2 === void 0 ? void 0 : _a2.includes(";"))) {
      result += ((_b = splittedInput[currentLine]) === null || _b === void 0 ? void 0 : _b.substring(currentColumn)) + "\n";
      currentLine++;
      currentColumn = 0;
    }
    let currentInput = splittedInput[currentLine];
    if (currentInput) {
      result += currentInput.substring(currentColumn, currentInput.indexOf(";") + 1);
    }
    return result;
  }
  function calculateVariables(constructor) {
    constructor.variables.forEach((variable) => {
      (0, utils_2.calculateVariable)(variable, constructor);
    });
    constructor.parameters.forEach((parameter) => {
      (0, utils_2.calculateVariable)(parameter.variable, constructor);
    });
  }
  const TypeGuards = {
    isFieldBuiltinDef: (field) => field instanceof tlb_parser_1.FieldBuiltinDef,
    isFieldCurlyExprDef: (field) => field instanceof tlb_parser_1.FieldCurlyExprDef,
    isFieldAnonymousDef: (field) => field instanceof tlb_parser_1.FieldAnonymousDef,
    isFieldNamedDef: (field) => field instanceof tlb_parser_1.FieldNamedDef,
    isFieldExprDef: (field) => field instanceof tlb_parser_1.FieldExprDef,
    isCompareExpr: (expr) => expr instanceof tlb_parser_1.CompareExpr,
    isMathExpr: (expr) => expr instanceof tlb_parser_1.MathExpr,
    isNegateExpr: (expr) => expr instanceof tlb_parser_1.NegateExpr,
    isNameExpr: (expr) => expr instanceof tlb_parser_1.NameExpr,
    isNumberExpr: (expr) => expr instanceof tlb_parser_1.NumberExpr,
    isCellRefExpr: (expr) => expr instanceof tlb_parser_1.CellRefExpr,
    isBuiltinZeroArgs: (expr) => expr instanceof tlb_parser_1.BuiltinZeroArgs,
    isBuiltinOneArgExpr: (expr) => expr instanceof tlb_parser_1.BuiltinOneArgExpr,
    isCombinatorExpr: (expr) => expr instanceof tlb_parser_1.CombinatorExpr,
    isCondExpr: (expr) => expr instanceof tlb_parser_1.CondExpr
  };
  function calculateTag(declaration) {
    const formattedDeclaration = formatDeclaration(declaration);
    const encoder = new TextEncoder();
    return (0, utils_1.crc32)(encoder.encode(formattedDeclaration)).toString(16);
  }
  function isImplicitOrConstraint(field) {
    const { isFieldBuiltinDef, isFieldCurlyExprDef, isFieldNamedDef, isFieldExprDef, isCompareExpr } = TypeGuards;
    if (isFieldBuiltinDef(field) || isFieldCurlyExprDef(field)) {
      return true;
    }
    if ((isFieldNamedDef(field) || isFieldExprDef(field)) && isCompareExpr(field.expr) && field.expr.op === "=") {
      return true;
    }
    return false;
  }
  function formatDeclaration(declaration) {
    const parts = [declaration.constructorDef.name];
    declaration.fields.forEach((field) => {
      parts.push(formatField(field));
    });
    parts.push("=", declaration.combinator.name);
    declaration.combinator.args.forEach((arg) => {
      parts.push(formatExpression(arg));
    });
    return parts.join(" ");
  }
  function formatField(field) {
    const { isFieldBuiltinDef, isFieldCurlyExprDef, isFieldNamedDef, isFieldExprDef, isFieldAnonymousDef } = TypeGuards;
    const parts = [];
    if (isImplicitOrConstraint(field)) {
      if (isFieldBuiltinDef(field) || isFieldNamedDef(field) || isFieldAnonymousDef(field) && field.name) {
        parts.push(`${field.name}:`);
      }
      if (isFieldBuiltinDef(field)) {
        parts.push(field.type);
      } else if (isFieldCurlyExprDef(field)) {
        parts.push(formatExpression(field.expr));
      } else if (isFieldNamedDef(field)) {
        parts.push(formatExpression(field.expr));
      } else if (isFieldExprDef(field)) {
        parts.push(formatExpression(field.expr));
      } else if (isFieldAnonymousDef(field)) {
        parts.push(formatAnonymousField(field));
      }
      return parts.join("");
    }
    if (isFieldNamedDef(field)) {
      parts.push(`${field.name}:`);
    } else if (isFieldAnonymousDef(field) && field.name) {
      parts.push(`${field.name}:`);
    }
    if (isFieldNamedDef(field)) {
      parts.push(formatExpression(field.expr));
    } else if (isFieldExprDef(field)) {
      parts.push(formatExpression(field.expr));
    } else if (isFieldAnonymousDef(field)) {
      parts.push(formatAnonymousField(field));
    }
    return parts.join("");
  }
  function formatAnonymousField(field) {
    const innerFields = field.fields.map((innerField, index) => index > 0 ? " " + formatField(innerField) : formatField(innerField)).join("");
    return `${field.isRef ? "^[ " : "[ "}${innerFields} ]`;
  }
  function formatExpression(expr) {
    const { isCompareExpr, isMathExpr, isNegateExpr, isNameExpr, isNumberExpr, isCellRefExpr, isBuiltinZeroArgs, isBuiltinOneArgExpr, isCombinatorExpr, isCondExpr } = TypeGuards;
    if (isCompareExpr(expr)) {
      return `${expr.op} ${formatExpression(expr.left)} ${formatExpression(expr.right)}`;
    }
    if (isMathExpr(expr)) {
      return formatMathExpr(expr);
    }
    if (isNegateExpr(expr)) {
      return "~" + formatExpression(expr.expr);
    }
    if (isNumberExpr(expr)) {
      return String(expr.num);
    }
    if (isNameExpr(expr)) {
      return expr.name;
    }
    if (isCellRefExpr(expr)) {
      return "^" + formatExpression(expr.expr);
    }
    if (isBuiltinZeroArgs(expr)) {
      return expr.name;
    }
    if (isBuiltinOneArgExpr(expr)) {
      return `${expr.name} ${formatExpression(expr.arg)}`;
    }
    if (isCombinatorExpr(expr)) {
      const args = expr.args.map((arg) => formatExpression(arg)).join(" ");
      return `${expr.name} ${args}`;
    }
    if (isCondExpr(expr)) {
      let result = formatExpression(expr.left);
      if (expr.dotExpr !== null) {
        result += "." + expr.dotExpr;
      }
      result += "?" + formatExpression(expr.condExpr);
      return result;
    }
    return String(expr);
  }
  function formatMathExpr(expr) {
    const { isNumberExpr } = TypeGuards;
    if (expr.op === "+") {
      return `${formatExpression(expr.left)} + ${formatExpression(expr.right)}`;
    }
    if (expr.op === "*") {
      if (isNumberExpr(expr.right) && !isNumberExpr(expr.left)) {
        return `${formatExpression(expr.right)} * ${formatExpression(expr.left)}`;
      }
      if (isNumberExpr(expr.left) && isNumberExpr(expr.right)) {
        return String(expr.left.num * expr.right.num);
      }
      return `${formatExpression(expr.left)} * ${formatExpression(expr.right)}`;
    }
    return `${formatExpression(expr.left)} ${expr.op} ${formatExpression(expr.right)}`;
  }
  return fill_constructors;
}
var CodeBuilder = {};
var hasRequiredCodeBuilder;
function requireCodeBuilder() {
  if (hasRequiredCodeBuilder) return CodeBuilder;
  hasRequiredCodeBuilder = 1;
  Object.defineProperty(CodeBuilder, "__esModule", { value: true });
  CodeBuilder.CodeBuilder = void 0;
  let CodeBuilder$1 = class CodeBuilder {
    constructor() {
      this.tabLevel = 0;
      this.code = "";
    }
    tab() {
      this.tabLevel++;
    }
    unTab() {
      this.tabLevel--;
    }
    inTab(callback) {
      this.tab();
      callback();
      this.unTab();
    }
    add(text, moveLine = true) {
      if (!text) {
        this.code += "\n";
        return;
      }
      let tab = " ".repeat(this.tabLevel * 4);
      this.code += tab + text + (moveLine ? "\n" : "");
    }
    addMultiline(text, inline = false) {
      let lines = text.split("\n");
      let i = 0;
      for (let line of lines) {
        if (line === "\n" && lines.indexOf(line) === lines.length - 1) {
          continue;
        }
        if (inline && i === 0) {
          this.code += line + "\n";
        } else {
          this.add(line);
        }
        i++;
      }
    }
    append(code) {
      this.addMultiline(code.render());
    }
    appendInline(code) {
      this.addMultiline(code.render(), true);
    }
    render() {
      return this.code;
    }
  };
  CodeBuilder.CodeBuilder = CodeBuilder$1;
  return CodeBuilder;
}
var generator = {};
var complex_expr = {};
var tsgen = {};
var hasRequiredTsgen;
function requireTsgen() {
  if (hasRequiredTsgen) return tsgen;
  hasRequiredTsgen = 1;
  Object.defineProperty(tsgen, "__esModule", { value: true });
  tsgen.id = tsgen.toCode = tsgen.tCodeAsIs = tsgen.tTernaryExpression = tsgen.tComment = tsgen.tMultiStatement = tsgen.tDeclareVariable = tsgen.tArrowFunctionType = tsgen.tBinaryExpression = tsgen.tUnaryOpExpression = tsgen.tIfStatement = tsgen.tExpressionStatement = tsgen.tUnionTypeDeclaration = tsgen.tArrowFunctionExpression = tsgen.tUnionTypeExpression = tsgen.tTypeParametersExpression = tsgen.tBinaryNumericLiteral = tsgen.tNumericLiteral = tsgen.tMemberExpression = tsgen.tFunctionCall = tsgen.tReturnStatement = tsgen.tStructExpression = tsgen.tObjectExpression = tsgen.tForCycle = tsgen.tObjectProperty = tsgen.tStructDeclaration = tsgen.tTypeWithParameters = tsgen.tTypedIdentifier = tsgen.tFunctionDeclaration = tsgen.tImportDeclaration = tsgen.tStringLiteral = tsgen.tIdentifier = void 0;
  const CodeBuilder_1 = requireCodeBuilder();
  function tIdentifier(name) {
    return { type: "Identifier", name };
  }
  tsgen.tIdentifier = tIdentifier;
  function tStringLiteral(value) {
    return { type: "StringLiteral", value };
  }
  tsgen.tStringLiteral = tStringLiteral;
  function tImportDeclaration(importValue, from) {
    return { type: "ImportDeclaration", importValue, from };
  }
  tsgen.tImportDeclaration = tImportDeclaration;
  function tFunctionDeclaration(name, typeParameters, returnType, parameters, body) {
    return {
      type: "FunctionDeclaration",
      name,
      typeParameters,
      returnType,
      parameters,
      body
    };
  }
  tsgen.tFunctionDeclaration = tFunctionDeclaration;
  function tTypedIdentifier(name, typeId, optional = false) {
    return { type: "TypedIdentifier", name, typeId, optional };
  }
  tsgen.tTypedIdentifier = tTypedIdentifier;
  function tTypeWithParameters(name, typeParameters) {
    return {
      type: "TypeWithParameters",
      name,
      typeParameters
    };
  }
  tsgen.tTypeWithParameters = tTypeWithParameters;
  function tStructDeclaration(name, fields, typeParameters) {
    return {
      type: "StructDeclaration",
      name,
      fields,
      typeParametersExpression: typeParameters
    };
  }
  tsgen.tStructDeclaration = tStructDeclaration;
  function tObjectProperty(key2, value) {
    return { type: "ObjectProperty", key: key2, value };
  }
  tsgen.tObjectProperty = tObjectProperty;
  function tForCycle(init, cond, inc, body) {
    return { type: "ForCycle", init, cond, inc, body };
  }
  tsgen.tForCycle = tForCycle;
  function tObjectExpression(objectValues) {
    return { type: "ObjectExpression", objectValues };
  }
  tsgen.tObjectExpression = tObjectExpression;
  function tStructExpression(fields) {
    return { type: "StructExpression", fields };
  }
  tsgen.tStructExpression = tStructExpression;
  function tReturnStatement(returnValue) {
    return { type: "ReturnStatement", returnValue };
  }
  tsgen.tReturnStatement = tReturnStatement;
  function tFunctionCall(functionId, parameters, typeParameters) {
    return {
      type: "FunctionCall",
      functionId,
      parameters,
      typeParameters
    };
  }
  tsgen.tFunctionCall = tFunctionCall;
  function tMemberExpression(thisObject, memberName) {
    return {
      type: "MemberExpression",
      thisObject,
      memberName
    };
  }
  tsgen.tMemberExpression = tMemberExpression;
  function tNumericLiteral(value) {
    return { type: "NumericLiteral", value };
  }
  tsgen.tNumericLiteral = tNumericLiteral;
  function tBinaryNumericLiteral(value) {
    return { type: "BinaryNumericLiteral", value };
  }
  tsgen.tBinaryNumericLiteral = tBinaryNumericLiteral;
  function tTypeParametersExpression(typeParameters) {
    return { type: "TypeParametersExpression", typeParameters };
  }
  tsgen.tTypeParametersExpression = tTypeParametersExpression;
  function tUnionTypeExpression(unionMembers) {
    return { type: "UnionTypeExpression", unionMembers };
  }
  tsgen.tUnionTypeExpression = tUnionTypeExpression;
  function tArrowFunctionExpression(parameters, body) {
    return {
      type: "ArrowFunctionExpression",
      parameters,
      body
    };
  }
  tsgen.tArrowFunctionExpression = tArrowFunctionExpression;
  function tUnionTypeDeclaration(name, union) {
    return { type: "UnionTypeDeclaration", name, union };
  }
  tsgen.tUnionTypeDeclaration = tUnionTypeDeclaration;
  function tExpressionStatement(expression) {
    return { type: "ExpressionStatement", expression };
  }
  tsgen.tExpressionStatement = tExpressionStatement;
  function tIfStatement(condition, body, elseBody) {
    return {
      type: "IfStatement",
      condition,
      body,
      elseBody
    };
  }
  tsgen.tIfStatement = tIfStatement;
  function tUnaryOpExpression(unaryOperator, expr) {
    return {
      type: "UnaryOpExpression",
      unaryOperator,
      expr
    };
  }
  tsgen.tUnaryOpExpression = tUnaryOpExpression;
  function tBinaryExpression(left, binarySign, right) {
    return {
      type: "BinaryExpression",
      binarySign,
      left,
      right
    };
  }
  tsgen.tBinaryExpression = tBinaryExpression;
  function tArrowFunctionType(parameters, returnType) {
    return {
      type: "ArrowFunctionType",
      parameters,
      returnType
    };
  }
  tsgen.tArrowFunctionType = tArrowFunctionType;
  function tDeclareVariable(name, init, typeName) {
    return {
      type: "DeclareVariable",
      name,
      init,
      typeName
    };
  }
  tsgen.tDeclareVariable = tDeclareVariable;
  function tMultiStatement(statements) {
    return { type: "MultiStatement", statements };
  }
  tsgen.tMultiStatement = tMultiStatement;
  function tComment(value) {
    return { type: "Comment", value };
  }
  tsgen.tComment = tComment;
  function tTernaryExpression(condition, body, elseBody) {
    return {
      type: "TernaryExpression",
      condition,
      body,
      elseBody
    };
  }
  tsgen.tTernaryExpression = tTernaryExpression;
  function tCodeAsIs(code) {
    return { type: "CodeAsIs", code };
  }
  tsgen.tCodeAsIs = tCodeAsIs;
  function toCodeArray(nodeArray, code, delimeter) {
    for (let i = 0; i < nodeArray.length; i++) {
      let currentParam = nodeArray[i];
      if (currentParam != void 0) {
        toCode(currentParam, code);
      }
      if (i + 1 < nodeArray.length) {
        code.add(delimeter, false);
      }
    }
    return code;
  }
  function toCode(node, code = new CodeBuilder_1.CodeBuilder()) {
    if (node.type == "Identifier") {
      code.add(node.name, false);
    }
    if (node.type == "NumericLiteral") {
      code.add(node.value.toString(), false);
    }
    if (node.type == "ImportDeclaration") {
      code.add(`import { ${toCode(node.importValue).render()} } from ${toCode(node.from).render()}`, false);
    }
    if (node.type == "FunctionDeclaration") {
      code.add(`export function ${toCode(node.name).render()}${toCode(node.typeParameters).render()}(`, false);
      toCodeArray(node.parameters, code, ", ");
      code.add(`)${node.returnType ? ": " + toCode(node.returnType).render() : ""} {`);
      code.inTab(() => {
        node.body.forEach((statement) => {
          code.append(toCode(statement));
        });
      });
      code.add("}");
    }
    if (node.type == "ArrowFunctionExpression") {
      code.add(`((`, false);
      toCodeArray(node.parameters, code, ", ");
      code.add(`) => {`);
      code.inTab(() => {
        node.body.forEach((statement) => {
          code.append(toCode(statement));
        });
      });
      code.add(`})`, false);
    }
    if (node.type == "ArrowFunctionType") {
      code.add(`(${toCodeArray(node.parameters, new CodeBuilder_1.CodeBuilder(), ", ").render()}) => ${node.returnType ? toCode(node.returnType).render() : ""}`, false);
    }
    if (node.type == "TypeWithParameters") {
      code.add(`${toCode(node.name).render()}${toCode(node.typeParameters).render()}`, false);
    }
    if (node.type == "TypedIdentifier") {
      code.add(toCode(node.name).render() + (node.optional ? "?" : "") + ": " + toCode(node.typeId).render(), false);
    }
    if (node.type == "ObjectProperty") {
      code.add(toCode(node.key).render() + ": " + toCode(node.value).render(), false);
    }
    if (node.type == "DeclareVariable") {
      code.add(`let ${toCode(node.name).render()}${node.typeName ? ": " + toCode(node.typeName).render() : ""}`, false);
      if (node.init) {
        code.add(" = ", false);
        toCode(node.init, code);
      }
    }
    if (node.type == "ObjectExpression") {
      code.add("{");
      code.inTab(() => {
        node.objectValues.forEach((objectValue) => {
          code.add(toCode(objectValue).render() + ",");
        });
      });
      code.add("}", false);
    }
    if (node.type == "StructExpression") {
      code.add("{", false);
      toCodeArray(node.fields, code, ", ");
      code.add("}", false);
    }
    if (node.type == "MultiStatement") {
      node.statements.forEach((statement) => {
        code.append(toCode(statement));
      });
    }
    if (node.type == "ReturnStatement") {
      code.add(`return `, false);
      code.appendInline(toCode(node.returnValue));
    }
    if (node.type == "ExpressionStatement") {
      code.add(toCode(node.expression).render() + ";", false);
    }
    if (node.type == "TypeParametersExpression") {
      if (node.typeParameters.length > 0) {
        code.add("<", false);
        toCodeArray(node.typeParameters, code, ", ");
        code.add(">", false);
      }
    }
    if (node.type == "StructDeclaration") {
      code.add(`export interface ${toCode(node.name).render()}${toCode(node.typeParametersExpression).render()} {`);
      code.inTab(() => {
        node.fields.forEach((field) => {
          code.add(`readonly ${toCode(field).render()};`);
        });
      });
      code.add("}");
    }
    if (node.type == "UnionTypeDeclaration") {
      code.add(`export type ${toCode(node.name).render()} = ${toCode(node.union).render()};`);
    }
    if (node.type == "UnionTypeExpression") {
      toCodeArray(node.unionMembers, code, " | ");
    }
    if (node.type == "FunctionCall") {
      code.add(`${toCode(node.functionId).render()}${node.typeParameters ? toCode(node.typeParameters).render() : ""}(`, false);
      toCodeArray(node.parameters, code, ", ");
      code.add(`)`, false);
    }
    if (node.type == "StringLiteral") {
      code.add(`'${node.value}'`, false);
    }
    if (node.type == "MemberExpression") {
      code.add(toCode(node.thisObject).render() + "." + toCode(node.memberName).render(), false);
    }
    if (node.type == "IfStatement") {
      code.add(`if (${toCode(node.condition).render()}) {`);
      code.inTab(() => {
        node.body.forEach((statement) => {
          code.append(toCode(statement));
        });
      });
      code.add("}", false);
    }
    if (node.type == "ForCycle") {
      code.add(`for (${toCode(node.init).render()};${toCode(node.cond).render()};${toCode(node.inc).render()}) {`);
      code.inTab(() => {
        node.body.forEach((statement) => {
          code.append(toCode(statement));
        });
      });
      code.add(`}`, false);
    }
    if (node.type == "UnaryOpExpression") {
      code.add(`(${node.unaryOperator}${toCode(node.expr).render()})`, false);
    }
    if (node.type == "BinaryExpression") {
      code.add(`(${toCode(node.left).render()} ${node.binarySign} ${toCode(node.right).render()})`, false);
    }
    if (node.type == "TernaryExpression") {
      code.add(`(${toCode(node.condition).render()} ? ${toCode(node.body).render()} : ${toCode(node.elseBody).render()})`, false);
    }
    if (node.type == "Comment") {
      let splittedComment = node.value.split("\n");
      if (splittedComment.length == 1) {
        code.add(`// ${splittedComment[0]}`);
      } else {
        code.add(`/*`);
        splittedComment.forEach((line) => {
          code.add(line);
        });
        code.add(`*/`);
      }
    }
    if (node.type == "CodeAsIs") {
      code.add(node.code, false);
    }
    return code;
  }
  tsgen.toCode = toCode;
  tsgen.id = tIdentifier;
  return tsgen;
}
var utils$2 = {};
var hasRequiredUtils$2;
function requireUtils$2() {
  if (hasRequiredUtils$2) return utils$2;
  hasRequiredUtils$2 = 1;
  Object.defineProperty(utils$2, "__esModule", { value: true });
  utils$2.useBuffer = utils$2.isBigInt = utils$2.isBigIntExpr = utils$2.getCondition = utils$2.getTypeParametersExpression = utils$2.convertToAST = utils$2.addLoadProperty = utils$2.getNegationDerivationFunctionBody = utils$2.getVarExprByName = utils$2.getParamVarExpr = void 0;
  const ast_1 = requireAst();
  const utils_1 = requireUtils$4();
  const complex_expr_1 = requireComplex_expr();
  const tsgen_1 = requireTsgen();
  function getParamVarExpr(param, constructor) {
    if (param.variable.deriveExpr) {
      return convertToAST(param.variable.deriveExpr, constructor);
    } else {
      throw new Error(`Could not get expression for param ${param.variable.name} for constructor ${constructor.name} of type ${constructor.tlbType}`);
    }
  }
  utils$2.getParamVarExpr = getParamVarExpr;
  function getVarExprByName(name, constructor) {
    let variable = constructor.variablesMap.get(name);
    if (variable === null || variable === void 0 ? void 0 : variable.deriveExpr) {
      return convertToAST(variable.deriveExpr, constructor);
    }
    return (0, tsgen_1.id)(name);
  }
  utils$2.getVarExprByName = getVarExprByName;
  function getNegationDerivationFunctionBody(tlbCode, typeName, parameterIndex, parameterName) {
    let result = [];
    let tlbType = tlbCode.types.get(typeName);
    if (!tlbType) {
      throw new Error(`Can not find type ${typeName}`);
    }
    tlbType.constructors.forEach((constructor) => {
      let parameter = constructor.parameters[parameterIndex];
      if (parameter) {
        let getExpression;
        getExpression = convertToAST(parameter.paramExpr, constructor);
        let statements = [];
        if (!parameter.variable.isConst) {
          statements.push((0, tsgen_1.tExpressionStatement)((0, tsgen_1.tDeclareVariable)((0, tsgen_1.id)(parameter.variable.name), (0, tsgen_1.tMemberExpression)((0, tsgen_1.id)(parameterName), (0, tsgen_1.id)(parameter.variable.name)))));
        }
        statements.push((0, tsgen_1.tReturnStatement)(getExpression));
        if (tlbType) {
          result.push((0, tsgen_1.tIfStatement)((0, complex_expr_1.tEqualExpression)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)(parameterName), (0, tsgen_1.id)("kind")), (0, tsgen_1.tStringLiteral)((0, utils_1.getSubStructName)(tlbType, constructor))), statements));
        }
      }
    });
    let exceptionTypesComment = tlbType.constructors.map((constructor) => {
      return `"${tlbType ? (0, utils_1.getSubStructName)(tlbType, constructor) : ""}"`;
    }).join(", ");
    let exceptionComment = (0, tsgen_1.tExpressionStatement)((0, tsgen_1.id)(`throw new Error('Expected one of ${exceptionTypesComment} for type "${tlbType.name}" while getting "${parameterName}", but data does not satisfy any constructor')`));
    result.push(exceptionComment);
    return result;
  }
  utils$2.getNegationDerivationFunctionBody = getNegationDerivationFunctionBody;
  function addLoadProperty(name, loadExpr, typeExpr, ctx) {
    let nameId = (0, tsgen_1.id)(name);
    ctx.loadStatements.push((0, tsgen_1.tExpressionStatement)((0, tsgen_1.tDeclareVariable)(nameId, loadExpr, typeExpr)));
    ctx.loadProperties.push((0, tsgen_1.tObjectProperty)(nameId, nameId));
  }
  utils$2.addLoadProperty = addLoadProperty;
  function convertToAST(mathExpr, constructor, objectId) {
    if (mathExpr instanceof ast_1.TLBVarExpr) {
      let varName = mathExpr.x;
      if (objectId != void 0) {
        return (0, tsgen_1.tMemberExpression)(objectId, (0, tsgen_1.id)(varName));
      }
      return (0, tsgen_1.id)(varName);
    }
    if (mathExpr instanceof ast_1.TLBNumberExpr) {
      return (0, tsgen_1.tNumericLiteral)(mathExpr.n);
    }
    if (mathExpr instanceof ast_1.TLBBinaryOp) {
      let operation = mathExpr.operation;
      if (operation == "=") {
        operation = "==";
      }
      return (0, tsgen_1.tBinaryExpression)(convertToAST(mathExpr.left, constructor, objectId), operation, convertToAST(mathExpr.right, constructor, objectId));
    }
    if (mathExpr instanceof ast_1.TLBUnaryOp) {
      if (mathExpr.operation == ".") {
        return (0, tsgen_1.tFunctionCall)((0, tsgen_1.id)("bitLen"), [convertToAST(mathExpr.value, constructor, objectId)]);
      }
      return (0, tsgen_1.tUnaryOpExpression)(mathExpr.operation, convertToAST(mathExpr.value, constructor, objectId));
    }
    throw new Error(`Type ${constructor.tlbType}, constructor ${constructor.name}: couldn't convert to math expression: ${mathExpr}`);
  }
  utils$2.convertToAST = convertToAST;
  function getTypeParametersExpression(parameters) {
    let structTypeParameters = [];
    parameters.forEach((element) => {
      if (element.variable.type == "Type") {
        structTypeParameters.push((0, tsgen_1.id)(element.variable.name));
      }
    });
    let structTypeParametersExpr = (0, tsgen_1.tTypeParametersExpression)(structTypeParameters);
    return structTypeParametersExpr;
  }
  utils$2.getTypeParametersExpression = getTypeParametersExpression;
  function getCondition(conditions) {
    let cnd = conditions[0];
    if (cnd) {
      if (conditions.length > 1) {
        return (0, tsgen_1.tBinaryExpression)(cnd, "&&", getCondition(conditions.slice(1)));
      } else {
        return cnd;
      }
    } else {
      return (0, tsgen_1.id)("true");
    }
  }
  utils$2.getCondition = getCondition;
  function isBigIntExpr(fieldType) {
    if (fieldType.expr instanceof ast_1.TLBNumberExpr && fieldType.expr.n <= 32) {
      return false;
    }
    return true;
  }
  utils$2.isBigIntExpr = isBigIntExpr;
  function isBigInt(fieldType) {
    if (fieldType.bits instanceof ast_1.TLBNumberExpr) {
      if (fieldType.bits.n <= 32) {
        return false;
      }
    }
    if (fieldType.maxBits && fieldType.maxBits <= 32) {
      return false;
    }
    return true;
  }
  utils$2.isBigInt = isBigInt;
  function useBuffer(bitsType) {
    if (bitsType.bits instanceof ast_1.TLBNumberExpr && bitsType.bits.n % 8 == 0) {
      return true;
    }
    return false;
  }
  utils$2.useBuffer = useBuffer;
  return utils$2;
}
var hasRequiredComplex_expr;
function requireComplex_expr() {
  if (hasRequiredComplex_expr) return complex_expr;
  hasRequiredComplex_expr = 1;
  Object.defineProperty(complex_expr, "__esModule", { value: true });
  complex_expr.dictAugTypeExpr = complex_expr.dictAugParse = complex_expr.dictKeyExpr = complex_expr.dictLoadExpr = complex_expr.dictValueStore = complex_expr.dictTypeParamExpr = complex_expr.dictStoreStmt = complex_expr.negationDerivationFuncDecl = complex_expr.inSeparateRef = complex_expr.checkConstraintStmt = complex_expr.newCellStmt = complex_expr.storeRefStmt = complex_expr.loadRefStmt = complex_expr.storeRefObjectStmt = complex_expr.storeExpressionNamedType = complex_expr.storeExprCond = complex_expr.loadTupleExpr = complex_expr.storeTupleStmt = complex_expr.arrayedType = complex_expr.loadFromNewSlice = complex_expr.storeInNewCell = complex_expr.storeCombinator = complex_expr.loadExprForParam = complex_expr.returnSliceFunc = complex_expr.storeExprForParam = complex_expr.coverFuncCall = complex_expr.storeFunctionExpr = complex_expr.checkHasBitsForTag = complex_expr.checkTagExpr = complex_expr.skipTagStmt = complex_expr.loadFunctionParam = complex_expr.storeFunctionParam = complex_expr.simpleCycle = complex_expr.sliceLoad = complex_expr.typedSlice = complex_expr.bitlenFunctionDecl = complex_expr.checkKindStmt = complex_expr.storeFunctionStmt = complex_expr.storeTagExpression = complex_expr.tEqualExpression = void 0;
  const utils_1 = requireUtils$4();
  const tsgen_1 = requireTsgen();
  const utils_2 = requireUtils$2();
  function tEqualExpression(left, right) {
    return (0, tsgen_1.tBinaryExpression)(left, "==", right);
  }
  complex_expr.tEqualExpression = tEqualExpression;
  function storeTagExpression(tag) {
    return (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)("builder"), (0, tsgen_1.id)("storeUint")), [(0, tsgen_1.id)(tag.binary), (0, tsgen_1.tNumericLiteral)(tag.bitLen)]));
  }
  complex_expr.storeTagExpression = storeTagExpression;
  function storeFunctionStmt(statements) {
    return (0, tsgen_1.tReturnStatement)((0, tsgen_1.tArrowFunctionExpression)([(0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("builder"), (0, tsgen_1.id)("Builder"))], statements));
  }
  complex_expr.storeFunctionStmt = storeFunctionStmt;
  function checkKindStmt(variableCombinatorName, constructorTypeName, storeStatement) {
    return (0, tsgen_1.tIfStatement)(tEqualExpression((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)(variableCombinatorName), (0, tsgen_1.id)("kind")), (0, tsgen_1.tStringLiteral)(constructorTypeName)), [storeStatement]);
  }
  complex_expr.checkKindStmt = checkKindStmt;
  function bitlenFunctionDecl() {
    return (0, tsgen_1.tFunctionDeclaration)((0, tsgen_1.id)("bitLen"), (0, tsgen_1.tTypeParametersExpression)([]), null, [(0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("n"), (0, tsgen_1.id)("number"))], [(0, tsgen_1.tExpressionStatement)((0, tsgen_1.id)("return n.toString(2).length"))]);
  }
  complex_expr.bitlenFunctionDecl = bitlenFunctionDecl;
  function typedSlice() {
    return [(0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("slice"), (0, tsgen_1.id)("Slice"))];
  }
  complex_expr.typedSlice = typedSlice;
  function sliceLoad(slicePrefix, currentSlice) {
    return (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tDeclareVariable)((0, tsgen_1.id)((0, utils_1.getCurrentSlice)(slicePrefix, "slice")), (0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)(currentSlice), (0, tsgen_1.id)("loadRef")), []), (0, tsgen_1.id)("beginParse")), [(0, tsgen_1.id)("true")])));
  }
  complex_expr.sliceLoad = sliceLoad;
  function simpleCycle(varName, finish) {
    return (0, tsgen_1.tForCycle)((0, tsgen_1.tDeclareVariable)((0, tsgen_1.id)(varName), (0, tsgen_1.tNumericLiteral)(0)), (0, tsgen_1.tBinaryExpression)((0, tsgen_1.id)(varName), "<", finish), (0, tsgen_1.tNumericLiteral)(5), []);
  }
  complex_expr.simpleCycle = simpleCycle;
  function storeFunctionParam(varName) {
    return (0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("store" + varName), (0, tsgen_1.tArrowFunctionType)([(0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)((0, utils_1.firstLower)(varName)), (0, tsgen_1.id)(varName))], (0, tsgen_1.tArrowFunctionType)([(0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("builder"), (0, tsgen_1.id)("Builder"))], (0, tsgen_1.id)("void"))));
  }
  complex_expr.storeFunctionParam = storeFunctionParam;
  function loadFunctionParam(varName) {
    return (0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("load" + varName), (0, tsgen_1.tArrowFunctionType)(typedSlice(), (0, tsgen_1.id)(varName)));
  }
  complex_expr.loadFunctionParam = loadFunctionParam;
  function skipTagStmt(bitLen) {
    return (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)("slice"), (0, tsgen_1.id)("loadUint")), [(0, tsgen_1.tNumericLiteral)(bitLen)]));
  }
  complex_expr.skipTagStmt = skipTagStmt;
  function checkTagExpr(tag) {
    return tEqualExpression((0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)("slice"), (0, tsgen_1.id)("preloadUint")), [(0, tsgen_1.tNumericLiteral)(tag.bitLen)]), (0, tsgen_1.id)(tag.binary));
  }
  complex_expr.checkTagExpr = checkTagExpr;
  function checkHasBitsForTag(bitLen) {
    return (0, tsgen_1.tBinaryExpression)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)("slice"), (0, tsgen_1.id)("remainingBits")), ">=", (0, tsgen_1.tNumericLiteral)(bitLen));
  }
  complex_expr.checkHasBitsForTag = checkHasBitsForTag;
  function storeFunctionExpr(typeParamExpr, storeExpr2) {
    return (0, tsgen_1.tArrowFunctionExpression)([(0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("arg"), typeParamExpr)], [(0, tsgen_1.tReturnStatement)((0, tsgen_1.tArrowFunctionExpression)([(0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("builder"), (0, tsgen_1.id)("Builder"))], [storeExpr2]))]);
  }
  complex_expr.storeFunctionExpr = storeFunctionExpr;
  function coverFuncCall(loadExpr) {
    return loadExpr.type == "FunctionCall" ? (0, tsgen_1.tArrowFunctionExpression)(typedSlice(), [(0, tsgen_1.tReturnStatement)(loadExpr)]) : loadExpr;
  }
  complex_expr.coverFuncCall = coverFuncCall;
  function storeExprForParam(theCell, exprForParam, insideStoreParameters) {
    return (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)(theCell), (0, tsgen_1.id)("store" + exprForParam.fieldStoreSuffix)), insideStoreParameters));
  }
  complex_expr.storeExprForParam = storeExprForParam;
  function returnSliceFunc() {
    return (0, tsgen_1.tArrowFunctionExpression)(typedSlice(), [
      (0, tsgen_1.tReturnStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)("slice"), (0, tsgen_1.id)("asCell")), []))
    ]);
  }
  complex_expr.returnSliceFunc = returnSliceFunc;
  function loadExprForParam(currentSlice, exprForParam) {
    return (0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)(currentSlice), (0, tsgen_1.id)("load" + exprForParam.fieldLoadSuffix)), exprForParam.argLoadExpr ? [exprForParam.argLoadExpr] : []);
  }
  complex_expr.loadExprForParam = loadExprForParam;
  function storeCombinator(typeName, insideStoreParameters, storeFunctionsArray, currentTypeParameters, theCell) {
    return (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tFunctionCall)((0, tsgen_1.id)("store" + typeName), insideStoreParameters.concat(storeFunctionsArray), currentTypeParameters), [(0, tsgen_1.id)(theCell)]));
  }
  complex_expr.storeCombinator = storeCombinator;
  function storeInNewCell(currentCell, storeExpr) {
    return (0, tsgen_1.tMultiStatement)([
      (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tDeclareVariable)((0, tsgen_1.id)(currentCell), (0, tsgen_1.tFunctionCall)((0, tsgen_1.id)("beginCell"), []))),
      storeExpr,
      (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)("builder"), (0, tsgen_1.id)("storeRef")), [(0, tsgen_1.id)(currentCell)]))
    ]);
  }
  complex_expr.storeInNewCell = storeInNewCell;
  function loadFromNewSlice(loadExpr) {
    return (0, tsgen_1.tArrowFunctionExpression)(typedSlice(), [sliceLoad([1, 0], "slice"), (0, tsgen_1.tReturnStatement)(loadExpr)]);
  }
  complex_expr.loadFromNewSlice = loadFromNewSlice;
  function arrayedType(typeParamExpr) {
    return (0, tsgen_1.tTypeWithParameters)((0, tsgen_1.id)("Array"), (0, tsgen_1.tTypeParametersExpression)([typeParamExpr]));
  }
  complex_expr.arrayedType = arrayedType;
  function storeTupleStmt(currentParam, storeExpr, typeParamExpr) {
    return (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)(currentParam, (0, tsgen_1.id)("forEach")), [
      (0, tsgen_1.tArrowFunctionExpression)([(0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("arg"), typeParamExpr)], [storeExpr])
    ]));
  }
  complex_expr.storeTupleStmt = storeTupleStmt;
  function loadTupleExpr(arrayLength, loadExpr) {
    return (0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)("Array"), (0, tsgen_1.id)("from")), [
      (0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.tFunctionCall)((0, tsgen_1.id)("Array"), [arrayLength]), (0, tsgen_1.id)("keys")), [])
    ]), (0, tsgen_1.id)("map")), [(0, tsgen_1.tArrowFunctionExpression)([(0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("arg"), (0, tsgen_1.id)("number"))], [(0, tsgen_1.tReturnStatement)(loadExpr)])]);
  }
  complex_expr.loadTupleExpr = loadTupleExpr;
  function storeExprCond(currentParam, storeExpr) {
    return (0, tsgen_1.tIfStatement)((0, tsgen_1.tBinaryExpression)(currentParam, "!=", (0, tsgen_1.id)("undefined")), [storeExpr]);
  }
  complex_expr.storeExprCond = storeExprCond;
  function storeExpressionNamedType(typeName, insideStoreParameters, currentCell) {
    return (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tFunctionCall)((0, tsgen_1.id)("store" + typeName), insideStoreParameters), [(0, tsgen_1.id)(currentCell)]));
  }
  complex_expr.storeExpressionNamedType = storeExpressionNamedType;
  function storeRefObjectStmt(currentCell, ctx, field) {
    return (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)(currentCell), (0, tsgen_1.id)("storeRef")), [
      (0, tsgen_1.tMemberExpression)((0, tsgen_1.id)(ctx.typeName), (0, tsgen_1.id)(field.name))
    ]));
  }
  complex_expr.storeRefObjectStmt = storeRefObjectStmt;
  function loadRefStmt(slicePrefix, currentSlice) {
    return (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tDeclareVariable)((0, tsgen_1.id)((0, utils_1.getCurrentSlice)(slicePrefix, "cell")), (0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)(currentSlice), (0, tsgen_1.id)("loadRef")), [])));
  }
  complex_expr.loadRefStmt = loadRefStmt;
  function storeRefStmt(slicePrefix, currentCell) {
    return (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)(currentCell), (0, tsgen_1.id)("storeRef")), [(0, tsgen_1.id)((0, utils_1.getCurrentSlice)(slicePrefix, "cell"))]));
  }
  complex_expr.storeRefStmt = storeRefStmt;
  function newCellStmt(slicePrefix) {
    return (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tDeclareVariable)((0, tsgen_1.id)((0, utils_1.getCurrentSlice)(slicePrefix, "cell")), (0, tsgen_1.tFunctionCall)((0, tsgen_1.id)("beginCell"), [])));
  }
  complex_expr.newCellStmt = newCellStmt;
  function checkConstraintStmt(constraintAST, exceptionCommentLastPart) {
    return (0, tsgen_1.tIfStatement)((0, tsgen_1.tUnaryOpExpression)("!", constraintAST), [
      (0, tsgen_1.tExpressionStatement)((0, tsgen_1.id)("throw new Error('Condition " + (0, tsgen_1.toCode)(constraintAST).code + exceptionCommentLastPart + "')"))
    ]);
  }
  complex_expr.checkConstraintStmt = checkConstraintStmt;
  function inSeparateRef(slicePrefix, callback) {
    slicePrefix[slicePrefix.length - 1]++;
    slicePrefix.push(0);
    callback();
    slicePrefix.pop();
  }
  complex_expr.inSeparateRef = inSeparateRef;
  function negationDerivationFuncDecl(tlbCode, getParameterFunctionId, fieldName, fieldTypeName, argIndex) {
    return (0, tsgen_1.tFunctionDeclaration)(getParameterFunctionId, (0, tsgen_1.tTypeParametersExpression)([]), (0, tsgen_1.id)("number"), [(0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)((0, utils_1.findNotReservedName)(fieldName)), (0, tsgen_1.id)(fieldTypeName))], (0, utils_2.getNegationDerivationFunctionBody)(tlbCode, fieldTypeName, argIndex, fieldName));
  }
  complex_expr.negationDerivationFuncDecl = negationDerivationFuncDecl;
  function dictStoreStmt(currentCell, storeParametersInside, keyForStore, valueStore, direct) {
    return (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)(currentCell), (0, tsgen_1.id)("storeDict" + (direct ? "Direct" : ""))), storeParametersInside.concat([keyForStore, valueStore])));
  }
  complex_expr.dictStoreStmt = dictStoreStmt;
  function dictTypeParamExpr(fieldType, typeParamExpr) {
    return (0, tsgen_1.tTypeWithParameters)((0, tsgen_1.id)("Dictionary"), (0, tsgen_1.tTypeParametersExpression)([(0, utils_2.isBigIntExpr)(fieldType.key) ? (0, tsgen_1.id)("bigint") : (0, tsgen_1.id)("number"), typeParamExpr]));
  }
  complex_expr.dictTypeParamExpr = dictTypeParamExpr;
  function dictValueStore(typeParamExpr, storeFunctionExpr2, extraStoreFunctionExpr) {
    let subStatements = [
      (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tFunctionCall)(storeFunctionExpr2, [(0, tsgen_1.id)(extraStoreFunctionExpr ? "arg.value" : "arg")]), [
        (0, tsgen_1.id)("builder")
      ]))
    ];
    if (extraStoreFunctionExpr) {
      subStatements = [
        (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tFunctionCall)(extraStoreFunctionExpr, [(0, tsgen_1.id)("arg.extra")]), [(0, tsgen_1.id)("builder")]))
      ].concat(subStatements);
    }
    return (0, tsgen_1.tObjectExpression)([
      (0, tsgen_1.tObjectProperty)((0, tsgen_1.id)("serialize"), (0, tsgen_1.tArrowFunctionExpression)([(0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("arg"), typeParamExpr), (0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("builder"), (0, tsgen_1.id)("Builder"))], subStatements)),
      (0, tsgen_1.tObjectProperty)((0, tsgen_1.id)("parse"), (0, tsgen_1.id)("() => { throw new Error('Not implemented') }"))
    ]);
  }
  complex_expr.dictValueStore = dictValueStore;
  function dictLoadExpr(keyForLoad, loadFunctionExpr, currentSlice, direct) {
    return (0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)("Dictionary"), (0, tsgen_1.id)("load" + (direct ? "Direct" : ""))), [
      keyForLoad,
      dictValueLoad(loadFunctionExpr),
      (0, tsgen_1.id)(currentSlice)
    ]);
  }
  complex_expr.dictLoadExpr = dictLoadExpr;
  function dictValueLoad(loadFunctionExpr) {
    return (0, tsgen_1.tObjectExpression)([
      (0, tsgen_1.tObjectProperty)((0, tsgen_1.id)("serialize"), (0, tsgen_1.id)("() => { throw new Error('Not implemented') }")),
      (0, tsgen_1.tObjectProperty)((0, tsgen_1.id)("parse"), loadFunctionExpr)
    ]);
  }
  function dictKeyExpr(keyType, ctx, objectId) {
    let param;
    if (objectId) {
      param = (0, utils_2.convertToAST)(keyType.expr, ctx.constructor, (0, tsgen_1.id)(objectId));
    } else {
      param = (0, utils_2.convertToAST)(keyType.expr, ctx.constructor);
    }
    return (0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)("Dictionary.Keys"), (0, utils_2.isBigIntExpr)(keyType) ? (0, tsgen_1.id)("BigUint") : (0, tsgen_1.id)("Uint")), [
      param
    ]);
  }
  complex_expr.dictKeyExpr = dictKeyExpr;
  function dictAugParse(extraLoadExpr, loadExpr) {
    return (0, tsgen_1.tArrowFunctionExpression)([(0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("slice"), (0, tsgen_1.id)("Slice"))], [
      (0, tsgen_1.tReturnStatement)((0, tsgen_1.tObjectExpression)([
        (0, tsgen_1.tObjectProperty)((0, tsgen_1.id)("extra"), extraLoadExpr),
        (0, tsgen_1.tObjectProperty)((0, tsgen_1.id)("value"), loadExpr)
      ]))
    ]);
  }
  complex_expr.dictAugParse = dictAugParse;
  function dictAugTypeExpr(typeExpr, extraTypeExpr) {
    return (0, tsgen_1.tStructExpression)([(0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("value"), typeExpr), (0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("extra"), extraTypeExpr)]);
  }
  complex_expr.dictAugTypeExpr = dictAugTypeExpr;
  return complex_expr;
}
var hasRequiredGenerator;
function requireGenerator() {
  if (hasRequiredGenerator) return generator;
  hasRequiredGenerator = 1;
  Object.defineProperty(generator, "__esModule", { value: true });
  generator.TypescriptGenerator = void 0;
  const ast_1 = requireAst();
  const utils_1 = requireUtils$4();
  const CodeBuilder_1 = requireCodeBuilder();
  const complex_expr_1 = requireComplex_expr();
  const tsgen_1 = requireTsgen();
  const utils_2 = requireUtils$2();
  class TypescriptGenerator {
    constructor(tlbCode) {
      this.jsCodeDeclarations = [];
      this.jsCodeConstructorDeclarations = [];
      this.jsCodeFunctionsDeclarations = [];
      this.tlbCode = tlbCode;
    }
    addTonCoreClassUsage(name) {
      this.jsCodeDeclarations.push((0, tsgen_1.tImportDeclaration)((0, tsgen_1.id)(name), (0, tsgen_1.tStringLiteral)("@ton/core")));
    }
    addBuiltinCode() {
      this.addBitLenFunction();
      this.addEmbeddedTypes();
      this.addCopyCellToBuilder();
    }
    addBitLenFunction() {
      this.jsCodeDeclarations.push((0, complex_expr_1.bitlenFunctionDecl)());
    }
    addCopyCellToBuilder() {
      this.jsCodeDeclarations.push((0, tsgen_1.tCodeAsIs)(`export function copyCellToBuilder(from: Cell, to: Builder): void {
    let slice = from.beginParse();
    to.storeBits(slice.loadBits(slice.remainingBits));
    while (slice.remainingRefs) {
        to.storeRef(slice.loadRef());
    }
}`));
    }
    addEmbeddedTypes() {
      this.jsCodeDeclarations.push((0, tsgen_1.tCodeAsIs)(`export interface Bool {
    readonly kind: 'Bool';
    readonly value: boolean;
}

export function loadBool(slice: Slice): Bool {
    if (slice.remainingBits >= 1) {
        let value = slice.loadUint(1);
        return {
            kind: 'Bool',
            value: value == 1
        }

    }
    throw new Error('Expected one of "BoolFalse" in loading "BoolFalse", but data does not satisfy any constructor');
}

export function storeBool(bool: Bool): (builder: Builder) => void {
    return ((builder: Builder) => {
        builder.storeUint(bool.value ? 1: 0, 1);
    })

}



export function loadBoolFalse(slice: Slice): Bool {
  if (((slice.remainingBits >= 1) && (slice.preloadUint(1) == 0b0))) {
      slice.loadUint(1);
      return {
          kind: 'Bool',
          value: false
      }

  }
  throw new Error('Expected one of "BoolFalse" in loading "BoolFalse", but data does not satisfy any constructor');
}

export function loadBoolTrue(slice: Slice): Bool {
  if (((slice.remainingBits >= 1) && (slice.preloadUint(1) == 0b1))) {
      slice.loadUint(1);
      return {
          kind: 'Bool',
          value: true
      }

  }
  throw new Error('Expected one of "BoolTrue" in loading "BoolTrue", but data does not satisfy any constructor');
}
`));
    }
    addTlbType(tlbType) {
      let typeName = (0, utils_1.findNotReservedName)((0, utils_1.firstLower)(tlbType.name), "0");
      let typeUnion = [];
      let constructorsDeclarations = [];
      let loadStatements = [];
      let storeStatements = [];
      let structTypeParametersExpr = (0, tsgen_1.tTypeParametersExpression)([]);
      tlbType.constructors.forEach((constructor) => {
        let constructorTypeName = (0, utils_1.getSubStructName)(tlbType, constructor);
        let ctx = {
          constructor,
          name: (0, utils_1.findNotReservedName)((0, utils_1.firstLower)(constructorTypeName), "_" + constructor.name),
          typeName,
          loadStatements: [],
          loadProperties: [(0, tsgen_1.tObjectProperty)((0, tsgen_1.id)("kind"), (0, tsgen_1.tStringLiteral)(constructorTypeName))],
          properties: [(0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("kind"), (0, tsgen_1.tStringLiteral)(constructorTypeName))],
          storeStatements: []
        };
        structTypeParametersExpr = (0, utils_2.getTypeParametersExpression)(constructor.parameters);
        let slicePrefix = [0];
        constructor.variables.forEach((variable) => {
          this.addVarToConstructorLoadProperty(variable, ctx, constructor);
        });
        constructor.fields.forEach((field) => {
          this.handleField(field, slicePrefix, ctx);
        });
        typeUnion.push((0, tsgen_1.tTypeWithParameters)((0, tsgen_1.id)(constructorTypeName), structTypeParametersExpr));
        let structX = (0, tsgen_1.tStructDeclaration)((0, tsgen_1.id)(constructorTypeName), ctx.properties, structTypeParametersExpr);
        constructor.constraints.forEach((constraint) => {
          this.genCodeForConstraint(constraint, typeName, tlbType, ctx);
        });
        ctx.loadStatements.push((0, tsgen_1.tReturnStatement)((0, tsgen_1.tObjectExpression)(ctx.loadProperties)));
        loadStatements = this.constructorStmtsToTypeStmts(constructor, tlbType, ctx, loadStatements);
        if (constructor.tag.bitLen != 0) {
          ctx.storeStatements.splice(0, 0, (0, complex_expr_1.storeTagExpression)(constructor.tag));
        }
        let storeStatement = (0, complex_expr_1.storeFunctionStmt)(ctx.storeStatements);
        if (tlbType.constructors.length > 1) {
          storeStatement = (0, complex_expr_1.checkKindStmt)(typeName, constructorTypeName, storeStatement);
        }
        storeStatements.push(storeStatement);
        constructorsDeclarations.push(structX);
        this.jsCodeFunctionsDeclarations.push((0, tsgen_1.tComment)(constructor.declaration));
        this.jsCodeConstructorDeclarations.push((0, tsgen_1.tComment)(constructor.declaration));
      });
      this.addExceptionStmts(tlbType, loadStatements, storeStatements);
      let loadFunctionParameters = (0, complex_expr_1.typedSlice)();
      const currentType = (0, tsgen_1.tTypeWithParameters)((0, tsgen_1.id)(tlbType.name), structTypeParametersExpr);
      let storeFunctionParameters = [(0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)(typeName), currentType)];
      this.addFunctionParameters(tlbType, loadFunctionParameters, storeFunctionParameters);
      let loadFunction = (0, tsgen_1.tFunctionDeclaration)((0, tsgen_1.id)("load" + tlbType.name), structTypeParametersExpr, currentType, loadFunctionParameters, loadStatements);
      let storeFunction = (0, tsgen_1.tFunctionDeclaration)((0, tsgen_1.id)("store" + tlbType.name), structTypeParametersExpr, (0, tsgen_1.id)("(builder: Builder) => void"), storeFunctionParameters, storeStatements);
      if (tlbType.constructors.length > 1) {
        this.jsCodeConstructorDeclarations.push((0, tsgen_1.tUnionTypeDeclaration)(currentType, (0, tsgen_1.tUnionTypeExpression)(typeUnion)));
      }
      constructorsDeclarations.forEach((element) => {
        this.jsCodeConstructorDeclarations.push(element);
      });
      this.jsCodeFunctionsDeclarations.push(loadFunction);
      this.jsCodeFunctionsDeclarations.push(storeFunction);
    }
    addFunctionParameters(tlbType, loadFunctionParameters, storeFunctionParameters) {
      let anyConstructor = tlbType.constructors[0];
      if (anyConstructor) {
        anyConstructor.parameters.forEach((element) => {
          if (element.variable.type == "Type") {
            loadFunctionParameters.push((0, complex_expr_1.loadFunctionParam)(element.variable.name));
            storeFunctionParameters.push((0, complex_expr_1.storeFunctionParam)(element.variable.name));
          }
          if (element.variable.type == "#" && !element.variable.negated) {
            if (element.argName) {
              loadFunctionParameters.push((0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)(element.argName), (0, tsgen_1.id)("number")));
            } else {
              loadFunctionParameters.push((0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)(element.variable.name), (0, tsgen_1.id)("number")));
            }
          }
        });
      } else {
        throw new Error(`Type ${tlbType.name} should have at least one constructor`);
      }
    }
    addExceptionStmts(tlbType, loadStatements, storeStatements) {
      var _a2;
      let exceptionTypesComment = tlbType.constructors.map((constructor) => {
        return `"${(0, utils_1.getSubStructName)(tlbType, constructor)}"`;
      }).join(", ");
      let exceptionComment = (0, tsgen_1.tExpressionStatement)((0, tsgen_1.id)(`throw new Error('Expected one of ${exceptionTypesComment} in loading "${tlbType.name}", but data does not satisfy any constructor')`));
      if (tlbType.constructors.length > 1 || ((_a2 = tlbType.constructors.at(0)) === null || _a2 === void 0 ? void 0 : _a2.tag.bitLen) != 0) {
        loadStatements.push(exceptionComment);
      }
      if (tlbType.constructors.length > 1) {
        storeStatements.push(exceptionComment);
      }
    }
    constructorStmtsToTypeStmts(constructor, tlbType, ctx, loadStatements) {
      if (constructor.tag.bitLen != 0 || tlbType.constructors.length > 1) {
        let conditions = [];
        if (constructor.tag.bitLen != 0) {
          conditions.push((0, complex_expr_1.checkHasBitsForTag)(constructor.tag.bitLen));
          conditions.push((0, complex_expr_1.checkTagExpr)(constructor.tag));
          let loadBitsStatement = [(0, complex_expr_1.skipTagStmt)(constructor.tag.bitLen)];
          ctx.loadStatements = loadBitsStatement.concat(ctx.loadStatements);
        }
        constructor.parameters.forEach((param) => {
          if (param.variable.isConst && !param.variable.negated) {
            let argName = param.variable.name;
            if (param.argName) {
              argName = param.argName;
            }
            conditions.push((0, complex_expr_1.tEqualExpression)((0, tsgen_1.id)(argName), (0, utils_2.getParamVarExpr)(param, constructor)));
          }
        });
        loadStatements.push((0, tsgen_1.tIfStatement)((0, utils_2.getCondition)(conditions), ctx.loadStatements));
      } else {
        loadStatements = loadStatements.concat(ctx.loadStatements);
      }
      return loadStatements;
    }
    genCodeForConstraint(constraint, variableCombinatorName, tlbType, ctx) {
      let loadConstraintAST = (0, utils_2.convertToAST)(constraint, ctx.constructor);
      let storeConstraintAST = (0, utils_2.convertToAST)(constraint, ctx.constructor, (0, tsgen_1.id)(variableCombinatorName));
      let exceptionCommentLastPart = ` is not satisfied while loading "${(0, utils_1.getSubStructName)(tlbType, ctx.constructor)}" for type "${tlbType.name}"`;
      ctx.loadStatements.push((0, complex_expr_1.checkConstraintStmt)(loadConstraintAST, exceptionCommentLastPart));
      ctx.storeStatements.push((0, complex_expr_1.checkConstraintStmt)(storeConstraintAST, exceptionCommentLastPart));
    }
    addVarToConstructorLoadProperty(variable, ctx, constructor) {
      let varExpr = void 0;
      if (variable.negated) {
        if (variable.deriveExpr) {
          varExpr = (0, utils_2.convertToAST)(variable.deriveExpr, constructor);
        }
      }
      if (variable.type == "#" && !variable.isField) {
        const isOptional = this.isOptionalVariable(variable, ctx);
        ctx.properties.push((0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)(variable.name), (0, tsgen_1.id)("number"), isOptional));
        let parameter = constructor.parametersMap.get(variable.name);
        if (parameter && !parameter.variable.isConst && !parameter.variable.negated) {
          varExpr = (0, utils_2.getParamVarExpr)(parameter, constructor);
        }
      }
      if (varExpr) {
        ctx.loadProperties.push((0, tsgen_1.tObjectProperty)((0, tsgen_1.id)(variable.name), varExpr));
      }
    }
    toCode(node, code = new CodeBuilder_1.CodeBuilder()) {
      return (0, tsgen_1.toCode)(node, code);
    }
    handleField(field, slicePrefix, ctx) {
      let currentSlice = (0, utils_1.getCurrentSlice)(slicePrefix, "slice");
      let currentCell = (0, utils_1.getCurrentSlice)(slicePrefix, "cell");
      if (field.subFields.length > 0) {
        (0, complex_expr_1.inSeparateRef)(slicePrefix, () => {
          ctx.loadStatements.push((0, complex_expr_1.sliceLoad)(slicePrefix, currentSlice));
          ctx.storeStatements.push((0, complex_expr_1.newCellStmt)(slicePrefix));
          field.subFields.forEach((fieldDef) => {
            this.handleField(fieldDef, slicePrefix, ctx);
          });
          ctx.storeStatements.push((0, complex_expr_1.storeRefStmt)(slicePrefix, currentCell));
        });
      }
      if (field.fieldType.kind == "TLBExoticType") {
        (0, complex_expr_1.inSeparateRef)(slicePrefix, () => {
          ctx.loadStatements.push((0, complex_expr_1.loadRefStmt)(slicePrefix, currentSlice));
          (0, utils_2.addLoadProperty)(field.name, (0, tsgen_1.id)((0, utils_1.getCurrentSlice)(slicePrefix, "cell")), void 0, ctx);
          ctx.properties.push((0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)(field.name), (0, tsgen_1.id)("Cell")));
          ctx.storeStatements.push((0, complex_expr_1.storeRefObjectStmt)(currentCell, ctx, field));
        });
      } else if (field.subFields.length == 0) {
        let fieldInfo = this.handleType(field, field.fieldType, true, ctx, slicePrefix, 0);
        if (fieldInfo.loadExpr) {
          (0, utils_2.addLoadProperty)(field.name, fieldInfo.loadExpr, fieldInfo.typeParamExpr, ctx);
        }
        if (fieldInfo.typeParamExpr) {
          ctx.properties.push((0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)(field.name), fieldInfo.typeParamExpr));
        }
        if (fieldInfo.storeStmtOutside) {
          ctx.storeStatements.push(fieldInfo.storeStmtOutside);
        }
        fieldInfo.negatedVariablesLoads.forEach((element) => {
          (0, utils_2.addLoadProperty)(element.name, element.expression, void 0, ctx);
        });
      }
    }
    handleType(field, fieldType, isField, ctx, slicePrefix, argIndex) {
      let currentSlice = (0, utils_1.getCurrentSlice)(slicePrefix, "slice");
      let currentCell = (0, utils_1.getCurrentSlice)(slicePrefix, "cell");
      let fieldName = field.name;
      let theSlice = "slice";
      let theCell = "builder";
      if (isField) {
        theSlice = currentSlice;
        theCell = currentCell;
      }
      let result = {
        typeParamExpr: void 0,
        loadExpr: void 0,
        loadFunctionExpr: void 0,
        storeStmtOutside: void 0,
        storeStmtInside: void 0,
        storeFunctionExpr: void 0,
        negatedVariablesLoads: []
      };
      let exprForParam;
      let storeParametersOutside;
      storeParametersOutside = [(0, tsgen_1.tMemberExpression)((0, tsgen_1.id)(ctx.typeName), (0, tsgen_1.id)(fieldName))];
      let storeParametersInside = [(0, tsgen_1.id)("arg")];
      if (fieldType.kind == "TLBNumberType") {
        exprForParam = {
          argLoadExpr: (0, utils_2.convertToAST)(fieldType.bits, ctx.constructor),
          argStoreExpr: (0, utils_2.convertToAST)(fieldType.storeBits, ctx.constructor, (0, tsgen_1.id)(ctx.typeName)),
          paramType: "number",
          fieldLoadSuffix: fieldType.signed ? "Int" : "Uint",
          fieldStoreSuffix: fieldType.signed ? "Int" : "Uint"
        };
        if ((0, utils_2.isBigInt)(fieldType)) {
          exprForParam.fieldLoadSuffix += "Big";
          exprForParam.paramType = "bigint";
        }
      } else if (fieldType.kind == "TLBBitsType") {
        if (fieldType.bits instanceof ast_1.TLBNumberExpr && fieldType.bits.n == 1) {
          exprForParam = {
            argLoadExpr: void 0,
            argStoreExpr: void 0,
            paramType: "boolean",
            fieldLoadSuffix: "Bit",
            fieldStoreSuffix: "Bit"
          };
        } else {
          let isBuffer2 = (0, utils_2.useBuffer)(fieldType);
          let suffix = isBuffer2 ? "Buffer" : "Bits";
          let argLoadExpr = (0, utils_2.convertToAST)(fieldType.bits, ctx.constructor);
          let argStoreExpr = (0, utils_2.convertToAST)(fieldType.bits, ctx.constructor, (0, tsgen_1.id)(ctx.name));
          if (isBuffer2) {
            argLoadExpr = (0, tsgen_1.tBinaryExpression)(argLoadExpr, "/", (0, tsgen_1.tNumericLiteral)(8));
            argStoreExpr = (0, tsgen_1.tBinaryExpression)(argStoreExpr, "/", (0, tsgen_1.tNumericLiteral)(8));
          }
          exprForParam = {
            argLoadExpr,
            argStoreExpr,
            paramType: isBuffer2 ? "Buffer" : "BitString",
            fieldLoadSuffix: suffix,
            fieldStoreSuffix: suffix
          };
        }
      } else if (fieldType.kind == "TLBCellType") {
        exprForParam = {
          argLoadExpr: (0, tsgen_1.id)(theSlice),
          argStoreExpr: (0, tsgen_1.id)(theSlice),
          paramType: "Cell",
          fieldLoadSuffix: "Ref",
          fieldStoreSuffix: "Slice"
        };
        storeParametersOutside[0] = (0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)(storeParametersOutside[0], (0, tsgen_1.id)("beginParse")), [
          (0, tsgen_1.id)("true")
        ]);
        storeParametersInside[0] = (0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)(storeParametersInside[0], (0, tsgen_1.id)("beginParse")), [
          (0, tsgen_1.id)("true")
        ]);
      } else if (fieldType.kind == "TLBCoinsType") {
        exprForParam = {
          argLoadExpr: void 0,
          argStoreExpr: void 0,
          paramType: "bigint",
          fieldLoadSuffix: "Coins",
          fieldStoreSuffix: "Coins"
        };
      } else if (fieldType.kind == "TLBVarIntegerType") {
        exprForParam = {
          argLoadExpr: (0, utils_2.convertToAST)(fieldType.n, ctx.constructor),
          argStoreExpr: (0, utils_2.convertToAST)(fieldType.n, ctx.constructor, (0, tsgen_1.id)(ctx.name)),
          paramType: "bigint",
          fieldLoadSuffix: fieldType.signed ? "VarIntBig" : "VarUintBig",
          fieldStoreSuffix: fieldType.signed ? "VarInt" : "VarUint"
        };
      } else if (fieldType.kind == "TLBTupleType") {
        result.loadExpr = (0, tsgen_1.tFunctionCall)((0, tsgen_1.id)("parseTuple"), [
          (0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)("slice"), (0, tsgen_1.id)("asCell")), [])
        ]);
        result.typeParamExpr = (0, tsgen_1.id)("TupleItem[]");
        result.storeStmtInside = (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.id)("copyCellToBuilder"), [
          (0, tsgen_1.tFunctionCall)((0, tsgen_1.id)("serializeTuple"), storeParametersInside),
          (0, tsgen_1.id)("builder")
        ]));
        result.storeStmtOutside = (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.id)("copyCellToBuilder"), [
          (0, tsgen_1.tFunctionCall)((0, tsgen_1.id)("serializeTuple"), storeParametersOutside),
          (0, tsgen_1.id)("builder")
        ]));
      } else if (fieldType.kind == "TLBAddressType") {
        if (fieldType.addrType == "Internal") {
          exprForParam = {
            argLoadExpr: void 0,
            argStoreExpr: void 0,
            paramType: "Address",
            fieldLoadSuffix: "Address",
            fieldStoreSuffix: "Address"
          };
        } else if (fieldType.addrType == "External") {
          exprForParam = {
            argLoadExpr: void 0,
            argStoreExpr: void 0,
            paramType: "ExternalAddress | null",
            fieldLoadSuffix: "MaybeExternalAddress",
            fieldStoreSuffix: "Address"
          };
        } else if (fieldType.addrType == "Any") {
          exprForParam = {
            argLoadExpr: void 0,
            argStoreExpr: void 0,
            paramType: "Address | ExternalAddress | null",
            fieldLoadSuffix: "AddressAny",
            fieldStoreSuffix: "Address"
          };
        } else {
          throw new Error("Address has type other than ['Internal', 'External', 'Any']");
        }
      } else if (fieldType.kind == "TLBExprMathType") {
        result.loadExpr = (0, utils_2.convertToAST)(fieldType.expr, ctx.constructor);
        result.storeStmtOutside = (0, tsgen_1.tExpressionStatement)(result.loadExpr);
      } else if (fieldType.kind == "TLBNegatedType") {
        let getParameterFunctionId = (0, tsgen_1.id)(ctx.name + "_get_" + fieldType.variableName);
        if (field.fieldType.kind == "TLBNamedType") {
          let fieldTypeName = field.fieldType.name;
          this.jsCodeFunctionsDeclarations.push((0, complex_expr_1.negationDerivationFuncDecl)(this.tlbCode, getParameterFunctionId, fieldName, fieldTypeName, argIndex));
        }
        result.negatedVariablesLoads.push({
          name: fieldType.variableName,
          expression: (0, tsgen_1.tFunctionCall)(getParameterFunctionId, [(0, tsgen_1.id)(fieldName)])
        });
      } else if (fieldType.kind == "TLBNamedType" && fieldType.arguments.length == 0) {
        let typeName = fieldType.name;
        result.typeParamExpr = (0, tsgen_1.id)(typeName);
        if (isField) {
          result.loadExpr = (0, tsgen_1.tFunctionCall)((0, tsgen_1.id)("load" + typeName), [(0, tsgen_1.id)(theSlice)]);
          result.storeStmtOutside = (0, complex_expr_1.storeExpressionNamedType)(typeName, storeParametersOutside, currentCell);
          result.storeStmtInside = (0, complex_expr_1.storeExpressionNamedType)(typeName, storeParametersInside, currentCell);
        } else {
          result.loadExpr = (0, tsgen_1.id)("load" + typeName);
          result.storeStmtOutside = (0, tsgen_1.tExpressionStatement)((0, tsgen_1.id)("store" + typeName));
        }
      } else if (fieldType.kind == "TLBCondType") {
        let subExprInfo;
        let conditionExpr;
        subExprInfo = this.handleType(field, fieldType.value, true, ctx, slicePrefix, argIndex);
        conditionExpr = (0, utils_2.convertToAST)(fieldType.condition, ctx.constructor);
        if (subExprInfo.typeParamExpr) {
          result.typeParamExpr = (0, tsgen_1.tUnionTypeExpression)([subExprInfo.typeParamExpr, (0, tsgen_1.id)("undefined")]);
        }
        if (subExprInfo.loadExpr) {
          result.loadExpr = (0, tsgen_1.tTernaryExpression)(conditionExpr, subExprInfo.loadExpr, (0, tsgen_1.id)("undefined"));
        }
        let currentParamOutside = storeParametersOutside[0];
        let currentParamInside = storeParametersInside[0];
        if (currentParamOutside && currentParamInside && subExprInfo.storeStmtOutside) {
          result.storeStmtOutside = (0, complex_expr_1.storeExprCond)(currentParamOutside, subExprInfo.storeStmtOutside);
          result.storeStmtInside = (0, complex_expr_1.storeExprCond)(currentParamInside, subExprInfo.storeStmtOutside);
        }
      } else if (fieldType.kind == "TLBMultipleType") {
        let arrayLength;
        let subExprInfo;
        arrayLength = (0, utils_2.convertToAST)(fieldType.times, ctx.constructor);
        subExprInfo = this.handleType(field, fieldType.value, false, ctx, slicePrefix, argIndex);
        let currentParamOutside = storeParametersOutside[0];
        let currentParamInside = storeParametersInside[0];
        if (subExprInfo.loadExpr) {
          result.loadExpr = (0, complex_expr_1.loadTupleExpr)(arrayLength, subExprInfo.loadExpr);
        }
        if (currentParamOutside && currentParamInside && subExprInfo.typeParamExpr && subExprInfo.storeStmtOutside) {
          if (subExprInfo.storeFunctionExpr && subExprInfo.storeStmtInside) {
            result.storeStmtOutside = (0, complex_expr_1.storeTupleStmt)(currentParamOutside, subExprInfo.storeStmtInside, subExprInfo.typeParamExpr);
            result.storeStmtInside = (0, complex_expr_1.storeTupleStmt)(currentParamInside, subExprInfo.storeStmtInside, subExprInfo.typeParamExpr);
          }
        }
        if (subExprInfo.typeParamExpr) {
          result.typeParamExpr = (0, complex_expr_1.arrayedType)(subExprInfo.typeParamExpr);
        }
      } else if (fieldType.kind == "TLBCellInsideType") {
        let currentCell2 = (0, utils_1.getCurrentSlice)([1, 0], "cell");
        let subExprInfo = this.handleType(field, fieldType.value, true, ctx, [1, 0], argIndex);
        if (subExprInfo.loadExpr) {
          result.typeParamExpr = subExprInfo.typeParamExpr;
          result.storeStmtOutside = subExprInfo.storeStmtOutside;
          result.negatedVariablesLoads = subExprInfo.negatedVariablesLoads;
          result.loadFunctionExpr = (0, complex_expr_1.loadFromNewSlice)(subExprInfo.loadExpr);
          result.loadExpr = (0, tsgen_1.tFunctionCall)(result.loadFunctionExpr, [(0, tsgen_1.id)(theSlice)]);
        }
        if (subExprInfo.storeStmtOutside) {
          result.storeStmtOutside = (0, complex_expr_1.storeInNewCell)(currentCell2, subExprInfo.storeStmtOutside);
        }
        if (subExprInfo.storeStmtInside) {
          result.storeStmtInside = (0, complex_expr_1.storeInNewCell)(currentCell2, subExprInfo.storeStmtInside);
        }
      } else if (fieldType.kind == "TLBBoolType") {
        let loadFunction = "load" + (fieldType.value === void 0 ? "Bool" : fieldType.value ? "BoolTrue" : "BoolFalse");
        result.loadExpr = (0, tsgen_1.tFunctionCall)((0, tsgen_1.id)(loadFunction), [(0, tsgen_1.id)("slice")]);
        result.typeParamExpr = (0, tsgen_1.id)("Bool");
        result.storeStmtInside = (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tFunctionCall)((0, tsgen_1.id)("storeBool"), storeParametersInside), [(0, tsgen_1.id)("builder")]));
        result.storeStmtOutside = (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tFunctionCall)((0, tsgen_1.id)("storeBool"), storeParametersOutside), [(0, tsgen_1.id)("builder")]));
      } else if (fieldType.kind == "TLBHashmapType") {
        let keyForLoad = (0, complex_expr_1.dictKeyExpr)(fieldType.key, ctx);
        let keyForStore = (0, complex_expr_1.dictKeyExpr)(fieldType.key, ctx, ctx.typeName);
        let subExprInfo = this.handleType(field, fieldType.value, fieldType.extra != void 0, ctx, slicePrefix, argIndex);
        if (subExprInfo.typeParamExpr && subExprInfo.loadFunctionExpr && subExprInfo.storeFunctionExpr) {
          let valueStore;
          if (fieldType.extra && subExprInfo.loadExpr) {
            let extraInfo = this.handleType(field, fieldType.extra, true, ctx, slicePrefix, argIndex);
            if (extraInfo.typeParamExpr) {
              subExprInfo.typeParamExpr = (0, complex_expr_1.dictAugTypeExpr)(subExprInfo.typeParamExpr, extraInfo.typeParamExpr);
            }
            valueStore = (0, complex_expr_1.dictValueStore)(subExprInfo.typeParamExpr, subExprInfo.storeFunctionExpr, extraInfo.storeFunctionExpr);
            if (extraInfo.loadExpr) {
              result.loadExpr = (0, complex_expr_1.dictLoadExpr)(keyForLoad, (0, complex_expr_1.dictAugParse)(extraInfo.loadExpr, subExprInfo.loadExpr), currentSlice, fieldType.directStore);
            }
          } else {
            valueStore = (0, complex_expr_1.dictValueStore)(subExprInfo.typeParamExpr, subExprInfo.storeFunctionExpr);
            result.loadExpr = (0, complex_expr_1.dictLoadExpr)(keyForLoad, subExprInfo.loadFunctionExpr, currentSlice, fieldType.directStore);
          }
          result.typeParamExpr = (0, complex_expr_1.dictTypeParamExpr)(fieldType, subExprInfo.typeParamExpr);
          result.storeStmtInside = (0, complex_expr_1.dictStoreStmt)(currentCell, storeParametersInside, keyForStore, valueStore, fieldType.directStore);
          result.storeStmtOutside = (0, complex_expr_1.dictStoreStmt)(currentCell, storeParametersOutside, keyForStore, valueStore, fieldType.directStore);
        }
      } else if (fieldType.kind == "TLBNamedType" && fieldType.arguments.length) {
        let typeName = fieldType.name;
        let typeExpression = (0, tsgen_1.tTypeParametersExpression)([]);
        let loadFunctionsArray = [];
        let storeFunctionsArray = [];
        let argIndex2 = -1;
        fieldType.arguments.forEach((arg) => {
          argIndex2++;
          let subExprInfo = this.handleType(field, arg, false, ctx, slicePrefix, argIndex2);
          if (subExprInfo.typeParamExpr) {
            typeExpression.typeParameters.push(subExprInfo.typeParamExpr);
          }
          if (subExprInfo.loadFunctionExpr) {
            loadFunctionsArray.push(subExprInfo.loadFunctionExpr);
          }
          if (subExprInfo.storeFunctionExpr) {
            storeFunctionsArray.push(subExprInfo.storeFunctionExpr);
          }
          result.negatedVariablesLoads = result.negatedVariablesLoads.concat(subExprInfo.negatedVariablesLoads);
        });
        result.typeParamExpr = (0, tsgen_1.tTypeWithParameters)((0, tsgen_1.id)(typeName), typeExpression);
        let currentTypeParameters = typeExpression;
        let insideLoadParameters = [(0, tsgen_1.id)(theSlice)];
        result.loadExpr = (0, tsgen_1.tFunctionCall)((0, tsgen_1.id)("load" + typeName), insideLoadParameters.concat(loadFunctionsArray), currentTypeParameters);
        result.storeStmtOutside = (0, complex_expr_1.storeCombinator)(typeName, storeParametersOutside, storeFunctionsArray, currentTypeParameters, theCell);
        result.storeStmtInside = (0, complex_expr_1.storeCombinator)(typeName, storeParametersInside, storeFunctionsArray, currentTypeParameters, theCell);
        if (exprForParam) {
          result.typeParamExpr = (0, tsgen_1.id)(exprForParam.paramType);
        }
      }
      if (exprForParam) {
        if (exprForParam.paramType != "BitString" && exprForParam.paramType != "Cell") {
          if (exprForParam.argStoreExpr) {
            storeParametersOutside.push(exprForParam.argStoreExpr);
            storeParametersInside.push(exprForParam.argStoreExpr);
          }
        }
        result.loadExpr = (0, complex_expr_1.loadExprForParam)(currentSlice, exprForParam);
        if (exprForParam.paramType == "Cell") {
          result.loadExpr = (0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)(currentSlice), (0, tsgen_1.id)("asCell")), []);
          result.loadFunctionExpr = (0, complex_expr_1.returnSliceFunc)();
        }
        result.typeParamExpr = (0, tsgen_1.id)(exprForParam.paramType);
        result.storeStmtOutside = (0, complex_expr_1.storeExprForParam)(theCell, exprForParam, storeParametersOutside);
        result.storeStmtInside = (0, complex_expr_1.storeExprForParam)(theCell, exprForParam, storeParametersInside);
      }
      if (result.loadExpr && !result.loadFunctionExpr) {
        result.loadFunctionExpr = (0, complex_expr_1.coverFuncCall)(result.loadExpr);
      }
      if (result.storeStmtOutside && !result.storeFunctionExpr) {
        if (!result.storeStmtInside) {
          result.storeStmtInside = result.storeStmtOutside;
        }
        if (result.typeParamExpr) {
          if (result.storeStmtOutside.type == "ExpressionStatement" && result.storeStmtOutside.expression.type == "FunctionCall" || result.storeStmtOutside.type == "MultiStatement") {
            result.storeFunctionExpr = (0, complex_expr_1.storeFunctionExpr)(result.typeParamExpr, result.storeStmtInside);
          } else {
            if (result.storeStmtOutside.type == "ExpressionStatement") {
              result.storeFunctionExpr = result.storeStmtOutside.expression;
            }
          }
        }
      }
      if (result.storeStmtInside) {
        result.storeStmtInside = Object.assign({}, result.storeStmtInside);
      }
      return result;
    }
    isOptionalVariable(variable, ctx) {
      const usedInStore = this.collectFieldsUsedInStore(ctx);
      const isParameter = ctx.constructor.parameters.some((param) => param.variable.name === variable.name || param.argName === variable.name);
      return !usedInStore.has(variable.name) && !isParameter;
    }
    collectFieldsUsedInStore(ctx) {
      const fieldsUsed = /* @__PURE__ */ new Set();
      for (const stmt of ctx.storeStatements) {
        this.extractFieldReferences(stmt, ctx.typeName, fieldsUsed);
      }
      return fieldsUsed;
    }
    extractFieldReferences(node, typeName, fieldsUsed) {
      if (!node)
        return;
      switch (node.type) {
        case "ExpressionStatement":
          this.extractFieldReferences(node.expression, typeName, fieldsUsed);
          break;
        case "IfStatement":
          this.extractFieldReferences(node.condition, typeName, fieldsUsed);
          if (node.body) {
            node.body.forEach((stmt) => this.extractFieldReferences(stmt, typeName, fieldsUsed));
          }
          if (node.elseBody) {
            node.elseBody.forEach((stmt) => this.extractFieldReferences(stmt, typeName, fieldsUsed));
          }
          break;
        case "MultiStatement":
          node.statements.forEach((stmt) => this.extractFieldReferences(stmt, typeName, fieldsUsed));
          break;
        case "ReturnStatement":
          this.extractFieldReferences(node.returnValue, typeName, fieldsUsed);
          break;
        case "MemberExpression":
          if (node.thisObject.type === "Identifier" && node.thisObject.name === typeName && node.memberName.type === "Identifier") {
            fieldsUsed.add(node.memberName.name);
          }
          this.extractFieldReferences(node.thisObject, typeName, fieldsUsed);
          break;
        case "FunctionCall":
          this.extractFieldReferences(node.functionId, typeName, fieldsUsed);
          node.parameters.forEach((param) => this.extractFieldReferences(param, typeName, fieldsUsed));
          break;
        case "BinaryExpression":
          this.extractFieldReferences(node.left, typeName, fieldsUsed);
          this.extractFieldReferences(node.right, typeName, fieldsUsed);
          break;
        case "UnaryOpExpression":
          this.extractFieldReferences(node.expr, typeName, fieldsUsed);
          break;
        case "TernaryExpression":
          this.extractFieldReferences(node.condition, typeName, fieldsUsed);
          this.extractFieldReferences(node.body, typeName, fieldsUsed);
          this.extractFieldReferences(node.elseBody, typeName, fieldsUsed);
          break;
        case "ArrowFunctionExpression":
          node.body.forEach((stmt) => this.extractFieldReferences(stmt, typeName, fieldsUsed));
          break;
        case "ObjectExpression":
          node.objectValues.forEach((prop) => {
            this.extractFieldReferences(prop.key, typeName, fieldsUsed);
            this.extractFieldReferences(prop.value, typeName, fieldsUsed);
          });
          break;
      }
    }
  }
  generator.TypescriptGenerator = TypescriptGenerator;
  return generator;
}
var hasRequiredMain;
function requireMain() {
  if (hasRequiredMain) return main$2;
  hasRequiredMain = 1;
  Object.defineProperty(main$2, "__esModule", { value: true });
  main$2.generateCode = main$2.generateCodeWithGenerator = main$2.getTLBCode = main$2.getGenerator = main$2.generateCodeByAST = main$2.getTLBCodeByAST = void 0;
  const tlb_parser_1 = requireDist$3();
  const fill_constructors_1 = requireFill_constructors();
  const fill_constructors_2 = requireFill_constructors();
  const CodeBuilder_1 = requireCodeBuilder();
  const generator_1 = requireGenerator();
  function getTLBCodeByAST(tree, input) {
    let oldTlbCode = { types: /* @__PURE__ */ new Map() };
    let splittedInput = input.split("\n");
    (0, fill_constructors_2.fillConstructors)(tree.declarations, oldTlbCode, splittedInput);
    return (0, fill_constructors_1.convertCodeToReadonly)(oldTlbCode);
  }
  main$2.getTLBCodeByAST = getTLBCodeByAST;
  function generateCodeByAST(tree, input, getGenerator2) {
    let tlbCode = getTLBCodeByAST(tree, input);
    let codeGenerator = getGenerator2(tlbCode);
    codeGenerator.addTonCoreClassUsage("Builder");
    codeGenerator.addTonCoreClassUsage("Slice");
    codeGenerator.addTonCoreClassUsage("beginCell");
    codeGenerator.addTonCoreClassUsage("BitString");
    codeGenerator.addTonCoreClassUsage("Cell");
    codeGenerator.addTonCoreClassUsage("Address");
    codeGenerator.addTonCoreClassUsage("ExternalAddress");
    codeGenerator.addTonCoreClassUsage("Dictionary");
    codeGenerator.addTonCoreClassUsage("DictionaryValue");
    codeGenerator.addTonCoreClassUsage("TupleItem");
    codeGenerator.addTonCoreClassUsage("parseTuple");
    codeGenerator.addTonCoreClassUsage("serializeTuple");
    codeGenerator.addBuiltinCode();
    let jsCodeDeclarations = [];
    codeGenerator.jsCodeDeclarations.forEach((declaration) => {
      jsCodeDeclarations.push(declaration);
    });
    tlbCode.types.forEach((tlbType) => {
      codeGenerator.addTlbType(tlbType);
    });
    let generatedCode = "";
    codeGenerator.jsCodeConstructorDeclarations.forEach((element) => {
      jsCodeDeclarations.push(element);
    });
    codeGenerator.jsCodeFunctionsDeclarations.forEach((element) => {
      jsCodeDeclarations.push(element);
    });
    jsCodeDeclarations.forEach((element) => {
      generatedCode += codeGenerator.toCode(element, new CodeBuilder_1.CodeBuilder()).render() + "\n";
    });
    return generatedCode;
  }
  main$2.generateCodeByAST = generateCodeByAST;
  function getGenerator(resultLanguage) {
    return (tlbCode) => {
      if (resultLanguage == "typescript") {
        return new generator_1.TypescriptGenerator(tlbCode);
      } else {
        throw new Error(`Result language ${resultLanguage} is not supported`);
      }
    };
  }
  main$2.getGenerator = getGenerator;
  function getTLBCode(input) {
    return getTLBCodeByAST((0, tlb_parser_1.ast)(input), input);
  }
  main$2.getTLBCode = getTLBCode;
  function generateCodeWithGenerator(input, getGenerator2) {
    return generateCodeByAST((0, tlb_parser_1.ast)(input), input, getGenerator2);
  }
  main$2.generateCodeWithGenerator = generateCodeWithGenerator;
  function generateCode(input, resultLanguage) {
    return generateCodeWithGenerator(input, getGenerator(resultLanguage));
  }
  main$2.generateCode = generateCode;
  return main$2;
}
var hasRequiredBuild;
function requireBuild() {
  if (hasRequiredBuild) return build;
  hasRequiredBuild = 1;
  (function(exports) {
    var __createBinding = build && build.__createBinding || (Object.create ? (function(o4, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o4, k22, desc);
    }) : (function(o4, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o4[k22] = m2[k2];
    }));
    var __exportStar = build && build.__exportStar || function(m2, exports2) {
      for (var p2 in m2) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypescriptGenerator = exports.isBigIntExpr = exports.isBigInt = exports.generateCode = exports.generateCodeWithGenerator = exports.getTLBCode = exports.generateCodeByAST = exports.getTLBCodeByAST = void 0;
    __exportStar(requireAst(), exports);
    var main_1 = requireMain();
    Object.defineProperty(exports, "getTLBCodeByAST", { enumerable: true, get: function() {
      return main_1.getTLBCodeByAST;
    } });
    Object.defineProperty(exports, "generateCodeByAST", { enumerable: true, get: function() {
      return main_1.generateCodeByAST;
    } });
    Object.defineProperty(exports, "getTLBCode", { enumerable: true, get: function() {
      return main_1.getTLBCode;
    } });
    Object.defineProperty(exports, "generateCodeWithGenerator", { enumerable: true, get: function() {
      return main_1.generateCodeWithGenerator;
    } });
    Object.defineProperty(exports, "generateCode", { enumerable: true, get: function() {
      return main_1.generateCode;
    } });
    var utils_1 = requireUtils$2();
    Object.defineProperty(exports, "isBigInt", { enumerable: true, get: function() {
      return utils_1.isBigInt;
    } });
    Object.defineProperty(exports, "isBigIntExpr", { enumerable: true, get: function() {
      return utils_1.isBigIntExpr;
    } });
    var generator_1 = requireGenerator();
    Object.defineProperty(exports, "TypescriptGenerator", { enumerable: true, get: function() {
      return generator_1.TypescriptGenerator;
    } });
  })(build);
  return build;
}
var common$1 = {};
var hasRequiredCommon$1;
function requireCommon$1() {
  if (hasRequiredCommon$1) return common$1;
  hasRequiredCommon$1 = 1;
  Object.defineProperty(common$1, "__esModule", { value: true });
  common$1.stringToBits = stringToBits;
  common$1.bitsToString = bitsToString;
  common$1.normalizeBitString = normalizeBitString;
  common$1.toCell = toCell;
  const core_1 = requireDist$4();
  const TLBRuntime_1 = requireTLBRuntime();
  function stringToBits(text) {
    const bytes = Buffer.from(text, "utf-8");
    return new core_1.BitString(bytes, 0, bytes.length * 8);
  }
  function bitsToString(bits) {
    if (bits.length % 8 !== 0) {
      throw new Error("Bits must be at least 8 bits");
    }
    let text = "";
    for (let offset = 0; offset < bits.length; offset += 8) {
      text += String.fromCharCode(parseInt(`0x${bits.substring(offset, 8).toString()}`));
    }
    return text;
  }
  function normalizeBitString(bits) {
    const length = bits.length;
    const newBuffer = Buffer.alloc(Math.ceil(length / 8));
    for (let i = 0; i < length; i++) {
      const byteIndex = Math.floor(i / 8);
      const bitIndex = 7 - i % 8;
      if (bits.at(i)) {
        newBuffer[byteIndex] |= 1 << bitIndex;
      }
    }
    return new core_1.BitString(newBuffer, 0, length);
  }
  function toCell(data) {
    try {
      return { success: true, value: core_1.Cell.fromBase64(data) };
    } catch (_) {
      try {
        return { success: true, value: core_1.Cell.fromHex(data) };
      } catch (_2) {
        return { success: false, error: new TLBRuntime_1.TLBDataError("Bad BoC string") };
      }
    }
  }
  return common$1;
}
var MathExprEvaluator = {};
var hasRequiredMathExprEvaluator;
function requireMathExprEvaluator() {
  if (hasRequiredMathExprEvaluator) return MathExprEvaluator;
  hasRequiredMathExprEvaluator = 1;
  Object.defineProperty(MathExprEvaluator, "__esModule", { value: true });
  MathExprEvaluator.MathExprEvaluator = void 0;
  const tlb_codegen_1 = requireBuild();
  let MathExprEvaluator$1 = class MathExprEvaluator2 {
    variables;
    constructor(variables = /* @__PURE__ */ new Map()) {
      this.variables = variables;
    }
    static calculateBitsForLessThan(n) {
      if (n <= 0)
        return 0;
      if (n === 1)
        return 0;
      const maxValue = n - 1;
      if (maxValue === 0)
        return 0;
      return Math.ceil(Math.log2(maxValue + 1));
    }
    static calculateBitsForLessThanOrEqual(n) {
      if (n < 0)
        return 0;
      if (n === 0)
        return 0;
      return Math.ceil(Math.log2(n + 1));
    }
    evaluate(expr) {
      if (expr instanceof tlb_codegen_1.TLBNumberExpr) {
        return expr.n;
      }
      if (expr instanceof tlb_codegen_1.TLBVarExpr) {
        const value = this.variables.get(expr.x);
        if (value === void 0) {
          throw new Error(`Variable ${expr.x} is not defined`);
        }
        return value;
      }
      if (expr instanceof tlb_codegen_1.TLBBinaryOp) {
        const left = this.evaluate(expr.left);
        const right = this.evaluate(expr.right);
        switch (expr.operation) {
          case "+":
            return left + right;
          case "-":
            return left - right;
          case "*":
            return left * right;
          case "/":
            return Math.floor(left / right);
          case "%":
            return left % right;
          case "<<":
            return left << right;
          case ">>":
            return left >> right;
          case "&":
            return left & right;
          case "|":
            return left | right;
          case "^":
            return left ^ right;
          case "==":
            return left === right ? 1 : 0;
          case "!=":
            return left !== right ? 1 : 0;
          case "<":
            return left < right ? 1 : 0;
          case "<=":
            return left <= right ? 1 : 0;
          case ">":
            return left > right ? 1 : 0;
          case ">=":
            return left >= right ? 1 : 0;
          case "=":
            return left === right ? 1 : 0;
          default:
            throw new Error(`Unknown operation: ${expr.operation}`);
        }
      }
      if (expr instanceof tlb_codegen_1.TLBUnaryOp) {
        const operation = expr.operation;
        switch (operation) {
          case ".": {
            const innerExpr = expr.value;
            if (innerExpr instanceof tlb_codegen_1.TLBBinaryOp && innerExpr.operation === "-") {
              const left = this.evaluate(innerExpr.left);
              const right = this.evaluate(innerExpr.right);
              if (right === 1) {
                return MathExprEvaluator2.calculateBitsForLessThan(left);
              }
              return left - right;
            }
            if (innerExpr instanceof tlb_codegen_1.TLBNumberExpr) {
              return MathExprEvaluator2.calculateBitsForLessThanOrEqual(innerExpr.n);
            }
            return this.evaluate(innerExpr);
          }
          case "-":
            return -this.evaluate(expr.value);
          case "~":
            return ~this.evaluate(expr.value);
          case "!":
            return this.evaluate(expr.value) ? 0 : 1;
          default:
            throw new Error(`Unknown unary operation: ${operation}`);
        }
      }
      throw new Error(`Unsupported expression type: ${typeof expr}`);
    }
  };
  MathExprEvaluator.MathExprEvaluator = MathExprEvaluator$1;
  return MathExprEvaluator;
}
var Result = {};
var hasRequiredResult;
function requireResult() {
  if (hasRequiredResult) return Result;
  hasRequiredResult = 1;
  Object.defineProperty(Result, "__esModule", { value: true });
  Result.error = error2;
  Result.unwrap = unwrap;
  function error2(result) {
    return result instanceof Error ? result : new Error(String(result));
  }
  function unwrap(result) {
    if (result.success) {
      return result.value;
    }
    throw error2(result.error);
  }
  return Result;
}
var hasRequiredTLBRuntime;
function requireTLBRuntime() {
  if (hasRequiredTLBRuntime) return TLBRuntime;
  hasRequiredTLBRuntime = 1;
  Object.defineProperty(TLBRuntime, "__esModule", { value: true });
  TLBRuntime.TLBRuntime = TLBRuntime.TLBDataError = TLBRuntime.TLBSchemaError = TLBRuntime.TLBRuntimeError = void 0;
  TLBRuntime.parseTLB = parseTLB;
  const core_1 = requireDist$4();
  const tlb_codegen_1 = requireBuild();
  const tlb_parser_1 = requireDist$3();
  const common_1 = requireCommon$1();
  const MathExprEvaluator_1 = requireMathExprEvaluator();
  const Result_1 = requireResult();
  class TLBRuntimeError extends Error {
  }
  TLBRuntime.TLBRuntimeError = TLBRuntimeError;
  class TLBSchemaError extends TLBRuntimeError {
  }
  TLBRuntime.TLBSchemaError = TLBSchemaError;
  class TLBDataError extends TLBRuntimeError {
  }
  TLBRuntime.TLBDataError = TLBDataError;
  function tagKey(tag) {
    return `0b${BigInt(tag.binary).toString(2).padStart(tag.bitLen, "0")}`;
  }
  let TLBRuntime$1 = class TLBRuntime2 {
    schema;
    types;
    lastTypeName;
    config;
    tagMap = /* @__PURE__ */ new Map();
    maxSizeTag = 0;
    constructor(schema2, types2, lastTypeName, config = {}) {
      this.schema = schema2;
      this.types = types2;
      this.lastTypeName = lastTypeName;
      this.config = config;
      config.autoText = config.autoText || true;
      for (const type of this.types.values()) {
        for (const item of type.constructors) {
          if (item.tag.bitLen > 0) {
            if (item.tag.bitLen > this.maxSizeTag) {
              this.maxSizeTag = item.tag.bitLen;
            }
            const key2 = tagKey(item.tag);
            this.tagMap.set(key2, { type, item });
          }
        }
      }
    }
    static from(schema2, config = {}) {
      try {
        const tree = (0, tlb_parser_1.ast)(schema2);
        const code = (0, tlb_codegen_1.getTLBCodeByAST)(tree, schema2);
        const pared = schema2.split("=");
        const lastTypeName = pared[pared.length - 1].split(";")[0].trim().split(" ")[0].trim();
        return {
          success: true,
          value: new TLBRuntime2(schema2, code.types, lastTypeName, config)
        };
      } catch (error2) {
      }
      return { success: false, error: new TLBSchemaError("Bad Schema") };
    }
    changeSchema(schema2) {
      if (this.schema === schema2) {
        return {
          success: true,
          value: this
        };
      }
      return TLBRuntime2.from(schema2, this.config);
    }
    parseCell(data) {
      return (0, Result_1.unwrap)(this.deserialize(data));
    }
    encodeCell(data) {
      if (typeof data === "string") {
        data = JSON.parse(data);
      }
      return (0, Result_1.unwrap)(this.serialize(data)).endCell();
    }
    findByTag(slice) {
      const savedBits = slice.remainingBits;
      const maxLen = Math.min(this.maxSizeTag, savedBits);
      for (let len = maxLen; len >= 1; len--) {
        if (savedBits < len)
          continue;
        const tagValue = slice.preloadUint(len);
        const key2 = tagKey({
          bitLen: len,
          binary: `0x${tagValue.toString(16)}`
        });
        const type = this.tagMap.get(key2);
        if (type) {
          return type;
        }
      }
      return null;
    }
    deserialize(data, findByTag = false) {
      if (typeof data === "string") {
        const result = (0, common_1.toCell)(data);
        if (!result.success) {
          return result;
        }
        data = result.value;
      }
      const slice = data.asSlice();
      if (findByTag) {
        const find = this.findByTag(slice);
        if (find) {
          return this.deserializeConstructor(find.type, find.item, slice);
        }
      }
      const types2 = Array.from(this.types.keys());
      try {
        const result = this.deserializeByTypeName(this.lastTypeName, slice.clone());
        if (result.success) {
          return result;
        }
      } catch (error2) {
      }
      for (const typeName of types2.slice().reverse()) {
        if (typeName === this.lastTypeName)
          continue;
        const result = this.deserializeByTypeName(typeName, slice.clone());
        if (result.success) {
          return result;
        }
      }
      return { success: false, error: new TLBDataError("No matching constructor") };
    }
    // Deserialize data from a Slice based on a TL-B type name
    deserializeByTypeName(typeName, slice) {
      const type = this.types.get(typeName);
      if (!type) {
        return {
          success: false,
          error: new TLBDataError(`Type ${typeName} not found in TL-B schema`)
        };
      }
      return this.deserializeType(type, slice);
    }
    serialize(data) {
      const typeKind = data.kind;
      if (!typeKind) {
        return {
          success: false,
          error: new TLBDataError("Data must by typed")
        };
      }
      return this.serializeByTypeName(typeKind, data);
    }
    // Serialize data to a Builder based on a TL-B type name
    serializeByTypeName(typeKind, data) {
      const sep = typeKind.indexOf("_");
      const typeName = sep === -1 ? typeKind : typeKind.slice(0, sep);
      const type = this.types.get(typeName);
      if (!type) {
        return {
          success: false,
          error: new TLBDataError(`Type ${typeName} not found in TL-B schema`)
        };
      }
      const value = (0, core_1.beginCell)();
      this.serializeType(type, data, value);
      return {
        success: true,
        value
      };
    }
    deserializeType(type, data, args = [], initialVariables) {
      for (const constructor of type.constructors) {
        const prev = data.clone();
        const result = this.deserializeConstructor(type, constructor, prev, args, initialVariables);
        if (result.success) {
          const bitsUsed = data.remainingBits - prev.remainingBits;
          const refsUsed = data.remainingRefs - prev.remainingRefs;
          if (bitsUsed > 0) {
            data.skip(bitsUsed);
          }
          for (let i = 0; i < refsUsed; i++) {
            data.loadRef();
          }
          return result;
        }
      }
      return {
        success: false,
        error: new TLBDataError(`Failed to deserialize type ${type.name} no matching constructor found`)
      };
    }
    deserializeConstructor(type, constructor, slice, args = [], initialVariables) {
      const kind = type.constructors.length > 1 ? `${type.name}_${constructor.name}` : type.name;
      if (constructor.tag.bitLen > 0) {
        const len = constructor.tag.bitLen;
        if (slice.remainingBits < len) {
          return {
            success: false,
            error: new TLBDataError(`Not enough bits to read tag for ${kind}`)
          };
        }
        const preloadedTag = `0b${slice.loadUint(len).toString(2).padStart(len, "0")}`;
        const expectedTag = tagKey(constructor.tag);
        if (preloadedTag !== expectedTag) {
          return {
            success: false,
            error: new TLBDataError(`Failed to deserialize type ${kind}`)
          };
        }
      }
      const variables = new Map(initialVariables);
      if (args.length > 0 && constructor.parameters.length > 0) {
        const evaluator2 = new MathExprEvaluator_1.MathExprEvaluator(variables);
        for (let i = 0; i < Math.min(args.length, constructor.parameters.length); i++) {
          const param = constructor.parameters[i];
          const arg = args[i];
          let argValue = void 0;
          try {
            if (arg.kind === "TLBExprMathType") {
              argValue = evaluator2.evaluate(arg.initialExpr);
            } else if (arg.kind === "TLBNumberType") {
              argValue = evaluator2.evaluate(arg.bits);
            }
          } catch (error2) {
          }
          if (param.argName && typeof argValue === "number") {
            variables.set(param.argName, argValue);
          }
          try {
            if (param.variable?.name && typeof argValue === "number") {
              const varName = param.variable.name;
              let solved = false;
              if (param.paramExpr) {
                const expr = param.paramExpr;
                let found;
                for (let cand = 0; cand <= 1024; cand++) {
                  const trial = new Map(variables);
                  trial.set(varName, cand);
                  const v2 = new MathExprEvaluator_1.MathExprEvaluator(trial).evaluate(expr);
                  if (v2 === argValue) {
                    found = cand;
                    break;
                  }
                }
                if (typeof found === "number") {
                  variables.set(varName, found);
                  solved = true;
                }
              }
              if (!solved && param.variable.deriveExpr) {
                if (variables.get(varName) === void 0) {
                  let found;
                  for (let cand = 0; cand <= 1024; cand++) {
                    const trial = new Map(variables);
                    trial.set(varName, cand);
                    const v2 = new MathExprEvaluator_1.MathExprEvaluator(trial).evaluate(param.variable.deriveExpr);
                    if (v2 === argValue) {
                      found = cand;
                      break;
                    }
                  }
                  if (typeof found === "number") {
                    variables.set(varName, found);
                    solved = true;
                  }
                }
              }
              if (!solved && !param.variable.negated) {
                variables.set(varName, argValue);
              }
            }
          } catch (error2) {
          }
        }
      }
      if (args.length === 0 && constructor.parameters.length > 0) {
        for (const param of constructor.parameters) {
          try {
            if (param.variable?.type === "#" && !param.variable.negated && !param.variable.isConst) {
              if (slice.remainingBits >= 32) {
                const val = Number(slice.loadUint(32));
                variables.set(param.variable.name, val);
              }
            }
          } catch (error2) {
          }
        }
      }
      if (constructor.fields.length === 0 && constructor.parameters.length === 1 && constructor.parameters[0].variable.type === "#" && variables.get(constructor.parameters[0].variable.name) === void 0 && slice.remainingBits >= 32) {
        try {
          const val = Number(slice.loadUint(32));
          variables.set(constructor.parameters[0].variable.name, val);
        } catch (error2) {
        }
      }
      if (args.length > 0 && constructor.parameters.length === 0 && constructor.variables.length > 0) {
        const evaluator2 = new MathExprEvaluator_1.MathExprEvaluator(variables);
        const numericVars = constructor.variables.filter((v2) => v2.type === "#");
        for (let i = 0; i < Math.min(args.length, numericVars.length); i++) {
          const v2 = numericVars[i];
          const arg = args[i];
          try {
            let argValue;
            if (arg.kind === "TLBExprMathType") {
              argValue = evaluator2.evaluate(arg.initialExpr);
            } else if (arg.kind === "TLBNumberType") {
              argValue = evaluator2.evaluate(arg.bits);
            }
            if (typeof argValue === "number") {
              variables.set(v2.name, argValue);
            }
          } catch (error2) {
          }
        }
      }
      let value = {
        kind
      };
      for (const field of constructor.fields) {
        if (field.subFields.length > 0) {
          if (slice.remainingRefs === 0) {
            return {
              success: false,
              error: new TLBDataError(`No more references available for field ${field.name}`)
            };
          }
          const ref = slice.loadRef();
          if (field.subFields.length === 1) {
            const subfield = field.subFields[0];
            if (subfield.fieldType.kind === "TLBCellType") {
              value[field.name] = ref;
            } else if (subfield.fieldType.kind === "TLBNamedType") {
              const refSlice = ref.beginParse(true);
              const type2 = this.types.get(subfield.fieldType.name);
              if (type2) {
                let initialSeed;
                if (type2.constructors.length > 0) {
                  const nestedCtor = type2.constructors[0];
                  const evaluator2 = new MathExprEvaluator_1.MathExprEvaluator(variables);
                  const forwardedArgs = subfield.fieldType.arguments ?? [];
                  const merged = new Map(variables);
                  if (nestedCtor.parameters.length > 0) {
                    for (let i = 0; i < Math.min(forwardedArgs.length, nestedCtor.parameters.length); i++) {
                      const param = nestedCtor.parameters[i];
                      const arg = forwardedArgs[i];
                      try {
                        let argValue;
                        if (arg.kind === "TLBExprMathType") {
                          argValue = evaluator2.evaluate(arg.initialExpr);
                        } else if (arg.kind === "TLBNumberType") {
                          argValue = evaluator2.evaluate(arg.bits);
                        }
                        if (typeof argValue === "number" && param.variable.type === "#" && !param.variable.negated) {
                          merged.set(param.variable.name, argValue);
                        }
                      } catch (error2) {
                      }
                    }
                    initialSeed = merged;
                  }
                }
                const result = this.deserializeType(type2, refSlice, subfield.fieldType.arguments, initialSeed);
                if (result.success) {
                  value[field.name] = result.value;
                } else {
                  return result;
                }
              } else {
                return {
                  success: false,
                  error: new TLBDataError(`Type ${subfield.fieldType.name} not found`)
                };
              }
            } else {
              const refSlice = ref.beginParse(true);
              value[field.name] = this.deserializeField(subfield, refSlice, variables, constructor, args);
            }
          } else {
            const refSlice = ref.beginParse(true);
            const subfields = {};
            for (const subfield of field.subFields) {
              subfields[subfield.name] = this.deserializeField(subfield, refSlice, variables, constructor, args);
            }
            value[field.name] = subfields;
          }
        } else {
          value[field.name] = this.deserializeField(field, slice, variables, constructor, args);
        }
      }
      if (constructor.parameters.length > 0) {
        for (const param of constructor.parameters) {
          try {
            if (param.variable?.name && param.variable.deriveExpr && variables.get(param.variable.name) === void 0) {
              const derived = new MathExprEvaluator_1.MathExprEvaluator(variables).evaluate(param.variable.deriveExpr);
              variables.set(param.variable.name, derived);
            }
          } catch (error2) {
          }
        }
      }
      const evaluator = new MathExprEvaluator_1.MathExprEvaluator(variables);
      for (const constraint of constructor.constraints) {
        if (evaluator.evaluate(constraint) !== 1) {
          return {
            success: false,
            error: new TLBDataError(`Failed to deserialize type ${kind} due to constraint`)
          };
        }
      }
      if (kind === "ExprType" && typeof value["x"] === "number") {
        value["x"] = BigInt(value["x"]);
      }
      const orderedValue = { kind };
      if (constructor.parameters.length > 0) {
        for (const param of constructor.parameters) {
          try {
            if (param.variable.type === "#" && !param.variable.negated && !param.variable.isConst) {
              const val = variables.get(param.variable.name);
              if (typeof val === "number") {
                orderedValue[param.variable.name] = val;
              }
            }
          } catch (error2) {
          }
        }
      } else if (constructor.variables.length > 0) {
        const fieldNamesSet = new Set(constructor.fields.map((f2) => f2.name));
        for (const v2 of constructor.variables) {
          try {
            if (v2.type === "#" && !v2.negated && !v2.isConst && !fieldNamesSet.has(v2.name)) {
              const val = variables.get(v2.name);
              if (typeof val === "number") {
                orderedValue[v2.name] = val;
              }
            }
          } catch (error2) {
          }
        }
      }
      if (Object.keys(orderedValue).length === 1 && constructor.parameters.length === 0 && constructor.variables.filter((v2) => v2.type === "#").length === 1) {
        const v2 = constructor.variables.find((vv) => vv.type === "#");
        const val = variables.get(v2.name);
        if (typeof val === "number") {
          orderedValue[v2.name] = val;
        }
      }
      const fieldNames = constructor.fields.map((f2) => f2.name).sort((a2, b2) => a2 < b2 ? -1 : a2 > b2 ? 1 : 0);
      for (const name of fieldNames) {
        orderedValue[name] = value[name];
      }
      return {
        success: true,
        value: orderedValue
      };
    }
    deserializeField(field, slice, variables, ctxConstructor, ctxArgs) {
      const value = this.deserializeFieldType(field.fieldType, slice, variables, ctxConstructor, ctxArgs);
      if (field.name && (field.fieldType.kind === "TLBNumberType" || field.fieldType.kind === "TLBVarIntegerType" || field.fieldType.kind === "TLBBoolType")) {
        variables.set(field.name, Number(value));
      }
      if (value && typeof value === "object") {
        for (const param of ctxConstructor.parameters) {
          if (param.variable?.type === "#" && !param.variable.negated && variables.get(param.variable.name) === void 0) {
            const extracted = this.extractNumericProperty(value, param.variable.name);
            if (typeof extracted === "number") {
              variables.set(param.variable.name, extracted);
            }
          }
        }
      }
      return value;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    extractNumericProperty(obj, name) {
      if (!obj || typeof obj !== "object")
        return void 0;
      if (typeof obj[name] === "number")
        return obj[name];
      for (const key2 of Object.keys(obj)) {
        const v2 = obj[key2];
        if (v2 && typeof v2 === "object") {
          const r = this.extractNumericProperty(v2, name);
          if (typeof r === "number")
            return r;
        }
      }
      return void 0;
    }
    deserializeFieldType(fieldType, slice, variables, ctxConstructor, ctxArgs) {
      const evaluator = new MathExprEvaluator_1.MathExprEvaluator(variables);
      switch (fieldType.kind) {
        case "TLBNumberType": {
          let bits;
          try {
            bits = evaluator.evaluate(fieldType.bits);
          } catch (e) {
            let rebound = false;
            if (ctxConstructor?.parameters?.length && ctxArgs?.length) {
              for (let i = 0; i < Math.min(ctxConstructor.parameters.length, ctxArgs.length); i++) {
                const p2 = ctxConstructor.parameters[i];
                const a2 = ctxArgs[i];
                if (p2.variable?.type === "#") {
                  try {
                    let val2;
                    if (a2.kind === "TLBExprMathType") {
                      val2 = new MathExprEvaluator_1.MathExprEvaluator(variables).evaluate(a2.initialExpr);
                    } else if (a2.kind === "TLBNumberType") {
                      val2 = new MathExprEvaluator_1.MathExprEvaluator(variables).evaluate(a2.bits);
                    }
                    if (typeof val2 === "number") {
                      variables.set(p2.variable.name, val2);
                      rebound = true;
                    }
                  } catch {
                  }
                }
              }
              if (rebound) {
                bits = new MathExprEvaluator_1.MathExprEvaluator(variables).evaluate(fieldType.bits);
              } else {
                throw e;
              }
            } else {
              throw e;
            }
          }
          const val = this.loadBigInt(slice, bits, fieldType.signed);
          const maxBits = fieldType.maxBits;
          const preferNumber = maxBits !== void 0 ? maxBits <= 32 : false;
          if (!preferNumber && bits > 32) {
            return val;
          }
          if (preferNumber || bits <= 32) {
            return Number(val);
          }
          return val;
        }
        case "TLBBoolType": {
          if (fieldType.value !== void 0) {
            return fieldType.value;
          }
          return slice.loadBit();
        }
        case "TLBBitsType": {
          const bits = evaluator.evaluate(fieldType.bits);
          const raw = slice.loadBits(bits);
          if (this.config.autoText && bits % 8 === 0) {
            return (0, common_1.bitsToString)(raw);
          }
          if (bits === 1) {
            return raw.at(0);
          }
          return (0, common_1.normalizeBitString)(raw);
        }
        case "TLBNamedType": {
          const p2 = ctxConstructor.parametersMap.get(fieldType.name);
          if (p2 && p2.variable.type === "Type") {
            const paramIndex = ctxConstructor.parameters.findIndex((pp) => pp.variable.name === p2.variable.name);
            if (paramIndex >= 0 && ctxArgs[paramIndex]) {
              return this.deserializeFieldType(ctxArgs[paramIndex], slice, variables, ctxConstructor, ctxArgs);
            }
          }
          if (fieldType.name === "Bool") {
            return slice.loadBit();
          }
          if (fieldType.name === "Any") {
            const b2 = (0, core_1.beginCell)();
            const bitsLeft = slice.remainingBits;
            if (bitsLeft > 0) {
              b2.storeBits(slice.loadBits(bitsLeft));
            }
            while (slice.remainingRefs > 0) {
              b2.storeRef(slice.loadRef());
            }
            return b2.endCell();
          }
          const type = this.types.get(fieldType.name);
          if (!type) {
            throw new TLBDataError(`Type ${fieldType.name} not found in TL-B schema`);
          }
          const forwardedArgs = fieldType.arguments ?? [];
          let childVars = new Map(variables);
          if (type.constructors.length > 0 && forwardedArgs.length > 0) {
            const nestedCtor = type.constructors[0];
            const evaluator2 = new MathExprEvaluator_1.MathExprEvaluator(childVars);
            const max = Math.min(forwardedArgs.length, nestedCtor.parameters.length);
            for (let i = 0; i < max; i++) {
              const param = nestedCtor.parameters[i];
              const arg = forwardedArgs[i];
              if (param.variable?.type === "#") {
                try {
                  let val;
                  if (arg.kind === "TLBExprMathType") {
                    val = evaluator2.evaluate(arg.initialExpr);
                  } else if (arg.kind === "TLBNumberType") {
                    val = evaluator2.evaluate(arg.bits);
                  }
                  if (typeof val === "number") {
                    childVars.set(param.variable.name, val);
                  }
                } catch (error2) {
                }
              }
            }
          }
          return (0, Result_1.unwrap)(this.deserializeType(type, slice, forwardedArgs, childVars));
        }
        case "TLBCoinsType": {
          return slice.loadCoins();
        }
        case "TLBAddressType": {
          if (slice.preloadUint(2) !== 2) {
            if (slice.remainingBits === 2) {
              return null;
            }
            const type = slice.loadUint(2);
            if (type === 1) {
              const bits = slice.loadUint(9);
              return new core_1.ExternalAddress(slice.loadUintBig(bits), bits);
            }
          }
          return slice.loadAddress();
        }
        case "TLBCellType": {
          if (slice.remainingRefs === 0) {
            throw new TLBDataError("No more references available for TLBCellType");
          }
          return slice.loadRef();
        }
        case "TLBCellInsideType": {
          if (slice.remainingRefs === 0) {
            throw new TLBDataError("No more references available for TLBCellInsideType");
          }
          const ref = slice.loadRef();
          if (fieldType.value.kind === "TLBCellType") {
            return ref;
          }
          const refSlice = ref.beginParse();
          return this.deserializeFieldType(fieldType.value, refSlice, variables, ctxConstructor, ctxArgs);
        }
        case "TLBHashmapType": {
          const keySize = evaluator.evaluate(fieldType.key.expr);
          const parseValue = (sl) => this.deserializeFieldType(fieldType.value, sl, new Map(variables), ctxConstructor, ctxArgs);
          const emptyBig = () => core_1.Dictionary.empty(core_1.Dictionary.Keys.BigUint(keySize));
          const emptyNum = () => core_1.Dictionary.empty(core_1.Dictionary.Keys.Uint(keySize));
          if (keySize > 32) {
            const dict = fieldType.directStore ? slice.loadDictDirect(core_1.Dictionary.Keys.BigUint(keySize), {
              serialize: () => {
              },
              parse: parseValue
            }) : slice.loadDict(core_1.Dictionary.Keys.BigUint(keySize), { serialize: () => {
            }, parse: parseValue });
            return dict.size === 0 ? emptyBig() : dict;
          } else {
            const dict = fieldType.directStore ? slice.loadDictDirect(core_1.Dictionary.Keys.Uint(keySize), {
              serialize: () => {
              },
              parse: parseValue
            }) : slice.loadDict(core_1.Dictionary.Keys.Uint(keySize), { serialize: () => {
            }, parse: parseValue });
            return dict.size === 0 ? emptyNum() : dict;
          }
        }
        case "TLBVarIntegerType": {
          const size = evaluator.evaluate(fieldType.n);
          if (fieldType.signed) {
            return slice.loadVarIntBig(size);
          } else {
            return slice.loadVarUintBig(size);
          }
        }
        case "TLBMultipleType": {
          const times = evaluator.evaluate(fieldType.times);
          const result = [];
          for (let i = 0; i < times; i++) {
            result.push(this.deserializeFieldType(fieldType.value, slice, variables, ctxConstructor, ctxArgs));
          }
          return result;
        }
        case "TLBCondType": {
          const condition = evaluator.evaluate(fieldType.condition);
          if (condition) {
            return this.deserializeFieldType(fieldType.value, slice, variables, ctxConstructor, ctxArgs);
          }
          return void 0;
        }
        case "TLBTupleType": {
          const cell = slice.loadRef();
          return (0, core_1.parseTuple)(cell);
        }
        default:
          throw new TLBDataError(`Unsupported field type: ${fieldType.kind}`);
      }
    }
    // FIXME
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    serializeType(type, data, builder2) {
      const typeKind = data.kind;
      if (!typeKind) {
        throw new TLBDataError("Data must by typed");
      }
      const constructorName = typeKind.substring(type.name.length + 1);
      let constructor;
      if (constructorName) {
        constructor = type.constructors.find((c) => c.name === constructorName);
      } else if (type.constructors.length > 0) {
        constructor = type.constructors[0];
      }
      if (!constructor) {
        throw new TLBDataError(`Constructor not found for type ${typeKind}`);
      }
      if (constructor.tag.bitLen > 0) {
        const tag = BigInt(constructor.tag.binary);
        builder2.storeUint(tag, constructor.tag.bitLen);
      }
      const variables = /* @__PURE__ */ new Map();
      for (const field of constructor.fields) {
        if (!field.anonymous) {
          this.serializeField(field, data[field.name], builder2, variables);
        } else {
          this.serializeField(field, null, builder2, variables);
        }
      }
      const evaluator = new MathExprEvaluator_1.MathExprEvaluator(variables);
      for (const constraint of constructor.constraints) {
        if (evaluator.evaluate(constraint) !== 1) {
          throw new TLBDataError(`Constraint failed for type ${type.name}, constructor ${constructor.name}`);
        }
      }
    }
    // FIXME
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    serializeField(field, value, builder2, variables) {
      if (field.name && (field.fieldType.kind === "TLBNumberType" || field.fieldType.kind === "TLBVarIntegerType" || field.fieldType.kind === "TLBBoolType")) {
        variables.set(field.name, Number(value));
      }
      this.serializeFieldType(field.fieldType, value, builder2, variables);
    }
    serializeFieldType(fieldType, value, builder2, variables) {
      const evaluator = new MathExprEvaluator_1.MathExprEvaluator(variables);
      switch (fieldType.kind) {
        case "TLBNumberType": {
          const bits = evaluator.evaluate(fieldType.bits);
          builder2.storeUint(value, bits);
          break;
        }
        case "TLBBoolType": {
          if (fieldType.value !== void 0) {
            break;
          }
          builder2.storeBit(value ? 1 : 0);
          break;
        }
        case "TLBBitsType": {
          if (typeof value === "string") {
            value = (0, common_1.stringToBits)(value);
          }
          if (value instanceof core_1.BitString) {
            builder2.storeBits(value);
          }
          break;
        }
        case "TLBNamedType": {
          const type = this.types.get(fieldType.name);
          if (!type) {
            throw new TLBDataError(`Type ${fieldType.name} not found in TL-B schema`);
          }
          this.serializeType(type, value, builder2);
          break;
        }
        case "TLBCoinsType": {
          builder2.storeCoins(value);
          break;
        }
        case "TLBAddressType": {
          if (typeof value === "string") {
            value = core_1.Address.parse(value);
          }
          builder2.storeAddress(value);
          break;
        }
        case "TLBCellType": {
          builder2.storeRef(value);
          break;
        }
        case "TLBCellInsideType": {
          const nestedBuilder = (0, core_1.beginCell)();
          this.serializeFieldType(fieldType.value, value, nestedBuilder, variables);
          builder2.storeRef(nestedBuilder.endCell());
          break;
        }
        case "TLBHashmapType": {
          const keySize = evaluator.evaluate(fieldType.key.expr);
          const dict = core_1.Dictionary.empty(core_1.Dictionary.Keys.BigInt(keySize), core_1.Dictionary.Values.Cell());
          if (value) {
            for (const [key2, dictValue] of Object.entries(value)) {
              const valueBuilder = (0, core_1.beginCell)();
              this.serializeFieldType(fieldType.value, dictValue, valueBuilder, new Map(variables));
              dict.set(BigInt(key2), valueBuilder.endCell());
            }
          }
          builder2.storeDict(dict);
          break;
        }
        case "TLBVarIntegerType": {
          const size = evaluator.evaluate(fieldType.n);
          if (fieldType.signed) {
            builder2.storeVarInt(value, size);
          } else {
            builder2.storeVarUint(value, size);
          }
          break;
        }
        case "TLBMultipleType": {
          const times = evaluator.evaluate(fieldType.times);
          for (let i = 0; i < times; i++) {
            this.serializeFieldType(fieldType.value, value[i], builder2, variables);
          }
          break;
        }
        case "TLBCondType": {
          const condition = evaluator.evaluate(fieldType.condition);
          if (condition) {
            this.serializeFieldType(fieldType.value, value, builder2, variables);
          }
          break;
        }
        case "TLBTupleType": {
          const cell = (0, core_1.serializeTuple)(value);
          builder2.storeRef(cell);
          break;
        }
        default:
          throw new TLBDataError(`Unsupported field type: ${fieldType.kind}`);
      }
    }
    loadBigInt(slice, bits, signed = false) {
      if (signed) {
        return slice.loadIntBig(bits);
      }
      return slice.loadUintBig(bits);
    }
  };
  TLBRuntime.TLBRuntime = TLBRuntime$1;
  function parseTLB(schema2) {
    return (0, Result_1.unwrap)(TLBRuntime$1.from(schema2));
  }
  return TLBRuntime;
}
var hasRequiredParser;
function requireParser() {
  if (hasRequiredParser) return parser;
  hasRequiredParser = 1;
  Object.defineProperty(parser, "__esModule", { value: true });
  parser.parseCell = parseCell;
  parser.encodeCell = encodeCell;
  parser.replacer = replacer;
  const core_1 = requireDist$4();
  const TLBRuntime_1 = requireTLBRuntime();
  function parseCell(schema2, data) {
    return (0, TLBRuntime_1.parseTLB)(schema2).parseCell(data);
  }
  function encodeCell(schema2, data) {
    return (0, TLBRuntime_1.parseTLB)(schema2).encodeCell(data);
  }
  function replacer(_key, value) {
    if (typeof value === "bigint") {
      return value.toString();
    } else if (value instanceof core_1.Address) {
      return value.toString();
    } else if (value instanceof core_1.BitString) {
      return value.toString();
    } else if (value instanceof core_1.Cell) {
      return value.toBoc().toString("base64");
    }
    return value;
  }
  return parser;
}
var schema = {};
var hasRequiredSchema;
function requireSchema() {
  if (hasRequiredSchema) return schema;
  hasRequiredSchema = 1;
  Object.defineProperty(schema, "__esModule", { value: true });
  schema.blockSchema = void 0;
  schema.blockSchema = `// https://github.com/ton-blockchain/ton/raw/774371bdc9f6107fd05106c1fd559e8903e0513d/crypto/block/block.tlb
unit$_ = Unit;
true$_ = True;
// EMPTY False;
bool_false$0 = Bool;
bool_true$1 = Bool;
bool_false$0 = BoolFalse;
bool_true$1 = BoolTrue;
nothing$0 {X:Type} = Maybe X;
just$1 {X:Type} value:X = Maybe X;
left$0 {X:Type} {Y:Type} value:X = Either X Y;
right$1 {X:Type} {Y:Type} value:Y = Either X Y;
pair$_ {X:Type} {Y:Type} first:X second:Y = Both X Y;

bit$_ (## 1) = Bit;
/*
 *
 *   FROM hashmap.tlb
 *
 */
// ordinary Hashmap / HashmapE, with fixed length keys
//
hm_edge#_ {n:#} {X:Type} {l:#} {m:#} label:(HmLabel ~l n) 
          {n = (~m) + l} node:(HashmapNode m X) = Hashmap n X;

hmn_leaf#_ {X:Type} value:X = HashmapNode 0 X;
hmn_fork#_ {n:#} {X:Type} left:^(Hashmap n X) 
           right:^(Hashmap n X) = HashmapNode (n + 1) X;

hml_short$0 {m:#} {n:#} len:(Unary ~n) {n <= m} s:(n * Bit) = HmLabel ~n m;
hml_long$10 {m:#} n:(#<= m) s:(n * Bit) = HmLabel ~n m;
hml_same$11 {m:#} v:Bit n:(#<= m) = HmLabel ~n m;

unary_zero$0 = Unary ~0;
unary_succ$1 {n:#} x:(Unary ~n) = Unary ~(n + 1);

hme_empty$0 {n:#} {X:Type} = HashmapE n X;
hme_root$1 {n:#} {X:Type} root:^(Hashmap n X) = HashmapE n X;

// true#_ = True;
_ {n:#} _:(Hashmap n True) = BitstringSet n;

//  HashmapAug, hashmap with an extra value 
//   (augmentation) of type Y at every node
//
ahm_edge#_ {n:#} {X:Type} {Y:Type} {l:#} {m:#} 
  label:(HmLabel ~l n) {n = (~m) + l} 
  node:(HashmapAugNode m X Y) = HashmapAug n X Y;
ahmn_leaf#_ {X:Type} {Y:Type} extra:Y value:X = HashmapAugNode 0 X Y;
ahmn_fork#_ {n:#} {X:Type} {Y:Type} left:^(HashmapAug n X Y)
  right:^(HashmapAug n X Y) extra:Y = HashmapAugNode (n + 1) X Y;

ahme_empty$0 {n:#} {X:Type} {Y:Type} extra:Y 
          = HashmapAugE n X Y;
ahme_root$1 {n:#} {X:Type} {Y:Type} root:^(HashmapAug n X Y) 
  extra:Y = HashmapAugE n X Y;

// VarHashmap / VarHashmapE, with variable-length keys
//
vhm_edge#_ {n:#} {X:Type} {l:#} {m:#} label:(HmLabel ~l n) 
           {n = (~m) + l} node:(VarHashmapNode m X) 
           = VarHashmap n X;
vhmn_leaf$00 {n:#} {X:Type} value:X = VarHashmapNode n X;
vhmn_fork$01 {n:#} {X:Type} left:^(VarHashmap n X) 
             right:^(VarHashmap n X) value:(Maybe X) 
             = VarHashmapNode (n + 1) X;
vhmn_cont$1 {n:#} {X:Type} branch:Bit child:^(VarHashmap n X) 
            value:X = VarHashmapNode (n + 1) X;

// nothing$0 {X:Type} = Maybe X;
// just$1 {X:Type} value:X = Maybe X;

vhme_empty$0 {n:#} {X:Type} = VarHashmapE n X;
vhme_root$1 {n:#} {X:Type} root:^(VarHashmap n X) 
            = VarHashmapE n X;

//
// PfxHashmap / PfxHashmapE, with variable-length keys
//                           constituting a prefix code
//

phm_edge#_ {n:#} {X:Type} {l:#} {m:#} label:(HmLabel ~l n) 
           {n = (~m) + l} node:(PfxHashmapNode m X) 
           = PfxHashmap n X;

phmn_leaf$0 {n:#} {X:Type} value:X = PfxHashmapNode n X;
phmn_fork$1 {n:#} {X:Type} left:^(PfxHashmap n X) 
            right:^(PfxHashmap n X) = PfxHashmapNode (n + 1) X;

phme_empty$0 {n:#} {X:Type} = PfxHashmapE n X;
phme_root$1 {n:#} {X:Type} root:^(PfxHashmap n X) 
            = PfxHashmapE n X;
/*
 *
 *  END hashmap.tlb
 *
 */
//
// TON BLOCK LAYOUT
//
addr_none$00 = MsgAddressExt;
addr_extern$01 len:(## 9) external_address:(bits len) 
             = MsgAddressExt;
anycast_info$_ depth:(#<= 30) { depth >= 1 }
   rewrite_pfx:(bits depth) = Anycast;
addr_std$10 anycast:(Maybe Anycast) 
   workchain_id:int8 address:bits256  = MsgAddressInt;
addr_var$11 anycast:(Maybe Anycast) addr_len:(## 9) 
   workchain_id:int32 address:(bits addr_len) = MsgAddressInt;
_ _:MsgAddressInt = MsgAddress;
_ _:MsgAddressExt = MsgAddress;
//
var_uint$_ {n:#} len:(#< n) value:(uint (len * 8))
         = VarUInteger n;
var_int$_ {n:#} len:(#< n) value:(int (len * 8)) 
        = VarInteger n;
nanograms$_ amount:(VarUInteger 16) = Grams;

_ grams:Grams = Coins;

//
extra_currencies$_ dict:(HashmapE 32 (VarUInteger 32)) 
                 = ExtraCurrencyCollection;
currencies$_ grams:Grams other:ExtraCurrencyCollection 
           = CurrencyCollection;
//
int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool
  src:MsgAddressInt dest:MsgAddressInt 
  value:CurrencyCollection ihr_fee:Grams fwd_fee:Grams
  created_lt:uint64 created_at:uint32 = CommonMsgInfo;
ext_in_msg_info$10 src:MsgAddressExt dest:MsgAddressInt 
  import_fee:Grams = CommonMsgInfo;
ext_out_msg_info$11 src:MsgAddressInt dest:MsgAddressExt
  created_lt:uint64 created_at:uint32 = CommonMsgInfo;

int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool
  src:MsgAddress dest:MsgAddressInt 
  value:CurrencyCollection ihr_fee:Grams fwd_fee:Grams
  created_lt:uint64 created_at:uint32 = CommonMsgInfoRelaxed;
ext_out_msg_info$11 src:MsgAddress dest:MsgAddressExt
  created_lt:uint64 created_at:uint32 = CommonMsgInfoRelaxed;

tick_tock$_ tick:Bool tock:Bool = TickTock;

_ fixed_prefix_length:(Maybe (## 5)) special:(Maybe TickTock)
  code:(Maybe ^Cell) data:(Maybe ^Cell)
  library:(Maybe ^Cell) = StateInit;

// StateInitWithLibs is used to validate sent and received messages
_ fixed_prefix_length:(Maybe (## 5)) special:(Maybe TickTock)
  code:(Maybe ^Cell) data:(Maybe ^Cell)
  library:(HashmapE 256 SimpleLib) = StateInitWithLibs;

simple_lib$_ public:Bool root:^Cell = SimpleLib;

message$_ {X:Type} info:CommonMsgInfo
  init:(Maybe (Either StateInit ^StateInit))
  body:(Either X ^X) = Message X;

message$_ {X:Type} info:CommonMsgInfoRelaxed
  init:(Maybe (Either StateInit ^StateInit))
  body:(Either X ^X) = MessageRelaxed X;
  
_ (Message Any) = MessageAny;

//
interm_addr_regular$0 use_dest_bits:(#<= 96) 
  = IntermediateAddress;
interm_addr_simple$10 workchain_id:int8 addr_pfx:uint64 
  = IntermediateAddress;
interm_addr_ext$11 workchain_id:int32 addr_pfx:uint64
  = IntermediateAddress;
msg_envelope#4 cur_addr:IntermediateAddress 
  next_addr:IntermediateAddress fwd_fee_remaining:Grams 
  msg:^(Message Any) = MsgEnvelope;
msg_metadata#0 depth:uint32 initiator_addr:MsgAddressInt initiator_lt:uint64 = MsgMetadata;
msg_envelope_v2#5 cur_addr:IntermediateAddress
  next_addr:IntermediateAddress fwd_fee_remaining:Grams
  msg:^(Message Any)
  emitted_lt:(Maybe uint64)
  metadata:(Maybe MsgMetadata) = MsgEnvelope;
//
msg_import_ext$000 msg:^(Message Any) transaction:^Transaction 
              = InMsg;
msg_import_ihr$010 msg:^(Message Any) transaction:^Transaction 
    ihr_fee:Grams proof_created:^Cell = InMsg;
msg_import_imm$011 in_msg:^MsgEnvelope
    transaction:^Transaction fwd_fee:Grams = InMsg;
msg_import_fin$100 in_msg:^MsgEnvelope 
    transaction:^Transaction fwd_fee:Grams = InMsg;
msg_import_tr$101  in_msg:^MsgEnvelope out_msg:^MsgEnvelope 
    transit_fee:Grams = InMsg;
msg_discard_fin$110 in_msg:^MsgEnvelope transaction_id:uint64 
    fwd_fee:Grams = InMsg;
msg_discard_tr$111 in_msg:^MsgEnvelope transaction_id:uint64 
    fwd_fee:Grams proof_delivered:^Cell = InMsg;
msg_import_deferred_fin$00100 in_msg:^MsgEnvelope
    transaction:^Transaction fwd_fee:Grams = InMsg;
msg_import_deferred_tr$00101 in_msg:^MsgEnvelope out_msg:^MsgEnvelope = InMsg;
//
import_fees$_ fees_collected:Grams 
  value_imported:CurrencyCollection = ImportFees;

_ (HashmapAugE 256 InMsg ImportFees) = InMsgDescr;

msg_export_ext$000 msg:^(Message Any)
    transaction:^Transaction = OutMsg;
msg_export_imm$010 out_msg:^MsgEnvelope 
    transaction:^Transaction reimport:^InMsg = OutMsg;
msg_export_new$001 out_msg:^MsgEnvelope 
    transaction:^Transaction = OutMsg;
msg_export_tr$011  out_msg:^MsgEnvelope 
    imported:^InMsg = OutMsg;
msg_export_deq$1100 out_msg:^MsgEnvelope
    import_block_lt:uint63 = OutMsg;
msg_export_deq_short$1101 msg_env_hash:bits256
    next_workchain:int32 next_addr_pfx:uint64
    import_block_lt:uint64 = OutMsg;
msg_export_tr_req$111 out_msg:^MsgEnvelope 
    imported:^InMsg = OutMsg;
msg_export_deq_imm$100 out_msg:^MsgEnvelope 
    reimport:^InMsg = OutMsg;
msg_export_new_defer$10100 out_msg:^MsgEnvelope
    transaction:^Transaction = OutMsg;
msg_export_deferred_tr$10101  out_msg:^MsgEnvelope
    imported:^InMsg = OutMsg;

_ enqueued_lt:uint64 out_msg:^MsgEnvelope = EnqueuedMsg;

_ (HashmapAugE 256 OutMsg CurrencyCollection) = OutMsgDescr;

_ (HashmapAugE 352 EnqueuedMsg uint64) = OutMsgQueue;

processed_upto$_ last_msg_lt:uint64 last_msg_hash:bits256 = ProcessedUpto;
// key is [ shard:uint64 mc_seqno:uint32 ]  
_ (HashmapE 96 ProcessedUpto) = ProcessedInfo;

ihr_pending$_ import_lt:uint64 = IhrPendingSince;
_ (HashmapE 320 IhrPendingSince) = IhrPendingInfo;

// key - created_lt
_ messages:(HashmapE 64 EnqueuedMsg) count:uint48 = AccountDispatchQueue;
// key - sender address, aug - min created_lt
_ (HashmapAugE 256 AccountDispatchQueue uint64) = DispatchQueue;

out_msg_queue_extra#0 dispatch_queue:DispatchQueue out_queue_size:(Maybe uint48) = OutMsgQueueExtra;

_ out_queue:OutMsgQueue proc_info:ProcessedInfo
  extra:(Maybe OutMsgQueueExtra) = OutMsgQueueInfo;

storage_extra_none$000 = StorageExtraInfo;
storage_extra_info$001 dict_hash:uint256 = StorageExtraInfo;

storage_used$_ cells:(VarUInteger 7) bits:(VarUInteger 7) = StorageUsed;

storage_info$_ used:StorageUsed storage_extra:StorageExtraInfo last_paid:uint32
              due_payment:(Maybe Grams) = StorageInfo;

account_none$0 = Account;
account$1 addr:MsgAddressInt storage_stat:StorageInfo
          storage:AccountStorage = Account;

account_storage$_ last_trans_lt:uint64
    balance:CurrencyCollection state:AccountState 
  = AccountStorage;

account_uninit$00 = AccountState;
account_active$1 _:StateInit = AccountState;
account_frozen$01 state_hash:bits256 = AccountState;

acc_state_uninit$00 = AccountStatus;
acc_state_frozen$01 = AccountStatus;
acc_state_active$10 = AccountStatus;
acc_state_nonexist$11 = AccountStatus;

account_descr$_ account:^Account last_trans_hash:bits256 
  last_trans_lt:uint64 = ShardAccount;

depth_balance$_ split_depth:(#<= 30) balance:CurrencyCollection = DepthBalanceInfo;

_ (HashmapAugE 256 ShardAccount DepthBalanceInfo) = ShardAccounts;

transaction$0111 account_addr:bits256 lt:uint64 
  prev_trans_hash:bits256 prev_trans_lt:uint64 now:uint32
  outmsg_cnt:uint15
  orig_status:AccountStatus end_status:AccountStatus
  ^[ in_msg:(Maybe ^(Message Any)) out_msgs:(HashmapE 15 ^(Message Any)) ]
  total_fees:CurrencyCollection state_update:^(HASH_UPDATE Account)
  description:^TransactionDescr = Transaction;

!merkle_update#04 {X:Type} old_hash:bits256 new_hash:bits256 old_depth:uint16 new_depth:uint16
  old:^X new:^X = MERKLE_UPDATE X;
update_hashes#72 {X:Type} old_hash:bits256 new_hash:bits256
  = HASH_UPDATE X;
!merkle_proof#03 {X:Type} virtual_hash:bits256 depth:uint16 virtual_root:^X = MERKLE_PROOF X;

acc_trans#5 account_addr:bits256
            transactions:(HashmapAug 64 ^Transaction CurrencyCollection)
            state_update:^(HASH_UPDATE Account)
          = AccountBlock;

_ (HashmapAugE 256 AccountBlock CurrencyCollection) = ShardAccountBlocks;
//
tr_phase_storage$_ storage_fees_collected:Grams 
  storage_fees_due:(Maybe Grams)
  status_change:AccStatusChange
  = TrStoragePhase;

acst_unchanged$0 = AccStatusChange;  // x -> x
acst_frozen$10 = AccStatusChange;    // init -> frozen
acst_deleted$11 = AccStatusChange;   // frozen -> deleted

tr_phase_credit$_ due_fees_collected:(Maybe Grams)
  credit:CurrencyCollection = TrCreditPhase;

tr_phase_compute_skipped$0 reason:ComputeSkipReason
  = TrComputePhase;
tr_phase_compute_vm$1 success:Bool msg_state_used:Bool 
  account_activated:Bool gas_fees:Grams
  ^[ gas_used:(VarUInteger 7)
  gas_limit:(VarUInteger 7) gas_credit:(Maybe (VarUInteger 3))
  mode:int8 exit_code:int32 exit_arg:(Maybe int32)
  vm_steps:uint32
  vm_init_state_hash:bits256 vm_final_state_hash:bits256 ]
  = TrComputePhase;
cskip_no_state$00 = ComputeSkipReason;
cskip_bad_state$01 = ComputeSkipReason;
cskip_no_gas$10 = ComputeSkipReason;
cskip_suspended$110 = ComputeSkipReason;

tr_phase_action$_ success:Bool valid:Bool no_funds:Bool
  status_change:AccStatusChange
  total_fwd_fees:(Maybe Grams) total_action_fees:(Maybe Grams)
  result_code:int32 result_arg:(Maybe int32) tot_actions:uint16
  spec_actions:uint16 skipped_actions:uint16 msgs_created:uint16 
  action_list_hash:bits256 tot_msg_size:StorageUsed
  = TrActionPhase;

tr_phase_bounce_negfunds$00 = TrBouncePhase;
tr_phase_bounce_nofunds$01 msg_size:StorageUsed
  req_fwd_fees:Grams = TrBouncePhase;
tr_phase_bounce_ok$1 msg_size:StorageUsed
  msg_fees:Grams fwd_fees:Grams = TrBouncePhase;
//
trans_ord$0000 credit_first:Bool
  storage_ph:(Maybe TrStoragePhase)
  credit_ph:(Maybe TrCreditPhase)
  compute_ph:TrComputePhase action:(Maybe ^TrActionPhase)
  aborted:Bool bounce:(Maybe TrBouncePhase)
  destroyed:Bool
  = TransactionDescr;

trans_storage$0001 storage_ph:TrStoragePhase
  = TransactionDescr;

trans_tick_tock$001 is_tock:Bool storage_ph:TrStoragePhase
  compute_ph:TrComputePhase action:(Maybe ^TrActionPhase)
  aborted:Bool destroyed:Bool = TransactionDescr;
//
split_merge_info$_ cur_shard_pfx_len:(## 6)
  acc_split_depth:(## 6) this_addr:bits256 sibling_addr:bits256
  = SplitMergeInfo;
trans_split_prepare$0100 split_info:SplitMergeInfo
  storage_ph:(Maybe TrStoragePhase)
  compute_ph:TrComputePhase action:(Maybe ^TrActionPhase)
  aborted:Bool destroyed:Bool
  = TransactionDescr;
trans_split_install$0101 split_info:SplitMergeInfo
  prepare_transaction:^Transaction
  installed:Bool = TransactionDescr;

trans_merge_prepare$0110 split_info:SplitMergeInfo
  storage_ph:TrStoragePhase aborted:Bool
  = TransactionDescr;
trans_merge_install$0111 split_info:SplitMergeInfo
  prepare_transaction:^Transaction
  storage_ph:(Maybe TrStoragePhase)
  credit_ph:(Maybe TrCreditPhase)
  compute_ph:TrComputePhase action:(Maybe ^TrActionPhase)
  aborted:Bool destroyed:Bool
  = TransactionDescr;

smc_info#076ef1ea actions:uint16 msgs_sent:uint16
  unixtime:uint32 block_lt:uint64 trans_lt:uint64 
  rand_seed:bits256 balance_remaining:CurrencyCollection
  myself:MsgAddressInt global_config:(Maybe Cell) = SmartContractInfo;
//
//
out_list_empty$_ = OutList 0;
out_list$_ {n:#} prev:^(OutList n) action:OutAction
  = OutList (n + 1);
action_send_msg#0ec3c86d mode:(## 8) 
  out_msg:^(MessageRelaxed Any) = OutAction;
action_set_code#ad4de08e new_code:^Cell = OutAction;
action_reserve_currency#36e6b809 mode:(## 8)
  currency:CurrencyCollection = OutAction;
libref_hash$0 lib_hash:bits256 = LibRef;
libref_ref$1 library:^Cell = LibRef;
action_change_library#26fa1dd4 mode:(## 7)
  libref:LibRef = OutAction;

out_list_node$_ prev:^Cell action:OutAction = OutListNode;
//
//
shard_ident$00 shard_pfx_bits:(#<= 60) 
  workchain_id:int32 shard_prefix:uint64 = ShardIdent;

ext_blk_ref$_ end_lt:uint64
  seq_no:uint32 root_hash:bits256 file_hash:bits256 
  = ExtBlkRef;

block_id_ext$_ shard_id:ShardIdent seq_no:uint32
  root_hash:bits256 file_hash:bits256 = BlockIdExt;

master_info$_ master:ExtBlkRef = BlkMasterInfo;

shard_state#9023afe2 global_id:int32
  shard_id:ShardIdent 
  seq_no:uint32 vert_seq_no:#
  gen_utime:uint32 gen_lt:uint64
  min_ref_mc_seqno:uint32
  out_msg_queue_info:^OutMsgQueueInfo
  before_split:(## 1)
  accounts:^ShardAccounts
  ^[ overload_history:uint64 underload_history:uint64
  total_balance:CurrencyCollection
  total_validator_fees:CurrencyCollection
  libraries:(HashmapE 256 LibDescr)
  master_ref:(Maybe BlkMasterInfo) ]
  custom:(Maybe ^McStateExtra)
  = ShardStateUnsplit;
  
_ ShardStateUnsplit = ShardState;
split_state#5f327da5 left:^ShardStateUnsplit right:^ShardStateUnsplit = ShardState;

shared_lib_descr$00 lib:^Cell publishers:(Hashmap 256 True)
  = LibDescr;

block_info#9bc7a987 version:uint32 
  not_master:(## 1) 
  after_merge:(## 1) before_split:(## 1) 
  after_split:(## 1) 
  want_split:Bool want_merge:Bool
  key_block:Bool vert_seqno_incr:(## 1)
  flags:(## 8) { flags <= 1 }
  seq_no:# vert_seq_no:# { vert_seq_no >= vert_seqno_incr } 
  { prev_seq_no:# } { ~prev_seq_no + 1 = seq_no } 
  shard:ShardIdent gen_utime:uint32
  start_lt:uint64 end_lt:uint64
  gen_validator_list_hash_short:uint32
  gen_catchain_seqno:uint32
  min_ref_mc_seqno:uint32
  prev_key_block_seqno:uint32
  gen_software:flags . 0?GlobalVersion
  master_ref:not_master?^BlkMasterInfo 
  prev_ref:^(BlkPrevInfo after_merge)
  prev_vert_ref:vert_seqno_incr?^(BlkPrevInfo 0)
  = BlockInfo;

prev_blk_info$_ prev:ExtBlkRef = BlkPrevInfo 0;
prev_blks_info$_ prev1:^ExtBlkRef prev2:^ExtBlkRef = BlkPrevInfo 1;

block#11ef55aa global_id:int32
  info:^BlockInfo value_flow:^ValueFlow
  state_update:^(MERKLE_UPDATE ShardState) 
  extra:^BlockExtra = Block;

block_extra in_msg_descr:^InMsgDescr
  out_msg_descr:^OutMsgDescr
  account_blocks:^ShardAccountBlocks
  rand_seed:bits256
  created_by:bits256
  custom:(Maybe ^McBlockExtra) = BlockExtra;
//
value_flow#b8e48dfb ^[ from_prev_blk:CurrencyCollection 
  to_next_blk:CurrencyCollection
  imported:CurrencyCollection
  exported:CurrencyCollection ]
  fees_collected:CurrencyCollection
  ^[
  fees_imported:CurrencyCollection
  recovered:CurrencyCollection
  created:CurrencyCollection
  minted:CurrencyCollection
  ] = ValueFlow;

value_flow_v2#3ebf98b7 ^[ from_prev_blk:CurrencyCollection
  to_next_blk:CurrencyCollection
  imported:CurrencyCollection
  exported:CurrencyCollection ]
  fees_collected:CurrencyCollection
  burned:CurrencyCollection
  ^[
  fees_imported:CurrencyCollection
  recovered:CurrencyCollection
  created:CurrencyCollection
  minted:CurrencyCollection
  ] = ValueFlow;

//
//
bt_leaf$0 {X:Type} leaf:X = BinTree X;
bt_fork$1 {X:Type} left:^(BinTree X) right:^(BinTree X) 
          = BinTree X;

fsm_none$0 = FutureSplitMerge;
fsm_split$10 split_utime:uint32 interval:uint32 = FutureSplitMerge;
fsm_merge$11 merge_utime:uint32 interval:uint32 = FutureSplitMerge;

shard_descr#b seq_no:uint32 reg_mc_seqno:uint32
  start_lt:uint64 end_lt:uint64
  root_hash:bits256 file_hash:bits256 
  before_split:Bool before_merge:Bool
  want_split:Bool want_merge:Bool
  nx_cc_updated:Bool flags:(## 3) { flags = 0 }
  next_catchain_seqno:uint32 next_validator_shard:uint64
  min_ref_mc_seqno:uint32 gen_utime:uint32
  split_merge_at:FutureSplitMerge
  fees_collected:CurrencyCollection
  funds_created:CurrencyCollection = ShardDescr;

shard_descr_new#a seq_no:uint32 reg_mc_seqno:uint32
  start_lt:uint64 end_lt:uint64
  root_hash:bits256 file_hash:bits256 
  before_split:Bool before_merge:Bool
  want_split:Bool want_merge:Bool
  nx_cc_updated:Bool flags:(## 3) { flags = 0 }
  next_catchain_seqno:uint32 next_validator_shard:uint64
  min_ref_mc_seqno:uint32 gen_utime:uint32
  split_merge_at:FutureSplitMerge
  ^[ fees_collected:CurrencyCollection
     funds_created:CurrencyCollection ] = ShardDescr;

_ (HashmapE 32 ^(BinTree ShardDescr)) = ShardHashes;

bta_leaf$0 {X:Type} {Y:Type} extra:Y leaf:X = BinTreeAug X Y;
bta_fork$1 {X:Type} {Y:Type} left:^(BinTreeAug X Y) 
           right:^(BinTreeAug X Y) extra:Y = BinTreeAug X Y;

_ fees:CurrencyCollection create:CurrencyCollection = ShardFeeCreated;
_ (HashmapAugE 96 ShardFeeCreated ShardFeeCreated) = ShardFees;

_ config_addr:bits256 config:^(Hashmap 32 ^Cell) 
  = ConfigParams;

validator_info$_
  validator_list_hash_short:uint32 
  catchain_seqno:uint32
  nx_cc_updated:Bool
= ValidatorInfo;

validator_base_info$_
  validator_list_hash_short:uint32 
  catchain_seqno:uint32
= ValidatorBaseInfo;

_ key:Bool max_end_lt:uint64 = KeyMaxLt;
_ key:Bool blk_ref:ExtBlkRef = KeyExtBlkRef;

_ (HashmapAugE 32 KeyExtBlkRef KeyMaxLt) = OldMcBlocksInfo;


counters#_ last_updated:uint32 total:uint64 cnt2048:uint64 cnt65536:uint64 = Counters; 
creator_info#4 mc_blocks:Counters shard_blocks:Counters = CreatorStats; 
block_create_stats#17 counters:(HashmapE 256 CreatorStats) = BlockCreateStats;
block_create_stats_ext#34 counters:(HashmapAugE 256 CreatorStats uint32) = BlockCreateStats;

masterchain_state_extra#cc26
  shard_hashes:ShardHashes
  config:ConfigParams
  ^[ flags:(## 16) { flags <= 1 }
     validator_info:ValidatorInfo
     prev_blocks:OldMcBlocksInfo
     after_key_block:Bool
     last_key_block:(Maybe ExtBlkRef)
     block_create_stats:(flags . 0)?BlockCreateStats ]
  global_balance:CurrencyCollection
= McStateExtra;

ed25519_pubkey#8e81278a pubkey:bits256 = SigPubKey;  // 288 bits
ed25519_signature#5 R:bits256 s:bits256 = CryptoSignatureSimple;  // 516 bits
_ CryptoSignatureSimple = CryptoSignature;
sig_pair$_ node_id_short:bits256 sign:CryptoSignature = CryptoSignaturePair;  // 256+x ~ 772 bits

certificate#4 temp_key:SigPubKey valid_since:uint32 valid_until:uint32 = Certificate;  // 356 bits
certificate_env#a419b7d certificate:Certificate = CertificateEnv;  // 384 bits
signed_certificate$_ certificate:Certificate certificate_signature:CryptoSignature
  = SignedCertificate;  // 356+516 = 872 bits
// certificate_signature is the signature of CertificateEnv (with embedded certificate) with persistent key
chained_signature#f signed_cert:^SignedCertificate temp_key_signature:CryptoSignatureSimple
  = CryptoSignature;   // 4+(356+516)+516 = 520 bits+ref (1392 bits total)
// temp_key_signature is the signature of whatever was originally intended to be signed with temp_key from certificate

masterchain_block_extra#cca5
  key_block:(## 1)
  shard_hashes:ShardHashes
  shard_fees:ShardFees
  ^[ prev_blk_signatures:(HashmapE 16 CryptoSignaturePair)
     recover_create_msg:(Maybe ^InMsg)
     mint_msg:(Maybe ^InMsg) ]
  config:key_block?ConfigParams
= McBlockExtra;

//
//  CONFIGURATION PARAMETERS
//

validator#53 public_key:SigPubKey weight:uint64 = ValidatorDescr;
validator_addr#73 public_key:SigPubKey weight:uint64 adnl_addr:bits256 = ValidatorDescr;
validators#11 utime_since:uint32 utime_until:uint32 
  total:(## 16) main:(## 16) { main <= total } { main >= 1 } 
  list:(Hashmap 16 ValidatorDescr) = ValidatorSet;
validators_ext#12 utime_since:uint32 utime_until:uint32 
  total:(## 16) main:(## 16) { main <= total } { main >= 1 } 
  total_weight:uint64 list:(HashmapE 16 ValidatorDescr) = ValidatorSet;

_ config_addr:bits256 = ConfigParam 0;
_ elector_addr:bits256 = ConfigParam 1;
_ minter_addr:bits256 = ConfigParam 2;  // ConfigParam 0 is used if absent
_ fee_collector_addr:bits256 = ConfigParam 3;  // ConfigParam 1 is used if absent
_ dns_root_addr:bits256 = ConfigParam 4;  // root TON DNS resolver

burning_config#01
  blackhole_addr:(Maybe bits256)
  fee_burn_num:# fee_burn_denom:# { fee_burn_num <= fee_burn_denom } { fee_burn_denom >= 1 } = BurningConfig;
_ BurningConfig = ConfigParam 5;

_ mint_new_price:Grams mint_add_price:Grams = ConfigParam 6;
_ to_mint:ExtraCurrencyCollection = ConfigParam 7;

capabilities#c4 version:uint32 capabilities:uint64 = GlobalVersion;
_ GlobalVersion = ConfigParam 8;  // all zero if absent
_ mandatory_params:(Hashmap 32 True) = ConfigParam 9;
_ critical_params:(Hashmap 32 True) = ConfigParam 10;

cfg_vote_cfg#36 min_tot_rounds:uint8 max_tot_rounds:uint8 min_wins:uint8 max_losses:uint8 min_store_sec:uint32 max_store_sec:uint32 bit_price:uint32 cell_price:uint32 = ConfigProposalSetup;
cfg_vote_setup#91 normal_params:^ConfigProposalSetup critical_params:^ConfigProposalSetup = ConfigVotingSetup;
_ ConfigVotingSetup = ConfigParam 11;

cfg_proposal#f3 param_id:int32 param_value:(Maybe ^Cell) if_hash_equal:(Maybe uint256) 
  = ConfigProposal;
cfg_proposal_status#ce expires:uint32 proposal:^ConfigProposal is_critical:Bool
  voters:(HashmapE 16 True) remaining_weight:int64 validator_set_id:uint256 
  rounds_remaining:uint8 wins:uint8 losses:uint8 = ConfigProposalStatus;

wfmt_basic#1 vm_version:int32 vm_mode:uint64 = WorkchainFormat 1;
wfmt_ext#0 min_addr_len:(## 12) max_addr_len:(## 12) addr_len_step:(## 12)
  { min_addr_len >= 64 } { min_addr_len <= max_addr_len } 
  { max_addr_len <= 1023 } { addr_len_step <= 1023 }
  workchain_type_id:(## 32) { workchain_type_id >= 1 }
  = WorkchainFormat 0;

wc_split_merge_timings#0
  split_merge_delay:uint32 split_merge_interval:uint32
  min_split_merge_interval:uint32 max_split_merge_delay:uint32
  = WcSplitMergeTimings;

//workchain#a5 enabled_since:uint32 min_split:(## 8) max_split:(## 8)
//  { min_split <= max_split } { max_split <= 60 }

workchain#a6 enabled_since:uint32 monitor_min_split:(## 8)
  min_split:(## 8) max_split:(## 8) { monitor_min_split <= min_split }
  basic:(## 1) active:Bool accept_msgs:Bool flags:(## 13) { flags = 0 }
  zerostate_root_hash:bits256 zerostate_file_hash:bits256
  version:uint32 format:(WorkchainFormat basic)
  = WorkchainDescr;

workchain_v2#a7 enabled_since:uint32 monitor_min_split:(## 8)
  min_split:(## 8) max_split:(## 8) { monitor_min_split <= min_split }
  basic:(## 1) active:Bool accept_msgs:Bool flags:(## 13) { flags = 0 }
  zerostate_root_hash:bits256 zerostate_file_hash:bits256
  version:uint32 format:(WorkchainFormat basic)
  split_merge_timings:WcSplitMergeTimings
  persistent_state_split_depth:(## 8) { persistent_state_split_depth <= 63 }
  = WorkchainDescr;

_ workchains:(HashmapE 32 WorkchainDescr) = ConfigParam 12;

complaint_prices#1a deposit:Grams bit_price:Grams cell_price:Grams = ComplaintPricing; 
_ ComplaintPricing = ConfigParam 13;

block_grams_created#6b masterchain_block_fee:Grams basechain_block_fee:Grams
  = BlockCreateFees;
_ BlockCreateFees = ConfigParam 14;

_ validators_elected_for:uint32 elections_start_before:uint32 
  elections_end_before:uint32 stake_held_for:uint32
  = ConfigParam 15;
  
_ max_validators:(## 16) max_main_validators:(## 16) min_validators:(## 16) 
  { max_validators >= max_main_validators } 
  { max_main_validators >= min_validators } 
  { min_validators >= 1 }
  = ConfigParam 16;

_ min_stake:Grams max_stake:Grams min_total_stake:Grams max_stake_factor:uint32 = ConfigParam 17;

_#cc utime_since:uint32 bit_price_ps:uint64 cell_price_ps:uint64 
  mc_bit_price_ps:uint64 mc_cell_price_ps:uint64 = StoragePrices;
_ (Hashmap 32 StoragePrices) = ConfigParam 18;

_ global_id:int32 = ConfigParam 19;

gas_prices#dd gas_price:uint64 gas_limit:uint64 gas_credit:uint64 
  block_gas_limit:uint64 freeze_due_limit:uint64 delete_due_limit:uint64 
  = GasLimitsPrices;

gas_prices_ext#de gas_price:uint64 gas_limit:uint64 special_gas_limit:uint64 gas_credit:uint64 
  block_gas_limit:uint64 freeze_due_limit:uint64 delete_due_limit:uint64 
  = GasLimitsPrices;

gas_flat_pfx#d1 flat_gas_limit:uint64 flat_gas_price:uint64 other:GasLimitsPrices
  = GasLimitsPrices;

config_mc_gas_prices#_ GasLimitsPrices = ConfigParam 20;
config_gas_prices#_ GasLimitsPrices = ConfigParam 21;

param_limits#c3 underload:# soft_limit:# { underload <= soft_limit }
  hard_limit:# { soft_limit <= hard_limit } = ParamLimits;
block_limits#5d bytes:ParamLimits gas:ParamLimits lt_delta:ParamLimits
  = BlockLimits;
  
config_mc_block_limits#_ BlockLimits = ConfigParam 22;
config_block_limits#_ BlockLimits = ConfigParam 23;

// msg_fwd_fees = (lump_price + ceil((bit_price * msg.bits + cell_price * msg.cells)/2^16)) nanograms
// ihr_fwd_fees = ceil((msg_fwd_fees * ihr_price_factor)/2^16) nanograms
// bits in the root cell of a message are not included in msg.bits (lump_price pays for them)
msg_forward_prices#ea lump_price:uint64 bit_price:uint64 cell_price:uint64
  ihr_price_factor:uint32 first_frac:uint16 next_frac:uint16 = MsgForwardPrices;

// used for messages to/from masterchain
config_mc_fwd_prices#_ MsgForwardPrices = ConfigParam 24;
// used for all other messages
config_fwd_prices#_ MsgForwardPrices = ConfigParam 25;

catchain_config#c1 mc_catchain_lifetime:uint32 shard_catchain_lifetime:uint32 
  shard_validators_lifetime:uint32 shard_validators_num:uint32 = CatchainConfig;

catchain_config_new#c2 flags:(## 7) { flags = 0 } shuffle_mc_validators:Bool
  mc_catchain_lifetime:uint32 shard_catchain_lifetime:uint32
  shard_validators_lifetime:uint32 shard_validators_num:uint32 = CatchainConfig;

consensus_config#d6 round_candidates:# { round_candidates >= 1 }
  next_candidate_delay_ms:uint32 consensus_timeout_ms:uint32
  fast_attempts:uint32 attempt_duration:uint32 catchain_max_deps:uint32
  max_block_bytes:uint32 max_collated_bytes:uint32 = ConsensusConfig;

consensus_config_new#d7 flags:(## 7) { flags = 0 } new_catchain_ids:Bool
  round_candidates:(## 8) { round_candidates >= 1 }
  next_candidate_delay_ms:uint32 consensus_timeout_ms:uint32
  fast_attempts:uint32 attempt_duration:uint32 catchain_max_deps:uint32
  max_block_bytes:uint32 max_collated_bytes:uint32 = ConsensusConfig;

consensus_config_v3#d8 flags:(## 7) { flags = 0 } new_catchain_ids:Bool
  round_candidates:(## 8) { round_candidates >= 1 }
  next_candidate_delay_ms:uint32 consensus_timeout_ms:uint32
  fast_attempts:uint32 attempt_duration:uint32 catchain_max_deps:uint32
  max_block_bytes:uint32 max_collated_bytes:uint32 
  proto_version:uint16 = ConsensusConfig;

consensus_config_v4#d9 flags:(## 7) { flags = 0 } new_catchain_ids:Bool
  round_candidates:(## 8) { round_candidates >= 1 }
  next_candidate_delay_ms:uint32 consensus_timeout_ms:uint32
  fast_attempts:uint32 attempt_duration:uint32 catchain_max_deps:uint32
  max_block_bytes:uint32 max_collated_bytes:uint32
  proto_version:uint16 catchain_max_blocks_coeff:uint32 = ConsensusConfig;

_ CatchainConfig = ConfigParam 28;
_ ConsensusConfig = ConfigParam 29;

_ fundamental_smc_addr:(HashmapE 256 True) = ConfigParam 31;
_ prev_validators:ValidatorSet = ConfigParam 32;
_ prev_temp_validators:ValidatorSet = ConfigParam 33;
_ cur_validators:ValidatorSet = ConfigParam 34;
_ cur_temp_validators:ValidatorSet = ConfigParam 35;
_ next_validators:ValidatorSet = ConfigParam 36;
_ next_temp_validators:ValidatorSet = ConfigParam 37;

validator_temp_key#3 adnl_addr:bits256 temp_public_key:SigPubKey seqno:# valid_until:uint32 = ValidatorTempKey;
signed_temp_key#4 key:^ValidatorTempKey signature:CryptoSignature = ValidatorSignedTempKey;
_ (HashmapE 256 ValidatorSignedTempKey) = ConfigParam 39;

misbehaviour_punishment_config_v1#01 
  default_flat_fine:Grams default_proportional_fine:uint32
  severity_flat_mult:uint16 severity_proportional_mult:uint16
  unpunishable_interval:uint16
  long_interval:uint16 long_flat_mult:uint16 long_proportional_mult:uint16
  medium_interval:uint16 medium_flat_mult:uint16 medium_proportional_mult:uint16
   = MisbehaviourPunishmentConfig;
_ MisbehaviourPunishmentConfig = ConfigParam 40;

size_limits_config#01 max_msg_bits:uint32 max_msg_cells:uint32 max_library_cells:uint32 max_vm_data_depth:uint16
  max_ext_msg_size:uint32 max_ext_msg_depth:uint16 = SizeLimitsConfig;
size_limits_config_v2#02 max_msg_bits:uint32 max_msg_cells:uint32 max_library_cells:uint32 max_vm_data_depth:uint16
  max_ext_msg_size:uint32 max_ext_msg_depth:uint16 max_acc_state_cells:uint32 max_acc_state_bits:uint32
  max_acc_public_libraries:uint32 defer_out_queue_size_limit:uint32 max_msg_extra_currencies:uint32
  max_acc_fixed_prefix_length:uint8 = SizeLimitsConfig;
_ SizeLimitsConfig = ConfigParam 43;

// key is [ wc:int32 addr:uint256 ]
suspended_address_list#00 addresses:(HashmapE 288 Unit) suspended_until:uint32 = SuspendedAddressList;
_ SuspendedAddressList = ConfigParam 44;

precompiled_smc#b0 gas_usage:uint64 = PrecompiledSmc;
precompiled_contracts_config#c0 list:(HashmapE 256 PrecompiledSmc) = PrecompiledContractsConfig;
_ PrecompiledContractsConfig = ConfigParam 45;

oracle_bridge_params#_ bridge_address:bits256 oracle_mutlisig_address:bits256 oracles:(HashmapE 256 uint256) external_chain_address:bits256 = OracleBridgeParams;
_ OracleBridgeParams = ConfigParam 71; // Ethereum bridge
_ OracleBridgeParams = ConfigParam 72; // Binance Smart Chain bridge
_ OracleBridgeParams = ConfigParam 73; // Polygon bridge

// Note that chains in which bridge, minter and jetton-wallet operate are fixated
jetton_bridge_prices#_ bridge_burn_fee:Coins bridge_mint_fee:Coins
                       wallet_min_tons_for_storage:Coins
                       wallet_gas_consumption:Coins
                       minter_min_tons_for_storage:Coins
                       discover_gas_consumption:Coins = JettonBridgePrices;

jetton_bridge_params_v0#00 bridge_address:bits256 oracles_address:bits256 oracles:(HashmapE 256 uint256) state_flags:uint8 burn_bridge_fee:Coins = JettonBridgeParams;
jetton_bridge_params_v1#01 bridge_address:bits256 oracles_address:bits256 oracles:(HashmapE 256 uint256) state_flags:uint8 prices:^JettonBridgePrices external_chain_address:bits256 = JettonBridgeParams;

_ JettonBridgeParams = ConfigParam 79; // ETH->TON token bridge
_ JettonBridgeParams = ConfigParam 81; // BNB->TON token bridge
_ JettonBridgeParams = ConfigParam 82; // Polygon->TON token bridge


//
//  PROOFS
//
block_signatures_pure#_ sig_count:uint32 sig_weight:uint64
  signatures:(HashmapE 16 CryptoSignaturePair) = BlockSignaturesPure;
block_signatures#11 validator_info:ValidatorBaseInfo pure_signatures:BlockSignaturesPure = BlockSignatures;
block_proof#c3 proof_for:BlockIdExt root:^Cell signatures:(Maybe ^BlockSignatures) = BlockProof;

chain_empty$_ = ProofChain 0;
chain_link$_ {n:#} root:^Cell prev:n?^(ProofChain n) = ProofChain (n + 1);
top_block_descr#d5 proof_for:BlockIdExt signatures:(Maybe ^BlockSignatures) 
  len:(## 8) { len >= 1 } { len <= 8 } chain:(ProofChain len) = TopBlockDescr;

//
//  COLLATED DATA
//
top_block_descr_set#4ac789f3 collection:(HashmapE 96 ^TopBlockDescr) = TopBlockDescrSet;

//
//  VALIDATOR MISBEHAVIOR COMPLAINTS
//
prod_info#34 utime:uint32 mc_blk_ref:ExtBlkRef state_proof:^(MERKLE_PROOF Block)
  prod_proof:^(MERKLE_PROOF ShardState) = ProducerInfo;
no_blk_gen from_utime:uint32 prod_info:^ProducerInfo = ComplaintDescr;
no_blk_gen_diff prod_info_old:^ProducerInfo prod_info_new:^ProducerInfo = ComplaintDescr;
validator_complaint#bc validator_pubkey:bits256 description:^ComplaintDescr created_at:uint32 severity:uint8 reward_addr:uint256 paid:Grams suggested_fine:Grams suggested_fine_part:uint32 = ValidatorComplaint;
complaint_status#2d complaint:^ValidatorComplaint voters:(HashmapE 16 True) vset_id:uint256 weight_remaining:int64 = ValidatorComplaintStatus;

//
//  TVM REFLECTION
//
vm_stk_null#00 = VmStackValue;
vm_stk_tinyint#01 value:int64 = VmStackValue;
vm_stk_int#0201_ value:int257 = VmStackValue;
vm_stk_nan#02ff = VmStackValue;
vm_stk_cell#03 cell:^Cell = VmStackValue;
_ cell:^Cell st_bits:(## 10) end_bits:(## 10) { st_bits <= end_bits }
  st_ref:(#<= 4) end_ref:(#<= 4) { st_ref <= end_ref } = VmCellSlice;
vm_stk_slice#04 _:VmCellSlice = VmStackValue;
vm_stk_builder#05 cell:^Cell = VmStackValue;
vm_stk_cont#06 cont:VmCont = VmStackValue;
vm_tupref_nil$_ = VmTupleRef 0;
vm_tupref_single$_ entry:^VmStackValue = VmTupleRef 1;
vm_tupref_any$_ {n:#} ref:^(VmTuple (n + 2)) = VmTupleRef (n + 2);
vm_tuple_nil$_ = VmTuple 0;
vm_tuple_tcons$_ {n:#} head:(VmTupleRef n) tail:^VmStackValue = VmTuple (n + 1);
vm_stk_tuple#07 len:(## 16) data:(VmTuple len) = VmStackValue;

vm_stack#_ depth:(## 24) stack:(VmStackList depth) = VmStack;
vm_stk_cons#_ {n:#} rest:^(VmStackList n) tos:VmStackValue = VmStackList (n + 1);
vm_stk_nil#_ = VmStackList 0;

_ cregs:(HashmapE 4 VmStackValue) = VmSaveList;
gas_limits#_ remaining:int64 _:^[ max_limit:int64 cur_limit:int64 credit:int64 ]
  = VmGasLimits;
_ libraries:(HashmapE 256 ^Cell) = VmLibraries;

vm_ctl_data$_ nargs:(Maybe uint13) stack:(Maybe VmStack) save:VmSaveList
cp:(Maybe int16) = VmControlData;
vmc_std$00 cdata:VmControlData code:VmCellSlice = VmCont;
vmc_envelope$01 cdata:VmControlData next:^VmCont = VmCont;
vmc_quit$1000 exit_code:int32 = VmCont;
vmc_quit_exc$1001 = VmCont;
vmc_repeat$10100 count:uint63 body:^VmCont after:^VmCont = VmCont; 
vmc_until$110000 body:^VmCont after:^VmCont = VmCont;
vmc_again$110001 body:^VmCont = VmCont;
vmc_while_cond$110010 cond:^VmCont body:^VmCont
after:^VmCont = VmCont;
vmc_while_body$110011 cond:^VmCont body:^VmCont
after:^VmCont = VmCont;
vmc_pushint$1111 value:int32 next:^VmCont = VmCont;

//
//  DNS RECORDS
//
_ (HashmapE 256 ^DNSRecord) = DNS_RecordSet;

chunk_ref$_ {n:#} ref:^(TextChunks (n + 1)) = TextChunkRef (n + 1);
chunk_ref_empty$_ = TextChunkRef 0;
text_chunk$_ {n:#} len:(## 8) data:(bits (len * 8)) next:(TextChunkRef n) = TextChunks (n + 1);
text_chunk_empty$_ = TextChunks 0;
text$_ chunks:(## 8) rest:(TextChunks chunks) = Text;
dns_text#1eda _:Text = DNSRecord;

dns_next_resolver#ba93 resolver:MsgAddressInt = DNSRecord;  // usually in record #-1

dns_adnl_address#ad01 adnl_addr:bits256 flags:(## 8) { flags <= 1 }
  proto_list:flags . 0?ProtoList = DNSRecord;  // often in record #2
proto_list_nil$0 = ProtoList;
proto_list_next$1 head:Protocol tail:ProtoList = ProtoList;
proto_http#4854 = Protocol;

dns_smc_address#9fd3 smc_addr:MsgAddressInt flags:(## 8) { flags <= 1 }
  cap_list:flags . 0?SmcCapList = DNSRecord;   // often in record #1
cap_list_nil$0 = SmcCapList;
cap_list_next$1 head:SmcCapability tail:SmcCapList = SmcCapList;
cap_method_seqno#5371 = SmcCapability;
cap_method_pubkey#71f4 = SmcCapability;
cap_is_wallet#2177 = SmcCapability;
cap_name#ff name:Text = SmcCapability;

dns_storage_address#7473 bag_id:bits256 = DNSRecord;

//
// PAYMENT CHANNELS
//

chan_config$_  init_timeout:uint32 close_timeout:uint32 a_key:bits256 b_key:bits256 
  a_addr:^MsgAddressInt b_addr:^MsgAddressInt channel_id:uint64 min_A_extra:Grams = ChanConfig;

chan_state_init$000  signed_A:Bool signed_B:Bool min_A:Grams min_B:Grams expire_at:uint32 A:Grams B:Grams = ChanState;
chan_state_close$001 signed_A:Bool signed_B:Bool promise_A:Grams promise_B:Grams expire_at:uint32 A:Grams B:Grams = ChanState;
chan_state_payout$010 A:Grams B:Grams = ChanState;

chan_promise$_ channel_id:uint64 promise_A:Grams promise_B:Grams = ChanPromise;
chan_signed_promise#_ sig:(Maybe ^bits512) promise:ChanPromise = ChanSignedPromise;

chan_msg_init#27317822 inc_A:Grams inc_B:Grams min_A:Grams min_B:Grams channel_id:uint64 = ChanMsg;
chan_msg_close#f28ae183 extra_A:Grams extra_B:Grams promise:ChanSignedPromise  = ChanMsg;
chan_msg_timeout#43278a28 = ChanMsg;
chan_msg_payout#37fe7810 = ChanMsg;

chan_signed_msg$_ sig_A:(Maybe ^bits512) sig_B:(Maybe ^bits512) msg:ChanMsg = ChanSignedMsg;

chan_op_cmd#912838d1 msg:ChanSignedMsg = ChanOp;


chan_data$_ config:^ChanConfig state:^ChanState = ChanData;
`;
  return schema;
}
var hasRequiredDist$2;
function requireDist$2() {
  if (hasRequiredDist$2) return dist$3;
  hasRequiredDist$2 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.blockSchema = exports.unwrap = exports.TLBSchemaError = exports.TLBRuntimeError = exports.TLBDataError = exports.parseTLB = exports.TLBRuntime = exports.parseCell = exports.encodeCell = exports.replacer = void 0;
    var parser_1 = requireParser();
    Object.defineProperty(exports, "replacer", { enumerable: true, get: function() {
      return parser_1.replacer;
    } });
    Object.defineProperty(exports, "encodeCell", { enumerable: true, get: function() {
      return parser_1.encodeCell;
    } });
    Object.defineProperty(exports, "parseCell", { enumerable: true, get: function() {
      return parser_1.parseCell;
    } });
    var TLBRuntime_1 = requireTLBRuntime();
    Object.defineProperty(exports, "TLBRuntime", { enumerable: true, get: function() {
      return TLBRuntime_1.TLBRuntime;
    } });
    Object.defineProperty(exports, "parseTLB", { enumerable: true, get: function() {
      return TLBRuntime_1.parseTLB;
    } });
    Object.defineProperty(exports, "TLBDataError", { enumerable: true, get: function() {
      return TLBRuntime_1.TLBDataError;
    } });
    Object.defineProperty(exports, "TLBRuntimeError", { enumerable: true, get: function() {
      return TLBRuntime_1.TLBRuntimeError;
    } });
    Object.defineProperty(exports, "TLBSchemaError", { enumerable: true, get: function() {
      return TLBRuntime_1.TLBSchemaError;
    } });
    var Result_1 = requireResult();
    Object.defineProperty(exports, "unwrap", { enumerable: true, get: function() {
      return Result_1.unwrap;
    } });
    var schema_1 = requireSchema();
    Object.defineProperty(exports, "blockSchema", { enumerable: true, get: function() {
      return schema_1.blockSchema;
    } });
  })(dist$3);
  return dist$3;
}
var distExports$2 = requireDist$2();
const BASE64_REGEX = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
const BOC_PREFIX = "te6cc";
function isValidObject(data) {
  return typeof data === "object" && data !== null;
}
function isValidString(data) {
  return typeof data === "string";
}
function hasExtraProperties(data, allowedKeys) {
  return typeof data === "object" && data !== null && Object.keys(data).some((key2) => !allowedKeys.includes(key2));
}
function isValidBoc(value) {
  return typeof value === "string" && BASE64_REGEX.test(value) && value.startsWith(BOC_PREFIX);
}
function validateSignDataPayload(data) {
  if (!isValidObject(data)) {
    return "Payload must be an object";
  }
  if (!isValidString(data.type)) {
    return "'type' is required";
  }
  switch (data.type) {
    case "text":
      return validateSignDataPayloadText(data);
    case "binary":
      return validateSignDataPayloadBinary(data);
    case "cell":
      return validateSignDataPayloadCell(data);
    default:
      return "Invalid 'type' value";
  }
}
function validateSignDataPayloadText(data) {
  const allowedKeys = ["type", "text", "network", "from"];
  if (hasExtraProperties(data, allowedKeys)) {
    return "Text payload contains extra properties";
  }
  if (!isValidString(data.text)) {
    return "'text' is required";
  }
  if (data.network !== void 0) {
    if (!isValidString(data.network) || !/^-?\d+$/.test(data.network)) {
      return "Invalid 'network' format";
    }
  }
  if (data.from !== void 0 && !isValidString(data.from)) {
    return "Invalid 'from'";
  }
  return null;
}
function validateSignDataPayloadBinary(data) {
  const allowedKeys = ["type", "bytes", "network", "from"];
  if (hasExtraProperties(data, allowedKeys)) {
    return "Binary payload contains extra properties";
  }
  if (!isValidString(data.bytes)) {
    return "'bytes' is required";
  }
  if (data.network !== void 0) {
    if (!isValidString(data.network) || !/^-?\d+$/.test(data.network)) {
      return "Invalid 'network' format";
    }
  }
  if (data.from !== void 0 && !isValidString(data.from)) {
    return "Invalid 'from'";
  }
  return null;
}
function validateSignDataPayloadCell(data) {
  const allowedKeys = ["type", "schema", "cell", "network", "from"];
  if (hasExtraProperties(data, allowedKeys)) {
    return "Cell payload contains extra properties";
  }
  if (!isValidString(data.schema)) {
    return "'schema' is required";
  }
  if (!isValidString(data.cell)) {
    return "'cell' is required";
  }
  if (!isValidBoc(data.cell)) {
    return "Invalid 'cell' format (must be valid base64)";
  }
  if (data.network !== void 0) {
    if (!isValidString(data.network) || !/^-?\d+$/.test(data.network)) {
      return "Invalid 'network' format";
    }
  }
  if (data.from !== void 0 && !isValidString(data.from)) {
    return "Invalid 'from'";
  }
  return null;
}
const log$c = globalLogger.createChild("SignDataHandler");
class SignDataHandler extends BasicHandler {
  analyticsApi;
  walletKitConfig;
  constructor(notify, walletKitConfig, analyticsApi) {
    super(notify);
    this.walletKitConfig = walletKitConfig;
    this.analyticsApi = analyticsApi;
  }
  canHandle(event) {
    return event.method === "signData";
  }
  async handle(event) {
    if (!event.walletAddress) {
      throw new WalletKitError(ERROR_CODES.WALLET_REQUIRED, "No wallet address found in sign data event", void 0, { eventId: event.id });
    }
    const data = this.parseDataToSign(event);
    if (!data) {
      log$c.error("No data to sign found in request", { event });
      throw new WalletKitError(ERROR_CODES.INVALID_REQUEST_EVENT, "No data to sign found in request", void 0, {
        eventId: event.id
      });
    }
    const preview = this.createDataPreview(data, event);
    if (!preview) {
      log$c.error("No preview found for data", { data });
      throw new WalletKitError(ERROR_CODES.RESPONSE_CREATION_FAILED, "Failed to create preview for sign data request", void 0, { eventId: event.id, data });
    }
    const signEvent = {
      ...event,
      request: data,
      preview,
      dAppInfo: event.dAppInfo ?? {},
      walletAddress: event.walletAddress
    };
    this.analyticsApi?.sendEvents([
      {
        event_name: "wallet-sign-data-request-received",
        trace_id: event.traceId ?? uuidv7(),
        client_environment: "wallet",
        subsystem: getEventsSubsystem(),
        client_id: event.from,
        wallet_id: event.walletAddress ? Base64Normalize(event.walletAddress) : void 0,
        client_timestamp: getUnixtime(),
        dapp_name: event.dAppInfo?.name,
        version: getVersion(),
        network_id: this.walletKitConfig.network,
        wallet_app_name: this.walletKitConfig.deviceInfo?.appName,
        wallet_app_version: this.walletKitConfig.deviceInfo?.appVersion,
        event_id: uuidv7(),
        // manifest_json_url: event.dAppInfo?.url, // todo
        origin_url: event.dAppInfo?.url
      }
    ]);
    return signEvent;
  }
  /**
   * Parse data to sign from bridge event
   */
  parseDataToSign(event) {
    try {
      const parsed = JSON.parse(event.params[0]);
      const validationResult = validateSignDataPayload(parsed);
      if (validationResult) {
        log$c.error("Invalid data to sign found in request", { validationResult });
        return void 0;
      }
      return parsed;
    } catch (error2) {
      log$c.error("Invalid data to sign found in request", { error: error2 });
      return void 0;
    }
  }
  /**
   * Create human-readable preview of data to sign
   */
  createDataPreview(data, _event) {
    if (data.type === "text") {
      return {
        kind: "text",
        content: data.text
      };
    }
    if (data.type === "binary") {
      return {
        kind: "binary",
        content: data.bytes
      };
    }
    if (data.type === "cell") {
      if (!data.schema) {
        return {
          kind: "cell",
          content: data.cell
        };
      }
      try {
        const parsed = distExports$2.parseTLB(data.schema).deserialize(data.cell);
        return {
          kind: "cell",
          schema: data.schema,
          content: data.cell,
          parsed
        };
      } catch (error2) {
        log$c.error("Error deserializing cell", { error: error2 });
        return {
          kind: "cell",
          content: data.cell
        };
      }
    }
    return void 0;
  }
}
class DisconnectHandler extends BasicHandler {
  sessionManager;
  constructor(notify, sessionManager) {
    super(notify);
    this.sessionManager = sessionManager;
  }
  canHandle(event) {
    return event.method === "disconnect";
  }
  async handle(event) {
    if (!event.walletAddress) {
      throw new WalletKitError(ERROR_CODES.WALLET_REQUIRED, "No wallet address found in disconnect event", void 0, { eventId: event.id });
    }
    const reason = this.extractDisconnectReason(event);
    const disconnectEvent = {
      reason,
      walletAddress: event.walletAddress,
      dAppInfo: event.dAppInfo ?? {}
    };
    await this.sessionManager.removeSession(event.from || "");
    return disconnectEvent;
  }
  /**
   * Extract disconnect reason from bridge event
   */
  extractDisconnectReason(event) {
    const params = event.params || {};
    const reason = params.reason;
    if (typeof reason === "string" && reason.length > 0) {
      return reason.slice(0, 200);
    }
    return void 0;
  }
}
const log$b = globalLogger.createChild("EventRouter");
class EventRouter {
  eventEmitter;
  sessionManager;
  walletManager;
  config;
  analyticsApi;
  handlers = [];
  bridgeManager;
  // Event callbacks
  connectRequestCallback = void 0;
  transactionRequestCallback = void 0;
  signDataRequestCallback = void 0;
  disconnectCallback = void 0;
  errorCallback = void 0;
  constructor(eventEmitter, sessionManager, walletManager, config, analyticsApi) {
    this.eventEmitter = eventEmitter;
    this.sessionManager = sessionManager;
    this.walletManager = walletManager;
    this.config = config;
    this.analyticsApi = analyticsApi;
    this.config = config;
    this.setupHandlers();
  }
  setBridgeManager(bridgeManager) {
    this.bridgeManager = bridgeManager;
  }
  /**
   * Route incoming bridge event to appropriate handler
   */
  async routeEvent(event) {
    const validation = validateBridgeEvent(event);
    if (!validation.isValid) {
      log$b.error("Invalid bridge event", { errors: validation.errors });
      return;
    }
    try {
      for (const handler of this.handlers) {
        if (handler.canHandle(event)) {
          const result = await handler.handle(event);
          if ("error" in result) {
            this.notifyErrorCallback({ incomingEvent: event, result });
            try {
              await this.bridgeManager.sendResponse(event, result);
            } catch (error2) {
              log$b.error("Error sending response for error event", { error: error2, event, result });
            }
            return;
          }
          await handler.notify(result);
          break;
        }
      }
    } catch (error2) {
      log$b.error("Error routing event", { error: error2 });
    }
  }
  /**
   * Register event callbacks
   */
  onConnectRequest(callback) {
    this.connectRequestCallback = callback;
  }
  onTransactionRequest(callback) {
    this.transactionRequestCallback = callback;
  }
  onSignDataRequest(callback) {
    this.signDataRequestCallback = callback;
  }
  onDisconnect(callback) {
    this.disconnectCallback = callback;
  }
  onRequestError(callback) {
    this.errorCallback = callback;
  }
  /**
   * Remove specific callback
   */
  removeConnectRequestCallback() {
    this.connectRequestCallback = void 0;
  }
  removeTransactionRequestCallback() {
    this.transactionRequestCallback = void 0;
  }
  removeSignDataRequestCallback() {
    this.signDataRequestCallback = void 0;
  }
  removeDisconnectCallback() {
    this.disconnectCallback = void 0;
  }
  removeErrorCallback() {
    this.errorCallback = void 0;
  }
  /**
   * Clear all callbacks
   */
  clearCallbacks() {
    this.connectRequestCallback = void 0;
    this.transactionRequestCallback = void 0;
    this.signDataRequestCallback = void 0;
    this.disconnectCallback = void 0;
    this.errorCallback = void 0;
  }
  /**
   * Setup event handlers
   */
  setupHandlers() {
    this.handlers = [
      new ConnectHandler(this.notifyConnectRequestCallbacks.bind(this), this.config, this.analyticsApi),
      new TransactionHandler(this.notifyTransactionRequestCallbacks.bind(this), this.eventEmitter, this.config, this.walletManager, this.analyticsApi),
      new SignDataHandler(this.notifySignDataRequestCallbacks.bind(this), this.config, this.analyticsApi),
      new DisconnectHandler(this.notifyDisconnectCallbacks.bind(this), this.sessionManager)
    ];
  }
  /**
   * Notify connect request callbacks
   */
  notifyConnectRequestCallbacks(event) {
    if ("error" in event) {
      return;
    }
    this.connectRequestCallback?.(event);
  }
  /**
   * Notify transaction request callbacks
   */
  async notifyTransactionRequestCallbacks(event) {
    this.transactionRequestCallback?.(event);
  }
  /**
   * Notify sign data request callbacks
   */
  notifySignDataRequestCallbacks(event) {
    this.signDataRequestCallback?.(event);
  }
  /**
   * Notify disconnect callbacks
   */
  notifyDisconnectCallbacks(event) {
    this.disconnectCallback?.(event);
  }
  /**
   * Notify error callbacks
   */
  notifyErrorCallback(event) {
    this.errorCallback?.(event);
  }
  /**
   * Get enabled event types based on registered callbacks
   */
  getEnabledEventTypes() {
    const enabledTypes = [];
    if (this.connectRequestCallback) {
      enabledTypes.push("connect");
    }
    if (this.transactionRequestCallback) {
      enabledTypes.push("sendTransaction");
    }
    if (this.signDataRequestCallback) {
      enabledTypes.push("signData");
    }
    if (this.disconnectCallback) {
      enabledTypes.push("disconnect");
    }
    return enabledTypes;
  }
}
var distExports$1 = requireDist$5();
const tonProofPrefix = "ton-proof-item-v2/";
const tonConnectPrefix = "ton-connect";
async function CreateTonProofMessageBytes(message) {
  const wc = Buffer.alloc(4);
  wc.writeUInt32BE(message.workchain);
  const ts = Buffer.alloc(8);
  ts.writeBigUInt64LE(BigInt(message.timstamp));
  const dl = Buffer.alloc(4);
  dl.writeUInt32LE(message.domain.lengthBytes);
  const m2 = Buffer.concat([
    Buffer.from(tonProofPrefix),
    wc,
    message.address,
    dl,
    Buffer.from(message.domain.value),
    ts,
    Buffer.from(message.payload)
  ]);
  const messageHash = distExports$1.sha256_sync(m2);
  const fullMes = Buffer.concat([Buffer.from([255, 255]), Buffer.from(tonConnectPrefix), Buffer.from(messageHash)]);
  const res = distExports$1.sha256_sync(fullMes);
  return Buffer.from(res);
}
function createTonProofMessage({ address, domain, payload, stateInit, timestamp }) {
  const res = {
    workchain: address.workChain,
    address: address.hash,
    domain: {
      lengthBytes: domain.lengthBytes,
      value: domain.value
    },
    payload,
    stateInit,
    timstamp: timestamp
  };
  return res;
}
/*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */
function signed_crc_table() {
  var c = 0, table = new Array(256);
  for (var n = 0; n != 256; ++n) {
    c = n;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    table[n] = c;
  }
  return typeof Int32Array !== "undefined" ? new Int32Array(table) : table;
}
var T0 = signed_crc_table();
function slice_by_16_tables(T10) {
  var c = 0, v2 = 0, n = 0, table = typeof Int32Array !== "undefined" ? new Int32Array(4096) : new Array(4096);
  for (n = 0; n != 256; ++n)
    table[n] = T10[n];
  for (n = 0; n != 256; ++n) {
    v2 = T10[n];
    for (c = 256 + n; c < 4096; c += 256)
      v2 = table[c] = v2 >>> 8 ^ T10[v2 & 255];
  }
  var out = [];
  for (n = 1; n != 16; ++n)
    out[n - 1] = typeof Int32Array !== "undefined" ? table.subarray(n * 256, n * 256 + 256) : table.slice(n * 256, n * 256 + 256);
  return out;
}
var TT = slice_by_16_tables(T0);
var T1 = TT[0], T2 = TT[1], T3 = TT[2], T4 = TT[3], T5 = TT[4];
var T6 = TT[5], T7 = TT[6], T8 = TT[7], T9 = TT[8], Ta = TT[9];
var Tb = TT[10], Tc = TT[11], Td = TT[12], Te = TT[13], Tf = TT[14];
function crc32_buf(B2, seed) {
  var C2 = seed ^ -1, L = B2.length - 15, i = 0;
  for (; i < L; )
    C2 = Tf[B2[i++] ^ C2 & 255] ^ Te[B2[i++] ^ C2 >> 8 & 255] ^ Td[B2[i++] ^ C2 >> 16 & 255] ^ Tc[B2[i++] ^ C2 >>> 24] ^ Tb[B2[i++]] ^ Ta[B2[i++]] ^ T9[B2[i++]] ^ T8[B2[i++]] ^ T7[B2[i++]] ^ T6[B2[i++]] ^ T5[B2[i++]] ^ T4[B2[i++]] ^ T3[B2[i++]] ^ T2[B2[i++]] ^ T1[B2[i++]] ^ T0[B2[i++]];
  L += 15;
  while (i < L)
    C2 = C2 >>> 8 ^ T0[(C2 ^ B2[i++]) & 255];
  return ~C2;
}
const buf = crc32_buf;
function createTextBinaryHash(payload, parsedAddr, domain, timestamp) {
  const wcBuffer = Buffer.alloc(4);
  wcBuffer.writeInt32BE(parsedAddr.workChain);
  const domainBuffer = Buffer.from(domain, "utf8");
  const domainLenBuffer = Buffer.alloc(4);
  domainLenBuffer.writeUInt32BE(domainBuffer.length);
  const tsBuffer = Buffer.alloc(8);
  tsBuffer.writeBigUInt64BE(BigInt(timestamp));
  const typePrefix = payload.type === "text" ? "txt" : "bin";
  const content2 = payload.type === "text" ? payload.text : payload.bytes;
  const encoding2 = payload.type === "text" ? "utf8" : "base64";
  const payloadPrefix = Buffer.from(typePrefix);
  const payloadBuffer = Buffer.from(content2, encoding2);
  const payloadLenBuffer = Buffer.alloc(4);
  payloadLenBuffer.writeUInt32BE(payloadBuffer.length);
  const message = Buffer.concat([
    Buffer.from([255, 255]),
    Buffer.from("ton-connect/sign-data/"),
    wcBuffer,
    parsedAddr.hash,
    domainLenBuffer,
    domainBuffer,
    tsBuffer,
    payloadPrefix,
    payloadLenBuffer,
    payloadBuffer
  ]);
  return distExports$1.sha256_sync(message);
}
function createCellHash(payload, parsedAddr, domain, timestamp) {
  const cell = distExports$3.Cell.fromBase64(payload.cell);
  const schemaHash = buf(Buffer.from(payload.schema, "utf8"), void 0) >>> 0;
  const tep81Domain = domain.split(".").reverse().join("\0") + "\0";
  const message = distExports$3.beginCell().storeUint(1968607266, 32).storeUint(schemaHash, 32).storeUint(timestamp, 64).storeAddress(parsedAddr).storeStringRefTail(tep81Domain).storeRef(cell).endCell();
  return Buffer.from(message.hash());
}
function PrepareTonConnectData(params) {
  const { payload, domain, address } = params;
  const timestamp = Math.floor(Date.now() / 1e3);
  const parsedAddr = distExports$3.Address.parse(address);
  const finalHash = payload.type === "cell" ? createCellHash(payload, parsedAddr, domain, timestamp) : createTextBinaryHash(payload, parsedAddr, domain, timestamp);
  return {
    address,
    timestamp,
    domain,
    payload,
    hash: new Uint8Array(finalHash)
  };
}
const DEFAULT_DEVICE_INFO = {
  platform: "browser",
  appName: "Wallet",
  appVersion: "1.0.0",
  maxProtocolVersion: 2,
  features: [
    "SendTransaction",
    {
      name: "SendTransaction",
      maxMessages: 1
    }
  ]
};
function getDeviceInfoWithDefaults(options) {
  const deviceInfo = {
    ...DEFAULT_DEVICE_INFO,
    ...options
  };
  return deviceInfo;
}
const log$a = globalLogger.createChild("RequestProcessor");
class RequestProcessor {
  walletKitOptions;
  sessionManager;
  bridgeManager;
  walletManager;
  client;
  network;
  analyticsApi;
  constructor(walletKitOptions, sessionManager, bridgeManager, walletManager, client, network, analyticsApi) {
    this.walletKitOptions = walletKitOptions;
    this.sessionManager = sessionManager;
    this.bridgeManager = bridgeManager;
    this.walletManager = walletManager;
    this.client = client;
    this.network = network;
    this.analyticsApi = analyticsApi;
  }
  /**
   * Process connect request approval
   */
  async approveConnectRequest(event) {
    try {
      if ("preview" in event && "request" in event) {
        if (!event.walletAddress) {
          const error2 = new WalletKitError(ERROR_CODES.WALLET_REQUIRED, "Wallet is required for connect request approval", void 0, { eventId: event.id });
          throw error2;
        }
        const wallet = this.walletManager.getWallet(event.walletAddress);
        if (!wallet) {
          const error2 = new WalletKitError(ERROR_CODES.WALLET_NOT_FOUND, "Wallet not found for connect request", void 0, { walletAddress: event.walletAddress, eventId: event.id });
          throw error2;
        }
        const url = new URL(event.preview.manifest?.url || "");
        const domain = url.hostname;
        const newSession = await this.sessionManager.createSession(event.from || (await distExports$1.getSecureRandomBytes(32)).toString("hex"), event.preview.manifest?.name || "", domain, event.preview.manifest?.iconUrl || "", event.preview.manifest?.description || "", wallet);
        await this.bridgeManager.createSession(newSession.sessionId);
        const response = await this.createConnectApprovalResponse(event);
        await this.bridgeManager.sendResponse(event, response.result);
        this.analyticsApi?.sendEvents([
          {
            event_name: "wallet-connect-accepted",
            trace_id: event.traceId,
            client_environment: "wallet",
            subsystem: getEventsSubsystem(),
            network_id: this.walletKitOptions.network,
            wallet_app_name: this.walletKitOptions.deviceInfo?.appName,
            wallet_app_version: this.walletKitOptions.deviceInfo?.appVersion,
            event_id: uuidv7(),
            origin_url: event.dAppInfo?.url,
            dapp_name: event.dAppInfo?.name,
            client_id: event.from,
            is_ton_addr: event.request.some((item) => item.name === "ton_addr"),
            is_ton_proof: event.request.some((item) => item.name === "ton_proof"),
            manifest_json_url: event.preview.manifest?.url,
            proof_payload_size: event.request.find((item) => item.name === "ton_proof")?.payload?.length,
            client_timestamp: getUnixtime(),
            version: getVersion()
          },
          {
            event_name: "wallet-connect-response-sent",
            trace_id: event.traceId,
            client_environment: "wallet",
            subsystem: getEventsSubsystem(),
            client_id: event.from,
            client_timestamp: getUnixtime(),
            version: getVersion(),
            dapp_name: event.dAppInfo?.name,
            origin_url: event.dAppInfo?.url,
            is_ton_addr: event.request.some((item) => item.name === "ton_addr"),
            is_ton_proof: event.request.some((item) => item.name === "ton_proof"),
            manifest_json_url: event.preview.manifest?.url,
            proof_payload_size: event.request.find((item) => item.name === "ton_proof")?.payload?.length,
            event_id: uuidv7(),
            network_id: this.walletKitOptions.network,
            wallet_app_name: this.walletKitOptions.deviceInfo?.appName,
            wallet_app_version: this.walletKitOptions.deviceInfo?.appVersion
          }
        ]);
      } else if ("result" in event) {
        if (!event.walletAddress) {
          const error2 = new WalletKitError(ERROR_CODES.WALLET_REQUIRED, "Wallet is required for connect approval result", void 0, { eventId: event.id });
          throw error2;
        }
        const wallet = this.walletManager.getWallet(event.walletAddress);
        if (!wallet) {
          const error2 = new WalletKitError(ERROR_CODES.WALLET_NOT_FOUND, "Wallet not found for connect approval result", void 0, { walletAddress: event.walletAddress, eventId: event.id });
          throw error2;
        }
        const url = new URL(event.result.dAppUrl);
        const domain = url.hostname;
        await this.sessionManager.createSession(event.from || (await distExports$1.getSecureRandomBytes(32)).toString("hex"), event.result.dAppName, domain, event.result.dAppIconUrl, event.result.dAppDescription, wallet);
        await this.bridgeManager.sendResponse(event, event.result.response);
        this.analyticsApi?.sendEvents([
          {
            event_name: "wallet-connect-accepted",
            trace_id: event.traceId,
            client_environment: "wallet",
            subsystem: getEventsSubsystem(),
            network_id: this.walletKitOptions.network,
            wallet_app_name: this.walletKitOptions.deviceInfo?.appName,
            wallet_app_version: this.walletKitOptions.deviceInfo?.appVersion,
            event_id: uuidv7(),
            client_id: event.from,
            is_ton_addr: event.result.response.payload.items.some((item) => item.name === "ton_addr"),
            is_ton_proof: event.result.response.payload.items.some((item) => item.name === "ton_proof"),
            manifest_json_url: event.result.dAppUrl,
            proof_payload_size: event.result.response.payload.items.find((item) => item.name === "ton_proof")?.proof?.payload?.length,
            client_timestamp: getUnixtime(),
            version: getVersion(),
            dapp_name: event.result.dAppName,
            origin_url: event.result.dAppUrl
          },
          {
            event_name: "wallet-connect-response-sent",
            trace_id: event.traceId,
            client_environment: "wallet",
            subsystem: getEventsSubsystem(),
            client_id: event.from,
            client_timestamp: getUnixtime(),
            version: getVersion(),
            dapp_name: event.result.dAppName,
            origin_url: event.result.dAppUrl,
            is_ton_addr: event.result.response.payload.items.some((item) => item.name === "ton_addr"),
            is_ton_proof: event.result.response.payload.items.some((item) => item.name === "ton_proof"),
            manifest_json_url: event.result.dAppUrl,
            proof_payload_size: event.result.response.payload.items.find((item) => item.name === "ton_proof")?.proof?.payload?.length,
            event_id: uuidv7(),
            network_id: this.walletKitOptions.network,
            wallet_app_name: this.walletKitOptions.deviceInfo?.appName,
            wallet_app_version: this.walletKitOptions.deviceInfo?.appVersion
          }
        ]);
      } else {
        log$a.error("Invalid event", { event });
        const error2 = new WalletKitError(ERROR_CODES.INVALID_REQUEST_EVENT, "Invalid connect request event", void 0, { event });
        throw error2;
      }
      return;
    } catch (error2) {
      log$a.error("Failed to approve connect request", { error: error2 });
      throw error2;
    }
  }
  /**
   * Process connect request rejection
   */
  async rejectConnectRequest(event, reason) {
    try {
      log$a.info("Connect request rejected", {
        id: event.id,
        dAppName: event.preview.manifest?.name || "",
        reason: reason || "User rejected connection"
      });
      const response = {
        event: "connect_error",
        id: parseInt(event.id || ""),
        payload: {
          code: CONNECT_EVENT_ERROR_CODES.USER_REJECTS_ERROR,
          message: reason || "User rejected connection"
        }
      };
      const newSession = await this.sessionManager.createSession(event.from || "", event.preview.manifest?.name || "", "", "", "", void 0, {
        disablePersist: true
      });
      await this.bridgeManager.sendResponse(event, response, newSession);
      this.analyticsApi?.sendEvents([
        {
          event_name: "wallet-connect-rejected",
          trace_id: event.traceId,
          client_environment: "wallet",
          subsystem: getEventsSubsystem(),
          dapp_name: event.preview.manifest?.name || "",
          origin_url: event.preview.manifest?.url || "",
          manifest_json_url: event.preview.manifest?.url || "",
          event_id: uuidv7(),
          client_timestamp: getUnixtime(),
          version: getVersion(),
          network_id: this.walletKitOptions.network,
          wallet_app_name: this.walletKitOptions.deviceInfo?.appName,
          wallet_app_version: this.walletKitOptions.deviceInfo?.appVersion,
          is_ton_addr: event.request.some((item) => item.name === "ton_addr"),
          is_ton_proof: event.request.some((item) => item.name === "ton_proof"),
          proof_payload_size: event.request.find((item) => item.name === "ton_proof")?.payload?.length,
          client_id: event.from
        },
        {
          event_name: "wallet-connect-response-sent",
          trace_id: event.traceId,
          client_environment: "wallet",
          subsystem: getEventsSubsystem(),
          dapp_name: event.preview.manifest?.name || "",
          origin_url: event.preview.manifest?.url || "",
          manifest_json_url: event.preview.manifest?.url || "",
          event_id: uuidv7(),
          client_timestamp: getUnixtime(),
          version: getVersion(),
          network_id: this.walletKitOptions.network,
          wallet_app_name: this.walletKitOptions.deviceInfo?.appName,
          wallet_app_version: this.walletKitOptions.deviceInfo?.appVersion,
          is_ton_addr: event.request.some((item) => item.name === "ton_addr"),
          is_ton_proof: event.request.some((item) => item.name === "ton_proof"),
          proof_payload_size: event.request.find((item) => item.name === "ton_proof")?.payload?.length,
          client_id: event.from
        }
      ]);
      return;
    } catch (error2) {
      log$a.error("Failed to reject connect request", { error: error2 });
      throw error2;
    }
  }
  /**
   * Process transaction request approval
   */
  async approveTransactionRequest(event) {
    try {
      if ("result" in event) {
        if (!this.walletKitOptions.dev?.disableNetworkSend) {
          await CallForSuccess(() => this.client.sendBoc(Buffer.from(event.result.signedBoc, "base64")));
        }
        const response = {
          result: event.result.signedBoc,
          id: event.id || ""
        };
        await this.bridgeManager.sendResponse(event, response);
        this.analyticsApi?.sendEvents([
          {
            event_name: "wallet-transaction-accepted",
            trace_id: event.traceId,
            client_environment: "wallet",
            subsystem: getEventsSubsystem(),
            event_id: uuidv7(),
            client_timestamp: getUnixtime(),
            version: getVersion(),
            network_id: this.walletKitOptions.network,
            wallet_app_name: this.walletKitOptions.deviceInfo?.appName,
            wallet_app_version: this.walletKitOptions.deviceInfo?.appVersion,
            client_id: event.from,
            wallet_id: Base64Normalize(event.walletAddress)
          },
          {
            event_name: "wallet-transaction-sent",
            trace_id: event.traceId,
            client_environment: "wallet",
            subsystem: getEventsSubsystem()
          }
        ]);
        return { signedBoc: event.result.signedBoc };
      } else {
        const signedBoc = await this.signTransaction(event);
        if (!this.walletKitOptions.dev?.disableNetworkSend) {
          await CallForSuccess(() => this.client.sendBoc(Buffer.from(signedBoc, "base64")));
        }
        const response = {
          result: signedBoc,
          id: event.id || ""
        };
        await this.bridgeManager.sendResponse(event, response);
        this.analyticsApi?.sendEvents([
          {
            event_name: "wallet-transaction-accepted",
            trace_id: event.traceId,
            client_environment: "wallet",
            subsystem: getEventsSubsystem(),
            dapp_name: event.dAppInfo?.name,
            origin_url: event.dAppInfo?.url,
            event_id: uuidv7(),
            network_id: this.walletKitOptions.network,
            wallet_app_name: this.walletKitOptions.deviceInfo?.appName,
            wallet_app_version: this.walletKitOptions.deviceInfo?.appVersion,
            wallet_id: event.walletAddress ? Base64Normalize(event.walletAddress) : void 0,
            version: getVersion(),
            client_timestamp: getUnixtime(),
            client_id: event.from
          },
          {
            event_name: "wallet-transaction-sent",
            trace_id: event.traceId,
            client_environment: "wallet",
            subsystem: getEventsSubsystem(),
            event_id: uuidv7(),
            network_id: this.walletKitOptions.network,
            wallet_app_name: this.walletKitOptions.deviceInfo?.appName,
            wallet_app_version: this.walletKitOptions.deviceInfo?.appVersion,
            version: getVersion(),
            client_timestamp: getUnixtime(),
            client_id: event.from,
            signed_boc: signedBoc
            // error_code events todo
            // error_message events todo
            // normalized_hash events todo
          }
        ]);
        return { signedBoc };
      }
    } catch (error2) {
      log$a.error("Failed to approve transaction request", { error: error2 });
      if (error2 instanceof WalletKitError) {
        throw error2;
      }
      if (error2?.message?.includes("Ledger device")) {
        throw new WalletKitError(ERROR_CODES.LEDGER_DEVICE_ERROR, "Ledger device error", error2);
      }
      throw error2;
    }
  }
  /**
   * Process transaction request rejection
   */
  async rejectTransactionRequest(event, reason) {
    try {
      const response = typeof reason === "string" || typeof reason === "undefined" ? {
        error: {
          code: SEND_TRANSACTION_ERROR_CODES.USER_REJECTS_ERROR,
          message: reason || "User rejected transaction"
        },
        id: event.id
      } : {
        error: reason,
        id: event.id
      };
      await this.bridgeManager.sendResponse(event, response);
      this.analyticsApi?.sendEvents([
        {
          event_name: "wallet-transaction-declined",
          trace_id: event.traceId,
          client_environment: "wallet",
          subsystem: getEventsSubsystem(),
          dapp_name: event.dAppInfo?.name,
          origin_url: event.dAppInfo?.url,
          event_id: uuidv7(),
          network_id: this.walletKitOptions.network,
          wallet_app_name: this.walletKitOptions.deviceInfo?.appName,
          wallet_app_version: this.walletKitOptions.deviceInfo?.appVersion,
          wallet_id: event.walletAddress ? Base64Normalize(event.walletAddress) : void 0,
          version: getVersion(),
          client_timestamp: getUnixtime(),
          client_id: event.from
        }
      ]);
      return;
    } catch (error2) {
      log$a.error("Failed to reject transaction request", { error: error2 });
      throw error2;
    }
  }
  /**
   * Process sign data request approval
   */
  async approveSignDataRequest(event) {
    try {
      if ("result" in event) {
        const response = {
          id: event.id || "",
          result: {
            signature: event.result.signature,
            address: event.result.address,
            timestamp: event.result.timestamp,
            domain: event.result.domain,
            payload: event.result.payload
          }
        };
        await this.bridgeManager.sendResponse(event, response);
        this.analyticsApi?.sendEvents([
          {
            event_name: "wallet-sign-data-accepted",
            trace_id: event.traceId,
            client_environment: "wallet",
            subsystem: getEventsSubsystem(),
            event_id: uuidv7(),
            network_id: this.walletKitOptions.network,
            wallet_app_name: this.walletKitOptions.deviceInfo?.appName,
            wallet_app_version: this.walletKitOptions.deviceInfo?.appVersion,
            wallet_id: event.walletAddress ? Base64Normalize(event.walletAddress) : void 0,
            version: getVersion(),
            client_timestamp: getUnixtime(),
            client_id: event.from
          },
          {
            event_name: "wallet-sign-data-sent",
            trace_id: event.traceId,
            client_environment: "wallet",
            subsystem: getEventsSubsystem(),
            event_id: uuidv7(),
            network_id: this.walletKitOptions.network,
            wallet_app_name: this.walletKitOptions.deviceInfo?.appName,
            wallet_app_version: this.walletKitOptions.deviceInfo?.appVersion,
            wallet_id: event.walletAddress ? Base64Normalize(event.walletAddress) : void 0,
            version: getVersion(),
            client_timestamp: getUnixtime(),
            client_id: event.from
          }
        ]);
        return { signature: asHex(event.result.signature) };
      } else {
        if (!event.domain) {
          const error2 = new WalletKitError(ERROR_CODES.SESSION_DOMAIN_REQUIRED, "Domain is required for sign data request", void 0, { eventId: event.id });
          throw error2;
        }
        if (!event.walletAddress) {
          const error2 = new WalletKitError(ERROR_CODES.WALLET_REQUIRED, "Wallet address is required for sign data request", void 0, { eventId: event.id });
          throw error2;
        }
        const wallet = this.walletManager.getWallet(event.walletAddress);
        if (!wallet) {
          const error2 = new WalletKitError(ERROR_CODES.WALLET_NOT_FOUND, "Wallet not found for sign data request", void 0, { walletAddress: event.walletAddress, eventId: event.id });
          throw error2;
        }
        const signData = PrepareTonConnectData({
          payload: event.request,
          domain: event.domain,
          address: event.walletAddress
        });
        const signature = await wallet.getSignedSignData(signData);
        const signatureBase64 = Buffer.from(signature.slice(2), "hex").toString("base64");
        const response = {
          id: event.id,
          result: {
            signature: signatureBase64,
            address: distExports$3.Address.parse(signData.address).toRawString(),
            timestamp: signData.timestamp,
            domain: signData.domain,
            payload: signData.payload
          }
        };
        await this.bridgeManager.sendResponse(event, response);
        this.analyticsApi?.sendEvents([
          {
            event_name: "wallet-sign-data-accepted",
            trace_id: event.traceId,
            client_environment: "wallet",
            subsystem: getEventsSubsystem(),
            dapp_name: event.dAppInfo?.name,
            origin_url: event.dAppInfo?.url,
            event_id: uuidv7(),
            network_id: this.walletKitOptions.network,
            wallet_app_name: this.walletKitOptions.deviceInfo?.appName,
            wallet_app_version: this.walletKitOptions.deviceInfo?.appVersion,
            wallet_id: event.walletAddress ? Base64Normalize(event.walletAddress) : void 0,
            version: getVersion(),
            client_timestamp: getUnixtime(),
            client_id: event.from
          },
          {
            event_name: "wallet-sign-data-sent",
            trace_id: event.traceId,
            client_environment: "wallet",
            subsystem: getEventsSubsystem(),
            dapp_name: event.dAppInfo?.name,
            origin_url: event.dAppInfo?.url,
            event_id: uuidv7(),
            network_id: this.walletKitOptions.network,
            wallet_app_name: this.walletKitOptions.deviceInfo?.appName,
            wallet_app_version: this.walletKitOptions.deviceInfo?.appVersion,
            wallet_id: event.walletAddress ? Base64Normalize(event.walletAddress) : void 0,
            version: getVersion(),
            client_timestamp: getUnixtime(),
            client_id: event.from
          }
        ]);
        return { signature: asHex(signature) };
      }
    } catch (error2) {
      log$a.error("Failed to approve sign data request", {
        error: error2?.message?.toString() ?? error2?.toString()
      });
      if (error2 instanceof WalletKitError) {
        throw error2;
      }
      throw error2;
    }
  }
  /**
   * Process sign data request rejection
   */
  async rejectSignDataRequest(event, reason) {
    try {
      const response = {
        error: "USER_REJECTED",
        reason: reason || "User rejected data signing"
      };
      await this.bridgeManager.sendResponse(event, response);
      this.analyticsApi?.sendEvents([
        {
          event_name: "wallet-sign-data-declined",
          trace_id: event.traceId,
          client_environment: "wallet",
          subsystem: getEventsSubsystem(),
          dapp_name: event.dAppInfo?.name,
          origin_url: event.dAppInfo?.url,
          event_id: uuidv7(),
          network_id: this.walletKitOptions.network,
          wallet_app_name: this.walletKitOptions.deviceInfo?.appName,
          wallet_app_version: this.walletKitOptions.deviceInfo?.appVersion,
          wallet_id: event.walletAddress ? Base64Normalize(event.walletAddress) : void 0,
          version: getVersion(),
          client_timestamp: getUnixtime(),
          client_id: event.from
        }
      ]);
      return;
    } catch (error2) {
      log$a.error("Failed to reject sign data request", { error: error2 });
      throw error2;
    }
  }
  /**
   * Create connect approval response
   */
  async createConnectApprovalResponse(event) {
    const walletAddress = event.walletAddress;
    if (!walletAddress) {
      throw new WalletKitError(ERROR_CODES.WALLET_REQUIRED, "Wallet address is required for connect approval response", void 0, { eventId: event.id });
    }
    const wallet = this.walletManager.getWallet(walletAddress);
    if (!wallet) {
      throw new WalletKitError(ERROR_CODES.WALLET_NOT_FOUND, "Wallet not found for connect approval response", void 0, { walletAddress, eventId: event.id });
    }
    const walletStateInit = await wallet.getStateInit();
    const publicKey = wallet.publicKey.replace("0x", "");
    const address = wallet.getAddress();
    const connectResponse = {
      event: "connect",
      id: Date.now(),
      payload: {
        device: getDeviceInfoWithDefaults(this.walletKitOptions.deviceInfo),
        items: [
          {
            name: "ton_addr",
            address: distExports$3.Address.parse(address).toRawString(),
            network: this.network,
            walletStateInit,
            publicKey
          }
        ]
      }
    };
    const proofItem = event.request.find((item) => item.name === "ton_proof");
    if (proofItem) {
      let domain = {
        lengthBytes: 0,
        value: ""
      };
      try {
        const dAppUrl = new URL(event.preview.manifest?.url || "");
        domain = {
          lengthBytes: Buffer.from(dAppUrl.host).length,
          value: dAppUrl.host
        };
      } catch (error2) {
        log$a.error("Failed to parse domain", { error: error2 });
      }
      const timestamp = Math.floor(Date.now() / 1e3);
      const signMessage = createTonProofMessage({
        address: distExports$3.Address.parse(address),
        domain,
        payload: proofItem.payload,
        stateInit: walletStateInit,
        timestamp
      });
      const signature = await wallet.getSignedTonProof(signMessage);
      const signatureBase64 = Buffer.from(signature.slice(2), "hex").toString("base64");
      connectResponse.payload.items.push({
        name: "ton_proof",
        proof: {
          timestamp,
          domain: {
            lengthBytes: domain.lengthBytes,
            value: domain.value
          },
          payload: proofItem.payload,
          signature: signatureBase64
        }
      });
    }
    return {
      result: connectResponse
    };
  }
  /**
   * Sign transaction and return BOC
   */
  async signTransaction(event) {
    if (!event.walletAddress) {
      throw new WalletKitError(ERROR_CODES.WALLET_REQUIRED, "Wallet address is required for transaction signing", void 0, { eventId: event.id });
    }
    const wallet = this.walletManager.getWallet(event.walletAddress);
    if (!wallet) {
      throw new WalletKitError(ERROR_CODES.WALLET_NOT_FOUND, "Wallet not found for transaction signing", void 0, { walletAddress: event.walletAddress, eventId: event.id });
    }
    const signedBoc = await wallet.getSignedSendTransaction(event.request, {
      fakeSignature: false
    });
    log$a.debug("Signing transaction", {
      id: event.id,
      messagesCount: event.request.messages.length,
      from: event.request.from,
      validUntil: event.request.valid_until
    });
    return signedBoc;
  }
}
const getEventUUID = () => {
  return crypto.randomUUID();
};
const log$9 = globalLogger.createChild("EventStore");
const MAX_EVENT_SIZE_BYTES = 100 * 1024;
class StorageEventStore {
  storageAdapter;
  storageKey = "durable_events";
  operationLock = /* @__PURE__ */ new Map();
  constructor(storageAdapter) {
    this.storageAdapter = storageAdapter;
  }
  /**
   * Store a new event from the bridge
   */
  async storeEvent(_rawEvent) {
    const rawEvent = { ..._rawEvent, wallet: void 0 };
    const validation = validateBridgeEvent(rawEvent);
    if (!validation.isValid) {
      throw new Error(`Invalid bridge event: ${validation.errors.join(", ")}`);
    }
    const eventStr = JSON.stringify(rawEvent);
    const sizeBytes = new TextEncoder().encode(eventStr).length;
    if (sizeBytes > MAX_EVENT_SIZE_BYTES) {
      throw new Error(`Event too large: ${sizeBytes} bytes (max: ${MAX_EVENT_SIZE_BYTES})`);
    }
    const eventType = this.extractEventType(rawEvent.method);
    const storedEvent = {
      id: getEventUUID(),
      sessionId: rawEvent.from,
      eventType,
      rawEvent,
      status: "new",
      createdAt: Date.now(),
      sizeBytes
    };
    await this.saveEvent(storedEvent);
    log$9.info("Event stored", {
      eventId: storedEvent.id,
      eventType,
      sizeBytes,
      sessionId: rawEvent.from
    });
    return storedEvent;
  }
  /**
   * Get events for a wallet that are ready for processing
   */
  async getEventsForWallet(_walletAddress, sessionIds, eventTypes) {
    const events = await this.getAllEvents();
    return events.filter((event) => (
      // Only new events
      event.status === "new" && // Must match one of the session IDs
      event.sessionId && sessionIds.includes(event.sessionId) && // Must be one of the requested event types
      eventTypes.includes(event.eventType)
    )).sort((a2, b2) => a2.createdAt - b2.createdAt);
  }
  /**
   * Get events that don't require a wallet or session (e.g., connect events)
   */
  async getNoWalletEvents(eventTypes) {
    const events = await this.getAllEvents();
    return events.filter((event) => (
      // Only new events
      event.status === "new" && // Must be one of the requested event types
      eventTypes.includes(event.eventType)
    )).sort((a2, b2) => a2.createdAt - b2.createdAt);
  }
  /**
   * Attempt to acquire exclusive lock on an event for processing
   */
  async acquireLock(eventId, walletAddress) {
    return this.withLock("storage", async () => {
      const allEvents = await this.getAllEventsFromStorage();
      const event = allEvents[eventId];
      if (!event) {
        log$9.warn("Cannot lock non-existent event", { eventId });
        return void 0;
      }
      if (event.status !== "new") {
        log$9.debug("Cannot lock event - not in new status", {
          eventId,
          status: event.status,
          lockedBy: event.lockedBy
        });
        return void 0;
      }
      const updatedEvent = {
        ...event,
        status: "processing",
        processingStartedAt: Date.now(),
        lockedBy: walletAddress
      };
      allEvents[eventId] = updatedEvent;
      await this.storageAdapter.set(this.storageKey, allEvents);
      log$9.debug("Event lock acquired", { eventId, walletAddress });
      return updatedEvent;
    });
  }
  /**
   * Update event status and timestamps with optimistic locking
   */
  async updateEventStatus(eventId, status, oldStatus) {
    return this.withLock("storage", async () => {
      const allEvents = await this.getAllEventsFromStorage();
      const event = allEvents[eventId];
      if (!event) {
        throw new Error(`Event not found: ${eventId}`);
      }
      if (event.status !== oldStatus) {
        throw new Error(`Event status mismatch: expected '${oldStatus}', but current status is '${event.status}'`);
      }
      const updatedEvent = {
        ...event,
        status
      };
      if (status === "completed") {
        updatedEvent.completedAt = Date.now();
      }
      allEvents[eventId] = updatedEvent;
      await this.storageAdapter.set(this.storageKey, allEvents);
      log$9.debug("Event status updated", { eventId, oldStatus, newStatus: status });
      return updatedEvent;
    });
  }
  /**
   * Get event by ID
   */
  async getEvent(eventId) {
    try {
      const allEvents = await this.getAllEventsFromStorage();
      return allEvents[eventId] || null;
    } catch (error2) {
      log$9.warn("Failed to get event", { eventId, error: error2 });
      return null;
    }
  }
  /**
   * Recover stale events that have been processing too long
   */
  async recoverStaleEvents(processingTimeoutMs) {
    const events = await this.getAllEvents();
    const now = Date.now();
    let recoveredCount = 0;
    for (const event of events) {
      if (event.status === "processing" && event.processingStartedAt && now - event.processingStartedAt > processingTimeoutMs) {
        const recoveredEvent = {
          ...event,
          status: "new",
          processingStartedAt: void 0,
          lockedBy: void 0
        };
        await this.saveEvent(recoveredEvent);
        recoveredCount++;
        log$9.info("Recovered stale event", {
          eventId: event.id,
          lockedBy: event.lockedBy,
          staleMinutes: Math.round((now - event.processingStartedAt) / 6e4)
        });
      }
    }
    if (recoveredCount > 0) {
      log$9.info("Event recovery completed", { recoveredCount });
    }
    return recoveredCount;
  }
  /**
   * Clean up old completed events
   */
  async cleanupOldEvents(retentionMs) {
    const events = await this.getAllEvents();
    const cutoffTime = Date.now() - retentionMs;
    let cleanedUpCount = 0;
    const eventsToRemove = [];
    for (const event of events) {
      if (event.status === "completed" && event.completedAt && event.completedAt < cutoffTime) {
        eventsToRemove.push(event.id);
        log$9.debug("Marked event for cleanup", { eventId: event.id });
      }
    }
    if (eventsToRemove.length > 0) {
      await this.withLock("storage", async () => {
        const allEvents = await this.getAllEventsFromStorage();
        for (const eventId of eventsToRemove) {
          delete allEvents[eventId];
          cleanedUpCount++;
        }
        await this.storageAdapter.set(this.storageKey, allEvents);
      });
      log$9.info("Event cleanup completed", { cleanedUpCount });
    }
    return cleanedUpCount;
  }
  /**
   * Get all events (for debugging and internal operations)
   */
  async getAllEvents() {
    try {
      const allEvents = await this.getAllEventsFromStorage();
      return Object.values(allEvents);
    } catch (error2) {
      log$9.warn("Failed to get all events", { error: error2 });
      return [];
    }
  }
  // Private helper methods
  async withLock(lockKey, operation) {
    const existingLock = this.operationLock.get(lockKey);
    if (existingLock) {
      await existingLock;
    }
    const operationPromise = operation();
    this.operationLock.set(lockKey, operationPromise.then(() => {
    }, () => {
    }));
    try {
      const result = await operationPromise;
      this.operationLock.delete(lockKey);
      return result;
    } catch (error2) {
      this.operationLock.delete(lockKey);
      throw error2;
    }
  }
  async getAllEventsFromStorage() {
    try {
      const eventsData = await this.storageAdapter.get(this.storageKey);
      return eventsData || {};
    } catch (error2) {
      log$9.warn("Failed to get events from storage", { error: error2 });
      return {};
    }
  }
  async saveEvent(event) {
    return this.withLock("storage", async () => {
      const allEvents = await this.getAllEventsFromStorage();
      allEvents[event.id] = event;
      await this.storageAdapter.set(this.storageKey, allEvents);
    });
  }
  async removeEvent(eventId) {
    return this.withLock("storage", async () => {
      const allEvents = await this.getAllEventsFromStorage();
      delete allEvents[eventId];
      await this.storageAdapter.set(this.storageKey, allEvents);
    });
  }
  extractEventType(method) {
    switch (method) {
      case "connect":
        return "connect";
      case "sendTransaction":
        return "sendTransaction";
      case "signData":
        return "signData";
      case "disconnect":
        return "disconnect";
      case "restoreConnection":
        return "restoreConnection";
      default:
        throw new Error(`Unknown event method: ${method}`);
    }
  }
}
const log$8 = globalLogger.createChild("EventProcessor");
class StorageEventProcessor {
  eventStore;
  config;
  walletManager;
  sessionManager;
  eventRouter;
  eventEmitter;
  // Active processing loops per wallet
  processingLoops = /* @__PURE__ */ new Map();
  // Wake-up promises for processing loops
  wakeUpResolvers = /* @__PURE__ */ new Map();
  // No-wallet processing loop state
  noWalletProcessing = false;
  noWalletWakeUpResolver;
  // Recovery and cleanup timeouts
  recoveryTimeoutId;
  cleanupTimeoutId;
  processorConfig;
  constructor(processorConfig = {}, eventStore, config, walletManager, sessionManager, eventRouter, eventEmitter) {
    this.processorConfig = processorConfig;
    this.eventStore = eventStore;
    this.config = config;
    this.walletManager = walletManager;
    this.sessionManager = sessionManager;
    this.eventRouter = eventRouter;
    this.eventEmitter = eventEmitter;
    if (this.processorConfig.disableEvents) {
      return;
    }
    this.eventEmitter.on("bridge-storage-updated", () => {
      this.triggerProcessingForAllWallets();
      this.triggerNoWalletProcessing();
    });
  }
  /**
   * Start processing events for a wallet
   */
  async startProcessing(walletAddress) {
    if (this.processorConfig.disableEvents) {
      return;
    }
    if (this.processingLoops.get(walletAddress)) {
      log$8.debug("Processing already active for wallet", { walletAddress });
      return;
    }
    this.processingLoops.set(walletAddress, true);
    log$8.info("Started event processing for wallet", { walletAddress });
    this.processEventsLoop(walletAddress);
  }
  /**
   * Stop processing events for a wallet
   */
  async stopProcessing(walletAddress) {
    if (this.processorConfig.disableEvents) {
      return;
    }
    this.processingLoops.set(walletAddress, false);
    const wakeUpResolver = this.wakeUpResolvers.get(walletAddress);
    if (wakeUpResolver) {
      wakeUpResolver();
      this.wakeUpResolvers.delete(walletAddress);
    }
    log$8.info("Stopped event processing for wallet", { walletAddress });
  }
  /**
   * Start processing events that don't require a wallet (e.g., connect events)
   */
  async startNoWalletProcessing() {
    if (this.processorConfig.disableEvents) {
      return;
    }
    if (this.noWalletProcessing) {
      log$8.debug("No-wallet processing already active");
      return;
    }
    this.noWalletProcessing = true;
    log$8.info("Started no-wallet event processing");
    this.processNoWalletEventsLoop();
  }
  /**
   * Stop processing events that don't require a wallet
   */
  async stopNoWalletProcessing() {
    if (this.processorConfig.disableEvents) {
      return;
    }
    this.noWalletProcessing = false;
    if (this.noWalletWakeUpResolver) {
      this.noWalletWakeUpResolver();
      this.noWalletWakeUpResolver = void 0;
    }
    log$8.info("Stopped no-wallet event processing");
  }
  /**
   * Process next available event for a wallet
   */
  async processNextEvent(walletAddress) {
    try {
      const sessions = this.sessionManager.getSessionsForAPI().filter((session) => session.walletAddress === walletAddress);
      if (sessions.length === 0) {
        log$8.debug("No active sessions for wallet", { walletAddress });
        return false;
      }
      const sessionIds = sessions.map((session) => session.sessionId);
      const enabledEventTypes = this.getEnabledEventTypes();
      const events = await this.eventStore.getEventsForWallet(walletAddress, sessionIds, enabledEventTypes);
      if (events.length === 0) {
        return false;
      }
      const eventToUse = events[0];
      const acquiredEvent = await this.eventStore.acquireLock(eventToUse.id, walletAddress);
      if (!acquiredEvent) {
        log$8.debug("Failed to acquire lock on event", { eventId: eventToUse.id, walletAddress });
        return false;
      }
      log$8.info("Processing event", {
        eventId: acquiredEvent.id,
        eventType: acquiredEvent.eventType,
        walletAddress,
        sessionId: acquiredEvent.sessionId
      });
      try {
        await this.eventRouter.routeEvent({
          ...acquiredEvent.rawEvent,
          walletAddress
        });
        await this.eventStore.updateEventStatus(acquiredEvent.id, "completed", "processing");
        log$8.info("Event processing completed", { eventId: acquiredEvent.id });
        return true;
      } catch (error2) {
        log$8.error("Error processing event", {
          eventId: acquiredEvent.id,
          error: error2.message
        });
        return false;
      }
    } catch (error2) {
      log$8.error("Error in processNextEvent", {
        walletAddress,
        error: error2.message
      });
      return false;
    }
  }
  /**
   * Process next available event that doesn't require a wallet
   */
  async processNextNoWalletEvent() {
    try {
      const enabledEventTypes = this.getNoWalletEnabledEventTypes();
      const events = await this.eventStore.getNoWalletEvents(enabledEventTypes);
      if (events.length === 0) {
        return false;
      }
      const eventToUse = events[0];
      const acquiredEvent = await this.eventStore.acquireLock(eventToUse.id, eventToUse?.rawEvent?.walletAddress || "no-wallet");
      if (!acquiredEvent) {
        log$8.debug("Failed to acquire lock on no-wallet event", { eventId: eventToUse.id });
        return false;
      }
      log$8.info("Processing no-wallet event", {
        eventId: acquiredEvent.id,
        eventType: acquiredEvent.eventType,
        sessionId: acquiredEvent.sessionId
      });
      try {
        await this.eventRouter.routeEvent({
          ...acquiredEvent.rawEvent
          // Don't set wallet for no-wallet events
        });
        await this.eventStore.updateEventStatus(acquiredEvent.id, "completed", "processing");
        log$8.info("No-wallet event processing completed", { eventId: acquiredEvent.id });
        return true;
      } catch (error2) {
        log$8.error("Error processing no-wallet event", {
          eventId: acquiredEvent.id,
          error: error2.message
        });
        return false;
      }
    } catch (error2) {
      log$8.error("Error in processNextNoWalletEvent", {
        error: error2.message
      });
      return false;
    }
  }
  /**
   * Mark an event as completed after successful processing
   */
  async completeEvent(eventId) {
    try {
      await this.eventStore.updateEventStatus(eventId, "completed", "processing");
      log$8.debug("Event marked as completed", { eventId });
    } catch (error2) {
      log$8.error("Failed to mark event as completed", {
        eventId,
        error: error2.message
      });
    }
  }
  /**
   * Start the recovery process for stale events
   */
  startRecoveryLoop() {
    if (this.recoveryTimeoutId) {
      log$8.debug("Recovery loop already running");
      return;
    }
    const recoveryLoop = async () => {
      try {
        const recoveredCount = await this.eventStore.recoverStaleEvents(this.config.processingTimeoutMs);
        if (recoveredCount > 0) {
          this.triggerProcessingForAllWallets();
        }
      } catch (error2) {
        log$8.error("Error in recovery loop", { error: error2.message });
      }
      if (this.recoveryTimeoutId !== void 0) {
        this.recoveryTimeoutId = setTimeout(recoveryLoop, this.config.recoveryIntervalMs);
      }
    };
    const cleanupLoop = async () => {
      try {
        await this.eventStore.cleanupOldEvents(this.config.retentionMs);
      } catch (error2) {
        log$8.error("Error in cleanup loop", { error: error2.message });
      }
      if (this.cleanupTimeoutId !== void 0) {
        this.cleanupTimeoutId = setTimeout(cleanupLoop, this.config.cleanupIntervalMs);
      }
    };
    this.recoveryTimeoutId = setTimeout(recoveryLoop, this.config.recoveryIntervalMs);
    this.cleanupTimeoutId = setTimeout(cleanupLoop, this.config.cleanupIntervalMs);
    log$8.info("Recovery and cleanup loops started");
  }
  /**
   * Stop the recovery process
   */
  stopRecoveryLoop() {
    if (this.recoveryTimeoutId) {
      clearTimeout(this.recoveryTimeoutId);
      this.recoveryTimeoutId = void 0;
    }
    if (this.cleanupTimeoutId) {
      clearTimeout(this.cleanupTimeoutId);
      this.cleanupTimeoutId = void 0;
    }
    log$8.info("Recovery and cleanup loops stopped");
  }
  // Private helper methods
  /**
   * Main processing loop for a wallet
   */
  async processEventsLoop(walletAddress) {
    while (this.processingLoops.get(walletAddress)) {
      try {
        const processed = await this.processNextEvent(walletAddress);
        if (!processed) {
          await this.waitForWakeUpOrTimeout(walletAddress, 1e3);
        }
      } catch (error2) {
        log$8.error("Error in processing loop", {
          walletAddress,
          error: error2.message
        });
        await this.waitForWakeUpOrTimeout(walletAddress, 5e3);
      }
    }
    this.wakeUpResolvers.delete(walletAddress);
    log$8.debug("Processing loop ended for wallet", { walletAddress });
  }
  /**
   * Main processing loop for no-wallet events
   */
  async processNoWalletEventsLoop() {
    while (this.noWalletProcessing) {
      try {
        const processed = await this.processNextNoWalletEvent();
        if (!processed) {
          await this.waitForNoWalletWakeUpOrTimeout(1e3);
        }
      } catch (error2) {
        log$8.error("Error in no-wallet processing loop", {
          error: error2.message
        });
        await this.waitForNoWalletWakeUpOrTimeout(5e3);
      }
    }
    this.noWalletWakeUpResolver = void 0;
    log$8.debug("No-wallet processing loop ended");
  }
  /**
   * Trigger processing for all active wallets
   */
  triggerProcessingForAllWallets() {
    for (const [walletAddress, isActive] of this.processingLoops.entries()) {
      if (isActive) {
        const wakeUpResolver = this.wakeUpResolvers.get(walletAddress);
        if (wakeUpResolver) {
          log$8.debug("Waking up processing loop for wallet", { walletAddress });
          wakeUpResolver();
        } else {
          log$8.debug("No wake-up resolver found for wallet", { walletAddress });
        }
      }
    }
  }
  /**
   * Trigger processing for no-wallet events
   */
  triggerNoWalletProcessing() {
    if (this.noWalletProcessing && this.noWalletWakeUpResolver) {
      log$8.debug("Waking up no-wallet processing loop");
      this.noWalletWakeUpResolver();
    }
  }
  /**
   * Wait for either a wake-up signal or timeout
   */
  async waitForWakeUpOrTimeout(walletAddress, timeoutMs) {
    return new Promise((resolve) => {
      const timeoutId = setTimeout(() => {
        this.wakeUpResolvers.delete(walletAddress);
        resolve();
      }, timeoutMs);
      const wakeUpResolver = () => {
        clearTimeout(timeoutId);
        this.wakeUpResolvers.delete(walletAddress);
        resolve();
      };
      this.wakeUpResolvers.set(walletAddress, wakeUpResolver);
    });
  }
  /**
   * Wait for either a wake-up signal or timeout for no-wallet processing
   */
  async waitForNoWalletWakeUpOrTimeout(timeoutMs) {
    return new Promise((resolve) => {
      const timeoutId = setTimeout(() => {
        this.noWalletWakeUpResolver = void 0;
        resolve();
      }, timeoutMs);
      const wakeUpResolver = () => {
        clearTimeout(timeoutId);
        this.noWalletWakeUpResolver = void 0;
        resolve();
      };
      this.noWalletWakeUpResolver = wakeUpResolver;
    });
  }
  /**
   * Get enabled event types based on registered handlers in EventRouter
   */
  getEnabledEventTypes() {
    return this.eventRouter.getEnabledEventTypes();
  }
  /**
   * Get enabled event types for no-wallet processing (currently only connect)
   */
  getNoWalletEnabledEventTypes() {
    const enabledTypes = this.eventRouter.getEnabledEventTypes();
    return enabledTypes.filter((type) => type === "connect" || type === "restoreConnection").concat(["restoreConnection"]);
  }
}
const ERROR_MESSAGES = {
  // Bridge Manager Errors (7000-7099)
  [ERROR_CODES.BRIDGE_NOT_INITIALIZED]: "Bridge not initialized",
  [ERROR_CODES.BRIDGE_CONNECTION_FAILED]: "Bridge connection failed",
  [ERROR_CODES.BRIDGE_EVENT_PROCESSING_FAILED]: "Bridge event processing failed",
  [ERROR_CODES.BRIDGE_RESPONSE_SEND_FAILED]: "Bridge response send failed",
  // Session Errors (7100-7199)
  [ERROR_CODES.SESSION_NOT_FOUND]: "Session not found",
  [ERROR_CODES.SESSION_ID_REQUIRED]: "Session ID required",
  [ERROR_CODES.SESSION_CREATION_FAILED]: "Session creation failed",
  [ERROR_CODES.SESSION_DOMAIN_REQUIRED]: "Session domain required",
  [ERROR_CODES.SESSION_RESTORATION_FAILED]: "Session restoration failed",
  // Event Store Errors (7200-7299)
  [ERROR_CODES.EVENT_STORE_NOT_INITIALIZED]: "Event store not initialized",
  [ERROR_CODES.EVENT_STORE_OPERATION_FAILED]: "Event store operation failed",
  // Storage Errors (7300-7399)
  [ERROR_CODES.STORAGE_READ_FAILED]: "Storage read failed",
  [ERROR_CODES.STORAGE_WRITE_FAILED]: "Storage write failed",
  // Wallet Errors (7400-7499)
  [ERROR_CODES.WALLET_NOT_FOUND]: "Wallet not found",
  [ERROR_CODES.WALLET_REQUIRED]: "Wallet required",
  [ERROR_CODES.WALLET_INVALID]: "Wallet invalid",
  [ERROR_CODES.WALLET_CREATION_FAILED]: "Wallet creation failed",
  [ERROR_CODES.WALLET_INITIALIZATION_FAILED]: "Wallet initialization failed",
  [ERROR_CODES.LEDGER_DEVICE_ERROR]: "Ledger device error",
  // Request Processing Errors (7500-7599)
  [ERROR_CODES.INVALID_REQUEST_EVENT]: "Invalid request event",
  [ERROR_CODES.REQUEST_PROCESSING_FAILED]: "Request processing failed",
  [ERROR_CODES.RESPONSE_CREATION_FAILED]: "Response creation failed",
  [ERROR_CODES.APPROVAL_FAILED]: "Approval failed",
  [ERROR_CODES.REJECTION_FAILED]: "Rejection failed",
  // API Client Errors (7600-7699)
  [ERROR_CODES.API_CLIENT_ERROR]: "Api client error",
  [ERROR_CODES.TON_CLIENT_INITIALIZATION_FAILED]: "Ton client initialization failed",
  [ERROR_CODES.API_REQUEST_FAILED]: "Api request failed",
  [ERROR_CODES.ACCOUNT_NOT_FOUND]: "Account not found",
  // Jetton/NFT Errors (7700-7799)
  [ERROR_CODES.JETTONS_MANAGER_ERROR]: "Jetton manager error",
  [ERROR_CODES.NFT_MANAGER_ERROR]: "NFT manager error",
  // Contract Errors (7800-7899)
  [ERROR_CODES.CONTRACT_DEPLOYMENT_FAILED]: "Contract deployment failed",
  [ERROR_CODES.CONTRACT_EXECUTION_FAILED]: "Contract execution failed",
  [ERROR_CODES.CONTRACT_VALIDATION_FAILED]: "Contract validation failed",
  // Generic Errors (7900-7999)
  [ERROR_CODES.UNKNOWN_ERROR]: "Unknown error",
  [ERROR_CODES.VALIDATION_ERROR]: "Validation error",
  [ERROR_CODES.INITIALIZATION_ERROR]: "Initialization error",
  [ERROR_CODES.CONFIGURATION_ERROR]: "Configuration error",
  [ERROR_CODES.NETWORK_ERROR]: "Network error",
  [ERROR_CODES.UNKNOWN_EMULATION_ERROR]: "Unknown emulation error"
};
function createErrorInfo(code, message, data) {
  return {
    code,
    message: message || ERROR_MESSAGES[code] || "Unknown error",
    data
  };
}
class WalletTonClass {
  client;
  constructor(client) {
    this.client = client;
  }
  async createTransferTonTransaction(param) {
    let messages = [];
    if (!isValidAddress(param.toAddress)) {
      throw new Error(`Invalid to address: ${param.toAddress}`);
    }
    if (!isValidNanotonAmount(param.amount)) {
      throw new Error(`Invalid amount: ${param.amount}`);
    }
    let body;
    if (param.body) {
      body = param.body;
    } else if (param.comment) {
      body = distExports$3.beginCell().storeUint(0, 32).storeStringTail(param.comment).endCell().toBoc().toString("base64");
    }
    const message = {
      address: param.toAddress,
      amount: param.amount,
      payload: body,
      stateInit: param.stateInit,
      extraCurrency: param.extraCurrency,
      mode: param.mode
    };
    if (!validateTransactionMessage(message, false).isValid) {
      throw new Error(`Invalid transaction message: ${JSON.stringify(message)}`);
    }
    messages.push(message);
    return {
      messages,
      from: this.getAddress()
    };
  }
  async createTransferMultiTonTransaction({ messages: params }) {
    let messages = [];
    for (const param of params) {
      if (!isValidAddress(param.toAddress)) {
        throw new Error(`Invalid to address: ${param.toAddress}`);
      }
      if (!isValidNanotonAmount(param.amount)) {
        throw new Error(`Invalid amount: ${param.amount}`);
      }
      let body;
      if (param.body) {
        body = param.body;
      } else if (param.comment) {
        body = distExports$3.beginCell().storeUint(0, 32).storeStringTail(param.comment).endCell().toBoc().toString("base64");
      }
      const message = {
        address: param.toAddress,
        amount: param.amount,
        payload: body,
        stateInit: param.stateInit,
        extraCurrency: param.extraCurrency,
        mode: param.mode
      };
      if (!validateTransactionMessage(message, false).isValid) {
        throw new Error(`Invalid transaction message: ${JSON.stringify(message)}`);
      }
      messages.push(message);
    }
    return {
      messages,
      from: this.getAddress()
    };
  }
  async getTransactionPreview(param) {
    await param;
    return {
      preview: {
        result: "error",
        emulationError: createErrorInfo(ERROR_CODES.UNKNOWN_EMULATION_ERROR)
      }
    };
  }
  async getBalance() {
    return await CallForSuccess(async () => this.client.getBalance(distExports$3.Address.parse(this.getAddress())));
  }
}
var dist$1 = {};
var sdk = {};
var pinata = {};
var utils$1 = {};
var hasRequiredUtils$1;
function requireUtils$1() {
  if (hasRequiredUtils$1) return utils$1;
  hasRequiredUtils$1 = 1;
  Object.defineProperty(utils$1, "__esModule", { value: true });
  utils$1.defer = utils$1.internalOnchainContentToCell = utils$1.sleep = void 0;
  const core_1 = requireDist$4();
  const crypto_1 = requireDist$5();
  function sleep(timeout) {
    return new Promise((res) => {
      setTimeout(() => res(), timeout);
    });
  }
  utils$1.sleep = sleep;
  function internalOnchainContentToCell(internal) {
    const dict = core_1.Dictionary.empty(core_1.Dictionary.Keys.Buffer(32), core_1.Dictionary.Values.Cell());
    for (const k2 in internal) {
      if (internal[k2] === void 0) {
        continue;
      }
      const b2 = (0, core_1.beginCell)();
      if (k2 === "image_data") {
        const chunks = core_1.Dictionary.empty(core_1.Dictionary.Keys.Uint(32), core_1.Dictionary.Values.Cell());
        const buf2 = Buffer.from(internal[k2], "base64");
        for (let i = 0; i * 127 < buf2.length; i++) {
          chunks.set(i, (0, core_1.beginCell)().storeBuffer(buf2.subarray(i * 127, (i + 1) * 127)).endCell());
        }
        b2.storeUint(1, 8).storeDict(chunks).endCell();
      } else {
        b2.storeUint(0, 8).storeStringTail(internal[k2].toString());
      }
      dict.set((0, crypto_1.sha256_sync)(k2), b2.endCell());
    }
    return (0, core_1.beginCell)().storeUint(0, 8).storeDict(dict).endCell();
  }
  utils$1.internalOnchainContentToCell = internalOnchainContentToCell;
  function defer(factory) {
    return (...args) => factory(...args);
  }
  utils$1.defer = defer;
  return utils$1;
}
var hasRequiredPinata;
function requirePinata() {
  if (hasRequiredPinata) return pinata;
  hasRequiredPinata = 1;
  var __createBinding = pinata && pinata.__createBinding || (Object.create ? (function(o4, m2, k2, k22) {
    if (k22 === void 0) k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o4, k22, desc);
  }) : (function(o4, m2, k2, k22) {
    if (k22 === void 0) k22 = k2;
    o4[k22] = m2[k2];
  }));
  var __setModuleDefault = pinata && pinata.__setModuleDefault || (Object.create ? (function(o4, v2) {
    Object.defineProperty(o4, "default", { enumerable: true, value: v2 });
  }) : function(o4, v2) {
    o4["default"] = v2;
  });
  var __importStar = pinata && pinata.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(pinata, "__esModule", { value: true });
  pinata.PinataStorage = void 0;
  const utils_1 = requireUtils$1();
  class PinataStorage {
    constructor(apiKey, secretApiKey) {
      this.client = (0, utils_1.defer)(async () => {
        const pinata2 = await Promise.resolve().then(() => __importStar(require$$4$2)).then((m2) => m2.default);
        return new pinata2(this.apiKey, this.secretApiKey);
      });
      this.stream = (0, utils_1.defer)(async (contents) => {
        const stream = await Promise.resolve().then(() => __importStar(require$$4$2)).then((m2) => m2.Readable);
        return stream.from(contents);
      });
      this.apiKey = apiKey;
      this.secretApiKey = secretApiKey;
    }
    static create(params) {
      return new PinataStorage(params.pinataApiKey, params.pinataSecretKey);
    }
    async uploadFile(contents) {
      const client = await this.client();
      const stream = await this.stream(contents);
      const result = await client.pinFileToIPFS(stream, {
        pinataMetadata: {
          name: "Assets SDK Jetton"
        }
      });
      return "ipfs://" + result.IpfsHash;
    }
  }
  pinata.PinataStorage = PinataStorage;
  return pinata;
}
var s3 = {};
var hasRequiredS3;
function requireS3() {
  if (hasRequiredS3) return s3;
  hasRequiredS3 = 1;
  var __createBinding = s3 && s3.__createBinding || (Object.create ? (function(o4, m2, k2, k22) {
    if (k22 === void 0) k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o4, k22, desc);
  }) : (function(o4, m2, k2, k22) {
    if (k22 === void 0) k22 = k2;
    o4[k22] = m2[k2];
  }));
  var __setModuleDefault = s3 && s3.__setModuleDefault || (Object.create ? (function(o4, v2) {
    Object.defineProperty(o4, "default", { enumerable: true, value: v2 });
  }) : function(o4, v2) {
    o4["default"] = v2;
  });
  var __importStar = s3 && s3.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(s3, "__esModule", { value: true });
  s3.S3Storage = void 0;
  const utils_1 = requireUtils$1();
  class S3Storage {
    constructor(accessKeyId, secretAccessKey, bucket) {
      this.s3 = (0, utils_1.defer)(async () => {
        const s32 = await Promise.resolve().then(() => __importStar(require$$4$2)).then((m2) => m2.S3);
        return new s32({
          credentials: {
            accessKeyId: this.accessKeyId,
            secretAccessKey: this.secretAccessKey
          }
        });
      });
      this.accessKeyId = accessKeyId;
      this.secretAccessKey = secretAccessKey;
      this.bucket = bucket;
    }
    static create(params) {
      return new S3Storage(params.s3AccessKeyId, params.s3SecretAccessKey, params.s3Bucket);
    }
    async uploadFile(contents) {
      const s32 = await this.s3();
      const key2 = "jetton/" + Math.random().toString(36).substring(2);
      await s32.putObject({
        Bucket: this.bucket,
        Key: key2,
        Body: contents
      });
      return "https://" + this.bucket + ".s3.amazonaws.com/" + key2;
    }
  }
  s3.S3Storage = S3Storage;
  return s3;
}
var content$2 = {};
var zod = {};
var external = {};
var errors = {};
var en = {};
var ZodError = {};
var util = {};
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getParsedType = exports.ZodParsedType = exports.objectUtil = exports.util = void 0;
    var util2;
    (function(util3) {
      util3.assertEqual = (_) => {
      };
      function assertIs(_arg) {
      }
      util3.assertIs = assertIs;
      function assertNever(_x) {
        throw new Error();
      }
      util3.assertNever = assertNever;
      util3.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
          obj[item] = item;
        }
        return obj;
      };
      util3.getValidEnumValues = (obj) => {
        const validKeys = util3.objectKeys(obj).filter((k2) => typeof obj[obj[k2]] !== "number");
        const filtered = {};
        for (const k2 of validKeys) {
          filtered[k2] = obj[k2];
        }
        return util3.objectValues(filtered);
      };
      util3.objectValues = (obj) => {
        return util3.objectKeys(obj).map(function(e) {
          return obj[e];
        });
      };
      util3.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
        const keys = [];
        for (const key2 in object) {
          if (Object.prototype.hasOwnProperty.call(object, key2)) {
            keys.push(key2);
          }
        }
        return keys;
      };
      util3.find = (arr, checker) => {
        for (const item of arr) {
          if (checker(item))
            return item;
        }
        return void 0;
      };
      util3.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
      function joinValues(array, separator = " | ") {
        return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
      }
      util3.joinValues = joinValues;
      util3.jsonStringifyReplacer = (_, value) => {
        if (typeof value === "bigint") {
          return value.toString();
        }
        return value;
      };
    })(util2 || (exports.util = util2 = {}));
    var objectUtil;
    (function(objectUtil2) {
      objectUtil2.mergeShapes = (first, second) => {
        return {
          ...first,
          ...second
          // second overwrites first
        };
      };
    })(objectUtil || (exports.objectUtil = objectUtil = {}));
    exports.ZodParsedType = util2.arrayToEnum([
      "string",
      "nan",
      "number",
      "integer",
      "float",
      "boolean",
      "date",
      "bigint",
      "symbol",
      "function",
      "undefined",
      "null",
      "array",
      "object",
      "unknown",
      "promise",
      "void",
      "never",
      "map",
      "set"
    ]);
    const getParsedType = (data) => {
      const t = typeof data;
      switch (t) {
        case "undefined":
          return exports.ZodParsedType.undefined;
        case "string":
          return exports.ZodParsedType.string;
        case "number":
          return Number.isNaN(data) ? exports.ZodParsedType.nan : exports.ZodParsedType.number;
        case "boolean":
          return exports.ZodParsedType.boolean;
        case "function":
          return exports.ZodParsedType.function;
        case "bigint":
          return exports.ZodParsedType.bigint;
        case "symbol":
          return exports.ZodParsedType.symbol;
        case "object":
          if (Array.isArray(data)) {
            return exports.ZodParsedType.array;
          }
          if (data === null) {
            return exports.ZodParsedType.null;
          }
          if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
            return exports.ZodParsedType.promise;
          }
          if (typeof Map !== "undefined" && data instanceof Map) {
            return exports.ZodParsedType.map;
          }
          if (typeof Set !== "undefined" && data instanceof Set) {
            return exports.ZodParsedType.set;
          }
          if (typeof Date !== "undefined" && data instanceof Date) {
            return exports.ZodParsedType.date;
          }
          return exports.ZodParsedType.object;
        default:
          return exports.ZodParsedType.unknown;
      }
    };
    exports.getParsedType = getParsedType;
  })(util);
  return util;
}
var hasRequiredZodError;
function requireZodError() {
  if (hasRequiredZodError) return ZodError;
  hasRequiredZodError = 1;
  Object.defineProperty(ZodError, "__esModule", { value: true });
  ZodError.ZodError = ZodError.quotelessJson = ZodError.ZodIssueCode = void 0;
  const util_js_1 = /* @__PURE__ */ requireUtil();
  ZodError.ZodIssueCode = util_js_1.util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
  ]);
  const quotelessJson = (obj) => {
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
  };
  ZodError.quotelessJson = quotelessJson;
  let ZodError$1 = class ZodError2 extends Error {
    get errors() {
      return this.issues;
    }
    constructor(issues) {
      super();
      this.issues = [];
      this.addIssue = (sub) => {
        this.issues = [...this.issues, sub];
      };
      this.addIssues = (subs = []) => {
        this.issues = [...this.issues, ...subs];
      };
      const actualProto = new.target.prototype;
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(this, actualProto);
      } else {
        this.__proto__ = actualProto;
      }
      this.name = "ZodError";
      this.issues = issues;
    }
    format(_mapper) {
      const mapper = _mapper || function(issue) {
        return issue.message;
      };
      const fieldErrors = { _errors: [] };
      const processError = (error2) => {
        for (const issue of error2.issues) {
          if (issue.code === "invalid_union") {
            issue.unionErrors.map(processError);
          } else if (issue.code === "invalid_return_type") {
            processError(issue.returnTypeError);
          } else if (issue.code === "invalid_arguments") {
            processError(issue.argumentsError);
          } else if (issue.path.length === 0) {
            fieldErrors._errors.push(mapper(issue));
          } else {
            let curr = fieldErrors;
            let i = 0;
            while (i < issue.path.length) {
              const el = issue.path[i];
              const terminal = i === issue.path.length - 1;
              if (!terminal) {
                curr[el] = curr[el] || { _errors: [] };
              } else {
                curr[el] = curr[el] || { _errors: [] };
                curr[el]._errors.push(mapper(issue));
              }
              curr = curr[el];
              i++;
            }
          }
        }
      };
      processError(this);
      return fieldErrors;
    }
    static assert(value) {
      if (!(value instanceof ZodError2)) {
        throw new Error(`Not a ZodError: ${value}`);
      }
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, util_js_1.util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
      const fieldErrors = {};
      const formErrors = [];
      for (const sub of this.issues) {
        if (sub.path.length > 0) {
          const firstEl = sub.path[0];
          fieldErrors[firstEl] = fieldErrors[firstEl] || [];
          fieldErrors[firstEl].push(mapper(sub));
        } else {
          formErrors.push(mapper(sub));
        }
      }
      return { formErrors, fieldErrors };
    }
    get formErrors() {
      return this.flatten();
    }
  };
  ZodError.ZodError = ZodError$1;
  ZodError$1.create = (issues) => {
    const error2 = new ZodError$1(issues);
    return error2;
  };
  return ZodError;
}
var hasRequiredEn;
function requireEn() {
  if (hasRequiredEn) return en;
  hasRequiredEn = 1;
  Object.defineProperty(en, "__esModule", { value: true });
  const ZodError_js_1 = /* @__PURE__ */ requireZodError();
  const util_js_1 = /* @__PURE__ */ requireUtil();
  const errorMap = (issue, _ctx) => {
    let message;
    switch (issue.code) {
      case ZodError_js_1.ZodIssueCode.invalid_type:
        if (issue.received === util_js_1.ZodParsedType.undefined) {
          message = "Required";
        } else {
          message = `Expected ${issue.expected}, received ${issue.received}`;
        }
        break;
      case ZodError_js_1.ZodIssueCode.invalid_literal:
        message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util_js_1.util.jsonStringifyReplacer)}`;
        break;
      case ZodError_js_1.ZodIssueCode.unrecognized_keys:
        message = `Unrecognized key(s) in object: ${util_js_1.util.joinValues(issue.keys, ", ")}`;
        break;
      case ZodError_js_1.ZodIssueCode.invalid_union:
        message = `Invalid input`;
        break;
      case ZodError_js_1.ZodIssueCode.invalid_union_discriminator:
        message = `Invalid discriminator value. Expected ${util_js_1.util.joinValues(issue.options)}`;
        break;
      case ZodError_js_1.ZodIssueCode.invalid_enum_value:
        message = `Invalid enum value. Expected ${util_js_1.util.joinValues(issue.options)}, received '${issue.received}'`;
        break;
      case ZodError_js_1.ZodIssueCode.invalid_arguments:
        message = `Invalid function arguments`;
        break;
      case ZodError_js_1.ZodIssueCode.invalid_return_type:
        message = `Invalid function return type`;
        break;
      case ZodError_js_1.ZodIssueCode.invalid_date:
        message = `Invalid date`;
        break;
      case ZodError_js_1.ZodIssueCode.invalid_string:
        if (typeof issue.validation === "object") {
          if ("includes" in issue.validation) {
            message = `Invalid input: must include "${issue.validation.includes}"`;
            if (typeof issue.validation.position === "number") {
              message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
            }
          } else if ("startsWith" in issue.validation) {
            message = `Invalid input: must start with "${issue.validation.startsWith}"`;
          } else if ("endsWith" in issue.validation) {
            message = `Invalid input: must end with "${issue.validation.endsWith}"`;
          } else {
            util_js_1.util.assertNever(issue.validation);
          }
        } else if (issue.validation !== "regex") {
          message = `Invalid ${issue.validation}`;
        } else {
          message = "Invalid";
        }
        break;
      case ZodError_js_1.ZodIssueCode.too_small:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
        else if (issue.type === "bigint")
          message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
        else
          message = "Invalid input";
        break;
      case ZodError_js_1.ZodIssueCode.too_big:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "bigint")
          message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
        else
          message = "Invalid input";
        break;
      case ZodError_js_1.ZodIssueCode.custom:
        message = `Invalid input`;
        break;
      case ZodError_js_1.ZodIssueCode.invalid_intersection_types:
        message = `Intersection results could not be merged`;
        break;
      case ZodError_js_1.ZodIssueCode.not_multiple_of:
        message = `Number must be a multiple of ${issue.multipleOf}`;
        break;
      case ZodError_js_1.ZodIssueCode.not_finite:
        message = "Number must be finite";
        break;
      default:
        message = _ctx.defaultError;
        util_js_1.util.assertNever(issue);
    }
    return { message };
  };
  en.default = errorMap;
  return en;
}
var hasRequiredErrors;
function requireErrors() {
  if (hasRequiredErrors) return errors;
  hasRequiredErrors = 1;
  var __importDefault = errors && errors.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(errors, "__esModule", { value: true });
  errors.defaultErrorMap = void 0;
  errors.setErrorMap = setErrorMap;
  errors.getErrorMap = getErrorMap;
  const en_js_1 = __importDefault(/* @__PURE__ */ requireEn());
  errors.defaultErrorMap = en_js_1.default;
  let overrideErrorMap = en_js_1.default;
  function setErrorMap(map2) {
    overrideErrorMap = map2;
  }
  function getErrorMap() {
    return overrideErrorMap;
  }
  return errors;
}
var parseUtil = {};
var hasRequiredParseUtil;
function requireParseUtil() {
  if (hasRequiredParseUtil) return parseUtil;
  hasRequiredParseUtil = 1;
  (function(exports) {
    var __importDefault = parseUtil && parseUtil.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAsync = exports.isValid = exports.isDirty = exports.isAborted = exports.OK = exports.DIRTY = exports.INVALID = exports.ParseStatus = exports.EMPTY_PATH = exports.makeIssue = void 0;
    exports.addIssueToContext = addIssueToContext;
    const errors_js_1 = /* @__PURE__ */ requireErrors();
    const en_js_1 = __importDefault(/* @__PURE__ */ requireEn());
    const makeIssue = (params) => {
      const { data, path, errorMaps, issueData } = params;
      const fullPath = [...path, ...issueData.path || []];
      const fullIssue = {
        ...issueData,
        path: fullPath
      };
      if (issueData.message !== void 0) {
        return {
          ...issueData,
          path: fullPath,
          message: issueData.message
        };
      }
      let errorMessage = "";
      const maps = errorMaps.filter((m2) => !!m2).slice().reverse();
      for (const map2 of maps) {
        errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
      }
      return {
        ...issueData,
        path: fullPath,
        message: errorMessage
      };
    };
    exports.makeIssue = makeIssue;
    exports.EMPTY_PATH = [];
    function addIssueToContext(ctx, issueData) {
      const overrideMap = (0, errors_js_1.getErrorMap)();
      const issue = (0, exports.makeIssue)({
        issueData,
        data: ctx.data,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          // contextual error map is first priority
          ctx.schemaErrorMap,
          // then schema-bound map if available
          overrideMap,
          // then global override map
          overrideMap === en_js_1.default ? void 0 : en_js_1.default
          // then global default map
        ].filter((x2) => !!x2)
      });
      ctx.common.issues.push(issue);
    }
    class ParseStatus {
      constructor() {
        this.value = "valid";
      }
      dirty() {
        if (this.value === "valid")
          this.value = "dirty";
      }
      abort() {
        if (this.value !== "aborted")
          this.value = "aborted";
      }
      static mergeArray(status, results) {
        const arrayValue = [];
        for (const s2 of results) {
          if (s2.status === "aborted")
            return exports.INVALID;
          if (s2.status === "dirty")
            status.dirty();
          arrayValue.push(s2.value);
        }
        return { status: status.value, value: arrayValue };
      }
      static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
          const key2 = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key: key2,
            value
          });
        }
        return ParseStatus.mergeObjectSync(status, syncPairs);
      }
      static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
          const { key: key2, value } = pair;
          if (key2.status === "aborted")
            return exports.INVALID;
          if (value.status === "aborted")
            return exports.INVALID;
          if (key2.status === "dirty")
            status.dirty();
          if (value.status === "dirty")
            status.dirty();
          if (key2.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
            finalObject[key2.value] = value.value;
          }
        }
        return { status: status.value, value: finalObject };
      }
    }
    exports.ParseStatus = ParseStatus;
    exports.INVALID = Object.freeze({
      status: "aborted"
    });
    const DIRTY = (value) => ({ status: "dirty", value });
    exports.DIRTY = DIRTY;
    const OK = (value) => ({ status: "valid", value });
    exports.OK = OK;
    const isAborted = (x2) => x2.status === "aborted";
    exports.isAborted = isAborted;
    const isDirty = (x2) => x2.status === "dirty";
    exports.isDirty = isDirty;
    const isValid = (x2) => x2.status === "valid";
    exports.isValid = isValid;
    const isAsync = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
    exports.isAsync = isAsync;
  })(parseUtil);
  return parseUtil;
}
var typeAliases = {};
var hasRequiredTypeAliases;
function requireTypeAliases() {
  if (hasRequiredTypeAliases) return typeAliases;
  hasRequiredTypeAliases = 1;
  Object.defineProperty(typeAliases, "__esModule", { value: true });
  return typeAliases;
}
var types$1 = {};
var errorUtil = {};
var hasRequiredErrorUtil;
function requireErrorUtil() {
  if (hasRequiredErrorUtil) return errorUtil;
  hasRequiredErrorUtil = 1;
  Object.defineProperty(errorUtil, "__esModule", { value: true });
  errorUtil.errorUtil = void 0;
  var errorUtil$1;
  (function(errorUtil2) {
    errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
  })(errorUtil$1 || (errorUtil.errorUtil = errorUtil$1 = {}));
  return errorUtil;
}
var hasRequiredTypes$1;
function requireTypes$1() {
  if (hasRequiredTypes$1) return types$1;
  hasRequiredTypes$1 = 1;
  Object.defineProperty(types$1, "__esModule", { value: true });
  types$1.discriminatedUnion = types$1.date = types$1.boolean = types$1.bigint = types$1.array = types$1.any = types$1.coerce = types$1.ZodFirstPartyTypeKind = types$1.late = types$1.ZodSchema = types$1.Schema = types$1.ZodReadonly = types$1.ZodPipeline = types$1.ZodBranded = types$1.BRAND = types$1.ZodNaN = types$1.ZodCatch = types$1.ZodDefault = types$1.ZodNullable = types$1.ZodOptional = types$1.ZodTransformer = types$1.ZodEffects = types$1.ZodPromise = types$1.ZodNativeEnum = types$1.ZodEnum = types$1.ZodLiteral = types$1.ZodLazy = types$1.ZodFunction = types$1.ZodSet = types$1.ZodMap = types$1.ZodRecord = types$1.ZodTuple = types$1.ZodIntersection = types$1.ZodDiscriminatedUnion = types$1.ZodUnion = types$1.ZodObject = types$1.ZodArray = types$1.ZodVoid = types$1.ZodNever = types$1.ZodUnknown = types$1.ZodAny = types$1.ZodNull = types$1.ZodUndefined = types$1.ZodSymbol = types$1.ZodDate = types$1.ZodBoolean = types$1.ZodBigInt = types$1.ZodNumber = types$1.ZodString = types$1.ZodType = void 0;
  types$1.NEVER = types$1.void = types$1.unknown = types$1.union = types$1.undefined = types$1.tuple = types$1.transformer = types$1.symbol = types$1.string = types$1.strictObject = types$1.set = types$1.record = types$1.promise = types$1.preprocess = types$1.pipeline = types$1.ostring = types$1.optional = types$1.onumber = types$1.oboolean = types$1.object = types$1.number = types$1.nullable = types$1.null = types$1.never = types$1.nativeEnum = types$1.nan = types$1.map = types$1.literal = types$1.lazy = types$1.intersection = types$1.instanceof = types$1.function = types$1.enum = types$1.effect = void 0;
  types$1.datetimeRegex = datetimeRegex;
  types$1.custom = custom;
  const ZodError_js_1 = /* @__PURE__ */ requireZodError();
  const errors_js_1 = /* @__PURE__ */ requireErrors();
  const errorUtil_js_1 = /* @__PURE__ */ requireErrorUtil();
  const parseUtil_js_1 = /* @__PURE__ */ requireParseUtil();
  const util_js_1 = /* @__PURE__ */ requireUtil();
  class ParseInputLazyPath {
    constructor(parent, value, path, key2) {
      this._cachedPath = [];
      this.parent = parent;
      this.data = value;
      this._path = path;
      this._key = key2;
    }
    get path() {
      if (!this._cachedPath.length) {
        if (Array.isArray(this._key)) {
          this._cachedPath.push(...this._path, ...this._key);
        } else {
          this._cachedPath.push(...this._path, this._key);
        }
      }
      return this._cachedPath;
    }
  }
  const handleResult = (ctx, result) => {
    if ((0, parseUtil_js_1.isValid)(result)) {
      return { success: true, data: result.value };
    } else {
      if (!ctx.common.issues.length) {
        throw new Error("Validation failed but no issues detected.");
      }
      return {
        success: false,
        get error() {
          if (this._error)
            return this._error;
          const error2 = new ZodError_js_1.ZodError(ctx.common.issues);
          this._error = error2;
          return this._error;
        }
      };
    }
  };
  function processCreateParams(params) {
    if (!params)
      return {};
    const { errorMap, invalid_type_error, required_error, description } = params;
    if (errorMap && (invalid_type_error || required_error)) {
      throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap)
      return { errorMap, description };
    const customMap = (iss, ctx) => {
      const { message } = params;
      if (iss.code === "invalid_enum_value") {
        return { message: message ?? ctx.defaultError };
      }
      if (typeof ctx.data === "undefined") {
        return { message: message ?? required_error ?? ctx.defaultError };
      }
      if (iss.code !== "invalid_type")
        return { message: ctx.defaultError };
      return { message: message ?? invalid_type_error ?? ctx.defaultError };
    };
    return { errorMap: customMap, description };
  }
  class ZodType {
    get description() {
      return this._def.description;
    }
    _getType(input) {
      return (0, util_js_1.getParsedType)(input.data);
    }
    _getOrReturnCtx(input, ctx) {
      return ctx || {
        common: input.parent.common,
        data: input.data,
        parsedType: (0, util_js_1.getParsedType)(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      };
    }
    _processInputParams(input) {
      return {
        status: new parseUtil_js_1.ParseStatus(),
        ctx: {
          common: input.parent.common,
          data: input.data,
          parsedType: (0, util_js_1.getParsedType)(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        }
      };
    }
    _parseSync(input) {
      const result = this._parse(input);
      if ((0, parseUtil_js_1.isAsync)(result)) {
        throw new Error("Synchronous parse encountered promise.");
      }
      return result;
    }
    _parseAsync(input) {
      const result = this._parse(input);
      return Promise.resolve(result);
    }
    parse(data, params) {
      const result = this.safeParse(data, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    safeParse(data, params) {
      const ctx = {
        common: {
          issues: [],
          async: params?.async ?? false,
          contextualErrorMap: params?.errorMap
        },
        path: params?.path || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: (0, util_js_1.getParsedType)(data)
      };
      const result = this._parseSync({ data, path: ctx.path, parent: ctx });
      return handleResult(ctx, result);
    }
    "~validate"(data) {
      const ctx = {
        common: {
          issues: [],
          async: !!this["~standard"].async
        },
        path: [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: (0, util_js_1.getParsedType)(data)
      };
      if (!this["~standard"].async) {
        try {
          const result = this._parseSync({ data, path: [], parent: ctx });
          return (0, parseUtil_js_1.isValid)(result) ? {
            value: result.value
          } : {
            issues: ctx.common.issues
          };
        } catch (err) {
          if (err?.message?.toLowerCase()?.includes("encountered")) {
            this["~standard"].async = true;
          }
          ctx.common = {
            issues: [],
            async: true
          };
        }
      }
      return this._parseAsync({ data, path: [], parent: ctx }).then((result) => (0, parseUtil_js_1.isValid)(result) ? {
        value: result.value
      } : {
        issues: ctx.common.issues
      });
    }
    async parseAsync(data, params) {
      const result = await this.safeParseAsync(data, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    async safeParseAsync(data, params) {
      const ctx = {
        common: {
          issues: [],
          contextualErrorMap: params?.errorMap,
          async: true
        },
        path: params?.path || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: (0, util_js_1.getParsedType)(data)
      };
      const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
      const result = await ((0, parseUtil_js_1.isAsync)(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
      return handleResult(ctx, result);
    }
    refine(check, message) {
      const getIssueProperties = (val) => {
        if (typeof message === "string" || typeof message === "undefined") {
          return { message };
        } else if (typeof message === "function") {
          return message(val);
        } else {
          return message;
        }
      };
      return this._refinement((val, ctx) => {
        const result = check(val);
        const setError = () => ctx.addIssue({
          code: ZodError_js_1.ZodIssueCode.custom,
          ...getIssueProperties(val)
        });
        if (typeof Promise !== "undefined" && result instanceof Promise) {
          return result.then((data) => {
            if (!data) {
              setError();
              return false;
            } else {
              return true;
            }
          });
        }
        if (!result) {
          setError();
          return false;
        } else {
          return true;
        }
      });
    }
    refinement(check, refinementData) {
      return this._refinement((val, ctx) => {
        if (!check(val)) {
          ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
          return false;
        } else {
          return true;
        }
      });
    }
    _refinement(refinement) {
      return new ZodEffects({
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "refinement", refinement }
      });
    }
    superRefine(refinement) {
      return this._refinement(refinement);
    }
    constructor(def) {
      this.spa = this.safeParseAsync;
      this._def = def;
      this.parse = this.parse.bind(this);
      this.safeParse = this.safeParse.bind(this);
      this.parseAsync = this.parseAsync.bind(this);
      this.safeParseAsync = this.safeParseAsync.bind(this);
      this.spa = this.spa.bind(this);
      this.refine = this.refine.bind(this);
      this.refinement = this.refinement.bind(this);
      this.superRefine = this.superRefine.bind(this);
      this.optional = this.optional.bind(this);
      this.nullable = this.nullable.bind(this);
      this.nullish = this.nullish.bind(this);
      this.array = this.array.bind(this);
      this.promise = this.promise.bind(this);
      this.or = this.or.bind(this);
      this.and = this.and.bind(this);
      this.transform = this.transform.bind(this);
      this.brand = this.brand.bind(this);
      this.default = this.default.bind(this);
      this.catch = this.catch.bind(this);
      this.describe = this.describe.bind(this);
      this.pipe = this.pipe.bind(this);
      this.readonly = this.readonly.bind(this);
      this.isNullable = this.isNullable.bind(this);
      this.isOptional = this.isOptional.bind(this);
      this["~standard"] = {
        version: 1,
        vendor: "zod",
        validate: (data) => this["~validate"](data)
      };
    }
    optional() {
      return ZodOptional.create(this, this._def);
    }
    nullable() {
      return ZodNullable.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return ZodArray.create(this);
    }
    promise() {
      return ZodPromise.create(this, this._def);
    }
    or(option) {
      return ZodUnion.create([this, option], this._def);
    }
    and(incoming) {
      return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform) {
      return new ZodEffects({
        ...processCreateParams(this._def),
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "transform", transform }
      });
    }
    default(def) {
      const defaultValueFunc = typeof def === "function" ? def : () => def;
      return new ZodDefault({
        ...processCreateParams(this._def),
        innerType: this,
        defaultValue: defaultValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodDefault
      });
    }
    brand() {
      return new ZodBranded({
        typeName: ZodFirstPartyTypeKind.ZodBranded,
        type: this,
        ...processCreateParams(this._def)
      });
    }
    catch(def) {
      const catchValueFunc = typeof def === "function" ? def : () => def;
      return new ZodCatch({
        ...processCreateParams(this._def),
        innerType: this,
        catchValue: catchValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodCatch
      });
    }
    describe(description) {
      const This = this.constructor;
      return new This({
        ...this._def,
        description
      });
    }
    pipe(target) {
      return ZodPipeline.create(this, target);
    }
    readonly() {
      return ZodReadonly.create(this);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  }
  types$1.ZodType = ZodType;
  types$1.Schema = ZodType;
  types$1.ZodSchema = ZodType;
  const cuidRegex = /^c[^\s-]{8,}$/i;
  const cuid2Regex = /^[0-9a-z]+$/;
  const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
  const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
  const nanoidRegex = /^[a-z0-9_-]{21}$/i;
  const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
  const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
  const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
  const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
  let emojiRegex;
  const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
  const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
  const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
  const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
  const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
  const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
  const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
  const dateRegex = new RegExp(`^${dateRegexSource}$`);
  function timeRegexSource(args) {
    let secondsRegexSource = `[0-5]\\d`;
    if (args.precision) {
      secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
    } else if (args.precision == null) {
      secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
    }
    const secondsQuantifier = args.precision ? "+" : "?";
    return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
  }
  function timeRegex(args) {
    return new RegExp(`^${timeRegexSource(args)}$`);
  }
  function datetimeRegex(args) {
    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
    const opts = [];
    opts.push(args.local ? `Z?` : `Z`);
    if (args.offset)
      opts.push(`([+-]\\d{2}:?\\d{2})`);
    regex = `${regex}(${opts.join("|")})`;
    return new RegExp(`^${regex}$`);
  }
  function isValidIP(ip, version2) {
    if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
      return true;
    }
    if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
      return true;
    }
    return false;
  }
  function isValidJWT(jwt, alg) {
    if (!jwtRegex.test(jwt))
      return false;
    try {
      const [header] = jwt.split(".");
      if (!header)
        return false;
      const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
      const decoded = JSON.parse(atob(base64));
      if (typeof decoded !== "object" || decoded === null)
        return false;
      if ("typ" in decoded && decoded?.typ !== "JWT")
        return false;
      if (!decoded.alg)
        return false;
      if (alg && decoded.alg !== alg)
        return false;
      return true;
    } catch {
      return false;
    }
  }
  function isValidCidr(ip, version2) {
    if ((version2 === "v4" || !version2) && ipv4CidrRegex.test(ip)) {
      return true;
    }
    if ((version2 === "v6" || !version2) && ipv6CidrRegex.test(ip)) {
      return true;
    }
    return false;
  }
  class ZodString extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = String(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== util_js_1.ZodParsedType.string) {
        const ctx2 = this._getOrReturnCtx(input);
        (0, parseUtil_js_1.addIssueToContext)(ctx2, {
          code: ZodError_js_1.ZodIssueCode.invalid_type,
          expected: util_js_1.ZodParsedType.string,
          received: ctx2.parsedType
        });
        return parseUtil_js_1.INVALID;
      }
      const status = new parseUtil_js_1.ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.length < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.length > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "length") {
          const tooBig = input.data.length > check.value;
          const tooSmall = input.data.length < check.value;
          if (tooBig || tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            if (tooBig) {
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            } else if (tooSmall) {
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            }
            status.dirty();
          }
        } else if (check.kind === "email") {
          if (!emailRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              validation: "email",
              code: ZodError_js_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "emoji") {
          if (!emojiRegex) {
            emojiRegex = new RegExp(_emojiRegex, "u");
          }
          if (!emojiRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              validation: "emoji",
              code: ZodError_js_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "uuid") {
          if (!uuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              validation: "uuid",
              code: ZodError_js_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "nanoid") {
          if (!nanoidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              validation: "nanoid",
              code: ZodError_js_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid") {
          if (!cuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              validation: "cuid",
              code: ZodError_js_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid2") {
          if (!cuid2Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              validation: "cuid2",
              code: ZodError_js_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ulid") {
          if (!ulidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              validation: "ulid",
              code: ZodError_js_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "url") {
          try {
            new URL(input.data);
          } catch {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              validation: "url",
              code: ZodError_js_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "regex") {
          check.regex.lastIndex = 0;
          const testResult = check.regex.test(input.data);
          if (!testResult) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              validation: "regex",
              code: ZodError_js_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "trim") {
          input.data = input.data.trim();
        } else if (check.kind === "includes") {
          if (!input.data.includes(check.value, check.position)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.invalid_string,
              validation: { includes: check.value, position: check.position },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "toLowerCase") {
          input.data = input.data.toLowerCase();
        } else if (check.kind === "toUpperCase") {
          input.data = input.data.toUpperCase();
        } else if (check.kind === "startsWith") {
          if (!input.data.startsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.invalid_string,
              validation: { startsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "endsWith") {
          if (!input.data.endsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.invalid_string,
              validation: { endsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "datetime") {
          const regex = datetimeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.invalid_string,
              validation: "datetime",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "date") {
          const regex = dateRegex;
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.invalid_string,
              validation: "date",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "time") {
          const regex = timeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.invalid_string,
              validation: "time",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "duration") {
          if (!durationRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              validation: "duration",
              code: ZodError_js_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ip") {
          if (!isValidIP(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              validation: "ip",
              code: ZodError_js_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "jwt") {
          if (!isValidJWT(input.data, check.alg)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              validation: "jwt",
              code: ZodError_js_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cidr") {
          if (!isValidCidr(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              validation: "cidr",
              code: ZodError_js_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "base64") {
          if (!base64Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              validation: "base64",
              code: ZodError_js_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "base64url") {
          if (!base64urlRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              validation: "base64url",
              code: ZodError_js_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util_js_1.util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _regex(regex, validation, message) {
      return this.refinement((data) => regex.test(data), {
        validation,
        code: ZodError_js_1.ZodIssueCode.invalid_string,
        ...errorUtil_js_1.errorUtil.errToObj(message)
      });
    }
    _addCheck(check) {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    email(message) {
      return this._addCheck({ kind: "email", ...errorUtil_js_1.errorUtil.errToObj(message) });
    }
    url(message) {
      return this._addCheck({ kind: "url", ...errorUtil_js_1.errorUtil.errToObj(message) });
    }
    emoji(message) {
      return this._addCheck({ kind: "emoji", ...errorUtil_js_1.errorUtil.errToObj(message) });
    }
    uuid(message) {
      return this._addCheck({ kind: "uuid", ...errorUtil_js_1.errorUtil.errToObj(message) });
    }
    nanoid(message) {
      return this._addCheck({ kind: "nanoid", ...errorUtil_js_1.errorUtil.errToObj(message) });
    }
    cuid(message) {
      return this._addCheck({ kind: "cuid", ...errorUtil_js_1.errorUtil.errToObj(message) });
    }
    cuid2(message) {
      return this._addCheck({ kind: "cuid2", ...errorUtil_js_1.errorUtil.errToObj(message) });
    }
    ulid(message) {
      return this._addCheck({ kind: "ulid", ...errorUtil_js_1.errorUtil.errToObj(message) });
    }
    base64(message) {
      return this._addCheck({ kind: "base64", ...errorUtil_js_1.errorUtil.errToObj(message) });
    }
    base64url(message) {
      return this._addCheck({
        kind: "base64url",
        ...errorUtil_js_1.errorUtil.errToObj(message)
      });
    }
    jwt(options) {
      return this._addCheck({ kind: "jwt", ...errorUtil_js_1.errorUtil.errToObj(options) });
    }
    ip(options) {
      return this._addCheck({ kind: "ip", ...errorUtil_js_1.errorUtil.errToObj(options) });
    }
    cidr(options) {
      return this._addCheck({ kind: "cidr", ...errorUtil_js_1.errorUtil.errToObj(options) });
    }
    datetime(options) {
      if (typeof options === "string") {
        return this._addCheck({
          kind: "datetime",
          precision: null,
          offset: false,
          local: false,
          message: options
        });
      }
      return this._addCheck({
        kind: "datetime",
        precision: typeof options?.precision === "undefined" ? null : options?.precision,
        offset: options?.offset ?? false,
        local: options?.local ?? false,
        ...errorUtil_js_1.errorUtil.errToObj(options?.message)
      });
    }
    date(message) {
      return this._addCheck({ kind: "date", message });
    }
    time(options) {
      if (typeof options === "string") {
        return this._addCheck({
          kind: "time",
          precision: null,
          message: options
        });
      }
      return this._addCheck({
        kind: "time",
        precision: typeof options?.precision === "undefined" ? null : options?.precision,
        ...errorUtil_js_1.errorUtil.errToObj(options?.message)
      });
    }
    duration(message) {
      return this._addCheck({ kind: "duration", ...errorUtil_js_1.errorUtil.errToObj(message) });
    }
    regex(regex, message) {
      return this._addCheck({
        kind: "regex",
        regex,
        ...errorUtil_js_1.errorUtil.errToObj(message)
      });
    }
    includes(value, options) {
      return this._addCheck({
        kind: "includes",
        value,
        position: options?.position,
        ...errorUtil_js_1.errorUtil.errToObj(options?.message)
      });
    }
    startsWith(value, message) {
      return this._addCheck({
        kind: "startsWith",
        value,
        ...errorUtil_js_1.errorUtil.errToObj(message)
      });
    }
    endsWith(value, message) {
      return this._addCheck({
        kind: "endsWith",
        value,
        ...errorUtil_js_1.errorUtil.errToObj(message)
      });
    }
    min(minLength, message) {
      return this._addCheck({
        kind: "min",
        value: minLength,
        ...errorUtil_js_1.errorUtil.errToObj(message)
      });
    }
    max(maxLength, message) {
      return this._addCheck({
        kind: "max",
        value: maxLength,
        ...errorUtil_js_1.errorUtil.errToObj(message)
      });
    }
    length(len, message) {
      return this._addCheck({
        kind: "length",
        value: len,
        ...errorUtil_js_1.errorUtil.errToObj(message)
      });
    }
    /**
     * Equivalent to `.min(1)`
     */
    nonempty(message) {
      return this.min(1, errorUtil_js_1.errorUtil.errToObj(message));
    }
    trim() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }]
      });
    }
    toLowerCase() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      });
    }
    toUpperCase() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isDate() {
      return !!this._def.checks.find((ch) => ch.kind === "date");
    }
    get isTime() {
      return !!this._def.checks.find((ch) => ch.kind === "time");
    }
    get isDuration() {
      return !!this._def.checks.find((ch) => ch.kind === "duration");
    }
    get isEmail() {
      return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((ch) => ch.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isNANOID() {
      return !!this._def.checks.find((ch) => ch.kind === "nanoid");
    }
    get isCUID() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((ch) => ch.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((ch) => ch.kind === "ip");
    }
    get isCIDR() {
      return !!this._def.checks.find((ch) => ch.kind === "cidr");
    }
    get isBase64() {
      return !!this._def.checks.find((ch) => ch.kind === "base64");
    }
    get isBase64url() {
      return !!this._def.checks.find((ch) => ch.kind === "base64url");
    }
    get minLength() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxLength() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  }
  types$1.ZodString = ZodString;
  ZodString.create = (params) => {
    return new ZodString({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodString,
      coerce: params?.coerce ?? false,
      ...processCreateParams(params)
    });
  };
  function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
    return valInt % stepInt / 10 ** decCount;
  }
  class ZodNumber extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
      this.step = this.multipleOf;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = Number(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== util_js_1.ZodParsedType.number) {
        const ctx2 = this._getOrReturnCtx(input);
        (0, parseUtil_js_1.addIssueToContext)(ctx2, {
          code: ZodError_js_1.ZodIssueCode.invalid_type,
          expected: util_js_1.ZodParsedType.number,
          received: ctx2.parsedType
        });
        return parseUtil_js_1.INVALID;
      }
      let ctx = void 0;
      const status = new parseUtil_js_1.ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "int") {
          if (!util_js_1.util.isInteger(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.invalid_type,
              expected: "integer",
              received: "float",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.too_small,
              minimum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.too_big,
              maximum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (floatSafeRemainder(input.data, check.value) !== 0) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "finite") {
          if (!Number.isFinite(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.not_finite,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util_js_1.util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil_js_1.errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil_js_1.errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil_js_1.errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil_js_1.errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new ZodNumber({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil_js_1.errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodNumber({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    int(message) {
      return this._addCheck({
        kind: "int",
        message: errorUtil_js_1.errorUtil.toString(message)
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: false,
        message: errorUtil_js_1.errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: false,
        message: errorUtil_js_1.errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: true,
        message: errorUtil_js_1.errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: true,
        message: errorUtil_js_1.errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil_js_1.errorUtil.toString(message)
      });
    }
    finite(message) {
      return this._addCheck({
        kind: "finite",
        message: errorUtil_js_1.errorUtil.toString(message)
      });
    }
    safe(message) {
      return this._addCheck({
        kind: "min",
        inclusive: true,
        value: Number.MIN_SAFE_INTEGER,
        message: errorUtil_js_1.errorUtil.toString(message)
      })._addCheck({
        kind: "max",
        inclusive: true,
        value: Number.MAX_SAFE_INTEGER,
        message: errorUtil_js_1.errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
    get isInt() {
      return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util_js_1.util.isInteger(ch.value));
    }
    get isFinite() {
      let max = null;
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
          return true;
        } else if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        } else if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return Number.isFinite(min) && Number.isFinite(max);
    }
  }
  types$1.ZodNumber = ZodNumber;
  ZodNumber.create = (params) => {
    return new ZodNumber({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodNumber,
      coerce: params?.coerce || false,
      ...processCreateParams(params)
    });
  };
  class ZodBigInt extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
    }
    _parse(input) {
      if (this._def.coerce) {
        try {
          input.data = BigInt(input.data);
        } catch {
          return this._getInvalidInput(input);
        }
      }
      const parsedType = this._getType(input);
      if (parsedType !== util_js_1.ZodParsedType.bigint) {
        return this._getInvalidInput(input);
      }
      let ctx = void 0;
      const status = new parseUtil_js_1.ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.too_small,
              type: "bigint",
              minimum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.too_big,
              type: "bigint",
              maximum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (input.data % check.value !== BigInt(0)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util_js_1.util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _getInvalidInput(input) {
      const ctx = this._getOrReturnCtx(input);
      (0, parseUtil_js_1.addIssueToContext)(ctx, {
        code: ZodError_js_1.ZodIssueCode.invalid_type,
        expected: util_js_1.ZodParsedType.bigint,
        received: ctx.parsedType
      });
      return parseUtil_js_1.INVALID;
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil_js_1.errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil_js_1.errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil_js_1.errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil_js_1.errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new ZodBigInt({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil_js_1.errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodBigInt({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil_js_1.errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil_js_1.errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil_js_1.errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil_js_1.errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil_js_1.errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  }
  types$1.ZodBigInt = ZodBigInt;
  ZodBigInt.create = (params) => {
    return new ZodBigInt({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodBigInt,
      coerce: params?.coerce ?? false,
      ...processCreateParams(params)
    });
  };
  class ZodBoolean extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = Boolean(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== util_js_1.ZodParsedType.boolean) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          code: ZodError_js_1.ZodIssueCode.invalid_type,
          expected: util_js_1.ZodParsedType.boolean,
          received: ctx.parsedType
        });
        return parseUtil_js_1.INVALID;
      }
      return (0, parseUtil_js_1.OK)(input.data);
    }
  }
  types$1.ZodBoolean = ZodBoolean;
  ZodBoolean.create = (params) => {
    return new ZodBoolean({
      typeName: ZodFirstPartyTypeKind.ZodBoolean,
      coerce: params?.coerce || false,
      ...processCreateParams(params)
    });
  };
  class ZodDate extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = new Date(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== util_js_1.ZodParsedType.date) {
        const ctx2 = this._getOrReturnCtx(input);
        (0, parseUtil_js_1.addIssueToContext)(ctx2, {
          code: ZodError_js_1.ZodIssueCode.invalid_type,
          expected: util_js_1.ZodParsedType.date,
          received: ctx2.parsedType
        });
        return parseUtil_js_1.INVALID;
      }
      if (Number.isNaN(input.data.getTime())) {
        const ctx2 = this._getOrReturnCtx(input);
        (0, parseUtil_js_1.addIssueToContext)(ctx2, {
          code: ZodError_js_1.ZodIssueCode.invalid_date
        });
        return parseUtil_js_1.INVALID;
      }
      const status = new parseUtil_js_1.ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.getTime() < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.too_small,
              message: check.message,
              inclusive: true,
              exact: false,
              minimum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.getTime() > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.too_big,
              message: check.message,
              inclusive: true,
              exact: false,
              maximum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else {
          util_js_1.util.assertNever(check);
        }
      }
      return {
        status: status.value,
        value: new Date(input.data.getTime())
      };
    }
    _addCheck(check) {
      return new ZodDate({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    min(minDate, message) {
      return this._addCheck({
        kind: "min",
        value: minDate.getTime(),
        message: errorUtil_js_1.errorUtil.toString(message)
      });
    }
    max(maxDate, message) {
      return this._addCheck({
        kind: "max",
        value: maxDate.getTime(),
        message: errorUtil_js_1.errorUtil.toString(message)
      });
    }
    get minDate() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min != null ? new Date(min) : null;
    }
    get maxDate() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max != null ? new Date(max) : null;
    }
  }
  types$1.ZodDate = ZodDate;
  ZodDate.create = (params) => {
    return new ZodDate({
      checks: [],
      coerce: params?.coerce || false,
      typeName: ZodFirstPartyTypeKind.ZodDate,
      ...processCreateParams(params)
    });
  };
  class ZodSymbol extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== util_js_1.ZodParsedType.symbol) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          code: ZodError_js_1.ZodIssueCode.invalid_type,
          expected: util_js_1.ZodParsedType.symbol,
          received: ctx.parsedType
        });
        return parseUtil_js_1.INVALID;
      }
      return (0, parseUtil_js_1.OK)(input.data);
    }
  }
  types$1.ZodSymbol = ZodSymbol;
  ZodSymbol.create = (params) => {
    return new ZodSymbol({
      typeName: ZodFirstPartyTypeKind.ZodSymbol,
      ...processCreateParams(params)
    });
  };
  class ZodUndefined extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== util_js_1.ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          code: ZodError_js_1.ZodIssueCode.invalid_type,
          expected: util_js_1.ZodParsedType.undefined,
          received: ctx.parsedType
        });
        return parseUtil_js_1.INVALID;
      }
      return (0, parseUtil_js_1.OK)(input.data);
    }
  }
  types$1.ZodUndefined = ZodUndefined;
  ZodUndefined.create = (params) => {
    return new ZodUndefined({
      typeName: ZodFirstPartyTypeKind.ZodUndefined,
      ...processCreateParams(params)
    });
  };
  class ZodNull extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== util_js_1.ZodParsedType.null) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          code: ZodError_js_1.ZodIssueCode.invalid_type,
          expected: util_js_1.ZodParsedType.null,
          received: ctx.parsedType
        });
        return parseUtil_js_1.INVALID;
      }
      return (0, parseUtil_js_1.OK)(input.data);
    }
  }
  types$1.ZodNull = ZodNull;
  ZodNull.create = (params) => {
    return new ZodNull({
      typeName: ZodFirstPartyTypeKind.ZodNull,
      ...processCreateParams(params)
    });
  };
  class ZodAny extends ZodType {
    constructor() {
      super(...arguments);
      this._any = true;
    }
    _parse(input) {
      return (0, parseUtil_js_1.OK)(input.data);
    }
  }
  types$1.ZodAny = ZodAny;
  ZodAny.create = (params) => {
    return new ZodAny({
      typeName: ZodFirstPartyTypeKind.ZodAny,
      ...processCreateParams(params)
    });
  };
  class ZodUnknown extends ZodType {
    constructor() {
      super(...arguments);
      this._unknown = true;
    }
    _parse(input) {
      return (0, parseUtil_js_1.OK)(input.data);
    }
  }
  types$1.ZodUnknown = ZodUnknown;
  ZodUnknown.create = (params) => {
    return new ZodUnknown({
      typeName: ZodFirstPartyTypeKind.ZodUnknown,
      ...processCreateParams(params)
    });
  };
  class ZodNever extends ZodType {
    _parse(input) {
      const ctx = this._getOrReturnCtx(input);
      (0, parseUtil_js_1.addIssueToContext)(ctx, {
        code: ZodError_js_1.ZodIssueCode.invalid_type,
        expected: util_js_1.ZodParsedType.never,
        received: ctx.parsedType
      });
      return parseUtil_js_1.INVALID;
    }
  }
  types$1.ZodNever = ZodNever;
  ZodNever.create = (params) => {
    return new ZodNever({
      typeName: ZodFirstPartyTypeKind.ZodNever,
      ...processCreateParams(params)
    });
  };
  class ZodVoid extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== util_js_1.ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          code: ZodError_js_1.ZodIssueCode.invalid_type,
          expected: util_js_1.ZodParsedType.void,
          received: ctx.parsedType
        });
        return parseUtil_js_1.INVALID;
      }
      return (0, parseUtil_js_1.OK)(input.data);
    }
  }
  types$1.ZodVoid = ZodVoid;
  ZodVoid.create = (params) => {
    return new ZodVoid({
      typeName: ZodFirstPartyTypeKind.ZodVoid,
      ...processCreateParams(params)
    });
  };
  class ZodArray extends ZodType {
    _parse(input) {
      const { ctx, status } = this._processInputParams(input);
      const def = this._def;
      if (ctx.parsedType !== util_js_1.ZodParsedType.array) {
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          code: ZodError_js_1.ZodIssueCode.invalid_type,
          expected: util_js_1.ZodParsedType.array,
          received: ctx.parsedType
        });
        return parseUtil_js_1.INVALID;
      }
      if (def.exactLength !== null) {
        const tooBig = ctx.data.length > def.exactLength.value;
        const tooSmall = ctx.data.length < def.exactLength.value;
        if (tooBig || tooSmall) {
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: tooBig ? ZodError_js_1.ZodIssueCode.too_big : ZodError_js_1.ZodIssueCode.too_small,
            minimum: tooSmall ? def.exactLength.value : void 0,
            maximum: tooBig ? def.exactLength.value : void 0,
            type: "array",
            inclusive: true,
            exact: true,
            message: def.exactLength.message
          });
          status.dirty();
        }
      }
      if (def.minLength !== null) {
        if (ctx.data.length < def.minLength.value) {
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.too_small,
            minimum: def.minLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.minLength.message
          });
          status.dirty();
        }
      }
      if (def.maxLength !== null) {
        if (ctx.data.length > def.maxLength.value) {
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.too_big,
            maximum: def.maxLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.maxLength.message
          });
          status.dirty();
        }
      }
      if (ctx.common.async) {
        return Promise.all([...ctx.data].map((item, i) => {
          return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        })).then((result2) => {
          return parseUtil_js_1.ParseStatus.mergeArray(status, result2);
        });
      }
      const result = [...ctx.data].map((item, i) => {
        return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      });
      return parseUtil_js_1.ParseStatus.mergeArray(status, result);
    }
    get element() {
      return this._def.type;
    }
    min(minLength, message) {
      return new ZodArray({
        ...this._def,
        minLength: { value: minLength, message: errorUtil_js_1.errorUtil.toString(message) }
      });
    }
    max(maxLength, message) {
      return new ZodArray({
        ...this._def,
        maxLength: { value: maxLength, message: errorUtil_js_1.errorUtil.toString(message) }
      });
    }
    length(len, message) {
      return new ZodArray({
        ...this._def,
        exactLength: { value: len, message: errorUtil_js_1.errorUtil.toString(message) }
      });
    }
    nonempty(message) {
      return this.min(1, message);
    }
  }
  types$1.ZodArray = ZodArray;
  ZodArray.create = (schema2, params) => {
    return new ZodArray({
      type: schema2,
      minLength: null,
      maxLength: null,
      exactLength: null,
      typeName: ZodFirstPartyTypeKind.ZodArray,
      ...processCreateParams(params)
    });
  };
  function deepPartialify(schema2) {
    if (schema2 instanceof ZodObject) {
      const newShape = {};
      for (const key2 in schema2.shape) {
        const fieldSchema = schema2.shape[key2];
        newShape[key2] = ZodOptional.create(deepPartialify(fieldSchema));
      }
      return new ZodObject({
        ...schema2._def,
        shape: () => newShape
      });
    } else if (schema2 instanceof ZodArray) {
      return new ZodArray({
        ...schema2._def,
        type: deepPartialify(schema2.element)
      });
    } else if (schema2 instanceof ZodOptional) {
      return ZodOptional.create(deepPartialify(schema2.unwrap()));
    } else if (schema2 instanceof ZodNullable) {
      return ZodNullable.create(deepPartialify(schema2.unwrap()));
    } else if (schema2 instanceof ZodTuple) {
      return ZodTuple.create(schema2.items.map((item) => deepPartialify(item)));
    } else {
      return schema2;
    }
  }
  class ZodObject extends ZodType {
    constructor() {
      super(...arguments);
      this._cached = null;
      this.nonstrict = this.passthrough;
      this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      const shape = this._def.shape();
      const keys = util_js_1.util.objectKeys(shape);
      this._cached = { shape, keys };
      return this._cached;
    }
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== util_js_1.ZodParsedType.object) {
        const ctx2 = this._getOrReturnCtx(input);
        (0, parseUtil_js_1.addIssueToContext)(ctx2, {
          code: ZodError_js_1.ZodIssueCode.invalid_type,
          expected: util_js_1.ZodParsedType.object,
          received: ctx2.parsedType
        });
        return parseUtil_js_1.INVALID;
      }
      const { status, ctx } = this._processInputParams(input);
      const { shape, keys: shapeKeys } = this._getCached();
      const extraKeys = [];
      if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
        for (const key2 in ctx.data) {
          if (!shapeKeys.includes(key2)) {
            extraKeys.push(key2);
          }
        }
      }
      const pairs = [];
      for (const key2 of shapeKeys) {
        const keyValidator = shape[key2];
        const value = ctx.data[key2];
        pairs.push({
          key: { status: "valid", value: key2 },
          value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key2)),
          alwaysSet: key2 in ctx.data
        });
      }
      if (this._def.catchall instanceof ZodNever) {
        const unknownKeys = this._def.unknownKeys;
        if (unknownKeys === "passthrough") {
          for (const key2 of extraKeys) {
            pairs.push({
              key: { status: "valid", value: key2 },
              value: { status: "valid", value: ctx.data[key2] }
            });
          }
        } else if (unknownKeys === "strict") {
          if (extraKeys.length > 0) {
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.unrecognized_keys,
              keys: extraKeys
            });
            status.dirty();
          }
        } else if (unknownKeys === "strip") ;
        else {
          throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
        }
      } else {
        const catchall = this._def.catchall;
        for (const key2 of extraKeys) {
          const value = ctx.data[key2];
          pairs.push({
            key: { status: "valid", value: key2 },
            value: catchall._parse(
              new ParseInputLazyPath(ctx, value, ctx.path, key2)
              //, ctx.child(key), value, getParsedType(value)
            ),
            alwaysSet: key2 in ctx.data
          });
        }
      }
      if (ctx.common.async) {
        return Promise.resolve().then(async () => {
          const syncPairs = [];
          for (const pair of pairs) {
            const key2 = await pair.key;
            const value = await pair.value;
            syncPairs.push({
              key: key2,
              value,
              alwaysSet: pair.alwaysSet
            });
          }
          return syncPairs;
        }).then((syncPairs) => {
          return parseUtil_js_1.ParseStatus.mergeObjectSync(status, syncPairs);
        });
      } else {
        return parseUtil_js_1.ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get shape() {
      return this._def.shape();
    }
    strict(message) {
      errorUtil_js_1.errorUtil.errToObj;
      return new ZodObject({
        ...this._def,
        unknownKeys: "strict",
        ...message !== void 0 ? {
          errorMap: (issue, ctx) => {
            const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
            if (issue.code === "unrecognized_keys")
              return {
                message: errorUtil_js_1.errorUtil.errToObj(message).message ?? defaultError
              };
            return {
              message: defaultError
            };
          }
        } : {}
      });
    }
    strip() {
      return new ZodObject({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new ZodObject({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(augmentation) {
      return new ZodObject({
        ...this._def,
        shape: () => ({
          ...this._def.shape(),
          ...augmentation
        })
      });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(merging) {
      const merged = new ZodObject({
        unknownKeys: merging._def.unknownKeys,
        catchall: merging._def.catchall,
        shape: () => ({
          ...this._def.shape(),
          ...merging._def.shape()
        }),
        typeName: ZodFirstPartyTypeKind.ZodObject
      });
      return merged;
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(key2, schema2) {
      return this.augment({ [key2]: schema2 });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(index) {
      return new ZodObject({
        ...this._def,
        catchall: index
      });
    }
    pick(mask) {
      const shape = {};
      for (const key2 of util_js_1.util.objectKeys(mask)) {
        if (mask[key2] && this.shape[key2]) {
          shape[key2] = this.shape[key2];
        }
      }
      return new ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    omit(mask) {
      const shape = {};
      for (const key2 of util_js_1.util.objectKeys(this.shape)) {
        if (!mask[key2]) {
          shape[key2] = this.shape[key2];
        }
      }
      return new ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    /**
     * @deprecated
     */
    deepPartial() {
      return deepPartialify(this);
    }
    partial(mask) {
      const newShape = {};
      for (const key2 of util_js_1.util.objectKeys(this.shape)) {
        const fieldSchema = this.shape[key2];
        if (mask && !mask[key2]) {
          newShape[key2] = fieldSchema;
        } else {
          newShape[key2] = fieldSchema.optional();
        }
      }
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    required(mask) {
      const newShape = {};
      for (const key2 of util_js_1.util.objectKeys(this.shape)) {
        if (mask && !mask[key2]) {
          newShape[key2] = this.shape[key2];
        } else {
          const fieldSchema = this.shape[key2];
          let newField = fieldSchema;
          while (newField instanceof ZodOptional) {
            newField = newField._def.innerType;
          }
          newShape[key2] = newField;
        }
      }
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    keyof() {
      return createZodEnum(util_js_1.util.objectKeys(this.shape));
    }
  }
  types$1.ZodObject = ZodObject;
  ZodObject.create = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strict",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
      shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  class ZodUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const options = this._def.options;
      function handleResults(results) {
        for (const result of results) {
          if (result.result.status === "valid") {
            return result.result;
          }
        }
        for (const result of results) {
          if (result.result.status === "dirty") {
            ctx.common.issues.push(...result.ctx.common.issues);
            return result.result;
          }
        }
        const unionErrors = results.map((result) => new ZodError_js_1.ZodError(result.ctx.common.issues));
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          code: ZodError_js_1.ZodIssueCode.invalid_union,
          unionErrors
        });
        return parseUtil_js_1.INVALID;
      }
      if (ctx.common.async) {
        return Promise.all(options.map(async (option) => {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            }),
            ctx: childCtx
          };
        })).then(handleResults);
      } else {
        let dirty = void 0;
        const issues = [];
        for (const option of options) {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          const result = option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          });
          if (result.status === "valid") {
            return result;
          } else if (result.status === "dirty" && !dirty) {
            dirty = { result, ctx: childCtx };
          }
          if (childCtx.common.issues.length) {
            issues.push(childCtx.common.issues);
          }
        }
        if (dirty) {
          ctx.common.issues.push(...dirty.ctx.common.issues);
          return dirty.result;
        }
        const unionErrors = issues.map((issues2) => new ZodError_js_1.ZodError(issues2));
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          code: ZodError_js_1.ZodIssueCode.invalid_union,
          unionErrors
        });
        return parseUtil_js_1.INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  }
  types$1.ZodUnion = ZodUnion;
  ZodUnion.create = (types2, params) => {
    return new ZodUnion({
      options: types2,
      typeName: ZodFirstPartyTypeKind.ZodUnion,
      ...processCreateParams(params)
    });
  };
  const getDiscriminator = (type) => {
    if (type instanceof ZodLazy) {
      return getDiscriminator(type.schema);
    } else if (type instanceof ZodEffects) {
      return getDiscriminator(type.innerType());
    } else if (type instanceof ZodLiteral) {
      return [type.value];
    } else if (type instanceof ZodEnum) {
      return type.options;
    } else if (type instanceof ZodNativeEnum) {
      return util_js_1.util.objectValues(type.enum);
    } else if (type instanceof ZodDefault) {
      return getDiscriminator(type._def.innerType);
    } else if (type instanceof ZodUndefined) {
      return [void 0];
    } else if (type instanceof ZodNull) {
      return [null];
    } else if (type instanceof ZodOptional) {
      return [void 0, ...getDiscriminator(type.unwrap())];
    } else if (type instanceof ZodNullable) {
      return [null, ...getDiscriminator(type.unwrap())];
    } else if (type instanceof ZodBranded) {
      return getDiscriminator(type.unwrap());
    } else if (type instanceof ZodReadonly) {
      return getDiscriminator(type.unwrap());
    } else if (type instanceof ZodCatch) {
      return getDiscriminator(type._def.innerType);
    } else {
      return [];
    }
  };
  class ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== util_js_1.ZodParsedType.object) {
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          code: ZodError_js_1.ZodIssueCode.invalid_type,
          expected: util_js_1.ZodParsedType.object,
          received: ctx.parsedType
        });
        return parseUtil_js_1.INVALID;
      }
      const discriminator = this.discriminator;
      const discriminatorValue = ctx.data[discriminator];
      const option = this.optionsMap.get(discriminatorValue);
      if (!option) {
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          code: ZodError_js_1.ZodIssueCode.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [discriminator]
        });
        return parseUtil_js_1.INVALID;
      }
      if (ctx.common.async) {
        return option._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      } else {
        return option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(discriminator, options, params) {
      const optionsMap = /* @__PURE__ */ new Map();
      for (const type of options) {
        const discriminatorValues = getDiscriminator(type.shape[discriminator]);
        if (!discriminatorValues.length) {
          throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
        }
        for (const value of discriminatorValues) {
          if (optionsMap.has(value)) {
            throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
          }
          optionsMap.set(value, type);
        }
      }
      return new ZodDiscriminatedUnion({
        typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
        discriminator,
        options,
        optionsMap,
        ...processCreateParams(params)
      });
    }
  }
  types$1.ZodDiscriminatedUnion = ZodDiscriminatedUnion;
  function mergeValues(a2, b2) {
    const aType = (0, util_js_1.getParsedType)(a2);
    const bType = (0, util_js_1.getParsedType)(b2);
    if (a2 === b2) {
      return { valid: true, data: a2 };
    } else if (aType === util_js_1.ZodParsedType.object && bType === util_js_1.ZodParsedType.object) {
      const bKeys = util_js_1.util.objectKeys(b2);
      const sharedKeys = util_js_1.util.objectKeys(a2).filter((key2) => bKeys.indexOf(key2) !== -1);
      const newObj = { ...a2, ...b2 };
      for (const key2 of sharedKeys) {
        const sharedValue = mergeValues(a2[key2], b2[key2]);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newObj[key2] = sharedValue.data;
      }
      return { valid: true, data: newObj };
    } else if (aType === util_js_1.ZodParsedType.array && bType === util_js_1.ZodParsedType.array) {
      if (a2.length !== b2.length) {
        return { valid: false };
      }
      const newArray = [];
      for (let index = 0; index < a2.length; index++) {
        const itemA = a2[index];
        const itemB = b2[index];
        const sharedValue = mergeValues(itemA, itemB);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newArray.push(sharedValue.data);
      }
      return { valid: true, data: newArray };
    } else if (aType === util_js_1.ZodParsedType.date && bType === util_js_1.ZodParsedType.date && +a2 === +b2) {
      return { valid: true, data: a2 };
    } else {
      return { valid: false };
    }
  }
  class ZodIntersection extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const handleParsed = (parsedLeft, parsedRight) => {
        if ((0, parseUtil_js_1.isAborted)(parsedLeft) || (0, parseUtil_js_1.isAborted)(parsedRight)) {
          return parseUtil_js_1.INVALID;
        }
        const merged = mergeValues(parsedLeft.value, parsedRight.value);
        if (!merged.valid) {
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_intersection_types
          });
          return parseUtil_js_1.INVALID;
        }
        if ((0, parseUtil_js_1.isDirty)(parsedLeft) || (0, parseUtil_js_1.isDirty)(parsedRight)) {
          status.dirty();
        }
        return { status: status.value, value: merged.data };
      };
      if (ctx.common.async) {
        return Promise.all([
          this._def.left._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }),
          this._def.right._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          })
        ]).then(([left, right]) => handleParsed(left, right));
      } else {
        return handleParsed(this._def.left._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }), this._def.right._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }));
      }
    }
  }
  types$1.ZodIntersection = ZodIntersection;
  ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
      left,
      right,
      typeName: ZodFirstPartyTypeKind.ZodIntersection,
      ...processCreateParams(params)
    });
  };
  class ZodTuple extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== util_js_1.ZodParsedType.array) {
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          code: ZodError_js_1.ZodIssueCode.invalid_type,
          expected: util_js_1.ZodParsedType.array,
          received: ctx.parsedType
        });
        return parseUtil_js_1.INVALID;
      }
      if (ctx.data.length < this._def.items.length) {
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          code: ZodError_js_1.ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        return parseUtil_js_1.INVALID;
      }
      const rest = this._def.rest;
      if (!rest && ctx.data.length > this._def.items.length) {
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          code: ZodError_js_1.ZodIssueCode.too_big,
          maximum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        status.dirty();
      }
      const items = [...ctx.data].map((item, itemIndex) => {
        const schema2 = this._def.items[itemIndex] || this._def.rest;
        if (!schema2)
          return null;
        return schema2._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
      }).filter((x2) => !!x2);
      if (ctx.common.async) {
        return Promise.all(items).then((results) => {
          return parseUtil_js_1.ParseStatus.mergeArray(status, results);
        });
      } else {
        return parseUtil_js_1.ParseStatus.mergeArray(status, items);
      }
    }
    get items() {
      return this._def.items;
    }
    rest(rest) {
      return new ZodTuple({
        ...this._def,
        rest
      });
    }
  }
  types$1.ZodTuple = ZodTuple;
  ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
      items: schemas,
      typeName: ZodFirstPartyTypeKind.ZodTuple,
      rest: null,
      ...processCreateParams(params)
    });
  };
  class ZodRecord extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== util_js_1.ZodParsedType.object) {
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          code: ZodError_js_1.ZodIssueCode.invalid_type,
          expected: util_js_1.ZodParsedType.object,
          received: ctx.parsedType
        });
        return parseUtil_js_1.INVALID;
      }
      const pairs = [];
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      for (const key2 in ctx.data) {
        pairs.push({
          key: keyType._parse(new ParseInputLazyPath(ctx, key2, ctx.path, key2)),
          value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key2], ctx.path, key2)),
          alwaysSet: key2 in ctx.data
        });
      }
      if (ctx.common.async) {
        return parseUtil_js_1.ParseStatus.mergeObjectAsync(status, pairs);
      } else {
        return parseUtil_js_1.ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get element() {
      return this._def.valueType;
    }
    static create(first, second, third) {
      if (second instanceof ZodType) {
        return new ZodRecord({
          keyType: first,
          valueType: second,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(third)
        });
      }
      return new ZodRecord({
        keyType: ZodString.create(),
        valueType: first,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(second)
      });
    }
  }
  types$1.ZodRecord = ZodRecord;
  class ZodMap extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== util_js_1.ZodParsedType.map) {
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          code: ZodError_js_1.ZodIssueCode.invalid_type,
          expected: util_js_1.ZodParsedType.map,
          received: ctx.parsedType
        });
        return parseUtil_js_1.INVALID;
      }
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      const pairs = [...ctx.data.entries()].map(([key2, value], index) => {
        return {
          key: keyType._parse(new ParseInputLazyPath(ctx, key2, ctx.path, [index, "key"])),
          value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
        };
      });
      if (ctx.common.async) {
        const finalMap = /* @__PURE__ */ new Map();
        return Promise.resolve().then(async () => {
          for (const pair of pairs) {
            const key2 = await pair.key;
            const value = await pair.value;
            if (key2.status === "aborted" || value.status === "aborted") {
              return parseUtil_js_1.INVALID;
            }
            if (key2.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key2.value, value.value);
          }
          return { status: status.value, value: finalMap };
        });
      } else {
        const finalMap = /* @__PURE__ */ new Map();
        for (const pair of pairs) {
          const key2 = pair.key;
          const value = pair.value;
          if (key2.status === "aborted" || value.status === "aborted") {
            return parseUtil_js_1.INVALID;
          }
          if (key2.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key2.value, value.value);
        }
        return { status: status.value, value: finalMap };
      }
    }
  }
  types$1.ZodMap = ZodMap;
  ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
      valueType,
      keyType,
      typeName: ZodFirstPartyTypeKind.ZodMap,
      ...processCreateParams(params)
    });
  };
  class ZodSet extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== util_js_1.ZodParsedType.set) {
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          code: ZodError_js_1.ZodIssueCode.invalid_type,
          expected: util_js_1.ZodParsedType.set,
          received: ctx.parsedType
        });
        return parseUtil_js_1.INVALID;
      }
      const def = this._def;
      if (def.minSize !== null) {
        if (ctx.data.size < def.minSize.value) {
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.too_small,
            minimum: def.minSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.minSize.message
          });
          status.dirty();
        }
      }
      if (def.maxSize !== null) {
        if (ctx.data.size > def.maxSize.value) {
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.too_big,
            maximum: def.maxSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.maxSize.message
          });
          status.dirty();
        }
      }
      const valueType = this._def.valueType;
      function finalizeSet(elements2) {
        const parsedSet = /* @__PURE__ */ new Set();
        for (const element of elements2) {
          if (element.status === "aborted")
            return parseUtil_js_1.INVALID;
          if (element.status === "dirty")
            status.dirty();
          parsedSet.add(element.value);
        }
        return { status: status.value, value: parsedSet };
      }
      const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
      if (ctx.common.async) {
        return Promise.all(elements).then((elements2) => finalizeSet(elements2));
      } else {
        return finalizeSet(elements);
      }
    }
    min(minSize, message) {
      return new ZodSet({
        ...this._def,
        minSize: { value: minSize, message: errorUtil_js_1.errorUtil.toString(message) }
      });
    }
    max(maxSize, message) {
      return new ZodSet({
        ...this._def,
        maxSize: { value: maxSize, message: errorUtil_js_1.errorUtil.toString(message) }
      });
    }
    size(size, message) {
      return this.min(size, message).max(size, message);
    }
    nonempty(message) {
      return this.min(1, message);
    }
  }
  types$1.ZodSet = ZodSet;
  ZodSet.create = (valueType, params) => {
    return new ZodSet({
      valueType,
      minSize: null,
      maxSize: null,
      typeName: ZodFirstPartyTypeKind.ZodSet,
      ...processCreateParams(params)
    });
  };
  class ZodFunction extends ZodType {
    constructor() {
      super(...arguments);
      this.validate = this.implement;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== util_js_1.ZodParsedType.function) {
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          code: ZodError_js_1.ZodIssueCode.invalid_type,
          expected: util_js_1.ZodParsedType.function,
          received: ctx.parsedType
        });
        return parseUtil_js_1.INVALID;
      }
      function makeArgsIssue(args, error2) {
        return (0, parseUtil_js_1.makeIssue)({
          data: args,
          path: ctx.path,
          errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, (0, errors_js_1.getErrorMap)(), errors_js_1.defaultErrorMap].filter((x2) => !!x2),
          issueData: {
            code: ZodError_js_1.ZodIssueCode.invalid_arguments,
            argumentsError: error2
          }
        });
      }
      function makeReturnsIssue(returns, error2) {
        return (0, parseUtil_js_1.makeIssue)({
          data: returns,
          path: ctx.path,
          errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, (0, errors_js_1.getErrorMap)(), errors_js_1.defaultErrorMap].filter((x2) => !!x2),
          issueData: {
            code: ZodError_js_1.ZodIssueCode.invalid_return_type,
            returnTypeError: error2
          }
        });
      }
      const params = { errorMap: ctx.common.contextualErrorMap };
      const fn2 = ctx.data;
      if (this._def.returns instanceof ZodPromise) {
        const me2 = this;
        return (0, parseUtil_js_1.OK)(async function(...args) {
          const error2 = new ZodError_js_1.ZodError([]);
          const parsedArgs = await me2._def.args.parseAsync(args, params).catch((e) => {
            error2.addIssue(makeArgsIssue(args, e));
            throw error2;
          });
          const result = await Reflect.apply(fn2, this, parsedArgs);
          const parsedReturns = await me2._def.returns._def.type.parseAsync(result, params).catch((e) => {
            error2.addIssue(makeReturnsIssue(result, e));
            throw error2;
          });
          return parsedReturns;
        });
      } else {
        const me2 = this;
        return (0, parseUtil_js_1.OK)(function(...args) {
          const parsedArgs = me2._def.args.safeParse(args, params);
          if (!parsedArgs.success) {
            throw new ZodError_js_1.ZodError([makeArgsIssue(args, parsedArgs.error)]);
          }
          const result = Reflect.apply(fn2, this, parsedArgs.data);
          const parsedReturns = me2._def.returns.safeParse(result, params);
          if (!parsedReturns.success) {
            throw new ZodError_js_1.ZodError([makeReturnsIssue(result, parsedReturns.error)]);
          }
          return parsedReturns.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...items) {
      return new ZodFunction({
        ...this._def,
        args: ZodTuple.create(items).rest(ZodUnknown.create())
      });
    }
    returns(returnType) {
      return new ZodFunction({
        ...this._def,
        returns: returnType
      });
    }
    implement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    strictImplement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    static create(args, returns, params) {
      return new ZodFunction({
        args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
        returns: returns || ZodUnknown.create(),
        typeName: ZodFirstPartyTypeKind.ZodFunction,
        ...processCreateParams(params)
      });
    }
  }
  types$1.ZodFunction = ZodFunction;
  class ZodLazy extends ZodType {
    get schema() {
      return this._def.getter();
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const lazySchema = this._def.getter();
      return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
  }
  types$1.ZodLazy = ZodLazy;
  ZodLazy.create = (getter, params) => {
    return new ZodLazy({
      getter,
      typeName: ZodFirstPartyTypeKind.ZodLazy,
      ...processCreateParams(params)
    });
  };
  class ZodLiteral extends ZodType {
    _parse(input) {
      if (input.data !== this._def.value) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          received: ctx.data,
          code: ZodError_js_1.ZodIssueCode.invalid_literal,
          expected: this._def.value
        });
        return parseUtil_js_1.INVALID;
      }
      return { status: "valid", value: input.data };
    }
    get value() {
      return this._def.value;
    }
  }
  types$1.ZodLiteral = ZodLiteral;
  ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
      value,
      typeName: ZodFirstPartyTypeKind.ZodLiteral,
      ...processCreateParams(params)
    });
  };
  function createZodEnum(values, params) {
    return new ZodEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodEnum,
      ...processCreateParams(params)
    });
  }
  class ZodEnum extends ZodType {
    _parse(input) {
      if (typeof input.data !== "string") {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          expected: util_js_1.util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodError_js_1.ZodIssueCode.invalid_type
        });
        return parseUtil_js_1.INVALID;
      }
      if (!this._cache) {
        this._cache = new Set(this._def.values);
      }
      if (!this._cache.has(input.data)) {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          received: ctx.data,
          code: ZodError_js_1.ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return parseUtil_js_1.INVALID;
      }
      return (0, parseUtil_js_1.OK)(input.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Values() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    extract(values, newDef = this._def) {
      return ZodEnum.create(values, {
        ...this._def,
        ...newDef
      });
    }
    exclude(values, newDef = this._def) {
      return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
        ...this._def,
        ...newDef
      });
    }
  }
  types$1.ZodEnum = ZodEnum;
  ZodEnum.create = createZodEnum;
  class ZodNativeEnum extends ZodType {
    _parse(input) {
      const nativeEnumValues = util_js_1.util.getValidEnumValues(this._def.values);
      const ctx = this._getOrReturnCtx(input);
      if (ctx.parsedType !== util_js_1.ZodParsedType.string && ctx.parsedType !== util_js_1.ZodParsedType.number) {
        const expectedValues = util_js_1.util.objectValues(nativeEnumValues);
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          expected: util_js_1.util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodError_js_1.ZodIssueCode.invalid_type
        });
        return parseUtil_js_1.INVALID;
      }
      if (!this._cache) {
        this._cache = new Set(util_js_1.util.getValidEnumValues(this._def.values));
      }
      if (!this._cache.has(input.data)) {
        const expectedValues = util_js_1.util.objectValues(nativeEnumValues);
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          received: ctx.data,
          code: ZodError_js_1.ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return parseUtil_js_1.INVALID;
      }
      return (0, parseUtil_js_1.OK)(input.data);
    }
    get enum() {
      return this._def.values;
    }
  }
  types$1.ZodNativeEnum = ZodNativeEnum;
  ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
      ...processCreateParams(params)
    });
  };
  class ZodPromise extends ZodType {
    unwrap() {
      return this._def.type;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== util_js_1.ZodParsedType.promise && ctx.common.async === false) {
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          code: ZodError_js_1.ZodIssueCode.invalid_type,
          expected: util_js_1.ZodParsedType.promise,
          received: ctx.parsedType
        });
        return parseUtil_js_1.INVALID;
      }
      const promisified = ctx.parsedType === util_js_1.ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
      return (0, parseUtil_js_1.OK)(promisified.then((data) => {
        return this._def.type.parseAsync(data, {
          path: ctx.path,
          errorMap: ctx.common.contextualErrorMap
        });
      }));
    }
  }
  types$1.ZodPromise = ZodPromise;
  ZodPromise.create = (schema2, params) => {
    return new ZodPromise({
      type: schema2,
      typeName: ZodFirstPartyTypeKind.ZodPromise,
      ...processCreateParams(params)
    });
  };
  class ZodEffects extends ZodType {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const effect = this._def.effect || null;
      const checkCtx = {
        addIssue: (arg) => {
          (0, parseUtil_js_1.addIssueToContext)(ctx, arg);
          if (arg.fatal) {
            status.abort();
          } else {
            status.dirty();
          }
        },
        get path() {
          return ctx.path;
        }
      };
      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
      if (effect.type === "preprocess") {
        const processed = effect.transform(ctx.data, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(processed).then(async (processed2) => {
            if (status.value === "aborted")
              return parseUtil_js_1.INVALID;
            const result = await this._def.schema._parseAsync({
              data: processed2,
              path: ctx.path,
              parent: ctx
            });
            if (result.status === "aborted")
              return parseUtil_js_1.INVALID;
            if (result.status === "dirty")
              return (0, parseUtil_js_1.DIRTY)(result.value);
            if (status.value === "dirty")
              return (0, parseUtil_js_1.DIRTY)(result.value);
            return result;
          });
        } else {
          if (status.value === "aborted")
            return parseUtil_js_1.INVALID;
          const result = this._def.schema._parseSync({
            data: processed,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return parseUtil_js_1.INVALID;
          if (result.status === "dirty")
            return (0, parseUtil_js_1.DIRTY)(result.value);
          if (status.value === "dirty")
            return (0, parseUtil_js_1.DIRTY)(result.value);
          return result;
        }
      }
      if (effect.type === "refinement") {
        const executeRefinement = (acc) => {
          const result = effect.refinement(acc, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(result);
          }
          if (result instanceof Promise) {
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          }
          return acc;
        };
        if (ctx.common.async === false) {
          const inner = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inner.status === "aborted")
            return parseUtil_js_1.INVALID;
          if (inner.status === "dirty")
            status.dirty();
          executeRefinement(inner.value);
          return { status: status.value, value: inner.value };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
            if (inner.status === "aborted")
              return parseUtil_js_1.INVALID;
            if (inner.status === "dirty")
              status.dirty();
            return executeRefinement(inner.value).then(() => {
              return { status: status.value, value: inner.value };
            });
          });
        }
      }
      if (effect.type === "transform") {
        if (ctx.common.async === false) {
          const base2 = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (!(0, parseUtil_js_1.isValid)(base2))
            return parseUtil_js_1.INVALID;
          const result = effect.transform(base2.value, checkCtx);
          if (result instanceof Promise) {
            throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
          }
          return { status: status.value, value: result };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base2) => {
            if (!(0, parseUtil_js_1.isValid)(base2))
              return parseUtil_js_1.INVALID;
            return Promise.resolve(effect.transform(base2.value, checkCtx)).then((result) => ({
              status: status.value,
              value: result
            }));
          });
        }
      }
      util_js_1.util.assertNever(effect);
    }
  }
  types$1.ZodEffects = ZodEffects;
  types$1.ZodTransformer = ZodEffects;
  ZodEffects.create = (schema2, effect, params) => {
    return new ZodEffects({
      schema: schema2,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect,
      ...processCreateParams(params)
    });
  };
  ZodEffects.createWithPreprocess = (preprocess, schema2, params) => {
    return new ZodEffects({
      schema: schema2,
      effect: { type: "preprocess", transform: preprocess },
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      ...processCreateParams(params)
    });
  };
  class ZodOptional extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === util_js_1.ZodParsedType.undefined) {
        return (0, parseUtil_js_1.OK)(void 0);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  types$1.ZodOptional = ZodOptional;
  ZodOptional.create = (type, params) => {
    return new ZodOptional({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodOptional,
      ...processCreateParams(params)
    });
  };
  class ZodNullable extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === util_js_1.ZodParsedType.null) {
        return (0, parseUtil_js_1.OK)(null);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  types$1.ZodNullable = ZodNullable;
  ZodNullable.create = (type, params) => {
    return new ZodNullable({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodNullable,
      ...processCreateParams(params)
    });
  };
  class ZodDefault extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      let data = ctx.data;
      if (ctx.parsedType === util_js_1.ZodParsedType.undefined) {
        data = this._def.defaultValue();
      }
      return this._def.innerType._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  }
  types$1.ZodDefault = ZodDefault;
  ZodDefault.create = (type, params) => {
    return new ZodDefault({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodDefault,
      defaultValue: typeof params.default === "function" ? params.default : () => params.default,
      ...processCreateParams(params)
    });
  };
  class ZodCatch extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const newCtx = {
        ...ctx,
        common: {
          ...ctx.common,
          issues: []
        }
      };
      const result = this._def.innerType._parse({
        data: newCtx.data,
        path: newCtx.path,
        parent: {
          ...newCtx
        }
      });
      if ((0, parseUtil_js_1.isAsync)(result)) {
        return result.then((result2) => {
          return {
            status: "valid",
            value: result2.status === "valid" ? result2.value : this._def.catchValue({
              get error() {
                return new ZodError_js_1.ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        });
      } else {
        return {
          status: "valid",
          value: result.status === "valid" ? result.value : this._def.catchValue({
            get error() {
              return new ZodError_js_1.ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      }
    }
    removeCatch() {
      return this._def.innerType;
    }
  }
  types$1.ZodCatch = ZodCatch;
  ZodCatch.create = (type, params) => {
    return new ZodCatch({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodCatch,
      catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
      ...processCreateParams(params)
    });
  };
  class ZodNaN extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== util_js_1.ZodParsedType.nan) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          code: ZodError_js_1.ZodIssueCode.invalid_type,
          expected: util_js_1.ZodParsedType.nan,
          received: ctx.parsedType
        });
        return parseUtil_js_1.INVALID;
      }
      return { status: "valid", value: input.data };
    }
  }
  types$1.ZodNaN = ZodNaN;
  ZodNaN.create = (params) => {
    return new ZodNaN({
      typeName: ZodFirstPartyTypeKind.ZodNaN,
      ...processCreateParams(params)
    });
  };
  types$1.BRAND = Symbol("zod_brand");
  class ZodBranded extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const data = ctx.data;
      return this._def.type._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    unwrap() {
      return this._def.type;
    }
  }
  types$1.ZodBranded = ZodBranded;
  class ZodPipeline extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.common.async) {
        const handleAsync = async () => {
          const inResult = await this._def.in._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return parseUtil_js_1.INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return (0, parseUtil_js_1.DIRTY)(inResult.value);
          } else {
            return this._def.out._parseAsync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        };
        return handleAsync();
      } else {
        const inResult = this._def.in._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return parseUtil_js_1.INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return {
            status: "dirty",
            value: inResult.value
          };
        } else {
          return this._def.out._parseSync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }
    }
    static create(a2, b2) {
      return new ZodPipeline({
        in: a2,
        out: b2,
        typeName: ZodFirstPartyTypeKind.ZodPipeline
      });
    }
  }
  types$1.ZodPipeline = ZodPipeline;
  class ZodReadonly extends ZodType {
    _parse(input) {
      const result = this._def.innerType._parse(input);
      const freeze = (data) => {
        if ((0, parseUtil_js_1.isValid)(data)) {
          data.value = Object.freeze(data.value);
        }
        return data;
      };
      return (0, parseUtil_js_1.isAsync)(result) ? result.then((data) => freeze(data)) : freeze(result);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  types$1.ZodReadonly = ZodReadonly;
  ZodReadonly.create = (type, params) => {
    return new ZodReadonly({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodReadonly,
      ...processCreateParams(params)
    });
  };
  function cleanParams(params, data) {
    const p2 = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
    const p22 = typeof p2 === "string" ? { message: p2 } : p2;
    return p22;
  }
  function custom(check, _params = {}, fatal) {
    if (check)
      return ZodAny.create().superRefine((data, ctx) => {
        const r = check(data);
        if (r instanceof Promise) {
          return r.then((r2) => {
            if (!r2) {
              const params = cleanParams(_params, data);
              const _fatal = params.fatal ?? fatal ?? true;
              ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
            }
          });
        }
        if (!r) {
          const params = cleanParams(_params, data);
          const _fatal = params.fatal ?? fatal ?? true;
          ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
        }
        return;
      });
    return ZodAny.create();
  }
  types$1.late = {
    object: ZodObject.lazycreate
  };
  var ZodFirstPartyTypeKind;
  (function(ZodFirstPartyTypeKind2) {
    ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
  })(ZodFirstPartyTypeKind || (types$1.ZodFirstPartyTypeKind = ZodFirstPartyTypeKind = {}));
  const instanceOfType = (cls, params = {
    message: `Input not instance of ${cls.name}`
  }) => custom((data) => data instanceof cls, params);
  types$1.instanceof = instanceOfType;
  const stringType = ZodString.create;
  types$1.string = stringType;
  const numberType = ZodNumber.create;
  types$1.number = numberType;
  const nanType = ZodNaN.create;
  types$1.nan = nanType;
  const bigIntType = ZodBigInt.create;
  types$1.bigint = bigIntType;
  const booleanType = ZodBoolean.create;
  types$1.boolean = booleanType;
  const dateType = ZodDate.create;
  types$1.date = dateType;
  const symbolType = ZodSymbol.create;
  types$1.symbol = symbolType;
  const undefinedType = ZodUndefined.create;
  types$1.undefined = undefinedType;
  const nullType = ZodNull.create;
  types$1.null = nullType;
  const anyType = ZodAny.create;
  types$1.any = anyType;
  const unknownType = ZodUnknown.create;
  types$1.unknown = unknownType;
  const neverType = ZodNever.create;
  types$1.never = neverType;
  const voidType = ZodVoid.create;
  types$1.void = voidType;
  const arrayType = ZodArray.create;
  types$1.array = arrayType;
  const objectType = ZodObject.create;
  types$1.object = objectType;
  const strictObjectType = ZodObject.strictCreate;
  types$1.strictObject = strictObjectType;
  const unionType = ZodUnion.create;
  types$1.union = unionType;
  const discriminatedUnionType = ZodDiscriminatedUnion.create;
  types$1.discriminatedUnion = discriminatedUnionType;
  const intersectionType = ZodIntersection.create;
  types$1.intersection = intersectionType;
  const tupleType = ZodTuple.create;
  types$1.tuple = tupleType;
  const recordType = ZodRecord.create;
  types$1.record = recordType;
  const mapType = ZodMap.create;
  types$1.map = mapType;
  const setType = ZodSet.create;
  types$1.set = setType;
  const functionType = ZodFunction.create;
  types$1.function = functionType;
  const lazyType = ZodLazy.create;
  types$1.lazy = lazyType;
  const literalType = ZodLiteral.create;
  types$1.literal = literalType;
  const enumType = ZodEnum.create;
  types$1.enum = enumType;
  const nativeEnumType = ZodNativeEnum.create;
  types$1.nativeEnum = nativeEnumType;
  const promiseType = ZodPromise.create;
  types$1.promise = promiseType;
  const effectsType = ZodEffects.create;
  types$1.effect = effectsType;
  types$1.transformer = effectsType;
  const optionalType = ZodOptional.create;
  types$1.optional = optionalType;
  const nullableType = ZodNullable.create;
  types$1.nullable = nullableType;
  const preprocessType = ZodEffects.createWithPreprocess;
  types$1.preprocess = preprocessType;
  const pipelineType = ZodPipeline.create;
  types$1.pipeline = pipelineType;
  const ostring = () => stringType().optional();
  types$1.ostring = ostring;
  const onumber = () => numberType().optional();
  types$1.onumber = onumber;
  const oboolean = () => booleanType().optional();
  types$1.oboolean = oboolean;
  types$1.coerce = {
    string: ((arg) => ZodString.create({ ...arg, coerce: true })),
    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),
    boolean: ((arg) => ZodBoolean.create({
      ...arg,
      coerce: true
    })),
    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),
    date: ((arg) => ZodDate.create({ ...arg, coerce: true }))
  };
  types$1.NEVER = parseUtil_js_1.INVALID;
  return types$1;
}
var hasRequiredExternal;
function requireExternal() {
  if (hasRequiredExternal) return external;
  hasRequiredExternal = 1;
  (function(exports) {
    var __createBinding = external && external.__createBinding || (Object.create ? (function(o4, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o4, k22, desc);
    }) : (function(o4, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o4[k22] = m2[k2];
    }));
    var __exportStar = external && external.__exportStar || function(m2, exports2) {
      for (var p2 in m2) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(/* @__PURE__ */ requireErrors(), exports);
    __exportStar(/* @__PURE__ */ requireParseUtil(), exports);
    __exportStar(/* @__PURE__ */ requireTypeAliases(), exports);
    __exportStar(/* @__PURE__ */ requireUtil(), exports);
    __exportStar(/* @__PURE__ */ requireTypes$1(), exports);
    __exportStar(/* @__PURE__ */ requireZodError(), exports);
  })(external);
  return external;
}
var hasRequiredZod;
function requireZod() {
  if (hasRequiredZod) return zod;
  hasRequiredZod = 1;
  (function(exports) {
    var __createBinding = zod && zod.__createBinding || (Object.create ? (function(o4, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o4, k22, desc);
    }) : (function(o4, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o4[k22] = m2[k2];
    }));
    var __setModuleDefault = zod && zod.__setModuleDefault || (Object.create ? (function(o4, v2) {
      Object.defineProperty(o4, "default", { enumerable: true, value: v2 });
    }) : function(o4, v2) {
      o4["default"] = v2;
    });
    var __importStar = zod && zod.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = zod && zod.__exportStar || function(m2, exports2) {
      for (var p2 in m2) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.z = void 0;
    const z2 = __importStar(/* @__PURE__ */ requireExternal());
    exports.z = z2;
    __exportStar(/* @__PURE__ */ requireExternal(), exports);
    exports.default = z2;
  })(zod);
  return zod;
}
var content$1 = {};
var hasRequiredContent$2;
function requireContent$2() {
  if (hasRequiredContent$2) return content$1;
  hasRequiredContent$2 = 1;
  Object.defineProperty(content$1, "__esModule", { value: true });
  content$1.bufferToStr = content$1.decodeImage = content$1.decodeSimpleFields = content$1.loadFullContent = content$1.DefaultContentResolver = void 0;
  const core_1 = requireDist$4();
  const crypto_1 = requireDist$5();
  class DefaultContentResolver {
    constructor(ipfsGateway) {
      this.ipfsGateway = ipfsGateway ?? ((id) => `https://ipfs.io/ipfs/${id}`);
    }
    async resolve(url) {
      if (url.startsWith("ipfs://")) {
        url = this.ipfsGateway(url.slice(7));
      }
      if (!(url.startsWith("https://") || url.startsWith("http://"))) {
        throw new Error("Unknown URL: " + url);
      }
      return Buffer.from(await (await fetch(url)).arrayBuffer());
    }
  }
  content$1.DefaultContentResolver = DefaultContentResolver;
  function loadSnake(s2) {
    const b2 = [];
    while (s2.remainingBits > 0 || s2.remainingRefs > 0) {
      if (s2.remainingBits % 8 !== 0) {
        throw new Error("Slice must contain an integer number of bytes");
      }
      b2.push(s2.loadBuffer(s2.remainingBits / 8));
      if (s2.remainingRefs === 1) {
        s2 = s2.loadRef().beginParse();
      } else if (s2.remainingRefs > 1) {
        throw new Error("Slice must contain at most 1 ref");
      }
    }
    return Buffer.concat(b2);
  }
  const BufferValue = {
    serialize: () => {
      throw new Error("Buffer serialization is not supported");
    },
    parse: (src2) => {
      const r = src2.loadRef().beginParse();
      if (r.remainingBits % 8 !== 0) {
        throw new Error("Slice must contain an integer number of bytes");
      }
      if (r.remainingRefs !== 0) {
        throw new Error("Slice must not contain refs");
      }
      return r.loadBuffer(r.remainingBits / 8);
    }
  };
  function loadChunked(s2) {
    const d = s2.loadDict(core_1.Dictionary.Keys.Uint(32), BufferValue);
    const b2 = [];
    for (let i = 0; i < d.size; i++) {
      const cb = d.get(i);
      if (cb === void 0) {
        throw new Error("Dict must contain sequential keys");
      }
      b2.push(cb);
    }
    return Buffer.concat(b2);
  }
  const ContentDataValue = {
    serialize: () => {
      throw new Error("ContentData serialization is not supported");
    },
    parse: (src2) => {
      const r = src2.loadRef().beginParse();
      const type = r.loadUint(8);
      if (type === 0) {
        return loadSnake(r);
      } else if (type === 1) {
        return loadChunked(r);
      } else {
        throw new Error("Unknown ContentData type: " + type);
      }
    }
  };
  function bufferToObj(b2) {
    const parsed = JSON.parse(b2.toString("utf-8"));
    if (typeof parsed !== "object") {
      throw new Error("Data must be an object");
    }
    return parsed;
  }
  function hashKey(key2) {
    return BigInt("0x" + (0, crypto_1.sha256_sync)(key2).toString("hex"));
  }
  async function loadFullContent(data, contentResolver) {
    const ds = data.beginParse();
    const type = ds.loadUint(8);
    if (type === 0) {
      const data2 = ds.loadDict(core_1.Dictionary.Keys.BigUint(256), ContentDataValue);
      const uri = data2.get(hashKey("uri"));
      if (uri !== void 0) {
        const uriStr = uri.toString("utf-8");
        const offchain = await contentResolver.resolve(uriStr);
        return {
          type: "semichain",
          offchainFields: bufferToObj(offchain),
          onchainFields: data2,
          offchainUrl: uriStr
        };
      }
      return {
        type: "onchain",
        onchainFields: data2
      };
    } else if (type === 1) {
      const uri = ds.loadStringTail();
      const data2 = await contentResolver.resolve(uri);
      return {
        type: "offchain",
        offchainFields: bufferToObj(data2),
        offchainUrl: uri
      };
    } else {
      throw new Error("Unknown FullContent type: " + type);
    }
  }
  content$1.loadFullContent = loadFullContent;
  function decodeSimpleFields(dc, parsers) {
    const out = {};
    for (const k2 in parsers) {
      if (dc.onchainFields !== void 0) {
        const h2 = hashKey(k2);
        const v2 = dc.onchainFields.get(h2);
        if (v2 !== void 0) {
          out[k2] = parsers[k2].onchain(v2);
          dc.onchainFields.delete(h2);
          continue;
        }
      }
      if (dc.offchainFields !== void 0) {
        if (k2 in dc.offchainFields) {
          out[k2] = parsers[k2].offchain(dc.offchainFields[k2]);
          delete dc.offchainFields[k2];
        }
      }
    }
    return out;
  }
  content$1.decodeSimpleFields = decodeSimpleFields;
  function decodeImage(dc) {
    if (dc.onchainFields !== void 0 && dc.onchainFields.has(hashKey("image")) && dc.onchainFields.has(hashKey("image_data"))) {
      throw new Error("Onchain fields contain both image and image_data");
    }
    if (dc.offchainFields !== void 0 && "image" in dc.offchainFields && "image_data" in dc.offchainFields) {
      throw new Error("Offchain fields contain both image and image_data");
    }
    if (dc.onchainFields !== void 0) {
      const image = dc.onchainFields.get(hashKey("image"));
      if (image !== void 0) {
        dc.onchainFields.delete(hashKey("image"));
        return image.toString("utf-8");
      }
      const imageData = dc.onchainFields.get(hashKey("image_data"));
      if (imageData !== void 0) {
        dc.onchainFields.delete(hashKey("image_data"));
        return imageData;
      }
    }
    if (dc.offchainFields !== void 0) {
      if ("image" in dc.offchainFields) {
        const image = dc.offchainFields.image;
        if (typeof image !== "string") {
          throw new Error("Image URI must be a string");
        }
        delete dc.offchainFields.image;
        return image;
      }
      if ("image_data" in dc.offchainFields) {
        const imageData = dc.offchainFields.image_data;
        if (typeof imageData !== "string") {
          throw new Error("Offchain image data must be a string");
        }
        delete dc.offchainFields.image_data;
        return Buffer.from(imageData, "base64");
      }
    }
    return void 0;
  }
  content$1.decodeImage = decodeImage;
  const bufferToStr = (b2) => b2.toString("utf-8");
  content$1.bufferToStr = bufferToStr;
  return content$1;
}
var hasRequiredContent$1;
function requireContent$1() {
  if (hasRequiredContent$1) return content$2;
  hasRequiredContent$1 = 1;
  var __importDefault = content$2 && content$2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(content$2, "__esModule", { value: true });
  content$2.parseJettonContent = content$2.jettonContentToInternal = void 0;
  const core_1 = requireDist$4();
  const zod_1 = __importDefault(/* @__PURE__ */ requireZod());
  const content_1 = requireContent$2();
  function jettonContentToInternal(content2) {
    return {
      uri: content2.uri,
      name: content2.name,
      description: content2.description,
      image: content2.image,
      image_data: content2.imageData?.toString("base64"),
      symbol: content2.symbol,
      decimals: content2.decimals?.toString(),
      amount_style: content2.amountStyle,
      render_type: content2.renderType
    };
  }
  content$2.jettonContentToInternal = jettonContentToInternal;
  function parseJettonContent(dc) {
    const decoded = (0, content_1.decodeSimpleFields)(dc, {
      name: {
        onchain: content_1.bufferToStr,
        offchain: (v2) => zod_1.default.string().parse(v2)
      },
      description: {
        onchain: content_1.bufferToStr,
        offchain: (v2) => zod_1.default.string().parse(v2)
      },
      symbol: {
        onchain: content_1.bufferToStr,
        offchain: (v2) => zod_1.default.string().parse(v2)
      },
      decimals: {
        onchain: (v2) => parseInt((0, content_1.bufferToStr)(v2)),
        offchain: (v2) => zod_1.default.union([zod_1.default.string(), zod_1.default.number()]).transform((v3) => Number(v3)).parse(v2)
      },
      amount_style: {
        onchain: (v2) => {
          const s2 = (0, content_1.bufferToStr)(v2);
          if (!["n", "n-of-total", "%"].includes(s2)) {
            throw new Error("Unknown amount_style: " + s2);
          }
          return s2;
        },
        offchain: (v2) => zod_1.default.union([zod_1.default.literal("n"), zod_1.default.literal("n-of-total"), zod_1.default.literal("%")]).parse(v2)
      },
      render_type: {
        onchain: (v2) => {
          const s2 = (0, content_1.bufferToStr)(v2);
          if (!["currency", "game"].includes(s2)) {
            throw new Error("Unknown render_type: " + s2);
          }
          return s2;
        },
        offchain: (v2) => zod_1.default.union([zod_1.default.literal("currency"), zod_1.default.literal("game")]).parse(v2)
      }
    });
    decoded.image = (0, content_1.decodeImage)(dc);
    const out = {
      ...decoded,
      type: dc.type,
      unknownOffchainFields: dc.offchainFields ?? {},
      unknownOnchainFields: dc.onchainFields ?? core_1.Dictionary.empty(),
      offchainUrl: dc.offchainUrl
    };
    return out;
  }
  content$2.parseJettonContent = parseJettonContent;
  return content$2;
}
var content = {};
var hasRequiredContent;
function requireContent() {
  if (hasRequiredContent) return content;
  hasRequiredContent = 1;
  var __importDefault = content && content.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(content, "__esModule", { value: true });
  content.parseNftContent = content.nftContentToInternal = void 0;
  const core_1 = requireDist$4();
  const zod_1 = __importDefault(/* @__PURE__ */ requireZod());
  const content_1 = requireContent$2();
  function nftContentToInternal(content2) {
    return {
      uri: content2.uri,
      name: content2.name,
      description: content2.description,
      image: content2.image,
      image_data: content2.imageData?.toString("base64")
    };
  }
  content.nftContentToInternal = nftContentToInternal;
  function parseNftContent(dc) {
    const decoded = (0, content_1.decodeSimpleFields)(dc, {
      name: {
        onchain: content_1.bufferToStr,
        offchain: (v2) => zod_1.default.string().parse(v2)
      },
      description: {
        onchain: content_1.bufferToStr,
        offchain: (v2) => zod_1.default.string().parse(v2)
      }
    });
    decoded.image = (0, content_1.decodeImage)(dc);
    const out = {
      ...decoded,
      type: dc.type,
      unknownOffchainFields: dc.offchainFields ?? {},
      unknownOnchainFields: dc.onchainFields ?? core_1.Dictionary.empty(),
      offchainUrl: dc.offchainUrl
    };
    return out;
  }
  content.parseNftContent = parseNftContent;
  return content;
}
var JettonWallet$1 = {};
var jettonWallet = {};
var hasRequiredJettonWallet$2;
function requireJettonWallet$2() {
  if (hasRequiredJettonWallet$2) return jettonWallet;
  hasRequiredJettonWallet$2 = 1;
  Object.defineProperty(jettonWallet, "__esModule", { value: true });
  jettonWallet.jettonWalletCode = void 0;
  jettonWallet.jettonWalletCode = {
    codeBoc: "te6ccgECEgEAAzQAART/APSkE/S88sgLAQIBYgIDAgLMBAUAG6D2BdqJofQB9IH0gahhAgHUBgcCAUgICQDDCDHAJJfBOAB0NMDAXGwlRNfA/AL4PpA+kAx+gAxcdch+gAx+gAwc6m0AALTH4IQD4p+pVIgupUxNFnwCOCCEBeNRRlSILqWMUREA/AJ4DWCEFlfB7y6k1nwCuBfBIQP8vCAAET6RDBwuvLhTYAIBIAoLAgEgEBEB8QD0z/6APpAIfAB7UTQ+gD6QPpA1DBRNqFSKscF8uLBKML/8uLCVDRCcFQgE1QUA8hQBPoCWM8WAc8WzMkiyMsBEvQA9ADLAMkg+QBwdMjLAsoHy//J0AT6QPQEMfoAINdJwgDy4sR3gBjIywVQCM8WcPoCF8trE8yAMA/c7UTQ+gD6QPpA1DAI0z/6AFFRoAX6QPpAU1vHBVRzbXBUIBNUFAPIUAT6AljPFgHPFszJIsjLARL0APQAywDJ+QBwdMjLAsoHy//J0FANxwUcsfLiwwr6AFGooYIImJaAggiYloAStgihggjk4cCgGKEn4w8l1wsBwwAjgDQ4PAK6CEBeNRRnIyx8Zyz9QB/oCIs8WUAbPFiX6AlADzxbJUAXMI5FykXHiUAioE6CCCOThwKoAggiYloCgoBS88uLFBMmAQPsAECPIUAT6AljPFgHPFszJ7VQAcFJ5oBihghBzYtCcyMsfUjDLP1j6AlAHzxZQB88WyXGAEMjLBSTPFlAG+gIVy2oUzMlx+wAQJBAjAA4QSRA4N18EAHbCALCOIYIQ1TJ223CAEMjLBVAIzxZQBPoCFstqEssfEss/yXL7AJM1bCHiA8hQBPoCWM8WAc8WzMntVADbO1E0PoA+kD6QNQwB9M/+gD6QDBRUaFSSccF8uLBJ8L/8uLCggjk4cCqABagFrzy4sOCEHvdl97Iyx8Vyz9QA/oCIs8WAc8WyXGAGMjLBSTPFnD6AstqzMmAQPsAQBPIUAT6AljPFgHPFszJ7VSAAgyAINch7UTQ+gD6QPpA1DAE0x+CEBeNRRlSILqCEHvdl94TuhKx8uLF0z8x+gAwE6BQI8hQBPoCWM8WAc8WzMntVIA=="
  };
  return jettonWallet;
}
var types = {};
var hasRequiredTypes;
function requireTypes() {
  if (hasRequiredTypes) return types;
  hasRequiredTypes = 1;
  Object.defineProperty(types, "__esModule", { value: true });
  types.parseExcessReturnOptions = types.parseNotifyOptions = void 0;
  const core_1 = requireDist$4();
  function parseNotifyOptions(options) {
    if (options === false) {
      return null;
    }
    if (typeof options === "object") {
      return {
        amount: options.amount ?? (0, core_1.toNano)("0.01"),
        payload: options.payload ?? null
      };
    }
    return {
      amount: (0, core_1.toNano)("0.01"),
      payload: null
    };
  }
  types.parseNotifyOptions = parseNotifyOptions;
  function parseExcessReturnOptions(options, sender) {
    if (options === false) {
      return null;
    }
    if (typeof options === "object") {
      return {
        address: options.address ?? sender.address
      };
    }
    return {
      address: sender.address
    };
  }
  types.parseExcessReturnOptions = parseExcessReturnOptions;
  return types;
}
var JettonTransferMessage = {};
var opcodes$1 = {};
var hasRequiredOpcodes$1;
function requireOpcodes$1() {
  if (hasRequiredOpcodes$1) return opcodes$1;
  hasRequiredOpcodes$1 = 1;
  Object.defineProperty(opcodes$1, "__esModule", { value: true });
  opcodes$1.JETTON_EXCESSES_OPCODE = opcodes$1.JETTON_BURN_NOTIFICATION_OPCODE = opcodes$1.JETTON_BURN_OPCODE = opcodes$1.JETTON_TRANSFER_NOTIFICATION_OPCODE = opcodes$1.JETTON_TRANSFER_OPCODE = opcodes$1.JETTON_CHANGE_CONTENT_OPCODE = opcodes$1.JETTON_CHANGE_ADMIN_OPCODE = opcodes$1.JETTON_INTERNAL_TRANSFER_OPCODE = opcodes$1.JETTON_MINT_OPCODE = void 0;
  opcodes$1.JETTON_MINT_OPCODE = 21;
  opcodes$1.JETTON_INTERNAL_TRANSFER_OPCODE = 395134233;
  opcodes$1.JETTON_CHANGE_ADMIN_OPCODE = 3;
  opcodes$1.JETTON_CHANGE_CONTENT_OPCODE = 4;
  opcodes$1.JETTON_TRANSFER_OPCODE = 260734629;
  opcodes$1.JETTON_TRANSFER_NOTIFICATION_OPCODE = 1935855772;
  opcodes$1.JETTON_BURN_OPCODE = 1499400124;
  opcodes$1.JETTON_BURN_NOTIFICATION_OPCODE = 2078119902;
  opcodes$1.JETTON_EXCESSES_OPCODE = 3576854235;
  return opcodes$1;
}
var hasRequiredJettonTransferMessage;
function requireJettonTransferMessage() {
  if (hasRequiredJettonTransferMessage) return JettonTransferMessage;
  hasRequiredJettonTransferMessage = 1;
  Object.defineProperty(JettonTransferMessage, "__esModule", { value: true });
  JettonTransferMessage.loadJettonTransferMessage = JettonTransferMessage.storeJettonTransferMessage = void 0;
  const opcodes_1 = requireOpcodes$1();
  function storeJettonTransferMessage(src2) {
    return (builder2) => {
      builder2.storeUint(opcodes_1.JETTON_TRANSFER_OPCODE, 32);
      builder2.storeUint(src2.queryId, 64);
      builder2.storeCoins(src2.amount);
      builder2.storeAddress(src2.destination);
      builder2.storeAddress(src2.responseDestination);
      builder2.storeMaybeRef(src2.customPayload);
      builder2.storeCoins(src2.forwardAmount ?? 0);
      builder2.storeMaybeRef(src2.forwardPayload);
    };
  }
  JettonTransferMessage.storeJettonTransferMessage = storeJettonTransferMessage;
  function loadJettonTransferMessage(slice) {
    if (slice.loadUint(32) !== opcodes_1.JETTON_TRANSFER_OPCODE) {
      throw new Error("Wrong opcode");
    }
    const queryId = slice.loadUintBig(64);
    const amount = slice.loadCoins();
    const to2 = slice.loadAddress();
    const responseDestination = slice.loadMaybeAddress();
    const customPayload = slice.loadMaybeRef();
    const forwardAmount = slice.loadCoins();
    const eitherPayload = slice.loadBoolean();
    const forwardPayload = eitherPayload ? slice.loadRef() : slice.asCell();
    return {
      queryId,
      amount,
      destination: to2,
      responseDestination,
      customPayload,
      forwardAmount,
      forwardPayload
    };
  }
  JettonTransferMessage.loadJettonTransferMessage = loadJettonTransferMessage;
  return JettonTransferMessage;
}
var JettonBurnMessage = {};
var hasRequiredJettonBurnMessage;
function requireJettonBurnMessage() {
  if (hasRequiredJettonBurnMessage) return JettonBurnMessage;
  hasRequiredJettonBurnMessage = 1;
  Object.defineProperty(JettonBurnMessage, "__esModule", { value: true });
  JettonBurnMessage.loadJettonBurnMessage = JettonBurnMessage.storeJettonBurnMessage = void 0;
  const opcodes_1 = requireOpcodes$1();
  function storeJettonBurnMessage(src2) {
    return (builder2) => {
      builder2.storeUint(opcodes_1.JETTON_BURN_OPCODE, 32);
      builder2.storeUint(src2.queryId, 64);
      builder2.storeCoins(src2.amount);
      builder2.storeAddress(src2.responseDestination);
      builder2.storeMaybeRef(src2.customPayload);
    };
  }
  JettonBurnMessage.storeJettonBurnMessage = storeJettonBurnMessage;
  function loadJettonBurnMessage(slice) {
    if (slice.loadUint(32) !== opcodes_1.JETTON_BURN_OPCODE) {
      throw new Error("Wrong opcode");
    }
    const queryId = slice.loadUintBig(64);
    const amount = slice.loadCoins();
    const responseDestination = slice.loadMaybeAddress();
    const customPayload = slice.loadMaybeRef();
    return {
      queryId,
      amount,
      responseDestination,
      customPayload
    };
  }
  JettonBurnMessage.loadJettonBurnMessage = loadJettonBurnMessage;
  return JettonBurnMessage;
}
var JettonWalletAction = {};
var JettonWalletMessage = {};
var JettonInternalTransferMessage = {};
var hasRequiredJettonInternalTransferMessage;
function requireJettonInternalTransferMessage() {
  if (hasRequiredJettonInternalTransferMessage) return JettonInternalTransferMessage;
  hasRequiredJettonInternalTransferMessage = 1;
  Object.defineProperty(JettonInternalTransferMessage, "__esModule", { value: true });
  JettonInternalTransferMessage.loadJettonInternalTransferMessage = JettonInternalTransferMessage.storeJettonInternalTransferMessage = void 0;
  const opcodes_1 = requireOpcodes$1();
  function storeJettonInternalTransferMessage(src2) {
    return (builder2) => {
      builder2.storeUint(opcodes_1.JETTON_INTERNAL_TRANSFER_OPCODE, 32);
      builder2.storeUint(src2.queryId, 64);
      builder2.storeCoins(src2.amount);
      builder2.storeAddress(src2.from);
      builder2.storeAddress(src2.responseAddress);
      builder2.storeCoins(src2.forwardTonAmount);
      builder2.storeMaybeRef(src2.forwardPayload);
    };
  }
  JettonInternalTransferMessage.storeJettonInternalTransferMessage = storeJettonInternalTransferMessage;
  function loadJettonInternalTransferMessage(slice) {
    if (slice.loadUint(32) !== opcodes_1.JETTON_INTERNAL_TRANSFER_OPCODE) {
      throw new Error("Wrong opcode");
    }
    const queryId = slice.loadUintBig(64);
    const amount = slice.loadCoins();
    const from = slice.loadAddress();
    const responseAddress = slice.loadAddress();
    const forwardTonAmount = slice.loadCoins();
    const eitherPayload = slice.loadBoolean();
    const forwardPayload = eitherPayload ? slice.loadRef() : slice.asCell();
    return {
      queryId,
      amount,
      from,
      responseAddress,
      forwardTonAmount,
      forwardPayload
    };
  }
  JettonInternalTransferMessage.loadJettonInternalTransferMessage = loadJettonInternalTransferMessage;
  return JettonInternalTransferMessage;
}
var JettonBurnNotificationMessage = {};
var hasRequiredJettonBurnNotificationMessage;
function requireJettonBurnNotificationMessage() {
  if (hasRequiredJettonBurnNotificationMessage) return JettonBurnNotificationMessage;
  hasRequiredJettonBurnNotificationMessage = 1;
  Object.defineProperty(JettonBurnNotificationMessage, "__esModule", { value: true });
  JettonBurnNotificationMessage.loadJettonBurnNotificationMessage = JettonBurnNotificationMessage.storeJettonBurnNotificationMessage = void 0;
  const opcodes_1 = requireOpcodes$1();
  function storeJettonBurnNotificationMessage(src2) {
    return (builder2) => {
      builder2.storeUint(opcodes_1.JETTON_BURN_NOTIFICATION_OPCODE, 32);
      builder2.storeUint(src2.queryId, 64);
      builder2.storeCoins(src2.amount);
      builder2.storeAddress(src2.sender);
      builder2.storeAddress(src2.responseDestination);
    };
  }
  JettonBurnNotificationMessage.storeJettonBurnNotificationMessage = storeJettonBurnNotificationMessage;
  function loadJettonBurnNotificationMessage(slice) {
    if (slice.loadUint(32) !== opcodes_1.JETTON_BURN_NOTIFICATION_OPCODE) {
      throw new Error("Wrong opcode");
    }
    const queryId = slice.loadUintBig(64);
    const amount = slice.loadCoins();
    const sender = slice.loadAddress();
    const responseDestination = slice.loadMaybeAddress();
    return {
      queryId,
      amount,
      sender,
      responseDestination
    };
  }
  JettonBurnNotificationMessage.loadJettonBurnNotificationMessage = loadJettonBurnNotificationMessage;
  return JettonBurnNotificationMessage;
}
var JettonTransferNotificationMessage = {};
var hasRequiredJettonTransferNotificationMessage;
function requireJettonTransferNotificationMessage() {
  if (hasRequiredJettonTransferNotificationMessage) return JettonTransferNotificationMessage;
  hasRequiredJettonTransferNotificationMessage = 1;
  Object.defineProperty(JettonTransferNotificationMessage, "__esModule", { value: true });
  JettonTransferNotificationMessage.loadJettonTransferNotificationMessage = JettonTransferNotificationMessage.storeJettonTransferNotificationMessage = void 0;
  const opcodes_1 = requireOpcodes$1();
  function storeJettonTransferNotificationMessage(src2) {
    return (builder2) => {
      builder2.storeUint(opcodes_1.JETTON_TRANSFER_NOTIFICATION_OPCODE, 32);
      builder2.storeUint(src2.queryId, 64);
      builder2.storeCoins(src2.amount);
      builder2.storeAddress(src2.sender);
      builder2.storeMaybeRef(src2.forwardPayload);
    };
  }
  JettonTransferNotificationMessage.storeJettonTransferNotificationMessage = storeJettonTransferNotificationMessage;
  function loadJettonTransferNotificationMessage(slice) {
    if (slice.loadUint(32) !== opcodes_1.JETTON_TRANSFER_NOTIFICATION_OPCODE) {
      throw new Error("Wrong opcode");
    }
    const queryId = slice.loadUintBig(64);
    const amount = slice.loadCoins();
    const sender = slice.loadAddress();
    const eitherPayload = slice.loadBoolean();
    const forwardPayload = eitherPayload ? slice.loadRef() : slice.asCell();
    return {
      queryId,
      amount,
      sender,
      forwardPayload
    };
  }
  JettonTransferNotificationMessage.loadJettonTransferNotificationMessage = loadJettonTransferNotificationMessage;
  return JettonTransferNotificationMessage;
}
var hasRequiredJettonWalletMessage;
function requireJettonWalletMessage() {
  if (hasRequiredJettonWalletMessage) return JettonWalletMessage;
  hasRequiredJettonWalletMessage = 1;
  Object.defineProperty(JettonWalletMessage, "__esModule", { value: true });
  JettonWalletMessage.loadJettonWalletMessage = void 0;
  const opcodes_1 = requireOpcodes$1();
  const JettonTransferMessage_1 = requireJettonTransferMessage();
  const JettonInternalTransferMessage_1 = requireJettonInternalTransferMessage();
  const JettonBurnMessage_1 = requireJettonBurnMessage();
  const JettonBurnNotificationMessage_1 = requireJettonBurnNotificationMessage();
  const JettonTransferNotificationMessage_1 = requireJettonTransferNotificationMessage();
  function loadJettonWalletMessage(slice) {
    try {
      const opcode = slice.preloadUint(32);
      switch (opcode) {
        case opcodes_1.JETTON_TRANSFER_OPCODE:
          return { kind: "jetton_transfer", ...(0, JettonTransferMessage_1.loadJettonTransferMessage)(slice) };
        case opcodes_1.JETTON_INTERNAL_TRANSFER_OPCODE:
          return { kind: "jetton_internal_transfer", ...(0, JettonInternalTransferMessage_1.loadJettonInternalTransferMessage)(slice) };
        case opcodes_1.JETTON_TRANSFER_NOTIFICATION_OPCODE:
          return { kind: "transfer_notification", ...(0, JettonTransferNotificationMessage_1.loadJettonTransferNotificationMessage)(slice) };
        case opcodes_1.JETTON_BURN_OPCODE:
          return { kind: "jetton_burn", ...(0, JettonBurnMessage_1.loadJettonBurnMessage)(slice) };
        case opcodes_1.JETTON_BURN_NOTIFICATION_OPCODE:
          return { kind: "jetton_burn_notification", ...(0, JettonBurnNotificationMessage_1.loadJettonBurnNotificationMessage)(slice) };
        case opcodes_1.JETTON_EXCESSES_OPCODE:
          return { kind: "excesses", ...{ queryId: slice.loadUintBig(64) } };
      }
    } catch (e) {
    }
    return { kind: "unknown" };
  }
  JettonWalletMessage.loadJettonWalletMessage = loadJettonWalletMessage;
  return JettonWalletMessage;
}
var TransferAction = {};
var TransferMessage = {};
var hasRequiredTransferMessage;
function requireTransferMessage() {
  if (hasRequiredTransferMessage) return TransferMessage;
  hasRequiredTransferMessage = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadTransferMessage = exports.loadEncryptedMessage = exports.storeEncryptedMessage = exports.loadTextMessage = exports.storeTextMessage = exports.loadSimpleTransferMessage = exports.storeSimpleTransferMessage = exports.ENCRYPTED_MESSAGE_OPCODE = exports.TEXT_OPCODE = void 0;
    exports.TEXT_OPCODE = 0;
    exports.ENCRYPTED_MESSAGE_OPCODE = 560454219;
    function storeSimpleTransferMessage(value) {
      return (builder2) => {
      };
    }
    exports.storeSimpleTransferMessage = storeSimpleTransferMessage;
    function loadSimpleTransferMessage(slice) {
      return {};
    }
    exports.loadSimpleTransferMessage = loadSimpleTransferMessage;
    function storeTextMessage(value) {
      return (builder2) => {
        builder2.storeUint(0, 32);
        builder2.storeStringTail(value.text);
      };
    }
    exports.storeTextMessage = storeTextMessage;
    function loadTextMessage(slice) {
      if (slice.loadUint(32) !== 0) {
        throw new Error("Wrong opcode");
      }
      return { text: slice.loadStringTail() };
    }
    exports.loadTextMessage = loadTextMessage;
    function storeEncryptedMessage(value) {
      return (builder2) => {
        builder2.storeUint(exports.ENCRYPTED_MESSAGE_OPCODE, 32);
        builder2.storeStringTail(value.data.toString("utf-8"));
      };
    }
    exports.storeEncryptedMessage = storeEncryptedMessage;
    function loadEncryptedMessage(slice) {
      if (slice.loadUint(32) !== exports.ENCRYPTED_MESSAGE_OPCODE) {
        throw new Error("Wrong opcode");
      }
      const data = slice.loadStringTail();
      return { data: Buffer.from(data, "utf-8") };
    }
    exports.loadEncryptedMessage = loadEncryptedMessage;
    function loadTransferMessage(slice) {
      if (slice.remainingBits === 0) {
        return { kind: "simple_transfer" };
      }
      try {
        const opcode = slice.preloadUint(32);
        switch (opcode) {
          case exports.TEXT_OPCODE:
            return { kind: "text_message", ...loadTextMessage(slice) };
          case exports.ENCRYPTED_MESSAGE_OPCODE:
            return { kind: "encrypted_message", ...loadEncryptedMessage(slice) };
        }
      } catch (e) {
      }
      return { kind: "unknown" };
    }
    exports.loadTransferMessage = loadTransferMessage;
  })(TransferMessage);
  return TransferMessage;
}
var hasRequiredTransferAction;
function requireTransferAction() {
  if (hasRequiredTransferAction) return TransferAction;
  hasRequiredTransferAction = 1;
  Object.defineProperty(TransferAction, "__esModule", { value: true });
  TransferAction.parseTransferTransaction = void 0;
  const TransferMessage_1 = requireTransferMessage();
  function parseTransferTransaction(tx) {
    if (tx.description.type !== "generic") {
      return { kind: "unknown", transaction: tx };
    }
    if (!tx.inMessage) {
      return { kind: "unknown", transaction: tx };
    }
    if (tx.inMessage.info.type !== "internal") {
      return { kind: "unknown", transaction: tx };
    }
    const body = tx.inMessage.body.beginParse();
    const inMessage = (0, TransferMessage_1.loadTransferMessage)(body);
    if (inMessage.kind === "simple_transfer") {
      return {
        kind: "simple_transfer",
        from: tx.inMessage.info.src,
        to: tx.inMessage.info.dest,
        amount: tx.inMessage.info.value.coins,
        transaction: tx
      };
    }
    if (inMessage.kind === "text_message") {
      return {
        kind: "text_message",
        from: tx.inMessage.info.src,
        to: tx.inMessage.info.dest,
        amount: tx.inMessage.info.value.coins,
        text: inMessage.text,
        transaction: tx
      };
    }
    if (inMessage.kind === "encrypted_message") {
      return {
        kind: "encrypted_message",
        from: tx.inMessage.info.src,
        to: tx.inMessage.info.dest,
        amount: tx.inMessage.info.value.coins,
        data: inMessage.data,
        transaction: tx
      };
    }
    return { kind: "unknown", transaction: tx };
  }
  TransferAction.parseTransferTransaction = parseTransferTransaction;
  return TransferAction;
}
var hasRequiredJettonWalletAction;
function requireJettonWalletAction() {
  if (hasRequiredJettonWalletAction) return JettonWalletAction;
  hasRequiredJettonWalletAction = 1;
  Object.defineProperty(JettonWalletAction, "__esModule", { value: true });
  JettonWalletAction.parseJettonWalletTransaction = void 0;
  const JettonWalletMessage_1 = requireJettonWalletMessage();
  const TransferAction_1 = requireTransferAction();
  function parseJettonWalletTransaction(tx) {
    const mayBeTransfer = (0, TransferAction_1.parseTransferTransaction)(tx);
    if (mayBeTransfer.kind !== "unknown") {
      return mayBeTransfer;
    }
    if (tx.description.type !== "generic") {
      return { kind: "unknown", transaction: tx };
    }
    if (!tx.inMessage) {
      return { kind: "unknown", transaction: tx };
    }
    if (tx.inMessage.info.type !== "internal") {
      return { kind: "unknown", transaction: tx };
    }
    if (tx.description.computePhase.type !== "vm") {
      return { kind: "unknown", transaction: tx };
    }
    if (tx.description.computePhase.exitCode !== 0) {
      return { kind: "unknown", transaction: tx };
    }
    if (!tx.inMessage.body) {
      return { kind: "unknown", transaction: tx };
    }
    const isBounced = tx.inMessage.info.bounced;
    const inMessage = (0, JettonWalletMessage_1.loadJettonWalletMessage)(tx.inMessage.body.beginParse());
    if (inMessage.kind === "jetton_transfer") {
      return {
        kind: "jetton_transfer",
        queryId: inMessage.queryId,
        from: tx.inMessage.info.src,
        to: inMessage.destination,
        amount: inMessage.amount,
        responseAddress: inMessage.responseDestination,
        forwardTonAmount: inMessage.forwardAmount,
        forwardPayload: inMessage.forwardPayload,
        transaction: tx
      };
    }
    if (isBounced && inMessage.kind === "jetton_internal_transfer") {
      return {
        kind: "jetton_transfer_failed",
        queryId: inMessage.queryId,
        amount: inMessage.amount,
        transaction: tx
      };
    }
    if (inMessage.kind === "jetton_internal_transfer") {
      return {
        kind: "jetton_transfer_received",
        queryId: inMessage.queryId,
        amount: inMessage.amount,
        from: tx.inMessage.info.src,
        transaction: tx
      };
    }
    if (inMessage.kind === "jetton_burn") {
      return {
        kind: "jetton_burn",
        queryId: inMessage.queryId,
        amount: inMessage.amount,
        transaction: tx
      };
    }
    if (isBounced && inMessage.kind === "jetton_burn_notification") {
      return {
        kind: "jetton_burn_failed",
        queryId: inMessage.queryId,
        amount: inMessage.amount,
        transaction: tx
      };
    }
    return { kind: "unknown", transaction: tx };
  }
  JettonWalletAction.parseJettonWalletTransaction = parseJettonWalletTransaction;
  return JettonWalletAction;
}
var hasRequiredJettonWallet$1;
function requireJettonWallet$1() {
  if (hasRequiredJettonWallet$1) return JettonWallet$1;
  hasRequiredJettonWallet$1 = 1;
  Object.defineProperty(JettonWallet$1, "__esModule", { value: true });
  JettonWallet$1.JettonWallet = JettonWallet$1.jettonWalletConfigToCell = void 0;
  const core_1 = requireDist$4();
  const jetton_wallet_1 = requireJettonWallet$2();
  const types_1 = requireTypes();
  const JettonTransferMessage_1 = requireJettonTransferMessage();
  const JettonBurnMessage_1 = requireJettonBurnMessage();
  const JettonWalletAction_1 = requireJettonWalletAction();
  function jettonWalletConfigToCell(config) {
    return (0, core_1.beginCell)().storeCoins(config.balance).storeAddress(config.owner).storeAddress(config.jettonMaster).storeRef(config.jettonWalletCode).endCell();
  }
  JettonWallet$1.jettonWalletConfigToCell = jettonWalletConfigToCell;
  class JettonWallet2 {
    constructor(address, init) {
      this.address = address;
      this.init = init;
    }
    static createFromConfig(config, code, workchain) {
      const data = jettonWalletConfigToCell({
        balance: 0n,
        owner: config.owner,
        jettonMaster: config.jettonMaster,
        jettonWalletCode: code ?? JettonWallet2.code
      });
      const init = { data, code: code ?? JettonWallet2.code };
      return new JettonWallet2((0, core_1.contractAddress)(workchain ?? 0, init), init);
    }
    static createFromAddress(address) {
      return new JettonWallet2(address);
    }
    async sendDeploy(provider, sender, value) {
      await provider.internal(sender, {
        value: value ?? (0, core_1.toNano)("0.05"),
        bounce: true
      });
    }
    async send(provider, sender, recipient, amount, options) {
      const notification = (0, types_1.parseNotifyOptions)(options?.notify);
      const excessReturn = (0, types_1.parseExcessReturnOptions)(options?.returnExcess, sender);
      await provider.internal(sender, {
        value: (options?.value ?? (0, core_1.toNano)("0.05")) + (notification?.amount ?? 0n),
        bounce: true,
        sendMode: core_1.SendMode.PAY_GAS_SEPARATELY,
        body: (0, core_1.beginCell)().store((0, JettonTransferMessage_1.storeJettonTransferMessage)({
          queryId: options?.queryId ?? 0n,
          amount,
          destination: recipient,
          responseDestination: excessReturn?.address ?? null,
          customPayload: options?.customPayload ?? null,
          forwardAmount: notification?.amount ?? 0n,
          forwardPayload: notification?.payload ?? null
        })).endCell()
      });
    }
    async sendBurn(provider, sender, amount, options) {
      const excessReturn = (0, types_1.parseExcessReturnOptions)(options?.returnExcess, sender);
      await provider.internal(sender, {
        value: options?.value ?? (0, core_1.toNano)("0.05"),
        bounce: true,
        sendMode: core_1.SendMode.PAY_GAS_SEPARATELY,
        body: (0, core_1.beginCell)().store((0, JettonBurnMessage_1.storeJettonBurnMessage)({
          queryId: options?.queryId ?? 0n,
          amount,
          responseDestination: excessReturn?.address ?? null,
          customPayload: options?.customPayload ?? null
        })).endCell()
      });
    }
    async getData(provider) {
      const { stack } = await provider.get("get_wallet_data", []);
      return {
        balance: stack.readBigNumber(),
        owner: stack.readAddress(),
        jettonMaster: stack.readAddress(),
        jettonWalletCode: stack.readCell()
      };
    }
    async getActions(provider, options) {
      let { lt: lt2, hash, limit } = options ?? {};
      if (!lt2 || !hash) {
        const state = await provider.getState();
        if (!state.last) {
          return [];
        }
        lt2 = state.last.lt;
        hash = state.last.hash;
      }
      const transactions = await provider.getTransactions(this.address, lt2, hash, limit);
      return transactions.map((tx) => (0, JettonWalletAction_1.parseJettonWalletTransaction)(tx));
    }
  }
  JettonWallet$1.JettonWallet = JettonWallet2;
  JettonWallet2.code = core_1.Cell.fromBase64(jetton_wallet_1.jettonWalletCode.codeBoc);
  return JettonWallet$1;
}
var JettonMinter = {};
var jettonMinter = {};
var hasRequiredJettonMinter$1;
function requireJettonMinter$1() {
  if (hasRequiredJettonMinter$1) return jettonMinter;
  hasRequiredJettonMinter$1 = 1;
  Object.defineProperty(jettonMinter, "__esModule", { value: true });
  jettonMinter.jettonMinterCode = void 0;
  jettonMinter.jettonMinterCode = {
    codeBoc: "te6ccgECDgEAAqMAART/APSkE/S88sgLAQIBYgIDAgLMBAUCA3pgDA0B9dkGOASS+B8ADoaYGAuNhJL4HwfSB9IBj9ABi465D9ABj9ABg51NoAAWmP6Z/2omh9AH0gamoYQAqpOF1HGZqamxsommOC+XAkgX0gfQBqGBBoQDBrkP0AGBKIGigheASKUCgZ5CgCfQEsZ4tmZmT2qnBBCD3uy+8pOF1AYAk7PwUIgG4KhAJqgoB5CgCfQEsZ4sA54tmZJFkZYCJegB6AGWAZJB8gDg6ZGWBZQPl/+ToO8AMZGWCrGeLKAJ9AQnltYlmZmS4/YBBPSO4DY3NwH6APpA+ChUEgZwVCATVBQDyFAE+gJYzxYBzxbMySLIywES9AD0AMsAyfkAcHTIywLKB8v/ydBQBscF8uBKoQNFRchQBPoCWM8WzMzJ7VQB+kAwINcLAcMAkVvjDeCCECx2uXNScLrjAjU3NyPAA+MCNQLABAcICQoAPoIQ1TJ223CAEMjLBVADzxYi+gISy2rLH8s/yYBC+wAB/jZfA4IImJaAFaAVvPLgSwL6QNMAMJXIIc8WyZFt4oIQ0XNUAHCAGMjLBVAFzxYk+gIUy2oTyx8Uyz8j+kQwcLqOM/goRANwVCATVBQDyFAE+gJYzxYBzxbMySLIywES9AD0AMsAyfkAcHTIywLKB8v/ydDPFpZsInABywHi9AALADQzUDXHBfLgSQP6QDBZyFAE+gJYzxbMzMntVABCjhhRJMcF8uBJ1DBDAMhQBPoCWM8WzMzJ7VTgXwWED/LwAArJgED7AAB9rbz2omh9AH0gamoYNhj8FAC4KhAJqgoB5CgCfQEsZ4sA54tmZJFkZYCJegB6AGWAZPyAODpkZYFlA+X/5OhAAB+vFvaiaH0AfSBqahg/qpBA"
  };
  return jettonMinter;
}
var JettonMintMessage = {};
var hasRequiredJettonMintMessage;
function requireJettonMintMessage() {
  if (hasRequiredJettonMintMessage) return JettonMintMessage;
  hasRequiredJettonMintMessage = 1;
  Object.defineProperty(JettonMintMessage, "__esModule", { value: true });
  JettonMintMessage.loadJettonMintMessage = JettonMintMessage.storeJettonMintMessage = void 0;
  const core_1 = requireDist$4();
  const opcodes_1 = requireOpcodes$1();
  const JettonInternalTransferMessage_1 = requireJettonInternalTransferMessage();
  function storeJettonMintMessage(src2) {
    return (builder2) => {
      builder2.storeUint(opcodes_1.JETTON_MINT_OPCODE, 32);
      builder2.storeUint(src2.queryId, 64);
      builder2.storeAddress(src2.to);
      builder2.storeCoins(src2.walletForwardValue);
      builder2.storeRef((0, core_1.beginCell)().store((0, JettonInternalTransferMessage_1.storeJettonInternalTransferMessage)(src2)).endCell());
    };
  }
  JettonMintMessage.storeJettonMintMessage = storeJettonMintMessage;
  function loadJettonMintMessage(slice) {
    if (slice.loadUint(32) !== opcodes_1.JETTON_MINT_OPCODE) {
      throw new Error("Wrong opcode");
    }
    const queryId = slice.loadUintBig(64);
    const to2 = slice.loadAddress();
    const walletForwardValue = slice.loadCoins();
    const internalTransfer = (0, JettonInternalTransferMessage_1.loadJettonInternalTransferMessage)(slice.loadRef().beginParse());
    return {
      queryId,
      amount: internalTransfer.amount,
      from: internalTransfer.from,
      to: to2,
      responseAddress: internalTransfer.responseAddress,
      forwardTonAmount: internalTransfer.forwardTonAmount,
      forwardPayload: internalTransfer.forwardPayload,
      walletForwardValue
    };
  }
  JettonMintMessage.loadJettonMintMessage = loadJettonMintMessage;
  return JettonMintMessage;
}
var JettonMinterContent = {};
var hasRequiredJettonMinterContent;
function requireJettonMinterContent() {
  if (hasRequiredJettonMinterContent) return JettonMinterContent;
  hasRequiredJettonMinterContent = 1;
  Object.defineProperty(JettonMinterContent, "__esModule", { value: true });
  JettonMinterContent.loadJettonMinterContent = JettonMinterContent.storeJettonMinterContent = void 0;
  function storeJettonMinterContent(src2) {
    return (builder2) => {
      builder2.storeCoins(0);
      builder2.storeAddress(src2.admin);
      builder2.storeRef(src2.content);
      builder2.storeRef(src2.jettonWalletCode);
    };
  }
  JettonMinterContent.storeJettonMinterContent = storeJettonMinterContent;
  function loadJettonMinterContent(slice) {
    slice.loadCoins();
    const adminAddress = slice.loadAddress();
    const jettonContent = slice.loadRef();
    const jettonWalletCode = slice.loadRef();
    return {
      admin: adminAddress,
      content: jettonContent,
      jettonWalletCode
    };
  }
  JettonMinterContent.loadJettonMinterContent = loadJettonMinterContent;
  return JettonMinterContent;
}
var JettonChangeAdminMessage = {};
var hasRequiredJettonChangeAdminMessage;
function requireJettonChangeAdminMessage() {
  if (hasRequiredJettonChangeAdminMessage) return JettonChangeAdminMessage;
  hasRequiredJettonChangeAdminMessage = 1;
  Object.defineProperty(JettonChangeAdminMessage, "__esModule", { value: true });
  JettonChangeAdminMessage.loadJettonChangeAdminMessage = JettonChangeAdminMessage.storeJettonChangeAdminMessage = void 0;
  const opcodes_1 = requireOpcodes$1();
  function storeJettonChangeAdminMessage(src2) {
    return (builder2) => {
      builder2.storeUint(opcodes_1.JETTON_CHANGE_ADMIN_OPCODE, 32);
      builder2.storeUint(src2.queryId, 64);
      builder2.storeAddress(src2.newAdmin);
    };
  }
  JettonChangeAdminMessage.storeJettonChangeAdminMessage = storeJettonChangeAdminMessage;
  function loadJettonChangeAdminMessage(slice) {
    if (slice.loadUint(32) !== opcodes_1.JETTON_CHANGE_ADMIN_OPCODE) {
      throw new Error("Wrong opcode");
    }
    const queryId = slice.loadUintBig(64);
    const newAdmin = slice.loadAddress();
    return {
      queryId,
      newAdmin
    };
  }
  JettonChangeAdminMessage.loadJettonChangeAdminMessage = loadJettonChangeAdminMessage;
  return JettonChangeAdminMessage;
}
var JettonChangeContentMessage = {};
var hasRequiredJettonChangeContentMessage;
function requireJettonChangeContentMessage() {
  if (hasRequiredJettonChangeContentMessage) return JettonChangeContentMessage;
  hasRequiredJettonChangeContentMessage = 1;
  Object.defineProperty(JettonChangeContentMessage, "__esModule", { value: true });
  JettonChangeContentMessage.loadJettonChangeContentMessage = JettonChangeContentMessage.storeJettonChangeContentMessage = void 0;
  const opcodes_1 = requireOpcodes$1();
  function storeJettonChangeContentMessage(src2) {
    return (builder2) => {
      builder2.storeUint(opcodes_1.JETTON_CHANGE_CONTENT_OPCODE, 32);
      builder2.storeUint(src2.queryId, 64);
      builder2.storeRef(src2.newContent);
    };
  }
  JettonChangeContentMessage.storeJettonChangeContentMessage = storeJettonChangeContentMessage;
  function loadJettonChangeContentMessage(slice) {
    if (slice.loadUint(32) !== opcodes_1.JETTON_CHANGE_CONTENT_OPCODE) {
      throw new Error("Wrong opcode");
    }
    const queryId = slice.loadUintBig(64);
    const newContent = slice.loadRef();
    return {
      queryId,
      newContent
    };
  }
  JettonChangeContentMessage.loadJettonChangeContentMessage = loadJettonChangeContentMessage;
  return JettonChangeContentMessage;
}
var JettonMinterAction = {};
var JettonMinterMessage = {};
var hasRequiredJettonMinterMessage;
function requireJettonMinterMessage() {
  if (hasRequiredJettonMinterMessage) return JettonMinterMessage;
  hasRequiredJettonMinterMessage = 1;
  Object.defineProperty(JettonMinterMessage, "__esModule", { value: true });
  JettonMinterMessage.loadJettonMinterMessage = void 0;
  const JettonMintMessage_1 = requireJettonMintMessage();
  const JettonInternalTransferMessage_1 = requireJettonInternalTransferMessage();
  const JettonChangeAdminMessage_1 = requireJettonChangeAdminMessage();
  const JettonChangeContentMessage_1 = requireJettonChangeContentMessage();
  const opcodes_1 = requireOpcodes$1();
  function loadJettonMinterMessage(slice) {
    try {
      const opcode = slice.preloadUint(32);
      switch (opcode) {
        case opcodes_1.JETTON_MINT_OPCODE:
          return { kind: "mint", ...(0, JettonMintMessage_1.loadJettonMintMessage)(slice) };
        case opcodes_1.JETTON_INTERNAL_TRANSFER_OPCODE:
          return { kind: "internal_transfer", ...(0, JettonInternalTransferMessage_1.loadJettonInternalTransferMessage)(slice) };
        case opcodes_1.JETTON_CHANGE_ADMIN_OPCODE:
          return { kind: "change_admin", ...(0, JettonChangeAdminMessage_1.loadJettonChangeAdminMessage)(slice) };
        case opcodes_1.JETTON_CHANGE_CONTENT_OPCODE:
          return { kind: "change_content", ...(0, JettonChangeContentMessage_1.loadJettonChangeContentMessage)(slice) };
      }
    } catch (e) {
    }
    return { kind: "unknown" };
  }
  JettonMinterMessage.loadJettonMinterMessage = loadJettonMinterMessage;
  return JettonMinterMessage;
}
var hasRequiredJettonMinterAction;
function requireJettonMinterAction() {
  if (hasRequiredJettonMinterAction) return JettonMinterAction;
  hasRequiredJettonMinterAction = 1;
  Object.defineProperty(JettonMinterAction, "__esModule", { value: true });
  JettonMinterAction.parseJettonMinterTransaction = void 0;
  const JettonMinterMessage_1 = requireJettonMinterMessage();
  const TransferAction_1 = requireTransferAction();
  function parseJettonMinterTransaction(tx) {
    const mayBeTransfer = (0, TransferAction_1.parseTransferTransaction)(tx);
    if (mayBeTransfer.kind !== "unknown") {
      return mayBeTransfer;
    }
    if (tx.description.type !== "generic") {
      return { kind: "unknown", transaction: tx };
    }
    if (!tx.inMessage) {
      return { kind: "unknown", transaction: tx };
    }
    if (tx.inMessage.info.type !== "internal") {
      return { kind: "unknown", transaction: tx };
    }
    if (tx.description.computePhase.type !== "vm") {
      return { kind: "unknown", transaction: tx };
    }
    if (tx.description.computePhase.exitCode !== 0) {
      return { kind: "unknown", transaction: tx };
    }
    const inMessage = (0, JettonMinterMessage_1.loadJettonMinterMessage)(tx.inMessage.body.beginParse());
    if (inMessage.kind === "mint") {
      return {
        kind: "mint",
        queryId: inMessage.queryId,
        amount: inMessage.amount,
        recipient: inMessage.to,
        responseAddress: inMessage.responseAddress,
        forwardPayload: inMessage.forwardPayload,
        forwardTonAmount: inMessage.forwardTonAmount,
        value: tx.inMessage.info.value.coins,
        transaction: tx
      };
    }
    if (inMessage.kind === "internal_transfer") {
      return {
        kind: "burn",
        queryId: inMessage.queryId,
        amount: inMessage.amount,
        from: inMessage.from,
        value: tx.inMessage.info.value.coins,
        transaction: tx
      };
    }
    if (inMessage.kind === "change_admin") {
      return {
        kind: "change_admin",
        queryId: inMessage.queryId,
        newAdmin: inMessage.newAdmin,
        value: tx.inMessage.info.value.coins,
        transaction: tx
      };
    }
    if (inMessage.kind === "change_content") {
      return {
        kind: "change_content",
        queryId: inMessage.queryId,
        newContent: inMessage.newContent,
        value: tx.inMessage.info.value.coins,
        transaction: tx
      };
    }
    return { kind: "unknown", transaction: tx };
  }
  JettonMinterAction.parseJettonMinterTransaction = parseJettonMinterTransaction;
  return JettonMinterAction;
}
var hasRequiredJettonMinter;
function requireJettonMinter() {
  if (hasRequiredJettonMinter) return JettonMinter;
  hasRequiredJettonMinter = 1;
  Object.defineProperty(JettonMinter, "__esModule", { value: true });
  JettonMinter.JettonMinter = JettonMinter.jettonMinterConfigToCell = void 0;
  const core_1 = requireDist$4();
  const JettonWallet_1 = requireJettonWallet$1();
  const content_1 = requireContent$2();
  const content_2 = requireContent$1();
  const jetton_minter_1 = requireJettonMinter$1();
  const types_1 = requireTypes();
  const JettonMintMessage_1 = requireJettonMintMessage();
  const JettonMinterContent_1 = requireJettonMinterContent();
  const JettonChangeAdminMessage_1 = requireJettonChangeAdminMessage();
  const JettonChangeContentMessage_1 = requireJettonChangeContentMessage();
  const JettonMinterAction_1 = requireJettonMinterAction();
  function jettonMinterConfigToCell(config) {
    return (0, core_1.beginCell)().store((0, JettonMinterContent_1.storeJettonMinterContent)({
      admin: config.admin,
      content: config.content,
      jettonWalletCode: config.jettonWalletCode ?? JettonWallet_1.JettonWallet.code
    })).endCell();
  }
  JettonMinter.jettonMinterConfigToCell = jettonMinterConfigToCell;
  let JettonMinter$1 = class JettonMinter2 {
    constructor(address, init, contentResolver) {
      this.address = address;
      this.init = init;
      this.contentResolver = contentResolver;
    }
    static createFromAddress(address, contentResolver) {
      return new JettonMinter2(address, void 0, contentResolver);
    }
    static createFromConfig(config, code, workchain, contentResolver) {
      const data = jettonMinterConfigToCell(config);
      const init = { data, code: code ?? JettonMinter2.code };
      return new JettonMinter2((0, core_1.contractAddress)(workchain ?? 0, init), init, contentResolver);
    }
    async sendDeploy(provider, sender, value) {
      await provider.internal(sender, {
        value: value ?? (0, core_1.toNano)("0.05"),
        bounce: true
      });
    }
    async sendMint(provider, sender, recipient, amount, options) {
      const notification = (0, types_1.parseNotifyOptions)(options?.notify);
      const excessReturn = (0, types_1.parseExcessReturnOptions)(options?.returnExcess, sender);
      await provider.internal(sender, {
        value: options?.value ?? (0, core_1.toNano)("0.05"),
        bounce: true,
        body: (0, core_1.beginCell)().store((0, JettonMintMessage_1.storeJettonMintMessage)({
          queryId: options?.queryId ?? 0n,
          amount,
          from: this.address,
          to: recipient,
          responseAddress: excessReturn?.address ?? null,
          forwardPayload: notification?.payload ?? null,
          forwardTonAmount: notification?.amount ?? 0n,
          walletForwardValue: (notification?.amount ?? 0n) + (excessReturn ? (0, core_1.toNano)("0.01") : 0n) + (0, core_1.toNano)(0.02)
        })).endCell()
      });
    }
    async sendChangeAdmin(provider, sender, newAdmin, options) {
      await provider.internal(sender, {
        value: options?.value ?? (0, core_1.toNano)("0.05"),
        bounce: true,
        body: (0, core_1.beginCell)().store((0, JettonChangeAdminMessage_1.storeJettonChangeAdminMessage)({
          queryId: options?.queryId ?? 0n,
          newAdmin
        })).endCell()
      });
    }
    async sendChangeContent(provider, sender, newContent, options) {
      await provider.internal(sender, {
        value: options?.value ?? (0, core_1.toNano)("0.05"),
        bounce: true,
        body: (0, core_1.beginCell)().store((0, JettonChangeContentMessage_1.storeJettonChangeContentMessage)({
          queryId: options?.queryId ?? 0n,
          newContent
        })).endCell()
      });
    }
    async getData(provider) {
      const builder2 = new core_1.TupleBuilder();
      const { stack } = await provider.get("get_jetton_data", builder2.build());
      return {
        totalSupply: stack.readBigNumber(),
        mintable: stack.readBigNumber() !== 0n,
        adminAddress: stack.readAddressOpt(),
        jettonContent: stack.readCell(),
        jettonWalletCode: stack.readCell()
      };
    }
    async getWalletAddress(provider, owner) {
      const builder2 = new core_1.TupleBuilder();
      builder2.writeAddress(owner);
      const { stack } = await provider.get("get_wallet_address", builder2.build());
      return stack.readAddress();
    }
    async getWallet(provider, owner) {
      const jettonWalletAddress = await this.getWalletAddress(provider, owner);
      return provider.open(new JettonWallet_1.JettonWallet(jettonWalletAddress));
    }
    async getContent(provider) {
      if (!this.contentResolver) {
        throw new Error("No content resolver");
      }
      const data = await this.getData(provider);
      return (0, content_2.parseJettonContent)(await (0, content_1.loadFullContent)(data.jettonContent, this.contentResolver));
    }
    async getActions(provider, options) {
      let { lt: lt2, hash, limit } = options ?? {};
      if (!lt2 || !hash) {
        const state = await provider.getState();
        if (!state.last) {
          return [];
        }
        lt2 = state.last.lt;
        hash = state.last.hash;
      }
      const transactions = await provider.getTransactions(this.address, lt2, hash, limit);
      return transactions.map((tx) => (0, JettonMinterAction_1.parseJettonMinterTransaction)(tx));
    }
  };
  JettonMinter.JettonMinter = JettonMinter$1;
  JettonMinter$1.code = core_1.Cell.fromBase64(jetton_minter_1.jettonMinterCode.codeBoc);
  return JettonMinter;
}
var NftCollection = {};
var NftCollectionBase = {};
var nftCollectionEditable = {};
var hasRequiredNftCollectionEditable;
function requireNftCollectionEditable() {
  if (hasRequiredNftCollectionEditable) return nftCollectionEditable;
  hasRequiredNftCollectionEditable = 1;
  Object.defineProperty(nftCollectionEditable, "__esModule", { value: true });
  nftCollectionEditable.nftCollectionEditableCode = void 0;
  nftCollectionEditable.nftCollectionEditableCode = {
    codeBoc: "te6ccgECFAEAAh8AART/APSkE/S88sgLAQIBYgIDAgLNBAUCASAODwTn0QY4BIrfAA6GmBgLjYSK3wfSAYAOmP6Z/2omh9IGmf6mpqGEEINJ6cqClAXUcUG6+CgOhBCFRlgFa4QAhkZYKoAueLEn0BCmW1CeWP5Z+A54tkwCB9gHAbKLnjgvlwyJLgAPGBEuABcYES4AHxgRgZgeACQGBwgJAgEgCgsAYDUC0z9TE7vy4ZJTE7oB+gDUMCgQNFnwBo4SAaRDQ8hQBc8WE8s/zMzMye1Ukl8F4gCmNXAD1DCON4BA9JZvpSCOKQakIIEA+r6T8sGP3oEBkyGgUyW78vQC+gDUMCJUSzDwBiO6kwKkAt4Ekmwh4rPmMDJQREMTyFAFzxYTyz/MzMzJ7VQALDI0AfpAMEFEyFAFzxYTyz/MzMzJ7VQAPI4V1NQwEDRBMMhQBc8WE8s/zMzMye1U4F8EhA/y8AIBIAwNAD1FrwBHAh8AV3gBjIywVYzxZQBPoCE8trEszMyXH7AIAC0AcjLP/gozxbJcCDIywET9AD0AMsAyYAAbPkAdMjLAhLKB8v/ydCACASAQEQAlvILfaiaH0gaZ/qamoYLehqGCxABDuLXTHtRND6QNM/1NTUMBAkXwTQ1DHUMNBxyMsHAc8WzMmAIBIBITAC+12v2omh9IGmf6mpqGDYg6GmH6Yf9IBhAALbT0faiaH0gaZ/qamoYCi+CeAI4APgCw"
  };
  return nftCollectionEditable;
}
var NftChangeContentMessage = {};
var NftRoyaltyParams = {};
var hasRequiredNftRoyaltyParams;
function requireNftRoyaltyParams() {
  if (hasRequiredNftRoyaltyParams) return NftRoyaltyParams;
  hasRequiredNftRoyaltyParams = 1;
  Object.defineProperty(NftRoyaltyParams, "__esModule", { value: true });
  NftRoyaltyParams.loadNftRoyaltyParams = NftRoyaltyParams.storeNftRoyaltyParams = void 0;
  function storeNftRoyaltyParams(src2) {
    return (builder2) => {
      builder2.storeUint(src2.numerator, 16);
      builder2.storeUint(src2.denominator, 16);
      builder2.storeAddress(src2.recipient);
    };
  }
  NftRoyaltyParams.storeNftRoyaltyParams = storeNftRoyaltyParams;
  function loadNftRoyaltyParams(slice) {
    return {
      numerator: slice.loadUintBig(16),
      denominator: slice.loadUintBig(16),
      recipient: slice.loadAddress()
    };
  }
  NftRoyaltyParams.loadNftRoyaltyParams = loadNftRoyaltyParams;
  return NftRoyaltyParams;
}
var opcodes = {};
var hasRequiredOpcodes;
function requireOpcodes() {
  if (hasRequiredOpcodes) return opcodes;
  hasRequiredOpcodes = 1;
  Object.defineProperty(opcodes, "__esModule", { value: true });
  opcodes.NFT_EXCESSES_OPCODE = opcodes.NFT_REPORT_STATIC_DATA_OPCODE = opcodes.NFT_GET_STATIC_DATA_OPCODE = opcodes.NFT_OWNER_ASSIGNED_OPCODE = opcodes.NFT_TRANSFER_OPCODE = opcodes.NFT_CHANGE_CONTENT_OPCODE = opcodes.NFT_CHANGE_ADMIN_OPCODE = opcodes.NFT_BATCH_MINT_OPCODE = opcodes.NFT_MINT_OPCODE = void 0;
  opcodes.NFT_MINT_OPCODE = 1;
  opcodes.NFT_BATCH_MINT_OPCODE = 2;
  opcodes.NFT_CHANGE_ADMIN_OPCODE = 3;
  opcodes.NFT_CHANGE_CONTENT_OPCODE = 4;
  opcodes.NFT_TRANSFER_OPCODE = 1607220500;
  opcodes.NFT_OWNER_ASSIGNED_OPCODE = 85167505;
  opcodes.NFT_GET_STATIC_DATA_OPCODE = 801842850;
  opcodes.NFT_REPORT_STATIC_DATA_OPCODE = 2339837749;
  opcodes.NFT_EXCESSES_OPCODE = 3576854235;
  return opcodes;
}
var hasRequiredNftChangeContentMessage;
function requireNftChangeContentMessage() {
  if (hasRequiredNftChangeContentMessage) return NftChangeContentMessage;
  hasRequiredNftChangeContentMessage = 1;
  Object.defineProperty(NftChangeContentMessage, "__esModule", { value: true });
  NftChangeContentMessage.loadNftChangeContentMessage = NftChangeContentMessage.storeNftChangeContentMessage = void 0;
  const NftRoyaltyParams_1 = requireNftRoyaltyParams();
  const opcodes_1 = requireOpcodes();
  function storeNftChangeContentMessage(src2) {
    return (builder2) => {
      builder2.storeUint(opcodes_1.NFT_CHANGE_CONTENT_OPCODE, 32);
      builder2.storeUint(src2.queryId, 64);
      builder2.storeRef(src2.newContent);
      builder2.store((0, NftRoyaltyParams_1.storeNftRoyaltyParams)(src2.newRoyaltyParams));
    };
  }
  NftChangeContentMessage.storeNftChangeContentMessage = storeNftChangeContentMessage;
  function loadNftChangeContentMessage(slice) {
    if (slice.loadUint(32) !== opcodes_1.NFT_CHANGE_CONTENT_OPCODE) {
      throw new Error("Wrong opcode");
    }
    const queryId = slice.loadUintBig(64);
    const newContent = slice.loadRef();
    const newRoyaltyParams = (0, NftRoyaltyParams_1.loadNftRoyaltyParams)(slice.loadRef().beginParse());
    return {
      queryId,
      newContent,
      newRoyaltyParams
    };
  }
  NftChangeContentMessage.loadNftChangeContentMessage = loadNftChangeContentMessage;
  return NftChangeContentMessage;
}
var NftMintMessage = {};
var hasRequiredNftMintMessage;
function requireNftMintMessage() {
  if (hasRequiredNftMintMessage) return NftMintMessage;
  hasRequiredNftMintMessage = 1;
  Object.defineProperty(NftMintMessage, "__esModule", { value: true });
  NftMintMessage.loadNftMintMessage = NftMintMessage.storeNftMintMessage = void 0;
  const core_1 = requireDist$4();
  const opcodes_1 = requireOpcodes();
  function storeNftMintMessage(src2, storeParams) {
    return (builder2) => {
      builder2.storeUint(opcodes_1.NFT_MINT_OPCODE, 32);
      builder2.storeUint(src2.queryId, 64);
      builder2.storeUint(src2.itemIndex, 64);
      builder2.storeCoins(src2.value);
      builder2.storeRef((0, core_1.beginCell)().store(storeParams(src2.itemParams)).endCell());
    };
  }
  NftMintMessage.storeNftMintMessage = storeNftMintMessage;
  function loadNftMintMessage(slice, loadParams) {
    if (slice.loadUint(32) !== opcodes_1.NFT_MINT_OPCODE) {
      throw new Error("Wrong opcode");
    }
    const queryId = slice.loadUintBig(64);
    const itemIndex = slice.loadUintBig(64);
    const value = slice.loadCoins();
    const itemParams = slice.loadRef();
    return {
      itemIndex,
      value,
      itemParams: loadParams(itemParams.beginParse()),
      queryId
    };
  }
  NftMintMessage.loadNftMintMessage = loadNftMintMessage;
  return NftMintMessage;
}
var NftBatchMintMessage = {};
var hasRequiredNftBatchMintMessage;
function requireNftBatchMintMessage() {
  if (hasRequiredNftBatchMintMessage) return NftBatchMintMessage;
  hasRequiredNftBatchMintMessage = 1;
  Object.defineProperty(NftBatchMintMessage, "__esModule", { value: true });
  NftBatchMintMessage.createNftMintItemValue = NftBatchMintMessage.loadNftBatchMintItem = NftBatchMintMessage.storeNftBatchMintItem = NftBatchMintMessage.loadNftBatchMintMessage = NftBatchMintMessage.storeNftBatchMintMessage = void 0;
  const core_1 = requireDist$4();
  const opcodes_1 = requireOpcodes();
  function storeNftBatchMintMessage(src2, storeParams) {
    return (builder2) => {
      const dict = core_1.Dictionary.empty(core_1.Dictionary.Keys.BigUint(64), createNftMintItemValue(storeParams));
      for (const r of src2.requests) {
        if (dict.has(r.index)) {
          throw new Error("Duplicate items");
        }
        dict.set(r.index, r);
      }
      builder2.storeUint(opcodes_1.NFT_BATCH_MINT_OPCODE, 32);
      builder2.storeUint(src2.queryId ?? 0, 64);
      builder2.storeRef((0, core_1.beginCell)().storeDictDirect(dict));
    };
  }
  NftBatchMintMessage.storeNftBatchMintMessage = storeNftBatchMintMessage;
  function loadNftBatchMintMessage(slice, loadParams) {
    if (slice.loadUint(32) !== opcodes_1.NFT_BATCH_MINT_OPCODE) {
      throw new Error("Wrong opcode");
    }
    const queryId = slice.loadUintBig(64);
    const requests = slice.loadDictDirect(core_1.Dictionary.Keys.BigUint(64), createNftMintItemValue(void 0, loadParams));
    return {
      queryId,
      requests: requests.values()
    };
  }
  NftBatchMintMessage.loadNftBatchMintMessage = loadNftBatchMintMessage;
  function storeNftBatchMintItem(request, storeParams) {
    return (builder2) => {
      builder2.storeCoins(request.value ?? (0, core_1.toNano)("0.03"));
      builder2.storeRef((0, core_1.beginCell)().store(storeParams(request.params)).endCell());
    };
  }
  NftBatchMintMessage.storeNftBatchMintItem = storeNftBatchMintItem;
  function loadNftBatchMintItem(slice, loadParams) {
    const itemIndex = slice.loadUintBig(64);
    const value = slice.loadCoins();
    const params = slice.loadRef();
    return {
      index: itemIndex,
      value,
      params: loadParams(params.beginParse())
    };
  }
  NftBatchMintMessage.loadNftBatchMintItem = loadNftBatchMintItem;
  function createNftMintItemValue(storeParams, loadParams) {
    return {
      serialize(src2, builder2) {
        if (!storeParams) {
          throw new Error("storeParams is not defined");
        }
        builder2.store(storeNftBatchMintItem(src2, storeParams));
      },
      parse(src2) {
        if (!loadParams) {
          throw new Error("loadParams is not defined");
        }
        return loadNftBatchMintItem(src2, loadParams);
      }
    };
  }
  NftBatchMintMessage.createNftMintItemValue = createNftMintItemValue;
  return NftBatchMintMessage;
}
var NftChangeAdminMessage = {};
var hasRequiredNftChangeAdminMessage;
function requireNftChangeAdminMessage() {
  if (hasRequiredNftChangeAdminMessage) return NftChangeAdminMessage;
  hasRequiredNftChangeAdminMessage = 1;
  Object.defineProperty(NftChangeAdminMessage, "__esModule", { value: true });
  NftChangeAdminMessage.loadNftChangeAdminMessage = NftChangeAdminMessage.storeNftChangeAdminMessage = void 0;
  const opcodes_1 = requireOpcodes();
  function storeNftChangeAdminMessage(src2) {
    return (builder2) => {
      builder2.storeUint(opcodes_1.NFT_CHANGE_ADMIN_OPCODE, 32);
      builder2.storeUint(src2.queryId ?? 0, 64);
      builder2.storeAddress(src2.newAdmin);
    };
  }
  NftChangeAdminMessage.storeNftChangeAdminMessage = storeNftChangeAdminMessage;
  function loadNftChangeAdminMessage(slice) {
    if (slice.loadUint(32) !== opcodes_1.NFT_CHANGE_ADMIN_OPCODE) {
      throw new Error("Wrong opcode");
    }
    const queryId = slice.loadUintBig(64);
    const newAdmin = slice.loadAddress();
    return {
      queryId,
      newAdmin
    };
  }
  NftChangeAdminMessage.loadNftChangeAdminMessage = loadNftChangeAdminMessage;
  return NftChangeAdminMessage;
}
var hasRequiredNftCollectionBase;
function requireNftCollectionBase() {
  if (hasRequiredNftCollectionBase) return NftCollectionBase;
  hasRequiredNftCollectionBase = 1;
  Object.defineProperty(NftCollectionBase, "__esModule", { value: true });
  NftCollectionBase.NftCollectionBase = void 0;
  const core_1 = requireDist$4();
  const content_1 = requireContent$2();
  const content_2 = requireContent();
  const nft_collection_editable_1 = requireNftCollectionEditable();
  const NftChangeContentMessage_1 = requireNftChangeContentMessage();
  const NftMintMessage_1 = requireNftMintMessage();
  const NftBatchMintMessage_1 = requireNftBatchMintMessage();
  const NftChangeAdminMessage_1 = requireNftChangeAdminMessage();
  let NftCollectionBase$1 = class NftCollectionBase {
    constructor(address, init, contentResolver, nftItemParamsValue) {
      this.address = address;
      this.init = init;
      this.contentResolver = contentResolver;
      this.itemParamsValue = nftItemParamsValue;
    }
    async sendDeploy(provider, sender, value) {
      await provider.internal(sender, {
        value: value ?? (0, core_1.toNano)("0.05"),
        bounce: true
      });
    }
    async sendMint(provider, sender, item, options) {
      if (this.itemParamsValue === void 0) {
        throw new Error("No item params value");
      }
      await provider.internal(sender, {
        value: options?.value ?? (0, core_1.toNano)("0.05"),
        bounce: true,
        sendMode: core_1.SendMode.PAY_GAS_SEPARATELY,
        body: (0, core_1.beginCell)().store((0, NftMintMessage_1.storeNftMintMessage)({
          queryId: options?.queryId ?? 0n,
          itemIndex: item.index,
          itemParams: item,
          value: item.value ?? (0, core_1.toNano)("0.03")
        }, this.itemParamsValue.store)).endCell()
      });
    }
    async sendBatchMint(provider, sender, items, options) {
      if (this.itemParamsValue === void 0) {
        throw new Error("No item params value");
      }
      await provider.internal(sender, {
        value: options?.value ?? (0, core_1.toNano)("0.05") * BigInt(items.length),
        bounce: true,
        body: (0, core_1.beginCell)().store((0, NftBatchMintMessage_1.storeNftBatchMintMessage)({
          queryId: options?.queryId ?? 0n,
          requests: items.map((item) => ({
            index: item.index,
            params: item,
            value: item.value ?? (0, core_1.toNano)("0.03")
          }))
        }, this.itemParamsValue.store)).endCell()
      });
    }
    async sendChangeAdmin(provider, sender, newAdmin, options) {
      await provider.internal(sender, {
        value: options?.value ?? (0, core_1.toNano)("0.05"),
        bounce: true,
        body: (0, core_1.beginCell)().store((0, NftChangeAdminMessage_1.storeNftChangeAdminMessage)({
          newAdmin,
          queryId: options?.queryId ?? 0n
        })).endCell()
      });
    }
    async sendChangeContent(provider, sender, message, options) {
      await provider.internal(sender, {
        value: options?.value ?? (0, core_1.toNano)("0.05"),
        bounce: true,
        body: (0, core_1.beginCell)().store((0, NftChangeContentMessage_1.storeNftChangeContentMessage)({
          queryId: options?.queryId ?? 0n,
          newContent: message.newContent,
          newRoyaltyParams: message.newRoyaltyParams
        })).endCell()
      });
    }
    async getItemAddress(provider, index) {
      const ret = await provider.get("get_nft_address_by_index", [{ type: "int", value: index }]);
      return ret.stack.readAddress();
    }
    async getData(provider) {
      const ret = await provider.get("get_collection_data", []);
      return {
        nextItemIndex: ret.stack.readBigNumber(),
        content: ret.stack.readCell(),
        owner: ret.stack.readAddressOpt()
      };
    }
    async getContent(provider) {
      if (this.contentResolver === void 0) {
        throw new Error("No content resolver");
      }
      const data = await this.getData(provider);
      return (0, content_2.parseNftContent)(await (0, content_1.loadFullContent)(data.content, this.contentResolver));
    }
    async getItemContent(provider, index, individualContent) {
      const res = await provider.get("get_nft_content", [{
        type: "int",
        value: index
      }, {
        type: "cell",
        cell: individualContent
      }]);
      return res.stack.readCell();
    }
  };
  NftCollectionBase.NftCollectionBase = NftCollectionBase$1;
  NftCollectionBase$1.code = core_1.Cell.fromBase64(nft_collection_editable_1.nftCollectionEditableCode.codeBoc);
  return NftCollectionBase;
}
var NftItem = {};
var nftItem = {};
var hasRequiredNftItem$1;
function requireNftItem$1() {
  if (hasRequiredNftItem$1) return nftItem;
  hasRequiredNftItem$1 = 1;
  Object.defineProperty(nftItem, "__esModule", { value: true });
  nftItem.nftItemCode = void 0;
  nftItem.nftItemCode = {
    codeBoc: "te6ccgECDgEAAdwAART/APSkE/S88sgLAQIBYgIDAgLOBAUACaEfn+AFAgEgBgcCASAMDQLPDIhxwCSXwPg0NMDAXGwkl8D4PpA+kAx+gAxcdch+gAx+gAwc6m0APACBLOOFDBsIjRSMscF8uGVAfpA1DAQI/AD4AbTH9M/ghBfzD0UUjC64wIwNDQ1NYIQL8smohK64wJfBIQP8vCAICQARPpEMHC68uFNgAqwyEDdeMkATUTXHBfLhkfpAIfAB+kDSADH6ACDXScIA8uLEggr68IAboSGUUxWgod4i1wsBwwAgkgahkTbiIML/8uGSIZQQKjdb4w0CkzAyNOMNVQLwAwoLAHJwghCLdxc1BcjL/1AEzxYQJIBAcIAQyMsFUAfPFlAF+gIVy2oSyx/LPyJus5RYzxcBkTLiAckB+wAAfIIQBRONkchQCc8WUAvPFnEkSRRURqBwgBDIywVQB88WUAX6AhXLahLLH8s/Im6zlFjPFwGRMuIByQH7ABBHAGom8AGCENUydtsQN0QAbXFwgBDIywVQB88WUAX6AhXLahLLH8s/Im6zlFjPFwGRMuIByQH7AAA7O1E0NM/+kAg10nCAJp/AfpA1DAQJBAj4DBwWW1tgAB0A8jLP1jPFgHPFszJ7VSA="
  };
  return nftItem;
}
var NftItemParams = {};
var hasRequiredNftItemParams;
function requireNftItemParams() {
  if (hasRequiredNftItemParams) return NftItemParams;
  hasRequiredNftItemParams = 1;
  Object.defineProperty(NftItemParams, "__esModule", { value: true });
  NftItemParams.createNftItemParamsValue = NftItemParams.loadNftItemParams = NftItemParams.storeNftItemParams = void 0;
  const core_1 = requireDist$4();
  function storeNftItemParams(src2) {
    return (builder2) => {
      builder2.storeAddress(src2.owner);
      if (typeof src2.individualContent === "string") {
        builder2.storeRef((0, core_1.beginCell)().storeStringTail(src2.individualContent).endCell());
      } else {
        builder2.storeRef(src2.individualContent);
      }
    };
  }
  NftItemParams.storeNftItemParams = storeNftItemParams;
  function loadNftItemParams(slice) {
    return {
      owner: slice.loadAddress(),
      individualContent: slice.loadRef()
    };
  }
  NftItemParams.loadNftItemParams = loadNftItemParams;
  function createNftItemParamsValue() {
    return {
      store: storeNftItemParams,
      load: loadNftItemParams
    };
  }
  NftItemParams.createNftItemParamsValue = createNftItemParamsValue;
  return NftItemParams;
}
var NftTransferMessage = {};
var hasRequiredNftTransferMessage;
function requireNftTransferMessage() {
  if (hasRequiredNftTransferMessage) return NftTransferMessage;
  hasRequiredNftTransferMessage = 1;
  Object.defineProperty(NftTransferMessage, "__esModule", { value: true });
  NftTransferMessage.loadNftTransferMessage = NftTransferMessage.storeNftTransferMessage = void 0;
  const opcodes_1 = requireOpcodes();
  function storeNftTransferMessage(message) {
    return (builder2) => {
      const { queryId, newOwner, responseDestination, customPayload, forwardAmount, forwardPayload } = message;
      builder2.storeUint(opcodes_1.NFT_TRANSFER_OPCODE, 32).storeUint(queryId, 64).storeAddress(newOwner).storeAddress(responseDestination).storeMaybeRef(customPayload).storeCoins(forwardAmount).storeMaybeRef(forwardPayload);
    };
  }
  NftTransferMessage.storeNftTransferMessage = storeNftTransferMessage;
  function loadNftTransferMessage(slice) {
    if (slice.loadUint(32) !== opcodes_1.NFT_TRANSFER_OPCODE) {
      throw new Error("Wrong opcode");
    }
    const queryId = slice.loadUintBig(64);
    const newOwner = slice.loadAddress();
    const responseDestination = slice.loadMaybeAddress();
    const customPayload = slice.loadMaybeRef();
    const forwardAmount = slice.loadCoins();
    const eitherPayload = slice.loadBoolean();
    const forwardPayload = eitherPayload ? slice.loadRef() : slice.asCell();
    return {
      queryId,
      newOwner,
      responseDestination,
      customPayload,
      forwardAmount,
      forwardPayload
    };
  }
  NftTransferMessage.loadNftTransferMessage = loadNftTransferMessage;
  return NftTransferMessage;
}
var NftItemAction = {};
var NftMessage = {};
var NftDeployMessage = {};
var hasRequiredNftDeployMessage;
function requireNftDeployMessage() {
  if (hasRequiredNftDeployMessage) return NftDeployMessage;
  hasRequiredNftDeployMessage = 1;
  Object.defineProperty(NftDeployMessage, "__esModule", { value: true });
  NftDeployMessage.loadNftDeployMessage = NftDeployMessage.storeNftDeployMessage = void 0;
  function storeNftDeployMessage(message) {
    return (builder2) => {
      const { owner, content: content2 } = message;
      builder2.storeAddress(owner).storeRef(content2);
    };
  }
  NftDeployMessage.storeNftDeployMessage = storeNftDeployMessage;
  function loadNftDeployMessage(slice) {
    const owner = slice.loadAddress();
    const content2 = slice.loadRef();
    return {
      owner,
      content: content2
    };
  }
  NftDeployMessage.loadNftDeployMessage = loadNftDeployMessage;
  return NftDeployMessage;
}
var NftGetStaticDataMessage = {};
var hasRequiredNftGetStaticDataMessage;
function requireNftGetStaticDataMessage() {
  if (hasRequiredNftGetStaticDataMessage) return NftGetStaticDataMessage;
  hasRequiredNftGetStaticDataMessage = 1;
  Object.defineProperty(NftGetStaticDataMessage, "__esModule", { value: true });
  NftGetStaticDataMessage.loadNftGetStaticDataMessage = NftGetStaticDataMessage.storeNftGetStaticDataMessage = void 0;
  const opcodes_1 = requireOpcodes();
  function storeNftGetStaticDataMessage(message) {
    return (builder2) => {
      const { queryId } = message;
      builder2.storeUint(opcodes_1.NFT_GET_STATIC_DATA_OPCODE, 32).storeUint(queryId, 64);
    };
  }
  NftGetStaticDataMessage.storeNftGetStaticDataMessage = storeNftGetStaticDataMessage;
  function loadNftGetStaticDataMessage(slice) {
    if (slice.loadUint(32) !== opcodes_1.NFT_GET_STATIC_DATA_OPCODE) {
      throw new Error("Wrong opcode");
    }
    const queryId = slice.loadUintBig(64);
    return {
      queryId
    };
  }
  NftGetStaticDataMessage.loadNftGetStaticDataMessage = loadNftGetStaticDataMessage;
  return NftGetStaticDataMessage;
}
var NftReportStaticDataMessage = {};
var hasRequiredNftReportStaticDataMessage;
function requireNftReportStaticDataMessage() {
  if (hasRequiredNftReportStaticDataMessage) return NftReportStaticDataMessage;
  hasRequiredNftReportStaticDataMessage = 1;
  Object.defineProperty(NftReportStaticDataMessage, "__esModule", { value: true });
  NftReportStaticDataMessage.loadNftReportStaticDataMessage = NftReportStaticDataMessage.storeNftReportStaticDataMessage = void 0;
  const opcodes_1 = requireOpcodes();
  function storeNftReportStaticDataMessage(message) {
    return (builder2) => {
      const { queryId, index, collection } = message;
      builder2.storeUint(opcodes_1.NFT_REPORT_STATIC_DATA_OPCODE, 32).storeUint(queryId, 64).storeUint(index, 256).storeAddress(collection);
    };
  }
  NftReportStaticDataMessage.storeNftReportStaticDataMessage = storeNftReportStaticDataMessage;
  function loadNftReportStaticDataMessage(slice) {
    if (slice.loadUint(32) !== opcodes_1.NFT_REPORT_STATIC_DATA_OPCODE) {
      throw new Error("Wrong opcode");
    }
    const queryId = slice.loadUintBig(64);
    const index = slice.loadUintBig(256);
    const collection = slice.loadAddress();
    return {
      queryId,
      index,
      collection
    };
  }
  NftReportStaticDataMessage.loadNftReportStaticDataMessage = loadNftReportStaticDataMessage;
  return NftReportStaticDataMessage;
}
var NftOwnerAssignedMessage = {};
var hasRequiredNftOwnerAssignedMessage;
function requireNftOwnerAssignedMessage() {
  if (hasRequiredNftOwnerAssignedMessage) return NftOwnerAssignedMessage;
  hasRequiredNftOwnerAssignedMessage = 1;
  Object.defineProperty(NftOwnerAssignedMessage, "__esModule", { value: true });
  NftOwnerAssignedMessage.loadNftOwnerAssignedMessage = NftOwnerAssignedMessage.storeNftOwnerAssignedMessage = void 0;
  const opcodes_1 = requireOpcodes();
  function storeNftOwnerAssignedMessage(message) {
    return (builder2) => {
      const { queryId, previousOwner, payload } = message;
      builder2.storeUint(opcodes_1.NFT_OWNER_ASSIGNED_OPCODE, 32).storeUint(queryId, 64).storeAddress(previousOwner).storeMaybeRef(payload);
    };
  }
  NftOwnerAssignedMessage.storeNftOwnerAssignedMessage = storeNftOwnerAssignedMessage;
  function loadNftOwnerAssignedMessage(slice) {
    if (slice.loadUint(32) !== opcodes_1.NFT_OWNER_ASSIGNED_OPCODE) {
      throw new Error("Wrong opcode");
    }
    const queryId = slice.loadUintBig(64);
    const previousOwner = slice.loadAddress();
    const eitherPayload = slice.loadBoolean();
    const payload = eitherPayload ? slice.loadRef() : slice.asCell();
    return {
      queryId,
      previousOwner,
      payload
    };
  }
  NftOwnerAssignedMessage.loadNftOwnerAssignedMessage = loadNftOwnerAssignedMessage;
  return NftOwnerAssignedMessage;
}
var NftExcessesMessage = {};
var hasRequiredNftExcessesMessage;
function requireNftExcessesMessage() {
  if (hasRequiredNftExcessesMessage) return NftExcessesMessage;
  hasRequiredNftExcessesMessage = 1;
  Object.defineProperty(NftExcessesMessage, "__esModule", { value: true });
  NftExcessesMessage.loadNftExcessesMessage = NftExcessesMessage.storeNftExcessesMessage = void 0;
  const opcodes_1 = requireOpcodes();
  function storeNftExcessesMessage(message) {
    return (builder2) => {
      const { queryId } = message;
      builder2.storeUint(opcodes_1.NFT_EXCESSES_OPCODE, 32).storeUint(queryId, 64);
    };
  }
  NftExcessesMessage.storeNftExcessesMessage = storeNftExcessesMessage;
  function loadNftExcessesMessage(slice) {
    if (slice.loadUint(32) !== opcodes_1.NFT_EXCESSES_OPCODE) {
      throw new Error("Wrong opcode");
    }
    const queryId = slice.loadUintBig(64);
    return {
      queryId
    };
  }
  NftExcessesMessage.loadNftExcessesMessage = loadNftExcessesMessage;
  return NftExcessesMessage;
}
var hasRequiredNftMessage;
function requireNftMessage() {
  if (hasRequiredNftMessage) return NftMessage;
  hasRequiredNftMessage = 1;
  Object.defineProperty(NftMessage, "__esModule", { value: true });
  NftMessage.loadNftMessage = void 0;
  const NftDeployMessage_1 = requireNftDeployMessage();
  const NftTransferMessage_1 = requireNftTransferMessage();
  const NftGetStaticDataMessage_1 = requireNftGetStaticDataMessage();
  const NftReportStaticDataMessage_1 = requireNftReportStaticDataMessage();
  const NftOwnerAssignedMessage_1 = requireNftOwnerAssignedMessage();
  const opcodes_1 = requireOpcodes();
  const NftExcessesMessage_1 = requireNftExcessesMessage();
  function loadNftMessage(slice) {
    try {
      const opcode = slice.preloadUint(32);
      switch (opcode) {
        case opcodes_1.NFT_TRANSFER_OPCODE:
          return { kind: "nft_transfer", ...(0, NftTransferMessage_1.loadNftTransferMessage)(slice) };
        case opcodes_1.NFT_OWNER_ASSIGNED_OPCODE:
          return { kind: "owner_assigned", ...(0, NftOwnerAssignedMessage_1.loadNftOwnerAssignedMessage)(slice) };
        case opcodes_1.NFT_REPORT_STATIC_DATA_OPCODE:
          return { kind: "report_static_data", ...(0, NftReportStaticDataMessage_1.loadNftReportStaticDataMessage)(slice) };
        case opcodes_1.NFT_GET_STATIC_DATA_OPCODE:
          return { kind: "get_static_data", ...(0, NftGetStaticDataMessage_1.loadNftGetStaticDataMessage)(slice) };
        case opcodes_1.NFT_EXCESSES_OPCODE:
          return { kind: "excesses", ...(0, NftExcessesMessage_1.loadNftExcessesMessage)(slice) };
      }
      if (slice.remainingBits === 256 + 11 && slice.remainingRefs === 1) {
        return { kind: "nft_deploy", ...(0, NftDeployMessage_1.loadNftDeployMessage)(slice) };
      }
    } catch (e) {
    }
    return { kind: "unknown" };
  }
  NftMessage.loadNftMessage = loadNftMessage;
  return NftMessage;
}
var hasRequiredNftItemAction;
function requireNftItemAction() {
  if (hasRequiredNftItemAction) return NftItemAction;
  hasRequiredNftItemAction = 1;
  Object.defineProperty(NftItemAction, "__esModule", { value: true });
  NftItemAction.parseNftItemTransaction = void 0;
  const NftMessage_1 = requireNftMessage();
  const TransferAction_1 = requireTransferAction();
  function parseNftItemTransaction(tx) {
    const mayBeTransfer = (0, TransferAction_1.parseTransferTransaction)(tx);
    if (mayBeTransfer.kind !== "unknown") {
      return mayBeTransfer;
    }
    if (tx.description.type !== "generic") {
      return { kind: "unknown", transaction: tx };
    }
    if (!tx.inMessage) {
      return { kind: "unknown", transaction: tx };
    }
    if (tx.inMessage.info.type !== "internal") {
      return { kind: "unknown", transaction: tx };
    }
    if (tx.description.computePhase.type !== "vm") {
      return { kind: "unknown", transaction: tx };
    }
    if (tx.description.computePhase.exitCode !== 0) {
      return { kind: "unknown", transaction: tx };
    }
    const inMessage = (0, NftMessage_1.loadNftMessage)(tx.inMessage.body.beginParse());
    if (inMessage.kind === "nft_deploy") {
      return {
        kind: "deploy",
        owner: inMessage.owner,
        content: inMessage.content,
        collection: tx.inMessage.info.src,
        transaction: tx
      };
    }
    if (inMessage.kind === "nft_transfer") {
      return {
        kind: "nft_transfer",
        queryId: inMessage.queryId,
        newOwner: inMessage.newOwner,
        customPayload: inMessage.customPayload ?? null,
        forwardAmount: inMessage.forwardAmount,
        forwardPayload: inMessage.forwardPayload ?? null,
        transaction: tx
      };
    }
    return { kind: "unknown", transaction: tx };
  }
  NftItemAction.parseNftItemTransaction = parseNftItemTransaction;
  return NftItemAction;
}
var hasRequiredNftItem;
function requireNftItem() {
  if (hasRequiredNftItem) return NftItem;
  hasRequiredNftItem = 1;
  Object.defineProperty(NftItem, "__esModule", { value: true });
  NftItem.NftItem = NftItem.nftItemConfigToCell = void 0;
  const core_1 = requireDist$4();
  const content_1 = requireContent$2();
  const NftCollection_1 = requireNftCollection();
  const content_2 = requireContent();
  const nft_item_1 = requireNftItem$1();
  const types_1 = requireTypes();
  const NftItemParams_1 = requireNftItemParams();
  const NftTransferMessage_1 = requireNftTransferMessage();
  const NftItemAction_1 = requireNftItemAction();
  function nftItemConfigToCell(config) {
    return (0, core_1.beginCell)().storeUint(config.index, 64).storeAddress(config.collection).endCell();
  }
  NftItem.nftItemConfigToCell = nftItemConfigToCell;
  let NftItem$1 = class NftItem2 {
    constructor(address, init, contentResolver) {
      this.address = address;
      this.init = init;
      this.contentResolver = contentResolver;
    }
    static createFromConfig(config, code, workchain, contentResolver) {
      const data = nftItemConfigToCell(config);
      const init = { data, code: code ?? NftItem2.nftCode };
      return new NftItem2((0, core_1.contractAddress)(workchain ?? 0, init), init, contentResolver);
    }
    static createFromAddress(address, contentResolver) {
      return new NftItem2(address, void 0, contentResolver);
    }
    async sendDeploy(provider, sender, params, value) {
      await provider.internal(sender, {
        value: value ?? (0, core_1.toNano)("0.05"),
        bounce: true,
        body: (0, core_1.beginCell)().store((0, NftItemParams_1.storeNftItemParams)(params)).endCell()
      });
    }
    async send(provider, sender, newOwner, options) {
      const notification = (0, types_1.parseNotifyOptions)(options?.notify);
      const excessReturn = (0, types_1.parseExcessReturnOptions)(options?.returnExcess, sender);
      await provider.internal(sender, {
        value: (options?.value ?? (0, core_1.toNano)("0.05")) + (notification?.amount ?? 0n),
        bounce: true,
        sendMode: core_1.SendMode.PAY_GAS_SEPARATELY,
        body: (0, core_1.beginCell)().store((0, NftTransferMessage_1.storeNftTransferMessage)({
          queryId: options?.queryId ?? 0n,
          newOwner,
          responseDestination: excessReturn?.address ?? null,
          customPayload: options?.customPayload ?? null,
          forwardAmount: notification?.amount ?? 0n,
          forwardPayload: notification?.payload ?? null
        })).endCell()
      });
    }
    async getData(provider) {
      const { stack } = await provider.get("get_nft_data", []);
      return {
        initialized: stack.readBoolean(),
        index: stack.readBigNumber(),
        collection: stack.readAddressOpt(),
        owner: stack.readAddressOpt(),
        individualContent: stack.readCellOpt()
      };
    }
    async getContent(provider) {
      if (this.contentResolver === void 0) {
        throw new Error("No content resolver");
      }
      const { collection, individualContent, index } = await this.getData(provider);
      if (individualContent === null) {
        throw new Error("Individual content is null");
      }
      let content2;
      if (collection === null) {
        content2 = individualContent;
      } else {
        const collectionContract = provider.open(NftCollection_1.NftCollection.createFromAddress(collection, this.contentResolver));
        content2 = await collectionContract.getItemContent(index, individualContent);
      }
      return (0, content_2.parseNftContent)(await (0, content_1.loadFullContent)(content2, this.contentResolver));
    }
    async getRoyaltyParams(provider) {
      const { collection } = await this.getData(provider);
      if (collection === null) {
        return this.getNftItemRoyaltyParams(provider);
      }
      const collectionContract = provider.open(NftCollection_1.NftCollection.createFromAddress(collection, this.contentResolver));
      return collectionContract.getRoyaltyParams();
    }
    async getNftItemRoyaltyParams(provider) {
      const { stack } = await provider.get("get_royalty_params", []);
      return {
        numerator: stack.readBigNumber(),
        denominator: stack.readBigNumber(),
        recipient: stack.readAddress()
      };
    }
    async getActions(provider, options) {
      let { lt: lt2, hash, limit } = options ?? {};
      if (!lt2 || !hash) {
        const state = await provider.getState();
        if (!state.last) {
          return [];
        }
        lt2 = state.last.lt;
        hash = state.last.hash;
      }
      const transactions = await provider.getTransactions(this.address, lt2, hash, limit);
      return transactions.map((tx) => (0, NftItemAction_1.parseNftItemTransaction)(tx));
    }
  };
  NftItem.NftItem = NftItem$1;
  NftItem$1.nftCode = core_1.Cell.fromBase64(nft_item_1.nftItemCode.codeBoc);
  return NftItem;
}
var NftCollectionData = {};
var hasRequiredNftCollectionData;
function requireNftCollectionData() {
  if (hasRequiredNftCollectionData) return NftCollectionData;
  hasRequiredNftCollectionData = 1;
  Object.defineProperty(NftCollectionData, "__esModule", { value: true });
  NftCollectionData.loadNftCollectionData = NftCollectionData.storeNftCollectionData = void 0;
  const core_1 = requireDist$4();
  const NftRoyaltyParams_1 = requireNftRoyaltyParams();
  function storeNftCollectionData(src2) {
    return (builder2) => {
      builder2.storeAddress(src2.admin);
      builder2.storeUint(0, 64);
      builder2.storeRef(src2.content);
      builder2.storeRef(src2.itemCode);
      builder2.storeRef((0, core_1.beginCell)().store((0, NftRoyaltyParams_1.storeNftRoyaltyParams)(src2.royalty)).endCell());
    };
  }
  NftCollectionData.storeNftCollectionData = storeNftCollectionData;
  function loadNftCollectionData(slice) {
    return {
      admin: slice.loadAddress(),
      content: slice.loadRef(),
      itemCode: slice.loadRef(),
      royalty: (0, NftRoyaltyParams_1.loadNftRoyaltyParams)(slice)
    };
  }
  NftCollectionData.loadNftCollectionData = loadNftCollectionData;
  return NftCollectionData;
}
var NftCollectionAction = {};
var NftCollectionMessage = {};
var hasRequiredNftCollectionMessage;
function requireNftCollectionMessage() {
  if (hasRequiredNftCollectionMessage) return NftCollectionMessage;
  hasRequiredNftCollectionMessage = 1;
  Object.defineProperty(NftCollectionMessage, "__esModule", { value: true });
  NftCollectionMessage.loadNftCollectionMessage = void 0;
  const opcodes_1 = requireOpcodes();
  const NftMintMessage_1 = requireNftMintMessage();
  const NftBatchMintMessage_1 = requireNftBatchMintMessage();
  const NftChangeAdminMessage_1 = requireNftChangeAdminMessage();
  const NftChangeContentMessage_1 = requireNftChangeContentMessage();
  function loadNftCollectionMessage(slice, paramsValue) {
    try {
      const op = slice.preloadUint(32);
      switch (op) {
        case opcodes_1.NFT_MINT_OPCODE: {
          return { kind: "mint", ...(0, NftMintMessage_1.loadNftMintMessage)(slice, paramsValue.load) };
        }
        case opcodes_1.NFT_BATCH_MINT_OPCODE: {
          return { kind: "mint_batch", ...(0, NftBatchMintMessage_1.loadNftBatchMintMessage)(slice, paramsValue.load) };
        }
        case opcodes_1.NFT_CHANGE_ADMIN_OPCODE: {
          return { kind: "change_admin", ...(0, NftChangeAdminMessage_1.loadNftChangeAdminMessage)(slice) };
        }
        case opcodes_1.NFT_CHANGE_CONTENT_OPCODE: {
          return { kind: "change_content", ...(0, NftChangeContentMessage_1.loadNftChangeContentMessage)(slice) };
        }
      }
    } catch (e) {
    }
    return { kind: "unknown" };
  }
  NftCollectionMessage.loadNftCollectionMessage = loadNftCollectionMessage;
  return NftCollectionMessage;
}
var hasRequiredNftCollectionAction;
function requireNftCollectionAction() {
  if (hasRequiredNftCollectionAction) return NftCollectionAction;
  hasRequiredNftCollectionAction = 1;
  Object.defineProperty(NftCollectionAction, "__esModule", { value: true });
  NftCollectionAction.parseNftCollectionTransaction = void 0;
  const NftCollectionMessage_1 = requireNftCollectionMessage();
  const NftItemParams_1 = requireNftItemParams();
  const TransferAction_1 = requireTransferAction();
  function parseNftCollectionTransaction(tx) {
    const mayBeTransfer = (0, TransferAction_1.parseTransferTransaction)(tx);
    if (mayBeTransfer.kind !== "unknown") {
      return mayBeTransfer;
    }
    if (tx.description.type !== "generic") {
      return { kind: "unknown", transaction: tx };
    }
    if (!tx.inMessage) {
      return { kind: "unknown", transaction: tx };
    }
    if (tx.inMessage.info.type !== "internal") {
      return { kind: "unknown", transaction: tx };
    }
    if (tx.description.computePhase.type !== "vm") {
      return { kind: "unknown", transaction: tx };
    }
    if (tx.description.computePhase.exitCode !== 0) {
      return { kind: "unknown", transaction: tx };
    }
    const inMessage = (0, NftCollectionMessage_1.loadNftCollectionMessage)(tx.inMessage.body.beginParse(), (0, NftItemParams_1.createNftItemParamsValue)());
    if (inMessage.kind === "mint") {
      return {
        kind: "mint",
        queryId: inMessage.queryId,
        index: inMessage.itemIndex,
        owner: inMessage.itemParams.owner,
        content: inMessage.itemParams.individualContent,
        transaction: tx
      };
    }
    if (inMessage.kind === "mint_batch") {
      return {
        kind: "mint_batch",
        queryId: inMessage.queryId,
        items: inMessage.requests.map((item) => ({
          index: item.index,
          owner: item.params.owner,
          content: item.params.individualContent
        })),
        transaction: tx
      };
    }
    if (inMessage.kind === "change_admin") {
      return {
        kind: "change_owner",
        queryId: inMessage.queryId,
        newOwner: inMessage.newAdmin,
        transaction: tx
      };
    }
    if (inMessage.kind === "change_content") {
      return {
        kind: "change_content",
        queryId: inMessage.queryId,
        newContent: inMessage.newContent,
        newRoyalty: inMessage.newRoyaltyParams,
        transaction: tx
      };
    }
    return { kind: "unknown", transaction: tx };
  }
  NftCollectionAction.parseNftCollectionTransaction = parseNftCollectionTransaction;
  return NftCollectionAction;
}
var hasRequiredNftCollection;
function requireNftCollection() {
  if (hasRequiredNftCollection) return NftCollection;
  hasRequiredNftCollection = 1;
  Object.defineProperty(NftCollection, "__esModule", { value: true });
  NftCollection.NftCollection = NftCollection.nftCollectionConfigToCell = void 0;
  const core_1 = requireDist$4();
  const NftCollectionBase_1 = requireNftCollectionBase();
  const NftItem_1 = requireNftItem();
  const NftCollectionData_1 = requireNftCollectionData();
  const NftItemParams_1 = requireNftItemParams();
  const NftCollectionAction_1 = requireNftCollectionAction();
  function nftCollectionConfigToCell(config) {
    return (0, core_1.beginCell)().store((0, NftCollectionData_1.storeNftCollectionData)({
      admin: config.admin,
      content: config.content,
      itemCode: config.itemCode ?? NftItem_1.NftItem.nftCode,
      royalty: {
        numerator: config.royalty?.numerator ?? 0n,
        denominator: config.royalty?.denominator ?? 1n,
        recipient: config.royalty?.recipient ?? config.admin
      }
    })).endCell();
  }
  NftCollection.nftCollectionConfigToCell = nftCollectionConfigToCell;
  let NftCollection$1 = class NftCollection2 extends NftCollectionBase_1.NftCollectionBase {
    static createFromConfig(config, code, workchain, contentResolver) {
      const data = nftCollectionConfigToCell(config);
      const init = { data, code: code ?? NftCollectionBase_1.NftCollectionBase.code };
      return new NftCollection2((0, core_1.contractAddress)(workchain ?? 0, init), init, contentResolver, (0, NftItemParams_1.createNftItemParamsValue)());
    }
    static createFromAddress(address, contentResolver) {
      return new NftCollection2(address, void 0, contentResolver, (0, NftItemParams_1.createNftItemParamsValue)());
    }
    async getItem(provider, index) {
      const nftItemAddress = await this.getItemAddress(provider, index);
      return provider.open(new NftItem_1.NftItem(nftItemAddress, void 0, this.contentResolver));
    }
    async getRoyaltyParams(provider) {
      const { stack } = await provider.get("royalty_params", []);
      return {
        numerator: stack.readBigNumber(),
        denominator: stack.readBigNumber(),
        recipient: stack.readAddress()
      };
    }
    async getActions(provider, options) {
      let { lt: lt2, hash, limit } = options ?? {};
      if (!lt2 || !hash) {
        const state = await provider.getState();
        if (!state.last) {
          return [];
        }
        lt2 = state.last.lt;
        hash = state.last.hash;
      }
      const messages = await provider.getTransactions(this.address, lt2, hash, limit);
      return messages.map((tx) => (0, NftCollectionAction_1.parseNftCollectionTransaction)(tx));
    }
  };
  NftCollection.NftCollection = NftCollection$1;
  return NftCollection;
}
var SbtCollection = {};
var SbtItem = {};
var sbtItem = {};
var hasRequiredSbtItem$1;
function requireSbtItem$1() {
  if (hasRequiredSbtItem$1) return sbtItem;
  hasRequiredSbtItem$1 = 1;
  Object.defineProperty(sbtItem, "__esModule", { value: true });
  sbtItem.sbtItemCode = void 0;
  sbtItem.sbtItemCode = {
    codeBoc: "te6ccgECEwEAAzsAART/APSkE/S88sgLAQIBYgIDAgLOBAUCASAPEAS9RsIiDHAJFb4AHQ0wP6QDDwAvhCs44cMfhDAccF8uGV+kAB+GTUAfhm+kAw+GVw+GfwA+AC0x8CcbDjAgHTP4IQ0MO/6lIwuuMCghAE3tFIUjC64wIwghAvyyaiUiC6gGBwgJAgEgDQ4AlDAx0x+CEAUkx64Suo450z8wgBD4RHCCEMGOhtJVA22AQAPIyx8Syz8hbrOTAc8XkTHiyXEFyMsFUATPFlj6AhPLaszJAfsAkTDiAMJsEvpA1NMAMPhH+EHIy/9QBs8W+ETPFhLMFMs/UjDLAAPDAJb4RlADzALegBB4sXCCEA3WB+NANRSAQAPIyx8Syz8hbrOTAc8XkTHiyXEFyMsFUATPFlj6AhPLaszJAfsAAMYy+ERQA8cF8uGR+kDU0wAw+Ef4QcjL//hEzxYTzBLLP1IQywABwwCU+EYBzN6AEHixcIIQBSTHrkBVA4BAA8jLHxLLPyFus5MBzxeRMeLJcQXIywVQBM8WWPoCE8tqzMkB+wAD+o5AMfhByMv/+EPPFoAQcIIQi3cXNUAVUEQDgEADyMsfEss/IW6zkwHPF5Ex4slxBcjLBVAEzxZY+gITy2rMyQH7AOCCEB8EU3pSILrjAoIQb4n141Iguo4WW/hFAccF8uGR+EfAAPLhk/gj+GfwA+CCENE207NSILrjAjAxCgsMAJIx+EQixwXy4ZGAEHCCENUydtsQJFUCbYMGA8jLHxLLPyFus5MBzxeRMeLJcQXIywVQBM8WWPoCE8tqzMkB+wCLAvhkiwL4ZfADAI4x+EQixwXy4ZGCCvrwgHD7AoAQcIIQ1TJ22xAkVQJtgwYDyMsfEss/IW6zkwHPF5Ex4slxBcjLBVAEzxZY+gITy2rMyQH7AAAgghBfzD0UupPywZ3ehA/y8ABhO1E0NM/Afhh+kAB+GNw+GIg10nCAI4Wf/hi+kAB+GTUAfhm+kAB+GXTPzD4Z5Ew4oAA3PhH+Eb4QcjLP/hDzxb4RM8WzPhFzxbLP8ntVIAIBWBESAB28fn+AF8IXwg/CH8InwjQADbVjHgBfCLAADbewfgBfCPA="
  };
  return sbtItem;
}
var SbtItemParams = {};
var hasRequiredSbtItemParams;
function requireSbtItemParams() {
  if (hasRequiredSbtItemParams) return SbtItemParams;
  hasRequiredSbtItemParams = 1;
  Object.defineProperty(SbtItemParams, "__esModule", { value: true });
  SbtItemParams.createSbtItemParamsValue = SbtItemParams.loadSbtItemParams = SbtItemParams.storeSbtItemParams = void 0;
  const core_1 = requireDist$4();
  function storeSbtItemParams(src2) {
    return (builder2) => {
      builder2.storeAddress(src2.owner);
      if (typeof src2.individualContent === "string") {
        builder2.storeRef((0, core_1.beginCell)().storeStringTail(src2.individualContent).endCell());
      } else {
        builder2.storeRef(src2.individualContent);
      }
      builder2.storeAddress(src2.authority);
    };
  }
  SbtItemParams.storeSbtItemParams = storeSbtItemParams;
  function loadSbtItemParams(slice) {
    const owner = slice.loadAddress();
    const content2 = slice.loadRef();
    const authority = slice.loadMaybeAddress();
    return { owner, individualContent: content2, authority };
  }
  SbtItemParams.loadSbtItemParams = loadSbtItemParams;
  function createSbtItemParamsValue() {
    return {
      store: storeSbtItemParams,
      load: loadSbtItemParams
    };
  }
  SbtItemParams.createSbtItemParamsValue = createSbtItemParamsValue;
  return SbtItemParams;
}
var SbtItemAction = {};
var hasRequiredSbtItemAction;
function requireSbtItemAction() {
  if (hasRequiredSbtItemAction) return SbtItemAction;
  hasRequiredSbtItemAction = 1;
  Object.defineProperty(SbtItemAction, "__esModule", { value: true });
  SbtItemAction.parseSbtItemTransaction = void 0;
  const NftMessage_1 = requireNftMessage();
  const TransferAction_1 = requireTransferAction();
  function parseSbtItemTransaction(tx) {
    const mayBeTransfer = (0, TransferAction_1.parseTransferTransaction)(tx);
    if (mayBeTransfer.kind !== "unknown") {
      return mayBeTransfer;
    }
    if (tx.description.type !== "generic") {
      return { kind: "unknown", transaction: tx };
    }
    if (!tx.inMessage) {
      return { kind: "unknown", transaction: tx };
    }
    if (tx.inMessage.info.type !== "internal") {
      return { kind: "unknown", transaction: tx };
    }
    if (tx.description.computePhase.type !== "vm") {
      return { kind: "unknown", transaction: tx };
    }
    if (tx.description.computePhase.exitCode !== 0) {
      return { kind: "unknown", transaction: tx };
    }
    const inMessage = (0, NftMessage_1.loadNftMessage)(tx.inMessage.body.beginParse());
    if (inMessage.kind === "nft_deploy") {
      return {
        kind: "sbt_deploy",
        owner: inMessage.owner,
        content: inMessage.content,
        collection: tx.inMessage.info.src,
        transaction: tx
      };
    }
    return { kind: "unknown", transaction: tx };
  }
  SbtItemAction.parseSbtItemTransaction = parseSbtItemTransaction;
  return SbtItemAction;
}
var hasRequiredSbtItem;
function requireSbtItem() {
  if (hasRequiredSbtItem) return SbtItem;
  hasRequiredSbtItem = 1;
  Object.defineProperty(SbtItem, "__esModule", { value: true });
  SbtItem.SbtItem = SbtItem.sbtItemConfigToCell = void 0;
  const core_1 = requireDist$4();
  const content_1 = requireContent$2();
  const NftCollection_1 = requireNftCollection();
  const content_2 = requireContent();
  const sbt_item_1 = requireSbtItem$1();
  const SbtItemParams_1 = requireSbtItemParams();
  const SbtItemAction_1 = requireSbtItemAction();
  function sbtItemConfigToCell(config) {
    return (0, core_1.beginCell)().storeUint(config.index, 64).storeAddress(config.collection).endCell();
  }
  SbtItem.sbtItemConfigToCell = sbtItemConfigToCell;
  let SbtItem$1 = class SbtItem2 {
    constructor(address, init, contentResolver) {
      this.address = address;
      this.init = init;
      this.contentResolver = contentResolver;
    }
    static createFromConfig(config, code, workchain, contentResolver) {
      const data = sbtItemConfigToCell(config);
      const init = { data, code: code ?? SbtItem2.sbtCode };
      return new SbtItem2((0, core_1.contractAddress)(workchain ?? 0, init), init, contentResolver);
    }
    static createFromAddress(address, contentResolver) {
      return new SbtItem2(address, void 0, contentResolver);
    }
    async sendDeploy(provider, sender, params, value) {
      await provider.internal(sender, {
        value: value ?? (0, core_1.toNano)("0.03"),
        bounce: true,
        body: (0, core_1.beginCell)().store((0, SbtItemParams_1.storeSbtItemParams)(params)).endCell()
      });
    }
    async getData(provider) {
      const { stack } = await provider.get("get_nft_data", []);
      return {
        initialized: stack.readBoolean(),
        index: stack.readBigNumber(),
        collection: stack.readAddressOpt(),
        owner: stack.readAddressOpt(),
        individualContent: stack.readCellOpt()
      };
    }
    async getContent(provider) {
      if (this.contentResolver === void 0) {
        throw new Error("No content resolver");
      }
      const { collection, individualContent, index } = await this.getData(provider);
      if (individualContent === null) {
        throw new Error("Individual content is null");
      }
      let content2;
      if (collection === null) {
        content2 = individualContent;
      } else {
        const collectionContract = provider.open(NftCollection_1.NftCollection.createFromAddress(collection, this.contentResolver));
        content2 = await collectionContract.getItemContent(index, individualContent);
      }
      return (0, content_2.parseNftContent)(await (0, content_1.loadFullContent)(content2, this.contentResolver));
    }
    async getActions(provider, options) {
      let { lt: lt2, hash, limit } = options ?? {};
      if (!lt2 || !hash) {
        const state = await provider.getState();
        if (!state.last) {
          return [];
        }
        lt2 = state.last.lt;
        hash = state.last.hash;
      }
      const transactions = await provider.getTransactions(this.address, lt2, hash, limit);
      return transactions.map((tx) => (0, SbtItemAction_1.parseSbtItemTransaction)(tx));
    }
  };
  SbtItem.SbtItem = SbtItem$1;
  SbtItem$1.sbtCode = core_1.Cell.fromBase64(sbt_item_1.sbtItemCode.codeBoc);
  return SbtItem;
}
var SbtCollectionAction = {};
var hasRequiredSbtCollectionAction;
function requireSbtCollectionAction() {
  if (hasRequiredSbtCollectionAction) return SbtCollectionAction;
  hasRequiredSbtCollectionAction = 1;
  Object.defineProperty(SbtCollectionAction, "__esModule", { value: true });
  SbtCollectionAction.parseSbtCollectionTransaction = void 0;
  const SbtItemParams_1 = requireSbtItemParams();
  const NftCollectionMessage_1 = requireNftCollectionMessage();
  function parseSbtCollectionTransaction(tx) {
    if (tx.description.type !== "generic") {
      return { kind: "unknown", transaction: tx };
    }
    if (!tx.inMessage) {
      return { kind: "unknown", transaction: tx };
    }
    if (tx.inMessage.info.type !== "internal") {
      return { kind: "unknown", transaction: tx };
    }
    if (tx.description.computePhase.type !== "vm") {
      return { kind: "unknown", transaction: tx };
    }
    if (tx.description.computePhase.exitCode !== 0) {
      return { kind: "unknown", transaction: tx };
    }
    const inMessage = (0, NftCollectionMessage_1.loadNftCollectionMessage)(tx.inMessage.body.beginParse(), (0, SbtItemParams_1.createSbtItemParamsValue)());
    if (inMessage.kind === "mint") {
      return {
        kind: "mint",
        index: inMessage.itemIndex,
        owner: inMessage.itemParams.owner,
        content: inMessage.itemParams.individualContent,
        authority: inMessage.itemParams.authority,
        transaction: tx
      };
    }
    if (inMessage.kind === "mint_batch") {
      return {
        kind: "mint_batch",
        items: inMessage.requests.map((item) => ({
          index: item.index,
          owner: item.params.owner,
          content: item.params.individualContent,
          authority: item.params.authority
        })),
        transaction: tx
      };
    }
    if (inMessage.kind === "change_admin") {
      return {
        kind: "change_owner",
        newOwner: inMessage.newAdmin,
        transaction: tx
      };
    }
    if (inMessage.kind === "change_content") {
      return {
        kind: "change_content",
        newContent: inMessage.newContent,
        newRoyalty: inMessage.newRoyaltyParams,
        transaction: tx
      };
    }
    return { kind: "unknown", transaction: tx };
  }
  SbtCollectionAction.parseSbtCollectionTransaction = parseSbtCollectionTransaction;
  return SbtCollectionAction;
}
var hasRequiredSbtCollection;
function requireSbtCollection() {
  if (hasRequiredSbtCollection) return SbtCollection;
  hasRequiredSbtCollection = 1;
  Object.defineProperty(SbtCollection, "__esModule", { value: true });
  SbtCollection.SbtCollection = SbtCollection.sbtCollectionConfigToCell = void 0;
  const core_1 = requireDist$4();
  const NftCollectionBase_1 = requireNftCollectionBase();
  const SbtItem_1 = requireSbtItem();
  const SbtCollectionAction_1 = requireSbtCollectionAction();
  const NftCollectionData_1 = requireNftCollectionData();
  const SbtItemParams_1 = requireSbtItemParams();
  function sbtCollectionConfigToCell(config) {
    return (0, core_1.beginCell)().store((0, NftCollectionData_1.storeNftCollectionData)({
      admin: config.admin,
      content: config.content,
      itemCode: config.itemCode ?? SbtItem_1.SbtItem.sbtCode,
      royalty: {
        numerator: 0n,
        denominator: 1n,
        recipient: config.admin
      }
    })).endCell();
  }
  SbtCollection.sbtCollectionConfigToCell = sbtCollectionConfigToCell;
  let SbtCollection$1 = class SbtCollection2 extends NftCollectionBase_1.NftCollectionBase {
    static createFromConfig(config, code, workchain, contentResolver) {
      const data = sbtCollectionConfigToCell(config);
      const init = { data, code: code ?? SbtCollection2.code };
      return new SbtCollection2((0, core_1.contractAddress)(workchain ?? 0, init), init, contentResolver, (0, SbtItemParams_1.createSbtItemParamsValue)());
    }
    static createFromAddress(address, contentResolver) {
      return new SbtCollection2(address, void 0, contentResolver, (0, SbtItemParams_1.createSbtItemParamsValue)());
    }
    async getItem(provider, index) {
      const nftItemAddress = await this.getItemAddress(provider, index);
      return provider.open(new SbtItem_1.SbtItem(nftItemAddress, void 0, this.contentResolver));
    }
    async getActions(provider, options) {
      let { lt: lt2, hash, limit } = options ?? {};
      if (!lt2 || !hash) {
        const state = await provider.getState();
        if (!state.last) {
          return [];
        }
        lt2 = state.last.lt;
        hash = state.last.hash;
      }
      const messages = await provider.getTransactions(this.address, lt2, hash, limit);
      return messages.map((tx) => (0, SbtCollectionAction_1.parseSbtCollectionTransaction)(tx));
    }
  };
  SbtCollection.SbtCollection = SbtCollection$1;
  return SbtCollection;
}
var NftSale = {};
var hasRequiredNftSale;
function requireNftSale() {
  if (hasRequiredNftSale) return NftSale;
  hasRequiredNftSale = 1;
  Object.defineProperty(NftSale, "__esModule", { value: true });
  NftSale.NftSale = void 0;
  const core_1 = requireDist$4();
  let NftSale$1 = class NftSale2 {
    constructor(address, init) {
      this.address = address;
      this.init = init;
    }
    static createFromConfig(params, code, workchain) {
      const data = (0, core_1.beginCell)().storeBit(false).storeUint(params.createdAt, 32).storeAddress(params.marketplace).storeAddress(params.nft).storeAddress(null).storeCoins(params.fullPrice).storeRef((0, core_1.beginCell)().storeAddress(params.marketplaceFeeTo).storeCoins(params.marketplaceFee).storeAddress(params.royaltyTo).storeCoins(params.royalty)).storeBit(params.canDeployByExternal).endCell();
      const init = { data, code: code ?? NftSale2.code };
      return new NftSale2((0, core_1.contractAddress)(workchain ?? 0, init), init);
    }
    static createFromAddress(address) {
      return new NftSale2(address);
    }
    async sendDeploy(provider, sender, value) {
      await provider.internal(sender, {
        value: value ?? (0, core_1.toNano)("1"),
        bounce: true,
        sendMode: core_1.SendMode.PAY_GAS_SEPARATELY
      });
    }
    async sendDeployExternal(provider) {
      await provider.external(new core_1.Cell());
    }
    async sendTopup(provider, sender, options) {
      await provider.internal(sender, {
        value: options?.value ?? (0, core_1.toNano)("0.05"),
        bounce: true,
        sendMode: core_1.SendMode.PAY_GAS_SEPARATELY,
        body: (0, core_1.beginCell)().storeUint(1, 32).storeUint(options?.queryId ?? 0, 64).endCell()
      });
    }
    async sendAdminMessage(provider, sender, params, value, queryId) {
      const builder2 = (0, core_1.beginCell)().storeUint(555, 32).storeUint(queryId ?? 0, 64);
      if (params.message instanceof core_1.Cell) {
        builder2.storeRef(builder2);
      } else {
        builder2.storeRef((0, core_1.beginCell)().store((0, core_1.storeMessageRelaxed)(params.message)));
      }
      await provider.internal(sender, {
        value: value ?? (0, core_1.toNano)("0.05"),
        bounce: true,
        sendMode: core_1.SendMode.PAY_GAS_SEPARATELY,
        body: builder2.storeUint(params.sendMode, 8).endCell()
      });
    }
    async sendCancel(provider, sender, options) {
      const { isComplete } = await this.getData(provider);
      if (isComplete) {
        throw new Error("Sale is complete");
      }
      await provider.internal(sender, {
        value: options?.value ?? (0, core_1.toNano)("1"),
        bounce: true,
        sendMode: core_1.SendMode.PAY_GAS_SEPARATELY,
        body: (0, core_1.beginCell)().storeUint(3, 32).storeUint(options?.queryId ?? 0, 64).endCell()
      });
    }
    async sendBuy(provider, sender, options) {
      const { isComplete, nftOwner, fullPrice } = await this.getData(provider);
      if (!isComplete) {
        throw new Error("Sale is not complete");
      }
      if (nftOwner === null) {
        throw new Error("NFT owner is not set");
      }
      await provider.internal(sender, {
        value: options?.value ?? fullPrice + (0, core_1.toNano)(1),
        bounce: true,
        sendMode: core_1.SendMode.PAY_GAS_SEPARATELY,
        body: (0, core_1.beginCell)().storeUint(2, 32).storeUint(options?.queryId ?? 0, 64).endCell()
      });
    }
    async getData(provider) {
      const { stack } = await provider.get("get_sale_data", []);
      return {
        type: stack.readNumber(),
        isComplete: stack.readBoolean(),
        createdAt: stack.readNumber(),
        marketplace: stack.readAddress(),
        nft: stack.readAddress(),
        nftOwner: stack.readAddressOpt(),
        fullPrice: stack.readBigNumber(),
        marketplaceFeeTo: stack.readAddress(),
        marketplaceFee: stack.readBigNumber(),
        royaltyTo: stack.readAddressOpt(),
        royalty: stack.readBigNumber()
      };
    }
  };
  NftSale.NftSale = NftSale$1;
  NftSale$1.code = core_1.Cell.fromBase64("te6cckECCwEAArkAART/APSkE/S88sgLAQIBIAMCAH7yMO1E0NMA0x/6QPpA+kD6ANTTADDAAY4d+ABwB8jLABbLH1AEzxZYzxYBzxYB+gLMywDJ7VTgXweCAP/+8vACAUgFBABXoDhZ2omhpgGmP/SB9IH0gfQBqaYAYGGh9IH0AfSB9ABhBCCMkrCgFYACqwECAs0IBgH3ZghA7msoAUmCgUjC+8uHCJND6QPoA+kD6ADBTkqEhoVCHoRagUpBwgBDIywVQA88WAfoCy2rJcfsAJcIAJddJwgKwjhdQRXCAEMjLBVADzxYB+gLLaslx+wAQI5I0NOJacIAQyMsFUAPPFgH6AstqyXH7AHAgghBfzD0UgcAlsjLHxPLPyPPFlADzxbKAIIJycOA+gLKAMlxgBjIywUmzxZw+gLLaszJgwb7AHFVUHAHyMsAFssfUATPFljPFgHPFgH6AszLAMntVAH30A6GmBgLjYSS+CcH0gGHaiaGmAaY/9IH0gfSB9AGppgBgYOCmE44BgAEqYhOmPhW8Q4YBKGATpn8cIxbMbC3MbK2QV44LJOZlvKAVxFWAAyS+G8BJrpOEBFcCBFd0VYACRWdjYKdxjgthOjq+G6hhoaYPqGAD9gHAU4ADAkB6PLRlLOOQjEzOTlTUscFkl8J4FFRxwXy4fSCEAUTjZEWuvLh9QP6QDBGUBA0WXAHyMsAFssfUATPFljPFgHPFgH6AszLAMntVOAwNyjAA+MCKMAAnDY3EDhHZRRDMHDwBeAIwAKYVUQQJBAj8AXgXwqED/LwCgDUODmCEDuaygAYvvLhyVNGxwVRUscFFbHy4cpwIIIQX8w9FCGAEMjLBSjPFiH6Astqyx8Vyz8nzxYnzxYUygAj+gITygDJgwb7AHFQZkUVBHAHyMsAFssfUATPFljPFgHPFgH6AszLAMntVOBqUYM=");
  return NftSale;
}
var noop = {};
var hasRequiredNoop;
function requireNoop() {
  if (hasRequiredNoop) return noop;
  hasRequiredNoop = 1;
  Object.defineProperty(noop, "__esModule", { value: true });
  noop.NoopStorage = void 0;
  class NoopStorage {
    async uploadFile(contents) {
      throw new Error(`No storage provider configured`);
    }
  }
  noop.NoopStorage = NoopStorage;
  return noop;
}
var common = {};
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1;
  var __importDefault = common && common.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(common, "__esModule", { value: true });
  common.retry = common.formatAddressLink = common.formatAddress = common.printAddress = common.printInfo = common.createEnv = common.createContentResolver = common.createStorageEnv = void 0;
  const core_1 = requireDist$4();
  const __1 = requireDist();
  const content_1 = requireContent$2();
  const chalk_1 = __importDefault(require$$4$2);
  const boxen_1 = __importDefault(require$$4$2);
  function createStorageEnv() {
    if (process.env.STORAGE_TYPE === void 0)
      throw new Error("No STORAGE_TYPE in env!");
    if (process.env.STORAGE_TYPE === "pinata") {
      if (process.env.PINATA_API_KEY === void 0)
        throw new Error("No PINATA_API_KEY in env!");
      if (process.env.PINATA_SECRET_KEY === void 0)
        throw new Error("No PINATA_SECRET_KEY in env!");
      return new __1.PinataStorage(process.env.PINATA_API_KEY, process.env.PINATA_SECRET_KEY);
    } else if (process.env.STORAGE_TYPE === "s3") {
      if (process.env.S3_ACCESS_KEY_ID === void 0)
        throw new Error("No S3_ACCESS_KEY_ID in env!");
      if (process.env.S3_SECRET_ACCESS_KEY === void 0)
        throw new Error("No S3_SECRET_ACCESS_KEY in env!");
      if (process.env.S3_BUCKET === void 0)
        throw new Error("No S3_BUCKET in env!");
      return new __1.S3Storage(process.env.S3_ACCESS_KEY_ID, process.env.S3_SECRET_ACCESS_KEY, process.env.S3_BUCKET);
    }
    throw new Error(`Unknown storage type: ${process.env.STORAGE_TYPE}`);
  }
  common.createStorageEnv = createStorageEnv;
  function createContentResolver() {
    if (process.env.IPFS_GATEWAY_TYPE === void 0)
      throw new Error("No IPFS_GATEWAY_TYPE in env!");
    if (process.env.IPFS_GATEWAY_TYPE === "ipfs.io") {
      return new content_1.DefaultContentResolver((id) => `https://ipfs.io/ipfs/${id}`);
    }
    if (process.env.IPFS_GATEWAY_TYPE === "https") {
      if (process.env.IPFS_GATEWAY === void 0)
        throw new Error("No IPFS_GATEWAY in env!");
      const ipfsGateway = new URL(process.env.IPFS_GATEWAY);
      return new content_1.DefaultContentResolver((id) => {
        ipfsGateway.pathname = "/ipfs/" + id;
        return ipfsGateway.toString();
      });
    }
    if (process.env.IPFS_GATEWAY_TYPE === "pinata") {
      if (process.env.IPFS_GATEWAY === void 0)
        throw new Error("No IPFS_GATEWAY in env!");
      if (process.env.IPFS_GATEWAY_API_KEY === void 0)
        throw new Error("No IPFS_GATEWAY_API_KEY in env!");
      const ipfsGateway = new URL(process.env.IPFS_GATEWAY);
      return new content_1.DefaultContentResolver((id) => {
        ipfsGateway.pathname = "/ipfs/" + id;
        ipfsGateway.searchParams.set("pinataGatewayToken", process.env.IPFS_GATEWAY_API_KEY);
        return ipfsGateway.toString();
      });
    }
    throw new Error(`Unknown IPFS gateway type: ${process.env.IPFS_GATEWAY_TYPE}`);
  }
  common.createContentResolver = createContentResolver;
  async function createEnv() {
    if (process.env.WALLET_TYPE === void 0)
      throw new Error("No WALLET_TYPE in env!");
    if (process.env.WALLET_TYPE !== "highload-v2")
      throw new Error(`Unknown wallet type: ${process.env.WALLET_TYPE}`);
    if (process.env.MNEMONIC === void 0)
      throw new Error("No MNEMONIC in env!");
    if (process.env.NETWORK === void 0)
      throw new Error("No NETWORK in env!");
    if (process.env.NETWORK !== "mainnet" && process.env.NETWORK !== "testnet")
      throw new Error(`Unknown network: ${process.env.NETWORK}`);
    const contentResolver = createContentResolver();
    const storage = createStorageEnv();
    const client = await (0, __1.createApi)(process.env.NETWORK);
    const keyPair = await (0, __1.importKey)(process.env.MNEMONIC);
    const { publicKey, secretKey } = keyPair;
    const walletContract = await (0, __1.createWallet)(process.env.WALLET_TYPE, publicKey);
    const sender = client.open(walletContract).sender(keyPair.secretKey);
    const sdk2 = __1.AssetsSDK.create({
      storage,
      api: client,
      sender,
      contentResolver
    });
    return {
      sdk: sdk2,
      network: process.env.NETWORK,
      storage,
      sender,
      client
    };
  }
  common.createEnv = createEnv;
  function printInfo(info, network) {
    const keys = Object.keys(info);
    const rows = [];
    for (const key2 of keys) {
      let value = info[key2];
      if (typeof value === "string") {
        value = chalk_1.default.green(value);
      } else if (typeof value === "bigint") {
        value = chalk_1.default.yellow(value.toString());
      } else if (typeof value === "number") {
        value = chalk_1.default.cyan(value);
      } else if (typeof value === "boolean") {
        value = chalk_1.default.blue(value);
      } else if (value === null) {
        value = chalk_1.default.red("null");
      } else if (value === void 0) {
        value = chalk_1.default.red("undefined");
      } else if (core_1.Address.isAddress(value)) {
        value = `${chalk_1.default.magenta(formatAddress(value, network))} ${chalk_1.default.blue(formatAddressLink(value, network))}`;
      } else if (value instanceof core_1.Cell) {
        value = chalk_1.default.blue(value.toString("base64"));
      } else {
        throw new Error(`Unknown type: ${typeof value}`);
      }
      rows.push([key2, value]);
    }
    console.log((0, boxen_1.default)(rows.filter(([key2]) => key2 !== "name").map(([key2, value]) => `${chalk_1.default.bold(key2)}: ${value}`).join("\n"), {
      padding: {
        top: 0,
        bottom: 0,
        left: 1,
        right: 1
      },
      borderStyle: "round",
      borderColor: "green",
      title: rows.find(([key2, value]) => key2 === "name")?.[1]
    }));
  }
  common.printInfo = printInfo;
  function printAddress(address, network, name = "wallet") {
    const formattedAddress = formatAddress(address, network);
    const formattedAddressLink = formatAddressLink(address, network);
    console.log(`Your ${name} has the address ${formattedAddress}
You can view it at ${formattedAddressLink}`);
  }
  common.printAddress = printAddress;
  function formatAddress(address, network) {
    if (!address) {
      return "null";
    }
    return address.toString({ testOnly: network === "testnet", bounceable: true });
  }
  common.formatAddress = formatAddress;
  function formatAddressLink(address, network) {
    if (!address) {
      return "null";
    }
    return `https://${network === "testnet" ? "testnet." : ""}tonviewer.com/${formatAddress(address, network)}`;
  }
  common.formatAddressLink = formatAddressLink;
  async function retry(fn2, options) {
    let { retries, delay: delay2, name } = { retries: 3, delay: 1e3, ...options };
    for (let i = 0; i < retries; i++) {
      try {
        return await fn2();
      } catch (e) {
        console.log(`Attempt ${i + 1} failed: ${name ? name + ": " : ""}${e}`);
      }
      await new Promise((resolve) => setTimeout(resolve, delay2 * 2 ** i));
    }
    throw new Error("Exceeded number of retries");
  }
  common.retry = retry;
  return common;
}
var hasRequiredSdk;
function requireSdk() {
  if (hasRequiredSdk) return sdk;
  hasRequiredSdk = 1;
  Object.defineProperty(sdk, "__esModule", { value: true });
  sdk.AssetsSDK = void 0;
  const core_1 = requireDist$4();
  const pinata_1 = requirePinata();
  const s3_1 = requireS3();
  const content_1 = requireContent$1();
  const content_2 = requireContent();
  const utils_1 = requireUtils$1();
  const JettonWallet_1 = requireJettonWallet$1();
  const JettonMinter_1 = requireJettonMinter();
  const NftCollection_1 = requireNftCollection();
  const NftItem_1 = requireNftItem();
  const SbtCollection_1 = requireSbtCollection();
  const content_3 = requireContent$2();
  const NftSale_1 = requireNftSale();
  const noop_1 = requireNoop();
  const common_1 = requireCommon();
  const WORKCHAIN = 0;
  class AssetsSDK {
    constructor(storage, api, sender, contentResolver) {
      this.storage = storage;
      this.api = api;
      this.sender = sender;
      this.contentResolver = contentResolver;
    }
    static create(params) {
      let { api, storage, sender, contentResolver } = params;
      if (!storage) {
        storage = new noop_1.NoopStorage();
      } else if ("pinataApiKey" in storage) {
        storage = pinata_1.PinataStorage.create(storage);
      } else if ("s3AccessKeyId" in storage) {
        storage = s3_1.S3Storage.create(storage);
      }
      contentResolver ?? (contentResolver = new content_3.DefaultContentResolver());
      return new AssetsSDK(storage, api, sender, contentResolver);
    }
    async deployJetton(content2, options) {
      if (!this.sender) {
        throw new Error("Sender must be defined");
      }
      const adminAddress = options?.adminAddress ?? this.sender?.address;
      if (adminAddress === void 0) {
        throw new Error("Admin address must be defined in options or be available in Sender");
      }
      const jettonMinterContract = JettonMinter_1.JettonMinter.createFromConfig({
        admin: adminAddress,
        content: await this.contentToCell((0, content_1.jettonContentToInternal)(content2), options?.onchainContent ?? false)
      }, JettonMinter_1.JettonMinter.code, WORKCHAIN, this.contentResolver);
      const jetton = this.api.open(jettonMinterContract);
      const premintAmount = options?.premintAmount;
      if (typeof premintAmount === "bigint" && premintAmount > 0n) {
        await jetton.sendMint(this.sender, adminAddress, premintAmount, {
          ...options?.premintOptions,
          value: options?.value,
          queryId: options?.queryId
        });
      } else {
        await jetton.sendDeploy(this.sender, options?.value);
      }
      return jetton;
    }
    openJetton(address) {
      return this.api.open(JettonMinter_1.JettonMinter.createFromAddress(address, this.contentResolver));
    }
    async deployNftCollection(content2, options) {
      if (!this.sender) {
        throw new Error("Sender must be defined");
      }
      const adminAddress = options?.adminAddress ?? this.sender?.address;
      if (adminAddress === void 0) {
        throw new Error("Admin address must be defined in options or be available in Sender");
      }
      const collection = this.api.open(NftCollection_1.NftCollection.createFromConfig({
        admin: adminAddress,
        content: (0, core_1.beginCell)().storeRef(await this.contentToCell((0, content_2.nftContentToInternal)(content2.collectionContent), options?.onchainContent ?? false)).storeRef((0, core_1.beginCell)().storeStringTail(content2.commonContent)).endCell(),
        royalty: options?.royaltyParams
      }, NftCollection_1.NftCollection.code, WORKCHAIN, this.contentResolver));
      if (typeof options?.premintItems?.length === "number" && options?.premintItems.length > 0) {
        await collection.sendBatchMint(this.sender, options?.premintItems, {
          value: options?.value,
          queryId: options?.queryId
        });
      } else {
        await collection.sendDeploy(this.sender, options?.value);
      }
      return collection;
    }
    openNftCollection(address) {
      return this.api.open(NftCollection_1.NftCollection.createFromAddress(address, this.contentResolver));
    }
    async deploySbtCollection(content2, options) {
      if (!this.sender) {
        throw new Error("Sender must be defined");
      }
      const adminAddress = options?.adminAddress ?? this.sender?.address;
      if (adminAddress === void 0) {
        throw new Error("Admin address must be defined in options or be available in Sender");
      }
      const collection = this.api.open(SbtCollection_1.SbtCollection.createFromConfig({
        admin: adminAddress,
        content: (0, core_1.beginCell)().storeRef(await this.contentToCell((0, content_2.nftContentToInternal)(content2.collectionContent), content2?.onchainContent ?? false)).storeRef((0, core_1.beginCell)().storeStringTail(content2.commonContent)).endCell()
      }, SbtCollection_1.SbtCollection.code, WORKCHAIN, this.contentResolver));
      if (typeof options?.premintItems?.length === "number" && options?.premintItems.length > 0) {
        await collection.sendBatchMint(this.sender, options?.premintItems, {
          value: options?.value,
          queryId: options?.queryId
        });
      } else {
        await collection.sendDeploy(this.sender, options?.value);
      }
      return collection;
    }
    openSbtCollection(address) {
      return this.api.open(SbtCollection_1.SbtCollection.createFromAddress(address, this.contentResolver));
    }
    openJettonWallet(address) {
      return this.api.open(new JettonWallet_1.JettonWallet(address));
    }
    openNftItem(address) {
      return this.api.open(new NftItem_1.NftItem(address, void 0, this.contentResolver));
    }
    async deployNftSale(params) {
      if (!this.sender) {
        throw new Error("Sender must be defined");
      }
      const marketplaceAddress = params.marketplace ?? this.sender?.address;
      if (marketplaceAddress === void 0) {
        throw new Error("Marketplace address must be defined in options or be available in Sender");
      }
      const sale = this.api.open(NftSale_1.NftSale.createFromConfig({
        createdAt: params.createdAt ?? Math.floor(Date.now() / 1e3),
        marketplace: params.marketplace ?? null,
        nft: params.nft,
        fullPrice: params.fullPrice,
        marketplaceFeeTo: params.marketplaceFeeTo ?? null,
        marketplaceFee: params.marketplaceFee ?? 0n,
        royaltyTo: params.royaltyTo ?? null,
        royalty: params.royalty ?? 0n,
        canDeployByExternal: params.canDeployByExternal ?? true
      }));
      await sale.sendTopup(this.sender, { value: params.value, queryId: params.queryId });
      return sale;
    }
    openNftSale(address) {
      return this.api.open(NftSale_1.NftSale.createFromAddress(address));
    }
    async internalOffchainContentToCell(internal) {
      const contents = Buffer.from(JSON.stringify(internal), "utf-8");
      const contentUrl = await (0, common_1.retry)(() => this.storage.uploadFile(contents), { name: "upload content" });
      return (0, core_1.beginCell)().storeUint(1, 8).storeStringTail(contentUrl).endCell();
    }
    async contentToCell(internal, onchain) {
      return onchain ? (0, utils_1.internalOnchainContentToCell)(internal) : await this.internalOffchainContentToCell(internal);
    }
  }
  sdk.AssetsSDK = AssetsSDK;
  return sdk;
}
var tonClientApi = {};
var dist = {};
var HttpApi = {};
var TonCache = {};
var hasRequiredTonCache;
function requireTonCache() {
  if (hasRequiredTonCache) return TonCache;
  hasRequiredTonCache = 1;
  Object.defineProperty(TonCache, "__esModule", { value: true });
  TonCache.InMemoryCache = void 0;
  class InMemoryCache {
    constructor() {
      this.cache = /* @__PURE__ */ new Map();
      this.set = async (namespace, key2, value) => {
        if (value !== null) {
          this.cache.set(namespace + "$$" + key2, value);
        } else {
          this.cache.delete(namespace + "$$" + key2);
        }
      };
      this.get = async (namespace, key2) => {
        let res = this.cache.get(namespace + "$$" + key2);
        if (res !== void 0) {
          return res;
        } else {
          return null;
        }
      };
    }
  }
  TonCache.InMemoryCache = InMemoryCache;
  return TonCache;
}
var dataloader;
var hasRequiredDataloader;
function requireDataloader() {
  if (hasRequiredDataloader) return dataloader;
  hasRequiredDataloader = 1;
  var DataLoader = /* @__PURE__ */ (function() {
    function DataLoader2(batchLoadFn, options) {
      if (typeof batchLoadFn !== "function") {
        throw new TypeError("DataLoader must be constructed with a function which accepts " + ("Array<key> and returns Promise<Array<value>>, but got: " + batchLoadFn + "."));
      }
      this._batchLoadFn = batchLoadFn;
      this._maxBatchSize = getValidMaxBatchSize(options);
      this._batchScheduleFn = getValidBatchScheduleFn(options);
      this._cacheKeyFn = getValidCacheKeyFn(options);
      this._cacheMap = getValidCacheMap(options);
      this._batch = null;
      this.name = getValidName(options);
    }
    var _proto = DataLoader2.prototype;
    _proto.load = function load(key2) {
      if (key2 === null || key2 === void 0) {
        throw new TypeError("The loader.load() function must be called with a value, " + ("but got: " + String(key2) + "."));
      }
      var batch = getCurrentBatch(this);
      var cacheMap = this._cacheMap;
      var cacheKey;
      if (cacheMap) {
        cacheKey = this._cacheKeyFn(key2);
        var cachedPromise = cacheMap.get(cacheKey);
        if (cachedPromise) {
          var cacheHits = batch.cacheHits || (batch.cacheHits = []);
          return new Promise(function(resolve) {
            cacheHits.push(function() {
              resolve(cachedPromise);
            });
          });
        }
      }
      batch.keys.push(key2);
      var promise = new Promise(function(resolve, reject) {
        batch.callbacks.push({
          resolve,
          reject
        });
      });
      if (cacheMap) {
        cacheMap.set(cacheKey, promise);
      }
      return promise;
    };
    _proto.loadMany = function loadMany(keys) {
      if (!isArrayLike(keys)) {
        throw new TypeError("The loader.loadMany() function must be called with Array<key> " + ("but got: " + keys + "."));
      }
      var loadPromises = [];
      for (var i = 0; i < keys.length; i++) {
        loadPromises.push(this.load(keys[i])["catch"](function(error2) {
          return error2;
        }));
      }
      return Promise.all(loadPromises);
    };
    _proto.clear = function clear(key2) {
      var cacheMap = this._cacheMap;
      if (cacheMap) {
        var cacheKey = this._cacheKeyFn(key2);
        cacheMap["delete"](cacheKey);
      }
      return this;
    };
    _proto.clearAll = function clearAll() {
      var cacheMap = this._cacheMap;
      if (cacheMap) {
        cacheMap.clear();
      }
      return this;
    };
    _proto.prime = function prime(key2, value) {
      var cacheMap = this._cacheMap;
      if (cacheMap) {
        var cacheKey = this._cacheKeyFn(key2);
        if (cacheMap.get(cacheKey) === void 0) {
          var promise;
          if (value instanceof Error) {
            promise = Promise.reject(value);
            promise["catch"](function() {
            });
          } else {
            promise = Promise.resolve(value);
          }
          cacheMap.set(cacheKey, promise);
        }
      }
      return this;
    };
    return DataLoader2;
  })();
  var enqueuePostPromiseJob = typeof process === "object" && typeof process.nextTick === "function" ? function(fn2) {
    if (!resolvedPromise) {
      resolvedPromise = Promise.resolve();
    }
    resolvedPromise.then(function() {
      process.nextTick(fn2);
    });
  } : typeof setImmediate === "function" ? function(fn2) {
    setImmediate(fn2);
  } : function(fn2) {
    setTimeout(fn2);
  };
  var resolvedPromise;
  function getCurrentBatch(loader) {
    var existingBatch = loader._batch;
    if (existingBatch !== null && !existingBatch.hasDispatched && existingBatch.keys.length < loader._maxBatchSize) {
      return existingBatch;
    }
    var newBatch = {
      hasDispatched: false,
      keys: [],
      callbacks: []
    };
    loader._batch = newBatch;
    loader._batchScheduleFn(function() {
      dispatchBatch(loader, newBatch);
    });
    return newBatch;
  }
  function dispatchBatch(loader, batch) {
    batch.hasDispatched = true;
    if (batch.keys.length === 0) {
      resolveCacheHits(batch);
      return;
    }
    var batchPromise;
    try {
      batchPromise = loader._batchLoadFn(batch.keys);
    } catch (e) {
      return failedDispatch(loader, batch, new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function " + ("errored synchronously: " + String(e) + ".")));
    }
    if (!batchPromise || typeof batchPromise.then !== "function") {
      return failedDispatch(loader, batch, new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did " + ("not return a Promise: " + String(batchPromise) + ".")));
    }
    batchPromise.then(function(values) {
      if (!isArrayLike(values)) {
        throw new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did " + ("not return a Promise of an Array: " + String(values) + "."));
      }
      if (values.length !== batch.keys.length) {
        throw new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise of an Array of the same length as the Array of keys." + ("\n\nKeys:\n" + String(batch.keys)) + ("\n\nValues:\n" + String(values)));
      }
      resolveCacheHits(batch);
      for (var i = 0; i < batch.callbacks.length; i++) {
        var _value = values[i];
        if (_value instanceof Error) {
          batch.callbacks[i].reject(_value);
        } else {
          batch.callbacks[i].resolve(_value);
        }
      }
    })["catch"](function(error2) {
      failedDispatch(loader, batch, error2);
    });
  }
  function failedDispatch(loader, batch, error2) {
    resolveCacheHits(batch);
    for (var i = 0; i < batch.keys.length; i++) {
      loader.clear(batch.keys[i]);
      batch.callbacks[i].reject(error2);
    }
  }
  function resolveCacheHits(batch) {
    if (batch.cacheHits) {
      for (var i = 0; i < batch.cacheHits.length; i++) {
        batch.cacheHits[i]();
      }
    }
  }
  function getValidMaxBatchSize(options) {
    var shouldBatch = !options || options.batch !== false;
    if (!shouldBatch) {
      return 1;
    }
    var maxBatchSize = options && options.maxBatchSize;
    if (maxBatchSize === void 0) {
      return Infinity;
    }
    if (typeof maxBatchSize !== "number" || maxBatchSize < 1) {
      throw new TypeError("maxBatchSize must be a positive number: " + maxBatchSize);
    }
    return maxBatchSize;
  }
  function getValidBatchScheduleFn(options) {
    var batchScheduleFn = options && options.batchScheduleFn;
    if (batchScheduleFn === void 0) {
      return enqueuePostPromiseJob;
    }
    if (typeof batchScheduleFn !== "function") {
      throw new TypeError("batchScheduleFn must be a function: " + batchScheduleFn);
    }
    return batchScheduleFn;
  }
  function getValidCacheKeyFn(options) {
    var cacheKeyFn = options && options.cacheKeyFn;
    if (cacheKeyFn === void 0) {
      return function(key2) {
        return key2;
      };
    }
    if (typeof cacheKeyFn !== "function") {
      throw new TypeError("cacheKeyFn must be a function: " + cacheKeyFn);
    }
    return cacheKeyFn;
  }
  function getValidCacheMap(options) {
    var shouldCache = !options || options.cache !== false;
    if (!shouldCache) {
      return null;
    }
    var cacheMap = options && options.cacheMap;
    if (cacheMap === void 0) {
      return /* @__PURE__ */ new Map();
    }
    if (cacheMap !== null) {
      var cacheFunctions = ["get", "set", "delete", "clear"];
      var missingFunctions = cacheFunctions.filter(function(fnName) {
        return cacheMap && typeof cacheMap[fnName] !== "function";
      });
      if (missingFunctions.length !== 0) {
        throw new TypeError("Custom cacheMap missing methods: " + missingFunctions.join(", "));
      }
    }
    return cacheMap;
  }
  function getValidName(options) {
    if (options && options.name) {
      return options.name;
    }
    return null;
  }
  function isArrayLike(x2) {
    return typeof x2 === "object" && x2 !== null && typeof x2.length === "number" && (x2.length === 0 || x2.length > 0 && Object.prototype.hasOwnProperty.call(x2, x2.length - 1));
  }
  dataloader = DataLoader;
  return dataloader;
}
/*! Axios v1.11.0 Copyright (c) 2025 Matt Zabriskie and contributors */
var axios_1;
var hasRequiredAxios;
function requireAxios() {
  if (hasRequiredAxios) return axios_1;
  hasRequiredAxios = 1;
  function bind(fn2, thisArg) {
    return function wrap() {
      return fn2.apply(thisArg, arguments);
    };
  }
  const { toString } = Object.prototype;
  const { getPrototypeOf } = Object;
  const { iterator, toStringTag } = Symbol;
  const kindOf = /* @__PURE__ */ ((cache) => (thing) => {
    const str = toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
  })(/* @__PURE__ */ Object.create(null));
  const kindOfTest = (type) => {
    type = type.toLowerCase();
    return (thing) => kindOf(thing) === type;
  };
  const typeOfTest = (type) => (thing) => typeof thing === type;
  const { isArray } = Array;
  const isUndefined = typeOfTest("undefined");
  function isBuffer2(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
  }
  const isArrayBuffer = kindOfTest("ArrayBuffer");
  function isArrayBufferView(val) {
    let result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
      result = ArrayBuffer.isView(val);
    } else {
      result = val && val.buffer && isArrayBuffer(val.buffer);
    }
    return result;
  }
  const isString = typeOfTest("string");
  const isFunction = typeOfTest("function");
  const isNumber = typeOfTest("number");
  const isObject = (thing) => thing !== null && typeof thing === "object";
  const isBoolean = (thing) => thing === true || thing === false;
  const isPlainObject = (val) => {
    if (kindOf(val) !== "object") {
      return false;
    }
    const prototype2 = getPrototypeOf(val);
    return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(toStringTag in val) && !(iterator in val);
  };
  const isEmptyObject = (val) => {
    if (!isObject(val) || isBuffer2(val)) {
      return false;
    }
    try {
      return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
    } catch (e) {
      return false;
    }
  };
  const isDate = kindOfTest("Date");
  const isFile = kindOfTest("File");
  const isBlob = kindOfTest("Blob");
  const isFileList = kindOfTest("FileList");
  const isStream = (val) => isObject(val) && isFunction(val.pipe);
  const isFormData = (thing) => {
    let kind;
    return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
    kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
  };
  const isURLSearchParams = kindOfTest("URLSearchParams");
  const [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
  const trim2 = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  function forEach(obj, fn2, { allOwnKeys = false } = {}) {
    if (obj === null || typeof obj === "undefined") {
      return;
    }
    let i;
    let l;
    if (typeof obj !== "object") {
      obj = [obj];
    }
    if (isArray(obj)) {
      for (i = 0, l = obj.length; i < l; i++) {
        fn2.call(null, obj[i], i, obj);
      }
    } else {
      if (isBuffer2(obj)) {
        return;
      }
      const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
      const len = keys.length;
      let key2;
      for (i = 0; i < len; i++) {
        key2 = keys[i];
        fn2.call(null, obj[key2], key2, obj);
      }
    }
  }
  function findKey(obj, key2) {
    if (isBuffer2(obj)) {
      return null;
    }
    key2 = key2.toLowerCase();
    const keys = Object.keys(obj);
    let i = keys.length;
    let _key;
    while (i-- > 0) {
      _key = keys[i];
      if (key2 === _key.toLowerCase()) {
        return _key;
      }
    }
    return null;
  }
  const _global = (() => {
    if (typeof globalThis !== "undefined") return globalThis;
    return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : commonjsGlobal;
  })();
  const isContextDefined = (context) => !isUndefined(context) && context !== _global;
  function merge() {
    const { caseless } = isContextDefined(this) && this || {};
    const result = {};
    const assignValue = (val, key2) => {
      const targetKey = caseless && findKey(result, key2) || key2;
      if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
        result[targetKey] = merge(result[targetKey], val);
      } else if (isPlainObject(val)) {
        result[targetKey] = merge({}, val);
      } else if (isArray(val)) {
        result[targetKey] = val.slice();
      } else {
        result[targetKey] = val;
      }
    };
    for (let i = 0, l = arguments.length; i < l; i++) {
      arguments[i] && forEach(arguments[i], assignValue);
    }
    return result;
  }
  const extend = (a2, b2, thisArg, { allOwnKeys } = {}) => {
    forEach(b2, (val, key2) => {
      if (thisArg && isFunction(val)) {
        a2[key2] = bind(val, thisArg);
      } else {
        a2[key2] = val;
      }
    }, { allOwnKeys });
    return a2;
  };
  const stripBOM = (content2) => {
    if (content2.charCodeAt(0) === 65279) {
      content2 = content2.slice(1);
    }
    return content2;
  };
  const inherits = (constructor, superConstructor, props, descriptors2) => {
    constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
    constructor.prototype.constructor = constructor;
    Object.defineProperty(constructor, "super", {
      value: superConstructor.prototype
    });
    props && Object.assign(constructor.prototype, props);
  };
  const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
    let props;
    let i;
    let prop;
    const merged = {};
    destObj = destObj || {};
    if (sourceObj == null) return destObj;
    do {
      props = Object.getOwnPropertyNames(sourceObj);
      i = props.length;
      while (i-- > 0) {
        prop = props[i];
        if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
          destObj[prop] = sourceObj[prop];
          merged[prop] = true;
        }
      }
      sourceObj = filter !== false && getPrototypeOf(sourceObj);
    } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
    return destObj;
  };
  const endsWith = (str, searchString, position) => {
    str = String(str);
    if (position === void 0 || position > str.length) {
      position = str.length;
    }
    position -= searchString.length;
    const lastIndex = str.indexOf(searchString, position);
    return lastIndex !== -1 && lastIndex === position;
  };
  const toArray = (thing) => {
    if (!thing) return null;
    if (isArray(thing)) return thing;
    let i = thing.length;
    if (!isNumber(i)) return null;
    const arr = new Array(i);
    while (i-- > 0) {
      arr[i] = thing[i];
    }
    return arr;
  };
  const isTypedArray = /* @__PURE__ */ ((TypedArray) => {
    return (thing) => {
      return TypedArray && thing instanceof TypedArray;
    };
  })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
  const forEachEntry = (obj, fn2) => {
    const generator2 = obj && obj[iterator];
    const _iterator = generator2.call(obj);
    let result;
    while ((result = _iterator.next()) && !result.done) {
      const pair = result.value;
      fn2.call(obj, pair[0], pair[1]);
    }
  };
  const matchAll = (regExp, str) => {
    let matches;
    const arr = [];
    while ((matches = regExp.exec(str)) !== null) {
      arr.push(matches);
    }
    return arr;
  };
  const isHTMLForm = kindOfTest("HTMLFormElement");
  const toCamelCase = (str) => {
    return str.toLowerCase().replace(
      /[-_\s]([a-z\d])(\w*)/g,
      function replacer(m2, p1, p2) {
        return p1.toUpperCase() + p2;
      }
    );
  };
  const hasOwnProperty2 = (({ hasOwnProperty: hasOwnProperty3 }) => (obj, prop) => hasOwnProperty3.call(obj, prop))(Object.prototype);
  const isRegExp = kindOfTest("RegExp");
  const reduceDescriptors = (obj, reducer) => {
    const descriptors2 = Object.getOwnPropertyDescriptors(obj);
    const reducedDescriptors = {};
    forEach(descriptors2, (descriptor2, name) => {
      let ret;
      if ((ret = reducer(descriptor2, name, obj)) !== false) {
        reducedDescriptors[name] = ret || descriptor2;
      }
    });
    Object.defineProperties(obj, reducedDescriptors);
  };
  const freezeMethods = (obj) => {
    reduceDescriptors(obj, (descriptor2, name) => {
      if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
        return false;
      }
      const value = obj[name];
      if (!isFunction(value)) return;
      descriptor2.enumerable = false;
      if ("writable" in descriptor2) {
        descriptor2.writable = false;
        return;
      }
      if (!descriptor2.set) {
        descriptor2.set = () => {
          throw Error("Can not rewrite read-only method '" + name + "'");
        };
      }
    });
  };
  const toObjectSet = (arrayOrString, delimiter2) => {
    const obj = {};
    const define = (arr) => {
      arr.forEach((value) => {
        obj[value] = true;
      });
    };
    isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter2));
    return obj;
  };
  const noop2 = () => {
  };
  const toFiniteNumber = (value, defaultValue) => {
    return value != null && Number.isFinite(value = +value) ? value : defaultValue;
  };
  function isSpecCompliantForm(thing) {
    return !!(thing && isFunction(thing.append) && thing[toStringTag] === "FormData" && thing[iterator]);
  }
  const toJSONObject = (obj) => {
    const stack = new Array(10);
    const visit2 = (source, i) => {
      if (isObject(source)) {
        if (stack.indexOf(source) >= 0) {
          return;
        }
        if (isBuffer2(source)) {
          return source;
        }
        if (!("toJSON" in source)) {
          stack[i] = source;
          const target = isArray(source) ? [] : {};
          forEach(source, (value, key2) => {
            const reducedValue = visit2(value, i + 1);
            !isUndefined(reducedValue) && (target[key2] = reducedValue);
          });
          stack[i] = void 0;
          return target;
        }
      }
      return source;
    };
    return visit2(obj, 0);
  };
  const isAsyncFn = kindOfTest("AsyncFunction");
  const isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
  const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
    if (setImmediateSupported) {
      return setImmediate;
    }
    return postMessageSupported ? ((token, callbacks) => {
      _global.addEventListener("message", ({ source, data }) => {
        if (source === _global && data === token) {
          callbacks.length && callbacks.shift()();
        }
      }, false);
      return (cb) => {
        callbacks.push(cb);
        _global.postMessage(token, "*");
      };
    })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
  })(
    typeof setImmediate === "function",
    isFunction(_global.postMessage)
  );
  const asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
  const isIterable = (thing) => thing != null && isFunction(thing[iterator]);
  var utils$12 = {
    isArray,
    isArrayBuffer,
    isBuffer: isBuffer2,
    isFormData,
    isArrayBufferView,
    isString,
    isNumber,
    isBoolean,
    isObject,
    isPlainObject,
    isEmptyObject,
    isReadableStream,
    isRequest,
    isResponse,
    isHeaders,
    isUndefined,
    isDate,
    isFile,
    isBlob,
    isRegExp,
    isFunction,
    isStream,
    isURLSearchParams,
    isTypedArray,
    isFileList,
    forEach,
    merge,
    extend,
    trim: trim2,
    stripBOM,
    inherits,
    toFlatObject,
    kindOf,
    kindOfTest,
    endsWith,
    toArray,
    forEachEntry,
    matchAll,
    isHTMLForm,
    hasOwnProperty: hasOwnProperty2,
    hasOwnProp: hasOwnProperty2,
    // an alias to avoid ESLint no-prototype-builtins detection
    reduceDescriptors,
    freezeMethods,
    toObjectSet,
    toCamelCase,
    noop: noop2,
    toFiniteNumber,
    findKey,
    global: _global,
    isContextDefined,
    isSpecCompliantForm,
    toJSONObject,
    isAsyncFn,
    isThenable,
    setImmediate: _setImmediate,
    asap,
    isIterable
  };
  function AxiosError(message, code, config, request, response) {
    Error.call(this);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error().stack;
    }
    this.message = message;
    this.name = "AxiosError";
    code && (this.code = code);
    config && (this.config = config);
    request && (this.request = request);
    if (response) {
      this.response = response;
      this.status = response.status ? response.status : null;
    }
  }
  utils$12.inherits(AxiosError, Error, {
    toJSON: function toJSON() {
      return {
        // Standard
        message: this.message,
        name: this.name,
        // Microsoft
        description: this.description,
        number: this.number,
        // Mozilla
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        // Axios
        config: utils$12.toJSONObject(this.config),
        code: this.code,
        status: this.status
      };
    }
  });
  const prototype$1 = AxiosError.prototype;
  const descriptors = {};
  [
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED",
    "ERR_NOT_SUPPORT",
    "ERR_INVALID_URL"
    // eslint-disable-next-line func-names
  ].forEach((code) => {
    descriptors[code] = { value: code };
  });
  Object.defineProperties(AxiosError, descriptors);
  Object.defineProperty(prototype$1, "isAxiosError", { value: true });
  AxiosError.from = (error2, code, config, request, response, customProps) => {
    const axiosError = Object.create(prototype$1);
    utils$12.toFlatObject(error2, axiosError, function filter(obj) {
      return obj !== Error.prototype;
    }, (prop) => {
      return prop !== "isAxiosError";
    });
    AxiosError.call(axiosError, error2.message, code, config, request, response);
    axiosError.cause = error2;
    axiosError.name = error2.name;
    customProps && Object.assign(axiosError, customProps);
    return axiosError;
  };
  var httpAdapter = null;
  function isVisitable(thing) {
    return utils$12.isPlainObject(thing) || utils$12.isArray(thing);
  }
  function removeBrackets(key2) {
    return utils$12.endsWith(key2, "[]") ? key2.slice(0, -2) : key2;
  }
  function renderKey(path, key2, dots) {
    if (!path) return key2;
    return path.concat(key2).map(function each(token, i) {
      token = removeBrackets(token);
      return !dots && i ? "[" + token + "]" : token;
    }).join(dots ? "." : "");
  }
  function isFlatArray(arr) {
    return utils$12.isArray(arr) && !arr.some(isVisitable);
  }
  const predicates = utils$12.toFlatObject(utils$12, {}, null, function filter(prop) {
    return /^is[A-Z]/.test(prop);
  });
  function toFormData(obj, formData, options) {
    if (!utils$12.isObject(obj)) {
      throw new TypeError("target must be an object");
    }
    formData = formData || new FormData();
    options = utils$12.toFlatObject(options, {
      metaTokens: true,
      dots: false,
      indexes: false
    }, false, function defined(option, source) {
      return !utils$12.isUndefined(source[option]);
    });
    const metaTokens = options.metaTokens;
    const visitor = options.visitor || defaultVisitor;
    const dots = options.dots;
    const indexes = options.indexes;
    const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
    const useBlob = _Blob && utils$12.isSpecCompliantForm(formData);
    if (!utils$12.isFunction(visitor)) {
      throw new TypeError("visitor must be a function");
    }
    function convertValue(value) {
      if (value === null) return "";
      if (utils$12.isDate(value)) {
        return value.toISOString();
      }
      if (utils$12.isBoolean(value)) {
        return value.toString();
      }
      if (!useBlob && utils$12.isBlob(value)) {
        throw new AxiosError("Blob is not supported. Use a Buffer instead.");
      }
      if (utils$12.isArrayBuffer(value) || utils$12.isTypedArray(value)) {
        return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
      }
      return value;
    }
    function defaultVisitor(value, key2, path) {
      let arr = value;
      if (value && !path && typeof value === "object") {
        if (utils$12.endsWith(key2, "{}")) {
          key2 = metaTokens ? key2 : key2.slice(0, -2);
          value = JSON.stringify(value);
        } else if (utils$12.isArray(value) && isFlatArray(value) || (utils$12.isFileList(value) || utils$12.endsWith(key2, "[]")) && (arr = utils$12.toArray(value))) {
          key2 = removeBrackets(key2);
          arr.forEach(function each(el, index) {
            !(utils$12.isUndefined(el) || el === null) && formData.append(
              // eslint-disable-next-line no-nested-ternary
              indexes === true ? renderKey([key2], index, dots) : indexes === null ? key2 : key2 + "[]",
              convertValue(el)
            );
          });
          return false;
        }
      }
      if (isVisitable(value)) {
        return true;
      }
      formData.append(renderKey(path, key2, dots), convertValue(value));
      return false;
    }
    const stack = [];
    const exposedHelpers = Object.assign(predicates, {
      defaultVisitor,
      convertValue,
      isVisitable
    });
    function build2(value, path) {
      if (utils$12.isUndefined(value)) return;
      if (stack.indexOf(value) !== -1) {
        throw Error("Circular reference detected in " + path.join("."));
      }
      stack.push(value);
      utils$12.forEach(value, function each(el, key2) {
        const result = !(utils$12.isUndefined(el) || el === null) && visitor.call(
          formData,
          el,
          utils$12.isString(key2) ? key2.trim() : key2,
          path,
          exposedHelpers
        );
        if (result === true) {
          build2(el, path ? path.concat(key2) : [key2]);
        }
      });
      stack.pop();
    }
    if (!utils$12.isObject(obj)) {
      throw new TypeError("data must be an object");
    }
    build2(obj);
    return formData;
  }
  function encode$12(str) {
    const charMap = {
      "!": "%21",
      "'": "%27",
      "(": "%28",
      ")": "%29",
      "~": "%7E",
      "%20": "+",
      "%00": "\0"
    };
    return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
      return charMap[match];
    });
  }
  function AxiosURLSearchParams(params, options) {
    this._pairs = [];
    params && toFormData(params, this, options);
  }
  const prototype = AxiosURLSearchParams.prototype;
  prototype.append = function append(name, value) {
    this._pairs.push([name, value]);
  };
  prototype.toString = function toString2(encoder) {
    const _encode = encoder ? function(value) {
      return encoder.call(this, value, encode$12);
    } : encode$12;
    return this._pairs.map(function each(pair) {
      return _encode(pair[0]) + "=" + _encode(pair[1]);
    }, "").join("&");
  };
  function encode2(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  }
  function buildURL(url, params, options) {
    if (!params) {
      return url;
    }
    const _encode = options && options.encode || encode2;
    if (utils$12.isFunction(options)) {
      options = {
        serialize: options
      };
    }
    const serializeFn = options && options.serialize;
    let serializedParams;
    if (serializeFn) {
      serializedParams = serializeFn(params, options);
    } else {
      serializedParams = utils$12.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
    }
    if (serializedParams) {
      const hashmarkIndex = url.indexOf("#");
      if (hashmarkIndex !== -1) {
        url = url.slice(0, hashmarkIndex);
      }
      url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url;
  }
  class InterceptorManager {
    constructor() {
      this.handlers = [];
    }
    /**
     * Add a new interceptor to the stack
     *
     * @param {Function} fulfilled The function to handle `then` for a `Promise`
     * @param {Function} rejected The function to handle `reject` for a `Promise`
     *
     * @return {Number} An ID used to remove interceptor later
     */
    use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    }
    /**
     * Remove an interceptor from the stack
     *
     * @param {Number} id The ID that was returned by `use`
     *
     * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
     */
    eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    }
    /**
     * Clear all interceptors from the stack
     *
     * @returns {void}
     */
    clear() {
      if (this.handlers) {
        this.handlers = [];
      }
    }
    /**
     * Iterate over all the registered interceptors
     *
     * This method is particularly useful for skipping over any
     * interceptors that may have become `null` calling `eject`.
     *
     * @param {Function} fn The function to call for each interceptor
     *
     * @returns {void}
     */
    forEach(fn2) {
      utils$12.forEach(this.handlers, function forEachHandler(h2) {
        if (h2 !== null) {
          fn2(h2);
        }
      });
    }
  }
  var InterceptorManager$1 = InterceptorManager;
  var transitionalDefaults = {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  };
  var URLSearchParams$12 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
  var FormData$1 = typeof FormData !== "undefined" ? FormData : null;
  var Blob$1 = typeof Blob !== "undefined" ? Blob : null;
  var platform$1 = {
    isBrowser: true,
    classes: {
      URLSearchParams: URLSearchParams$12,
      FormData: FormData$1,
      Blob: Blob$1
    },
    protocols: ["http", "https", "file", "blob", "url", "data"]
  };
  const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
  const _navigator = typeof navigator === "object" && navigator || void 0;
  const hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
  const hasStandardBrowserWebWorkerEnv = (() => {
    return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
  })();
  const origin = hasBrowserEnv && window.location.href || "http://localhost";
  var utils2 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    hasBrowserEnv,
    hasStandardBrowserWebWorkerEnv,
    hasStandardBrowserEnv,
    navigator: _navigator,
    origin
  });
  var platform = {
    ...utils2,
    ...platform$1
  };
  function toURLEncodedForm(data, options) {
    return toFormData(data, new platform.classes.URLSearchParams(), {
      visitor: function(value, key2, path, helpers) {
        if (platform.isNode && utils$12.isBuffer(value)) {
          this.append(key2, value.toString("base64"));
          return false;
        }
        return helpers.defaultVisitor.apply(this, arguments);
      },
      ...options
    });
  }
  function parsePropPath(name) {
    return utils$12.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
      return match[0] === "[]" ? "" : match[1] || match[0];
    });
  }
  function arrayToObject(arr) {
    const obj = {};
    const keys = Object.keys(arr);
    let i;
    const len = keys.length;
    let key2;
    for (i = 0; i < len; i++) {
      key2 = keys[i];
      obj[key2] = arr[key2];
    }
    return obj;
  }
  function formDataToJSON(formData) {
    function buildPath(path, value, target, index) {
      let name = path[index++];
      if (name === "__proto__") return true;
      const isNumericKey = Number.isFinite(+name);
      const isLast = index >= path.length;
      name = !name && utils$12.isArray(target) ? target.length : name;
      if (isLast) {
        if (utils$12.hasOwnProp(target, name)) {
          target[name] = [target[name], value];
        } else {
          target[name] = value;
        }
        return !isNumericKey;
      }
      if (!target[name] || !utils$12.isObject(target[name])) {
        target[name] = [];
      }
      const result = buildPath(path, value, target[name], index);
      if (result && utils$12.isArray(target[name])) {
        target[name] = arrayToObject(target[name]);
      }
      return !isNumericKey;
    }
    if (utils$12.isFormData(formData) && utils$12.isFunction(formData.entries)) {
      const obj = {};
      utils$12.forEachEntry(formData, (name, value) => {
        buildPath(parsePropPath(name), value, obj, 0);
      });
      return obj;
    }
    return null;
  }
  function stringifySafely(rawValue, parser2, encoder) {
    if (utils$12.isString(rawValue)) {
      try {
        (parser2 || JSON.parse)(rawValue);
        return utils$12.trim(rawValue);
      } catch (e) {
        if (e.name !== "SyntaxError") {
          throw e;
        }
      }
    }
    return (encoder || JSON.stringify)(rawValue);
  }
  const defaults = {
    transitional: transitionalDefaults,
    adapter: ["xhr", "http", "fetch"],
    transformRequest: [function transformRequest(data, headers) {
      const contentType = headers.getContentType() || "";
      const hasJSONContentType = contentType.indexOf("application/json") > -1;
      const isObjectPayload = utils$12.isObject(data);
      if (isObjectPayload && utils$12.isHTMLForm(data)) {
        data = new FormData(data);
      }
      const isFormData2 = utils$12.isFormData(data);
      if (isFormData2) {
        return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
      }
      if (utils$12.isArrayBuffer(data) || utils$12.isBuffer(data) || utils$12.isStream(data) || utils$12.isFile(data) || utils$12.isBlob(data) || utils$12.isReadableStream(data)) {
        return data;
      }
      if (utils$12.isArrayBufferView(data)) {
        return data.buffer;
      }
      if (utils$12.isURLSearchParams(data)) {
        headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
        return data.toString();
      }
      let isFileList2;
      if (isObjectPayload) {
        if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
          return toURLEncodedForm(data, this.formSerializer).toString();
        }
        if ((isFileList2 = utils$12.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
          const _FormData = this.env && this.env.FormData;
          return toFormData(
            isFileList2 ? { "files[]": data } : data,
            _FormData && new _FormData(),
            this.formSerializer
          );
        }
      }
      if (isObjectPayload || hasJSONContentType) {
        headers.setContentType("application/json", false);
        return stringifySafely(data);
      }
      return data;
    }],
    transformResponse: [function transformResponse(data) {
      const transitional = this.transitional || defaults.transitional;
      const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
      const JSONRequested = this.responseType === "json";
      if (utils$12.isResponse(data) || utils$12.isReadableStream(data)) {
        return data;
      }
      if (data && utils$12.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
        const silentJSONParsing = transitional && transitional.silentJSONParsing;
        const strictJSONParsing = !silentJSONParsing && JSONRequested;
        try {
          return JSON.parse(data);
        } catch (e) {
          if (strictJSONParsing) {
            if (e.name === "SyntaxError") {
              throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
            }
            throw e;
          }
        }
      }
      return data;
    }],
    /**
     * A timeout in milliseconds to abort a request. If set to 0 (default) a
     * timeout is not created.
     */
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
      FormData: platform.classes.FormData,
      Blob: platform.classes.Blob
    },
    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    },
    headers: {
      common: {
        "Accept": "application/json, text/plain, */*",
        "Content-Type": void 0
      }
    }
  };
  utils$12.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
    defaults.headers[method] = {};
  });
  var defaults$1 = defaults;
  const ignoreDuplicateOf = utils$12.toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ]);
  var parseHeaders2 = (rawHeaders) => {
    const parsed = {};
    let key2;
    let val;
    let i;
    rawHeaders && rawHeaders.split("\n").forEach(function parser2(line) {
      i = line.indexOf(":");
      key2 = line.substring(0, i).trim().toLowerCase();
      val = line.substring(i + 1).trim();
      if (!key2 || parsed[key2] && ignoreDuplicateOf[key2]) {
        return;
      }
      if (key2 === "set-cookie") {
        if (parsed[key2]) {
          parsed[key2].push(val);
        } else {
          parsed[key2] = [val];
        }
      } else {
        parsed[key2] = parsed[key2] ? parsed[key2] + ", " + val : val;
      }
    });
    return parsed;
  };
  const $internals = Symbol("internals");
  function normalizeHeader(header) {
    return header && String(header).trim().toLowerCase();
  }
  function normalizeValue2(value) {
    if (value === false || value == null) {
      return value;
    }
    return utils$12.isArray(value) ? value.map(normalizeValue2) : String(value);
  }
  function parseTokens(str) {
    const tokens = /* @__PURE__ */ Object.create(null);
    const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let match;
    while (match = tokensRE.exec(str)) {
      tokens[match[1]] = match[2];
    }
    return tokens;
  }
  const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
  function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
    if (utils$12.isFunction(filter)) {
      return filter.call(this, value, header);
    }
    if (isHeaderNameFilter) {
      value = header;
    }
    if (!utils$12.isString(value)) return;
    if (utils$12.isString(filter)) {
      return value.indexOf(filter) !== -1;
    }
    if (utils$12.isRegExp(filter)) {
      return filter.test(value);
    }
  }
  function formatHeader(header) {
    return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char, str) => {
      return char.toUpperCase() + str;
    });
  }
  function buildAccessors(obj, header) {
    const accessorName = utils$12.toCamelCase(" " + header);
    ["get", "set", "has"].forEach((methodName) => {
      Object.defineProperty(obj, methodName + accessorName, {
        value: function(arg1, arg2, arg3) {
          return this[methodName].call(this, header, arg1, arg2, arg3);
        },
        configurable: true
      });
    });
  }
  class AxiosHeaders {
    constructor(headers) {
      headers && this.set(headers);
    }
    set(header, valueOrRewrite, rewrite) {
      const self2 = this;
      function setHeader(_value, _header, _rewrite) {
        const lHeader = normalizeHeader(_header);
        if (!lHeader) {
          throw new Error("header name must be a non-empty string");
        }
        const key2 = utils$12.findKey(self2, lHeader);
        if (!key2 || self2[key2] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key2] !== false) {
          self2[key2 || _header] = normalizeValue2(_value);
        }
      }
      const setHeaders = (headers, _rewrite) => utils$12.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
      if (utils$12.isPlainObject(header) || header instanceof this.constructor) {
        setHeaders(header, valueOrRewrite);
      } else if (utils$12.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
        setHeaders(parseHeaders2(header), valueOrRewrite);
      } else if (utils$12.isObject(header) && utils$12.isIterable(header)) {
        let obj = {}, dest, key2;
        for (const entry of header) {
          if (!utils$12.isArray(entry)) {
            throw TypeError("Object iterator must return a key-value pair");
          }
          obj[key2 = entry[0]] = (dest = obj[key2]) ? utils$12.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
        }
        setHeaders(obj, valueOrRewrite);
      } else {
        header != null && setHeader(valueOrRewrite, header, rewrite);
      }
      return this;
    }
    get(header, parser2) {
      header = normalizeHeader(header);
      if (header) {
        const key2 = utils$12.findKey(this, header);
        if (key2) {
          const value = this[key2];
          if (!parser2) {
            return value;
          }
          if (parser2 === true) {
            return parseTokens(value);
          }
          if (utils$12.isFunction(parser2)) {
            return parser2.call(this, value, key2);
          }
          if (utils$12.isRegExp(parser2)) {
            return parser2.exec(value);
          }
          throw new TypeError("parser must be boolean|regexp|function");
        }
      }
    }
    has(header, matcher) {
      header = normalizeHeader(header);
      if (header) {
        const key2 = utils$12.findKey(this, header);
        return !!(key2 && this[key2] !== void 0 && (!matcher || matchHeaderValue(this, this[key2], key2, matcher)));
      }
      return false;
    }
    delete(header, matcher) {
      const self2 = this;
      let deleted = false;
      function deleteHeader(_header) {
        _header = normalizeHeader(_header);
        if (_header) {
          const key2 = utils$12.findKey(self2, _header);
          if (key2 && (!matcher || matchHeaderValue(self2, self2[key2], key2, matcher))) {
            delete self2[key2];
            deleted = true;
          }
        }
      }
      if (utils$12.isArray(header)) {
        header.forEach(deleteHeader);
      } else {
        deleteHeader(header);
      }
      return deleted;
    }
    clear(matcher) {
      const keys = Object.keys(this);
      let i = keys.length;
      let deleted = false;
      while (i--) {
        const key2 = keys[i];
        if (!matcher || matchHeaderValue(this, this[key2], key2, matcher, true)) {
          delete this[key2];
          deleted = true;
        }
      }
      return deleted;
    }
    normalize(format) {
      const self2 = this;
      const headers = {};
      utils$12.forEach(this, (value, header) => {
        const key2 = utils$12.findKey(headers, header);
        if (key2) {
          self2[key2] = normalizeValue2(value);
          delete self2[header];
          return;
        }
        const normalized = format ? formatHeader(header) : String(header).trim();
        if (normalized !== header) {
          delete self2[header];
        }
        self2[normalized] = normalizeValue2(value);
        headers[normalized] = true;
      });
      return this;
    }
    concat(...targets) {
      return this.constructor.concat(this, ...targets);
    }
    toJSON(asStrings) {
      const obj = /* @__PURE__ */ Object.create(null);
      utils$12.forEach(this, (value, header) => {
        value != null && value !== false && (obj[header] = asStrings && utils$12.isArray(value) ? value.join(", ") : value);
      });
      return obj;
    }
    [Symbol.iterator]() {
      return Object.entries(this.toJSON())[Symbol.iterator]();
    }
    toString() {
      return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
    }
    getSetCookie() {
      return this.get("set-cookie") || [];
    }
    get [Symbol.toStringTag]() {
      return "AxiosHeaders";
    }
    static from(thing) {
      return thing instanceof this ? thing : new this(thing);
    }
    static concat(first, ...targets) {
      const computed = new this(first);
      targets.forEach((target) => computed.set(target));
      return computed;
    }
    static accessor(header) {
      const internals = this[$internals] = this[$internals] = {
        accessors: {}
      };
      const accessors = internals.accessors;
      const prototype2 = this.prototype;
      function defineAccessor(_header) {
        const lHeader = normalizeHeader(_header);
        if (!accessors[lHeader]) {
          buildAccessors(prototype2, _header);
          accessors[lHeader] = true;
        }
      }
      utils$12.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
      return this;
    }
  }
  AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
  utils$12.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key2) => {
    let mapped = key2[0].toUpperCase() + key2.slice(1);
    return {
      get: () => value,
      set(headerValue) {
        this[mapped] = headerValue;
      }
    };
  });
  utils$12.freezeMethods(AxiosHeaders);
  var AxiosHeaders$1 = AxiosHeaders;
  function transformData(fns, response) {
    const config = this || defaults$1;
    const context = response || config;
    const headers = AxiosHeaders$1.from(context.headers);
    let data = context.data;
    utils$12.forEach(fns, function transform(fn2) {
      data = fn2.call(config, data, headers.normalize(), response ? response.status : void 0);
    });
    headers.normalize();
    return data;
  }
  function isCancel(value) {
    return !!(value && value.__CANCEL__);
  }
  function CanceledError(message, config, request) {
    AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request);
    this.name = "CanceledError";
  }
  utils$12.inherits(CanceledError, AxiosError, {
    __CANCEL__: true
  });
  function settle(resolve, reject, response) {
    const validateStatus = response.config.validateStatus;
    if (!response.status || !validateStatus || validateStatus(response.status)) {
      resolve(response);
    } else {
      reject(new AxiosError(
        "Request failed with status code " + response.status,
        [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
        response.config,
        response.request,
        response
      ));
    }
  }
  function parseProtocol(url) {
    const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
    return match && match[1] || "";
  }
  function speedometer(samplesCount, min) {
    samplesCount = samplesCount || 10;
    const bytes = new Array(samplesCount);
    const timestamps = new Array(samplesCount);
    let head = 0;
    let tail = 0;
    let firstSampleTS;
    min = min !== void 0 ? min : 1e3;
    return function push(chunkLength) {
      const now = Date.now();
      const startedAt = timestamps[tail];
      if (!firstSampleTS) {
        firstSampleTS = now;
      }
      bytes[head] = chunkLength;
      timestamps[head] = now;
      let i = tail;
      let bytesCount = 0;
      while (i !== head) {
        bytesCount += bytes[i++];
        i = i % samplesCount;
      }
      head = (head + 1) % samplesCount;
      if (head === tail) {
        tail = (tail + 1) % samplesCount;
      }
      if (now - firstSampleTS < min) {
        return;
      }
      const passed = startedAt && now - startedAt;
      return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
    };
  }
  function throttle(fn2, freq) {
    let timestamp = 0;
    let threshold = 1e3 / freq;
    let lastArgs;
    let timer;
    const invoke = (args, now = Date.now()) => {
      timestamp = now;
      lastArgs = null;
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      fn2(...args);
    };
    const throttled = (...args) => {
      const now = Date.now();
      const passed = now - timestamp;
      if (passed >= threshold) {
        invoke(args, now);
      } else {
        lastArgs = args;
        if (!timer) {
          timer = setTimeout(() => {
            timer = null;
            invoke(lastArgs);
          }, threshold - passed);
        }
      }
    };
    const flush = () => lastArgs && invoke(lastArgs);
    return [throttled, flush];
  }
  const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
    let bytesNotified = 0;
    const _speedometer = speedometer(50, 250);
    return throttle((e) => {
      const loaded = e.loaded;
      const total = e.lengthComputable ? e.total : void 0;
      const progressBytes = loaded - bytesNotified;
      const rate = _speedometer(progressBytes);
      const inRange = loaded <= total;
      bytesNotified = loaded;
      const data = {
        loaded,
        total,
        progress: total ? loaded / total : void 0,
        bytes: progressBytes,
        rate: rate ? rate : void 0,
        estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
        event: e,
        lengthComputable: total != null,
        [isDownloadStream ? "download" : "upload"]: true
      };
      listener(data);
    }, freq);
  };
  const progressEventDecorator = (total, throttled) => {
    const lengthComputable = total != null;
    return [(loaded) => throttled[0]({
      lengthComputable,
      total,
      loaded
    }), throttled[1]];
  };
  const asyncDecorator = (fn2) => (...args) => utils$12.asap(() => fn2(...args));
  var isURLSameOrigin = platform.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url) => {
    url = new URL(url, platform.origin);
    return origin2.protocol === url.protocol && origin2.host === url.host && (isMSIE || origin2.port === url.port);
  })(
    new URL(platform.origin),
    platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)
  ) : () => true;
  var cookies = platform.hasStandardBrowserEnv ? (
    // Standard browser envs support document.cookie
    {
      write(name, value, expires, path, domain, secure) {
        const cookie = [name + "=" + encodeURIComponent(value)];
        utils$12.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
        utils$12.isString(path) && cookie.push("path=" + path);
        utils$12.isString(domain) && cookie.push("domain=" + domain);
        secure === true && cookie.push("secure");
        document.cookie = cookie.join("; ");
      },
      read(name) {
        const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
        return match ? decodeURIComponent(match[3]) : null;
      },
      remove(name) {
        this.write(name, "", Date.now() - 864e5);
      }
    }
  ) : (
    // Non-standard browser env (web workers, react-native) lack needed support.
    {
      write() {
      },
      read() {
        return null;
      },
      remove() {
      }
    }
  );
  function isAbsoluteURL(url) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
  }
  function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
  }
  function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
    let isRelativeUrl = !isAbsoluteURL(requestedURL);
    if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
      return combineURLs(baseURL, requestedURL);
    }
    return requestedURL;
  }
  const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;
  function mergeConfig(config1, config2) {
    config2 = config2 || {};
    const config = {};
    function getMergedValue(target, source, prop, caseless) {
      if (utils$12.isPlainObject(target) && utils$12.isPlainObject(source)) {
        return utils$12.merge.call({ caseless }, target, source);
      } else if (utils$12.isPlainObject(source)) {
        return utils$12.merge({}, source);
      } else if (utils$12.isArray(source)) {
        return source.slice();
      }
      return source;
    }
    function mergeDeepProperties(a2, b2, prop, caseless) {
      if (!utils$12.isUndefined(b2)) {
        return getMergedValue(a2, b2, prop, caseless);
      } else if (!utils$12.isUndefined(a2)) {
        return getMergedValue(void 0, a2, prop, caseless);
      }
    }
    function valueFromConfig2(a2, b2) {
      if (!utils$12.isUndefined(b2)) {
        return getMergedValue(void 0, b2);
      }
    }
    function defaultToConfig2(a2, b2) {
      if (!utils$12.isUndefined(b2)) {
        return getMergedValue(void 0, b2);
      } else if (!utils$12.isUndefined(a2)) {
        return getMergedValue(void 0, a2);
      }
    }
    function mergeDirectKeys(a2, b2, prop) {
      if (prop in config2) {
        return getMergedValue(a2, b2);
      } else if (prop in config1) {
        return getMergedValue(void 0, a2);
      }
    }
    const mergeMap = {
      url: valueFromConfig2,
      method: valueFromConfig2,
      data: valueFromConfig2,
      baseURL: defaultToConfig2,
      transformRequest: defaultToConfig2,
      transformResponse: defaultToConfig2,
      paramsSerializer: defaultToConfig2,
      timeout: defaultToConfig2,
      timeoutMessage: defaultToConfig2,
      withCredentials: defaultToConfig2,
      withXSRFToken: defaultToConfig2,
      adapter: defaultToConfig2,
      responseType: defaultToConfig2,
      xsrfCookieName: defaultToConfig2,
      xsrfHeaderName: defaultToConfig2,
      onUploadProgress: defaultToConfig2,
      onDownloadProgress: defaultToConfig2,
      decompress: defaultToConfig2,
      maxContentLength: defaultToConfig2,
      maxBodyLength: defaultToConfig2,
      beforeRedirect: defaultToConfig2,
      transport: defaultToConfig2,
      httpAgent: defaultToConfig2,
      httpsAgent: defaultToConfig2,
      cancelToken: defaultToConfig2,
      socketPath: defaultToConfig2,
      responseEncoding: defaultToConfig2,
      validateStatus: mergeDirectKeys,
      headers: (a2, b2, prop) => mergeDeepProperties(headersToObject(a2), headersToObject(b2), prop, true)
    };
    utils$12.forEach(Object.keys({ ...config1, ...config2 }), function computeConfigValue(prop) {
      const merge2 = mergeMap[prop] || mergeDeepProperties;
      const configValue = merge2(config1[prop], config2[prop], prop);
      utils$12.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
    });
    return config;
  }
  var resolveConfig = (config) => {
    const newConfig = mergeConfig({}, config);
    let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
    newConfig.headers = headers = AxiosHeaders$1.from(headers);
    newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);
    if (auth) {
      headers.set(
        "Authorization",
        "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
      );
    }
    let contentType;
    if (utils$12.isFormData(data)) {
      if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
        headers.setContentType(void 0);
      } else if ((contentType = headers.getContentType()) !== false) {
        const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
        headers.setContentType([type || "multipart/form-data", ...tokens].join("; "));
      }
    }
    if (platform.hasStandardBrowserEnv) {
      withXSRFToken && utils$12.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
      if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
        const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
        if (xsrfValue) {
          headers.set(xsrfHeaderName, xsrfValue);
        }
      }
    }
    return newConfig;
  };
  const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
  var xhrAdapter = isXHRAdapterSupported && function(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
      const _config = resolveConfig(config);
      let requestData = _config.data;
      const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
      let { responseType, onUploadProgress, onDownloadProgress } = _config;
      let onCanceled;
      let uploadThrottled, downloadThrottled;
      let flushUpload, flushDownload;
      function done() {
        flushUpload && flushUpload();
        flushDownload && flushDownload();
        _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
        _config.signal && _config.signal.removeEventListener("abort", onCanceled);
      }
      let request = new XMLHttpRequest();
      request.open(_config.method.toUpperCase(), _config.url, true);
      request.timeout = _config.timeout;
      function onloadend() {
        if (!request) {
          return;
        }
        const responseHeaders = AxiosHeaders$1.from(
          "getAllResponseHeaders" in request && request.getAllResponseHeaders()
        );
        const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
        const response = {
          data: responseData,
          status: request.status,
          statusText: request.statusText,
          headers: responseHeaders,
          config,
          request
        };
        settle(function _resolve(value) {
          resolve(value);
          done();
        }, function _reject(err) {
          reject(err);
          done();
        }, response);
        request = null;
      }
      if ("onloadend" in request) {
        request.onloadend = onloadend;
      } else {
        request.onreadystatechange = function handleLoad() {
          if (!request || request.readyState !== 4) {
            return;
          }
          if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
            return;
          }
          setTimeout(onloadend);
        };
      }
      request.onabort = function handleAbort() {
        if (!request) {
          return;
        }
        reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
        request = null;
      };
      request.onerror = function handleError() {
        reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request));
        request = null;
      };
      request.ontimeout = function handleTimeout() {
        let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
        const transitional = _config.transitional || transitionalDefaults;
        if (_config.timeoutErrorMessage) {
          timeoutErrorMessage = _config.timeoutErrorMessage;
        }
        reject(new AxiosError(
          timeoutErrorMessage,
          transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
          config,
          request
        ));
        request = null;
      };
      requestData === void 0 && requestHeaders.setContentType(null);
      if ("setRequestHeader" in request) {
        utils$12.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key2) {
          request.setRequestHeader(key2, val);
        });
      }
      if (!utils$12.isUndefined(_config.withCredentials)) {
        request.withCredentials = !!_config.withCredentials;
      }
      if (responseType && responseType !== "json") {
        request.responseType = _config.responseType;
      }
      if (onDownloadProgress) {
        [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
        request.addEventListener("progress", downloadThrottled);
      }
      if (onUploadProgress && request.upload) {
        [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
        request.upload.addEventListener("progress", uploadThrottled);
        request.upload.addEventListener("loadend", flushUpload);
      }
      if (_config.cancelToken || _config.signal) {
        onCanceled = (cancel) => {
          if (!request) {
            return;
          }
          reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
          request.abort();
          request = null;
        };
        _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
        if (_config.signal) {
          _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
        }
      }
      const protocol = parseProtocol(_config.url);
      if (protocol && platform.protocols.indexOf(protocol) === -1) {
        reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
        return;
      }
      request.send(requestData || null);
    });
  };
  const composeSignals = (signals, timeout) => {
    const { length } = signals = signals ? signals.filter(Boolean) : [];
    if (timeout || length) {
      let controller = new AbortController();
      let aborted;
      const onabort = function(reason) {
        if (!aborted) {
          aborted = true;
          unsubscribe();
          const err = reason instanceof Error ? reason : this.reason;
          controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));
        }
      };
      let timer = timeout && setTimeout(() => {
        timer = null;
        onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT));
      }, timeout);
      const unsubscribe = () => {
        if (signals) {
          timer && clearTimeout(timer);
          timer = null;
          signals.forEach((signal2) => {
            signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
          });
          signals = null;
        }
      };
      signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
      const { signal } = controller;
      signal.unsubscribe = () => utils$12.asap(unsubscribe);
      return signal;
    }
  };
  var composeSignals$1 = composeSignals;
  const streamChunk = function* (chunk, chunkSize) {
    let len = chunk.byteLength;
    if (len < chunkSize) {
      yield chunk;
      return;
    }
    let pos = 0;
    let end2;
    while (pos < len) {
      end2 = pos + chunkSize;
      yield chunk.slice(pos, end2);
      pos = end2;
    }
  };
  const readBytes = async function* (iterable, chunkSize) {
    for await (const chunk of readStream(iterable)) {
      yield* streamChunk(chunk, chunkSize);
    }
  };
  const readStream = async function* (stream) {
    if (stream[Symbol.asyncIterator]) {
      yield* stream;
      return;
    }
    const reader2 = stream.getReader();
    try {
      for (; ; ) {
        const { done, value } = await reader2.read();
        if (done) {
          break;
        }
        yield value;
      }
    } finally {
      await reader2.cancel();
    }
  };
  const trackStream = (stream, chunkSize, onProgress, onFinish) => {
    const iterator2 = readBytes(stream, chunkSize);
    let bytes = 0;
    let done;
    let _onFinish = (e) => {
      if (!done) {
        done = true;
        onFinish && onFinish(e);
      }
    };
    return new ReadableStream({
      async pull(controller) {
        try {
          const { done: done2, value } = await iterator2.next();
          if (done2) {
            _onFinish();
            controller.close();
            return;
          }
          let len = value.byteLength;
          if (onProgress) {
            let loadedBytes = bytes += len;
            onProgress(loadedBytes);
          }
          controller.enqueue(new Uint8Array(value));
        } catch (err) {
          _onFinish(err);
          throw err;
        }
      },
      cancel(reason) {
        _onFinish(reason);
        return iterator2.return();
      }
    }, {
      highWaterMark: 2
    });
  };
  const isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
  const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
  const encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
  const test = (fn2, ...args) => {
    try {
      return !!fn2(...args);
    } catch (e) {
      return false;
    }
  };
  const supportsRequestStream = isReadableStreamSupported && test(() => {
    let duplexAccessed = false;
    const hasContentType = new Request(platform.origin, {
      body: new ReadableStream(),
      method: "POST",
      get duplex() {
        duplexAccessed = true;
        return "half";
      }
    }).headers.has("Content-Type");
    return duplexAccessed && !hasContentType;
  });
  const DEFAULT_CHUNK_SIZE = 64 * 1024;
  const supportsResponseStream = isReadableStreamSupported && test(() => utils$12.isReadableStream(new Response("").body));
  const resolvers = {
    stream: supportsResponseStream && ((res) => res.body)
  };
  isFetchSupported && ((res) => {
    ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
      !resolvers[type] && (resolvers[type] = utils$12.isFunction(res[type]) ? (res2) => res2[type]() : (_, config) => {
        throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);
      });
    });
  })(new Response());
  const getBodyLength = async (body) => {
    if (body == null) {
      return 0;
    }
    if (utils$12.isBlob(body)) {
      return body.size;
    }
    if (utils$12.isSpecCompliantForm(body)) {
      const _request = new Request(platform.origin, {
        method: "POST",
        body
      });
      return (await _request.arrayBuffer()).byteLength;
    }
    if (utils$12.isArrayBufferView(body) || utils$12.isArrayBuffer(body)) {
      return body.byteLength;
    }
    if (utils$12.isURLSearchParams(body)) {
      body = body + "";
    }
    if (utils$12.isString(body)) {
      return (await encodeText(body)).byteLength;
    }
  };
  const resolveBodyLength = async (headers, body) => {
    const length = utils$12.toFiniteNumber(headers.getContentLength());
    return length == null ? getBodyLength(body) : length;
  };
  var fetchAdapter = isFetchSupported && (async (config) => {
    let {
      url,
      method,
      data,
      signal,
      cancelToken,
      timeout,
      onDownloadProgress,
      onUploadProgress,
      responseType,
      headers,
      withCredentials = "same-origin",
      fetchOptions
    } = resolveConfig(config);
    responseType = responseType ? (responseType + "").toLowerCase() : "text";
    let composedSignal = composeSignals$1([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
    let request;
    const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
      composedSignal.unsubscribe();
    });
    let requestContentLength;
    try {
      if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
        let _request = new Request(url, {
          method: "POST",
          body: data,
          duplex: "half"
        });
        let contentTypeHeader;
        if (utils$12.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
          headers.setContentType(contentTypeHeader);
        }
        if (_request.body) {
          const [onProgress, flush] = progressEventDecorator(
            requestContentLength,
            progressEventReducer(asyncDecorator(onUploadProgress))
          );
          data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
        }
      }
      if (!utils$12.isString(withCredentials)) {
        withCredentials = withCredentials ? "include" : "omit";
      }
      const isCredentialsSupported = "credentials" in Request.prototype;
      request = new Request(url, {
        ...fetchOptions,
        signal: composedSignal,
        method: method.toUpperCase(),
        headers: headers.normalize().toJSON(),
        body: data,
        duplex: "half",
        credentials: isCredentialsSupported ? withCredentials : void 0
      });
      let response = await fetch(request, fetchOptions);
      const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
      if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
        const options = {};
        ["status", "statusText", "headers"].forEach((prop) => {
          options[prop] = response[prop];
        });
        const responseContentLength = utils$12.toFiniteNumber(response.headers.get("content-length"));
        const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
          responseContentLength,
          progressEventReducer(asyncDecorator(onDownloadProgress), true)
        ) || [];
        response = new Response(
          trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
            flush && flush();
            unsubscribe && unsubscribe();
          }),
          options
        );
      }
      responseType = responseType || "text";
      let responseData = await resolvers[utils$12.findKey(resolvers, responseType) || "text"](response, config);
      !isStreamResponse && unsubscribe && unsubscribe();
      return await new Promise((resolve, reject) => {
        settle(resolve, reject, {
          data: responseData,
          headers: AxiosHeaders$1.from(response.headers),
          status: response.status,
          statusText: response.statusText,
          config,
          request
        });
      });
    } catch (err) {
      unsubscribe && unsubscribe();
      if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
        throw Object.assign(
          new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request),
          {
            cause: err.cause || err
          }
        );
      }
      throw AxiosError.from(err, err && err.code, config, request);
    }
  });
  const knownAdapters = {
    http: httpAdapter,
    xhr: xhrAdapter,
    fetch: fetchAdapter
  };
  utils$12.forEach(knownAdapters, (fn2, value) => {
    if (fn2) {
      try {
        Object.defineProperty(fn2, "name", { value });
      } catch (e) {
      }
      Object.defineProperty(fn2, "adapterName", { value });
    }
  });
  const renderReason = (reason) => `- ${reason}`;
  const isResolvedHandle = (adapter) => utils$12.isFunction(adapter) || adapter === null || adapter === false;
  var adapters = {
    getAdapter: (adapters2) => {
      adapters2 = utils$12.isArray(adapters2) ? adapters2 : [adapters2];
      const { length } = adapters2;
      let nameOrAdapter;
      let adapter;
      const rejectedReasons = {};
      for (let i = 0; i < length; i++) {
        nameOrAdapter = adapters2[i];
        let id;
        adapter = nameOrAdapter;
        if (!isResolvedHandle(nameOrAdapter)) {
          adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
          if (adapter === void 0) {
            throw new AxiosError(`Unknown adapter '${id}'`);
          }
        }
        if (adapter) {
          break;
        }
        rejectedReasons[id || "#" + i] = adapter;
      }
      if (!adapter) {
        const reasons = Object.entries(rejectedReasons).map(
          ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
        );
        let s2 = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
        throw new AxiosError(
          `There is no suitable adapter to dispatch the request ` + s2,
          "ERR_NOT_SUPPORT"
        );
      }
      return adapter;
    },
    adapters: knownAdapters
  };
  function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
      config.cancelToken.throwIfRequested();
    }
    if (config.signal && config.signal.aborted) {
      throw new CanceledError(null, config);
    }
  }
  function dispatchRequest(config) {
    throwIfCancellationRequested(config);
    config.headers = AxiosHeaders$1.from(config.headers);
    config.data = transformData.call(
      config,
      config.transformRequest
    );
    if (["post", "put", "patch"].indexOf(config.method) !== -1) {
      config.headers.setContentType("application/x-www-form-urlencoded", false);
    }
    const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);
    return adapter(config).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config);
      response.data = transformData.call(
        config,
        config.transformResponse,
        response
      );
      response.headers = AxiosHeaders$1.from(response.headers);
      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel(reason)) {
        throwIfCancellationRequested(config);
        if (reason && reason.response) {
          reason.response.data = transformData.call(
            config,
            config.transformResponse,
            reason.response
          );
          reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
        }
      }
      return Promise.reject(reason);
    });
  }
  const VERSION2 = "1.11.0";
  const validators$1 = {};
  ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
    validators$1[type] = function validator2(thing) {
      return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
    };
  });
  const deprecatedWarnings = {};
  validators$1.transitional = function transitional(validator2, version2, message) {
    function formatMessage(opt, desc) {
      return "[Axios v" + VERSION2 + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
    }
    return (value, opt, opts) => {
      if (validator2 === false) {
        throw new AxiosError(
          formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
          AxiosError.ERR_DEPRECATED
        );
      }
      if (version2 && !deprecatedWarnings[opt]) {
        deprecatedWarnings[opt] = true;
        console.warn(
          formatMessage(
            opt,
            " has been deprecated since v" + version2 + " and will be removed in the near future"
          )
        );
      }
      return validator2 ? validator2(value, opt, opts) : true;
    };
  };
  validators$1.spelling = function spelling(correctSpelling) {
    return (value, opt) => {
      console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
      return true;
    };
  };
  function assertOptions(options, schema2, allowUnknown) {
    if (typeof options !== "object") {
      throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
    }
    const keys = Object.keys(options);
    let i = keys.length;
    while (i-- > 0) {
      const opt = keys[i];
      const validator2 = schema2[opt];
      if (validator2) {
        const value = options[opt];
        const result = value === void 0 || validator2(value, opt, options);
        if (result !== true) {
          throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
        }
        continue;
      }
      if (allowUnknown !== true) {
        throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
      }
    }
  }
  var validator = {
    assertOptions,
    validators: validators$1
  };
  const validators = validator.validators;
  class Axios {
    constructor(instanceConfig) {
      this.defaults = instanceConfig || {};
      this.interceptors = {
        request: new InterceptorManager$1(),
        response: new InterceptorManager$1()
      };
    }
    /**
     * Dispatch a request
     *
     * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
     * @param {?Object} config
     *
     * @returns {Promise} The Promise to be fulfilled
     */
    async request(configOrUrl, config) {
      try {
        return await this._request(configOrUrl, config);
      } catch (err) {
        if (err instanceof Error) {
          let dummy = {};
          Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
          const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
          try {
            if (!err.stack) {
              err.stack = stack;
            } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
              err.stack += "\n" + stack;
            }
          } catch (e) {
          }
        }
        throw err;
      }
    }
    _request(configOrUrl, config) {
      if (typeof configOrUrl === "string") {
        config = config || {};
        config.url = configOrUrl;
      } else {
        config = configOrUrl || {};
      }
      config = mergeConfig(this.defaults, config);
      const { transitional, paramsSerializer, headers } = config;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      if (paramsSerializer != null) {
        if (utils$12.isFunction(paramsSerializer)) {
          config.paramsSerializer = {
            serialize: paramsSerializer
          };
        } else {
          validator.assertOptions(paramsSerializer, {
            encode: validators.function,
            serialize: validators.function
          }, true);
        }
      }
      if (config.allowAbsoluteUrls !== void 0) ;
      else if (this.defaults.allowAbsoluteUrls !== void 0) {
        config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
      } else {
        config.allowAbsoluteUrls = true;
      }
      validator.assertOptions(config, {
        baseUrl: validators.spelling("baseURL"),
        withXsrfToken: validators.spelling("withXSRFToken")
      }, true);
      config.method = (config.method || this.defaults.method || "get").toLowerCase();
      let contextHeaders = headers && utils$12.merge(
        headers.common,
        headers[config.method]
      );
      headers && utils$12.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        (method) => {
          delete headers[method];
        }
      );
      config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
      const requestInterceptorChain = [];
      let synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      const responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      let promise;
      let i = 0;
      let len;
      if (!synchronousRequestInterceptors) {
        const chain = [dispatchRequest.bind(this), void 0];
        chain.unshift(...requestInterceptorChain);
        chain.push(...responseInterceptorChain);
        len = chain.length;
        promise = Promise.resolve(config);
        while (i < len) {
          promise = promise.then(chain[i++], chain[i++]);
        }
        return promise;
      }
      len = requestInterceptorChain.length;
      let newConfig = config;
      i = 0;
      while (i < len) {
        const onFulfilled = requestInterceptorChain[i++];
        const onRejected = requestInterceptorChain[i++];
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error2) {
          onRejected.call(this, error2);
          break;
        }
      }
      try {
        promise = dispatchRequest.call(this, newConfig);
      } catch (error2) {
        return Promise.reject(error2);
      }
      i = 0;
      len = responseInterceptorChain.length;
      while (i < len) {
        promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
      }
      return promise;
    }
    getUri(config) {
      config = mergeConfig(this.defaults, config);
      const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
      return buildURL(fullPath, config.params, config.paramsSerializer);
    }
  }
  utils$12.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
    Axios.prototype[method] = function(url, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        url,
        data: (config || {}).data
      }));
    };
  });
  utils$12.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
    function generateHTTPMethod(isForm) {
      return function httpMethod(url, data, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          headers: isForm ? {
            "Content-Type": "multipart/form-data"
          } : {},
          url,
          data
        }));
      };
    }
    Axios.prototype[method] = generateHTTPMethod();
    Axios.prototype[method + "Form"] = generateHTTPMethod(true);
  });
  var Axios$1 = Axios;
  class CancelToken {
    constructor(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      let resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      const token = this;
      this.promise.then((cancel) => {
        if (!token._listeners) return;
        let i = token._listeners.length;
        while (i-- > 0) {
          token._listeners[i](cancel);
        }
        token._listeners = null;
      });
      this.promise.then = (onfulfilled) => {
        let _resolve;
        const promise = new Promise((resolve) => {
          token.subscribe(resolve);
          _resolve = resolve;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message, config, request) {
        if (token.reason) {
          return;
        }
        token.reason = new CanceledError(message, config, request);
        resolvePromise(token.reason);
      });
    }
    /**
     * Throws a `CanceledError` if cancellation has been requested.
     */
    throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    }
    /**
     * Subscribe to the cancel signal
     */
    subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    }
    /**
     * Unsubscribe from the cancel signal
     */
    unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      const index = this._listeners.indexOf(listener);
      if (index !== -1) {
        this._listeners.splice(index, 1);
      }
    }
    toAbortSignal() {
      const controller = new AbortController();
      const abort = (err) => {
        controller.abort(err);
      };
      this.subscribe(abort);
      controller.signal.unsubscribe = () => this.unsubscribe(abort);
      return controller.signal;
    }
    /**
     * Returns an object that contains a new `CancelToken` and a function that, when called,
     * cancels the `CancelToken`.
     */
    static source() {
      let cancel;
      const token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel
      };
    }
  }
  var CancelToken$1 = CancelToken;
  function spread(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  }
  function isAxiosError(payload) {
    return utils$12.isObject(payload) && payload.isAxiosError === true;
  }
  const HttpStatusCode = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
  };
  Object.entries(HttpStatusCode).forEach(([key2, value]) => {
    HttpStatusCode[value] = key2;
  });
  var HttpStatusCode$1 = HttpStatusCode;
  function createInstance(defaultConfig) {
    const context = new Axios$1(defaultConfig);
    const instance = bind(Axios$1.prototype.request, context);
    utils$12.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
    utils$12.extend(instance, context, null, { allOwnKeys: true });
    instance.create = function create(instanceConfig) {
      return createInstance(mergeConfig(defaultConfig, instanceConfig));
    };
    return instance;
  }
  const axios = createInstance(defaults$1);
  axios.Axios = Axios$1;
  axios.CanceledError = CanceledError;
  axios.CancelToken = CancelToken$1;
  axios.isCancel = isCancel;
  axios.VERSION = VERSION2;
  axios.toFormData = toFormData;
  axios.AxiosError = AxiosError;
  axios.Cancel = axios.CanceledError;
  axios.all = function all(promises) {
    return Promise.all(promises);
  };
  axios.spread = spread;
  axios.isAxiosError = isAxiosError;
  axios.mergeConfig = mergeConfig;
  axios.AxiosHeaders = AxiosHeaders$1;
  axios.formToJSON = (thing) => formDataToJSON(utils$12.isHTMLForm(thing) ? new FormData(thing) : thing);
  axios.getAdapter = adapters.getAdapter;
  axios.HttpStatusCode = HttpStatusCode$1;
  axios.default = axios;
  axios_1 = axios;
  return axios_1;
}
const version$1 = "15.3.1";
const require$$4$1 = {
  version: version$1
};
var hasRequiredHttpApi;
function requireHttpApi() {
  if (hasRequiredHttpApi) return HttpApi;
  hasRequiredHttpApi = 1;
  var __importDefault = HttpApi && HttpApi.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(HttpApi, "__esModule", { value: true });
  HttpApi.HttpApi = void 0;
  const TonCache_1 = requireTonCache();
  const dataloader_1 = __importDefault(requireDataloader());
  const axios_12 = __importDefault(/* @__PURE__ */ requireAxios());
  const zod_1 = /* @__PURE__ */ requireZod();
  const version2 = require$$4$1.version;
  const blockIdExt = zod_1.z.object({
    "@type": zod_1.z.literal("ton.blockIdExt"),
    workchain: zod_1.z.number(),
    shard: zod_1.z.string(),
    seqno: zod_1.z.number(),
    root_hash: zod_1.z.string(),
    file_hash: zod_1.z.string()
  });
  const addressInformation = zod_1.z.object({
    balance: zod_1.z.union([zod_1.z.number(), zod_1.z.string()]),
    extra_currencies: zod_1.z.optional(zod_1.z.array(zod_1.z.object({
      "@type": zod_1.z.literal("extraCurrency"),
      id: zod_1.z.number(),
      amount: zod_1.z.string()
    }))),
    state: zod_1.z.union([zod_1.z.literal("active"), zod_1.z.literal("uninitialized"), zod_1.z.literal("frozen")]),
    data: zod_1.z.string(),
    code: zod_1.z.string(),
    last_transaction_id: zod_1.z.object({
      "@type": zod_1.z.literal("internal.transactionId"),
      lt: zod_1.z.string(),
      hash: zod_1.z.string()
    }),
    block_id: blockIdExt,
    sync_utime: zod_1.z.number()
  });
  const bocResponse = zod_1.z.object({
    "@type": zod_1.z.literal("ok")
  });
  const feeResponse = zod_1.z.object({
    "@type": zod_1.z.literal("query.fees"),
    source_fees: zod_1.z.object({
      "@type": zod_1.z.literal("fees"),
      in_fwd_fee: zod_1.z.number(),
      storage_fee: zod_1.z.number(),
      gas_fee: zod_1.z.number(),
      fwd_fee: zod_1.z.number()
    })
  });
  const callGetMethod = zod_1.z.object({
    gas_used: zod_1.z.number(),
    exit_code: zod_1.z.number(),
    stack: zod_1.z.array(zod_1.z.unknown())
  });
  const messageData = zod_1.z.union([
    zod_1.z.object({
      "@type": zod_1.z.literal("msg.dataRaw"),
      "body": zod_1.z.string()
    }),
    zod_1.z.object({
      "@type": zod_1.z.literal("msg.dataText"),
      "text": zod_1.z.string()
    }),
    zod_1.z.object({
      "@type": zod_1.z.literal("msg.dataDecryptedText"),
      "text": zod_1.z.string()
    }),
    zod_1.z.object({
      "@type": zod_1.z.literal("msg.dataEncryptedText"),
      "text": zod_1.z.string()
    })
  ]);
  const message = zod_1.z.object({
    source: zod_1.z.string(),
    destination: zod_1.z.string(),
    value: zod_1.z.string(),
    fwd_fee: zod_1.z.string(),
    ihr_fee: zod_1.z.string(),
    created_lt: zod_1.z.string(),
    body_hash: zod_1.z.string(),
    msg_data: messageData,
    message: zod_1.z.string().optional()
  });
  const transaction = zod_1.z.object({
    data: zod_1.z.string(),
    utime: zod_1.z.number(),
    transaction_id: zod_1.z.object({
      lt: zod_1.z.string(),
      hash: zod_1.z.string()
    }),
    fee: zod_1.z.string(),
    storage_fee: zod_1.z.string(),
    other_fee: zod_1.z.string(),
    in_msg: zod_1.z.union([zod_1.z.undefined(), message]),
    out_msgs: zod_1.z.array(message)
  });
  const getTransactions = zod_1.z.array(transaction);
  const getMasterchain = zod_1.z.object({
    state_root_hash: zod_1.z.string(),
    last: blockIdExt,
    init: blockIdExt
  });
  const getShards = zod_1.z.object({
    shards: zod_1.z.array(blockIdExt)
  });
  const blockShortTxt = zod_1.z.object({
    "@type": zod_1.z.literal("blocks.shortTxId"),
    mode: zod_1.z.number(),
    account: zod_1.z.string(),
    lt: zod_1.z.string(),
    hash: zod_1.z.string()
  });
  const getBlockTransactions = zod_1.z.object({
    id: blockIdExt,
    req_count: zod_1.z.number(),
    incomplete: zod_1.z.boolean(),
    transactions: zod_1.z.array(blockShortTxt)
  });
  class TypedCache {
    constructor(namespace, cache, codec, keyEncoder) {
      this.namespace = namespace;
      this.cache = cache;
      this.codec = codec;
      this.keyEncoder = keyEncoder;
    }
    async get(key2) {
      let ex = await this.cache.get(this.namespace, this.keyEncoder(key2));
      if (ex) {
        let decoded = this.codec.safeParse(JSON.parse(ex));
        if (decoded.success) {
          return decoded.data;
        }
      }
      return null;
    }
    async set(key2, value) {
      if (value !== null) {
        await this.cache.set(this.namespace, this.keyEncoder(key2), JSON.stringify(value));
      } else {
        await this.cache.set(this.namespace, this.keyEncoder(key2), null);
      }
    }
  }
  let HttpApi$1 = class HttpApi {
    constructor(endpoint, parameters) {
      this.endpoint = endpoint;
      this.cache = new TonCache_1.InMemoryCache();
      this.parameters = {
        timeout: parameters?.timeout || 3e4,
        // 30 seconds by default
        apiKey: parameters?.apiKey,
        adapter: parameters?.adapter
      };
      this.shardCache = new TypedCache("ton-shard", this.cache, zod_1.z.array(blockIdExt), (src2) => src2 + "");
      this.shardLoader = new dataloader_1.default(async (src2) => {
        return await Promise.all(src2.map(async (v2) => {
          const cached = await this.shardCache.get(v2);
          if (cached) {
            return cached;
          }
          let loaded = (await this.doCall("shards", { seqno: v2 }, getShards)).shards;
          await this.shardCache.set(v2, loaded);
          return loaded;
        }));
      });
      this.shardTransactionsCache = new TypedCache("ton-shard-tx", this.cache, getBlockTransactions, (src2) => src2.workchain + ":" + src2.shard + ":" + src2.seqno);
      this.shardTransactionsLoader = new dataloader_1.default(async (src2) => {
        return await Promise.all(src2.map(async (v2) => {
          const cached = await this.shardTransactionsCache.get(v2);
          if (cached) {
            return cached;
          }
          let loaded = await this.doCall("getBlockTransactions", { workchain: v2.workchain, seqno: v2.seqno, shard: v2.shard }, getBlockTransactions);
          await this.shardTransactionsCache.set(v2, loaded);
          return loaded;
        }));
      }, { cacheKeyFn: (src2) => src2.workchain + ":" + src2.shard + ":" + src2.seqno });
    }
    getAddressInformation(address) {
      return this.doCall("getAddressInformation", { address: address.toString() }, addressInformation);
    }
    async getTransactions(address, opts) {
      const inclusive = opts.inclusive;
      delete opts.inclusive;
      let hash = void 0;
      if (opts.hash) {
        hash = Buffer.from(opts.hash, "base64").toString("hex");
      }
      let limit = opts.limit;
      if (opts.hash && opts.lt && inclusive !== true) {
        limit++;
      }
      let res = await this.doCall("getTransactions", { address: address.toString(), ...opts, limit, hash }, getTransactions);
      if (res.length > limit) {
        res = res.slice(0, limit);
      }
      if (opts.hash && opts.lt && inclusive !== true) {
        res.shift();
        return res;
      } else {
        return res;
      }
    }
    async getMasterchainInfo() {
      return await this.doCall("getMasterchainInfo", {}, getMasterchain);
    }
    async getShards(seqno) {
      return await this.shardLoader.load(seqno);
    }
    async getBlockTransactions(workchain, seqno, shard) {
      return await this.shardTransactionsLoader.load({ workchain, seqno, shard });
    }
    async getTransaction(address, lt2, hash) {
      let convHash = Buffer.from(hash, "base64").toString("hex");
      let res = await this.doCall("getTransactions", { address: address.toString(), lt: lt2, hash: convHash, limit: 1 }, getTransactions);
      let ex = res.find((v2) => v2.transaction_id.lt === lt2 && v2.transaction_id.hash === hash);
      if (ex) {
        return ex;
      } else {
        return null;
      }
    }
    async callGetMethod(address, method, stack) {
      return await this.doCall("runGetMethod", { address: address.toString(), method, stack: serializeStack2(stack) }, callGetMethod);
    }
    async sendBoc(body) {
      await this.doCall("sendBoc", { boc: body.toString("base64") }, bocResponse);
    }
    async estimateFee(address, args) {
      return await this.doCall("estimateFee", {
        address: address.toString(),
        body: args.body.toBoc().toString("base64"),
        "init_data": args.initData ? args.initData.toBoc().toString("base64") : "",
        "init_code": args.initCode ? args.initCode.toBoc().toString("base64") : "",
        ignore_chksig: args.ignoreSignature
      }, feeResponse);
    }
    async tryLocateResultTx(source, destination, created_lt) {
      return await this.doCall("tryLocateResultTx", { source: source.toString(), destination: destination.toString(), created_lt }, transaction);
    }
    async tryLocateSourceTx(source, destination, created_lt) {
      return await this.doCall("tryLocateSourceTx", { source: source.toString(), destination: destination.toString(), created_lt }, transaction);
    }
    async doCall(method, body, codec) {
      let headers = {
        "Content-Type": "application/json",
        "X-Ton-Client-Version": version2
      };
      if (this.parameters.apiKey) {
        headers["X-API-Key"] = this.parameters.apiKey;
      }
      let res = await axios_12.default.post(this.endpoint, JSON.stringify({
        id: "1",
        jsonrpc: "2.0",
        method,
        params: body
      }), {
        headers,
        timeout: this.parameters.timeout,
        adapter: this.parameters.adapter
      });
      if (res.status !== 200 || !res.data.ok) {
        throw Error("Received error: " + JSON.stringify(res.data));
      }
      let decoded = codec.safeParse(res.data.result);
      if (decoded.success) {
        return decoded.data;
      } else {
        throw Error("Malformed response: " + decoded.error.format()._errors.join(", "));
      }
    }
  };
  HttpApi.HttpApi = HttpApi$1;
  function serializeStack2(src2) {
    let stack = [];
    for (let s2 of src2) {
      if (s2.type === "int") {
        stack.push(["num", s2.value.toString()]);
      } else if (s2.type === "cell") {
        stack.push(["tvm.Cell", s2.cell.toBoc().toString("base64")]);
      } else if (s2.type === "slice") {
        stack.push(["tvm.Slice", s2.cell.toBoc().toString("base64")]);
      } else if (s2.type === "builder") {
        stack.push(["tvm.Builder", s2.cell.toBoc().toString("base64")]);
      } else {
        throw Error("Unsupported stack item type: " + s2.type);
      }
    }
    return stack;
  }
  return HttpApi;
}
var TonClient = {};
var hasRequiredTonClient;
function requireTonClient() {
  if (hasRequiredTonClient) return TonClient;
  hasRequiredTonClient = 1;
  Object.defineProperty(TonClient, "__esModule", { value: true });
  TonClient.TonClient = void 0;
  const HttpApi_1 = requireHttpApi();
  const core_1 = requireDist$4();
  let TonClient$1 = class TonClient {
    constructor(parameters) {
      this.parameters = {
        endpoint: parameters.endpoint
      };
      this.api = new HttpApi_1.HttpApi(this.parameters.endpoint, {
        timeout: parameters.timeout,
        apiKey: parameters.apiKey,
        adapter: parameters.httpAdapter
      });
    }
    /**
     * Get Address Balance
     * @param address address for balance check
     * @returns balance
     */
    async getBalance(address) {
      return (await this.getContractState(address)).balance;
    }
    /**
     * Invoke get method
     * @param address contract address
     * @param name name of method
     * @param params optional parameters
     * @returns stack and gas_used field
     */
    async runMethod(address, name, stack = []) {
      let res = await this.api.callGetMethod(address, name, stack);
      if (res.exit_code !== 0) {
        throw Error("Unable to execute get method. Got exit_code: " + res.exit_code);
      }
      return { gas_used: res.gas_used, stack: parseStack2(res.stack) };
    }
    /**
     * Invoke get method
     * @param address contract address
     * @param name name of method
     * @param params optional parameters
     * @returns stack and gas_used field
     * @deprecated use runMethod instead
     */
    async callGetMethod(address, name, stack = []) {
      return this.runMethod(address, name, stack);
    }
    /**
     * Invoke get method that returns error code instead of throwing error
     * @param address contract address
     * @param name name of method
     * @param params optional parameters
     * @returns stack and gas_used field
    */
    async runMethodWithError(address, name, params = []) {
      let res = await this.api.callGetMethod(address, name, params);
      return { gas_used: res.gas_used, stack: parseStack2(res.stack), exit_code: res.exit_code };
    }
    /**
     * Invoke get method that returns error code instead of throwing error
     * @param address contract address
     * @param name name of method
     * @param params optional parameters
     * @returns stack and gas_used field
     * @deprecated use runMethodWithError instead
     */
    async callGetMethodWithError(address, name, stack = []) {
      return this.runMethodWithError(address, name, stack);
    }
    /**
     * Get transactions
     * @param address address
     */
    async getTransactions(address, opts) {
      let tx = await this.api.getTransactions(address, opts);
      let res = [];
      for (let r of tx) {
        res.push((0, core_1.loadTransaction)(core_1.Cell.fromBoc(Buffer.from(r.data, "base64"))[0].beginParse()));
      }
      return res;
    }
    /**
     * Get transaction by it's id
     * @param address address
     * @param lt logical time
     * @param hash transaction hash
     * @returns transaction or null if not exist
     */
    async getTransaction(address, lt2, hash) {
      let res = await this.api.getTransaction(address, lt2, hash);
      if (res) {
        return (0, core_1.loadTransaction)(core_1.Cell.fromBoc(Buffer.from(res.data, "base64"))[0].beginParse());
      } else {
        return null;
      }
    }
    /**
     * Locate outcoming transaction of destination address by incoming message
     * @param source message source address
     * @param destination message destination address
     * @param created_lt message's created lt
     * @returns transaction
     */
    async tryLocateResultTx(source, destination, created_lt) {
      let res = await this.api.tryLocateResultTx(source, destination, created_lt);
      return (0, core_1.loadTransaction)(core_1.Cell.fromBase64(res.data).beginParse());
    }
    /**
     * Locate incoming transaction of source address by outcoming message
     * @param source message source address
     * @param destination message destination address
     * @param created_lt message's created lt
     * @returns transaction
     */
    async tryLocateSourceTx(source, destination, created_lt) {
      let res = await this.api.tryLocateSourceTx(source, destination, created_lt);
      return (0, core_1.loadTransaction)(core_1.Cell.fromBase64(res.data).beginParse());
    }
    /**
     * Fetch latest masterchain info
     * @returns masterchain info
     */
    async getMasterchainInfo() {
      let r = await this.api.getMasterchainInfo();
      return {
        workchain: r.init.workchain,
        shard: r.last.shard,
        initSeqno: r.init.seqno,
        latestSeqno: r.last.seqno
      };
    }
    /**
     * Fetch latest workchain shards
     * @param seqno masterchain seqno
     */
    async getWorkchainShards(seqno) {
      let r = await this.api.getShards(seqno);
      return r.map((m2) => ({
        workchain: m2.workchain,
        shard: m2.shard,
        seqno: m2.seqno
      }));
    }
    /**
     * Fetch transactions inf shards
     * @param workchain
     * @param seqno
     * @param shard
     */
    async getShardTransactions(workchain, seqno, shard) {
      let tx = await this.api.getBlockTransactions(workchain, seqno, shard);
      if (tx.incomplete) {
        throw Error("Unsupported");
      }
      return tx.transactions.map((v2) => ({
        account: core_1.Address.parseRaw(v2.account),
        lt: v2.lt,
        hash: v2.hash
      }));
    }
    /**
     * Send message to a network
     * @param src source message
     */
    async sendMessage(src2) {
      const boc = (0, core_1.beginCell)().store((0, core_1.storeMessage)(src2)).endCell().toBoc();
      await this.api.sendBoc(boc);
    }
    /**
     * Send file to a network
     * @param src source file
     */
    async sendFile(src2) {
      await this.api.sendBoc(src2);
    }
    /**
     * Estimate fees for external message
     * @param address target address
     * @returns
     */
    async estimateExternalMessageFee(address, args) {
      return await this.api.estimateFee(address, { body: args.body, initCode: args.initCode, initData: args.initData, ignoreSignature: args.ignoreSignature });
    }
    /**
     * Send external message to contract
     * @param contract contract to send message
     * @param src message body
     */
    async sendExternalMessage(contract, src2) {
      if (await this.isContractDeployed(contract.address) || !contract.init) {
        const message = (0, core_1.external)({
          to: contract.address,
          body: src2
        });
        await this.sendMessage(message);
      } else {
        const message = (0, core_1.external)({
          to: contract.address,
          init: contract.init,
          body: src2
        });
        await this.sendMessage(message);
      }
    }
    /**
     * Check if contract is deployed
     * @param address addres to check
     * @returns true if contract is in active state
     */
    async isContractDeployed(address) {
      return (await this.getContractState(address)).state === "active";
    }
    /**
     * Resolves contract state
     * @param address contract address
     */
    async getContractState(address) {
      let info = await this.api.getAddressInformation(address);
      let balance = BigInt(info.balance);
      let state = info.state;
      return {
        balance,
        extra_currencies: info.extra_currencies,
        state,
        code: info.code !== "" ? Buffer.from(info.code, "base64") : null,
        data: info.data !== "" ? Buffer.from(info.data, "base64") : null,
        lastTransaction: info.last_transaction_id.lt !== "0" ? {
          lt: info.last_transaction_id.lt,
          hash: info.last_transaction_id.hash
        } : null,
        blockId: {
          workchain: info.block_id.workchain,
          shard: info.block_id.shard,
          seqno: info.block_id.seqno
        },
        timestampt: info.sync_utime
      };
    }
    /**
     * Open contract
     * @param src source contract
     * @returns contract
     */
    open(src2) {
      return (0, core_1.openContract)(src2, (args) => createProvider(this, args.address, args.init));
    }
    /**
     * Create a provider
     * @param address address
     * @param init optional init
     * @returns provider
     */
    provider(address, init) {
      return createProvider(this, address, init ?? null);
    }
  };
  TonClient.TonClient = TonClient$1;
  function parseStackEntry(x2) {
    const typeName = x2["@type"];
    switch (typeName) {
      case "tvm.list":
      case "tvm.tuple":
        return x2.elements.map(parseStackEntry);
      case "tvm.cell":
        return core_1.Cell.fromBoc(Buffer.from(x2.bytes, "base64"))[0];
      case "tvm.slice":
        return core_1.Cell.fromBoc(Buffer.from(x2.bytes, "base64"))[0];
      case "tvm.stackEntryCell":
        return parseStackEntry(x2.cell);
      case "tvm.stackEntrySlice":
        return parseStackEntry(x2.slice);
      case "tvm.stackEntryTuple":
        return parseStackEntry(x2.tuple);
      case "tvm.stackEntryList":
        return parseStackEntry(x2.list);
      case "tvm.stackEntryNumber":
        return parseStackEntry(x2.number);
      case "tvm.numberDecimal":
        return BigInt(x2.number);
      default:
        throw Error("Unsupported item type: " + typeName);
    }
  }
  function parseStackItem2(s2) {
    if (s2[0] === "num") {
      let val = s2[1];
      if (val.startsWith("-")) {
        return { type: "int", value: -BigInt(val.slice(1)) };
      } else {
        return { type: "int", value: BigInt(val) };
      }
    } else if (s2[0] === "null") {
      return { type: "null" };
    } else if (s2[0] === "cell") {
      return { type: "cell", cell: core_1.Cell.fromBoc(Buffer.from(s2[1].bytes, "base64"))[0] };
    } else if (s2[0] === "slice") {
      return { type: "slice", cell: core_1.Cell.fromBoc(Buffer.from(s2[1].bytes, "base64"))[0] };
    } else if (s2[0] === "builder") {
      return { type: "builder", cell: core_1.Cell.fromBoc(Buffer.from(s2[1].bytes, "base64"))[0] };
    } else if (s2[0] === "tuple" || s2[0] === "list") {
      if (s2[1].elements.length === 0) {
        return { type: "null" };
      }
      return { type: "tuple", items: s2[1].elements.map(parseStackEntry) };
    } else {
      throw Error("Unsupported stack item type: " + s2[0]);
    }
  }
  function parseStack2(src2) {
    let stack = [];
    for (let s2 of src2) {
      stack.push(parseStackItem2(s2));
    }
    return new core_1.TupleReader(stack);
  }
  function createProvider(client, address, init) {
    return {
      async getState() {
        let state = await client.getContractState(address);
        let balance = state.balance;
        let last = state.lastTransaction ? { lt: BigInt(state.lastTransaction.lt), hash: Buffer.from(state.lastTransaction.hash, "base64") } : null;
        let ecMap = null;
        let storage;
        if (state.state === "active") {
          storage = {
            type: "active",
            code: state.code ? state.code : null,
            data: state.data ? state.data : null
          };
        } else if (state.state === "uninitialized") {
          storage = {
            type: "uninit"
          };
        } else if (state.state === "frozen") {
          storage = {
            type: "frozen",
            stateHash: Buffer.alloc(0)
          };
        } else {
          throw Error("Unsupported state");
        }
        if (state.extra_currencies && state.extra_currencies.length > 0) {
          ecMap = {};
          for (let ec of state.extra_currencies) {
            ecMap[ec.id] = BigInt(ec.amount);
          }
        }
        return {
          balance,
          extracurrency: ecMap,
          last,
          state: storage
        };
      },
      async get(name, args) {
        if (typeof name !== "string") {
          throw new Error("Method name must be a string for TonClient provider");
        }
        let method = await client.runMethod(address, name, args);
        return { stack: method.stack };
      },
      async external(message) {
        let neededInit = null;
        if (init && !await client.isContractDeployed(address)) {
          neededInit = init;
        }
        const ext = (0, core_1.external)({
          to: address,
          init: neededInit,
          body: message
        });
        let boc = (0, core_1.beginCell)().store((0, core_1.storeMessage)(ext)).endCell().toBoc();
        await client.sendFile(boc);
      },
      async internal(via, message) {
        let neededInit = null;
        if (init && !await client.isContractDeployed(address)) {
          neededInit = init;
        }
        let bounce = true;
        if (message.bounce !== null && message.bounce !== void 0) {
          bounce = message.bounce;
        }
        let value;
        if (typeof message.value === "string") {
          value = (0, core_1.toNano)(message.value);
        } else {
          value = message.value;
        }
        let body = null;
        if (typeof message.body === "string") {
          body = (0, core_1.comment)(message.body);
        } else if (message.body) {
          body = message.body;
        }
        await via.send({
          to: address,
          value,
          bounce,
          sendMode: message.sendMode,
          extracurrency: message.extracurrency,
          init: neededInit,
          body
        });
      },
      open(contract) {
        return (0, core_1.openContract)(contract, (args) => createProvider(client, args.address, args.init ?? null));
      },
      getTransactions(address2, lt2, hash, limit) {
        return client.getTransactions(address2, { limit: limit ?? 100, lt: lt2.toString(), hash: hash.toString("base64"), inclusive: true });
      }
    };
  }
  return TonClient;
}
var TonClient4 = {};
var toUrlSafe = {};
var hasRequiredToUrlSafe;
function requireToUrlSafe() {
  if (hasRequiredToUrlSafe) return toUrlSafe;
  hasRequiredToUrlSafe = 1;
  Object.defineProperty(toUrlSafe, "__esModule", { value: true });
  toUrlSafe.toUrlSafe = toUrlSafe$1;
  function toUrlSafe$1(src2) {
    while (src2.indexOf("/") >= 0) {
      src2 = src2.replace("/", "_");
    }
    while (src2.indexOf("+") >= 0) {
      src2 = src2.replace("+", "-");
    }
    while (src2.indexOf("=") >= 0) {
      src2 = src2.replace("=", "");
    }
    return src2;
  }
  return toUrlSafe;
}
var hasRequiredTonClient4;
function requireTonClient4() {
  if (hasRequiredTonClient4) return TonClient4;
  hasRequiredTonClient4 = 1;
  var __classPrivateFieldSet = TonClient4 && TonClient4.__classPrivateFieldSet || function(receiver, state, value, kind, f2) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = TonClient4 && TonClient4.__classPrivateFieldGet || function(receiver, state, kind, f2) {
    if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
  };
  var __importDefault = TonClient4 && TonClient4.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  var _TonClient4_endpoint, _TonClient4_timeout, _TonClient4_adapter, _TonClient4_axios;
  Object.defineProperty(TonClient4, "__esModule", { value: true });
  TonClient4.TonClient4 = void 0;
  const axios_12 = __importDefault(/* @__PURE__ */ requireAxios());
  const core_1 = requireDist$4();
  const toUrlSafe_1 = requireToUrlSafe();
  const zod_1 = /* @__PURE__ */ requireZod();
  let TonClient4$1 = class TonClient4 {
    constructor(args) {
      _TonClient4_endpoint.set(this, void 0);
      _TonClient4_timeout.set(this, void 0);
      _TonClient4_adapter.set(this, void 0);
      _TonClient4_axios.set(this, void 0);
      __classPrivateFieldSet(this, _TonClient4_axios, axios_12.default.create(), "f");
      __classPrivateFieldSet(this, _TonClient4_endpoint, args.endpoint, "f");
      __classPrivateFieldSet(this, _TonClient4_timeout, args.timeout || 5e3, "f");
      __classPrivateFieldSet(this, _TonClient4_adapter, args.httpAdapter, "f");
      if (args.requestInterceptor) {
        __classPrivateFieldGet(this, _TonClient4_axios, "f").interceptors.request.use(args.requestInterceptor);
      }
    }
    /**
     * Get Last Block
     * @returns last block info
     */
    async getLastBlock() {
      let res = await __classPrivateFieldGet(this, _TonClient4_axios, "f").get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/latest", { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
      let lastBlock = lastBlockCodec.safeParse(res.data);
      if (!lastBlock.success) {
        throw Error("Mailformed response: " + lastBlock.error.format()._errors.join(", "));
      }
      return lastBlock.data;
    }
    /**
     * Get block info
     * @param seqno block sequence number
     * @returns block info
     */
    async getBlock(seqno) {
      let res = await __classPrivateFieldGet(this, _TonClient4_axios, "f").get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno, { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
      let block = blockCodec.safeParse(res.data);
      if (!block.success) {
        throw Error("Mailformed response");
      }
      if (!block.data.exist) {
        throw Error("Block is out of scope");
      }
      return block.data.block;
    }
    /**
     * Get block info by unix timestamp
     * @param ts unix timestamp
     * @returns block info
     */
    async getBlockByUtime(ts) {
      let res = await __classPrivateFieldGet(this, _TonClient4_axios, "f").get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/utime/" + ts, { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
      let block = blockCodec.safeParse(res.data);
      if (!block.success) {
        throw Error("Mailformed response");
      }
      if (!block.data.exist) {
        throw Error("Block is out of scope");
      }
      return block.data.block;
    }
    /**
     * Get block info by unix timestamp
     * @param seqno block sequence number
     * @param address account address
     * @returns account info
     */
    async getAccount(seqno, address) {
      let res = await __classPrivateFieldGet(this, _TonClient4_axios, "f").get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno + "/" + address.toString({ urlSafe: true }), { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
      let account = accountCodec.safeParse(res.data);
      if (!account.success) {
        throw Error("Mailformed response");
      }
      return account.data;
    }
    /**
     * Get account lite info (without code and data)
     * @param seqno block sequence number
     * @param address account address
     * @returns account lite info
     */
    async getAccountLite(seqno, address) {
      let res = await __classPrivateFieldGet(this, _TonClient4_axios, "f").get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno + "/" + address.toString({ urlSafe: true }) + "/lite", { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
      let account = accountLiteCodec.safeParse(res.data);
      if (!account.success) {
        throw Error("Mailformed response");
      }
      return account.data;
    }
    /**
     * Check if contract is deployed
     * @param address addres to check
     * @returns true if contract is in active state
     */
    async isContractDeployed(seqno, address) {
      let account = await this.getAccountLite(seqno, address);
      return account.account.state.type === "active";
    }
    /**
     * Check if account was updated since
     * @param seqno block sequence number
     * @param address account address
     * @param lt account last transaction lt
     * @returns account change info
     */
    async isAccountChanged(seqno, address, lt2) {
      let res = await __classPrivateFieldGet(this, _TonClient4_axios, "f").get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno + "/" + address.toString({ urlSafe: true }) + "/changed/" + lt2.toString(10), { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
      let changed = changedCodec.safeParse(res.data);
      if (!changed.success) {
        throw Error("Mailformed response");
      }
      return changed.data;
    }
    /**
     * Load unparsed account transactions
     * @param address address
     * @param lt last transaction lt
     * @param hash last transaction hash
     * @returns unparsed transactions
     */
    async getAccountTransactions(address, lt2, hash) {
      let res = await __classPrivateFieldGet(this, _TonClient4_axios, "f").get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/account/" + address.toString({ urlSafe: true }) + "/tx/" + lt2.toString(10) + "/" + (0, toUrlSafe_1.toUrlSafe)(hash.toString("base64")), { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
      let transactions = transactionsCodec.safeParse(res.data);
      if (!transactions.success) {
        throw Error("Mailformed response");
      }
      let data = transactions.data;
      let tx = [];
      let cells = core_1.Cell.fromBoc(Buffer.from(data.boc, "base64"));
      for (let i = 0; i < data.blocks.length; i++) {
        tx.push({
          block: data.blocks[i],
          tx: (0, core_1.loadTransaction)(cells[i].beginParse())
        });
      }
      return tx;
    }
    /**
     * Load parsed account transactions
     * @param address address
     * @param lt last transaction lt
     * @param hash last transaction hash
     * @param count number of transactions to load
     * @returns parsed transactions
     */
    async getAccountTransactionsParsed(address, lt2, hash, count = 20) {
      let res = await __classPrivateFieldGet(this, _TonClient4_axios, "f").get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/account/" + address.toString({ urlSafe: true }) + "/tx/parsed/" + lt2.toString(10) + "/" + (0, toUrlSafe_1.toUrlSafe)(hash.toString("base64")), {
        adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"),
        timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f"),
        params: {
          count
        }
      });
      let parsedTransactionsRes = parsedTransactionsCodec.safeParse(res.data);
      if (!parsedTransactionsRes.success) {
        throw Error("Mailformed response");
      }
      return parsedTransactionsRes.data;
    }
    /**
     * Get network config
     * @param seqno block sequence number
     * @param ids optional config ids
     * @returns network config
     */
    async getConfig(seqno, ids) {
      let tail = "";
      if (ids && ids.length > 0) {
        tail = "/" + [...ids].sort().join(",");
      }
      let res = await __classPrivateFieldGet(this, _TonClient4_axios, "f").get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno + "/config" + tail, { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
      let config = configCodec.safeParse(res.data);
      if (!config.success) {
        throw Error("Mailformed response");
      }
      return config.data;
    }
    /**
     * Execute run method
     * @param seqno block sequence number
     * @param address account address
     * @param name method name
     * @param args method arguments
     * @returns method result
     */
    async runMethod(seqno, address, name, args) {
      let tail = args && args.length > 0 ? "/" + (0, toUrlSafe_1.toUrlSafe)((0, core_1.serializeTuple)(args).toBoc({ idx: false, crc32: false }).toString("base64")) : "";
      let url = __classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno + "/" + address.toString({ urlSafe: true }) + "/run/" + encodeURIComponent(name) + tail;
      let res = await __classPrivateFieldGet(this, _TonClient4_axios, "f").get(url, { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
      let runMethod = runMethodCodec.safeParse(res.data);
      if (!runMethod.success) {
        throw Error("Mailformed response");
      }
      let resultTuple = runMethod.data.resultRaw ? (0, core_1.parseTuple)(core_1.Cell.fromBoc(Buffer.from(runMethod.data.resultRaw, "base64"))[0]) : [];
      return {
        exitCode: runMethod.data.exitCode,
        result: resultTuple,
        resultRaw: runMethod.data.resultRaw,
        block: runMethod.data.block,
        shardBlock: runMethod.data.shardBlock,
        reader: new core_1.TupleReader(resultTuple)
      };
    }
    /**
     * Send external message
     * @param message message boc
     * @returns message status
     */
    async sendMessage(message) {
      let res = await __classPrivateFieldGet(this, _TonClient4_axios, "f").post(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/send", { boc: message.toString("base64") }, { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
      let send = sendCodec.safeParse(res.data);
      if (!send.success) {
        throw Error("Mailformed response");
      }
      return { status: res.data.status };
    }
    /**
     * Open smart contract
     * @param contract contract
     * @returns opened contract
     */
    open(contract) {
      return (0, core_1.openContract)(contract, (args) => createProvider(this, null, args.address, args.init));
    }
    /**
     * Open smart contract
     * @param block block number
     * @param contract contract
     * @returns opened contract
     */
    openAt(block, contract) {
      return (0, core_1.openContract)(contract, (args) => createProvider(this, block, args.address, args.init));
    }
    /**
     * Create provider
     * @param address address
     * @param init optional init data
     * @returns provider
     */
    provider(address, init) {
      return createProvider(this, null, address, init ?? null);
    }
    /**
     * Create provider at specified block number
     * @param block block number
     * @param address address
     * @param init optional init data
     * @returns provider
     */
    providerAt(block, address, init) {
      return createProvider(this, block, address, init ?? null);
    }
  };
  TonClient4.TonClient4 = TonClient4$1;
  _TonClient4_endpoint = /* @__PURE__ */ new WeakMap(), _TonClient4_timeout = /* @__PURE__ */ new WeakMap(), _TonClient4_adapter = /* @__PURE__ */ new WeakMap(), _TonClient4_axios = /* @__PURE__ */ new WeakMap();
  function createProvider(client, block, address, init) {
    return {
      async getState() {
        let sq = block;
        if (sq === null) {
          let res = await client.getLastBlock();
          sq = res.last.seqno;
        }
        let state = await client.getAccount(sq, address);
        let last = state.account.last ? { lt: BigInt(state.account.last.lt), hash: Buffer.from(state.account.last.hash, "base64") } : null;
        let storage;
        if (state.account.state.type === "active") {
          storage = {
            type: "active",
            code: state.account.state.code ? Buffer.from(state.account.state.code, "base64") : null,
            data: state.account.state.data ? Buffer.from(state.account.state.data, "base64") : null
          };
        } else if (state.account.state.type === "uninit") {
          storage = {
            type: "uninit"
          };
        } else if (state.account.state.type === "frozen") {
          storage = {
            type: "frozen",
            stateHash: Buffer.from(state.account.state.stateHash, "base64")
          };
        } else {
          throw Error("Unsupported state");
        }
        let ecMap = null;
        if (state.account.balance.currencies) {
          ecMap = {};
          let currencies = state.account.balance.currencies;
          for (let [k2, v2] of Object.entries(currencies)) {
            ecMap[Number(k2)] = BigInt(v2);
          }
        }
        return {
          balance: BigInt(state.account.balance.coins),
          extracurrency: ecMap,
          last,
          state: storage
        };
      },
      async get(name, args) {
        if (typeof name !== "string") {
          throw new Error("Method name must be a string for TonClient4 provider");
        }
        let sq = block;
        if (sq === null) {
          let res = await client.getLastBlock();
          sq = res.last.seqno;
        }
        let method = await client.runMethod(sq, address, name, args);
        if (method.exitCode !== 0 && method.exitCode !== 1) {
          throw Error("Exit code: " + method.exitCode);
        }
        return {
          stack: new core_1.TupleReader(method.result)
        };
      },
      async external(message) {
        let last = await client.getLastBlock();
        let neededInit = null;
        if (init && (await client.getAccountLite(last.last.seqno, address)).account.state.type !== "active") {
          neededInit = init;
        }
        const ext = (0, core_1.external)({
          to: address,
          init: neededInit,
          body: message
        });
        let pkg = (0, core_1.beginCell)().store((0, core_1.storeMessage)(ext)).endCell().toBoc();
        await client.sendMessage(pkg);
      },
      async internal(via, message) {
        let last = await client.getLastBlock();
        let neededInit = null;
        if (init && (await client.getAccountLite(last.last.seqno, address)).account.state.type !== "active") {
          neededInit = init;
        }
        let bounce = true;
        if (message.bounce !== null && message.bounce !== void 0) {
          bounce = message.bounce;
        }
        let value;
        if (typeof message.value === "string") {
          value = (0, core_1.toNano)(message.value);
        } else {
          value = message.value;
        }
        let body = null;
        if (typeof message.body === "string") {
          body = (0, core_1.comment)(message.body);
        } else if (message.body) {
          body = message.body;
        }
        await via.send({
          to: address,
          value,
          extracurrency: message.extracurrency,
          bounce,
          sendMode: message.sendMode,
          init: neededInit,
          body
        });
      },
      open(contract) {
        return (0, core_1.openContract)(contract, (args) => createProvider(client, block, args.address, args.init ?? null));
      },
      async getTransactions(address2, lt2, hash, limit) {
        const useLimit = typeof limit === "number";
        if (useLimit && limit <= 0) {
          return [];
        }
        let transactions = [];
        do {
          const txs = await client.getAccountTransactions(address2, lt2, hash);
          const firstTx = txs[0].tx;
          const [firstLt, firstHash] = [firstTx.lt, firstTx.hash()];
          const needSkipFirst = transactions.length > 0 && firstLt === lt2 && firstHash.equals(hash);
          if (needSkipFirst) {
            txs.shift();
          }
          if (txs.length === 0) {
            break;
          }
          const lastTx = txs[txs.length - 1].tx;
          const [lastLt, lastHash] = [lastTx.lt, lastTx.hash()];
          if (lastLt === lt2 && lastHash.equals(hash)) {
            break;
          }
          transactions.push(...txs.map((tx) => tx.tx));
          lt2 = lastLt;
          hash = lastHash;
        } while (useLimit && transactions.length < limit);
        if (useLimit) {
          transactions = transactions.slice(0, limit);
        }
        return transactions;
      }
    };
  }
  const lastBlockCodec = zod_1.z.object({
    last: zod_1.z.object({
      seqno: zod_1.z.number(),
      shard: zod_1.z.string(),
      workchain: zod_1.z.number(),
      fileHash: zod_1.z.string(),
      rootHash: zod_1.z.string()
    }),
    init: zod_1.z.object({
      fileHash: zod_1.z.string(),
      rootHash: zod_1.z.string()
    }),
    stateRootHash: zod_1.z.string(),
    now: zod_1.z.number()
  });
  const blockCodec = zod_1.z.union([zod_1.z.object({
    exist: zod_1.z.literal(false)
  }), zod_1.z.object({
    exist: zod_1.z.literal(true),
    block: zod_1.z.object({
      shards: zod_1.z.array(zod_1.z.object({
        workchain: zod_1.z.number(),
        seqno: zod_1.z.number(),
        shard: zod_1.z.string(),
        rootHash: zod_1.z.string(),
        fileHash: zod_1.z.string(),
        transactions: zod_1.z.array(zod_1.z.object({
          account: zod_1.z.string(),
          hash: zod_1.z.string(),
          lt: zod_1.z.string()
        }))
      }))
    })
  })]);
  const storageStatCodec = zod_1.z.object({
    lastPaid: zod_1.z.number(),
    duePayment: zod_1.z.union([zod_1.z.null(), zod_1.z.string()]),
    used: zod_1.z.object({
      bits: zod_1.z.number(),
      cells: zod_1.z.number(),
      publicCells: zod_1.z.number().optional()
    })
  });
  const accountCodec = zod_1.z.object({
    account: zod_1.z.object({
      state: zod_1.z.union([
        zod_1.z.object({ type: zod_1.z.literal("uninit") }),
        zod_1.z.object({ type: zod_1.z.literal("active"), code: zod_1.z.union([zod_1.z.string(), zod_1.z.null()]), data: zod_1.z.union([zod_1.z.string(), zod_1.z.null()]) }),
        zod_1.z.object({ type: zod_1.z.literal("frozen"), stateHash: zod_1.z.string() })
      ]),
      balance: zod_1.z.object({
        coins: zod_1.z.string(),
        currencies: zod_1.z.record(zod_1.z.string(), zod_1.z.string())
      }),
      last: zod_1.z.union([
        zod_1.z.null(),
        zod_1.z.object({
          lt: zod_1.z.string(),
          hash: zod_1.z.string()
        })
      ]),
      storageStat: zod_1.z.union([zod_1.z.null(), storageStatCodec])
    }),
    block: zod_1.z.object({
      workchain: zod_1.z.number(),
      seqno: zod_1.z.number(),
      shard: zod_1.z.string(),
      rootHash: zod_1.z.string(),
      fileHash: zod_1.z.string()
    })
  });
  const accountLiteCodec = zod_1.z.object({
    account: zod_1.z.object({
      state: zod_1.z.union([
        zod_1.z.object({ type: zod_1.z.literal("uninit") }),
        zod_1.z.object({ type: zod_1.z.literal("active"), codeHash: zod_1.z.string(), dataHash: zod_1.z.string() }),
        zod_1.z.object({ type: zod_1.z.literal("frozen"), stateHash: zod_1.z.string() })
      ]),
      balance: zod_1.z.object({
        coins: zod_1.z.string(),
        currencies: zod_1.z.record(zod_1.z.string(), zod_1.z.string())
      }),
      last: zod_1.z.union([
        zod_1.z.null(),
        zod_1.z.object({
          lt: zod_1.z.string(),
          hash: zod_1.z.string()
        })
      ]),
      storageStat: zod_1.z.union([zod_1.z.null(), storageStatCodec])
    })
  });
  const changedCodec = zod_1.z.object({
    changed: zod_1.z.boolean(),
    block: zod_1.z.object({
      workchain: zod_1.z.number(),
      seqno: zod_1.z.number(),
      shard: zod_1.z.string(),
      rootHash: zod_1.z.string(),
      fileHash: zod_1.z.string()
    })
  });
  const runMethodCodec = zod_1.z.object({
    exitCode: zod_1.z.number(),
    resultRaw: zod_1.z.union([zod_1.z.string(), zod_1.z.null()]),
    block: zod_1.z.object({
      workchain: zod_1.z.number(),
      seqno: zod_1.z.number(),
      shard: zod_1.z.string(),
      rootHash: zod_1.z.string(),
      fileHash: zod_1.z.string()
    }),
    shardBlock: zod_1.z.object({
      workchain: zod_1.z.number(),
      seqno: zod_1.z.number(),
      shard: zod_1.z.string(),
      rootHash: zod_1.z.string(),
      fileHash: zod_1.z.string()
    })
  });
  const configCodec = zod_1.z.object({
    config: zod_1.z.object({
      cell: zod_1.z.string(),
      address: zod_1.z.string(),
      globalBalance: zod_1.z.object({
        coins: zod_1.z.string()
      })
    })
  });
  const sendCodec = zod_1.z.object({
    status: zod_1.z.number()
  });
  const blocksCodec = zod_1.z.array(zod_1.z.object({
    workchain: zod_1.z.number(),
    seqno: zod_1.z.number(),
    shard: zod_1.z.string(),
    rootHash: zod_1.z.string(),
    fileHash: zod_1.z.string()
  }));
  const transactionsCodec = zod_1.z.object({
    blocks: blocksCodec,
    boc: zod_1.z.string()
  });
  const parsedAddressExternalCodec = zod_1.z.object({
    bits: zod_1.z.number(),
    data: zod_1.z.string()
  });
  const parsedMessageInfoCodec = zod_1.z.union([
    zod_1.z.object({
      type: zod_1.z.literal("internal"),
      value: zod_1.z.string(),
      dest: zod_1.z.string(),
      src: zod_1.z.string(),
      bounced: zod_1.z.boolean(),
      bounce: zod_1.z.boolean(),
      ihrDisabled: zod_1.z.boolean(),
      createdAt: zod_1.z.number(),
      createdLt: zod_1.z.string(),
      fwdFee: zod_1.z.string(),
      ihrFee: zod_1.z.string()
    }),
    zod_1.z.object({
      type: zod_1.z.literal("external-in"),
      dest: zod_1.z.string(),
      src: zod_1.z.union([parsedAddressExternalCodec, zod_1.z.null()]),
      importFee: zod_1.z.string()
    }),
    zod_1.z.object({
      type: zod_1.z.literal("external-out"),
      dest: zod_1.z.union([parsedAddressExternalCodec, zod_1.z.null()])
    })
  ]);
  const parsedStateInitCodec = zod_1.z.object({
    splitDepth: zod_1.z.union([zod_1.z.number(), zod_1.z.null()]),
    code: zod_1.z.union([zod_1.z.string(), zod_1.z.null()]),
    data: zod_1.z.union([zod_1.z.string(), zod_1.z.null()]),
    special: zod_1.z.union([zod_1.z.object({ tick: zod_1.z.boolean(), tock: zod_1.z.boolean() }), zod_1.z.null()])
  });
  const parsedMessageCodec = zod_1.z.object({
    body: zod_1.z.string(),
    info: parsedMessageInfoCodec,
    init: zod_1.z.union([parsedStateInitCodec, zod_1.z.null()])
  });
  const accountStatusCodec = zod_1.z.union([zod_1.z.literal("uninitialized"), zod_1.z.literal("frozen"), zod_1.z.literal("active"), zod_1.z.literal("non-existing")]);
  const txBodyCodec = zod_1.z.union([
    zod_1.z.object({ type: zod_1.z.literal("comment"), comment: zod_1.z.string() }),
    zod_1.z.object({ type: zod_1.z.literal("payload"), cell: zod_1.z.string() })
  ]);
  const parsedOperationItemCodec = zod_1.z.union([
    zod_1.z.object({ kind: zod_1.z.literal("ton"), amount: zod_1.z.string() }),
    zod_1.z.object({ kind: zod_1.z.literal("token"), amount: zod_1.z.string() })
  ]);
  const supportedMessageTypeCodec = zod_1.z.union([
    zod_1.z.literal("jetton::excesses"),
    zod_1.z.literal("jetton::transfer"),
    zod_1.z.literal("jetton::transfer_notification"),
    zod_1.z.literal("deposit"),
    zod_1.z.literal("deposit::ok"),
    zod_1.z.literal("withdraw"),
    zod_1.z.literal("withdraw::all"),
    zod_1.z.literal("withdraw::delayed"),
    zod_1.z.literal("withdraw::ok"),
    zod_1.z.literal("airdrop")
  ]);
  const opCodec = zod_1.z.object({
    type: supportedMessageTypeCodec,
    options: zod_1.z.optional(zod_1.z.record(zod_1.z.string()))
  });
  const parsedOperationCodec = zod_1.z.object({
    address: zod_1.z.string(),
    comment: zod_1.z.optional(zod_1.z.string()),
    items: zod_1.z.array(parsedOperationItemCodec),
    op: zod_1.z.optional(opCodec)
  });
  const parsedTransactionCodec = zod_1.z.object({
    address: zod_1.z.string(),
    lt: zod_1.z.string(),
    hash: zod_1.z.string(),
    prevTransaction: zod_1.z.object({
      lt: zod_1.z.string(),
      hash: zod_1.z.string()
    }),
    time: zod_1.z.number(),
    outMessagesCount: zod_1.z.number(),
    oldStatus: accountStatusCodec,
    newStatus: accountStatusCodec,
    fees: zod_1.z.string(),
    update: zod_1.z.object({
      oldHash: zod_1.z.string(),
      newHash: zod_1.z.string()
    }),
    inMessage: zod_1.z.union([parsedMessageCodec, zod_1.z.null()]),
    outMessages: zod_1.z.array(parsedMessageCodec),
    parsed: zod_1.z.object({
      seqno: zod_1.z.union([zod_1.z.number(), zod_1.z.null()]),
      body: zod_1.z.union([txBodyCodec, zod_1.z.null()]),
      status: zod_1.z.union([zod_1.z.literal("success"), zod_1.z.literal("failed"), zod_1.z.literal("pending")]),
      dest: zod_1.z.union([zod_1.z.string(), zod_1.z.null()]),
      kind: zod_1.z.union([zod_1.z.literal("out"), zod_1.z.literal("in")]),
      amount: zod_1.z.string(),
      resolvedAddress: zod_1.z.string(),
      bounced: zod_1.z.boolean(),
      mentioned: zod_1.z.array(zod_1.z.string())
    }),
    operation: parsedOperationCodec
  });
  const parsedTransactionsCodec = zod_1.z.object({
    blocks: blocksCodec,
    transactions: zod_1.z.array(parsedTransactionCodec)
  });
  return TonClient4;
}
var WalletContractV1R1 = {};
var createWalletTransfer = {};
var WalletContractV5Beta$1 = {};
var WalletV5BetaWalletId = {};
var hasRequiredWalletV5BetaWalletId;
function requireWalletV5BetaWalletId() {
  if (hasRequiredWalletV5BetaWalletId) return WalletV5BetaWalletId;
  hasRequiredWalletV5BetaWalletId = 1;
  Object.defineProperty(WalletV5BetaWalletId, "__esModule", { value: true });
  WalletV5BetaWalletId.loadWalletIdV5Beta = loadWalletIdV5Beta;
  WalletV5BetaWalletId.storeWalletIdV5Beta = storeWalletIdV5Beta;
  const core_1 = requireDist$4();
  const walletV5BetaVersionsSerialisation = {
    v5: 0
  };
  function loadWalletIdV5Beta(value) {
    const bitReader = new core_1.BitReader(new core_1.BitString(typeof value === "bigint" ? Buffer.from(value.toString(16), "hex") : value instanceof core_1.Slice ? value.loadBuffer(10) : value, 0, 80));
    const networkGlobalId = bitReader.loadInt(32);
    const workchain = bitReader.loadInt(8);
    const walletVersionRaw = bitReader.loadUint(8);
    const subwalletNumber = bitReader.loadUint(32);
    const walletVersion = Object.entries(walletV5BetaVersionsSerialisation).find(([_, value2]) => value2 === walletVersionRaw)?.[0];
    if (walletVersion === void 0) {
      throw new Error(`Can't deserialize walletId: unknown wallet version ${walletVersionRaw}`);
    }
    return { networkGlobalId, workchain, walletVersion, subwalletNumber };
  }
  function storeWalletIdV5Beta(walletId) {
    return (builder2) => {
      builder2.storeInt(walletId.networkGlobalId, 32);
      builder2.storeInt(walletId.workchain, 8);
      builder2.storeUint(walletV5BetaVersionsSerialisation[walletId.walletVersion], 8);
      builder2.storeUint(walletId.subwalletNumber, 32);
    };
  }
  return WalletV5BetaWalletId;
}
var hasRequiredWalletContractV5Beta$1;
function requireWalletContractV5Beta$1() {
  if (hasRequiredWalletContractV5Beta$1) return WalletContractV5Beta$1;
  hasRequiredWalletContractV5Beta$1 = 1;
  Object.defineProperty(WalletContractV5Beta$1, "__esModule", { value: true });
  WalletContractV5Beta$1.WalletContractV5Beta = void 0;
  const core_1 = requireDist$4();
  const createWalletTransfer_1 = requireCreateWalletTransfer();
  const WalletV5BetaWalletId_1 = requireWalletV5BetaWalletId();
  class WalletContractV5Beta2 {
    static create(args) {
      const walletId = {
        networkGlobalId: args.walletId?.networkGlobalId ?? -239,
        workchain: args?.walletId?.workchain ?? 0,
        subwalletNumber: args?.walletId?.subwalletNumber ?? 0,
        walletVersion: args?.walletId?.walletVersion ?? "v5"
      };
      return new WalletContractV5Beta2(walletId, args.publicKey);
    }
    constructor(walletId, publicKey) {
      this.walletId = walletId;
      this.publicKey = publicKey;
      this.walletId = walletId;
      let code = core_1.Cell.fromBoc(Buffer.from("te6cckEBAQEAIwAIQgLkzzsvTG1qYeoPK1RH0mZ4WyavNjfbLe7mvNGqgm80Eg3NjhE=", "base64"))[0];
      let data = (0, core_1.beginCell)().storeInt(0, 33).store((0, WalletV5BetaWalletId_1.storeWalletIdV5Beta)(this.walletId)).storeBuffer(this.publicKey, 32).storeBit(0).endCell();
      this.init = { code, data };
      this.address = (0, core_1.contractAddress)(this.walletId.workchain, { code, data });
    }
    /**
     * Get Wallet Balance
     */
    async getBalance(provider) {
      let state = await provider.getState();
      return state.balance;
    }
    /**
     * Get Wallet Seqno
     */
    async getSeqno(provider) {
      let state = await provider.getState();
      if (state.state.type === "active") {
        let res = await provider.get("seqno", []);
        return res.stack.readNumber();
      } else {
        return 0;
      }
    }
    /**
     * Get Wallet Extensions
     */
    async getExtensions(provider) {
      let state = await provider.getState();
      if (state.state.type === "active") {
        const result = await provider.get("get_extensions", []);
        return result.stack.readCellOpt();
      } else {
        return null;
      }
    }
    /**
     * Get Wallet Extensions
     */
    async getExtensionsArray(provider) {
      const extensions = await this.getExtensions(provider);
      if (!extensions) {
        return [];
      }
      const dict = core_1.Dictionary.loadDirect(core_1.Dictionary.Keys.BigUint(256), core_1.Dictionary.Values.BigInt(8), extensions);
      return dict.keys().map((key2) => {
        const wc = dict.get(key2);
        const addressHex = key2 ^ wc + 1n;
        return core_1.Address.parseRaw(`${wc}:${addressHex.toString(16).padStart(64, "0")}`);
      });
    }
    /**
     * Get is secret-key authentication enabled
     */
    async getIsSecretKeyAuthEnabled(provider) {
      let res = await provider.get("get_is_signature_auth_allowed", []);
      const result = res.stack.readNumber();
      return result !== 0;
    }
    /**
     * Send signed transfer
     */
    async send(provider, message) {
      await provider.external(message);
    }
    /**
     * Sign and send transfer
     */
    async sendTransfer(provider, args) {
      const transfer = await this.createTransfer(args);
      await this.send(provider, transfer);
    }
    /**
     * Sign and send add extension request
     */
    async sendAddExtension(provider, args) {
      const request = await this.createAddExtension(args);
      await this.send(provider, request);
    }
    /**
     * Sign and send remove extension request
     */
    async sendRemoveExtension(provider, args) {
      const request = await this.createRemoveExtension(args);
      await this.send(provider, request);
    }
    /**
     * Sign and send actions batch
     */
    async sendActionsBatch(provider, args) {
      const request = await this.createRequest(args);
      await this.send(provider, request);
    }
    createActions(args) {
      const actions = args.messages.map((message) => ({ type: "sendMsg", mode: args.sendMode, outMsg: message }));
      return actions;
    }
    /**
     * Create signed transfer
     */
    createTransfer(args) {
      return this.createRequest({
        ...args,
        actions: this.createActions({ messages: args.messages, sendMode: args.sendMode })
      });
    }
    /**
     * Create signed add extension request
     */
    createAddExtension(args) {
      return this.createRequest({
        ...args,
        actions: [{
          type: "addExtension",
          address: args.extensionAddress
        }]
      });
    }
    /**
     * Create signed remove extension request
     */
    createRemoveExtension(args) {
      return this.createRequest({
        ...args,
        actions: [{
          type: "removeExtension",
          address: args.extensionAddress
        }]
      });
    }
    /**
     * Create signed request or extension auth request
     */
    createRequest(args) {
      if (args.authType === "extension") {
        return (0, createWalletTransfer_1.createWalletTransferV5Beta)(args);
      }
      return (0, createWalletTransfer_1.createWalletTransferV5Beta)({
        ...args,
        walletId: (0, WalletV5BetaWalletId_1.storeWalletIdV5Beta)(this.walletId)
      });
    }
    /**
     * Create sender
     */
    sender(provider, secretKey) {
      return {
        send: async (args) => {
          let seqno = await this.getSeqno(provider);
          let transfer = this.createTransfer({
            seqno,
            secretKey,
            sendMode: args.sendMode ?? core_1.SendMode.PAY_GAS_SEPARATELY + core_1.SendMode.IGNORE_ERRORS,
            messages: [(0, core_1.internal)({
              to: args.to,
              value: args.value,
              extracurrency: args.extracurrency,
              init: args.init,
              body: args.body,
              bounce: args.bounce
            })]
          });
          await this.send(provider, transfer);
        }
      };
    }
  }
  WalletContractV5Beta$1.WalletContractV5Beta = WalletContractV5Beta2;
  WalletContractV5Beta2.OpCodes = {
    auth_extension: 1702392942,
    auth_signed_external: 1936287598,
    auth_signed_internal: 1936289396
  };
  return WalletContractV5Beta$1;
}
var WalletV5BetaActions = {};
var WalletV5OutActions = {};
var hasRequiredWalletV5OutActions;
function requireWalletV5OutActions() {
  if (hasRequiredWalletV5OutActions) return WalletV5OutActions;
  hasRequiredWalletV5OutActions = 1;
  Object.defineProperty(WalletV5OutActions, "__esModule", { value: true });
  WalletV5OutActions.isOutActionExtended = isOutActionExtended;
  WalletV5OutActions.isOutActionBasic = isOutActionBasic;
  function isOutActionExtended(action) {
    return action.type === "setIsPublicKeyEnabled" || action.type === "addExtension" || action.type === "removeExtension";
  }
  function isOutActionBasic(action) {
    return !isOutActionExtended(action);
  }
  return WalletV5OutActions;
}
var hasRequiredWalletV5BetaActions;
function requireWalletV5BetaActions() {
  if (hasRequiredWalletV5BetaActions) return WalletV5BetaActions;
  hasRequiredWalletV5BetaActions = 1;
  Object.defineProperty(WalletV5BetaActions, "__esModule", { value: true });
  WalletV5BetaActions.storeOutActionExtendedV5Beta = storeOutActionExtendedV5Beta;
  WalletV5BetaActions.loadOutActionV5BetaExtended = loadOutActionV5BetaExtended;
  WalletV5BetaActions.storeOutListExtendedV5Beta = storeOutListExtendedV5Beta;
  WalletV5BetaActions.loadOutListExtendedV5Beta = loadOutListExtendedV5Beta;
  const core_1 = requireDist$4();
  const WalletV5OutActions_1 = requireWalletV5OutActions();
  const outActionSetIsPublicKeyEnabledTag = 550222170;
  function storeOutActionSetIsPublicKeyEnabled(action) {
    return (builder2) => {
      builder2.storeUint(outActionSetIsPublicKeyEnabledTag, 32).storeUint(action.isEnabled ? 1 : 0, 1);
    };
  }
  const outActionAddExtensionTag = 474012575;
  function storeOutActionAddExtension(action) {
    return (builder2) => {
      builder2.storeUint(outActionAddExtensionTag, 32).storeAddress(action.address);
    };
  }
  const outActionRemoveExtensionTag = 1588524196;
  function storeOutActionRemoveExtension(action) {
    return (builder2) => {
      builder2.storeUint(outActionRemoveExtensionTag, 32).storeAddress(action.address);
    };
  }
  function storeOutActionExtendedV5Beta(action) {
    switch (action.type) {
      case "setIsPublicKeyEnabled":
        return storeOutActionSetIsPublicKeyEnabled(action);
      case "addExtension":
        return storeOutActionAddExtension(action);
      case "removeExtension":
        return storeOutActionRemoveExtension(action);
      default:
        throw new Error("Unknown action type" + action?.type);
    }
  }
  function loadOutActionV5BetaExtended(slice) {
    const tag = slice.loadUint(32);
    switch (tag) {
      case outActionSetIsPublicKeyEnabledTag:
        return {
          type: "setIsPublicKeyEnabled",
          isEnabled: !!slice.loadUint(1)
        };
      case outActionAddExtensionTag:
        return {
          type: "addExtension",
          address: slice.loadAddress()
        };
      case outActionRemoveExtensionTag:
        return {
          type: "removeExtension",
          address: slice.loadAddress()
        };
      default:
        throw new Error(`Unknown extended out action tag 0x${tag.toString(16)}`);
    }
  }
  function storeOutListExtendedV5Beta(actions) {
    const [action, ...rest] = actions;
    if (!action || !(0, WalletV5OutActions_1.isOutActionExtended)(action)) {
      if (actions.some(WalletV5OutActions_1.isOutActionExtended)) {
        throw new Error("Can't serialize actions list: all extended actions must be placed before out actions");
      }
      return (builder2) => {
        builder2.storeUint(0, 1).storeRef((0, core_1.beginCell)().store((0, core_1.storeOutList)(actions)).endCell());
      };
    }
    return (builder2) => {
      builder2.storeUint(1, 1).store(storeOutActionExtendedV5Beta(action)).storeRef((0, core_1.beginCell)().store(storeOutListExtendedV5Beta(rest)).endCell());
    };
  }
  function loadOutListExtendedV5Beta(slice) {
    const actions = [];
    while (slice.loadUint(1)) {
      const action = loadOutActionV5BetaExtended(slice);
      actions.push(action);
      slice = slice.loadRef().beginParse();
    }
    const commonAction = (0, core_1.loadOutList)(slice.loadRef().beginParse());
    if (commonAction.some((i) => i.type === "setCode")) {
      throw new Error("Can't deserialize actions list: only sendMsg actions are allowed for wallet v5");
    }
    return actions.concat(commonAction);
  }
  return WalletV5BetaActions;
}
var singer = {};
var hasRequiredSinger;
function requireSinger() {
  if (hasRequiredSinger) return singer;
  hasRequiredSinger = 1;
  Object.defineProperty(singer, "__esModule", { value: true });
  singer.signPayload = signPayload;
  const crypto_1 = requireDist$5();
  function signPayload(args, signingMessage, packMessage) {
    if ("secretKey" in args) {
      return packMessage((0, crypto_1.sign)(signingMessage.endCell().hash(), args.secretKey), signingMessage);
    } else {
      return args.signer(signingMessage.endCell()).then((signature) => packMessage(signature, signingMessage));
    }
  }
  return singer;
}
var WalletContractV5R1$1 = {};
var WalletV5R1WalletId = {};
var hasRequiredWalletV5R1WalletId;
function requireWalletV5R1WalletId() {
  if (hasRequiredWalletV5R1WalletId) return WalletV5R1WalletId;
  hasRequiredWalletV5R1WalletId = 1;
  Object.defineProperty(WalletV5R1WalletId, "__esModule", { value: true });
  WalletV5R1WalletId.isWalletIdV5R1ClientContext = isWalletIdV5R1ClientContext;
  WalletV5R1WalletId.loadWalletIdV5R1 = loadWalletIdV5R1;
  WalletV5R1WalletId.storeWalletIdV5R1 = storeWalletIdV5R1;
  const core_1 = requireDist$4();
  function isWalletIdV5R1ClientContext(context) {
    return typeof context !== "number";
  }
  const walletV5R1VersionsSerialisation = {
    v5r1: 0
  };
  function loadWalletIdV5R1(value, networkGlobalId) {
    const val = new core_1.BitReader(new core_1.BitString(typeof value === "bigint" ? Buffer.from(value.toString(16), "hex") : value instanceof core_1.Slice ? value.loadBuffer(4) : value, 0, 32)).loadInt(32);
    const context = BigInt(val) ^ BigInt(networkGlobalId);
    const bitReader = (0, core_1.beginCell)().storeInt(context, 32).endCell().beginParse();
    const isClientContext = bitReader.loadUint(1);
    if (isClientContext) {
      const workchain = bitReader.loadInt(8);
      const walletVersionRaw = bitReader.loadUint(8);
      const subwalletNumber = bitReader.loadUint(15);
      const walletVersion = Object.entries(walletV5R1VersionsSerialisation).find(([_, value2]) => value2 === walletVersionRaw)?.[0];
      if (walletVersion === void 0) {
        throw new Error(`Can't deserialize walletId: unknown wallet version ${walletVersionRaw}`);
      }
      return {
        networkGlobalId,
        context: {
          walletVersion,
          workchain,
          subwalletNumber
        }
      };
    } else {
      const context2 = bitReader.loadUint(31);
      return {
        networkGlobalId,
        context: context2
      };
    }
  }
  function storeWalletIdV5R1(walletId) {
    return (builder2) => {
      let context;
      if (isWalletIdV5R1ClientContext(walletId.context)) {
        context = (0, core_1.beginCell)().storeUint(1, 1).storeInt(walletId.context.workchain, 8).storeUint(walletV5R1VersionsSerialisation[walletId.context.walletVersion], 8).storeUint(walletId.context.subwalletNumber, 15).endCell().beginParse().loadInt(32);
      } else {
        context = (0, core_1.beginCell)().storeUint(0, 1).storeUint(walletId.context, 31).endCell().beginParse().loadInt(32);
      }
      return builder2.storeInt(BigInt(walletId.networkGlobalId) ^ BigInt(context), 32);
    };
  }
  return WalletV5R1WalletId;
}
var hasRequiredWalletContractV5R1$1;
function requireWalletContractV5R1$1() {
  if (hasRequiredWalletContractV5R1$1) return WalletContractV5R1$1;
  hasRequiredWalletContractV5R1$1 = 1;
  Object.defineProperty(WalletContractV5R1$1, "__esModule", { value: true });
  WalletContractV5R1$1.WalletContractV5R1 = void 0;
  const core_1 = requireDist$4();
  const createWalletTransfer_1 = requireCreateWalletTransfer();
  const WalletV5R1WalletId_1 = requireWalletV5R1WalletId();
  class WalletContractV5R12 {
    static create(args) {
      let workchain = 0;
      if ("workchain" in args && args.workchain != void 0) {
        workchain = args.workchain;
      }
      if (args.walletId?.context && (0, WalletV5R1WalletId_1.isWalletIdV5R1ClientContext)(args.walletId.context) && args.walletId.context.workchain != void 0) {
        workchain = args.walletId.context.workchain;
      }
      return new WalletContractV5R12(workchain, args.publicKey, {
        networkGlobalId: args.walletId?.networkGlobalId ?? -239,
        context: args.walletId?.context ?? {
          workchain: 0,
          walletVersion: "v5r1",
          subwalletNumber: 0
        }
      });
    }
    constructor(workchain, publicKey, walletId) {
      this.publicKey = publicKey;
      this.walletId = walletId;
      this.walletId = walletId;
      let code = core_1.Cell.fromBoc(Buffer.from("b5ee9c7241021401000281000114ff00f4a413f4bcf2c80b01020120020d020148030402dcd020d749c120915b8f6320d70b1f2082106578746ebd21821073696e74bdb0925f03e082106578746eba8eb48020d72101d074d721fa4030fa44f828fa443058bd915be0ed44d0810141d721f4058307f40e6fa1319130e18040d721707fdb3ce03120d749810280b99130e070e2100f020120050c020120060902016e07080019adce76a2684020eb90eb85ffc00019af1df6a2684010eb90eb858fc00201480a0b0017b325fb51341c75c875c2c7e00011b262fb513435c280200019be5f0f6a2684080a0eb90fa02c0102f20e011e20d70b1f82107369676ebaf2e08a7f0f01e68ef0eda2edfb218308d722028308d723208020d721d31fd31fd31fed44d0d200d31f20d31fd3ffd70a000af90140ccf9109a28945f0adb31e1f2c087df02b35007b0f2d0845125baf2e0855036baf2e086f823bbf2d0882292f800de01a47fc8ca00cb1f01cf16c9ed542092f80fde70db3cd81003f6eda2edfb02f404216e926c218e4c0221d73930709421c700b38e2d01d72820761e436c20d749c008f2e09320d74ac002f2e09320d71d06c712c2005230b0f2d089d74cd7393001a4e86c128407bbf2e093d74ac000f2e093ed55e2d20001c000915be0ebd72c08142091709601d72c081c12e25210b1e30f20d74a111213009601fa4001fa44f828fa443058baf2e091ed44d0810141d718f405049d7fc8ca0040048307f453f2e08b8e14038307f45bf2e08c22d70a00216e01b3b0f2d090e2c85003cf1612f400c9ed54007230d72c08248e2d21f2e092d200ed44d0d2005113baf2d08f54503091319c01810140d721d70a00f2e08ee2c8ca0058cf16c9ed5493f2c08de20010935bdb31e1d74cd0b4d6c35e", "hex"))[0];
      let data = (0, core_1.beginCell)().storeUint(1, 1).storeUint(0, 32).store((0, WalletV5R1WalletId_1.storeWalletIdV5R1)(this.walletId)).storeBuffer(this.publicKey, 32).storeBit(0).endCell();
      this.init = { code, data };
      this.address = (0, core_1.contractAddress)(workchain, { code, data });
    }
    /**
     * Get Wallet Balance
     */
    async getBalance(provider) {
      let state = await provider.getState();
      return state.balance;
    }
    /**
     * Get Wallet Seqno
     */
    async getSeqno(provider) {
      let state = await provider.getState();
      if (state.state.type === "active") {
        let res = await provider.get("seqno", []);
        return res.stack.readNumber();
      } else {
        return 0;
      }
    }
    /**
     * Get Wallet Extensions
     */
    async getExtensions(provider) {
      let state = await provider.getState();
      if (state.state.type === "active") {
        const result = await provider.get("get_extensions", []);
        return result.stack.readCellOpt();
      } else {
        return null;
      }
    }
    /**
     * Get Wallet Extensions
     */
    async getExtensionsArray(provider) {
      const extensions = await this.getExtensions(provider);
      if (!extensions) {
        return [];
      }
      const dict = core_1.Dictionary.loadDirect(core_1.Dictionary.Keys.BigUint(256), core_1.Dictionary.Values.BigInt(1), extensions);
      return dict.keys().map((addressHex) => {
        const wc = this.address.workChain;
        return core_1.Address.parseRaw(`${wc}:${addressHex.toString(16).padStart(64, "0")}`);
      });
    }
    /**
     * Get is secret-key authentication enabled
     */
    async getIsSecretKeyAuthEnabled(provider) {
      let res = await provider.get("is_signature_allowed", []);
      return res.stack.readBoolean();
    }
    /**
     * Send signed transfer
     */
    async send(provider, message) {
      await provider.external(message);
    }
    /**
     * Sign and send transfer
     */
    async sendTransfer(provider, args) {
      const transfer = await this.createTransfer(args);
      await this.send(provider, transfer);
    }
    /**
     * Sign and send add extension request
     */
    async sendAddExtension(provider, args) {
      const request = await this.createAddExtension(args);
      await this.send(provider, request);
    }
    /**
     * Sign and send remove extension request
     */
    async sendRemoveExtension(provider, args) {
      const request = await this.createRemoveExtension(args);
      await this.send(provider, request);
    }
    createActions(args) {
      const actions = args.messages.map((message) => ({ type: "sendMsg", mode: args.sendMode, outMsg: message }));
      return actions;
    }
    /**
     * Create signed transfer
     */
    createTransfer(args) {
      return this.createRequest({
        actions: this.createActions({ messages: args.messages, sendMode: args.sendMode }),
        ...args
      });
    }
    /**
     * Create signed add extension request
     */
    createAddExtension(args) {
      return this.createRequest({
        actions: [{
          type: "addExtension",
          address: args.extensionAddress
        }],
        ...args
      });
    }
    /**
     * Create signed remove extension request
     */
    createRemoveExtension(args) {
      return this.createRequest({
        actions: [{
          type: "removeExtension",
          address: args.extensionAddress
        }],
        ...args
      });
    }
    /**
     * Create signed request or extension auth request
     */
    createRequest(args) {
      if (args.authType === "extension") {
        return (0, createWalletTransfer_1.createWalletTransferV5R1)(args);
      }
      return (0, createWalletTransfer_1.createWalletTransferV5R1)({
        ...args,
        walletId: (0, WalletV5R1WalletId_1.storeWalletIdV5R1)(this.walletId)
      });
    }
    /**
     * Create sender
     */
    sender(provider, secretKey) {
      return {
        send: async (args) => {
          let seqno = await this.getSeqno(provider);
          let transfer = this.createTransfer({
            seqno,
            secretKey,
            sendMode: args.sendMode ?? core_1.SendMode.PAY_GAS_SEPARATELY + core_1.SendMode.IGNORE_ERRORS,
            messages: [(0, core_1.internal)({
              to: args.to,
              value: args.value,
              extracurrency: args.extracurrency,
              init: args.init,
              body: args.body,
              bounce: args.bounce
            })]
          });
          await this.send(provider, transfer);
        }
      };
    }
  }
  WalletContractV5R1$1.WalletContractV5R1 = WalletContractV5R12;
  WalletContractV5R12.OpCodes = {
    auth_extension: 1702392942,
    auth_signed_external: 1936287598,
    auth_signed_internal: 1936289396
  };
  return WalletContractV5R1$1;
}
var WalletV5R1Actions = {};
var hasRequiredWalletV5R1Actions;
function requireWalletV5R1Actions() {
  if (hasRequiredWalletV5R1Actions) return WalletV5R1Actions;
  hasRequiredWalletV5R1Actions = 1;
  Object.defineProperty(WalletV5R1Actions, "__esModule", { value: true });
  WalletV5R1Actions.storeOutActionExtendedV5R1 = storeOutActionExtendedV5R1;
  WalletV5R1Actions.loadOutActionExtendedV5R1 = loadOutActionExtendedV5R1;
  WalletV5R1Actions.storeOutListExtendedV5R1 = storeOutListExtendedV5R1;
  WalletV5R1Actions.loadOutListExtendedV5R1 = loadOutListExtendedV5R1;
  WalletV5R1Actions.toSafeV5R1SendMode = toSafeV5R1SendMode;
  WalletV5R1Actions.patchV5R1ActionsSendMode = patchV5R1ActionsSendMode;
  const core_1 = requireDist$4();
  const WalletV5OutActions_1 = requireWalletV5OutActions();
  const outActionSetIsPublicKeyEnabledTag = 4;
  function storeOutActionSetIsPublicKeyEnabled(action) {
    return (builder2) => {
      builder2.storeUint(outActionSetIsPublicKeyEnabledTag, 8).storeUint(action.isEnabled ? 1 : 0, 1);
    };
  }
  const outActionAddExtensionTag = 2;
  function storeOutActionAddExtension(action) {
    return (builder2) => {
      builder2.storeUint(outActionAddExtensionTag, 8).storeAddress(action.address);
    };
  }
  const outActionRemoveExtensionTag = 3;
  function storeOutActionRemoveExtension(action) {
    return (builder2) => {
      builder2.storeUint(outActionRemoveExtensionTag, 8).storeAddress(action.address);
    };
  }
  function storeOutActionExtendedV5R1(action) {
    switch (action.type) {
      case "setIsPublicKeyEnabled":
        return storeOutActionSetIsPublicKeyEnabled(action);
      case "addExtension":
        return storeOutActionAddExtension(action);
      case "removeExtension":
        return storeOutActionRemoveExtension(action);
      default:
        throw new Error("Unknown action type" + action?.type);
    }
  }
  function loadOutActionExtendedV5R1(slice) {
    const tag = slice.loadUint(8);
    switch (tag) {
      case outActionSetIsPublicKeyEnabledTag:
        return {
          type: "setIsPublicKeyEnabled",
          isEnabled: !!slice.loadUint(1)
        };
      case outActionAddExtensionTag:
        return {
          type: "addExtension",
          address: slice.loadAddress()
        };
      case outActionRemoveExtensionTag:
        return {
          type: "removeExtension",
          address: slice.loadAddress()
        };
      default:
        throw new Error(`Unknown extended out action tag 0x${tag.toString(16)}`);
    }
  }
  function storeOutListExtendedV5R1(actions) {
    const extendedActions = actions.filter(WalletV5OutActions_1.isOutActionExtended);
    const basicActions = actions.filter(WalletV5OutActions_1.isOutActionBasic);
    return (builder2) => {
      const outListPacked = basicActions.length ? (0, core_1.beginCell)().store((0, core_1.storeOutList)(basicActions.slice().reverse())) : null;
      builder2.storeMaybeRef(outListPacked);
      if (extendedActions.length === 0) {
        builder2.storeUint(0, 1);
      } else {
        const [first, ...rest] = extendedActions;
        builder2.storeUint(1, 1).store(storeOutActionExtendedV5R1(first));
        if (rest.length > 0) {
          builder2.storeRef(packExtendedActionsRec(rest));
        }
      }
    };
  }
  function packExtendedActionsRec(extendedActions) {
    const [first, ...rest] = extendedActions;
    let builder2 = (0, core_1.beginCell)().store(storeOutActionExtendedV5R1(first));
    if (rest.length > 0) {
      builder2 = builder2.storeRef(packExtendedActionsRec(rest));
    }
    return builder2.endCell();
  }
  function loadOutListExtendedV5R1(slice) {
    const actions = [];
    const outListPacked = slice.loadMaybeRef();
    if (outListPacked) {
      const loadedActions = (0, core_1.loadOutList)(outListPacked.beginParse());
      if (loadedActions.some((a2) => a2.type !== "sendMsg")) {
        throw new Error("Can't deserialize actions list: only sendMsg actions are allowed for wallet v5r1");
      }
      actions.push(...loadedActions);
    }
    if (slice.loadBoolean()) {
      const action = loadOutActionExtendedV5R1(slice);
      actions.push(action);
    }
    while (slice.remainingRefs > 0) {
      slice = slice.loadRef().beginParse();
      const action = loadOutActionExtendedV5R1(slice);
      actions.push(action);
    }
    return actions;
  }
  function toSafeV5R1SendMode(sendMode, authType) {
    if (authType === "internal" || authType === "extension") {
      return sendMode;
    }
    return sendMode | core_1.SendMode.IGNORE_ERRORS;
  }
  function patchV5R1ActionsSendMode(actions, authType) {
    return actions.map((action) => action.type === "sendMsg" ? {
      ...action,
      mode: toSafeV5R1SendMode(action.mode, authType)
    } : action);
  }
  return WalletV5R1Actions;
}
var hasRequiredCreateWalletTransfer;
function requireCreateWalletTransfer() {
  if (hasRequiredCreateWalletTransfer) return createWalletTransfer;
  hasRequiredCreateWalletTransfer = 1;
  Object.defineProperty(createWalletTransfer, "__esModule", { value: true });
  createWalletTransfer.createWalletTransferV1 = createWalletTransferV1;
  createWalletTransfer.createWalletTransferV2 = createWalletTransferV2;
  createWalletTransfer.createWalletTransferV3 = createWalletTransferV3;
  createWalletTransfer.createWalletTransferV4 = createWalletTransferV4;
  createWalletTransfer.createWalletTransferV5Beta = createWalletTransferV5Beta;
  createWalletTransfer.createWalletTransferV5R1 = createWalletTransferV5R1;
  const core_1 = requireDist$4();
  const crypto_1 = requireDist$5();
  const WalletContractV5Beta_1 = requireWalletContractV5Beta$1();
  const WalletV5BetaActions_1 = requireWalletV5BetaActions();
  const singer_1 = requireSinger();
  const WalletContractV5R1_1 = requireWalletContractV5R1$1();
  const WalletV5R1Actions_1 = requireWalletV5R1Actions();
  function packSignatureToFront(signature, signingMessage) {
    const body = (0, core_1.beginCell)().storeBuffer(signature).storeBuilder(signingMessage).endCell();
    return body;
  }
  function packSignatureToTail(signature, signingMessage) {
    const body = (0, core_1.beginCell)().storeBuilder(signingMessage).storeBuffer(signature).endCell();
    return body;
  }
  function createWalletTransferV1(args) {
    let signingMessage = (0, core_1.beginCell)().storeUint(args.seqno, 32);
    if (args.message) {
      signingMessage.storeUint(args.sendMode, 8);
      signingMessage.storeRef((0, core_1.beginCell)().store((0, core_1.storeMessageRelaxed)(args.message)));
    }
    let signature = (0, crypto_1.sign)(signingMessage.endCell().hash(), args.secretKey);
    const body = (0, core_1.beginCell)().storeBuffer(signature).storeBuilder(signingMessage).endCell();
    return body;
  }
  function createWalletTransferV2(args) {
    if (args.messages.length > 4) {
      throw Error("Maximum number of messages in a single transfer is 4");
    }
    let signingMessage = (0, core_1.beginCell)().storeUint(args.seqno, 32);
    if (args.seqno === 0) {
      for (let i = 0; i < 32; i++) {
        signingMessage.storeBit(1);
      }
    } else {
      signingMessage.storeUint(args.timeout || Math.floor(Date.now() / 1e3) + 60, 32);
    }
    for (let m2 of args.messages) {
      signingMessage.storeUint(args.sendMode, 8);
      signingMessage.storeRef((0, core_1.beginCell)().store((0, core_1.storeMessageRelaxed)(m2)));
    }
    let signature = (0, crypto_1.sign)(signingMessage.endCell().hash(), args.secretKey);
    const body = (0, core_1.beginCell)().storeBuffer(signature).storeBuilder(signingMessage).endCell();
    return body;
  }
  function createWalletTransferV3(args) {
    if (args.messages.length > 4) {
      throw Error("Maximum number of messages in a single transfer is 4");
    }
    let signingMessage = (0, core_1.beginCell)().storeUint(args.walletId, 32);
    if (args.seqno === 0) {
      for (let i = 0; i < 32; i++) {
        signingMessage.storeBit(1);
      }
    } else {
      signingMessage.storeUint(args.timeout || Math.floor(Date.now() / 1e3) + 60, 32);
    }
    signingMessage.storeUint(args.seqno, 32);
    for (let m2 of args.messages) {
      signingMessage.storeUint(args.sendMode, 8);
      signingMessage.storeRef((0, core_1.beginCell)().store((0, core_1.storeMessageRelaxed)(m2)));
    }
    return (0, singer_1.signPayload)(args, signingMessage, packSignatureToFront);
  }
  function createWalletTransferV4(args) {
    if (args.messages.length > 4) {
      throw Error("Maximum number of messages in a single transfer is 4");
    }
    let signingMessage = (0, core_1.beginCell)().storeUint(args.walletId, 32);
    if (args.seqno === 0) {
      for (let i = 0; i < 32; i++) {
        signingMessage.storeBit(1);
      }
    } else {
      signingMessage.storeUint(args.timeout || Math.floor(Date.now() / 1e3) + 60, 32);
    }
    signingMessage.storeUint(args.seqno, 32);
    signingMessage.storeUint(0, 8);
    for (let m2 of args.messages) {
      signingMessage.storeUint(args.sendMode, 8);
      signingMessage.storeRef((0, core_1.beginCell)().store((0, core_1.storeMessageRelaxed)(m2)));
    }
    return (0, singer_1.signPayload)(args, signingMessage, packSignatureToFront);
  }
  function createWalletTransferV5Beta(args) {
    if (args.actions.length > 255) {
      throw Error("Maximum number of OutActions in a single request is 255");
    }
    if (args.authType === "extension") {
      return (0, core_1.beginCell)().storeUint(WalletContractV5Beta_1.WalletContractV5Beta.OpCodes.auth_extension, 32).store((0, WalletV5BetaActions_1.storeOutListExtendedV5Beta)(args.actions)).endCell();
    }
    const signingMessage = (0, core_1.beginCell)().storeUint(args.authType === "internal" ? WalletContractV5Beta_1.WalletContractV5Beta.OpCodes.auth_signed_internal : WalletContractV5Beta_1.WalletContractV5Beta.OpCodes.auth_signed_external, 32).store(args.walletId);
    if (args.seqno === 0) {
      for (let i = 0; i < 32; i++) {
        signingMessage.storeBit(1);
      }
    } else {
      signingMessage.storeUint(args.timeout || Math.floor(Date.now() / 1e3) + 60, 32);
    }
    signingMessage.storeUint(args.seqno, 32).store((0, WalletV5BetaActions_1.storeOutListExtendedV5Beta)(args.actions));
    return (0, singer_1.signPayload)(args, signingMessage, packSignatureToTail);
  }
  function createWalletTransferV5R1(args) {
    if (args.actions.length > 255) {
      throw Error("Maximum number of OutActions in a single request is 255");
    }
    args = { ...args };
    if (args.authType === "extension") {
      return (0, core_1.beginCell)().storeUint(WalletContractV5R1_1.WalletContractV5R1.OpCodes.auth_extension, 32).storeUint(args.queryId ?? 0, 64).store((0, WalletV5R1Actions_1.storeOutListExtendedV5R1)(args.actions)).endCell();
    }
    args.actions = (0, WalletV5R1Actions_1.patchV5R1ActionsSendMode)(args.actions, args.authType);
    const signingMessage = (0, core_1.beginCell)().storeUint(args.authType === "internal" ? WalletContractV5R1_1.WalletContractV5R1.OpCodes.auth_signed_internal : WalletContractV5R1_1.WalletContractV5R1.OpCodes.auth_signed_external, 32).store(args.walletId);
    if (args.seqno === 0) {
      for (let i = 0; i < 32; i++) {
        signingMessage.storeBit(1);
      }
    } else {
      signingMessage.storeUint(args.timeout || Math.floor(Date.now() / 1e3) + 60, 32);
    }
    signingMessage.storeUint(args.seqno, 32).store((0, WalletV5R1Actions_1.storeOutListExtendedV5R1)(args.actions));
    return (0, singer_1.signPayload)(args, signingMessage, packSignatureToTail);
  }
  return createWalletTransfer;
}
var hasRequiredWalletContractV1R1;
function requireWalletContractV1R1() {
  if (hasRequiredWalletContractV1R1) return WalletContractV1R1;
  hasRequiredWalletContractV1R1 = 1;
  Object.defineProperty(WalletContractV1R1, "__esModule", { value: true });
  WalletContractV1R1.WalletContractV1R1 = void 0;
  const core_1 = requireDist$4();
  const createWalletTransfer_1 = requireCreateWalletTransfer();
  let WalletContractV1R1$1 = class WalletContractV1R12 {
    static create(args) {
      return new WalletContractV1R12(args.workchain, args.publicKey);
    }
    constructor(workchain, publicKey) {
      this.workchain = workchain;
      this.publicKey = publicKey;
      let code = core_1.Cell.fromBoc(Buffer.from("te6cckEBAQEARAAAhP8AIN2k8mCBAgDXGCDXCx/tRNDTH9P/0VESuvKhIvkBVBBE+RDyovgAAdMfMSDXSpbTB9QC+wDe0aTIyx/L/8ntVEH98Ik=", "base64"))[0];
      let data = (0, core_1.beginCell)().storeUint(0, 32).storeBuffer(publicKey).endCell();
      this.init = { code, data };
      this.address = (0, core_1.contractAddress)(workchain, { code, data });
    }
    /**
     * Get Wallet Balance
     */
    async getBalance(provider) {
      let state = await provider.getState();
      return state.balance;
    }
    /**
     * Get Wallet Seqno
     */
    async getSeqno(provider) {
      let state = await provider.getState();
      if (state.state.type === "active") {
        return core_1.Cell.fromBoc(state.state.data)[0].beginParse().loadUint(32);
      } else {
        return 0;
      }
    }
    /**
     * Send signed transfer
     */
    async send(provider, message) {
      await provider.external(message);
    }
    /**
     * Sign and send transfer
     */
    async sendTransfer(provider, args) {
      let transfer = this.createTransfer(args);
      await this.send(provider, transfer);
    }
    /**
     * Create signed transfer
     */
    createTransfer(args) {
      let sendMode = core_1.SendMode.PAY_GAS_SEPARATELY;
      if (args.sendMode !== null && args.sendMode !== void 0) {
        sendMode = args.sendMode;
      }
      return (0, createWalletTransfer_1.createWalletTransferV1)({
        seqno: args.seqno,
        sendMode,
        secretKey: args.secretKey,
        message: args.message
      });
    }
    /**
     * Create sender
     */
    sender(provider, secretKey) {
      return {
        send: async (args) => {
          let seqno = await this.getSeqno(provider);
          let transfer = this.createTransfer({
            seqno,
            secretKey,
            sendMode: args.sendMode,
            message: (0, core_1.internal)({
              to: args.to,
              value: args.value,
              extracurrency: args.extracurrency,
              init: args.init,
              body: args.body,
              bounce: args.bounce
            })
          });
          await this.send(provider, transfer);
        }
      };
    }
  };
  WalletContractV1R1.WalletContractV1R1 = WalletContractV1R1$1;
  return WalletContractV1R1;
}
var WalletContractV1R2 = {};
var hasRequiredWalletContractV1R2;
function requireWalletContractV1R2() {
  if (hasRequiredWalletContractV1R2) return WalletContractV1R2;
  hasRequiredWalletContractV1R2 = 1;
  Object.defineProperty(WalletContractV1R2, "__esModule", { value: true });
  WalletContractV1R2.WalletContractV1R2 = void 0;
  const core_1 = requireDist$4();
  const createWalletTransfer_1 = requireCreateWalletTransfer();
  let WalletContractV1R2$1 = class WalletContractV1R22 {
    static create(args) {
      return new WalletContractV1R22(args.workchain, args.publicKey);
    }
    constructor(workchain, publicKey) {
      this.workchain = workchain;
      this.publicKey = publicKey;
      let code = core_1.Cell.fromBoc(Buffer.from("te6cckEBAQEAUwAAov8AIN0gggFMl7qXMO1E0NcLH+Ck8mCBAgDXGCDXCx/tRNDTH9P/0VESuvKhIvkBVBBE+RDyovgAAdMfMSDXSpbTB9QC+wDe0aTIyx/L/8ntVNDieG8=", "base64"))[0];
      let data = (0, core_1.beginCell)().storeUint(0, 32).storeBuffer(publicKey).endCell();
      this.init = { code, data };
      this.address = (0, core_1.contractAddress)(workchain, { code, data });
    }
    /**
     * Get Wallet Balance
     */
    async getBalance(provider) {
      let state = await provider.getState();
      return state.balance;
    }
    /**
     * Get Wallet Seqno
     */
    async getSeqno(provider) {
      let state = await provider.getState();
      if (state.state.type === "active") {
        let res = await provider.get("seqno", []);
        return res.stack.readNumber();
      } else {
        return 0;
      }
    }
    /**
     * Send signed transfer
     */
    async send(provider, message) {
      await provider.external(message);
    }
    /**
     * Sign and send transfer
     */
    async sendTransfer(provider, args) {
      let transfer = this.createTransfer(args);
      await this.send(provider, transfer);
    }
    /**
     * Create signed transfer
     */
    createTransfer(args) {
      let sendMode = core_1.SendMode.PAY_GAS_SEPARATELY;
      if (args.sendMode !== null && args.sendMode !== void 0) {
        sendMode = args.sendMode;
      }
      return (0, createWalletTransfer_1.createWalletTransferV1)({
        seqno: args.seqno,
        sendMode,
        secretKey: args.secretKey,
        message: args.message
      });
    }
    /**
     * Create sender
     */
    sender(provider, secretKey) {
      return {
        send: async (args) => {
          let seqno = await this.getSeqno(provider);
          let transfer = this.createTransfer({
            seqno,
            secretKey,
            sendMode: args.sendMode,
            message: (0, core_1.internal)({
              to: args.to,
              value: args.value,
              extracurrency: args.extracurrency,
              init: args.init,
              body: args.body,
              bounce: args.bounce
            })
          });
          await this.send(provider, transfer);
        }
      };
    }
  };
  WalletContractV1R2.WalletContractV1R2 = WalletContractV1R2$1;
  return WalletContractV1R2;
}
var WalletContractV1R3 = {};
var hasRequiredWalletContractV1R3;
function requireWalletContractV1R3() {
  if (hasRequiredWalletContractV1R3) return WalletContractV1R3;
  hasRequiredWalletContractV1R3 = 1;
  Object.defineProperty(WalletContractV1R3, "__esModule", { value: true });
  WalletContractV1R3.WalletContractV1R3 = void 0;
  const core_1 = requireDist$4();
  const createWalletTransfer_1 = requireCreateWalletTransfer();
  let WalletContractV1R3$1 = class WalletContractV1R32 {
    static create(args) {
      return new WalletContractV1R32(args.workchain, args.publicKey);
    }
    constructor(workchain, publicKey) {
      this.workchain = workchain;
      this.publicKey = publicKey;
      let code = core_1.Cell.fromBoc(Buffer.from("te6cckEBAQEAXwAAuv8AIN0gggFMl7ohggEznLqxnHGw7UTQ0x/XC//jBOCk8mCBAgDXGCDXCx/tRNDTH9P/0VESuvKhIvkBVBBE+RDyovgAAdMfMSDXSpbTB9QC+wDe0aTIyx/L/8ntVLW4bkI=", "base64"))[0];
      let data = (0, core_1.beginCell)().storeUint(0, 32).storeBuffer(publicKey).endCell();
      this.init = { code, data };
      this.address = (0, core_1.contractAddress)(workchain, { code, data });
    }
    /**
     * Get Wallet Balance
     */
    async getBalance(provider) {
      let state = await provider.getState();
      return state.balance;
    }
    /**
     * Get Wallet Seqno
     */
    async getSeqno(provider) {
      let state = await provider.getState();
      if (state.state.type === "active") {
        let res = await provider.get("seqno", []);
        return res.stack.readNumber();
      } else {
        return 0;
      }
    }
    /**
     * Send signed transfer
     */
    async send(executor, message) {
      await executor.external(message);
    }
    /**
     * Sign and send transfer
     */
    async sendTransfer(provider, args) {
      let transfer = this.createTransfer(args);
      await this.send(provider, transfer);
    }
    /**
     * Create signed transfer
     */
    createTransfer(args) {
      let sendMode = core_1.SendMode.PAY_GAS_SEPARATELY;
      if (args.sendMode !== null && args.sendMode !== void 0) {
        sendMode = args.sendMode;
      }
      return (0, createWalletTransfer_1.createWalletTransferV1)({
        seqno: args.seqno,
        sendMode,
        secretKey: args.secretKey,
        message: args.message
      });
    }
    /**
     * Create sender
     */
    sender(provider, secretKey) {
      return {
        send: async (args) => {
          let seqno = await this.getSeqno(provider);
          let transfer = this.createTransfer({
            seqno,
            secretKey,
            sendMode: args.sendMode,
            message: (0, core_1.internal)({
              to: args.to,
              value: args.value,
              init: args.init,
              body: args.body,
              bounce: args.bounce
            })
          });
          await this.send(provider, transfer);
        }
      };
    }
  };
  WalletContractV1R3.WalletContractV1R3 = WalletContractV1R3$1;
  return WalletContractV1R3;
}
var WalletContractV2R1 = {};
var hasRequiredWalletContractV2R1;
function requireWalletContractV2R1() {
  if (hasRequiredWalletContractV2R1) return WalletContractV2R1;
  hasRequiredWalletContractV2R1 = 1;
  Object.defineProperty(WalletContractV2R1, "__esModule", { value: true });
  WalletContractV2R1.WalletContractV2R1 = void 0;
  const core_1 = requireDist$4();
  const createWalletTransfer_1 = requireCreateWalletTransfer();
  let WalletContractV2R1$1 = class WalletContractV2R12 {
    static create(args) {
      return new WalletContractV2R12(args.workchain, args.publicKey);
    }
    constructor(workchain, publicKey) {
      this.workchain = workchain;
      this.publicKey = publicKey;
      let code = core_1.Cell.fromBoc(Buffer.from("te6cckEBAQEAVwAAqv8AIN0gggFMl7qXMO1E0NcLH+Ck8mCDCNcYINMf0x8B+CO78mPtRNDTH9P/0VExuvKhA/kBVBBC+RDyovgAApMg10qW0wfUAvsA6NGkyMsfy//J7VShNwu2", "base64"))[0];
      let data = (0, core_1.beginCell)().storeUint(0, 32).storeBuffer(publicKey).endCell();
      this.init = { code, data };
      this.address = (0, core_1.contractAddress)(workchain, { code, data });
    }
    /**
     * Get Wallet Balance
     */
    async getBalance(provider) {
      let state = await provider.getState();
      return state.balance;
    }
    /**
     * Get Wallet Seqno
     */
    async getSeqno(provider) {
      let state = await provider.getState();
      if (state.state.type === "active") {
        let res = await provider.get("seqno", []);
        return res.stack.readNumber();
      } else {
        return 0;
      }
    }
    /**
     * Send signed transfer
     */
    async send(provider, message) {
      await provider.external(message);
    }
    /**
     * Sign and send transfer
     */
    async sendTransfer(provider, args) {
      let transfer = this.createTransfer(args);
      await this.send(provider, transfer);
    }
    /**
     * Create signed transfer
     */
    createTransfer(args) {
      let sendMode = core_1.SendMode.PAY_GAS_SEPARATELY;
      if (args.sendMode !== null && args.sendMode !== void 0) {
        sendMode = args.sendMode;
      }
      return (0, createWalletTransfer_1.createWalletTransferV2)({
        seqno: args.seqno,
        sendMode,
        secretKey: args.secretKey,
        messages: args.messages,
        timeout: args.timeout
      });
    }
    /**
     * Create sender
     */
    sender(provider, secretKey) {
      return {
        send: async (args) => {
          let seqno = await this.getSeqno(provider);
          let transfer = this.createTransfer({
            seqno,
            secretKey,
            sendMode: args.sendMode,
            messages: [(0, core_1.internal)({
              to: args.to,
              value: args.value,
              extracurrency: args.extracurrency,
              init: args.init,
              body: args.body,
              bounce: args.bounce
            })]
          });
          await this.send(provider, transfer);
        }
      };
    }
  };
  WalletContractV2R1.WalletContractV2R1 = WalletContractV2R1$1;
  return WalletContractV2R1;
}
var WalletContractV2R2 = {};
var hasRequiredWalletContractV2R2;
function requireWalletContractV2R2() {
  if (hasRequiredWalletContractV2R2) return WalletContractV2R2;
  hasRequiredWalletContractV2R2 = 1;
  Object.defineProperty(WalletContractV2R2, "__esModule", { value: true });
  WalletContractV2R2.WalletContractV2R2 = void 0;
  const core_1 = requireDist$4();
  const createWalletTransfer_1 = requireCreateWalletTransfer();
  let WalletContractV2R2$1 = class WalletContractV2R22 {
    static create(args) {
      return new WalletContractV2R22(args.workchain, args.publicKey);
    }
    constructor(workchain, publicKey) {
      this.workchain = workchain;
      this.publicKey = publicKey;
      let code = core_1.Cell.fromBoc(Buffer.from("te6cckEBAQEAYwAAwv8AIN0gggFMl7ohggEznLqxnHGw7UTQ0x/XC//jBOCk8mCDCNcYINMf0x8B+CO78mPtRNDTH9P/0VExuvKhA/kBVBBC+RDyovgAApMg10qW0wfUAvsA6NGkyMsfy//J7VQETNeh", "base64"))[0];
      let data = (0, core_1.beginCell)().storeUint(0, 32).storeBuffer(publicKey).endCell();
      this.init = { code, data };
      this.address = (0, core_1.contractAddress)(workchain, { code, data });
    }
    /**
     * Get Wallet Balance
     */
    async getBalance(provider) {
      let state = await provider.getState();
      return state.balance;
    }
    /**
     * Get Wallet Seqno
     */
    async getSeqno(provider) {
      let state = await provider.getState();
      if (state.state.type === "active") {
        let res = await provider.get("seqno", []);
        return res.stack.readNumber();
      } else {
        return 0;
      }
    }
    /**
     * Send signed transfer
     */
    async send(provider, message) {
      await provider.external(message);
    }
    /**
     * Sign and send transfer
     */
    async sendTransfer(provider, args) {
      let transfer = this.createTransfer(args);
      await this.send(provider, transfer);
    }
    /**
     * Create signed transfer
     */
    createTransfer(args) {
      let sendMode = core_1.SendMode.PAY_GAS_SEPARATELY;
      if (args.sendMode !== null && args.sendMode !== void 0) {
        sendMode = args.sendMode;
      }
      return (0, createWalletTransfer_1.createWalletTransferV2)({
        seqno: args.seqno,
        sendMode,
        secretKey: args.secretKey,
        messages: args.messages,
        timeout: args.timeout
      });
    }
    /**
     * Create sender
     */
    sender(provider, secretKey) {
      return {
        send: async (args) => {
          let seqno = await this.getSeqno(provider);
          let transfer = this.createTransfer({
            seqno,
            secretKey,
            sendMode: args.sendMode,
            messages: [(0, core_1.internal)({
              to: args.to,
              value: args.value,
              extracurrency: args.extracurrency,
              init: args.init,
              body: args.body,
              bounce: args.bounce
            })]
          });
          await this.send(provider, transfer);
        }
      };
    }
  };
  WalletContractV2R2.WalletContractV2R2 = WalletContractV2R2$1;
  return WalletContractV2R2;
}
var WalletContractV3R1 = {};
var hasRequiredWalletContractV3R1;
function requireWalletContractV3R1() {
  if (hasRequiredWalletContractV3R1) return WalletContractV3R1;
  hasRequiredWalletContractV3R1 = 1;
  Object.defineProperty(WalletContractV3R1, "__esModule", { value: true });
  WalletContractV3R1.WalletContractV3R1 = void 0;
  const core_1 = requireDist$4();
  const createWalletTransfer_1 = requireCreateWalletTransfer();
  let WalletContractV3R1$1 = class WalletContractV3R12 {
    static create(args) {
      return new WalletContractV3R12(args.workchain, args.publicKey, args.walletId);
    }
    constructor(workchain, publicKey, walletId) {
      this.workchain = workchain;
      this.publicKey = publicKey;
      if (walletId !== null && walletId !== void 0) {
        this.walletId = walletId;
      } else {
        this.walletId = 698983191 + workchain;
      }
      let code = core_1.Cell.fromBoc(Buffer.from("te6cckEBAQEAYgAAwP8AIN0gggFMl7qXMO1E0NcLH+Ck8mCDCNcYINMf0x/TH/gjE7vyY+1E0NMf0x/T/9FRMrryoVFEuvKiBPkBVBBV+RDyo/gAkyDXSpbTB9QC+wDo0QGkyMsfyx/L/8ntVD++buA=", "base64"))[0];
      let data = (0, core_1.beginCell)().storeUint(0, 32).storeUint(this.walletId, 32).storeBuffer(publicKey).endCell();
      this.init = { code, data };
      this.address = (0, core_1.contractAddress)(workchain, { code, data });
    }
    /**
     * Get wallet balance
     */
    async getBalance(provider) {
      let state = await provider.getState();
      return state.balance;
    }
    /**
     * Get Wallet Seqno
     */
    async getSeqno(provider) {
      let state = await provider.getState();
      if (state.state.type === "active") {
        let res = await provider.get("seqno", []);
        return res.stack.readNumber();
      } else {
        return 0;
      }
    }
    /**
     * Send signed transfer
     */
    async send(provider, message) {
      await provider.external(message);
    }
    /**
     * Sign and send transfer
     */
    async sendTransfer(provider, args) {
      let transfer = this.createTransfer(args);
      await this.send(provider, transfer);
    }
    /**
     * Create transfer
     */
    createTransfer(args) {
      return (0, createWalletTransfer_1.createWalletTransferV3)({
        ...args,
        sendMode: args.sendMode ?? core_1.SendMode.PAY_GAS_SEPARATELY,
        walletId: this.walletId
      });
    }
    /**
     * Create sender
     */
    sender(provider, secretKey) {
      return {
        send: async (args) => {
          let seqno = await this.getSeqno(provider);
          let transfer = this.createTransfer({
            seqno,
            secretKey,
            sendMode: args.sendMode,
            messages: [(0, core_1.internal)({
              to: args.to,
              value: args.value,
              extracurrency: args.extracurrency,
              init: args.init,
              body: args.body,
              bounce: args.bounce
            })]
          });
          await this.send(provider, transfer);
        }
      };
    }
  };
  WalletContractV3R1.WalletContractV3R1 = WalletContractV3R1$1;
  return WalletContractV3R1;
}
var WalletContractV3R2 = {};
var hasRequiredWalletContractV3R2;
function requireWalletContractV3R2() {
  if (hasRequiredWalletContractV3R2) return WalletContractV3R2;
  hasRequiredWalletContractV3R2 = 1;
  Object.defineProperty(WalletContractV3R2, "__esModule", { value: true });
  WalletContractV3R2.WalletContractV3R2 = void 0;
  const core_1 = requireDist$4();
  const createWalletTransfer_1 = requireCreateWalletTransfer();
  let WalletContractV3R2$1 = class WalletContractV3R22 {
    static create(args) {
      return new WalletContractV3R22(args.workchain, args.publicKey, args.walletId);
    }
    constructor(workchain, publicKey, walletId) {
      this.workchain = workchain;
      this.publicKey = publicKey;
      if (walletId !== null && walletId !== void 0) {
        this.walletId = walletId;
      } else {
        this.walletId = 698983191 + workchain;
      }
      let code = core_1.Cell.fromBoc(Buffer.from("te6cckEBAQEAcQAA3v8AIN0gggFMl7ohggEznLqxn3Gw7UTQ0x/THzHXC//jBOCk8mCDCNcYINMf0x/TH/gjE7vyY+1E0NMf0x/T/9FRMrryoVFEuvKiBPkBVBBV+RDyo/gAkyDXSpbTB9QC+wDo0QGkyMsfyx/L/8ntVBC9ba0=", "base64"))[0];
      let data = (0, core_1.beginCell)().storeUint(0, 32).storeUint(this.walletId, 32).storeBuffer(publicKey).endCell();
      this.init = { code, data };
      this.address = (0, core_1.contractAddress)(workchain, { code, data });
    }
    /**
     * Get wallet balance
     */
    async getBalance(provider) {
      let state = await provider.getState();
      return state.balance;
    }
    /**
     * Get Wallet Seqno
     */
    async getSeqno(provider) {
      let state = await provider.getState();
      if (state.state.type === "active") {
        let res = await provider.get("seqno", []);
        return res.stack.readNumber();
      } else {
        return 0;
      }
    }
    /**
     * Send signed transfer
     */
    async send(provider, message) {
      await provider.external(message);
    }
    /**
     * Sign and send transfer
     */
    async sendTransfer(provider, args) {
      let transfer = this.createTransfer(args);
      await this.send(provider, transfer);
    }
    /**
     * Create transfer
     */
    createTransfer(args) {
      return (0, createWalletTransfer_1.createWalletTransferV3)({
        ...args,
        sendMode: args.sendMode ?? core_1.SendMode.PAY_GAS_SEPARATELY,
        walletId: this.walletId
      });
    }
    /**
     * Create sender
     */
    sender(provider, secretKey) {
      return {
        send: async (args) => {
          let seqno = await this.getSeqno(provider);
          let transfer = this.createTransfer({
            seqno,
            secretKey,
            sendMode: args.sendMode,
            messages: [(0, core_1.internal)({
              to: args.to,
              value: args.value,
              extracurrency: args.extracurrency,
              init: args.init,
              body: args.body,
              bounce: args.bounce
            })]
          });
          await this.send(provider, transfer);
        }
      };
    }
  };
  WalletContractV3R2.WalletContractV3R2 = WalletContractV3R2$1;
  return WalletContractV3R2;
}
var WalletContractV4 = {};
var hasRequiredWalletContractV4;
function requireWalletContractV4() {
  if (hasRequiredWalletContractV4) return WalletContractV4;
  hasRequiredWalletContractV4 = 1;
  Object.defineProperty(WalletContractV4, "__esModule", { value: true });
  WalletContractV4.WalletContractV4 = void 0;
  const core_1 = requireDist$4();
  const createWalletTransfer_1 = requireCreateWalletTransfer();
  let WalletContractV4$1 = class WalletContractV42 {
    static create(args) {
      return new WalletContractV42(args.workchain, args.publicKey, args.walletId);
    }
    constructor(workchain, publicKey, walletId) {
      this.workchain = workchain;
      this.publicKey = publicKey;
      if (walletId !== null && walletId !== void 0) {
        this.walletId = walletId;
      } else {
        this.walletId = 698983191 + workchain;
      }
      let code = core_1.Cell.fromBoc(Buffer.from("te6ccgECFAEAAtQAART/APSkE/S88sgLAQIBIAIDAgFIBAUE+PKDCNcYINMf0x/THwL4I7vyZO1E0NMf0x/T//QE0VFDuvKhUVG68qIF+QFUEGT5EPKj+AAkpMjLH1JAyx9SMMv/UhD0AMntVPgPAdMHIcAAn2xRkyDXSpbTB9QC+wDoMOAhwAHjACHAAuMAAcADkTDjDQOkyMsfEssfy/8QERITAubQAdDTAyFxsJJfBOAi10nBIJJfBOAC0x8hghBwbHVnvSKCEGRzdHK9sJJfBeAD+kAwIPpEAcjKB8v/ydDtRNCBAUDXIfQEMFyBAQj0Cm+hMbOSXwfgBdM/yCWCEHBsdWe6kjgw4w0DghBkc3RyupJfBuMNBgcCASAICQB4AfoA9AQw+CdvIjBQCqEhvvLgUIIQcGx1Z4MesXCAGFAEywUmzxZY+gIZ9ADLaRfLH1Jgyz8gyYBA+wAGAIpQBIEBCPRZMO1E0IEBQNcgyAHPFvQAye1UAXKwjiOCEGRzdHKDHrFwgBhQBcsFUAPPFiP6AhPLassfyz/JgED7AJJfA+ICASAKCwBZvSQrb2omhAgKBrkPoCGEcNQICEekk30pkQzmkD6f+YN4EoAbeBAUiYcVnzGEAgFYDA0AEbjJftRNDXCx+AA9sp37UTQgQFA1yH0BDACyMoHy//J0AGBAQj0Cm+hMYAIBIA4PABmtznaiaEAga5Drhf/AABmvHfaiaEAQa5DrhY/AAG7SB/oA1NQi+QAFyMoHFcv/ydB3dIAYyMsFywIizxZQBfoCFMtrEszMyXP7AMhAFIEBCPRR8qcCAHCBAQjXGPoA0z/IVCBHgQEI9FHyp4IQbm90ZXB0gBjIywXLAlAGzxZQBPoCFMtqEssfyz/Jc/sAAgBsgQEI1xj6ANM/MFIkgQEI9Fnyp4IQZHN0cnB0gBjIywXLAlAFzxZQA/oCE8tqyx8Syz/Jc/sAAAr0AMntVA==", "base64"))[0];
      let data = (0, core_1.beginCell)().storeUint(0, 32).storeUint(this.walletId, 32).storeBuffer(this.publicKey).storeBit(0).endCell();
      this.init = { code, data };
      this.address = (0, core_1.contractAddress)(workchain, { code, data });
    }
    /**
     * Get Wallet Balance
     */
    async getBalance(provider) {
      let state = await provider.getState();
      return state.balance;
    }
    /**
     * Get Wallet Seqno
     */
    async getSeqno(provider) {
      let state = await provider.getState();
      if (state.state.type === "active") {
        let res = await provider.get("seqno", []);
        return res.stack.readNumber();
      } else {
        return 0;
      }
    }
    /**
     * Send signed transfer
     */
    async send(provider, message) {
      await provider.external(message);
    }
    /**
     * Sign and send transfer
     */
    async sendTransfer(provider, args) {
      let transfer = this.createTransfer(args);
      await this.send(provider, transfer);
    }
    /**
     * Create signed transfer
     */
    createTransfer(args) {
      return (0, createWalletTransfer_1.createWalletTransferV4)({
        ...args,
        sendMode: args.sendMode ?? core_1.SendMode.PAY_GAS_SEPARATELY,
        walletId: this.walletId
      });
    }
    /**
     * Create sender
     */
    sender(provider, secretKey) {
      return {
        send: async (args) => {
          let seqno = await this.getSeqno(provider);
          let transfer = this.createTransfer({
            seqno,
            secretKey,
            sendMode: args.sendMode,
            messages: [(0, core_1.internal)({
              to: args.to,
              value: args.value,
              extracurrency: args.extracurrency,
              init: args.init,
              body: args.body,
              bounce: args.bounce
            })]
          });
          await this.send(provider, transfer);
        }
      };
    }
  };
  WalletContractV4.WalletContractV4 = WalletContractV4$1;
  return WalletContractV4;
}
var WalletContractV5Beta = {};
var hasRequiredWalletContractV5Beta;
function requireWalletContractV5Beta() {
  if (hasRequiredWalletContractV5Beta) return WalletContractV5Beta;
  hasRequiredWalletContractV5Beta = 1;
  (function(exports) {
    var __createBinding = WalletContractV5Beta && WalletContractV5Beta.__createBinding || (Object.create ? (function(o4, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o4, k22, desc);
    }) : (function(o4, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o4[k22] = m2[k2];
    }));
    var __exportStar = WalletContractV5Beta && WalletContractV5Beta.__exportStar || function(m2, exports2) {
      for (var p2 in m2) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(requireWalletContractV5Beta$1(), exports);
    __exportStar(requireWalletV5BetaActions(), exports);
    __exportStar(requireWalletV5BetaWalletId(), exports);
  })(WalletContractV5Beta);
  return WalletContractV5Beta;
}
var WalletContractV5R1 = {};
var hasRequiredWalletContractV5R1;
function requireWalletContractV5R1() {
  if (hasRequiredWalletContractV5R1) return WalletContractV5R1;
  hasRequiredWalletContractV5R1 = 1;
  (function(exports) {
    var __createBinding = WalletContractV5R1 && WalletContractV5R1.__createBinding || (Object.create ? (function(o4, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o4, k22, desc);
    }) : (function(o4, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o4[k22] = m2[k2];
    }));
    var __exportStar = WalletContractV5R1 && WalletContractV5R1.__exportStar || function(m2, exports2) {
      for (var p2 in m2) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(requireWalletContractV5R1$1(), exports);
    __exportStar(requireWalletV5R1Actions(), exports);
    __exportStar(requireWalletV5R1WalletId(), exports);
  })(WalletContractV5R1);
  return WalletContractV5R1;
}
var JettonMaster = {};
var hasRequiredJettonMaster;
function requireJettonMaster() {
  if (hasRequiredJettonMaster) return JettonMaster;
  hasRequiredJettonMaster = 1;
  Object.defineProperty(JettonMaster, "__esModule", { value: true });
  JettonMaster.JettonMaster = void 0;
  const core_1 = requireDist$4();
  let JettonMaster$1 = class JettonMaster2 {
    static create(address) {
      return new JettonMaster2(address);
    }
    constructor(address) {
      this.address = address;
    }
    async getWalletAddress(provider, owner) {
      let res = await provider.get("get_wallet_address", [{ type: "slice", cell: (0, core_1.beginCell)().storeAddress(owner).endCell() }]);
      return res.stack.readAddress();
    }
    async getJettonData(provider) {
      let res = await provider.get("get_jetton_data", []);
      let totalSupply = res.stack.readBigNumber();
      let mintable = res.stack.readBoolean();
      let adminAddress = res.stack.readAddress();
      let content2 = res.stack.readCell();
      let walletCode = res.stack.readCell();
      return {
        totalSupply,
        mintable,
        adminAddress,
        content: content2,
        walletCode
      };
    }
  };
  JettonMaster.JettonMaster = JettonMaster$1;
  return JettonMaster;
}
var JettonWallet = {};
var hasRequiredJettonWallet;
function requireJettonWallet() {
  if (hasRequiredJettonWallet) return JettonWallet;
  hasRequiredJettonWallet = 1;
  Object.defineProperty(JettonWallet, "__esModule", { value: true });
  JettonWallet.JettonWallet = void 0;
  let JettonWallet$12 = class JettonWallet2 {
    static create(address) {
      return new JettonWallet2(address);
    }
    constructor(address) {
      this.address = address;
    }
    async getBalance(provider) {
      let state = await provider.getState();
      if (state.state.type !== "active") {
        return 0n;
      }
      let res = await provider.get("get_wallet_data", []);
      return res.stack.readBigNumber();
    }
  };
  JettonWallet.JettonWallet = JettonWallet$12;
  return JettonWallet;
}
var MultisigOrder = {};
var hasRequiredMultisigOrder;
function requireMultisigOrder() {
  if (hasRequiredMultisigOrder) return MultisigOrder;
  hasRequiredMultisigOrder = 1;
  Object.defineProperty(MultisigOrder, "__esModule", { value: true });
  MultisigOrder.MultisigOrder = void 0;
  const crypto_1 = requireDist$5();
  const core_1 = requireDist$4();
  let MultisigOrder$1 = class MultisigOrder2 {
    constructor(payload) {
      this.signatures = {};
      this.payload = payload;
    }
    static fromCell(cell) {
      let s2 = cell.beginParse();
      let signatures = s2.loadMaybeRef()?.beginParse();
      const messagesCell = s2.asCell();
      let order = new MultisigOrder2(messagesCell);
      if (signatures) {
        while (signatures.remainingBits > 0) {
          const signature = signatures.loadBuffer(64);
          const ownerId = signatures.loadUint(8);
          order.signatures[ownerId] = signature;
          if (signatures.remainingRefs > 0) {
            signatures = signatures.loadRef().asSlice();
          } else {
            signatures.skip(1);
          }
        }
        signatures.endParse();
      }
      return order;
    }
    static fromPayload(payload) {
      return new MultisigOrder2(payload);
    }
    addSignature(ownerId, signature, multisig) {
      const signingHash = this.payload.hash();
      if (!(0, crypto_1.signVerify)(signingHash, signature, multisig.owners.get(ownerId).slice(0, -1))) {
        throw Error("invalid signature");
      }
      this.signatures[ownerId] = signature;
    }
    sign(ownerId, secretKey) {
      const signingHash = this.payload.hash();
      this.signatures[ownerId] = (0, crypto_1.sign)(signingHash, secretKey);
      return signingHash;
    }
    unionSignatures(other) {
      this.signatures = Object.assign({}, this.signatures, other.signatures);
    }
    clearSignatures() {
      this.signatures = {};
    }
    toCell(ownerId) {
      let b2 = (0, core_1.beginCell)().storeBit(0);
      for (const ownerId2 in this.signatures) {
        const signature = this.signatures[ownerId2];
        b2 = (0, core_1.beginCell)().storeBit(1).storeRef((0, core_1.beginCell)().storeBuffer(signature).storeUint(parseInt(ownerId2), 8).storeBuilder(b2).endCell());
      }
      return (0, core_1.beginCell)().storeUint(ownerId, 8).storeBuilder(b2).storeBuilder(this.payload.asBuilder()).endCell();
    }
  };
  MultisigOrder.MultisigOrder = MultisigOrder$1;
  return MultisigOrder;
}
var MultisigOrderBuilder = {};
var hasRequiredMultisigOrderBuilder;
function requireMultisigOrderBuilder() {
  if (hasRequiredMultisigOrderBuilder) return MultisigOrderBuilder;
  hasRequiredMultisigOrderBuilder = 1;
  Object.defineProperty(MultisigOrderBuilder, "__esModule", { value: true });
  MultisigOrderBuilder.MultisigOrderBuilder = void 0;
  const core_1 = requireDist$4();
  const MultisigOrder_1 = requireMultisigOrder();
  let MultisigOrderBuilder$1 = class MultisigOrderBuilder {
    constructor(walletId, offset) {
      this.messages = (0, core_1.beginCell)();
      this.queryId = 0n;
      this.walletId = walletId;
      this.queryOffset = offset || 7200;
    }
    addMessage(message, mode) {
      if (this.messages.refs >= 4) {
        throw Error("only 4 refs are allowed");
      }
      this.updateQueryId();
      this.messages.storeUint(mode, 8);
      this.messages.storeRef((0, core_1.beginCell)().store((0, core_1.storeMessageRelaxed)(message)).endCell());
    }
    clearMessages() {
      this.messages = (0, core_1.beginCell)();
    }
    build() {
      return MultisigOrder_1.MultisigOrder.fromPayload((0, core_1.beginCell)().storeUint(this.walletId, 32).storeUint(this.queryId, 64).storeBuilder(this.messages).endCell());
    }
    updateQueryId() {
      const time = BigInt(Math.floor(Date.now() / 1e3 + this.queryOffset));
      this.queryId = time << 32n;
    }
  };
  MultisigOrderBuilder.MultisigOrderBuilder = MultisigOrderBuilder$1;
  return MultisigOrderBuilder;
}
var MultisigWallet = {};
var hasRequiredMultisigWallet;
function requireMultisigWallet() {
  if (hasRequiredMultisigWallet) return MultisigWallet;
  hasRequiredMultisigWallet = 1;
  Object.defineProperty(MultisigWallet, "__esModule", { value: true });
  MultisigWallet.MultisigWallet = void 0;
  const crypto_1 = requireDist$5();
  const core_1 = requireDist$4();
  const MULTISIG_CODE = core_1.Cell.fromBase64("te6ccgECKwEABBgAART/APSkE/S88sgLAQIBIAIDAgFIBAUE2vIgxwCOgzDbPOCDCNcYIPkBAdMH2zwiwAAToVNxePQOb6Hyn9s8VBq6+RDyoAb0BCD5AQHTH1EYuvKq0z9wUwHwCgHCCAGDCryx8mhTFYBA9A5voSCYDqQgwgryZw7f+COqH1NAufJhVCOjU04gIyEiAgLMBgcCASAMDQIBIAgJAgFmCgsAA9GEAiPymAvHoHN9CYbZ5S7Z4BPHohwhJQAtAKkItdJEqCTItdKlwLUAdAT8ArobBKAATwhbpEx4CBukTDgAdAg10rDAJrUAvALyFjPFszJ4HHXI8gBzxb0AMmACASAODwIBIBQVARW77ZbVA0cFUg2zyCoCAUgQEQIBIBITAXOxHXQgwjXGCD5AQHTB4IB1MTtQ9hTIHj0Dm+h8p/XC/9eMfkQ8qCuAfQEIW6TW3Ey4PkBWNs8AaQBgJwA9rtqA6ADoAPoCAXoCEfyAgPyA3XlP+AXkegAA54tkwAAXrhlXP8EA1WZ2oexAAgEgFhcCASAYGQFRtyVbZ4YmRmpGEAgegc30McJNhFpAADMaYeYuAFrgJhwLb+4cC3d0bhAjAYm1WZtnhqvgb+2xxsoicAgej430pBHEoFpAADHDhBACGuQkuuBk9kUWE5kAOeLKhACQCB6IYFImHFImHFImXEA2YlzNijAjAgEgGhsAF7UGtc4QQDVZnah7EAIBIBwdAgOZOB4fARGsGm2eL4G2CUAjABWt+UEAzJV2oewYQAENqTbPBVfBYCMAFa3f3CCAarM7UPYgAiDbPALyZfgAUENxQxPbPO1UIyoACtP/0wcwBKDbPC+uUyCw8mISsQKkJbNTHLmwJYEA4aojoCi8sPJpggGGoPgBBZcCERACPj4wjo0REB/bPEDXePRDEL0F4lQWW1Rz51YQU9zbPFRxClR6vCQlKCYAIO1E0NMf0wfTB9M/9AT0BNEAXgGOGjDSAAHyo9MH0wdQA9cBIPkBBfkBFbrypFAD4GwhIddKqgIi10m68qtwVCATAAwByMv/ywcE1ts87VT4D3AlblOJvrGYEG4QLVDHXwePGzBUJANQTds8UFWgRlAQSRA6SwlTuds8UFQWf+L4AAeDJaGOLCaAQPSWb6UglDBTA7neII4WODk5CNIAAZfTBzAW8AcFkTDifwgHBZJsMeKz5jAGKicoKQBgcI4pA9CDCNcY0wf0BDBTFnj0Dm+h8qXXC/9URUT5EPKmrlIgsVIDvRShI27mbCIyAH5SML6OIF8D+ACTItdKmALTB9QC+wAC6DJwyMoAQBSAQPRDAvAHjhdxyMsAFMsHEssHWM8BWM8WQBOAQPRDAeIBII6KEEUQNEMA2zztVJJfBuIqABzIyx/LB8sHyz/0APQAyQ==");
  let MultisigWallet$1 = class MultisigWallet2 {
    constructor(publicKeys, workchain, walletId, k2, opts) {
      this.provider = null;
      this.owners = core_1.Dictionary.empty();
      this.workchain = workchain;
      this.walletId = walletId;
      this.k = k2;
      for (let i = 0; i < publicKeys.length; i += 1) {
        this.owners.set(i, Buffer.concat([publicKeys[i], Buffer.alloc(1)]));
      }
      this.init = {
        code: MULTISIG_CODE,
        data: (0, core_1.beginCell)().storeUint(this.walletId, 32).storeUint(this.owners.size, 8).storeUint(this.k, 8).storeUint(0, 64).storeDict(this.owners, core_1.Dictionary.Keys.Uint(8), core_1.Dictionary.Values.Buffer(33)).storeBit(0).endCell()
      };
      this.address = opts?.address || (0, core_1.contractAddress)(workchain, this.init);
      if (opts?.provider) {
        this.provider = opts.provider;
      } else if (opts?.client) {
        this.provider = opts.client.provider(this.address, {
          code: this.init.code,
          data: this.init.data
        });
      }
    }
    static async fromAddress(address, opts) {
      let provider;
      if (opts.provider) {
        provider = opts.provider;
      } else {
        if (!opts.client) {
          throw Error("Either provider or client must be specified");
        }
        provider = opts.client.provider(address, {
          code: null,
          data: null
        });
      }
      const contractState = (await provider.getState()).state;
      if (contractState.type !== "active") {
        throw Error("Contract must be active");
      }
      const data = core_1.Cell.fromBoc(contractState.data)[0].beginParse();
      const walletId = data.loadUint(32);
      data.skip(8);
      const k2 = data.loadUint(8);
      data.skip(64);
      const owners = data.loadDict(core_1.Dictionary.Keys.Uint(8), core_1.Dictionary.Values.Buffer(33));
      let publicKeys = [];
      for (const [key2, value] of owners) {
        const publicKey = value.subarray(0, 32);
        publicKeys.push(publicKey);
      }
      return new MultisigWallet2(publicKeys, address.workChain, walletId, k2, {
        address,
        provider,
        client: opts.client
      });
    }
    async deployExternal(provider) {
      if (!provider && !this.provider) {
        throw Error("you must specify provider if there is no such property in MultisigWallet instance");
      }
      if (!provider) {
        provider = this.provider;
      }
      await provider.external(core_1.Cell.EMPTY);
    }
    async deployInternal(sender, value = 1000000000n) {
      await sender.send({
        sendMode: core_1.SendMode.PAY_GAS_SEPARATELY + core_1.SendMode.IGNORE_ERRORS,
        to: this.address,
        value,
        init: this.init,
        body: core_1.Cell.EMPTY,
        bounce: true
      });
    }
    async sendOrder(order, secretKey, provider) {
      if (!provider && !this.provider) {
        throw Error("you must specify provider if there is no such property in MultisigWallet instance");
      }
      if (!provider) {
        provider = this.provider;
      }
      let publicKey = (0, crypto_1.keyPairFromSecretKey)(secretKey).publicKey;
      let ownerId = this.getOwnerIdByPubkey(publicKey);
      let cell = order.toCell(ownerId);
      let signature = (0, crypto_1.sign)(cell.hash(), secretKey);
      cell = (0, core_1.beginCell)().storeBuffer(signature).storeSlice(cell.asSlice()).endCell();
      await provider.external(cell);
    }
    async sendOrderWithoutSecretKey(order, signature, ownerId, provider) {
      if (!provider && !this.provider) {
        throw Error("you must specify provider if there is no such property in MultisigWallet instance");
      }
      if (!provider) {
        provider = this.provider;
      }
      let cell = order.toCell(ownerId);
      cell = (0, core_1.beginCell)().storeBuffer(signature).storeSlice(cell.asSlice()).endCell();
      await provider.external(cell);
    }
    getOwnerIdByPubkey(publicKey) {
      for (const [key2, value] of this.owners) {
        if (value.subarray(0, 32).equals(publicKey)) {
          return key2;
        }
      }
      throw Error("public key is not an owner");
    }
  };
  MultisigWallet.MultisigWallet = MultisigWallet$1;
  return MultisigWallet;
}
var ElectorContract = {};
var hasRequiredElectorContract;
function requireElectorContract() {
  if (hasRequiredElectorContract) return ElectorContract;
  hasRequiredElectorContract = 1;
  Object.defineProperty(ElectorContract, "__esModule", { value: true });
  ElectorContract.ElectorContract = void 0;
  const core_1 = requireDist$4();
  const FrozenDictValue = {
    serialize(src2, builder2) {
      throw Error("not implemented");
    },
    parse(src2) {
      const address = new core_1.Address(-1, src2.loadBuffer(32));
      const weight = src2.loadUintBig(64);
      const stake = src2.loadCoins();
      return { address, weight, stake };
    }
  };
  const EntitiesDictValue = {
    serialize(src2, builder2) {
      throw Error("not implemented");
    },
    parse(src2) {
      const stake = src2.loadCoins();
      src2.skip(64);
      const address = new core_1.Address(-1, src2.loadBuffer(32));
      const adnl = src2.loadBuffer(32);
      return { stake, address, adnl };
    }
  };
  let ElectorContract$1 = class ElectorContract2 {
    //readonly source: ContractSource = new UnknownContractSource('org.ton.elector', -1, 'Elector Contract');
    static create() {
      return new ElectorContract2();
    }
    constructor() {
      this.address = core_1.Address.parseRaw("-1:3333333333333333333333333333333333333333333333333333333333333333");
    }
    async getReturnedStake(provider, address) {
      if (address.workChain !== -1) {
        throw Error("Only masterchain addresses could have stake");
      }
      const res = await provider.get("compute_returned_stake", [{ type: "int", value: BigInt("0x" + address.hash.toString("hex")) }]);
      return res.stack.readBigNumber();
    }
    async getPastElectionsList(provider) {
      const res = await provider.get("past_elections_list", []);
      const electionsListRaw = new core_1.TupleReader(res.stack.readLispList());
      const elections = [];
      while (electionsListRaw.remaining > 0) {
        const electionsListEntry = electionsListRaw.readTuple();
        const id = electionsListEntry.readNumber();
        const unfreezeAt = electionsListEntry.readNumber();
        electionsListEntry.pop();
        const stakeHeld = electionsListEntry.readNumber();
        elections.push({ id, unfreezeAt, stakeHeld });
      }
      return elections;
    }
    async getPastElections(provider) {
      const res = await provider.get("past_elections", []);
      const electionsRaw = new core_1.TupleReader(res.stack.readLispList());
      const elections = [];
      while (electionsRaw.remaining > 0) {
        const electionsEntry = electionsRaw.readTuple();
        const id = electionsEntry.readNumber();
        const unfreezeAt = electionsEntry.readNumber();
        const stakeHeld = electionsEntry.readNumber();
        electionsEntry.pop();
        const frozenDict = electionsEntry.readCell();
        const totalStake = electionsEntry.readBigNumber();
        const bonuses = electionsEntry.readBigNumber();
        let frozen = /* @__PURE__ */ new Map();
        const frozenData = frozenDict.beginParse().loadDictDirect(core_1.Dictionary.Keys.Buffer(32), FrozenDictValue);
        for (const [key2, value] of frozenData) {
          frozen.set(BigInt("0x" + key2.toString("hex")).toString(10), { address: value["address"], weight: value["weight"], stake: value["stake"] });
        }
        elections.push({ id, unfreezeAt, stakeHeld, totalStake, bonuses, frozen });
      }
      return elections;
    }
    async getElectionEntities(provider) {
      const account = await provider.getState();
      if (account.state.type !== "active") {
        throw Error("Unexpected error");
      }
      const cell = core_1.Cell.fromBoc(account.state.data)[0];
      const cs = cell.beginParse();
      if (!cs.loadBit()) {
        return null;
      }
      const sc = cs.loadRef().beginParse();
      const startWorkTime = sc.loadUint(32);
      const endElectionsTime = sc.loadUint(32);
      const minStake = sc.loadCoins();
      const allStakes = sc.loadCoins();
      const entitiesData = sc.loadDict(core_1.Dictionary.Keys.Buffer(32), EntitiesDictValue);
      let entities = [];
      if (entitiesData) {
        for (const [key2, value] of entitiesData) {
          entities.push({ pubkey: key2, stake: value["stake"], address: value["address"], adnl: value["adnl"] });
        }
      }
      return { minStake, allStakes, endElectionsTime, startWorkTime, entities };
    }
    // possible code for fetching data via get method if it is possible to set gas limit by request
    // async getElectionEntities(block: number) {
    //     const res = await this.client.runMethod(block, this.address, 'participant_list_extended');
    //     if (res.exitCode !== 0 && res.exitCode !== 1) {
    //         throw Error('Exit code: ' + res.exitCode);
    //     }
    //     let tuple = new TupleReader(res.result);
    //     const startWorkTime = tuple.readNumber();
    //     const endElectionsTime = tuple.readNumber();
    //     const minStake = tuple.readBigNumber();
    //     const allStakes = tuple.readBigNumber();
    //     let entriesTuple = tuple.readTuple();
    //     const entriesRaw = new TupleReader(entriesTuple.readLispList());
    //     let entities: { pubkey: Buffer, stake: bigint, address: Address, adnl: Buffer }[] = [];
    //     while (entriesRaw.remaining > 0) {
    //         const electionsEntry = entriesRaw.readTuple();
    //         const pubkey = electionsEntry.readBuffer();
    //         const stake = electionsEntry.readBigNumber();
    //         const address = electionsEntry.readAddress();
    //         const adnl = electionsEntry.readBuffer();
    //         entities.push({ pubkey, stake, address, adnl });
    //     }
    //     return { minStake, allStakes, endElectionsTime, startWorkTime, entities };
    // }
    async getActiveElectionId(provider) {
      const res = await provider.get("active_election_id", []);
      const electionId = res.stack.readNumber();
      return electionId > 0 ? electionId : null;
    }
    async getComplaints(provider, electionId) {
      const b2 = new core_1.TupleBuilder();
      b2.writeNumber(electionId);
      const res = await provider.get("list_complaints", b2.build());
      if (res.stack.peek().type === "null") {
        return [];
      }
      const complaintsRaw = new core_1.TupleReader(res.stack.readLispList());
      const results = [];
      while (complaintsRaw.remaining > 0) {
        const complaintsEntry = complaintsRaw.readTuple();
        const id = complaintsEntry.readBigNumber();
        const completeUnpackedComplaint = complaintsEntry.readTuple();
        const unpackedComplaints = completeUnpackedComplaint.readTuple();
        const publicKey = Buffer.from(unpackedComplaints.readBigNumber().toString(16), "hex");
        unpackedComplaints.readCell();
        const createdAt = unpackedComplaints.readNumber();
        const severity = unpackedComplaints.readNumber();
        const rewardAddress = new core_1.Address(-1, Buffer.from(unpackedComplaints.readBigNumber().toString(16), "hex"));
        const paid = unpackedComplaints.readBigNumber();
        const suggestedFine = unpackedComplaints.readBigNumber();
        const suggestedFinePart = unpackedComplaints.readBigNumber();
        const votes = [];
        const votersListRaw = new core_1.TupleReader(completeUnpackedComplaint.readLispList());
        while (votersListRaw.remaining > 0) {
          votes.push(votersListRaw.readNumber());
        }
        const vsetId = completeUnpackedComplaint.readBigNumber();
        const remainingWeight = completeUnpackedComplaint.readBigNumber();
        results.push({
          id,
          publicKey,
          createdAt,
          severity,
          paid,
          suggestedFine,
          suggestedFinePart,
          rewardAddress,
          votes,
          remainingWeight,
          vsetId
        });
      }
      return results;
    }
  };
  ElectorContract.ElectorContract = ElectorContract$1;
  return ElectorContract;
}
var ConfigParser = {};
var hasRequiredConfigParser;
function requireConfigParser() {
  if (hasRequiredConfigParser) return ConfigParser;
  hasRequiredConfigParser = 1;
  Object.defineProperty(ConfigParser, "__esModule", { value: true });
  ConfigParser.configParseMasterAddress = configParseMasterAddress;
  ConfigParser.parseValidatorSet = parseValidatorSet;
  ConfigParser.parseBridge = parseBridge;
  ConfigParser.configParseMasterAddressRequired = configParseMasterAddressRequired;
  ConfigParser.configParse5 = configParse5;
  ConfigParser.configParse13 = configParse13;
  ConfigParser.configParse15 = configParse15;
  ConfigParser.configParse16 = configParse16;
  ConfigParser.configParse17 = configParse17;
  ConfigParser.configParse18 = configParse18;
  ConfigParser.configParse8 = configParse8;
  ConfigParser.configParse40 = configParse40;
  ConfigParser.configParseWorkchainDescriptor = configParseWorkchainDescriptor;
  ConfigParser.configParse12 = configParse12;
  ConfigParser.configParseValidatorSet = configParseValidatorSet;
  ConfigParser.configParseBridge = configParseBridge;
  ConfigParser.configParseGasLimitsPrices = configParseGasLimitsPrices;
  ConfigParser.configParseMsgPrices = configParseMsgPrices;
  ConfigParser.configParse28 = configParse28;
  ConfigParser.configParse29 = configParse29;
  ConfigParser.parseProposalSetup = parseProposalSetup;
  ConfigParser.parseVotingSetup = parseVotingSetup;
  ConfigParser.loadConfigParamById = loadConfigParamById;
  ConfigParser.loadConfigParamsAsSlice = loadConfigParamsAsSlice;
  ConfigParser.parseFullConfig = parseFullConfig;
  const core_1 = requireDist$4();
  function configParseMasterAddress(slice) {
    if (slice) {
      return new core_1.Address(-1, slice.loadBuffer(32));
    } else {
      return null;
    }
  }
  function readPublicKey(slice) {
    if (slice.loadUint(32) !== 2390828938) {
      throw Error("Invalid config");
    }
    return slice.loadBuffer(32);
  }
  const ValidatorDescriptionDictValue = {
    serialize(src2, builder2) {
      throw Error("not implemented");
    },
    parse(src2) {
      const header = src2.loadUint(8);
      if (header === 83) {
        return {
          publicKey: readPublicKey(src2),
          weight: src2.loadUintBig(64),
          adnlAddress: null
        };
      } else if (header === 115) {
        return {
          publicKey: readPublicKey(src2),
          weight: src2.loadUintBig(64),
          adnlAddress: src2.loadBuffer(32)
        };
      } else {
        throw Error("Invalid config");
      }
    }
  };
  function parseValidatorSet(slice) {
    const header = slice.loadUint(8);
    if (header === 17) {
      const timeSince = slice.loadUint(32);
      const timeUntil = slice.loadUint(32);
      const total = slice.loadUint(16);
      const main2 = slice.loadUint(16);
      const list = slice.loadDictDirect(core_1.Dictionary.Keys.Uint(16), ValidatorDescriptionDictValue);
      return {
        timeSince,
        timeUntil,
        total,
        main: main2,
        totalWeight: null,
        list
      };
    } else if (header === 18) {
      const timeSince = slice.loadUint(32);
      const timeUntil = slice.loadUint(32);
      const total = slice.loadUint(16);
      const main2 = slice.loadUint(16);
      const totalWeight = slice.loadUintBig(64);
      const list = slice.loadDict(core_1.Dictionary.Keys.Uint(16), ValidatorDescriptionDictValue);
      return {
        timeSince,
        timeUntil,
        total,
        main: main2,
        totalWeight,
        list
      };
    }
  }
  function parseBridge(slice) {
    const bridgeAddress = new core_1.Address(-1, slice.loadBuffer(32));
    const oracleMultisigAddress = new core_1.Address(-1, slice.loadBuffer(32));
    const oraclesDict = slice.loadDict(core_1.Dictionary.Keys.Buffer(32), core_1.Dictionary.Values.Buffer(32));
    const oracles = /* @__PURE__ */ new Map();
    for (const [local, remote] of oraclesDict) {
      oracles.set(new core_1.Address(-1, local).toString(), remote);
    }
    const externalChainAddress = slice.loadBuffer(32);
    return {
      bridgeAddress,
      oracleMultisigAddress,
      oracles,
      externalChainAddress
    };
  }
  function configParseMasterAddressRequired(slice) {
    if (!slice) {
      throw Error("Invalid config");
    }
    return configParseMasterAddress(slice);
  }
  function configParse5(slice) {
    if (!slice) {
      throw Error("Invalid config");
    }
    const magic = slice.loadUint(8);
    if (magic === 1) {
      const blackholeAddr = slice.loadBit() ? new core_1.Address(-1, slice.loadBuffer(32)) : null;
      const feeBurnNominator = slice.loadUint(32);
      const feeBurnDenominator = slice.loadUint(32);
      return {
        blackholeAddr,
        feeBurnNominator,
        feeBurnDenominator
      };
    }
    throw new Error("Invalid config");
  }
  function configParse13(slice) {
    if (!slice) {
      throw Error("Invalid config");
    }
    const magic = slice.loadUint(8);
    if (magic === 26) {
      const deposit = slice.loadCoins();
      const bitPrice = slice.loadCoins();
      const cellPrice = slice.loadCoins();
      return {
        deposit,
        bitPrice,
        cellPrice
      };
    }
    throw new Error("Invalid config");
  }
  function configParse15(slice) {
    if (!slice) {
      throw Error("Invalid config");
    }
    const validatorsElectedFor = slice.loadUint(32);
    const electorsStartBefore = slice.loadUint(32);
    const electorsEndBefore = slice.loadUint(32);
    const stakeHeldFor = slice.loadUint(32);
    return {
      validatorsElectedFor,
      electorsStartBefore,
      electorsEndBefore,
      stakeHeldFor
    };
  }
  function configParse16(slice) {
    if (!slice) {
      throw Error("Invalid config");
    }
    const maxValidators = slice.loadUint(16);
    const maxMainValidators = slice.loadUint(16);
    const minValidators = slice.loadUint(16);
    return {
      maxValidators,
      maxMainValidators,
      minValidators
    };
  }
  function configParse17(slice) {
    if (!slice) {
      throw Error("Invalid config");
    }
    const minStake = slice.loadCoins();
    const maxStake = slice.loadCoins();
    const minTotalStake = slice.loadCoins();
    const maxStakeFactor = slice.loadUint(32);
    return {
      minStake,
      maxStake,
      minTotalStake,
      maxStakeFactor
    };
  }
  const StoragePricesDictValue = {
    serialize(src2, builder2) {
      throw Error("not implemented");
    },
    parse(src2) {
      const header = src2.loadUint(8);
      if (header !== 204) {
        throw Error("Invalid config");
      }
      const utime_since = src2.loadUint(32);
      const bit_price_ps = src2.loadUintBig(64);
      const cell_price_ps = src2.loadUintBig(64);
      const mc_bit_price_ps = src2.loadUintBig(64);
      const mc_cell_price_ps = src2.loadUintBig(64);
      return {
        utime_since,
        bit_price_ps,
        cell_price_ps,
        mc_bit_price_ps,
        mc_cell_price_ps
      };
    }
  };
  function configParse18(slice) {
    if (!slice) {
      throw Error("Invalid config");
    }
    return slice.loadDictDirect(core_1.Dictionary.Keys.Buffer(4), StoragePricesDictValue).values();
  }
  function configParse8(slice) {
    if (!slice) {
      return {
        version: 0,
        capabilities: 0n
      };
    }
    const version2 = slice.loadUint(32);
    const capabilities = slice.loadUintBig(64);
    return {
      version: version2,
      capabilities
    };
  }
  function configParse40(slice) {
    if (!slice) {
      return null;
    }
    const header = slice.loadUint(8);
    if (header !== 1) {
      throw Error("Invalid config");
    }
    const defaultFlatFine = slice.loadCoins();
    const defaultProportionaFine = slice.loadCoins();
    const severityFlatMult = slice.loadUint(16);
    const severityProportionalMult = slice.loadUint(16);
    const unfunishableInterval = slice.loadUint(16);
    const longInterval = slice.loadUint(16);
    const longFlatMult = slice.loadUint(16);
    const longProportionalMult = slice.loadUint(16);
    const mediumInterval = slice.loadUint(16);
    const mediumFlatMult = slice.loadUint(16);
    const mediumProportionalMult = slice.loadUint(16);
    return {
      defaultFlatFine,
      defaultProportionaFine,
      severityFlatMult,
      severityProportionalMult,
      unfunishableInterval,
      longInterval,
      longFlatMult,
      longProportionalMult,
      mediumInterval,
      mediumFlatMult,
      mediumProportionalMult
    };
  }
  function configParseWorkchainDescriptor(slice) {
    const constructorTag = slice.loadUint(8);
    if (!(constructorTag == 166 || constructorTag == 167)) {
      throw Error("Invalid config");
    }
    const enabledSince = slice.loadUint(32);
    const actialMinSplit = slice.loadUint(8);
    const min_split = slice.loadUint(8);
    const max_split = slice.loadUint(8);
    const basic = slice.loadBit();
    const active = slice.loadBit();
    const accept_msgs = slice.loadBit();
    const flags = slice.loadUint(13);
    const zerostateRootHash = slice.loadBuffer(32);
    const zerostateFileHash = slice.loadBuffer(32);
    const version2 = slice.loadUint(32);
    if (!slice.loadUint(4)) {
      throw Error("Invalid config");
    }
    const vmVersion = slice.loadInt(32);
    const vmMode = slice.loadUintBig(64);
    let extension = void 0;
    if (constructorTag == 167) {
      const splitMergeTimings = parseWorkchainSplitMergeTimings(slice);
      const stateSplitDepth = slice.loadUint(8);
      if (stateSplitDepth > 63) {
        throw RangeError(`Invalid persistent_state_split_depth: ${stateSplitDepth} expected <= 63`);
      }
      extension = {
        split_merge_timings: splitMergeTimings,
        persistent_state_split_depth: stateSplitDepth
      };
    }
    return {
      enabledSince,
      actialMinSplit,
      min_split,
      max_split,
      basic,
      active,
      accept_msgs,
      flags,
      zerostateRootHash,
      zerostateFileHash,
      version: version2,
      format: {
        vmVersion,
        vmMode
      },
      workchain_v2: extension
    };
  }
  function parseWorkchainSplitMergeTimings(slice) {
    if (slice.loadUint(4) !== 0) {
      throw Error(`Invalid WcSplitMergeTimings tag expected 0!`);
    }
    return {
      split_merge_delay: slice.loadUint(32),
      split_merge_interval: slice.loadUint(32),
      min_split_merge_interval: slice.loadUint(32),
      max_split_merge_delay: slice.loadUint(32)
    };
  }
  const WorkchainDescriptorDictValue = {
    serialize(src2, builder2) {
      throw Error("not implemented");
    },
    parse(src2) {
      return configParseWorkchainDescriptor(src2);
    }
  };
  function configParse12(slice) {
    if (!slice) {
      throw Error("Invalid config");
    }
    const wd = slice.loadDict(core_1.Dictionary.Keys.Uint(32), WorkchainDescriptorDictValue);
    if (wd) {
      return wd;
    }
    throw Error("No workchains exist");
  }
  function configParseValidatorSet(slice) {
    if (!slice) {
      return null;
    }
    return parseValidatorSet(slice);
  }
  function configParseBridge(slice) {
    if (!slice) {
      return null;
    }
    return parseBridge(slice);
  }
  function parseGasLimitsInternal(slice) {
    const tag = slice.loadUint(8);
    if (tag === 222) {
      const gasPrice = slice.loadUintBig(64);
      const gasLimit = slice.loadUintBig(64);
      const specialGasLimit = slice.loadUintBig(64);
      const gasCredit = slice.loadUintBig(64);
      const blockGasLimit = slice.loadUintBig(64);
      const freezeDueLimit = slice.loadUintBig(64);
      const deleteDueLimit = slice.loadUintBig(64);
      return {
        gasPrice,
        gasLimit,
        specialGasLimit,
        gasCredit,
        blockGasLimit,
        freezeDueLimit,
        deleteDueLimit
      };
    } else if (tag === 221) {
      const gasPrice = slice.loadUintBig(64);
      const gasLimit = slice.loadUintBig(64);
      const gasCredit = slice.loadUintBig(64);
      const blockGasLimit = slice.loadUintBig(64);
      const freezeDueLimit = slice.loadUintBig(64);
      const deleteDueLimit = slice.loadUintBig(64);
      return {
        gasPrice,
        gasLimit,
        gasCredit,
        blockGasLimit,
        freezeDueLimit,
        deleteDueLimit
      };
    } else {
      throw Error("Invalid config");
    }
  }
  function configParseGasLimitsPrices(slice) {
    if (!slice) {
      throw Error("Invalid config");
    }
    const tag = slice.loadUint(8);
    if (tag === 209) {
      const flatLimit = slice.loadUintBig(64);
      const flatGasPrice = slice.loadUintBig(64);
      const other = parseGasLimitsInternal(slice);
      return {
        flatLimit,
        flatGasPrice,
        other
      };
    } else {
      throw Error("Invalid config");
    }
  }
  function configParseMsgPrices(slice) {
    if (!slice) {
      throw new Error("Invalid config");
    }
    const magic = slice.loadUint(8);
    if (magic !== 234) {
      throw new Error("Invalid msg prices param");
    }
    return {
      lumpPrice: slice.loadUintBig(64),
      bitPrice: slice.loadUintBig(64),
      cellPrice: slice.loadUintBig(64),
      ihrPriceFactor: slice.loadUint(32),
      firstFrac: slice.loadUint(16),
      nextFrac: slice.loadUint(16)
    };
  }
  function configParse28(slice) {
    if (!slice) {
      throw new Error("Invalid config");
    }
    const magic = slice.loadUint(8);
    if (magic === 193) {
      const masterCatchainLifetime = slice.loadUint(32);
      const shardCatchainLifetime = slice.loadUint(32);
      const shardValidatorsLifetime = slice.loadUint(32);
      const shardValidatorsCount = slice.loadUint(32);
      return {
        masterCatchainLifetime,
        shardCatchainLifetime,
        shardValidatorsLifetime,
        shardValidatorsCount
      };
    }
    if (magic === 194) {
      const flags = slice.loadUint(7);
      const suffleMasterValidators = slice.loadBit();
      const masterCatchainLifetime = slice.loadUint(32);
      const shardCatchainLifetime = slice.loadUint(32);
      const shardValidatorsLifetime = slice.loadUint(32);
      const shardValidatorsCount = slice.loadUint(32);
      return {
        flags,
        suffleMasterValidators,
        masterCatchainLifetime,
        shardCatchainLifetime,
        shardValidatorsLifetime,
        shardValidatorsCount
      };
    }
    throw new Error("Invalid config");
  }
  function configParse29(slice) {
    if (!slice) {
      throw new Error("Invalid config");
    }
    const magic = slice.loadUint(8);
    if (magic === 214) {
      const roundCandidates = slice.loadUint(32);
      const nextCandidateDelay = slice.loadUint(32);
      const consensusTimeout = slice.loadUint(32);
      const fastAttempts = slice.loadUint(32);
      const attemptDuration = slice.loadUint(32);
      const catchainMaxDeps = slice.loadUint(32);
      const maxBlockBytes = slice.loadUint(32);
      const maxColaltedBytes = slice.loadUint(32);
      return {
        roundCandidates,
        nextCandidateDelay,
        consensusTimeout,
        fastAttempts,
        attemptDuration,
        catchainMaxDeps,
        maxBlockBytes,
        maxColaltedBytes
      };
    } else if (magic === 215) {
      const flags = slice.loadUint(7);
      const newCatchainIds = slice.loadBit();
      const roundCandidates = slice.loadUint(8);
      const nextCandidateDelay = slice.loadUint(32);
      const consensusTimeout = slice.loadUint(32);
      const fastAttempts = slice.loadUint(32);
      const attemptDuration = slice.loadUint(32);
      const catchainMaxDeps = slice.loadUint(32);
      const maxBlockBytes = slice.loadUint(32);
      const maxColaltedBytes = slice.loadUint(32);
      return {
        flags,
        newCatchainIds,
        roundCandidates,
        nextCandidateDelay,
        consensusTimeout,
        fastAttempts,
        attemptDuration,
        catchainMaxDeps,
        maxBlockBytes,
        maxColaltedBytes
      };
    } else if (magic === 216) {
      const flags = slice.loadUint(7);
      const newCatchainIds = slice.loadBit();
      const roundCandidates = slice.loadUint(8);
      const nextCandidateDelay = slice.loadUint(32);
      const consensusTimeout = slice.loadUint(32);
      const fastAttempts = slice.loadUint(32);
      const attemptDuration = slice.loadUint(32);
      const catchainMaxDeps = slice.loadUint(32);
      const maxBlockBytes = slice.loadUint(32);
      const maxColaltedBytes = slice.loadUint(32);
      const protoVersion = slice.loadUint(16);
      return {
        flags,
        newCatchainIds,
        roundCandidates,
        nextCandidateDelay,
        consensusTimeout,
        fastAttempts,
        attemptDuration,
        catchainMaxDeps,
        maxBlockBytes,
        maxColaltedBytes,
        protoVersion
      };
    } else if (magic === 217) {
      const flags = slice.loadUint(7);
      const newCatchainIds = slice.loadBit();
      const roundCandidates = slice.loadUint(8);
      const nextCandidateDelay = slice.loadUint(32);
      const consensusTimeout = slice.loadUint(32);
      const fastAttempts = slice.loadUint(32);
      const attemptDuration = slice.loadUint(32);
      const catchainMaxDeps = slice.loadUint(32);
      const maxBlockBytes = slice.loadUint(32);
      const maxColaltedBytes = slice.loadUint(32);
      const protoVersion = slice.loadUint(16);
      const catchainMaxBlocksCoeff = slice.loadUint(32);
      return {
        flags,
        newCatchainIds,
        roundCandidates,
        nextCandidateDelay,
        consensusTimeout,
        fastAttempts,
        attemptDuration,
        catchainMaxDeps,
        maxBlockBytes,
        maxColaltedBytes,
        protoVersion,
        catchainMaxBlocksCoeff
      };
    }
    throw new Error("Invalid config");
  }
  function parseProposalSetup(slice) {
    const magic = slice.loadUint(8);
    if (magic !== 54) {
      throw new Error("Invalid config");
    }
    const minTotalRounds = slice.loadUint(8);
    const maxTotalRounds = slice.loadUint(8);
    const minWins = slice.loadUint(8);
    const maxLoses = slice.loadUint(8);
    const minStoreSec = slice.loadUint(32);
    const maxStoreSec = slice.loadUint(32);
    const bitPrice = slice.loadUint(32);
    const cellPrice = slice.loadUint(32);
    return { minTotalRounds, maxTotalRounds, minWins, maxLoses, minStoreSec, maxStoreSec, bitPrice, cellPrice };
  }
  function parseVotingSetup(slice) {
    if (!slice) {
      throw new Error("Invalid config");
    }
    const magic = slice.loadUint(8);
    if (magic !== 145) {
      throw new Error("Invalid config");
    }
    const normalParams = parseProposalSetup(slice.loadRef().beginParse());
    const criticalParams = parseProposalSetup(slice.loadRef().beginParse());
    return { normalParams, criticalParams };
  }
  function loadConfigParams(configBase64) {
    const comfigMap = core_1.Cell.fromBase64(configBase64).beginParse().loadDictDirect(core_1.Dictionary.Keys.Int(32), core_1.Dictionary.Values.Cell());
    return comfigMap;
  }
  function loadConfigParamById(configBase64, id) {
    return loadConfigParams(configBase64).get(id);
  }
  function loadConfigParamsAsSlice(configBase64) {
    const pramsAsCells = loadConfigParams(configBase64);
    const params = /* @__PURE__ */ new Map();
    for (const [key2, value] of pramsAsCells) {
      params.set(key2, value.beginParse());
    }
    return params;
  }
  function parseFullConfig(configs) {
    return {
      configAddress: configParseMasterAddressRequired(configs.get(0)),
      electorAddress: configParseMasterAddressRequired(configs.get(1)),
      minterAddress: configParseMasterAddress(configs.get(2)),
      feeCollectorAddress: configParseMasterAddress(configs.get(3)),
      dnsRootAddress: configParseMasterAddress(configs.get(4)),
      burningConfig: configParse5(configs.get(5)),
      globalVersion: configParse8(configs.get(8)),
      workchains: configParse12(configs.get(12)),
      voting: parseVotingSetup(configs.get(11)),
      validators: {
        ...configParse15(configs.get(15)),
        ...configParse16(configs.get(16)),
        ...configParse17(configs.get(17))
      },
      storagePrices: configParse18(configs.get(18)),
      gasPrices: {
        masterchain: configParseGasLimitsPrices(configs.get(20)),
        workchain: configParseGasLimitsPrices(configs.get(21))
      },
      msgPrices: {
        masterchain: configParseMsgPrices(configs.get(24)),
        workchain: configParseMsgPrices(configs.get(25))
      },
      validatorSets: {
        prevValidators: configParseValidatorSet(configs.get(32)),
        prevTempValidators: configParseValidatorSet(configs.get(33)),
        currentValidators: configParseValidatorSet(configs.get(34)),
        currentTempValidators: configParseValidatorSet(configs.get(35)),
        nextValidators: configParseValidatorSet(configs.get(36)),
        nextTempValidators: configParseValidatorSet(configs.get(37))
      },
      validatorsPunish: configParse40(configs.get(40)),
      bridges: {
        ethereum: configParseBridge(configs.get(71)),
        binance: configParseBridge(configs.get(72)),
        polygon: configParseBridge(configs.get(73))
      },
      catchain: configParse28(configs.get(28)),
      consensus: configParse29(configs.get(29))
      // TODO: mint_new_price:Grams mint_add_price:Grams = ConfigParam 6;
      // TODO: to_mint:ExtraCurrencyCollection = ConfigParam 7
      // TODO: mandatory_params:(Hashmap 32 True) = ConfigParam 9
      // TODO: critical_params:(Hashmap 32 True) = ConfigParam 10
      // TODO: BlockCreateFees = ConfigParam 14
    };
  }
  return ConfigParser;
}
var fees = {};
var hasRequiredFees;
function requireFees() {
  if (hasRequiredFees) return fees;
  hasRequiredFees = 1;
  Object.defineProperty(fees, "__esModule", { value: true });
  fees.computeStorageFees = computeStorageFees;
  fees.computeFwdFees = computeFwdFees;
  fees.computeGasPrices = computeGasPrices;
  fees.computeExternalMessageFees = computeExternalMessageFees;
  fees.computeMessageForwardFees = computeMessageForwardFees;
  const core_1 = requireDist$4();
  function computeStorageFees(data) {
    const { lastPaid, now, storagePrices, storageStat, special, masterchain } = data;
    if (now <= lastPaid || storagePrices.length === 0 || now < storagePrices[0].utime_since || special) {
      return BigInt(0);
    }
    let upto = Math.max(lastPaid, storagePrices[0].utime_since);
    let total = BigInt(0);
    for (let i = 0; i < storagePrices.length && upto < now; i++) {
      let valid_until = i < storagePrices.length - 1 ? Math.min(now, storagePrices[i + 1].utime_since) : now;
      let payment = BigInt(0);
      if (upto < valid_until) {
        let delta = valid_until - upto;
        payment += BigInt(storageStat.cells) * (masterchain ? storagePrices[i].mc_cell_price_ps : storagePrices[i].cell_price_ps);
        payment += BigInt(storageStat.bits) * (masterchain ? storagePrices[i].mc_bit_price_ps : storagePrices[i].bit_price_ps);
        payment = payment * BigInt(delta);
      }
      upto = valid_until;
      total += payment;
    }
    return shr16ceil(total);
  }
  function computeFwdFees(msgPrices, cells, bits) {
    return msgPrices.lumpPrice + shr16ceil(msgPrices.bitPrice * bits + msgPrices.cellPrice * cells);
  }
  function computeGasPrices(gasUsed, prices) {
    if (gasUsed <= prices.flatLimit) {
      return prices.flatPrice;
    } else {
      return prices.flatPrice + (prices.price * (gasUsed - prices.flatLimit) >> 16n);
    }
  }
  function computeExternalMessageFees(msgPrices, cell) {
    let storageStats = collectCellStats(cell);
    storageStats.bits -= cell.bits.length;
    storageStats.cells -= 1;
    return computeFwdFees(msgPrices, BigInt(storageStats.cells), BigInt(storageStats.bits));
  }
  function computeMessageForwardFees(msgPrices, cell) {
    let msg = (0, core_1.loadMessageRelaxed)(cell.beginParse());
    let storageStats = { bits: 0, cells: 0 };
    if (msg.init) {
      const rawBuilder = new core_1.Cell().asBuilder();
      (0, core_1.storeStateInit)(msg.init)(rawBuilder);
      const raw = rawBuilder.endCell();
      let c = collectCellStats(raw);
      c.bits -= raw.bits.length;
      c.cells -= 1;
      storageStats.bits += c.bits;
      storageStats.cells += c.cells;
    }
    let bc = collectCellStats(msg.body);
    bc.bits -= msg.body.bits.length;
    bc.cells -= 1;
    storageStats.bits += bc.bits;
    storageStats.cells += bc.cells;
    let fees2 = computeFwdFees(msgPrices, BigInt(storageStats.cells), BigInt(storageStats.bits));
    let res = fees2 * BigInt(msgPrices.firstFrac) >> 16n;
    let remaining = fees2 - res;
    return { fees: res, remaining };
  }
  function collectCellStats(cell) {
    let bits = cell.bits.length;
    let cells = 1;
    for (let ref of cell.refs) {
      let r = collectCellStats(ref);
      cells += r.cells;
      bits += r.bits;
    }
    return { bits, cells };
  }
  function shr16ceil(src2) {
    let rem = src2 % 65536n;
    let res = src2 >> 16n;
    if (rem !== 0n) {
      res += 1n;
    }
    return res;
  }
  return fees;
}
var hasRequiredDist$1;
function requireDist$1() {
  if (hasRequiredDist$1) return dist;
  hasRequiredDist$1 = 1;
  (function(exports) {
    var __createBinding = dist && dist.__createBinding || (Object.create ? (function(o4, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o4, k22, desc);
    }) : (function(o4, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o4[k22] = m2[k2];
    }));
    var __exportStar = dist && dist.__exportStar || function(m2, exports2) {
      for (var p2 in m2) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.computeStorageFees = exports.computeMessageForwardFees = exports.computeGasPrices = exports.computeFwdFees = exports.computeExternalMessageFees = exports.loadConfigParamsAsSlice = exports.loadConfigParamById = exports.parseFullConfig = exports.parseVotingSetup = exports.parseValidatorSet = exports.parseProposalSetup = exports.parseBridge = exports.configParseWorkchainDescriptor = exports.configParseValidatorSet = exports.configParseMsgPrices = exports.configParseMasterAddressRequired = exports.configParseMasterAddress = exports.configParseGasLimitsPrices = exports.configParseBridge = exports.configParse40 = exports.configParse29 = exports.configParse28 = exports.configParse18 = exports.configParse17 = exports.configParse16 = exports.configParse15 = exports.configParse13 = exports.configParse12 = exports.configParse8 = exports.configParse5 = exports.ElectorContract = exports.MultisigWallet = exports.MultisigOrderBuilder = exports.MultisigOrder = exports.JettonWallet = exports.JettonMaster = exports.WalletContractV5R1 = exports.WalletContractV5Beta = exports.WalletContractV4 = exports.WalletContractV3R2 = exports.WalletContractV3R1 = exports.WalletContractV2R2 = exports.WalletContractV2R1 = exports.WalletContractV1R3 = exports.WalletContractV1R2 = exports.WalletContractV1R1 = exports.TonClient4 = exports.TonClient = exports.HttpApi = void 0;
    __exportStar(requireDist$4(), exports);
    var HttpApi_1 = requireHttpApi();
    Object.defineProperty(exports, "HttpApi", { enumerable: true, get: function() {
      return HttpApi_1.HttpApi;
    } });
    var TonClient_1 = requireTonClient();
    Object.defineProperty(exports, "TonClient", { enumerable: true, get: function() {
      return TonClient_1.TonClient;
    } });
    var TonClient4_1 = requireTonClient4();
    Object.defineProperty(exports, "TonClient4", { enumerable: true, get: function() {
      return TonClient4_1.TonClient4;
    } });
    var WalletContractV1R1_1 = requireWalletContractV1R1();
    Object.defineProperty(exports, "WalletContractV1R1", { enumerable: true, get: function() {
      return WalletContractV1R1_1.WalletContractV1R1;
    } });
    var WalletContractV1R2_1 = requireWalletContractV1R2();
    Object.defineProperty(exports, "WalletContractV1R2", { enumerable: true, get: function() {
      return WalletContractV1R2_1.WalletContractV1R2;
    } });
    var WalletContractV1R3_1 = requireWalletContractV1R3();
    Object.defineProperty(exports, "WalletContractV1R3", { enumerable: true, get: function() {
      return WalletContractV1R3_1.WalletContractV1R3;
    } });
    var WalletContractV2R1_1 = requireWalletContractV2R1();
    Object.defineProperty(exports, "WalletContractV2R1", { enumerable: true, get: function() {
      return WalletContractV2R1_1.WalletContractV2R1;
    } });
    var WalletContractV2R2_1 = requireWalletContractV2R2();
    Object.defineProperty(exports, "WalletContractV2R2", { enumerable: true, get: function() {
      return WalletContractV2R2_1.WalletContractV2R2;
    } });
    var WalletContractV3R1_1 = requireWalletContractV3R1();
    Object.defineProperty(exports, "WalletContractV3R1", { enumerable: true, get: function() {
      return WalletContractV3R1_1.WalletContractV3R1;
    } });
    var WalletContractV3R2_1 = requireWalletContractV3R2();
    Object.defineProperty(exports, "WalletContractV3R2", { enumerable: true, get: function() {
      return WalletContractV3R2_1.WalletContractV3R2;
    } });
    var WalletContractV4_1 = requireWalletContractV4();
    Object.defineProperty(exports, "WalletContractV4", { enumerable: true, get: function() {
      return WalletContractV4_1.WalletContractV4;
    } });
    var WalletContractV5Beta_1 = requireWalletContractV5Beta();
    Object.defineProperty(exports, "WalletContractV5Beta", { enumerable: true, get: function() {
      return WalletContractV5Beta_1.WalletContractV5Beta;
    } });
    var WalletContractV5R1_1 = requireWalletContractV5R1();
    Object.defineProperty(exports, "WalletContractV5R1", { enumerable: true, get: function() {
      return WalletContractV5R1_1.WalletContractV5R1;
    } });
    var JettonMaster_1 = requireJettonMaster();
    Object.defineProperty(exports, "JettonMaster", { enumerable: true, get: function() {
      return JettonMaster_1.JettonMaster;
    } });
    var JettonWallet_1 = requireJettonWallet();
    Object.defineProperty(exports, "JettonWallet", { enumerable: true, get: function() {
      return JettonWallet_1.JettonWallet;
    } });
    var MultisigOrder_1 = requireMultisigOrder();
    Object.defineProperty(exports, "MultisigOrder", { enumerable: true, get: function() {
      return MultisigOrder_1.MultisigOrder;
    } });
    var MultisigOrderBuilder_1 = requireMultisigOrderBuilder();
    Object.defineProperty(exports, "MultisigOrderBuilder", { enumerable: true, get: function() {
      return MultisigOrderBuilder_1.MultisigOrderBuilder;
    } });
    var MultisigWallet_1 = requireMultisigWallet();
    Object.defineProperty(exports, "MultisigWallet", { enumerable: true, get: function() {
      return MultisigWallet_1.MultisigWallet;
    } });
    var ElectorContract_1 = requireElectorContract();
    Object.defineProperty(exports, "ElectorContract", { enumerable: true, get: function() {
      return ElectorContract_1.ElectorContract;
    } });
    var ConfigParser_1 = requireConfigParser();
    Object.defineProperty(exports, "configParse5", { enumerable: true, get: function() {
      return ConfigParser_1.configParse5;
    } });
    Object.defineProperty(exports, "configParse8", { enumerable: true, get: function() {
      return ConfigParser_1.configParse8;
    } });
    Object.defineProperty(exports, "configParse12", { enumerable: true, get: function() {
      return ConfigParser_1.configParse12;
    } });
    Object.defineProperty(exports, "configParse13", { enumerable: true, get: function() {
      return ConfigParser_1.configParse13;
    } });
    Object.defineProperty(exports, "configParse15", { enumerable: true, get: function() {
      return ConfigParser_1.configParse15;
    } });
    Object.defineProperty(exports, "configParse16", { enumerable: true, get: function() {
      return ConfigParser_1.configParse16;
    } });
    Object.defineProperty(exports, "configParse17", { enumerable: true, get: function() {
      return ConfigParser_1.configParse17;
    } });
    Object.defineProperty(exports, "configParse18", { enumerable: true, get: function() {
      return ConfigParser_1.configParse18;
    } });
    Object.defineProperty(exports, "configParse28", { enumerable: true, get: function() {
      return ConfigParser_1.configParse28;
    } });
    Object.defineProperty(exports, "configParse29", { enumerable: true, get: function() {
      return ConfigParser_1.configParse29;
    } });
    Object.defineProperty(exports, "configParse40", { enumerable: true, get: function() {
      return ConfigParser_1.configParse40;
    } });
    Object.defineProperty(exports, "configParseBridge", { enumerable: true, get: function() {
      return ConfigParser_1.configParseBridge;
    } });
    Object.defineProperty(exports, "configParseGasLimitsPrices", { enumerable: true, get: function() {
      return ConfigParser_1.configParseGasLimitsPrices;
    } });
    Object.defineProperty(exports, "configParseMasterAddress", { enumerable: true, get: function() {
      return ConfigParser_1.configParseMasterAddress;
    } });
    Object.defineProperty(exports, "configParseMasterAddressRequired", { enumerable: true, get: function() {
      return ConfigParser_1.configParseMasterAddressRequired;
    } });
    Object.defineProperty(exports, "configParseMsgPrices", { enumerable: true, get: function() {
      return ConfigParser_1.configParseMsgPrices;
    } });
    Object.defineProperty(exports, "configParseValidatorSet", { enumerable: true, get: function() {
      return ConfigParser_1.configParseValidatorSet;
    } });
    Object.defineProperty(exports, "configParseWorkchainDescriptor", { enumerable: true, get: function() {
      return ConfigParser_1.configParseWorkchainDescriptor;
    } });
    Object.defineProperty(exports, "parseBridge", { enumerable: true, get: function() {
      return ConfigParser_1.parseBridge;
    } });
    Object.defineProperty(exports, "parseProposalSetup", { enumerable: true, get: function() {
      return ConfigParser_1.parseProposalSetup;
    } });
    Object.defineProperty(exports, "parseValidatorSet", { enumerable: true, get: function() {
      return ConfigParser_1.parseValidatorSet;
    } });
    Object.defineProperty(exports, "parseVotingSetup", { enumerable: true, get: function() {
      return ConfigParser_1.parseVotingSetup;
    } });
    Object.defineProperty(exports, "parseFullConfig", { enumerable: true, get: function() {
      return ConfigParser_1.parseFullConfig;
    } });
    Object.defineProperty(exports, "loadConfigParamById", { enumerable: true, get: function() {
      return ConfigParser_1.loadConfigParamById;
    } });
    Object.defineProperty(exports, "loadConfigParamsAsSlice", { enumerable: true, get: function() {
      return ConfigParser_1.loadConfigParamsAsSlice;
    } });
    var fees_1 = requireFees();
    Object.defineProperty(exports, "computeExternalMessageFees", { enumerable: true, get: function() {
      return fees_1.computeExternalMessageFees;
    } });
    Object.defineProperty(exports, "computeFwdFees", { enumerable: true, get: function() {
      return fees_1.computeFwdFees;
    } });
    Object.defineProperty(exports, "computeGasPrices", { enumerable: true, get: function() {
      return fees_1.computeGasPrices;
    } });
    Object.defineProperty(exports, "computeMessageForwardFees", { enumerable: true, get: function() {
      return fees_1.computeMessageForwardFees;
    } });
    Object.defineProperty(exports, "computeStorageFees", { enumerable: true, get: function() {
      return fees_1.computeStorageFees;
    } });
  })(dist);
  return dist;
}
var lib = {};
var nodes = {};
var g = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || // eslint-disable-next-line no-undef
typeof global !== "undefined" && global || {};
var support = {
  searchParams: "URLSearchParams" in g,
  iterable: "Symbol" in g && "iterator" in Symbol,
  blob: "FileReader" in g && "Blob" in g && (function() {
    try {
      new Blob();
      return true;
    } catch (e) {
      return false;
    }
  })(),
  formData: "FormData" in g,
  arrayBuffer: "ArrayBuffer" in g
};
function isDataView(obj) {
  return obj && DataView.prototype.isPrototypeOf(obj);
}
if (support.arrayBuffer) {
  var viewClasses = [
    "[object Int8Array]",
    "[object Uint8Array]",
    "[object Uint8ClampedArray]",
    "[object Int16Array]",
    "[object Uint16Array]",
    "[object Int32Array]",
    "[object Uint32Array]",
    "[object Float32Array]",
    "[object Float64Array]"
  ];
  var isArrayBufferView = ArrayBuffer.isView || function(obj) {
    return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
  };
}
function normalizeName(name) {
  if (typeof name !== "string") {
    name = String(name);
  }
  if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
    throw new TypeError('Invalid character in header field name: "' + name + '"');
  }
  return name.toLowerCase();
}
function normalizeValue(value) {
  if (typeof value !== "string") {
    value = String(value);
  }
  return value;
}
function iteratorFor(items) {
  var iterator = {
    next: function() {
      var value = items.shift();
      return { done: value === void 0, value };
    }
  };
  if (support.iterable) {
    iterator[Symbol.iterator] = function() {
      return iterator;
    };
  }
  return iterator;
}
function Headers$1(headers) {
  this.map = {};
  if (headers instanceof Headers$1) {
    headers.forEach(function(value, name) {
      this.append(name, value);
    }, this);
  } else if (Array.isArray(headers)) {
    headers.forEach(function(header) {
      if (header.length != 2) {
        throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + header.length);
      }
      this.append(header[0], header[1]);
    }, this);
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function(name) {
      this.append(name, headers[name]);
    }, this);
  }
}
Headers$1.prototype.append = function(name, value) {
  name = normalizeName(name);
  value = normalizeValue(value);
  var oldValue = this.map[name];
  this.map[name] = oldValue ? oldValue + ", " + value : value;
};
Headers$1.prototype["delete"] = function(name) {
  delete this.map[normalizeName(name)];
};
Headers$1.prototype.get = function(name) {
  name = normalizeName(name);
  return this.has(name) ? this.map[name] : null;
};
Headers$1.prototype.has = function(name) {
  return this.map.hasOwnProperty(normalizeName(name));
};
Headers$1.prototype.set = function(name, value) {
  this.map[normalizeName(name)] = normalizeValue(value);
};
Headers$1.prototype.forEach = function(callback, thisArg) {
  for (var name in this.map) {
    if (this.map.hasOwnProperty(name)) {
      callback.call(thisArg, this.map[name], name, this);
    }
  }
};
Headers$1.prototype.keys = function() {
  var items = [];
  this.forEach(function(value, name) {
    items.push(name);
  });
  return iteratorFor(items);
};
Headers$1.prototype.values = function() {
  var items = [];
  this.forEach(function(value) {
    items.push(value);
  });
  return iteratorFor(items);
};
Headers$1.prototype.entries = function() {
  var items = [];
  this.forEach(function(value, name) {
    items.push([name, value]);
  });
  return iteratorFor(items);
};
if (support.iterable) {
  Headers$1.prototype[Symbol.iterator] = Headers$1.prototype.entries;
}
function consumed(body) {
  if (body._noBody) return;
  if (body.bodyUsed) {
    return Promise.reject(new TypeError("Already read"));
  }
  body.bodyUsed = true;
}
function fileReaderReady(reader2) {
  return new Promise(function(resolve, reject) {
    reader2.onload = function() {
      resolve(reader2.result);
    };
    reader2.onerror = function() {
      reject(reader2.error);
    };
  });
}
function readBlobAsArrayBuffer(blob) {
  var reader2 = new FileReader();
  var promise = fileReaderReady(reader2);
  reader2.readAsArrayBuffer(blob);
  return promise;
}
function readBlobAsText(blob) {
  var reader2 = new FileReader();
  var promise = fileReaderReady(reader2);
  var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
  var encoding2 = match ? match[1] : "utf-8";
  reader2.readAsText(blob, encoding2);
  return promise;
}
function readArrayBufferAsText(buf2) {
  var view = new Uint8Array(buf2);
  var chars = new Array(view.length);
  for (var i = 0; i < view.length; i++) {
    chars[i] = String.fromCharCode(view[i]);
  }
  return chars.join("");
}
function bufferClone(buf2) {
  if (buf2.slice) {
    return buf2.slice(0);
  } else {
    var view = new Uint8Array(buf2.byteLength);
    view.set(new Uint8Array(buf2));
    return view.buffer;
  }
}
function Body() {
  this.bodyUsed = false;
  this._initBody = function(body) {
    this.bodyUsed = this.bodyUsed;
    this._bodyInit = body;
    if (!body) {
      this._noBody = true;
      this._bodyText = "";
    } else if (typeof body === "string") {
      this._bodyText = body;
    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
      this._bodyBlob = body;
    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
      this._bodyFormData = body;
    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
      this._bodyText = body.toString();
    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
      this._bodyArrayBuffer = bufferClone(body.buffer);
      this._bodyInit = new Blob([this._bodyArrayBuffer]);
    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
      this._bodyArrayBuffer = bufferClone(body);
    } else {
      this._bodyText = body = Object.prototype.toString.call(body);
    }
    if (!this.headers.get("content-type")) {
      if (typeof body === "string") {
        this.headers.set("content-type", "text/plain;charset=UTF-8");
      } else if (this._bodyBlob && this._bodyBlob.type) {
        this.headers.set("content-type", this._bodyBlob.type);
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
      }
    }
  };
  if (support.blob) {
    this.blob = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected;
      }
      if (this._bodyBlob) {
        return Promise.resolve(this._bodyBlob);
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(new Blob([this._bodyArrayBuffer]));
      } else if (this._bodyFormData) {
        throw new Error("could not read FormData body as blob");
      } else {
        return Promise.resolve(new Blob([this._bodyText]));
      }
    };
  }
  this.arrayBuffer = function() {
    if (this._bodyArrayBuffer) {
      var isConsumed = consumed(this);
      if (isConsumed) {
        return isConsumed;
      } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
        return Promise.resolve(
          this._bodyArrayBuffer.buffer.slice(
            this._bodyArrayBuffer.byteOffset,
            this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
          )
        );
      } else {
        return Promise.resolve(this._bodyArrayBuffer);
      }
    } else if (support.blob) {
      return this.blob().then(readBlobAsArrayBuffer);
    } else {
      throw new Error("could not read as ArrayBuffer");
    }
  };
  this.text = function() {
    var rejected = consumed(this);
    if (rejected) {
      return rejected;
    }
    if (this._bodyBlob) {
      return readBlobAsText(this._bodyBlob);
    } else if (this._bodyArrayBuffer) {
      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
    } else if (this._bodyFormData) {
      throw new Error("could not read FormData body as text");
    } else {
      return Promise.resolve(this._bodyText);
    }
  };
  if (support.formData) {
    this.formData = function() {
      return this.text().then(decode);
    };
  }
  this.json = function() {
    return this.text().then(JSON.parse);
  };
  return this;
}
var methods = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
function normalizeMethod(method) {
  var upcased = method.toUpperCase();
  return methods.indexOf(upcased) > -1 ? upcased : method;
}
function Request$1(input, options) {
  if (!(this instanceof Request$1)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  }
  options = options || {};
  var body = options.body;
  if (input instanceof Request$1) {
    if (input.bodyUsed) {
      throw new TypeError("Already read");
    }
    this.url = input.url;
    this.credentials = input.credentials;
    if (!options.headers) {
      this.headers = new Headers$1(input.headers);
    }
    this.method = input.method;
    this.mode = input.mode;
    this.signal = input.signal;
    if (!body && input._bodyInit != null) {
      body = input._bodyInit;
      input.bodyUsed = true;
    }
  } else {
    this.url = String(input);
  }
  this.credentials = options.credentials || this.credentials || "same-origin";
  if (options.headers || !this.headers) {
    this.headers = new Headers$1(options.headers);
  }
  this.method = normalizeMethod(options.method || this.method || "GET");
  this.mode = options.mode || this.mode || null;
  this.signal = options.signal || this.signal || (function() {
    if ("AbortController" in g) {
      var ctrl = new AbortController();
      return ctrl.signal;
    }
  })();
  this.referrer = null;
  if ((this.method === "GET" || this.method === "HEAD") && body) {
    throw new TypeError("Body not allowed for GET or HEAD requests");
  }
  this._initBody(body);
  if (this.method === "GET" || this.method === "HEAD") {
    if (options.cache === "no-store" || options.cache === "no-cache") {
      var reParamSearch = /([?&])_=[^&]*/;
      if (reParamSearch.test(this.url)) {
        this.url = this.url.replace(reParamSearch, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
      } else {
        var reQueryString = /\?/;
        this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
      }
    }
  }
}
Request$1.prototype.clone = function() {
  return new Request$1(this, { body: this._bodyInit });
};
function decode(body) {
  var form = new FormData();
  body.trim().split("&").forEach(function(bytes) {
    if (bytes) {
      var split = bytes.split("=");
      var name = split.shift().replace(/\+/g, " ");
      var value = split.join("=").replace(/\+/g, " ");
      form.append(decodeURIComponent(name), decodeURIComponent(value));
    }
  });
  return form;
}
function parseHeaders(rawHeaders) {
  var headers = new Headers$1();
  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
  preProcessedHeaders.split("\r").map(function(header) {
    return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
  }).forEach(function(line) {
    var parts = line.split(":");
    var key2 = parts.shift().trim();
    if (key2) {
      var value = parts.join(":").trim();
      try {
        headers.append(key2, value);
      } catch (error2) {
        console.warn("Response " + error2.message);
      }
    }
  });
  return headers;
}
Body.call(Request$1.prototype);
function Response$1(bodyInit, options) {
  if (!(this instanceof Response$1)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  }
  if (!options) {
    options = {};
  }
  this.type = "default";
  this.status = options.status === void 0 ? 200 : options.status;
  if (this.status < 200 || this.status > 599) {
    throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
  }
  this.ok = this.status >= 200 && this.status < 300;
  this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
  this.headers = new Headers$1(options.headers);
  this.url = options.url || "";
  this._initBody(bodyInit);
}
Body.call(Response$1.prototype);
Response$1.prototype.clone = function() {
  return new Response$1(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new Headers$1(this.headers),
    url: this.url
  });
};
Response$1.error = function() {
  var response = new Response$1(null, { status: 200, statusText: "" });
  response.ok = false;
  response.status = 0;
  response.type = "error";
  return response;
};
var redirectStatuses = [301, 302, 303, 307, 308];
Response$1.redirect = function(url, status) {
  if (redirectStatuses.indexOf(status) === -1) {
    throw new RangeError("Invalid status code");
  }
  return new Response$1(null, { status, headers: { location: url } });
};
var DOMException = g.DOMException;
try {
  new DOMException();
} catch (err) {
  DOMException = function(message, name) {
    this.message = message;
    this.name = name;
    var error2 = Error(message);
    this.stack = error2.stack;
  };
  DOMException.prototype = Object.create(Error.prototype);
  DOMException.prototype.constructor = DOMException;
}
function fetch$1(input, init) {
  return new Promise(function(resolve, reject) {
    var request = new Request$1(input, init);
    if (request.signal && request.signal.aborted) {
      return reject(new DOMException("Aborted", "AbortError"));
    }
    var xhr = new XMLHttpRequest();
    function abortXhr() {
      xhr.abort();
    }
    xhr.onload = function() {
      var options = {
        statusText: xhr.statusText,
        headers: parseHeaders(xhr.getAllResponseHeaders() || "")
      };
      if (request.url.indexOf("file://") === 0 && (xhr.status < 200 || xhr.status > 599)) {
        options.status = 200;
      } else {
        options.status = xhr.status;
      }
      options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
      var body = "response" in xhr ? xhr.response : xhr.responseText;
      setTimeout(function() {
        resolve(new Response$1(body, options));
      }, 0);
    };
    xhr.onerror = function() {
      setTimeout(function() {
        reject(new TypeError("Network request failed"));
      }, 0);
    };
    xhr.ontimeout = function() {
      setTimeout(function() {
        reject(new TypeError("Network request timed out"));
      }, 0);
    };
    xhr.onabort = function() {
      setTimeout(function() {
        reject(new DOMException("Aborted", "AbortError"));
      }, 0);
    };
    function fixUrl(url) {
      try {
        return url === "" && g.location.href ? g.location.href : url;
      } catch (e) {
        return url;
      }
    }
    xhr.open(request.method, fixUrl(request.url), true);
    if (request.credentials === "include") {
      xhr.withCredentials = true;
    } else if (request.credentials === "omit") {
      xhr.withCredentials = false;
    }
    if ("responseType" in xhr) {
      if (support.blob) {
        xhr.responseType = "blob";
      } else if (support.arrayBuffer) {
        xhr.responseType = "arraybuffer";
      }
    }
    if (init && typeof init.headers === "object" && !(init.headers instanceof Headers$1 || g.Headers && init.headers instanceof g.Headers)) {
      var names = [];
      Object.getOwnPropertyNames(init.headers).forEach(function(name) {
        names.push(normalizeName(name));
        xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
      });
      request.headers.forEach(function(value, name) {
        if (names.indexOf(name) === -1) {
          xhr.setRequestHeader(name, value);
        }
      });
    } else {
      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });
    }
    if (request.signal) {
      request.signal.addEventListener("abort", abortXhr);
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
          request.signal.removeEventListener("abort", abortXhr);
        }
      };
    }
    xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
  });
}
fetch$1.polyfill = true;
if (!g.fetch) {
  g.fetch = fetch$1;
  g.Headers = Headers$1;
  g.Request = Request$1;
  g.Response = Response$1;
}
var fetchNpmBrowserify;
var hasRequiredFetchNpmBrowserify;
function requireFetchNpmBrowserify() {
  if (hasRequiredFetchNpmBrowserify) return fetchNpmBrowserify;
  hasRequiredFetchNpmBrowserify = 1;
  fetchNpmBrowserify = self.fetch.bind(self);
  return fetchNpmBrowserify;
}
var hasRequiredNodes;
function requireNodes() {
  if (hasRequiredNodes) return nodes;
  hasRequiredNodes = 1;
  var __awaiter = nodes && nodes.__awaiter || function(thisArg, _arguments, P2, generator2) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator2.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator2["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator2 = generator2.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(nodes, "__esModule", { value: true });
  nodes.Nodes = void 0;
  requireFetchNpmBrowserify();
  class Nodes {
    ///////////////////////////////////
    constructor() {
      this.nodeIndex = -1;
      this.committee = /* @__PURE__ */ new Set();
      this.topology = [];
      this.initTime = 0;
    }
    ///////////////////////////////////
    init(nodesUrl) {
      return __awaiter(this, void 0, void 0, function* () {
        this.nodeIndex = -1;
        this.committee.clear();
        this.topology = [];
        this.initTime = Date.now();
        let topology = [];
        try {
          const response = yield fetch(nodesUrl);
          const data = yield response.json();
          topology = data;
        } catch (e) {
          throw new Error(`exception in fetch(${nodesUrl}): ${e}`);
        }
        for (const node of topology) {
          if (node.Healthy === "1") {
            this.topology.push(node);
          }
        }
        if (this.topology.length === 0)
          throw new Error(`no healthy nodes in ${nodesUrl}`);
      });
    }
    getHealthyFor(protonet) {
      var _a2;
      const res = [];
      for (const node of this.topology) {
        if (node.Weight > 0 && ((_a2 = node.Mngr) === null || _a2 === void 0 ? void 0 : _a2.health[protonet])) {
          res.push(node);
        }
      }
      return res;
    }
  }
  nodes.Nodes = Nodes;
  return nodes;
}
const version = "2.3.3";
const require$$1$1 = {
  version
};
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib;
  hasRequiredLib = 1;
  var __awaiter = lib && lib.__awaiter || function(thisArg, _arguments, P2, generator2) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator2.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator2["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator2 = generator2.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(lib, "__esModule", { value: true });
  lib.getHttpV4Endpoint = lib.getHttpV4Endpoints = lib.getHttpEndpoint = lib.getHttpEndpoints = lib.Access = void 0;
  const nodes_1 = requireNodes();
  class Access {
    //////////////////////////////////
    constructor() {
      this.host = "ton.access.orbs.network";
      this.urlVersion = 1;
      this.nodes = new nodes_1.Nodes();
    }
    //////////////////////////////////
    init() {
      return __awaiter(this, void 0, void 0, function* () {
        const pjson = require$$1$1;
        yield this.nodes.init(`https://${this.host}/mngr/nodes?npm_version=${pjson.version}`);
      });
    }
    //////////////////////////////////
    makeProtonet(edgeProtocol, network) {
      let res = "";
      switch (edgeProtocol) {
        case "toncenter-api-v2":
          res += "v2-";
          break;
        case "ton-api-v4":
          res += "v4-";
          break;
      }
      res += network;
      return res;
    }
    //////////////////////////////////
    weightedRandom(nodes2) {
      let sumWeights = 0;
      for (const node of nodes2) {
        sumWeights += node.Weight;
      }
      const rnd = Math.floor(Math.random() * sumWeights);
      let cur = 0;
      for (const node of nodes2) {
        if (rnd >= cur && rnd < cur + node.Weight)
          return node;
        cur += node.Weight;
      }
    }
    //////////////////////////////////
    buildUrls(network, edgeProtocol, suffix, single) {
      if (!suffix)
        suffix = "";
      if (!edgeProtocol)
        edgeProtocol = "toncenter-api-v2";
      if (!network)
        network = "mainnet";
      if (suffix.length)
        suffix = suffix.replace(/^\/+/, "");
      const res = [];
      const protonet = this.makeProtonet(edgeProtocol, network);
      let healthyNodes = this.nodes.getHealthyFor(protonet);
      if (!(healthyNodes === null || healthyNodes === void 0 ? void 0 : healthyNodes.length))
        throw new Error(`no healthy nodes for ${protonet}`);
      if (single && healthyNodes.length) {
        const chosen = this.weightedRandom(healthyNodes);
        if (chosen)
          healthyNodes = [chosen];
        else
          throw new Error("weightedRandom return empty");
      }
      for (const node of healthyNodes) {
        let url = `https://${this.host}/${node.NodeId}/${this.urlVersion}/${network}/${edgeProtocol}`;
        if (suffix.length)
          url += `/${suffix}`;
        res.push(url);
      }
      return res;
    }
  }
  lib.Access = Access;
  function getEndpoints(network, edgeProtocol, suffix, single) {
    return __awaiter(this, void 0, void 0, function* () {
      const access = new Access();
      yield access.init();
      const res = access.buildUrls(network, edgeProtocol, suffix, single);
      return res;
    });
  }
  function getHttpEndpoints(config, single) {
    return __awaiter(this, void 0, void 0, function* () {
      const network = (config === null || config === void 0 ? void 0 : config.network) ? config.network : "mainnet";
      let suffix = "jsonRPC";
      if ((config === null || config === void 0 ? void 0 : config.protocol) === "rest") {
        suffix = "";
      }
      return yield getEndpoints(network, "toncenter-api-v2", suffix, single);
    });
  }
  lib.getHttpEndpoints = getHttpEndpoints;
  function getHttpEndpoint(config) {
    return __awaiter(this, void 0, void 0, function* () {
      const endpoints = yield getHttpEndpoints(config, true);
      return endpoints[0];
    });
  }
  lib.getHttpEndpoint = getHttpEndpoint;
  function getHttpV4Endpoints(config, single) {
    return __awaiter(this, void 0, void 0, function* () {
      const network = (config === null || config === void 0 ? void 0 : config.network) ? config.network : "mainnet";
      if ((config === null || config === void 0 ? void 0 : config.protocol) === "json-rpc") {
        throw Error("config.protocol json-rpc is not supported for getTonApiV4Endpoints");
      }
      const suffix = "";
      return yield getEndpoints(network, "ton-api-v4", suffix, single);
    });
  }
  lib.getHttpV4Endpoints = getHttpV4Endpoints;
  function getHttpV4Endpoint(config) {
    return __awaiter(this, void 0, void 0, function* () {
      const endpoints = yield getHttpV4Endpoints(config, true);
      return endpoints[0];
    });
  }
  lib.getHttpV4Endpoint = getHttpV4Endpoint;
  return lib;
}
var hasRequiredTonClientApi;
function requireTonClientApi() {
  if (hasRequiredTonClientApi) return tonClientApi;
  hasRequiredTonClientApi = 1;
  Object.defineProperty(tonClientApi, "__esModule", { value: true });
  tonClientApi.createApi = void 0;
  const ton_1 = requireDist$1();
  const ton_access_1 = requireLib();
  async function createApi(network) {
    const endpoint = await (0, ton_access_1.getHttpV4Endpoint)({ network });
    return new ton_1.TonClient4({ endpoint, timeout: 15e3 });
  }
  tonClientApi.createApi = createApi;
  return tonClientApi;
}
var key = {};
var hasRequiredKey;
function requireKey() {
  if (hasRequiredKey) return key;
  hasRequiredKey = 1;
  Object.defineProperty(key, "__esModule", { value: true });
  key.importKey = void 0;
  const crypto_1 = requireDist$5();
  async function importKey(key2) {
    if (typeof key2 === "string") {
      return await (0, crypto_1.mnemonicToWalletKey)(key2.split(" "));
    } else if (Array.isArray(key2)) {
      return await (0, crypto_1.mnemonicToWalletKey)(key2);
    } else {
      return (0, crypto_1.keyPairFromSecretKey)(key2);
    }
  }
  key.importKey = importKey;
  return key;
}
var wallets = {};
var HighloadWalletContractV2 = {};
var hasRequiredHighloadWalletContractV2;
function requireHighloadWalletContractV2() {
  if (hasRequiredHighloadWalletContractV2) return HighloadWalletContractV2;
  hasRequiredHighloadWalletContractV2 = 1;
  Object.defineProperty(HighloadWalletContractV2, "__esModule", { value: true });
  HighloadWalletContractV2.HighloadWalletContractV2 = void 0;
  const core_1 = requireDist$4();
  const crypto_1 = requireDist$5();
  const utils_1 = requireUtils$1();
  let HighloadWalletContractV2$1 = class HighloadWalletContractV22 {
    constructor(workchain, publicKey, walletId) {
      this.workchain = workchain;
      this.publicKey = publicKey;
      if (walletId !== null && walletId !== void 0) {
        this.walletId = walletId;
      } else {
        this.walletId = 698983191 + workchain;
      }
      const code = core_1.Cell.fromBase64("te6cckEBCQEA5QABFP8A9KQT9LzyyAsBAgEgAgMCAUgEBQHq8oMI1xgg0x/TP/gjqh9TILnyY+1E0NMf0z/T//QE0VNggED0Dm+hMfJgUXO68qIH+QFUEIf5EPKjAvQE0fgAf44WIYAQ9HhvpSCYAtMH1DAB+wCRMuIBs+ZbgyWhyEA0gED0Q4rmMQHIyx8Tyz/L//QAye1UCAAE0DACASAGBwAXvZznaiaGmvmOuF/8AEG+X5dqJoaY+Y6Z/p/5j6AmipEEAgegc30JjJLb/JXdHxQANCCAQPSWb6VsEiCUMFMDud4gkzM2AZJsIeKzn55UWg==");
      const data = (0, core_1.beginCell)().storeUint(this.walletId, 32).storeUint(0, 64).storeBuffer(this.publicKey, 32).storeDict(null).endCell();
      this.init = { code, data };
      this.address = (0, core_1.contractAddress)(this.workchain, this.init);
    }
    static create(args) {
      return new HighloadWalletContractV22(args.workchain, args.publicKey, args.walletId);
    }
    /**
     * Get wallet balance.
     */
    async getBalance(provider) {
      const state = await provider.getState();
      return state.balance;
    }
    /**
     * Send signed message.
     */
    async send(provider, message) {
      await provider.external(message);
    }
    /**
     * Sign and send message.
     */
    async sendTransfer(provider, args) {
      const message = this.createTransfer(args);
      await this.send(provider, message);
    }
    /**
     * Create signed message.
     */
    createTransfer(args) {
      let seqno = Math.floor(Math.random() * (1 << 32));
      if (args.seqno !== null && args.seqno !== void 0) {
        seqno = args.seqno;
      }
      let timeout = 5 * 60;
      if (args.timeout !== null && args.timeout !== void 0 && args.timeout < timeout) {
        timeout = args.timeout;
      }
      let sendMode = core_1.SendMode.PAY_GAS_SEPARATELY | core_1.SendMode.IGNORE_ERRORS;
      if (args.sendMode !== null && args.sendMode !== void 0) {
        sendMode = args.sendMode;
      }
      let now = Date.now();
      if (args.now !== null && args.now !== void 0) {
        now = args.now;
      }
      return (0, core_1.beginCell)().store(storeSignedTransferHighloadWalletV2({
        secretKey: args.secretKey,
        messages: args.messages,
        seqno,
        sendMode,
        timeout,
        walletId: this.walletId,
        now
      })).endCell();
    }
    /**
     * Load signed message.
     */
    loadTransfer(src2) {
      return loadSignedTransferHighloadWalletV2(src2);
    }
    /**
     * Send signed message and wait for processing.
     */
    async sendTransferAndWait(provider, args, sleepInterval = 3e3) {
      const transfer = this.createTransfer(args);
      const { queryId } = this.loadTransfer(transfer.beginParse());
      while (true) {
        try {
          await provider.external(transfer);
        } catch (e) {
        }
        await (0, utils_1.sleep)(sleepInterval);
        const state = await provider.getState();
        if (state.state.type === "uninit") {
          continue;
        }
        const status = await this.getProcessedStatus(provider, queryId);
        if (status === "processed") {
          return;
        } else if (status === "forgotten") {
          throw new Error("The transfer was forgotten");
        }
      }
    }
    /**
     * Get processed status of message.
     */
    async getProcessedStatus(provider, queryId) {
      const { stack } = await provider.get("processed?", [{ type: "int", value: queryId }]);
      const processedStatus = stack.readBigNumber();
      switch (processedStatus) {
        case -1n:
          return "processed";
        case 0n:
          return "unprocessed";
        case 1n:
          return "forgotten";
        default:
          throw new Error("Unknown processed status " + processedStatus);
      }
    }
    /**
     * Create sender.
     */
    sender(provider, secretKey) {
      return {
        send: async (args) => {
          await this.sendTransferAndWait(provider, {
            secretKey,
            sendMode: args.sendMode,
            messages: [(0, core_1.internal)({
              to: args.to,
              value: args.value,
              bounce: args.bounce,
              init: args.init,
              body: args.body
            })]
          });
        },
        address: this.address
      };
    }
  };
  HighloadWalletContractV2.HighloadWalletContractV2 = HighloadWalletContractV2$1;
  function createMessageRelaxedValue() {
    return {
      serialize: (args, builder2) => {
        const { sendMode, message } = args;
        const messageRelaxed = (0, core_1.beginCell)().storeWritable((0, core_1.storeMessageRelaxed)(message));
        builder2.storeUint(sendMode, 8);
        builder2.storeRef(messageRelaxed);
      },
      parse: (src2) => {
        const sendMode = src2.loadUint(8);
        const message = (0, core_1.loadMessageRelaxed)(src2.loadRef().beginParse());
        return { sendMode, message };
      }
    };
  }
  function getQueryId(now, timeout, seqno) {
    const validUntil = Math.floor(now / 1e3) + timeout;
    return (BigInt(validUntil) << 32n) + BigInt(seqno);
  }
  function storeSignedTransferHighloadWalletV2(args) {
    return (builder2) => {
      const { secretKey, messages, seqno, sendMode, now, timeout, walletId } = args;
      const queryId = getQueryId(now, timeout, seqno);
      const dict = core_1.Dictionary.empty(core_1.Dictionary.Keys.Int(16), createMessageRelaxedValue());
      for (const [i, message] of messages.entries()) {
        dict.set(i, { sendMode, message });
      }
      const signedMessage = (0, core_1.beginCell)().storeUint(walletId, 32).storeUint(queryId, 64).storeDict(dict).endCell();
      const hash = signedMessage.hash();
      const signature = (0, crypto_1.sign)(hash, secretKey);
      builder2.storeBuffer(signature);
      builder2.storeSlice(signedMessage.beginParse());
    };
  }
  function loadSignedTransferHighloadWalletV2(src2) {
    const signature = src2.loadBuffer(64);
    const walletId = src2.loadUint(32);
    const queryId = src2.loadUintBig(64);
    const dict = src2.loadDict(core_1.Dictionary.Keys.Int(16), createMessageRelaxedValue());
    const messages = dict.values();
    return {
      signature,
      walletId,
      queryId,
      messages
    };
  }
  return HighloadWalletContractV2;
}
var hasRequiredWallets;
function requireWallets() {
  if (hasRequiredWallets) return wallets;
  hasRequiredWallets = 1;
  Object.defineProperty(wallets, "__esModule", { value: true });
  wallets.createSender = wallets.createWallet = wallets.createHighloadV2 = void 0;
  const HighloadWalletContractV2_1 = requireHighloadWalletContractV2();
  const ton_client_api_1 = requireTonClientApi();
  const WORKCHAIN = 0;
  function createHighloadV2(publicKey) {
    return HighloadWalletContractV2_1.HighloadWalletContractV2.create({ workchain: WORKCHAIN, publicKey });
  }
  wallets.createHighloadV2 = createHighloadV2;
  function createWallet(walletType, publicKey) {
    switch (walletType) {
      case "highload-v2":
        return createHighloadV2(publicKey);
      default:
        throw new Error("Unsupported wallet type");
    }
  }
  wallets.createWallet = createWallet;
  async function createSender(walletType, keypair, clientOrNetwork) {
    const isNetwork = clientOrNetwork === "testnet" || clientOrNetwork === "mainnet";
    const client = isNetwork ? await (0, ton_client_api_1.createApi)(clientOrNetwork) : clientOrNetwork;
    const wallet = createWallet(walletType, keypair.publicKey);
    return client.open(wallet).sender(keypair.secretKey);
  }
  wallets.createSender = createSender;
  return wallets;
}
var error = {};
var hasRequiredError;
function requireError() {
  if (hasRequiredError) return error;
  hasRequiredError = 1;
  Object.defineProperty(error, "__esModule", { value: true });
  error.NoSenderError = void 0;
  class NoSenderError extends Error {
    constructor() {
      super("Sender is not set");
    }
  }
  error.NoSenderError = NoSenderError;
  return error;
}
var TonAPI = {};
var hasRequiredTonAPI;
function requireTonAPI() {
  if (hasRequiredTonAPI) return TonAPI;
  hasRequiredTonAPI = 1;
  var __importDefault = TonAPI && TonAPI.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(TonAPI, "__esModule", { value: true });
  TonAPI.TonAPI = void 0;
  const core_1 = requireDist$4();
  const zod_1 = __importDefault(/* @__PURE__ */ requireZod());
  const axios_12 = __importDefault(/* @__PURE__ */ requireAxios());
  const Address2 = zod_1.default.string().transform((v2) => core_1.Address.parseRaw(v2));
  const HexBuffer = zod_1.default.string().transform((v2) => Buffer.from(v2, "hex"));
  const zBigint = zod_1.default.union([zod_1.default.number(), zod_1.default.string()]).transform((v2) => BigInt(v2));
  const zStrnum = zod_1.default.union([zod_1.default.number(), zod_1.default.string()]).transform((v2) => Number(v2));
  const ImagePreview = zod_1.default.object({
    resolution: zod_1.default.string(),
    url: zod_1.default.string()
  });
  const AccountAddress = zod_1.default.object({
    address: Address2,
    name: zod_1.default.optional(zod_1.default.string()),
    is_scam: zod_1.default.boolean(),
    icon: zod_1.default.optional(zod_1.default.string()),
    is_wallet: zod_1.default.boolean()
  });
  const NftCollection2 = zod_1.default.object({
    address: Address2,
    next_item_index: zBigint,
    owner: zod_1.default.optional(AccountAddress),
    metadata: zod_1.default.optional(zod_1.default.record(zod_1.default.any())),
    raw_collection_content: HexBuffer,
    previews: zod_1.default.optional(zod_1.default.array(ImagePreview)),
    approved_by: zod_1.default.array(zod_1.default.string())
  });
  const NftCollections = zod_1.default.object({
    nft_collections: zod_1.default.array(NftCollection2)
  });
  const Price = zod_1.default.object({
    value: zBigint,
    token_name: zod_1.default.string()
  });
  const Sale = zod_1.default.object({
    address: Address2,
    market: AccountAddress,
    owner: zod_1.default.optional(AccountAddress),
    price: Price
  });
  const NftItem2 = zod_1.default.object({
    address: Address2,
    index: zBigint,
    owner: zod_1.default.optional(AccountAddress),
    collection: zod_1.default.optional(zod_1.default.object({
      address: Address2,
      name: zod_1.default.string(),
      description: zod_1.default.string()
    })),
    verified: zod_1.default.boolean(),
    metadata: zod_1.default.record(zod_1.default.any()),
    sale: zod_1.default.optional(Sale),
    previews: zod_1.default.optional(zod_1.default.array(ImagePreview)),
    dns: zod_1.default.optional(zod_1.default.string()),
    approved_by: zod_1.default.array(zod_1.default.string())
  });
  const NftItems = zod_1.default.object({
    nft_items: zod_1.default.array(NftItem2)
  });
  const JettonVerificationType = zod_1.default.union([zod_1.default.literal("whitelist"), zod_1.default.literal("blacklist"), zod_1.default.literal("none")]);
  const JettonMetadata = zod_1.default.object({
    address: Address2,
    name: zod_1.default.string(),
    symbol: zod_1.default.string(),
    decimals: zStrnum,
    image: zod_1.default.optional(zod_1.default.string()),
    description: zod_1.default.optional(zod_1.default.string()),
    social: zod_1.default.optional(zod_1.default.array(zod_1.default.string())),
    websites: zod_1.default.optional(zod_1.default.array(zod_1.default.string())),
    catalogs: zod_1.default.optional(zod_1.default.array(zod_1.default.string()))
  });
  const JettonInfo = zod_1.default.object({
    mintable: zod_1.default.boolean(),
    total_supply: zBigint,
    metadata: JettonMetadata,
    verification: JettonVerificationType,
    holders_count: zod_1.default.number()
  });
  const Jettons = zod_1.default.object({
    jettons: zod_1.default.array(JettonInfo)
  });
  const JettonHolder = zod_1.default.object({
    address: Address2,
    owner: AccountAddress,
    balance: zBigint
  });
  const JettonHolders = zod_1.default.object({
    addresses: zod_1.default.array(JettonHolder)
  });
  const EncryptedComment = zod_1.default.object({
    encryption_type: zod_1.default.string(),
    cipher_text: HexBuffer
  });
  const Refund = zod_1.default.object({
    type: zod_1.default.string(),
    origin: Address2
  });
  const NftItemTransferAction = zod_1.default.object({
    sender: zod_1.default.optional(AccountAddress),
    recipient: zod_1.default.optional(AccountAddress),
    nft: Address2,
    comment: zod_1.default.optional(zod_1.default.string()),
    encrypted_comment: zod_1.default.optional(EncryptedComment),
    payload: zod_1.default.optional(HexBuffer),
    refund: zod_1.default.optional(Refund)
  });
  const ActionStatus = zod_1.default.union([zod_1.default.literal("ok"), zod_1.default.literal("failed")]);
  const ActionSpecificNftItemTransfer = zod_1.default.object({
    type: zod_1.default.literal("NftItemTransfer"),
    status: ActionStatus,
    NftItemTransfer: NftItemTransferAction
  }).transform((v2) => ({
    status: v2.status,
    ...v2.NftItemTransfer
  }));
  const AccountEventGeneric = (t) => zod_1.default.object({
    event_id: zod_1.default.string(),
    account: AccountAddress,
    timestamp: zod_1.default.number(),
    actions: zod_1.default.array(t),
    is_scam: zod_1.default.boolean(),
    lt: zBigint,
    in_progress: zod_1.default.boolean()
  });
  const AccountEventNftItemTransfer = AccountEventGeneric(ActionSpecificNftItemTransfer);
  const AccountEventsGeneric = (t) => zod_1.default.object({
    events: zod_1.default.array(t),
    next_from: zBigint
  });
  const AccountEventsNftItemTransfer = AccountEventsGeneric(AccountEventNftItemTransfer);
  const TokenRates = zod_1.default.object({
    prices: zod_1.default.optional(zod_1.default.record(zod_1.default.number())),
    diff_24h: zod_1.default.optional(zod_1.default.record(zod_1.default.string())),
    diff_7d: zod_1.default.optional(zod_1.default.record(zod_1.default.string())),
    diff_30d: zod_1.default.optional(zod_1.default.record(zod_1.default.string()))
  });
  const JettonPreview = zod_1.default.object({
    address: Address2,
    name: zod_1.default.string(),
    symbol: zod_1.default.string(),
    decimals: zStrnum,
    image: zod_1.default.string(),
    verification: JettonVerificationType
  });
  const JettonBalance = zod_1.default.object({
    balance: zBigint,
    price: zod_1.default.optional(TokenRates),
    wallet_address: AccountAddress,
    jetton: JettonPreview
  });
  const JettonBalances = zod_1.default.object({
    balances: zod_1.default.array(JettonBalance)
  });
  const rawAddress = (address) => {
    return typeof address === "string" ? address : address.toRawString();
  };
  let TonAPI$1 = class TonAPI {
    constructor(params) {
      this.instance = axios_12.default.create({
        baseURL: params?.baseURL ?? "https://tonapi.io",
        headers: params?.token === void 0 ? {} : {
          "Authorization": "Bearer " + params.token
        }
      });
    }
    async getNftCollections(params) {
      return NftCollections.parse((await this.instance.get("/v2/nfts/collections", {
        params
      })).data).nft_collections;
    }
    async getNftCollection(collection) {
      return NftCollection2.parse((await this.instance.get(`/v2/nfts/collections/${rawAddress(collection)}`)).data);
    }
    async getNftCollectionItems(collection, params) {
      return NftItems.parse((await this.instance.get(`/v2/nfts/collections/${rawAddress(collection)}/items`, {
        params
      })).data).nft_items;
    }
    async getNftItems(items) {
      return NftItems.parse((await this.instance.post(`/v2/nfts/_bulk`, {
        account_ids: items.map(rawAddress)
      })).data).nft_items;
    }
    async getNftItem(item) {
      return NftItem2.parse((await this.instance.get(`/v2/nfts/${rawAddress(item)}`)).data);
    }
    async getJettons(params) {
      return Jettons.parse((await this.instance.get("/v2/jettons", {
        params
      })).data).jettons;
    }
    async getJetton(jettonMaster) {
      return JettonInfo.parse((await this.instance.get(`/v2/jettons/${rawAddress(jettonMaster)}`)).data);
    }
    async getJettonHolders(jettonMaster, params) {
      return JettonHolders.parse((await this.instance.get(`/v2/jettons/${rawAddress(jettonMaster)}/holders`, {
        params
      })).data).addresses;
    }
    async getNftItemTransferHistory(item, params) {
      return AccountEventsNftItemTransfer.parse((await this.instance.get(`/v2/nfts/${rawAddress(item)}/history`, {
        params: {
          limit: 100,
          ...params
        }
      })).data);
    }
    async getAccountNfts(account, params) {
      return NftItems.parse((await this.instance.get(`/v2/accounts/${rawAddress(account)}/nfts`, {
        params: {
          ...params,
          collection: params?.collection === void 0 ? void 0 : rawAddress(params.collection)
        }
      })).data).nft_items;
    }
    async getAccountJettons(account, params) {
      return JettonBalances.parse((await this.instance.get(`/v2/accounts/${rawAddress(account)}/jettons`, {
        params: {
          currencies: params?.currencies === void 0 ? void 0 : params.currencies.join(",")
        }
      })).data).balances;
    }
  };
  TonAPI.TonAPI = TonAPI$1;
  return TonAPI;
}
var JettonExcessesMessage = {};
var hasRequiredJettonExcessesMessage;
function requireJettonExcessesMessage() {
  if (hasRequiredJettonExcessesMessage) return JettonExcessesMessage;
  hasRequiredJettonExcessesMessage = 1;
  Object.defineProperty(JettonExcessesMessage, "__esModule", { value: true });
  JettonExcessesMessage.loadJettonExcessesMessage = JettonExcessesMessage.storeJettonExcessesMessage = void 0;
  const opcodes_1 = requireOpcodes$1();
  function storeJettonExcessesMessage(src2) {
    return (builder2) => {
      builder2.storeUint(opcodes_1.JETTON_EXCESSES_OPCODE, 32);
      builder2.storeUint(src2.queryId, 64);
    };
  }
  JettonExcessesMessage.storeJettonExcessesMessage = storeJettonExcessesMessage;
  function loadJettonExcessesMessage(slice) {
    if (slice.loadUint(32) !== opcodes_1.JETTON_EXCESSES_OPCODE) {
      throw new Error("Wrong opcode");
    }
    let queryId = slice.loadUintBig(64);
    return {
      queryId
    };
  }
  JettonExcessesMessage.loadJettonExcessesMessage = loadJettonExcessesMessage;
  return JettonExcessesMessage;
}
var hasRequiredDist;
function requireDist() {
  if (hasRequiredDist) return dist$1;
  hasRequiredDist = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeNftGetStaticDataMessage = exports.loadNftGetStaticDataMessage = exports.storeNftExcessesMessage = exports.loadNftExcessesMessage = exports.storeNftDeployMessage = exports.loadNftDeployMessage = exports.loadNftCollectionMessage = exports.storeNftCollectionData = exports.loadNftCollectionData = exports.parseNftCollectionTransaction = exports.storeNftChangeContentMessage = exports.loadNftChangeContentMessage = exports.storeNftChangeAdminMessage = exports.loadNftChangeAdminMessage = exports.storeNftBatchMintMessage = exports.loadNftBatchMintMessage = exports.createNftMintItemValue = exports.storeNftBatchMintItem = exports.loadNftBatchMintItem = exports.NFT_MINT_OPCODE = exports.NFT_CHANGE_CONTENT_OPCODE = exports.NFT_CHANGE_ADMIN_OPCODE = exports.NFT_BATCH_MINT_OPCODE = exports.NFT_OWNER_ASSIGNED_OPCODE = exports.NFT_REPORT_STATIC_DATA_OPCODE = exports.NFT_GET_STATIC_DATA_OPCODE = exports.NFT_EXCESSES_OPCODE = exports.NFT_TRANSFER_OPCODE = exports.TonAPI = exports.NoSenderError = exports.parseTransferTransaction = exports.storeEncryptedMessage = exports.storeTextMessage = exports.storeSimpleTransferMessage = exports.loadEncryptedMessage = exports.loadTextMessage = exports.loadSimpleTransferMessage = exports.loadTransferMessage = exports.ENCRYPTED_MESSAGE_OPCODE = exports.TEXT_OPCODE = exports.HighloadWalletContractV2 = exports.createSender = exports.createHighloadV2 = exports.createWallet = exports.importKey = exports.createApi = exports.NoopStorage = exports.S3Storage = exports.PinataStorage = exports.AssetsSDK = void 0;
    exports.storeJettonChangeContentMessage = exports.loadJettonChangeContentMessage = exports.storeJettonChangeAdminMessage = exports.loadJettonChangeAdminMessage = exports.storeJettonBurnNotificationMessage = exports.loadJettonBurnNotificationMessage = exports.storeJettonBurnMessage = exports.loadJettonBurnMessage = exports.jettonContentToInternal = exports.parseJettonContent = exports.jettonWalletConfigToCell = exports.JettonWallet = exports.jettonMinterConfigToCell = exports.JettonMinter = exports.JETTON_TRANSFER_NOTIFICATION_OPCODE = exports.JETTON_EXCESSES_OPCODE = exports.JETTON_MINT_OPCODE = exports.JETTON_INTERNAL_TRANSFER_OPCODE = exports.JETTON_TRANSFER_OPCODE = exports.JETTON_CHANGE_CONTENT_OPCODE = exports.JETTON_CHANGE_ADMIN_OPCODE = exports.JETTON_BURN_OPCODE = exports.JETTON_BURN_NOTIFICATION_OPCODE = exports.NftSale = exports.nftItemConfigToCell = exports.NftItem = exports.sbtCollectionConfigToCell = exports.SbtCollection = exports.nftCollectionConfigToCell = exports.NftCollection = exports.createSbtItemParamsValue = exports.storeSbtItemParams = exports.loadSbtItemParams = exports.parseSbtItemTransaction = exports.parseSbtCollectionTransaction = exports.storeNftTransferMessage = exports.loadNftTransferMessage = exports.storeNftRoyaltyParams = exports.loadNftRoyaltyParams = exports.storeNftReportStaticDataMessage = exports.loadNftReportStaticDataMessage = exports.storeNftOwnerAssignedMessage = exports.loadNftOwnerAssignedMessage = exports.storeNftMintMessage = exports.loadNftMintMessage = exports.loadNftMessage = exports.createNftItemParamsValue = exports.storeNftItemParams = exports.loadNftItemParams = exports.parseNftItemTransaction = void 0;
    exports.loadJettonWalletMessage = exports.parseJettonWalletTransaction = exports.loadJettonMinterMessage = exports.parseJettonMinterTransaction = exports.storeJettonTransferNotificationMessage = exports.loadJettonTransferNotificationMessage = exports.storeJettonTransferMessage = exports.loadJettonTransferMessage = exports.storeJettonMintMessage = exports.loadJettonMintMessage = exports.storeJettonMinterContent = exports.loadJettonMinterContent = exports.storeJettonInternalTransferMessage = exports.loadJettonInternalTransferMessage = exports.storeJettonExcessesMessage = exports.loadJettonExcessesMessage = void 0;
    var sdk_1 = requireSdk();
    Object.defineProperty(exports, "AssetsSDK", { enumerable: true, get: function() {
      return sdk_1.AssetsSDK;
    } });
    var pinata_1 = requirePinata();
    Object.defineProperty(exports, "PinataStorage", { enumerable: true, get: function() {
      return pinata_1.PinataStorage;
    } });
    var s3_1 = requireS3();
    Object.defineProperty(exports, "S3Storage", { enumerable: true, get: function() {
      return s3_1.S3Storage;
    } });
    var noop_1 = requireNoop();
    Object.defineProperty(exports, "NoopStorage", { enumerable: true, get: function() {
      return noop_1.NoopStorage;
    } });
    var ton_client_api_1 = requireTonClientApi();
    Object.defineProperty(exports, "createApi", { enumerable: true, get: function() {
      return ton_client_api_1.createApi;
    } });
    var key_1 = requireKey();
    Object.defineProperty(exports, "importKey", { enumerable: true, get: function() {
      return key_1.importKey;
    } });
    var wallets_1 = requireWallets();
    Object.defineProperty(exports, "createWallet", { enumerable: true, get: function() {
      return wallets_1.createWallet;
    } });
    Object.defineProperty(exports, "createHighloadV2", { enumerable: true, get: function() {
      return wallets_1.createHighloadV2;
    } });
    Object.defineProperty(exports, "createSender", { enumerable: true, get: function() {
      return wallets_1.createSender;
    } });
    var HighloadWalletContractV2_1 = requireHighloadWalletContractV2();
    Object.defineProperty(exports, "HighloadWalletContractV2", { enumerable: true, get: function() {
      return HighloadWalletContractV2_1.HighloadWalletContractV2;
    } });
    var TransferMessage_1 = requireTransferMessage();
    Object.defineProperty(exports, "TEXT_OPCODE", { enumerable: true, get: function() {
      return TransferMessage_1.TEXT_OPCODE;
    } });
    Object.defineProperty(exports, "ENCRYPTED_MESSAGE_OPCODE", { enumerable: true, get: function() {
      return TransferMessage_1.ENCRYPTED_MESSAGE_OPCODE;
    } });
    Object.defineProperty(exports, "loadTransferMessage", { enumerable: true, get: function() {
      return TransferMessage_1.loadTransferMessage;
    } });
    Object.defineProperty(exports, "loadSimpleTransferMessage", { enumerable: true, get: function() {
      return TransferMessage_1.loadSimpleTransferMessage;
    } });
    Object.defineProperty(exports, "loadTextMessage", { enumerable: true, get: function() {
      return TransferMessage_1.loadTextMessage;
    } });
    Object.defineProperty(exports, "loadEncryptedMessage", { enumerable: true, get: function() {
      return TransferMessage_1.loadEncryptedMessage;
    } });
    Object.defineProperty(exports, "storeSimpleTransferMessage", { enumerable: true, get: function() {
      return TransferMessage_1.storeSimpleTransferMessage;
    } });
    Object.defineProperty(exports, "storeTextMessage", { enumerable: true, get: function() {
      return TransferMessage_1.storeTextMessage;
    } });
    Object.defineProperty(exports, "storeEncryptedMessage", { enumerable: true, get: function() {
      return TransferMessage_1.storeEncryptedMessage;
    } });
    var TransferAction_1 = requireTransferAction();
    Object.defineProperty(exports, "parseTransferTransaction", { enumerable: true, get: function() {
      return TransferAction_1.parseTransferTransaction;
    } });
    var error_1 = requireError();
    Object.defineProperty(exports, "NoSenderError", { enumerable: true, get: function() {
      return error_1.NoSenderError;
    } });
    var TonAPI_1 = requireTonAPI();
    Object.defineProperty(exports, "TonAPI", { enumerable: true, get: function() {
      return TonAPI_1.TonAPI;
    } });
    var opcodes_1 = requireOpcodes();
    Object.defineProperty(exports, "NFT_TRANSFER_OPCODE", { enumerable: true, get: function() {
      return opcodes_1.NFT_TRANSFER_OPCODE;
    } });
    Object.defineProperty(exports, "NFT_EXCESSES_OPCODE", { enumerable: true, get: function() {
      return opcodes_1.NFT_EXCESSES_OPCODE;
    } });
    Object.defineProperty(exports, "NFT_GET_STATIC_DATA_OPCODE", { enumerable: true, get: function() {
      return opcodes_1.NFT_GET_STATIC_DATA_OPCODE;
    } });
    Object.defineProperty(exports, "NFT_REPORT_STATIC_DATA_OPCODE", { enumerable: true, get: function() {
      return opcodes_1.NFT_REPORT_STATIC_DATA_OPCODE;
    } });
    Object.defineProperty(exports, "NFT_OWNER_ASSIGNED_OPCODE", { enumerable: true, get: function() {
      return opcodes_1.NFT_OWNER_ASSIGNED_OPCODE;
    } });
    Object.defineProperty(exports, "NFT_BATCH_MINT_OPCODE", { enumerable: true, get: function() {
      return opcodes_1.NFT_BATCH_MINT_OPCODE;
    } });
    Object.defineProperty(exports, "NFT_CHANGE_ADMIN_OPCODE", { enumerable: true, get: function() {
      return opcodes_1.NFT_CHANGE_ADMIN_OPCODE;
    } });
    Object.defineProperty(exports, "NFT_CHANGE_CONTENT_OPCODE", { enumerable: true, get: function() {
      return opcodes_1.NFT_CHANGE_CONTENT_OPCODE;
    } });
    Object.defineProperty(exports, "NFT_MINT_OPCODE", { enumerable: true, get: function() {
      return opcodes_1.NFT_MINT_OPCODE;
    } });
    var NftBatchMintMessage_1 = requireNftBatchMintMessage();
    Object.defineProperty(exports, "loadNftBatchMintItem", { enumerable: true, get: function() {
      return NftBatchMintMessage_1.loadNftBatchMintItem;
    } });
    var NftBatchMintMessage_2 = requireNftBatchMintMessage();
    Object.defineProperty(exports, "storeNftBatchMintItem", { enumerable: true, get: function() {
      return NftBatchMintMessage_2.storeNftBatchMintItem;
    } });
    var NftBatchMintMessage_3 = requireNftBatchMintMessage();
    Object.defineProperty(exports, "createNftMintItemValue", { enumerable: true, get: function() {
      return NftBatchMintMessage_3.createNftMintItemValue;
    } });
    var NftBatchMintMessage_4 = requireNftBatchMintMessage();
    Object.defineProperty(exports, "loadNftBatchMintMessage", { enumerable: true, get: function() {
      return NftBatchMintMessage_4.loadNftBatchMintMessage;
    } });
    var NftBatchMintMessage_5 = requireNftBatchMintMessage();
    Object.defineProperty(exports, "storeNftBatchMintMessage", { enumerable: true, get: function() {
      return NftBatchMintMessage_5.storeNftBatchMintMessage;
    } });
    var NftChangeAdminMessage_1 = requireNftChangeAdminMessage();
    Object.defineProperty(exports, "loadNftChangeAdminMessage", { enumerable: true, get: function() {
      return NftChangeAdminMessage_1.loadNftChangeAdminMessage;
    } });
    var NftChangeAdminMessage_2 = requireNftChangeAdminMessage();
    Object.defineProperty(exports, "storeNftChangeAdminMessage", { enumerable: true, get: function() {
      return NftChangeAdminMessage_2.storeNftChangeAdminMessage;
    } });
    var NftChangeContentMessage_1 = requireNftChangeContentMessage();
    Object.defineProperty(exports, "loadNftChangeContentMessage", { enumerable: true, get: function() {
      return NftChangeContentMessage_1.loadNftChangeContentMessage;
    } });
    var NftChangeContentMessage_2 = requireNftChangeContentMessage();
    Object.defineProperty(exports, "storeNftChangeContentMessage", { enumerable: true, get: function() {
      return NftChangeContentMessage_2.storeNftChangeContentMessage;
    } });
    var NftCollectionAction_1 = requireNftCollectionAction();
    Object.defineProperty(exports, "parseNftCollectionTransaction", { enumerable: true, get: function() {
      return NftCollectionAction_1.parseNftCollectionTransaction;
    } });
    var NftCollectionData_1 = requireNftCollectionData();
    Object.defineProperty(exports, "loadNftCollectionData", { enumerable: true, get: function() {
      return NftCollectionData_1.loadNftCollectionData;
    } });
    var NftCollectionData_2 = requireNftCollectionData();
    Object.defineProperty(exports, "storeNftCollectionData", { enumerable: true, get: function() {
      return NftCollectionData_2.storeNftCollectionData;
    } });
    var NftCollectionMessage_1 = requireNftCollectionMessage();
    Object.defineProperty(exports, "loadNftCollectionMessage", { enumerable: true, get: function() {
      return NftCollectionMessage_1.loadNftCollectionMessage;
    } });
    var NftDeployMessage_1 = requireNftDeployMessage();
    Object.defineProperty(exports, "loadNftDeployMessage", { enumerable: true, get: function() {
      return NftDeployMessage_1.loadNftDeployMessage;
    } });
    var NftDeployMessage_2 = requireNftDeployMessage();
    Object.defineProperty(exports, "storeNftDeployMessage", { enumerable: true, get: function() {
      return NftDeployMessage_2.storeNftDeployMessage;
    } });
    var NftExcessesMessage_1 = requireNftExcessesMessage();
    Object.defineProperty(exports, "loadNftExcessesMessage", { enumerable: true, get: function() {
      return NftExcessesMessage_1.loadNftExcessesMessage;
    } });
    var NftExcessesMessage_2 = requireNftExcessesMessage();
    Object.defineProperty(exports, "storeNftExcessesMessage", { enumerable: true, get: function() {
      return NftExcessesMessage_2.storeNftExcessesMessage;
    } });
    var NftGetStaticDataMessage_1 = requireNftGetStaticDataMessage();
    Object.defineProperty(exports, "loadNftGetStaticDataMessage", { enumerable: true, get: function() {
      return NftGetStaticDataMessage_1.loadNftGetStaticDataMessage;
    } });
    var NftGetStaticDataMessage_2 = requireNftGetStaticDataMessage();
    Object.defineProperty(exports, "storeNftGetStaticDataMessage", { enumerable: true, get: function() {
      return NftGetStaticDataMessage_2.storeNftGetStaticDataMessage;
    } });
    var NftItemAction_1 = requireNftItemAction();
    Object.defineProperty(exports, "parseNftItemTransaction", { enumerable: true, get: function() {
      return NftItemAction_1.parseNftItemTransaction;
    } });
    var NftItemParams_1 = requireNftItemParams();
    Object.defineProperty(exports, "loadNftItemParams", { enumerable: true, get: function() {
      return NftItemParams_1.loadNftItemParams;
    } });
    var NftItemParams_2 = requireNftItemParams();
    Object.defineProperty(exports, "storeNftItemParams", { enumerable: true, get: function() {
      return NftItemParams_2.storeNftItemParams;
    } });
    var NftItemParams_3 = requireNftItemParams();
    Object.defineProperty(exports, "createNftItemParamsValue", { enumerable: true, get: function() {
      return NftItemParams_3.createNftItemParamsValue;
    } });
    var NftMessage_1 = requireNftMessage();
    Object.defineProperty(exports, "loadNftMessage", { enumerable: true, get: function() {
      return NftMessage_1.loadNftMessage;
    } });
    var NftMintMessage_1 = requireNftMintMessage();
    Object.defineProperty(exports, "loadNftMintMessage", { enumerable: true, get: function() {
      return NftMintMessage_1.loadNftMintMessage;
    } });
    var NftMintMessage_2 = requireNftMintMessage();
    Object.defineProperty(exports, "storeNftMintMessage", { enumerable: true, get: function() {
      return NftMintMessage_2.storeNftMintMessage;
    } });
    var NftOwnerAssignedMessage_1 = requireNftOwnerAssignedMessage();
    Object.defineProperty(exports, "loadNftOwnerAssignedMessage", { enumerable: true, get: function() {
      return NftOwnerAssignedMessage_1.loadNftOwnerAssignedMessage;
    } });
    var NftOwnerAssignedMessage_2 = requireNftOwnerAssignedMessage();
    Object.defineProperty(exports, "storeNftOwnerAssignedMessage", { enumerable: true, get: function() {
      return NftOwnerAssignedMessage_2.storeNftOwnerAssignedMessage;
    } });
    var NftReportStaticDataMessage_1 = requireNftReportStaticDataMessage();
    Object.defineProperty(exports, "loadNftReportStaticDataMessage", { enumerable: true, get: function() {
      return NftReportStaticDataMessage_1.loadNftReportStaticDataMessage;
    } });
    var NftReportStaticDataMessage_2 = requireNftReportStaticDataMessage();
    Object.defineProperty(exports, "storeNftReportStaticDataMessage", { enumerable: true, get: function() {
      return NftReportStaticDataMessage_2.storeNftReportStaticDataMessage;
    } });
    var NftRoyaltyParams_1 = requireNftRoyaltyParams();
    Object.defineProperty(exports, "loadNftRoyaltyParams", { enumerable: true, get: function() {
      return NftRoyaltyParams_1.loadNftRoyaltyParams;
    } });
    var NftRoyaltyParams_2 = requireNftRoyaltyParams();
    Object.defineProperty(exports, "storeNftRoyaltyParams", { enumerable: true, get: function() {
      return NftRoyaltyParams_2.storeNftRoyaltyParams;
    } });
    var NftTransferMessage_1 = requireNftTransferMessage();
    Object.defineProperty(exports, "loadNftTransferMessage", { enumerable: true, get: function() {
      return NftTransferMessage_1.loadNftTransferMessage;
    } });
    var NftTransferMessage_2 = requireNftTransferMessage();
    Object.defineProperty(exports, "storeNftTransferMessage", { enumerable: true, get: function() {
      return NftTransferMessage_2.storeNftTransferMessage;
    } });
    var SbtCollectionAction_1 = requireSbtCollectionAction();
    Object.defineProperty(exports, "parseSbtCollectionTransaction", { enumerable: true, get: function() {
      return SbtCollectionAction_1.parseSbtCollectionTransaction;
    } });
    var SbtItemAction_1 = requireSbtItemAction();
    Object.defineProperty(exports, "parseSbtItemTransaction", { enumerable: true, get: function() {
      return SbtItemAction_1.parseSbtItemTransaction;
    } });
    var SbtItemParams_1 = requireSbtItemParams();
    Object.defineProperty(exports, "loadSbtItemParams", { enumerable: true, get: function() {
      return SbtItemParams_1.loadSbtItemParams;
    } });
    var SbtItemParams_2 = requireSbtItemParams();
    Object.defineProperty(exports, "storeSbtItemParams", { enumerable: true, get: function() {
      return SbtItemParams_2.storeSbtItemParams;
    } });
    var SbtItemParams_3 = requireSbtItemParams();
    Object.defineProperty(exports, "createSbtItemParamsValue", { enumerable: true, get: function() {
      return SbtItemParams_3.createSbtItemParamsValue;
    } });
    var NftCollection_1 = requireNftCollection();
    Object.defineProperty(exports, "NftCollection", { enumerable: true, get: function() {
      return NftCollection_1.NftCollection;
    } });
    Object.defineProperty(exports, "nftCollectionConfigToCell", { enumerable: true, get: function() {
      return NftCollection_1.nftCollectionConfigToCell;
    } });
    var SbtCollection_1 = requireSbtCollection();
    Object.defineProperty(exports, "SbtCollection", { enumerable: true, get: function() {
      return SbtCollection_1.SbtCollection;
    } });
    Object.defineProperty(exports, "sbtCollectionConfigToCell", { enumerable: true, get: function() {
      return SbtCollection_1.sbtCollectionConfigToCell;
    } });
    var NftItem_1 = requireNftItem();
    Object.defineProperty(exports, "NftItem", { enumerable: true, get: function() {
      return NftItem_1.NftItem;
    } });
    Object.defineProperty(exports, "nftItemConfigToCell", { enumerable: true, get: function() {
      return NftItem_1.nftItemConfigToCell;
    } });
    var NftSale_1 = requireNftSale();
    Object.defineProperty(exports, "NftSale", { enumerable: true, get: function() {
      return NftSale_1.NftSale;
    } });
    var opcodes_2 = requireOpcodes$1();
    Object.defineProperty(exports, "JETTON_BURN_NOTIFICATION_OPCODE", { enumerable: true, get: function() {
      return opcodes_2.JETTON_BURN_NOTIFICATION_OPCODE;
    } });
    Object.defineProperty(exports, "JETTON_BURN_OPCODE", { enumerable: true, get: function() {
      return opcodes_2.JETTON_BURN_OPCODE;
    } });
    Object.defineProperty(exports, "JETTON_CHANGE_ADMIN_OPCODE", { enumerable: true, get: function() {
      return opcodes_2.JETTON_CHANGE_ADMIN_OPCODE;
    } });
    Object.defineProperty(exports, "JETTON_CHANGE_CONTENT_OPCODE", { enumerable: true, get: function() {
      return opcodes_2.JETTON_CHANGE_CONTENT_OPCODE;
    } });
    Object.defineProperty(exports, "JETTON_TRANSFER_OPCODE", { enumerable: true, get: function() {
      return opcodes_2.JETTON_TRANSFER_OPCODE;
    } });
    Object.defineProperty(exports, "JETTON_INTERNAL_TRANSFER_OPCODE", { enumerable: true, get: function() {
      return opcodes_2.JETTON_INTERNAL_TRANSFER_OPCODE;
    } });
    Object.defineProperty(exports, "JETTON_MINT_OPCODE", { enumerable: true, get: function() {
      return opcodes_2.JETTON_MINT_OPCODE;
    } });
    Object.defineProperty(exports, "JETTON_EXCESSES_OPCODE", { enumerable: true, get: function() {
      return opcodes_2.JETTON_EXCESSES_OPCODE;
    } });
    Object.defineProperty(exports, "JETTON_TRANSFER_NOTIFICATION_OPCODE", { enumerable: true, get: function() {
      return opcodes_2.JETTON_TRANSFER_NOTIFICATION_OPCODE;
    } });
    var JettonMinter_1 = requireJettonMinter();
    Object.defineProperty(exports, "JettonMinter", { enumerable: true, get: function() {
      return JettonMinter_1.JettonMinter;
    } });
    Object.defineProperty(exports, "jettonMinterConfigToCell", { enumerable: true, get: function() {
      return JettonMinter_1.jettonMinterConfigToCell;
    } });
    var JettonWallet_1 = requireJettonWallet$1();
    Object.defineProperty(exports, "JettonWallet", { enumerable: true, get: function() {
      return JettonWallet_1.JettonWallet;
    } });
    Object.defineProperty(exports, "jettonWalletConfigToCell", { enumerable: true, get: function() {
      return JettonWallet_1.jettonWalletConfigToCell;
    } });
    var content_1 = requireContent$1();
    Object.defineProperty(exports, "parseJettonContent", { enumerable: true, get: function() {
      return content_1.parseJettonContent;
    } });
    Object.defineProperty(exports, "jettonContentToInternal", { enumerable: true, get: function() {
      return content_1.jettonContentToInternal;
    } });
    var JettonBurnMessage_1 = requireJettonBurnMessage();
    Object.defineProperty(exports, "loadJettonBurnMessage", { enumerable: true, get: function() {
      return JettonBurnMessage_1.loadJettonBurnMessage;
    } });
    var JettonBurnMessage_2 = requireJettonBurnMessage();
    Object.defineProperty(exports, "storeJettonBurnMessage", { enumerable: true, get: function() {
      return JettonBurnMessage_2.storeJettonBurnMessage;
    } });
    var JettonBurnNotificationMessage_1 = requireJettonBurnNotificationMessage();
    Object.defineProperty(exports, "loadJettonBurnNotificationMessage", { enumerable: true, get: function() {
      return JettonBurnNotificationMessage_1.loadJettonBurnNotificationMessage;
    } });
    var JettonBurnNotificationMessage_2 = requireJettonBurnNotificationMessage();
    Object.defineProperty(exports, "storeJettonBurnNotificationMessage", { enumerable: true, get: function() {
      return JettonBurnNotificationMessage_2.storeJettonBurnNotificationMessage;
    } });
    var JettonChangeAdminMessage_1 = requireJettonChangeAdminMessage();
    Object.defineProperty(exports, "loadJettonChangeAdminMessage", { enumerable: true, get: function() {
      return JettonChangeAdminMessage_1.loadJettonChangeAdminMessage;
    } });
    var JettonChangeAdminMessage_2 = requireJettonChangeAdminMessage();
    Object.defineProperty(exports, "storeJettonChangeAdminMessage", { enumerable: true, get: function() {
      return JettonChangeAdminMessage_2.storeJettonChangeAdminMessage;
    } });
    var JettonChangeContentMessage_1 = requireJettonChangeContentMessage();
    Object.defineProperty(exports, "loadJettonChangeContentMessage", { enumerable: true, get: function() {
      return JettonChangeContentMessage_1.loadJettonChangeContentMessage;
    } });
    var JettonChangeContentMessage_2 = requireJettonChangeContentMessage();
    Object.defineProperty(exports, "storeJettonChangeContentMessage", { enumerable: true, get: function() {
      return JettonChangeContentMessage_2.storeJettonChangeContentMessage;
    } });
    var JettonExcessesMessage_1 = requireJettonExcessesMessage();
    Object.defineProperty(exports, "loadJettonExcessesMessage", { enumerable: true, get: function() {
      return JettonExcessesMessage_1.loadJettonExcessesMessage;
    } });
    var JettonExcessesMessage_2 = requireJettonExcessesMessage();
    Object.defineProperty(exports, "storeJettonExcessesMessage", { enumerable: true, get: function() {
      return JettonExcessesMessage_2.storeJettonExcessesMessage;
    } });
    var JettonInternalTransferMessage_1 = requireJettonInternalTransferMessage();
    Object.defineProperty(exports, "loadJettonInternalTransferMessage", { enumerable: true, get: function() {
      return JettonInternalTransferMessage_1.loadJettonInternalTransferMessage;
    } });
    var JettonInternalTransferMessage_2 = requireJettonInternalTransferMessage();
    Object.defineProperty(exports, "storeJettonInternalTransferMessage", { enumerable: true, get: function() {
      return JettonInternalTransferMessage_2.storeJettonInternalTransferMessage;
    } });
    var JettonMinterContent_1 = requireJettonMinterContent();
    Object.defineProperty(exports, "loadJettonMinterContent", { enumerable: true, get: function() {
      return JettonMinterContent_1.loadJettonMinterContent;
    } });
    var JettonMinterContent_2 = requireJettonMinterContent();
    Object.defineProperty(exports, "storeJettonMinterContent", { enumerable: true, get: function() {
      return JettonMinterContent_2.storeJettonMinterContent;
    } });
    var JettonMintMessage_1 = requireJettonMintMessage();
    Object.defineProperty(exports, "loadJettonMintMessage", { enumerable: true, get: function() {
      return JettonMintMessage_1.loadJettonMintMessage;
    } });
    var JettonMintMessage_2 = requireJettonMintMessage();
    Object.defineProperty(exports, "storeJettonMintMessage", { enumerable: true, get: function() {
      return JettonMintMessage_2.storeJettonMintMessage;
    } });
    var JettonTransferMessage_1 = requireJettonTransferMessage();
    Object.defineProperty(exports, "loadJettonTransferMessage", { enumerable: true, get: function() {
      return JettonTransferMessage_1.loadJettonTransferMessage;
    } });
    var JettonTransferMessage_2 = requireJettonTransferMessage();
    Object.defineProperty(exports, "storeJettonTransferMessage", { enumerable: true, get: function() {
      return JettonTransferMessage_2.storeJettonTransferMessage;
    } });
    var JettonTransferNotificationMessage_1 = requireJettonTransferNotificationMessage();
    Object.defineProperty(exports, "loadJettonTransferNotificationMessage", { enumerable: true, get: function() {
      return JettonTransferNotificationMessage_1.loadJettonTransferNotificationMessage;
    } });
    var JettonTransferNotificationMessage_2 = requireJettonTransferNotificationMessage();
    Object.defineProperty(exports, "storeJettonTransferNotificationMessage", { enumerable: true, get: function() {
      return JettonTransferNotificationMessage_2.storeJettonTransferNotificationMessage;
    } });
    var JettonMinterAction_1 = requireJettonMinterAction();
    Object.defineProperty(exports, "parseJettonMinterTransaction", { enumerable: true, get: function() {
      return JettonMinterAction_1.parseJettonMinterTransaction;
    } });
    var JettonMinterMessage_1 = requireJettonMinterMessage();
    Object.defineProperty(exports, "loadJettonMinterMessage", { enumerable: true, get: function() {
      return JettonMinterMessage_1.loadJettonMinterMessage;
    } });
    var JettonWalletAction_1 = requireJettonWalletAction();
    Object.defineProperty(exports, "parseJettonWalletTransaction", { enumerable: true, get: function() {
      return JettonWalletAction_1.parseJettonWalletTransaction;
    } });
    var JettonWalletMessage_1 = requireJettonWalletMessage();
    Object.defineProperty(exports, "loadJettonWalletMessage", { enumerable: true, get: function() {
      return JettonWalletMessage_1.loadJettonWalletMessage;
    } });
  })(dist$1);
  return dist$1;
}
var distExports = requireDist();
class WalletJettonClass {
  async createTransferJettonTransaction(jettonTransferParams) {
    if (!isValidAddress(jettonTransferParams.toAddress)) {
      throw new Error(`Invalid to address: ${jettonTransferParams.toAddress}`);
    }
    if (!isValidAddress(jettonTransferParams.jettonAddress)) {
      throw new Error(`Invalid jetton address: ${jettonTransferParams.jettonAddress}`);
    }
    if (!jettonTransferParams.amount || BigInt(jettonTransferParams.amount) <= 0n) {
      throw new Error(`Invalid amount: ${jettonTransferParams.amount}`);
    }
    const jettonWalletAddress = await CallForSuccess(() => this.getJettonWalletAddress(jettonTransferParams.jettonAddress));
    const forwardPayload = jettonTransferParams.comment ? distExports$3.beginCell().storeUint(0, 32).storeStringTail(jettonTransferParams.comment).endCell() : null;
    const jettonPayload = distExports$3.beginCell().store(distExports.storeJettonTransferMessage({
      queryId: 0n,
      amount: BigInt(jettonTransferParams.amount),
      destination: distExports$3.Address.parse(jettonTransferParams.toAddress),
      responseDestination: distExports$3.Address.parse(this.getAddress()),
      customPayload: null,
      forwardAmount: 1n,
      //1 nanoton default
      forwardPayload
    })).endCell();
    const message = {
      address: jettonWalletAddress,
      amount: "50000000",
      // 0.05 TON for gas fees
      payload: jettonPayload.toBoc().toString("base64"),
      stateInit: void 0,
      extraCurrency: void 0,
      mode: distExports$3.SendMode.PAY_GAS_SEPARATELY | distExports$3.SendMode.IGNORE_ERRORS
    };
    if (!validateTransactionMessage(message, false).isValid) {
      throw new Error(`Invalid transaction message: ${JSON.stringify(message)}`);
    }
    return {
      messages: [message],
      from: this.getAddress()
    };
  }
  async getJettonBalance(jettonAddress) {
    const jettonWalletAddress = await this.getJettonWalletAddress(jettonAddress);
    try {
      const result = await this.client.runGetMethod(distExports$3.Address.parse(jettonWalletAddress), "get_wallet_data");
      const balance = result.stack.readBigNumber();
      return balance.toString();
    } catch (_error) {
      return "0";
    }
  }
  async getJettonWalletAddress(jettonAddress) {
    if (!isValidAddress(jettonAddress)) {
      throw new Error(`Invalid jetton address: ${jettonAddress}`);
    }
    try {
      const result = await this.client.runGetMethod(distExports$3.Address.parse(jettonAddress), "get_wallet_address", [
        { type: "slice", cell: distExports$3.beginCell().storeAddress(distExports$3.Address.parse(this.getAddress())).endCell() }
      ]);
      const jettonWalletAddress = result.stack.readAddress();
      return jettonWalletAddress.toString();
    } catch (error2) {
      throw new Error(`Failed to get jetton wallet address for ${jettonAddress}: ${error2 instanceof Error ? error2.message : "Unknown error"}`);
    }
  }
}
class WalletNftClass {
  async getNfts(params) {
    const out = await this.client.nftItemsByOwner({
      ownerAddress: [this.getAddress()],
      offset: params.offset ?? 0,
      limit: params.limit ?? 100
    });
    return {
      items: out.items,
      pagination: out.pagination
    };
  }
  async getNft(address) {
    const result = await this.client.nftItemsByAddress({
      address: [address]
    });
    if (result.items.length > 0) {
      return result.items[0];
    }
    return null;
  }
  async createTransferNftTransaction(nftTransferMessage) {
    const forwardPayload = nftTransferMessage.comment ? distExports$3.beginCell().storeUint(0, 32).storeStringTail(nftTransferMessage.comment).endCell() : null;
    const nftPayload = distExports$3.beginCell().store(distExports.storeNftTransferMessage({
      customPayload: null,
      forwardAmount: 1n,
      forwardPayload,
      newOwner: distExports$3.Address.parse(nftTransferMessage.toAddress),
      queryId: 0n,
      responseDestination: distExports$3.Address.parse(this.getAddress())
    })).endCell();
    const message = {
      address: nftTransferMessage.nftAddress,
      amount: nftTransferMessage.transferAmount.toString(),
      payload: nftPayload.toBoc().toString("base64"),
      stateInit: void 0,
      extraCurrency: void 0,
      mode: distExports$3.SendMode.PAY_GAS_SEPARATELY | distExports$3.SendMode.IGNORE_ERRORS
    };
    if (!validateTransactionMessage(message, false).isValid) {
      throw new Error(`Invalid transaction message: ${JSON.stringify(message)}`);
    }
    return {
      messages: [message],
      from: this.getAddress()
    };
  }
  async createTransferNftRawTransaction(params) {
    const transferMessage = {
      queryId: BigInt(params.transferMessage.queryId),
      newOwner: typeof params.transferMessage.newOwner === "string" ? distExports$3.Address.parse(params.transferMessage.newOwner) : params.transferMessage.newOwner,
      responseDestination: params.transferMessage.responseDestination ? typeof params.transferMessage.responseDestination === "string" ? distExports$3.Address.parse(params.transferMessage.responseDestination) : params.transferMessage.responseDestination : null,
      customPayload: params.transferMessage.customPayload ? typeof params.transferMessage.customPayload === "string" ? distExports$3.Cell.fromBase64(params.transferMessage.customPayload) : params.transferMessage.customPayload : null,
      forwardAmount: BigInt(params.transferMessage.forwardAmount),
      forwardPayload: params.transferMessage.forwardPayload ? typeof params.transferMessage.forwardPayload === "string" ? distExports$3.Cell.fromBase64(params.transferMessage.forwardPayload) : params.transferMessage.forwardPayload : null
    };
    const nftPayload = distExports$3.beginCell().store(distExports.storeNftTransferMessage(transferMessage)).endCell();
    const message = {
      address: params.nftAddress,
      amount: params.transferAmount.toString(),
      payload: nftPayload.toBoc().toString("base64"),
      stateInit: void 0,
      extraCurrency: void 0,
      mode: distExports$3.SendMode.PAY_GAS_SEPARATELY | distExports$3.SendMode.IGNORE_ERRORS
    };
    if (!validateTransactionMessage(message, false).isValid) {
      throw new Error(`Invalid transaction message: ${JSON.stringify(message)}`);
    }
    return {
      messages: [message],
      from: this.getAddress()
    };
  }
}
const log$7 = globalLogger.createChild("Initializer");
class Initializer {
  config;
  tonClient;
  eventEmitter;
  analyticsApi;
  constructor(config, eventEmitter, analyticsApi) {
    this.config = config;
    this.eventEmitter = eventEmitter;
    this.analyticsApi = analyticsApi;
  }
  /**
   * Initialize all components
   */
  async initialize(options, tonClient) {
    try {
      log$7.info("Initializing TonWalletKit...");
      this.tonClient = tonClient;
      const storageAdapter = this.initializeStorage(options);
      const { walletManager, sessionManager, bridgeManager, eventRouter, eventProcessor } = await this.initializeManagers(options, storageAdapter);
      const { requestProcessor } = this.initializeProcessors(sessionManager, bridgeManager, walletManager);
      log$7.info("TonWalletKit initialized successfully");
      return {
        walletManager,
        sessionManager,
        bridgeManager,
        eventRouter,
        requestProcessor,
        storageAdapter,
        eventProcessor
      };
    } catch (error2) {
      log$7.error("Failed to initialize TonWalletKit", { error: error2 });
      throw error2;
    }
  }
  /**
   * Initialize storage adapter
   */
  initializeStorage(options) {
    if (options.storage && "get" in options.storage && typeof options.storage.get === "function" && "set" in options.storage && typeof options.storage.set === "function" && "remove" in options.storage && typeof options.storage.remove === "function" && "clear" in options.storage && typeof options.storage.clear === "function") {
      return options.storage;
    }
    const createStorageOptions = {
      prefix: options?.storage?.prefix ?? "tonwalletkit:",
      maxRetries: options?.storage?.maxRetries,
      retryDelay: options?.storage?.retryDelay,
      allowMemory: options?.storage?.allowMemory
    };
    return createStorageAdapter(createStorageOptions);
  }
  /**
   * Initialize core managers
   */
  async initializeManagers(options, storageAdapter) {
    const walletManager = new WalletManager(storageAdapter);
    await walletManager.initialize();
    const sessionManager = new SessionManager(storageAdapter, walletManager);
    await sessionManager.initialize();
    const eventStore = new StorageEventStore(storageAdapter);
    const eventRouter = new EventRouter(this.eventEmitter, sessionManager, walletManager, this.config, this.analyticsApi);
    const bridgeManager = new BridgeManager(options?.walletManifest, options?.bridge, sessionManager, storageAdapter, eventStore, eventRouter, options, this.eventEmitter, this.analyticsApi);
    eventRouter.setBridgeManager(bridgeManager);
    await bridgeManager.start();
    const eventProcessor = new StorageEventProcessor(options?.eventProcessor, eventStore, DEFAULT_DURABLE_EVENTS_CONFIG, walletManager, sessionManager, eventRouter, this.eventEmitter);
    return {
      walletManager,
      sessionManager,
      bridgeManager,
      eventRouter,
      eventProcessor
    };
  }
  /**
   * Initialize processors
   */
  initializeProcessors(sessionManager, bridgeManager, walletManager) {
    const requestProcessor = new RequestProcessor(this.config, sessionManager, bridgeManager, walletManager, this.tonClient, this.config.network === CHAIN.MAINNET ? CHAIN.MAINNET : CHAIN.TESTNET, this.analyticsApi);
    return {
      requestProcessor
    };
  }
  /**
   * Cleanup resources during shutdown
   */
  async cleanup(components) {
    try {
      log$7.info("Cleaning up TonWalletKit components...");
      if (components.eventProcessor) {
        components.eventProcessor.stopRecoveryLoop();
        await components.eventProcessor.stopNoWalletProcessing();
      }
      if (components.bridgeManager) {
        await components.bridgeManager.close();
      }
      if (components.eventRouter) {
        components.eventRouter.clearCallbacks();
      }
      log$7.info("TonWalletKit cleanup completed");
    } catch (error2) {
      log$7.error("Error during cleanup", { error: error2 });
    }
  }
}
async function wrapWalletInterface(wallet, _tonClient) {
  const ourClassesToExtend = [WalletTonClass, WalletJettonClass, WalletNftClass];
  const newProxy = new Proxy(wallet, {
    get: (target, prop) => {
      if (typeof prop === "symbol") {
        return target[prop];
      }
      const ourMethonImplementation = ourClassesToExtend.find((cls) => !!cls.prototype[prop]);
      if (ourMethonImplementation) {
        const value2 = ourMethonImplementation.prototype[prop];
        return (...args) => value2.apply(newProxy, [...args]);
      }
      const value = target[prop];
      return value;
    }
  });
  return newProxy;
}
const perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
const warned = /* @__PURE__ */ new Set();
const PROCESS = typeof process === "object" && !!process ? process : {};
const emitWarning = (msg, type, code, fn2) => {
  typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn2) : console.error(`[${code}] ${type}: ${msg}`);
};
let AC = globalThis.AbortController;
let AS = globalThis.AbortSignal;
if (typeof AC === "undefined") {
  AS = class AbortSignal {
    onabort;
    _onabort = [];
    reason;
    aborted = false;
    addEventListener(_, fn2) {
      this._onabort.push(fn2);
    }
  };
  AC = class AbortController {
    constructor() {
      warnACPolyfill();
    }
    signal = new AS();
    abort(reason) {
      if (this.signal.aborted)
        return;
      this.signal.reason = reason;
      this.signal.aborted = true;
      for (const fn2 of this.signal._onabort) {
        fn2(reason);
      }
      this.signal.onabort?.(reason);
    }
  };
  let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
  const warnACPolyfill = () => {
    if (!printACPolyfillWarning)
      return;
    printACPolyfillWarning = false;
    emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
  };
}
const shouldWarn = (code) => !warned.has(code);
const isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
const getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
class ZeroArray extends Array {
  constructor(size) {
    super(size);
    this.fill(0);
  }
}
class Stack {
  heap;
  length;
  // private constructor
  static #constructing = false;
  static create(max) {
    const HeapCls = getUintArray(max);
    if (!HeapCls)
      return [];
    Stack.#constructing = true;
    const s2 = new Stack(max, HeapCls);
    Stack.#constructing = false;
    return s2;
  }
  constructor(max, HeapCls) {
    if (!Stack.#constructing) {
      throw new TypeError("instantiate Stack using Stack.create(n)");
    }
    this.heap = new HeapCls(max);
    this.length = 0;
  }
  push(n) {
    this.heap[this.length++] = n;
  }
  pop() {
    return this.heap[--this.length];
  }
}
class LRUCache {
  // options that cannot be changed without disaster
  #max;
  #maxSize;
  #dispose;
  #onInsert;
  #disposeAfter;
  #fetchMethod;
  #memoMethod;
  /**
   * {@link LRUCache.OptionsBase.ttl}
   */
  ttl;
  /**
   * {@link LRUCache.OptionsBase.ttlResolution}
   */
  ttlResolution;
  /**
   * {@link LRUCache.OptionsBase.ttlAutopurge}
   */
  ttlAutopurge;
  /**
   * {@link LRUCache.OptionsBase.updateAgeOnGet}
   */
  updateAgeOnGet;
  /**
   * {@link LRUCache.OptionsBase.updateAgeOnHas}
   */
  updateAgeOnHas;
  /**
   * {@link LRUCache.OptionsBase.allowStale}
   */
  allowStale;
  /**
   * {@link LRUCache.OptionsBase.noDisposeOnSet}
   */
  noDisposeOnSet;
  /**
   * {@link LRUCache.OptionsBase.noUpdateTTL}
   */
  noUpdateTTL;
  /**
   * {@link LRUCache.OptionsBase.maxEntrySize}
   */
  maxEntrySize;
  /**
   * {@link LRUCache.OptionsBase.sizeCalculation}
   */
  sizeCalculation;
  /**
   * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
   */
  noDeleteOnFetchRejection;
  /**
   * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
   */
  noDeleteOnStaleGet;
  /**
   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
   */
  allowStaleOnFetchAbort;
  /**
   * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
   */
  allowStaleOnFetchRejection;
  /**
   * {@link LRUCache.OptionsBase.ignoreFetchAbort}
   */
  ignoreFetchAbort;
  // computed properties
  #size;
  #calculatedSize;
  #keyMap;
  #keyList;
  #valList;
  #next;
  #prev;
  #head;
  #tail;
  #free;
  #disposed;
  #sizes;
  #starts;
  #ttls;
  #hasDispose;
  #hasFetchMethod;
  #hasDisposeAfter;
  #hasOnInsert;
  /**
   * Do not call this method unless you need to inspect the
   * inner workings of the cache.  If anything returned by this
   * object is modified in any way, strange breakage may occur.
   *
   * These fields are private for a reason!
   *
   * @internal
   */
  static unsafeExposeInternals(c) {
    return {
      // properties
      starts: c.#starts,
      ttls: c.#ttls,
      sizes: c.#sizes,
      keyMap: c.#keyMap,
      keyList: c.#keyList,
      valList: c.#valList,
      next: c.#next,
      prev: c.#prev,
      get head() {
        return c.#head;
      },
      get tail() {
        return c.#tail;
      },
      free: c.#free,
      // methods
      isBackgroundFetch: (p2) => c.#isBackgroundFetch(p2),
      backgroundFetch: (k2, index, options, context) => c.#backgroundFetch(k2, index, options, context),
      moveToTail: (index) => c.#moveToTail(index),
      indexes: (options) => c.#indexes(options),
      rindexes: (options) => c.#rindexes(options),
      isStale: (index) => c.#isStale(index)
    };
  }
  // Protected read-only members
  /**
   * {@link LRUCache.OptionsBase.max} (read-only)
   */
  get max() {
    return this.#max;
  }
  /**
   * {@link LRUCache.OptionsBase.maxSize} (read-only)
   */
  get maxSize() {
    return this.#maxSize;
  }
  /**
   * The total computed size of items in the cache (read-only)
   */
  get calculatedSize() {
    return this.#calculatedSize;
  }
  /**
   * The number of items stored in the cache (read-only)
   */
  get size() {
    return this.#size;
  }
  /**
   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
   */
  get fetchMethod() {
    return this.#fetchMethod;
  }
  get memoMethod() {
    return this.#memoMethod;
  }
  /**
   * {@link LRUCache.OptionsBase.dispose} (read-only)
   */
  get dispose() {
    return this.#dispose;
  }
  /**
   * {@link LRUCache.OptionsBase.onInsert} (read-only)
   */
  get onInsert() {
    return this.#onInsert;
  }
  /**
   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
   */
  get disposeAfter() {
    return this.#disposeAfter;
  }
  constructor(options) {
    const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, onInsert, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
    if (max !== 0 && !isPosInt(max)) {
      throw new TypeError("max option must be a nonnegative integer");
    }
    const UintArray = max ? getUintArray(max) : Array;
    if (!UintArray) {
      throw new Error("invalid max value: " + max);
    }
    this.#max = max;
    this.#maxSize = maxSize;
    this.maxEntrySize = maxEntrySize || this.#maxSize;
    this.sizeCalculation = sizeCalculation;
    if (this.sizeCalculation) {
      if (!this.#maxSize && !this.maxEntrySize) {
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      }
      if (typeof this.sizeCalculation !== "function") {
        throw new TypeError("sizeCalculation set to non-function");
      }
    }
    if (memoMethod !== void 0 && typeof memoMethod !== "function") {
      throw new TypeError("memoMethod must be a function if defined");
    }
    this.#memoMethod = memoMethod;
    if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
      throw new TypeError("fetchMethod must be a function if specified");
    }
    this.#fetchMethod = fetchMethod;
    this.#hasFetchMethod = !!fetchMethod;
    this.#keyMap = /* @__PURE__ */ new Map();
    this.#keyList = new Array(max).fill(void 0);
    this.#valList = new Array(max).fill(void 0);
    this.#next = new UintArray(max);
    this.#prev = new UintArray(max);
    this.#head = 0;
    this.#tail = 0;
    this.#free = Stack.create(max);
    this.#size = 0;
    this.#calculatedSize = 0;
    if (typeof dispose === "function") {
      this.#dispose = dispose;
    }
    if (typeof onInsert === "function") {
      this.#onInsert = onInsert;
    }
    if (typeof disposeAfter === "function") {
      this.#disposeAfter = disposeAfter;
      this.#disposed = [];
    } else {
      this.#disposeAfter = void 0;
      this.#disposed = void 0;
    }
    this.#hasDispose = !!this.#dispose;
    this.#hasOnInsert = !!this.#onInsert;
    this.#hasDisposeAfter = !!this.#disposeAfter;
    this.noDisposeOnSet = !!noDisposeOnSet;
    this.noUpdateTTL = !!noUpdateTTL;
    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
    this.ignoreFetchAbort = !!ignoreFetchAbort;
    if (this.maxEntrySize !== 0) {
      if (this.#maxSize !== 0) {
        if (!isPosInt(this.#maxSize)) {
          throw new TypeError("maxSize must be a positive integer if specified");
        }
      }
      if (!isPosInt(this.maxEntrySize)) {
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      }
      this.#initializeSizeTracking();
    }
    this.allowStale = !!allowStale;
    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
    this.updateAgeOnGet = !!updateAgeOnGet;
    this.updateAgeOnHas = !!updateAgeOnHas;
    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
    this.ttlAutopurge = !!ttlAutopurge;
    this.ttl = ttl || 0;
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError("ttl must be a positive integer if specified");
      }
      this.#initializeTTLTracking();
    }
    if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    }
    if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
      const code = "LRU_CACHE_UNBOUNDED";
      if (shouldWarn(code)) {
        warned.add(code);
        const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
        emitWarning(msg, "UnboundedCacheWarning", code, LRUCache);
      }
    }
  }
  /**
   * Return the number of ms left in the item's TTL. If item is not in cache,
   * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
   */
  getRemainingTTL(key2) {
    return this.#keyMap.has(key2) ? Infinity : 0;
  }
  #initializeTTLTracking() {
    const ttls = new ZeroArray(this.#max);
    const starts = new ZeroArray(this.#max);
    this.#ttls = ttls;
    this.#starts = starts;
    this.#setItemTTL = (index, ttl, start = perf.now()) => {
      starts[index] = ttl !== 0 ? start : 0;
      ttls[index] = ttl;
      if (ttl !== 0 && this.ttlAutopurge) {
        const t = setTimeout(() => {
          if (this.#isStale(index)) {
            this.#delete(this.#keyList[index], "expire");
          }
        }, ttl + 1);
        if (t.unref) {
          t.unref();
        }
      }
    };
    this.#updateItemAge = (index) => {
      starts[index] = ttls[index] !== 0 ? perf.now() : 0;
    };
    this.#statusTTL = (status, index) => {
      if (ttls[index]) {
        const ttl = ttls[index];
        const start = starts[index];
        if (!ttl || !start)
          return;
        status.ttl = ttl;
        status.start = start;
        status.now = cachedNow || getNow();
        const age = status.now - start;
        status.remainingTTL = ttl - age;
      }
    };
    let cachedNow = 0;
    const getNow = () => {
      const n = perf.now();
      if (this.ttlResolution > 0) {
        cachedNow = n;
        const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
        if (t.unref) {
          t.unref();
        }
      }
      return n;
    };
    this.getRemainingTTL = (key2) => {
      const index = this.#keyMap.get(key2);
      if (index === void 0) {
        return 0;
      }
      const ttl = ttls[index];
      const start = starts[index];
      if (!ttl || !start) {
        return Infinity;
      }
      const age = (cachedNow || getNow()) - start;
      return ttl - age;
    };
    this.#isStale = (index) => {
      const s2 = starts[index];
      const t = ttls[index];
      return !!t && !!s2 && (cachedNow || getNow()) - s2 > t;
    };
  }
  // conditionally set private methods related to TTL
  #updateItemAge = () => {
  };
  #statusTTL = () => {
  };
  #setItemTTL = () => {
  };
  /* c8 ignore stop */
  #isStale = () => false;
  #initializeSizeTracking() {
    const sizes = new ZeroArray(this.#max);
    this.#calculatedSize = 0;
    this.#sizes = sizes;
    this.#removeItemSize = (index) => {
      this.#calculatedSize -= sizes[index];
      sizes[index] = 0;
    };
    this.#requireSize = (k2, v2, size, sizeCalculation) => {
      if (this.#isBackgroundFetch(v2)) {
        return 0;
      }
      if (!isPosInt(size)) {
        if (sizeCalculation) {
          if (typeof sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation must be a function");
          }
          size = sizeCalculation(v2, k2);
          if (!isPosInt(size)) {
            throw new TypeError("sizeCalculation return invalid (expect positive integer)");
          }
        } else {
          throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
        }
      }
      return size;
    };
    this.#addItemSize = (index, size, status) => {
      sizes[index] = size;
      if (this.#maxSize) {
        const maxSize = this.#maxSize - sizes[index];
        while (this.#calculatedSize > maxSize) {
          this.#evict(true);
        }
      }
      this.#calculatedSize += sizes[index];
      if (status) {
        status.entrySize = size;
        status.totalCalculatedSize = this.#calculatedSize;
      }
    };
  }
  #removeItemSize = (_i) => {
  };
  #addItemSize = (_i, _s, _st) => {
  };
  #requireSize = (_k, _v, size, sizeCalculation) => {
    if (size || sizeCalculation) {
      throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
    }
    return 0;
  };
  *#indexes({ allowStale = this.allowStale } = {}) {
    if (this.#size) {
      for (let i = this.#tail; true; ) {
        if (!this.#isValidIndex(i)) {
          break;
        }
        if (allowStale || !this.#isStale(i)) {
          yield i;
        }
        if (i === this.#head) {
          break;
        } else {
          i = this.#prev[i];
        }
      }
    }
  }
  *#rindexes({ allowStale = this.allowStale } = {}) {
    if (this.#size) {
      for (let i = this.#head; true; ) {
        if (!this.#isValidIndex(i)) {
          break;
        }
        if (allowStale || !this.#isStale(i)) {
          yield i;
        }
        if (i === this.#tail) {
          break;
        } else {
          i = this.#next[i];
        }
      }
    }
  }
  #isValidIndex(index) {
    return index !== void 0 && this.#keyMap.get(this.#keyList[index]) === index;
  }
  /**
   * Return a generator yielding `[key, value]` pairs,
   * in order from most recently used to least recently used.
   */
  *entries() {
    for (const i of this.#indexes()) {
      if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield [this.#keyList[i], this.#valList[i]];
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.entries}
   *
   * Return a generator yielding `[key, value]` pairs,
   * in order from least recently used to most recently used.
   */
  *rentries() {
    for (const i of this.#rindexes()) {
      if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield [this.#keyList[i], this.#valList[i]];
      }
    }
  }
  /**
   * Return a generator yielding the keys in the cache,
   * in order from most recently used to least recently used.
   */
  *keys() {
    for (const i of this.#indexes()) {
      const k2 = this.#keyList[i];
      if (k2 !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield k2;
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.keys}
   *
   * Return a generator yielding the keys in the cache,
   * in order from least recently used to most recently used.
   */
  *rkeys() {
    for (const i of this.#rindexes()) {
      const k2 = this.#keyList[i];
      if (k2 !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield k2;
      }
    }
  }
  /**
   * Return a generator yielding the values in the cache,
   * in order from most recently used to least recently used.
   */
  *values() {
    for (const i of this.#indexes()) {
      const v2 = this.#valList[i];
      if (v2 !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield this.#valList[i];
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.values}
   *
   * Return a generator yielding the values in the cache,
   * in order from least recently used to most recently used.
   */
  *rvalues() {
    for (const i of this.#rindexes()) {
      const v2 = this.#valList[i];
      if (v2 !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield this.#valList[i];
      }
    }
  }
  /**
   * Iterating over the cache itself yields the same results as
   * {@link LRUCache.entries}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * A String value that is used in the creation of the default string
   * description of an object. Called by the built-in method
   * `Object.prototype.toString`.
   */
  [Symbol.toStringTag] = "LRUCache";
  /**
   * Find a value for which the supplied fn method returns a truthy value,
   * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
   */
  find(fn2, getOptions = {}) {
    for (const i of this.#indexes()) {
      const v2 = this.#valList[i];
      const value = this.#isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
      if (value === void 0)
        continue;
      if (fn2(value, this.#keyList[i], this)) {
        return this.get(this.#keyList[i], getOptions);
      }
    }
  }
  /**
   * Call the supplied function on each item in the cache, in order from most
   * recently used to least recently used.
   *
   * `fn` is called as `fn(value, key, cache)`.
   *
   * If `thisp` is provided, function will be called in the `this`-context of
   * the provided object, or the cache if no `thisp` object is provided.
   *
   * Does not update age or recenty of use, or iterate over stale values.
   */
  forEach(fn2, thisp = this) {
    for (const i of this.#indexes()) {
      const v2 = this.#valList[i];
      const value = this.#isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
      if (value === void 0)
        continue;
      fn2.call(thisp, value, this.#keyList[i], this);
    }
  }
  /**
   * The same as {@link LRUCache.forEach} but items are iterated over in
   * reverse order.  (ie, less recently used items are iterated over first.)
   */
  rforEach(fn2, thisp = this) {
    for (const i of this.#rindexes()) {
      const v2 = this.#valList[i];
      const value = this.#isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
      if (value === void 0)
        continue;
      fn2.call(thisp, value, this.#keyList[i], this);
    }
  }
  /**
   * Delete any stale entries. Returns true if anything was removed,
   * false otherwise.
   */
  purgeStale() {
    let deleted = false;
    for (const i of this.#rindexes({ allowStale: true })) {
      if (this.#isStale(i)) {
        this.#delete(this.#keyList[i], "expire");
        deleted = true;
      }
    }
    return deleted;
  }
  /**
   * Get the extended info about a given entry, to get its value, size, and
   * TTL info simultaneously. Returns `undefined` if the key is not present.
   *
   * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
   * serialization, the `start` value is always the current timestamp, and the
   * `ttl` is a calculated remaining time to live (negative if expired).
   *
   * Always returns stale values, if their info is found in the cache, so be
   * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
   * if relevant.
   */
  info(key2) {
    const i = this.#keyMap.get(key2);
    if (i === void 0)
      return void 0;
    const v2 = this.#valList[i];
    const value = this.#isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
    if (value === void 0)
      return void 0;
    const entry = { value };
    if (this.#ttls && this.#starts) {
      const ttl = this.#ttls[i];
      const start = this.#starts[i];
      if (ttl && start) {
        const remain = ttl - (perf.now() - start);
        entry.ttl = remain;
        entry.start = Date.now();
      }
    }
    if (this.#sizes) {
      entry.size = this.#sizes[i];
    }
    return entry;
  }
  /**
   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
   * passed to {@link LRUCache#load}.
   *
   * The `start` fields are calculated relative to a portable `Date.now()`
   * timestamp, even if `performance.now()` is available.
   *
   * Stale entries are always included in the `dump`, even if
   * {@link LRUCache.OptionsBase.allowStale} is false.
   *
   * Note: this returns an actual array, not a generator, so it can be more
   * easily passed around.
   */
  dump() {
    const arr = [];
    for (const i of this.#indexes({ allowStale: true })) {
      const key2 = this.#keyList[i];
      const v2 = this.#valList[i];
      const value = this.#isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
      if (value === void 0 || key2 === void 0)
        continue;
      const entry = { value };
      if (this.#ttls && this.#starts) {
        entry.ttl = this.#ttls[i];
        const age = perf.now() - this.#starts[i];
        entry.start = Math.floor(Date.now() - age);
      }
      if (this.#sizes) {
        entry.size = this.#sizes[i];
      }
      arr.unshift([key2, entry]);
    }
    return arr;
  }
  /**
   * Reset the cache and load in the items in entries in the order listed.
   *
   * The shape of the resulting cache may be different if the same options are
   * not used in both caches.
   *
   * The `start` fields are assumed to be calculated relative to a portable
   * `Date.now()` timestamp, even if `performance.now()` is available.
   */
  load(arr) {
    this.clear();
    for (const [key2, entry] of arr) {
      if (entry.start) {
        const age = Date.now() - entry.start;
        entry.start = perf.now() - age;
      }
      this.set(key2, entry.value, entry);
    }
  }
  /**
   * Add a value to the cache.
   *
   * Note: if `undefined` is specified as a value, this is an alias for
   * {@link LRUCache#delete}
   *
   * Fields on the {@link LRUCache.SetOptions} options param will override
   * their corresponding values in the constructor options for the scope
   * of this single `set()` operation.
   *
   * If `start` is provided, then that will set the effective start
   * time for the TTL calculation. Note that this must be a previous
   * value of `performance.now()` if supported, or a previous value of
   * `Date.now()` if not.
   *
   * Options object may also include `size`, which will prevent
   * calling the `sizeCalculation` function and just use the specified
   * number if it is a positive integer, and `noDisposeOnSet` which
   * will prevent calling a `dispose` function in the case of
   * overwrites.
   *
   * If the `size` (or return value of `sizeCalculation`) for a given
   * entry is greater than `maxEntrySize`, then the item will not be
   * added to the cache.
   *
   * Will update the recency of the entry.
   *
   * If the value is `undefined`, then this is an alias for
   * `cache.delete(key)`. `undefined` is never stored in the cache.
   */
  set(k2, v2, setOptions = {}) {
    if (v2 === void 0) {
      this.delete(k2);
      return this;
    }
    const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
    let { noUpdateTTL = this.noUpdateTTL } = setOptions;
    const size = this.#requireSize(k2, v2, setOptions.size || 0, sizeCalculation);
    if (this.maxEntrySize && size > this.maxEntrySize) {
      if (status) {
        status.set = "miss";
        status.maxEntrySizeExceeded = true;
      }
      this.#delete(k2, "set");
      return this;
    }
    let index = this.#size === 0 ? void 0 : this.#keyMap.get(k2);
    if (index === void 0) {
      index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
      this.#keyList[index] = k2;
      this.#valList[index] = v2;
      this.#keyMap.set(k2, index);
      this.#next[this.#tail] = index;
      this.#prev[index] = this.#tail;
      this.#tail = index;
      this.#size++;
      this.#addItemSize(index, size, status);
      if (status)
        status.set = "add";
      noUpdateTTL = false;
      if (this.#hasOnInsert) {
        this.#onInsert?.(v2, k2, "add");
      }
    } else {
      this.#moveToTail(index);
      const oldVal = this.#valList[index];
      if (v2 !== oldVal) {
        if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
          oldVal.__abortController.abort(new Error("replaced"));
          const { __staleWhileFetching: s2 } = oldVal;
          if (s2 !== void 0 && !noDisposeOnSet) {
            if (this.#hasDispose) {
              this.#dispose?.(s2, k2, "set");
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([s2, k2, "set"]);
            }
          }
        } else if (!noDisposeOnSet) {
          if (this.#hasDispose) {
            this.#dispose?.(oldVal, k2, "set");
          }
          if (this.#hasDisposeAfter) {
            this.#disposed?.push([oldVal, k2, "set"]);
          }
        }
        this.#removeItemSize(index);
        this.#addItemSize(index, size, status);
        this.#valList[index] = v2;
        if (status) {
          status.set = "replace";
          const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
          if (oldValue !== void 0)
            status.oldValue = oldValue;
        }
      } else if (status) {
        status.set = "update";
      }
      if (this.#hasOnInsert) {
        this.onInsert?.(v2, k2, v2 === oldVal ? "update" : "replace");
      }
    }
    if (ttl !== 0 && !this.#ttls) {
      this.#initializeTTLTracking();
    }
    if (this.#ttls) {
      if (!noUpdateTTL) {
        this.#setItemTTL(index, ttl, start);
      }
      if (status)
        this.#statusTTL(status, index);
    }
    if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
      const dt2 = this.#disposed;
      let task;
      while (task = dt2?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
    return this;
  }
  /**
   * Evict the least recently used item, returning its value or
   * `undefined` if cache is empty.
   */
  pop() {
    try {
      while (this.#size) {
        const val = this.#valList[this.#head];
        this.#evict(true);
        if (this.#isBackgroundFetch(val)) {
          if (val.__staleWhileFetching) {
            return val.__staleWhileFetching;
          }
        } else if (val !== void 0) {
          return val;
        }
      }
    } finally {
      if (this.#hasDisposeAfter && this.#disposed) {
        const dt2 = this.#disposed;
        let task;
        while (task = dt2?.shift()) {
          this.#disposeAfter?.(...task);
        }
      }
    }
  }
  #evict(free) {
    const head = this.#head;
    const k2 = this.#keyList[head];
    const v2 = this.#valList[head];
    if (this.#hasFetchMethod && this.#isBackgroundFetch(v2)) {
      v2.__abortController.abort(new Error("evicted"));
    } else if (this.#hasDispose || this.#hasDisposeAfter) {
      if (this.#hasDispose) {
        this.#dispose?.(v2, k2, "evict");
      }
      if (this.#hasDisposeAfter) {
        this.#disposed?.push([v2, k2, "evict"]);
      }
    }
    this.#removeItemSize(head);
    if (free) {
      this.#keyList[head] = void 0;
      this.#valList[head] = void 0;
      this.#free.push(head);
    }
    if (this.#size === 1) {
      this.#head = this.#tail = 0;
      this.#free.length = 0;
    } else {
      this.#head = this.#next[head];
    }
    this.#keyMap.delete(k2);
    this.#size--;
    return head;
  }
  /**
   * Check if a key is in the cache, without updating the recency of use.
   * Will return false if the item is stale, even though it is technically
   * in the cache.
   *
   * Check if a key is in the cache, without updating the recency of
   * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
   * to `true` in either the options or the constructor.
   *
   * Will return `false` if the item is stale, even though it is technically in
   * the cache. The difference can be determined (if it matters) by using a
   * `status` argument, and inspecting the `has` field.
   *
   * Will not update item age unless
   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
   */
  has(k2, hasOptions = {}) {
    const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
    const index = this.#keyMap.get(k2);
    if (index !== void 0) {
      const v2 = this.#valList[index];
      if (this.#isBackgroundFetch(v2) && v2.__staleWhileFetching === void 0) {
        return false;
      }
      if (!this.#isStale(index)) {
        if (updateAgeOnHas) {
          this.#updateItemAge(index);
        }
        if (status) {
          status.has = "hit";
          this.#statusTTL(status, index);
        }
        return true;
      } else if (status) {
        status.has = "stale";
        this.#statusTTL(status, index);
      }
    } else if (status) {
      status.has = "miss";
    }
    return false;
  }
  /**
   * Like {@link LRUCache#get} but doesn't update recency or delete stale
   * items.
   *
   * Returns `undefined` if the item is stale, unless
   * {@link LRUCache.OptionsBase.allowStale} is set.
   */
  peek(k2, peekOptions = {}) {
    const { allowStale = this.allowStale } = peekOptions;
    const index = this.#keyMap.get(k2);
    if (index === void 0 || !allowStale && this.#isStale(index)) {
      return;
    }
    const v2 = this.#valList[index];
    return this.#isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
  }
  #backgroundFetch(k2, index, options, context) {
    const v2 = index === void 0 ? void 0 : this.#valList[index];
    if (this.#isBackgroundFetch(v2)) {
      return v2;
    }
    const ac = new AC();
    const { signal } = options;
    signal?.addEventListener("abort", () => ac.abort(signal.reason), {
      signal: ac.signal
    });
    const fetchOpts = {
      signal: ac.signal,
      options,
      context
    };
    const cb = (v3, updateCache = false) => {
      const { aborted } = ac.signal;
      const ignoreAbort = options.ignoreFetchAbort && v3 !== void 0;
      if (options.status) {
        if (aborted && !updateCache) {
          options.status.fetchAborted = true;
          options.status.fetchError = ac.signal.reason;
          if (ignoreAbort)
            options.status.fetchAbortIgnored = true;
        } else {
          options.status.fetchResolved = true;
        }
      }
      if (aborted && !ignoreAbort && !updateCache) {
        return fetchFail(ac.signal.reason);
      }
      const bf2 = p2;
      if (this.#valList[index] === p2) {
        if (v3 === void 0) {
          if (bf2.__staleWhileFetching) {
            this.#valList[index] = bf2.__staleWhileFetching;
          } else {
            this.#delete(k2, "fetch");
          }
        } else {
          if (options.status)
            options.status.fetchUpdated = true;
          this.set(k2, v3, fetchOpts.options);
        }
      }
      return v3;
    };
    const eb = (er) => {
      if (options.status) {
        options.status.fetchRejected = true;
        options.status.fetchError = er;
      }
      return fetchFail(er);
    };
    const fetchFail = (er) => {
      const { aborted } = ac.signal;
      const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
      const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
      const noDelete = allowStale || options.noDeleteOnFetchRejection;
      const bf2 = p2;
      if (this.#valList[index] === p2) {
        const del = !noDelete || bf2.__staleWhileFetching === void 0;
        if (del) {
          this.#delete(k2, "fetch");
        } else if (!allowStaleAborted) {
          this.#valList[index] = bf2.__staleWhileFetching;
        }
      }
      if (allowStale) {
        if (options.status && bf2.__staleWhileFetching !== void 0) {
          options.status.returnedStale = true;
        }
        return bf2.__staleWhileFetching;
      } else if (bf2.__returned === bf2) {
        throw er;
      }
    };
    const pcall = (res, rej) => {
      const fmp = this.#fetchMethod?.(k2, v2, fetchOpts);
      if (fmp && fmp instanceof Promise) {
        fmp.then((v3) => res(v3 === void 0 ? void 0 : v3), rej);
      }
      ac.signal.addEventListener("abort", () => {
        if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
          res(void 0);
          if (options.allowStaleOnFetchAbort) {
            res = (v3) => cb(v3, true);
          }
        }
      });
    };
    if (options.status)
      options.status.fetchDispatched = true;
    const p2 = new Promise(pcall).then(cb, eb);
    const bf = Object.assign(p2, {
      __abortController: ac,
      __staleWhileFetching: v2,
      __returned: void 0
    });
    if (index === void 0) {
      this.set(k2, bf, { ...fetchOpts.options, status: void 0 });
      index = this.#keyMap.get(k2);
    } else {
      this.#valList[index] = bf;
    }
    return bf;
  }
  #isBackgroundFetch(p2) {
    if (!this.#hasFetchMethod)
      return false;
    const b2 = p2;
    return !!b2 && b2 instanceof Promise && b2.hasOwnProperty("__staleWhileFetching") && b2.__abortController instanceof AC;
  }
  async fetch(k2, fetchOptions = {}) {
    const {
      // get options
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      // set options
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      // fetch exclusive options
      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
      ignoreFetchAbort = this.ignoreFetchAbort,
      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
      context,
      forceRefresh = false,
      status,
      signal
    } = fetchOptions;
    if (!this.#hasFetchMethod) {
      if (status)
        status.fetch = "get";
      return this.get(k2, {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        status
      });
    }
    const options = {
      allowStale,
      updateAgeOnGet,
      noDeleteOnStaleGet,
      ttl,
      noDisposeOnSet,
      size,
      sizeCalculation,
      noUpdateTTL,
      noDeleteOnFetchRejection,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
      status,
      signal
    };
    let index = this.#keyMap.get(k2);
    if (index === void 0) {
      if (status)
        status.fetch = "miss";
      const p2 = this.#backgroundFetch(k2, index, options, context);
      return p2.__returned = p2;
    } else {
      const v2 = this.#valList[index];
      if (this.#isBackgroundFetch(v2)) {
        const stale = allowStale && v2.__staleWhileFetching !== void 0;
        if (status) {
          status.fetch = "inflight";
          if (stale)
            status.returnedStale = true;
        }
        return stale ? v2.__staleWhileFetching : v2.__returned = v2;
      }
      const isStale = this.#isStale(index);
      if (!forceRefresh && !isStale) {
        if (status)
          status.fetch = "hit";
        this.#moveToTail(index);
        if (updateAgeOnGet) {
          this.#updateItemAge(index);
        }
        if (status)
          this.#statusTTL(status, index);
        return v2;
      }
      const p2 = this.#backgroundFetch(k2, index, options, context);
      const hasStale = p2.__staleWhileFetching !== void 0;
      const staleVal = hasStale && allowStale;
      if (status) {
        status.fetch = isStale ? "stale" : "refresh";
        if (staleVal && isStale)
          status.returnedStale = true;
      }
      return staleVal ? p2.__staleWhileFetching : p2.__returned = p2;
    }
  }
  async forceFetch(k2, fetchOptions = {}) {
    const v2 = await this.fetch(k2, fetchOptions);
    if (v2 === void 0)
      throw new Error("fetch() returned undefined");
    return v2;
  }
  memo(k2, memoOptions = {}) {
    const memoMethod = this.#memoMethod;
    if (!memoMethod) {
      throw new Error("no memoMethod provided to constructor");
    }
    const { context, forceRefresh, ...options } = memoOptions;
    const v2 = this.get(k2, options);
    if (!forceRefresh && v2 !== void 0)
      return v2;
    const vv = memoMethod(k2, v2, {
      options,
      context
    });
    this.set(k2, vv, options);
    return vv;
  }
  /**
   * Return a value from the cache. Will update the recency of the cache
   * entry found.
   *
   * If the key is not found, get() will return `undefined`.
   */
  get(k2, getOptions = {}) {
    const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
    const index = this.#keyMap.get(k2);
    if (index !== void 0) {
      const value = this.#valList[index];
      const fetching = this.#isBackgroundFetch(value);
      if (status)
        this.#statusTTL(status, index);
      if (this.#isStale(index)) {
        if (status)
          status.get = "stale";
        if (!fetching) {
          if (!noDeleteOnStaleGet) {
            this.#delete(k2, "expire");
          }
          if (status && allowStale)
            status.returnedStale = true;
          return allowStale ? value : void 0;
        } else {
          if (status && allowStale && value.__staleWhileFetching !== void 0) {
            status.returnedStale = true;
          }
          return allowStale ? value.__staleWhileFetching : void 0;
        }
      } else {
        if (status)
          status.get = "hit";
        if (fetching) {
          return value.__staleWhileFetching;
        }
        this.#moveToTail(index);
        if (updateAgeOnGet) {
          this.#updateItemAge(index);
        }
        return value;
      }
    } else if (status) {
      status.get = "miss";
    }
  }
  #connect(p2, n) {
    this.#prev[n] = p2;
    this.#next[p2] = n;
  }
  #moveToTail(index) {
    if (index !== this.#tail) {
      if (index === this.#head) {
        this.#head = this.#next[index];
      } else {
        this.#connect(this.#prev[index], this.#next[index]);
      }
      this.#connect(this.#tail, index);
      this.#tail = index;
    }
  }
  /**
   * Deletes a key out of the cache.
   *
   * Returns true if the key was deleted, false otherwise.
   */
  delete(k2) {
    return this.#delete(k2, "delete");
  }
  #delete(k2, reason) {
    let deleted = false;
    if (this.#size !== 0) {
      const index = this.#keyMap.get(k2);
      if (index !== void 0) {
        deleted = true;
        if (this.#size === 1) {
          this.#clear(reason);
        } else {
          this.#removeItemSize(index);
          const v2 = this.#valList[index];
          if (this.#isBackgroundFetch(v2)) {
            v2.__abortController.abort(new Error("deleted"));
          } else if (this.#hasDispose || this.#hasDisposeAfter) {
            if (this.#hasDispose) {
              this.#dispose?.(v2, k2, reason);
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([v2, k2, reason]);
            }
          }
          this.#keyMap.delete(k2);
          this.#keyList[index] = void 0;
          this.#valList[index] = void 0;
          if (index === this.#tail) {
            this.#tail = this.#prev[index];
          } else if (index === this.#head) {
            this.#head = this.#next[index];
          } else {
            const pi = this.#prev[index];
            this.#next[pi] = this.#next[index];
            const ni = this.#next[index];
            this.#prev[ni] = this.#prev[index];
          }
          this.#size--;
          this.#free.push(index);
        }
      }
    }
    if (this.#hasDisposeAfter && this.#disposed?.length) {
      const dt2 = this.#disposed;
      let task;
      while (task = dt2?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
    return deleted;
  }
  /**
   * Clear the cache entirely, throwing away all values.
   */
  clear() {
    return this.#clear("delete");
  }
  #clear(reason) {
    for (const index of this.#rindexes({ allowStale: true })) {
      const v2 = this.#valList[index];
      if (this.#isBackgroundFetch(v2)) {
        v2.__abortController.abort(new Error("deleted"));
      } else {
        const k2 = this.#keyList[index];
        if (this.#hasDispose) {
          this.#dispose?.(v2, k2, reason);
        }
        if (this.#hasDisposeAfter) {
          this.#disposed?.push([v2, k2, reason]);
        }
      }
    }
    this.#keyMap.clear();
    this.#valList.fill(void 0);
    this.#keyList.fill(void 0);
    if (this.#ttls && this.#starts) {
      this.#ttls.fill(0);
      this.#starts.fill(0);
    }
    if (this.#sizes) {
      this.#sizes.fill(0);
    }
    this.#head = 0;
    this.#tail = 0;
    this.#free.length = 0;
    this.#calculatedSize = 0;
    this.#size = 0;
    if (this.#hasDisposeAfter && this.#disposed) {
      const dt2 = this.#disposed;
      let task;
      while (task = dt2?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
  }
}
const log$6 = globalLogger.createChild("JettonsManager");
class JettonsManager {
  eventEmitter;
  apiClient;
  cache;
  // private readonly TONCENTER_V3_BASE = 'https://toncenter.com/api/v3';
  DEFAULT_TIMEOUT = 1e4;
  // 10 seconds
  constructor(cacheSize = 1e4, eventEmitter, apiClient) {
    this.eventEmitter = eventEmitter;
    this.apiClient = apiClient;
    this.cache = new LRUCache({
      max: cacheSize,
      ttl: 1e3 * 60 * 10
      // 10 minutes TTL
    });
    this.cache.set("TON", {
      address: "TON",
      name: "TON",
      symbol: "TON",
      description: "The Open Network native token",
      decimals: 9,
      totalSupply: "5000000000000000000",
      image: "https://asset.ston.fi/img/EQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM9c/ee9fb21d17bc8d75c2a5f7b5f5f62d2bacec6b128f58b63cb841e98f7b74c4fc",
      verification: {
        verified: true,
        source: "manual"
      }
    });
    log$6.info("JettonsManager initialized", { cacheSize });
    this.eventEmitter.on("emulation:result", (emulationResult) => {
      if (emulationResult && typeof emulationResult === "object" && "metadata" in emulationResult) {
        this.addJettonsFromEmulationMetadata(emulationResult.metadata);
      }
    });
  }
  /**
   * Get jetton information by address (sync - cache only)
   */
  async getJettonInfo(jettonAddress) {
    try {
      const normalizedAddress = this.normalizeAddress(jettonAddress);
      const cachedInfo = this.cache.get(normalizedAddress);
      if (cachedInfo) {
        log$6.debug("Jetton info found in cache", { jettonAddress: normalizedAddress });
        return cachedInfo;
      }
      log$6.debug("Jetton info not found in cache", { jettonAddress: normalizedAddress });
      const jettonFromApi = await this.apiClient?.jettonsByAddress({
        address: normalizedAddress,
        offset: 0,
        limit: 1
      });
      if (jettonFromApi && jettonFromApi?.jetton_masters?.length > 0 && jettonFromApi?.jetton_masters?.[0]) {
        const jetton = jettonFromApi?.jetton_masters?.[0];
        const metadata = jettonFromApi?.metadata?.[jetton.address];
        const tokenInfo = metadata?.token_info?.find((t) => t.valid && t.type === "jetton_masters");
        let decimals;
        try {
          decimals = parseInt(tokenInfo?.extra.decimals, 10);
        } catch {
          decimals = 9;
        }
        const result = {
          address: jetton.jetton,
          name: tokenInfo?.name ?? "",
          symbol: tokenInfo?.symbol ?? "",
          description: tokenInfo?.description ?? "",
          decimals,
          image: tokenInfo?.image,
          uri: tokenInfo?.extra?.uri,
          totalSupply: "0"
          //tokenInfo?.extra.totalSupply ?? '',
        };
        this.cache.set(jetton.jetton, result);
        return result;
      }
      return null;
    } catch (error2) {
      log$6.error("Error getting jetton info", { error: error2, jettonAddress });
      return null;
    }
  }
  /**
   * Get jettons for a specific address
   */
  async getAddressJettons(userAddress, offset = 0, limit = 50) {
    try {
      if (!this.apiClient) {
        throw new JettonError("Api client not initialized", JettonErrorCode.NETWORK_ERROR);
      }
      const normalizedAddress = this.normalizeAddress(userAddress);
      log$6.debug("Getting address jettons", { userAddress: normalizedAddress, offset, limit });
      const response = await this.apiClient.jettonsByOwnerAddress({
        ownerAddress: normalizedAddress,
        offset,
        limit
      });
      if (!response.jetton_wallets) {
        return [];
      }
      const addressJettons = [];
      for (const item of response.jetton_wallets) {
        try {
          const jettonMetadata = response.metadata[item.jetton];
          const metadataJettonInfo = jettonMetadata?.token_info?.find((info) => typeof info === "object" && info !== null && "type" in info && info.type === "jetton_masters");
          const jettonInfo = metadataJettonInfo ? {
            address: normalizedAddress,
            name: metadataJettonInfo.name,
            symbol: metadataJettonInfo.symbol,
            description: metadataJettonInfo.description,
            image: metadataJettonInfo.image,
            decimals: typeof metadataJettonInfo.extra.decimals === "string" ? parseInt(metadataJettonInfo.extra.decimals, 10) : metadataJettonInfo.extra.decimals,
            image_data: metadataJettonInfo.extra.image_data,
            uri: metadataJettonInfo.extra.uri
          } : await this.getJettonInfo(item.jetton);
          if (jettonInfo) {
            const addressJetton = {
              address: item.jetton,
              name: jettonInfo.name,
              symbol: jettonInfo.symbol,
              description: jettonInfo.description,
              decimals: jettonInfo.decimals,
              balance: item.balance,
              jettonWalletAddress: item.address,
              usdValue: "0",
              image: jettonInfo.image,
              verification: jettonInfo.verification,
              metadata: jettonInfo.metadata,
              totalSupply: jettonInfo.totalSupply,
              uri: jettonInfo.uri,
              image_data: jettonInfo.image_data
              // lastActivity: item.last_transaction_lt,
            };
            addressJettons.push(addressJetton);
          }
        } catch (error2) {
          log$6.warn("Failed to get jetton info for address jetton", {
            jettonAddress: item.jetton,
            error: error2
          });
        }
      }
      log$6.debug("Retrieved address jettons", { count: addressJettons.length });
      return addressJettons;
    } catch (error2) {
      log$6.error("Failed to get address jettons", { error: error2, userAddress });
      throw new JettonError(`Failed to get jettons for address: ${error2 instanceof Error ? error2.message : "Unknown error"}`, JettonErrorCode.NETWORK_ERROR, error2);
    }
  }
  /**
   * Add jetton info to cache from emulation data
   */
  addJettonFromEmulation(jettonAddress, emulationInfo) {
    try {
      const normalizedAddress = this.normalizeAddress(jettonAddress);
      const jettonInfo = {
        address: normalizedAddress,
        name: emulationInfo.name,
        symbol: emulationInfo.symbol,
        description: emulationInfo.description,
        image: emulationInfo.image,
        decimals: typeof emulationInfo.extra.decimals === "string" ? parseInt(emulationInfo.extra.decimals, 10) : emulationInfo.extra.decimals,
        uri: emulationInfo.extra.uri
      };
      this.cache.set(normalizedAddress, jettonInfo);
      log$6.debug("Added jetton info from emulation to cache", {
        jettonAddress: normalizedAddress,
        name: jettonInfo.name,
        symbol: jettonInfo.symbol
      });
    } catch (error2) {
      log$6.error("Error adding jetton from emulation", { error: error2, jettonAddress });
    }
  }
  /**
   * Add multiple jettons from emulation metadata
   */
  addJettonsFromEmulationMetadata(metadata) {
    try {
      let addedCount = 0;
      for (const [jettonAddress, addressMetadata] of Object.entries(metadata)) {
        if (!addressMetadata.is_indexed || !addressMetadata.token_info) {
          continue;
        }
        const jettonMasterInfo = addressMetadata.token_info.find((info) => typeof info === "object" && info !== null && "type" in info && info.type === "jetton_masters");
        if (jettonMasterInfo) {
          log$6.debug("Adding jetton from emulation metadata", { jettonAddress });
          this.addJettonFromEmulation(jettonAddress, jettonMasterInfo);
          addedCount++;
        }
      }
      if (addedCount > 0) {
        log$6.info("Added jettons from emulation metadata", { addedCount });
      }
    } catch (error2) {
      log$6.error("Error adding jettons from emulation metadata", { error: error2 });
    }
  }
  /**
   * Normalize jetton address for consistent caching
   */
  normalizeAddress(address) {
    if (address === "TON") {
      return "TON";
    }
    return distExports$3.Address.parse(address).toRawString().toUpperCase();
  }
  /**
   * Get cache statistics
   */
  getCacheStats() {
    return {
      size: this.cache.size,
      capacity: this.cache.max
    };
  }
  /**
   * Validate jetton address format
   */
  validateJettonAddress(address) {
    try {
      if (address === "TON") {
        return true;
      }
      distExports$3.Address.parse(address);
      return true;
    } catch {
      return false;
    }
  }
  /**
   * Clear the jetton cache
   */
  clearCache() {
    this.cache.clear();
    this.cache.set("TON", {
      address: "TON",
      name: "TON",
      symbol: "TON",
      description: "The Open Network native token",
      decimals: 9,
      totalSupply: "5000000000000000000",
      image: "https://asset.ston.fi/img/EQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM9c/ee9fb21d17bc8d75c2a5f7b5f5f62d2bacec6b128f58b63cb841e98f7b74c4fc",
      verification: {
        verified: true,
        source: "manual"
      }
    });
    log$6.info("Jetton cache cleared");
  }
}
const log$5 = globalLogger.createChild("EventEmitter");
class EventEmitter {
  listeners = /* @__PURE__ */ new Map();
  /**
   * Subscribe to an event
   */
  on(eventName, listener) {
    if (!this.listeners.has(eventName)) {
      this.listeners.set(eventName, /* @__PURE__ */ new Set());
    }
    this.listeners.get(eventName).add(listener);
    log$5.debug("Event listener added", { eventName, totalListeners: this.listeners.get(eventName).size });
  }
  /**
   * Subscribe to an event once (automatically removes after first emission)
   */
  once(eventName, listener) {
    const onceListener = (data) => {
      this.off(eventName, onceListener);
      listener(data);
    };
    this.on(eventName, onceListener);
  }
  /**
   * Unsubscribe from an event
   */
  off(eventName, listener) {
    const eventListeners = this.listeners.get(eventName);
    if (eventListeners) {
      eventListeners.delete(listener);
      log$5.debug("Event listener removed", { eventName, totalListeners: eventListeners.size });
      if (eventListeners.size === 0) {
        this.listeners.delete(eventName);
      }
    }
  }
  /**
   * Emit an event to all subscribers
   */
  emit(eventName, data) {
    const eventListeners = this.listeners.get(eventName);
    if (eventListeners) {
      log$5.debug("Emitting event", { eventName, listenerCount: eventListeners.size });
      eventListeners.forEach((listener) => {
        try {
          listener(data);
        } catch (error2) {
          log$5.error("Error in event listener", { eventName, error: error2 });
        }
      });
    }
  }
  /**
   * Remove all listeners for a specific event
   */
  removeAllListeners(eventName) {
    if (eventName) {
      this.listeners.delete(eventName);
      log$5.debug("All listeners removed for event", { eventName });
    } else {
      this.listeners.clear();
      log$5.debug("All event listeners cleared");
    }
  }
  /**
   * Get the number of listeners for an event
   */
  listenerCount(eventName) {
    return this.listeners.get(eventName)?.size || 0;
  }
  /**
   * Get all event names that have listeners
   */
  eventNames() {
    return Array.from(this.listeners.keys());
  }
}
var ContentType;
(function(ContentType2) {
  ContentType2["Json"] = "application/json";
  ContentType2["JsonApi"] = "application/vnd.api+json";
  ContentType2["FormData"] = "multipart/form-data";
  ContentType2["UrlEncoded"] = "application/x-www-form-urlencoded";
  ContentType2["Text"] = "text/plain";
})(ContentType || (ContentType = {}));
class HttpClient {
  baseUrl = "";
  securityData = null;
  securityWorker;
  abortControllers = /* @__PURE__ */ new Map();
  customFetch = (...fetchParams) => fetch(...fetchParams);
  baseApiParams = {
    credentials: "same-origin",
    headers: {},
    redirect: "follow",
    referrerPolicy: "no-referrer"
  };
  constructor(apiConfig = {}) {
    Object.assign(this, apiConfig);
  }
  setSecurityData = (data) => {
    this.securityData = data;
  };
  encodeQueryParam(key2, value) {
    const encodedKey = encodeURIComponent(key2);
    return `${encodedKey}=${encodeURIComponent(typeof value === "number" ? value : `${value}`)}`;
  }
  addQueryParam(query, key2) {
    return this.encodeQueryParam(key2, query[key2]);
  }
  addArrayQueryParam(query, key2) {
    const value = query[key2];
    return value.map((v2) => this.encodeQueryParam(key2, v2)).join("&");
  }
  toQueryString(rawQuery) {
    const query = rawQuery || {};
    const keys = Object.keys(query).filter((key2) => "undefined" !== typeof query[key2]);
    return keys.map((key2) => Array.isArray(query[key2]) ? this.addArrayQueryParam(query, key2) : this.addQueryParam(query, key2)).join("&");
  }
  addQueryParams(rawQuery) {
    const queryString = this.toQueryString(rawQuery);
    return queryString ? `?${queryString}` : "";
  }
  contentFormatters = {
    [ContentType.Json]: (input) => input !== null && (typeof input === "object" || typeof input === "string") ? JSON.stringify(input) : input,
    [ContentType.JsonApi]: (input) => input !== null && (typeof input === "object" || typeof input === "string") ? JSON.stringify(input) : input,
    [ContentType.Text]: (input) => input !== null && typeof input !== "string" ? JSON.stringify(input) : input,
    [ContentType.FormData]: (input) => {
      if (input instanceof FormData) {
        return input;
      }
      return Object.keys(input || {}).reduce((formData, key2) => {
        const property = input[key2];
        formData.append(key2, property instanceof Blob ? property : typeof property === "object" && property !== null ? JSON.stringify(property) : `${property}`);
        return formData;
      }, new FormData());
    },
    [ContentType.UrlEncoded]: (input) => this.toQueryString(input)
  };
  mergeRequestParams(params1, params2) {
    return {
      ...this.baseApiParams,
      ...params1,
      ...params2 || {},
      headers: {
        ...this.baseApiParams.headers || {},
        ...params1.headers || {},
        ...params2 && params2.headers || {}
      }
    };
  }
  createAbortSignal = (cancelToken) => {
    if (this.abortControllers.has(cancelToken)) {
      const abortController2 = this.abortControllers.get(cancelToken);
      if (abortController2) {
        return abortController2.signal;
      }
      return void 0;
    }
    const abortController = new AbortController();
    this.abortControllers.set(cancelToken, abortController);
    return abortController.signal;
  };
  abortRequest = (cancelToken) => {
    const abortController = this.abortControllers.get(cancelToken);
    if (abortController) {
      abortController.abort();
      this.abortControllers.delete(cancelToken);
    }
  };
  request = async ({ body, secure, path, type, query, format, baseUrl, cancelToken, ...params }) => {
    const secureParams = (typeof secure === "boolean" ? secure : this.baseApiParams.secure) && this.securityWorker && await this.securityWorker(this.securityData) || {};
    const requestParams = this.mergeRequestParams(params, secureParams);
    const queryString = query && this.toQueryString(query);
    const payloadFormatter = this.contentFormatters[type || ContentType.Json];
    const responseFormat = format || requestParams.format;
    return this.customFetch(`${baseUrl || this.baseUrl || ""}${path}${queryString ? `?${queryString}` : ""}`, {
      ...requestParams,
      headers: {
        ...requestParams.headers || {}
        // ...(type && type !== ContentType.FormData
        //   ? { "Content-Type": type }
        //   : {}),
      },
      signal: (cancelToken ? this.createAbortSignal(cancelToken) : requestParams.signal) || null,
      body: typeof body === "undefined" || body === null ? null : payloadFormatter(body)
    }).then(async (response) => {
      const r = response;
      r.data = null;
      r.error = null;
      const responseToParse = responseFormat ? response.clone() : response;
      const data = !responseFormat ? r : await responseToParse[responseFormat]().then((data2) => {
        if (r.ok) {
          r.data = data2;
        } else {
          r.error = data2;
        }
        return r;
      }).catch((e) => {
        r.error = e;
        return r;
      });
      if (cancelToken) {
        this.abortControllers.delete(cancelToken);
      }
      if (!response.ok)
        throw data;
      return data;
    });
  };
}
class Api extends HttpClient {
  events = {
    /**
     * No description
     *
     * @name EventsCreate
     * @request POST:/events
     */
    eventsCreate: (events, params = {}) => this.request({
      path: `/events`,
      method: "POST",
      body: events,
      type: ContentType.Json,
      ...params,
      credentials: "include"
    })
  };
}
const log$4 = globalLogger.createChild("AnalyticsApi");
class AnalyticsApi {
  api;
  constructor(config) {
    if (config?.enabled) {
      this.api = new Api({
        baseUrl: config?.endpoint ?? "https://analytics.ton.org"
      });
    }
  }
  async sendEvents(events) {
    await this.api?.events.eventsCreate(events).catch(() => {
    });
  }
  async sendEventsWithErrors(events) {
    await this.api?.events.eventsCreate(events).catch((error2) => {
      log$4.info("Failed to send events", { error: error2 });
    });
  }
}
function parseStackItem(item) {
  switch (item.type) {
    case "num":
      if (item.value.startsWith("-")) {
        return { type: "int", value: -BigInt(item.value.slice(1)) };
      } else {
        return { type: "int", value: BigInt(item.value) };
      }
    case "null":
      return { type: "null" };
    case "cell":
      return { type: "cell", cell: distExports$3.Cell.fromBoc(Buffer.from(item.value, "base64"))[0] };
    case "tuple":
    case "list":
      if (item.value.length === 0) {
        return { type: "null" };
      }
      return { type: "tuple", items: item.value.map((value) => parseStackItem(value)) };
    default:
      throw Error(`Unsupported parse stack item type: ${JSON.stringify(item)}`);
  }
}
function parseStack(list) {
  let stack = [];
  for (let item of list) {
    stack.push(parseStackItem(item));
  }
  return new distExports$3.TupleReader(stack);
}
function serializeStackItem(item) {
  switch (item.type) {
    case "int":
      return { type: "num", value: `${item.value < 0 ? "-" : ""}0x${item.value.toString(16)}` };
    case "slice":
      return { type: "slice", value: item.cell.toBoc().toString("base64") };
    case "cell":
      return { type: "cell", value: item.cell.toBoc().toString("base64") };
    default:
      throw Error(`Unsupported serialize stack item type: ${item.type}`);
  }
}
function serializeStack(list) {
  let stack = [];
  for (let item of list) {
    stack.push(serializeStackItem(item));
  }
  return stack;
}
function toNftCollection(data) {
  if (!data)
    return null;
  const out = {
    address: asAddressFriendly(data.address),
    codeHash: data.code_hash ? Base64ToHex(data.code_hash) : null,
    dataHash: data.data_hash ? Base64ToHex(data.data_hash) : null,
    nextItemIndex: BigInt(data.next_item_index),
    ownerAddress: asMaybeAddressFriendly(data.owner_address)
  };
  if (data.last_transaction_lt)
    out.lastTransactionLt = BigInt(data.last_transaction_lt);
  if (data.collection_content)
    out.collectionContent = data.collection_content;
  return out;
}
function toNftItem(data) {
  const out = {
    address: asAddressFriendly(data.address),
    auctionContractAddress: asMaybeAddressFriendly(data.auction_contract_address),
    codeHash: data.code_hash ? Base64ToHex(data.code_hash) : null,
    dataHash: data.data_hash ? Base64ToHex(data.data_hash) : null,
    collection: toNftCollection(data.collection),
    collectionAddress: asMaybeAddressFriendly(data.collection_address),
    index: BigInt(data.index),
    init: data.init,
    onSale: data.on_sale,
    ownerAddress: asMaybeAddressFriendly(data.owner_address),
    realOwner: asMaybeAddressFriendly(data.real_owner),
    saleContractAddress: asMaybeAddressFriendly(data.sale_contract_address)
  };
  if (data.last_transaction_lt)
    out.lastTransactionLt = BigInt(data.last_transaction_lt);
  if (data.content)
    out.content = data.content;
  return out;
}
function toTokenInfo(data) {
  return {
    valid: data.valid,
    type: data.type,
    name: data.name,
    description: data.description,
    image: data.image,
    extra: data.extra
  };
}
function toNftItemsResponse(data, pagination) {
  const metadata = {};
  if (data.metadata) {
    for (const address of Object.keys(data.metadata)) {
      metadata[asAddressFriendly(address)] = {
        isIndexed: data.metadata[address].is_indexed,
        tokenInfo: (data.metadata[address].token_info ?? []).map(toTokenInfo)
      };
    }
  }
  const out = {
    addressBook: {},
    metadata,
    items: (data.nft_items ?? []).map((data2) => {
      const item = toNftItem(data2);
      const meta = metadata[item.address];
      if (meta) {
        const tokenInfo = meta.tokenInfo.filter((it2) => it2.valid);
        if (tokenInfo.length > 0) {
          item.metadata = tokenInfo[0];
        }
      }
      return item;
    }),
    pagination
  };
  if (out.items.length === 0) {
    out.pagination.pages = 0;
  }
  if (data.address_book) {
    for (const address of Object.keys(data.address_book)) {
      out.addressBook[asAddressFriendly(address)] = {
        domain: data.address_book[address].domain
      };
    }
  }
  return out;
}
function toDnsRecord(data) {
  return {
    dnsNextResolver: data.dns_next_resolver,
    dnsSiteAdnl: data.dns_site_adnl,
    dnsStorageBagId: data.dns_storage_bag_id,
    dnsWallet: data.dns_wallet,
    domain: data.domain,
    nftItemAddress: asAddressFriendly(data.nft_item_address),
    nftItemOwner: asAddressFriendly(data.nft_item_owner)
  };
}
function toDnsRecords(data) {
  const out = {
    addressBook: {},
    records: data.records ? data.records.map(toDnsRecord) : []
  };
  for (const key2 of Object.keys(data.address_book)) {
    out.addressBook[asAddressFriendly(key2)] = {
      domain: data.address_book[key2].domain
    };
  }
  return out;
}
const ROOT_DNS_RESOLVER_MAINNET = "Ef_lZ1T4NCb2mwkme9h2rJfESCE0W34ma9lWp7-_uY3zXDvq";
const ROOT_DNS_RESOLVER_TESTNET = "kf_v5x0Thgr6pq6ur2NvkWhIf4DxAxsL-Nk5rknT6n99oEkd";
var DnsCategory;
(function(DnsCategory2) {
  DnsCategory2["DnsNextResolver"] = "dns_next_resolver";
  DnsCategory2["Wallet"] = "wallet";
  DnsCategory2["Site"] = "site";
  DnsCategory2["BagId"] = "storage";
  DnsCategory2[DnsCategory2["All"] = 0] = "All";
})(DnsCategory || (DnsCategory = {}));
var DnsRecord;
(function(DnsRecord2) {
  DnsRecord2[DnsRecord2["SmcAddress"] = 40915] = "SmcAddress";
  DnsRecord2[DnsRecord2["NextResolver"] = 47763] = "NextResolver";
  DnsRecord2[DnsRecord2["AdnlAddress"] = 44289] = "AdnlAddress";
  DnsRecord2[DnsRecord2["StorageAddress"] = 29811] = "StorageAddress";
})(DnsRecord || (DnsRecord = {}));
function toDnsInternal(domain) {
  domain = domain.toLowerCase().normalize("NFC");
  return domain.split(".").filter(Boolean).reverse().join("\0") + "\0";
}
function toTonDnsCategory(category) {
  category = category ?? DnsCategory.All;
  if (typeof category === "number") {
    return BigInt(category);
  }
  return BigInt("0x" + distExports$1.sha256_sync(category).toString("hex"));
}
async function dnsResolve(client, domain, category, resolver) {
  let currentResolver = resolver ?? ROOT_DNS_RESOLVER_MAINNET;
  let unresolved = domain;
  let maxResolveDepth = 100;
  while (maxResolveDepth > 0) {
    maxResolveDepth--;
    const step = await dnsLookup(client, unresolved, DnsCategory.DnsNextResolver, currentResolver);
    if (step == null) {
      return null;
    }
    if (step.unresolved) {
      if (!step.value) {
        return null;
      }
      currentResolver = step.value;
      unresolved = step.unresolved;
      continue;
    }
    if (step.record === "NextResolver" && step.value) {
      if (category !== void 0) {
        return dnsLookup(client, ".", category, step.value);
      }
      currentResolver = step.value;
      unresolved = ".";
      continue;
    }
    if (category !== void 0) {
      return dnsLookup(client, ".", category, currentResolver);
    }
    return step;
  }
  return null;
}
async function dnsLookup(client, domain, category, resolver) {
  category = category ?? DnsCategory.DnsNextResolver;
  resolver = resolver ?? ROOT_DNS_RESOLVER_MAINNET;
  const result = {
    resolved: "",
    unresolved: ""
  };
  const isSelf = domain === "." || domain === "";
  const internal = toDnsInternal(domain);
  const param = [
    { type: "slice", cell: toStringTail(internal) },
    { type: "int", value: toTonDnsCategory(category) }
  ];
  const { stack, exitCode } = await client.runGetMethod(resolver, "dnsresolve", param);
  if (exitCode !== 0) {
    return null;
  }
  const resolvedBit = stack.readNumber();
  if (resolvedBit === 0 || resolvedBit % 8 !== 0) {
    return null;
  }
  const resolvedByte = resolvedBit / 8;
  const part = isSelf ? [] : domain.split(".").filter(Boolean);
  const level = internal.slice(0, Number(resolvedByte)).split(".").filter(Boolean).length;
  result.unresolved = part.slice(0, part.length - level).join(".");
  result.resolved = part.slice(part.length - level).join(".");
  if (category === DnsCategory.All) {
    throw new Error("not implemented all categories are requested");
  }
  const cell = stack.readCellOpt();
  if (!cell) {
    return result;
  }
  const slice = cell.asSlice();
  const tag = slice.loadUint(16);
  if (tag == DnsRecord.NextResolver || tag == DnsRecord.SmcAddress) {
    result.value = slice.loadAddress().toString();
  } else if (tag == DnsRecord.AdnlAddress || tag == DnsRecord.StorageAddress) {
    result.value = toHexString(slice.loadBuffer(32));
  } else {
    result.value = cell.toBoc().toString("base64");
  }
  if (result.value) {
    result.record = DnsRecord[tag];
  }
  return result;
}
const log$3 = globalLogger.createChild("ApiClientToncenter");
class TonClientError extends Error {
  status;
  details;
  constructor(message, status, details) {
    super(message);
    this.name = "TonClientError";
    this.status = status;
    this.details = details;
  }
}
class ApiClientToncenter {
  dnsResolver;
  endpoint;
  apiKey;
  timeout;
  fetchApi;
  network;
  constructor(config = {}) {
    this.network = config.network;
    const dnsResolver = this.network === CHAIN.MAINNET ? ROOT_DNS_RESOLVER_MAINNET : ROOT_DNS_RESOLVER_TESTNET;
    const defaultEndpoint = this.network === CHAIN.MAINNET ? "https://toncenter.com" : "https://testnet.toncenter.com";
    this.dnsResolver = config.dnsResolver ?? dnsResolver;
    this.endpoint = config.endpoint ?? defaultEndpoint;
    this.apiKey = config.apiKey;
    this.timeout = config.timeout ?? 3e4;
    this.fetchApi = config.fetchApi ?? fetch;
  }
  async nftItemsByAddress(request) {
    const props = {
      address: (request.address ?? []).map(prepareAddress)
    };
    const response = await this.getJson("/api/v3/nft/items", props);
    return toNftItemsResponse(response, {
      limit: 0,
      offset: 0
    });
  }
  async nftItemsByOwner(request) {
    const pagination = {
      limit: request.limit ?? 10,
      offset: request.offset ?? 0
    };
    const props = {
      owner_address: (request.ownerAddress ?? []).map(prepareAddress),
      sort_by_last_transaction_lt: request.sortByLastTransactionLt ?? false,
      limit: pagination.limit,
      offset: pagination.offset
    };
    const response = await this.getJson("/api/v3/nft/items", props);
    return toNftItemsResponse(response, pagination);
  }
  async fetchEmulation(address, messages, seqno) {
    if (address instanceof distExports$3.Address) {
      address = address.toString();
    }
    const props = {
      from: address,
      valid_until: Math.floor(Date.now() / 1e3) + 60,
      include_code_data: true,
      include_address_book: true,
      include_metadata: true,
      with_actions: true,
      messages
    };
    if (typeof seqno === "number")
      props.mc_block_seqno = seqno;
    return this.postJson("/api/emulate/v1/emulateTonConnect", props);
  }
  async sendBoc(boc) {
    if (typeof boc !== "string") {
      boc = Uint8ArrayToBase64(boc);
    }
    const response = await this.postJson("/api/v3/message", { boc });
    return Base64ToBigInt(response.message_hash_norm).toString(16);
  }
  async runGetMethod(address, method, stack = [], seqno) {
    if (address instanceof distExports$3.Address) {
      address = address.toString();
    }
    const props = {
      address,
      method,
      stack: serializeStack(stack)
    };
    if (typeof seqno === "number")
      props.seqno = seqno;
    const raw = await this.postJson("/api/v3/runGetMethod", props);
    return {
      gasUsed: raw.gas_used,
      stack: parseStack(raw.stack),
      exitCode: raw.exit_code
    };
  }
  async getAccountState(address, seqno) {
    if (address instanceof distExports$3.Address) {
      address = address.toString();
    }
    const query = { include_boc: true, address: [address] };
    if (typeof seqno === "number")
      query.seqno = seqno.toString();
    const raw = await this.getJson("/api/v3/addressInformation", query);
    const balance = BigInt(raw.balance);
    const extraCurrencies = {};
    for (const currency of raw.extra_currencies || []) {
      extraCurrencies[currency.id] = BigInt(currency.amount);
    }
    const out = {
      status: raw.status,
      balance: balance.toString(),
      extraCurrencies,
      code: raw.code,
      data: raw.data,
      lastTransaction: parseInternalTransactionId({
        hash: raw.last_transaction_hash,
        lt: raw.last_transaction_lt
      })
    };
    if (raw.frozen_hash) {
      out.frozenHash = Base64ToHex(raw.frozen_hash) ?? void 0;
    }
    return out;
  }
  async getBalance(address, seqno) {
    return (await this.getAccountState(address, seqno)).balance;
  }
  async doRequest(url, init = {}) {
    const fetchFn = this.fetchApi;
    if (!this.timeout || this.timeout <= 0) {
      return fetchFn(url, init);
    }
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.timeout);
    try {
      return await fetchFn(url, { ...init, signal: controller.signal });
    } finally {
      clearTimeout(timeoutId);
    }
  }
  async fetch(url, props = {}) {
    const headers = new Headers(props.headers);
    headers.set("accept", "application/json");
    if (this.apiKey)
      headers.set("x-api-key", this.apiKey);
    props = { ...props, headers };
    const response = await this.doRequest(url, props);
    if (!response.ok) {
      throw await this.buildError(response);
    }
    const contentType = response.headers.get("content-type") || "";
    if (!contentType.includes("application/json")) {
      const text = await response.text();
      throw new TonClientError("Unexpected non-JSON response", response.status, text.slice(0, 200));
    }
    const json = await response.json();
    return json;
  }
  async getJson(path, query) {
    return this.fetch(this.buildUrl(path, query), { method: "GET" });
  }
  async postJson(path, props) {
    return this.fetch(this.buildUrl(path), {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify(props)
    });
  }
  buildUrl(path, query = {}) {
    const url = new URL(path.replace(/^\/*/, "/"), this.endpoint);
    for (const [key2, value] of Object.entries(query)) {
      if (typeof value === "string")
        url.searchParams.set(key2, value);
      else if (Array.isArray(value)) {
        for (const item of value) {
          if (typeof item === "string")
            url.searchParams.set(key2, item);
          else if (item != null && typeof item.toString === "function") {
            url.searchParams.set(key2, item.toString());
          }
        }
      } else if (value != null && typeof value.toString === "function") {
        url.searchParams.set(key2, value.toString());
      }
    }
    return url;
  }
  async buildError(response) {
    const message = response.statusText || "HTTP Error";
    const code = response.status ?? 500;
    let detail;
    try {
      detail = await response.json();
    } catch {
    }
    return new TonClientError(`HTTP ${response.status}: ${message}`, code, detail);
  }
  async getAccountTransactions(request) {
    const accounts = request.address?.map(prepareAddress);
    let offset = request.offset ?? 0;
    let limit = request.limit ?? 10;
    if (limit > 100) {
      limit = 100;
    } else if (limit < 0) {
      limit = 0;
    }
    if (offset < 0) {
      offset = 0;
    }
    const response = await this.getJson("/api/v3/transactions", {
      account: accounts,
      limit,
      offset
    });
    return response;
  }
  async getTransactionsByHash(request) {
    const msgHash = "msgHash" in request ? padBase64(request.msgHash) : void 0;
    const bodyHash = "bodyHash" in request ? padBase64(request.bodyHash) : void 0;
    const response = await this.getJson("/api/v3/transactionsByMessage", {
      msg_hash: msgHash ? [msgHash] : void 0,
      body_hash: bodyHash ? [bodyHash] : void 0
    });
    return response;
  }
  async getPendingTransactions(request) {
    const accounts = "accounts" in request ? request.accounts?.map(prepareAddress) : void 0;
    const traceId = "traceId" in request ? request.traceId : void 0;
    const response = await this.getJson("/api/v3/pendingTransactions", {
      account: accounts,
      trace_id: traceId
    });
    return response;
  }
  async getTrace(request) {
    const inTraceId = request.traceId ? request.traceId[0] : void 0;
    const traceId = padBase64(Base64Normalize(inTraceId || "").replace(/=/g, ""));
    try {
      const response = await CallForSuccess(() => this.getJson("/api/v3/traces", {
        tx_hash: traceId
      }));
      if (response.traces.length > 0) {
        return response;
      }
    } catch (error2) {
      log$3.error("Error fetching trace", { error: error2 });
    }
    try {
      const response = await CallForSuccess(() => this.getJson("/api/v3/traces", {
        trace_id: traceId
      }));
      if (response.traces.length > 0) {
        return response;
      }
    } catch (error2) {
      log$3.error("Error fetching trace", { error: error2 });
    }
    try {
      const response = await CallForSuccess(() => this.getJson("/api/v3/traces", {
        msg_hash: traceId
      }));
      if (response.traces.length > 0) {
        return response;
      }
    } catch (error2) {
      log$3.error("Error fetching pending trace", { error: error2 });
    }
    throw new Error("Failed to fetch trace");
  }
  async getPendingTrace(request) {
    try {
      const response = await CallForSuccess(() => this.getJson("/api/v3/pendingTraces", {
        ext_msg_hash: request.externalMessageHash
      }));
      if (response.traces.length > 0) {
        return response;
      }
    } catch (error2) {
      log$3.error("Error fetching pending trace", { error: error2 });
    }
    throw new Error("Failed to fetch pending trace");
  }
  async resolveDnsWallet(domain) {
    const result = await dnsResolve(this, domain, DnsCategory.Wallet, this.dnsResolver);
    if (result && result.value) {
      return result.value;
    }
    return null;
  }
  async backResolveDnsWallet(wallet) {
    if (wallet instanceof distExports$3.Address) {
      wallet = wallet.toString();
    }
    const response = toDnsRecords(await this.getJson("/api/v3/dns/records", {
      wallet,
      limit: 1,
      offset: 0
    }));
    if (response.records.length > 0) {
      return response.records[0].domain;
    }
    return null;
  }
  async jettonsByAddress(request) {
    return this.getJson("/api/v3/jetton/masters", {
      address: request.address,
      offset: request.offset,
      limit: request.limit
    });
  }
  async jettonsByOwnerAddress(request) {
    return this.getJson("/api/v3/jetton/wallets", {
      owner_address: request.ownerAddress,
      offset: request.offset,
      limit: request.limit
    });
  }
}
const padBase64 = (data) => {
  return data.padEnd(data.length + (4 - data.length % 4), "=");
};
function prepareAddress(address) {
  if (address instanceof distExports$3.Address) {
    address = address.toString();
  }
  return address;
}
function parseInternalTransactionId(data) {
  if (data.hash !== "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=") {
    return {
      lt: data.lt,
      hash: Base64ToHex(data.hash)
    };
  }
  return null;
}
const log$2 = globalLogger.createChild("TonWalletKit");
class TonWalletKit {
  // Component references
  walletManager;
  sessionManager;
  eventRouter;
  requestProcessor;
  // private responseHandler!: ResponseHandler;
  tonClient;
  jettonsManager;
  initializer;
  eventProcessor;
  bridgeManager;
  config;
  // Event emitter for this kit instance
  eventEmitter;
  // State
  isInitialized = false;
  initializationPromise;
  analyticsApi;
  constructor(options) {
    this.config = options;
    if (options?.analytics?.enabled) {
      this.analyticsApi = new AnalyticsApi(options?.analytics);
    }
    this.tonClient = this.initializeTonClient(options);
    this.eventEmitter = new EventEmitter();
    this.initializer = new Initializer(options, this.eventEmitter, this.analyticsApi);
    this.initializationPromise = this.initialize();
    this.jettonsManager = new JettonsManager(1e4, this.eventEmitter, this.tonClient);
    this.eventEmitter.on("restoreConnection", async (event) => {
      if (!event.domain) {
        log$2.error("Domain is required for restore connection");
        return;
      }
      const session = await this.sessionManager.getSessionByDomain(event.domain);
      if (!session) {
        log$2.error("Session not found for domain", { domain: event.domain });
        return;
      }
      const deviceInfo = getDeviceInfoWithDefaults(this.config.deviceInfo);
      const connectResponse = {
        event: "connect",
        id: Date.now(),
        payload: {
          device: deviceInfo,
          items: [
            {
              name: "ton_addr",
              address: distExports$3.Address.parse(session.walletAddress).toRawString(),
              network: this.getNetwork(),
              walletStateInit: "",
              publicKey: ""
            }
          ]
        }
      };
      this.bridgeManager.sendJsBridgeResponse(event?.tabId?.toString() || "", true, event?.id ?? event?.messageId, connectResponse);
    });
  }
  // === Initialization ===
  /**
   * Initialize all components
   */
  async initialize() {
    if (this.isInitialized)
      return;
    try {
      const components = await this.initializer.initialize(this.config, this.tonClient);
      this.assignComponents(components);
      this.setupEventRouting();
      this.eventProcessor.startRecoveryLoop();
      await this.eventProcessor.startNoWalletProcessing();
      this.isInitialized = true;
    } catch (error2) {
      log$2.error("TonWalletKit initialization failed", { error: error2?.toString() });
      throw error2;
    }
  }
  /**
   * Assign initialized components
   */
  assignComponents(components) {
    this.walletManager = components.walletManager;
    this.sessionManager = components.sessionManager;
    this.eventRouter = components.eventRouter;
    this.requestProcessor = components.requestProcessor;
    this.eventProcessor = components.eventProcessor;
    this.bridgeManager = components.bridgeManager;
  }
  /**
   * Setup event routing from bridge to handlers
   */
  setupEventRouting() {
    this.startProcessingForExistingWallets();
  }
  /**
   * Start event processing for all existing wallets
   */
  async startProcessingForExistingWallets() {
    const wallets2 = this.walletManager.getWallets();
    for (const wallet of wallets2) {
      try {
        await this.eventProcessor.startProcessing(wallet.getAddress());
      } catch (error2) {
        log$2.error("Failed to start event processing for wallet", {
          walletAddress: wallet.getAddress(),
          error: error2
        });
      }
    }
  }
  /**
   * Ensure initialization is complete
   */
  async ensureInitialized() {
    if (this.initializationPromise) {
      await this.initializationPromise;
    }
  }
  getNetwork() {
    return this.config.network ?? CHAIN.TESTNET;
  }
  // === Wallet Management API (Delegated) ===
  getWallets() {
    if (!this.isInitialized) {
      log$2.warn("TonWalletKit not yet initialized, returning empty array");
      return [];
    }
    return this.walletManager.getWallets();
  }
  /**
   * Get wallet by address
   */
  getWallet(address) {
    if (!this.isInitialized) {
      log$2.warn("TonWalletKit not yet initialized, returning undefined");
      return void 0;
    }
    return this.walletManager.getWallet(address);
  }
  async addWallet(adapter) {
    await this.ensureInitialized();
    const wallet = await wrapWalletInterface(adapter, this.tonClient);
    const walletAdded = await this.walletManager.addWallet(wallet);
    if (!walletAdded) {
      return void 0;
    }
    await this.eventProcessor.startProcessing(wallet.getAddress());
    return wallet;
  }
  async removeWallet(argWallet) {
    await this.ensureInitialized();
    const wallet = typeof argWallet === "string" ? this.walletManager.getWallet(argWallet) : argWallet;
    if (!wallet) {
      throw new WalletKitError(ERROR_CODES.WALLET_NOT_FOUND, "Wallet not found for sending transaction", void 0, { walletAddress: typeof argWallet === "string" ? argWallet : "Unknown" });
    }
    await this.eventProcessor.stopProcessing(wallet.getAddress());
    await this.walletManager.removeWallet(wallet);
    await this.sessionManager.removeSessionsForWallet(wallet);
  }
  async clearWallets() {
    await this.ensureInitialized();
    const wallets2 = this.walletManager.getWallets();
    for (const wallet of wallets2) {
      await this.eventProcessor.stopProcessing(wallet.getAddress());
    }
    await this.walletManager.clearWallets();
    await this.sessionManager.clearSessions();
  }
  // === Session Management API (Delegated) ===
  async disconnect(sessionId) {
    await this.ensureInitialized();
    const removeSession = async (sessionId2) => {
      await this.bridgeManager.sendResponse({
        sessionId: sessionId2,
        isJsBridge: false,
        id: Date.now()
      }, {
        event: "disconnect",
        id: Date.now(),
        payload: {}
      });
      await this.sessionManager.removeSession(sessionId2);
    };
    if (sessionId) {
      try {
        await removeSession(sessionId);
      } catch (error2) {
        log$2.error("Failed to remove session", { sessionId, error: error2 });
      }
    } else {
      const sessions = this.sessionManager.getSessions();
      if (sessions.length > 0) {
        for (const session of sessions) {
          try {
            await removeSession(session.sessionId);
          } catch (error2) {
            log$2.error("Failed to remove session", { sessionId: session.sessionId, error: error2 });
          }
        }
      }
    }
  }
  async listSessions() {
    await this.ensureInitialized();
    return this.sessionManager.getSessionsForAPI();
  }
  // === Event Handler Registration (Delegated) ===
  onConnectRequest(cb) {
    if (this.eventRouter) {
      this.eventRouter.onConnectRequest(cb);
    } else {
      this.ensureInitialized().then(() => {
        this.eventRouter.onConnectRequest(cb);
      });
    }
  }
  onTransactionRequest(cb) {
    if (this.eventRouter) {
      this.eventRouter.onTransactionRequest(cb);
    } else {
      this.ensureInitialized().then(() => {
        this.eventRouter.onTransactionRequest(cb);
      });
    }
  }
  onSignDataRequest(cb) {
    if (this.eventRouter) {
      this.eventRouter.onSignDataRequest(cb);
    } else {
      this.ensureInitialized().then(() => {
        this.eventRouter.onSignDataRequest(cb);
      });
    }
  }
  onDisconnect(cb) {
    if (this.eventRouter) {
      this.eventRouter.onDisconnect(cb);
    } else {
      this.ensureInitialized().then(() => {
        this.eventRouter.onDisconnect(cb);
      });
    }
  }
  removeConnectRequestCallback() {
    this.eventRouter.removeConnectRequestCallback();
  }
  removeTransactionRequestCallback() {
    this.eventRouter.removeTransactionRequestCallback();
  }
  removeSignDataRequestCallback() {
    this.eventRouter.removeSignDataRequestCallback();
  }
  removeDisconnectCallback() {
    this.eventRouter.removeDisconnectCallback();
  }
  onRequestError(cb) {
    if (this.eventRouter) {
      this.eventRouter.onRequestError(cb);
    } else {
      this.ensureInitialized().then(() => {
        this.eventRouter.onRequestError(cb);
      });
    }
  }
  removeErrorCallback() {
    this.eventRouter.removeErrorCallback();
  }
  // === URL Processing API ===
  /**
   * Handle pasted TON Connect URL/link
   * Parses the URL and creates a connect request event
   */
  async handleTonConnectUrl(url) {
    await this.ensureInitialized();
    try {
      const parsedUrl = this.parseTonConnectUrl(url);
      if (!parsedUrl) {
        throw new WalletKitError(ERROR_CODES.VALIDATION_ERROR, "Invalid TON Connect URL format", void 0, {
          url
        });
      }
      const bridgeEvent = this.createConnectEventFromUrl(parsedUrl);
      if (!bridgeEvent) {
        throw new WalletKitError(ERROR_CODES.VALIDATION_ERROR, "Invalid TON Connect URL - unable to create bridge event", void 0, { parsedUrl });
      }
      await this.eventRouter.routeEvent(bridgeEvent);
    } catch (error2) {
      log$2.error("Failed to handle TON Connect URL", { error: error2, url });
      throw error2;
    }
  }
  async handleNewTransaction(wallet, data) {
    await this.ensureInitialized();
    data.valid_until ??= Math.floor(Date.now() / 1e3) + 300;
    data.network ??= this.config.network ?? CHAIN.TESTNET;
    const bridgeEvent = {
      id: Date.now().toString(),
      method: "sendTransaction",
      params: [JSON.stringify(data)],
      from: "",
      domain: "",
      isLocal: true,
      walletAddress: wallet.getAddress().toString()
    };
    await this.eventRouter.routeEvent(bridgeEvent);
  }
  /**
   * Parse TON Connect URL to extract connection parameters
   */
  parseTonConnectUrl(url) {
    try {
      let parsedUrl;
      parsedUrl = new URL(url);
      const params = {};
      for (const [key2, value] of parsedUrl.searchParams.entries()) {
        params[key2] = value;
      }
      if (!params.v || !params.id || !params.r) {
        log$2.warn("Missing required TON Connect URL parameters");
        return null;
      }
      return {
        version: params.v,
        clientId: params.id,
        requestId: params.id,
        returnStrategy: params.ret || "back",
        r: params.r,
        ...params
      };
    } catch (error2) {
      log$2.error("Failed to parse TON Connect URL", { error: error2, url });
      return null;
    }
  }
  /**
   * Create bridge event from parsed URL parameters
   */
  createConnectEventFromUrl(params) {
    const rString = params.r;
    const r = rString ? JSON.parse(rString) : void 0;
    if (!r?.manifestUrl || !params.clientId) {
      return void 0;
    }
    return {
      from: params.clientId,
      id: params.requestId,
      method: "connect",
      params: {
        manifest: {
          url: r.manifestUrl
        },
        items: r.items,
        returnStrategy: params.returnStrategy
      },
      timestamp: Date.now(),
      domain: ""
    };
  }
  // === Request Processing API (Delegated) ===
  async approveConnectRequest(event) {
    await this.ensureInitialized();
    return this.requestProcessor.approveConnectRequest(event);
  }
  async rejectConnectRequest(event, reason) {
    await this.ensureInitialized();
    return this.requestProcessor.rejectConnectRequest(event, reason);
  }
  async approveTransactionRequest(event) {
    await this.ensureInitialized();
    return this.requestProcessor.approveTransactionRequest(event);
  }
  async rejectTransactionRequest(event, reason) {
    await this.ensureInitialized();
    return this.requestProcessor.rejectTransactionRequest(event, reason);
  }
  async signDataRequest(event) {
    await this.ensureInitialized();
    return this.requestProcessor.approveSignDataRequest(event);
  }
  async rejectSignDataRequest(event, reason) {
    await this.ensureInitialized();
    return this.requestProcessor.rejectSignDataRequest(event, reason);
  }
  // === TON Client Access ===
  /**
   * Get the shared TON client instance
   */
  getApiClient() {
    if (!this.isInitialized) {
      throw new WalletKitError(ERROR_CODES.INITIALIZATION_ERROR, "TonWalletKit not yet initialized - call initialize() first");
    }
    return this.tonClient;
  }
  // === Lifecycle Management ===
  /**
   * Check if kit is ready for use
   */
  isReady() {
    return this.isInitialized;
  }
  /**
   * Wait for initialization to complete
   */
  async waitForReady() {
    await this.ensureInitialized();
  }
  /**
   * Get initialization status
   */
  getStatus() {
    return {
      initialized: this.isInitialized,
      ready: this.isInitialized
    };
  }
  /**
   * Clean shutdown
   */
  async close() {
    if (this.initializer) {
      await this.initializer.cleanup({
        walletManager: this.walletManager,
        sessionManager: this.sessionManager,
        eventRouter: this.eventRouter,
        requestProcessor: this.requestProcessor,
        // responseHandler: this.responseHandler,
        // tonClient: this.tonClient,
        eventProcessor: this.eventProcessor
      });
    }
    this.isInitialized = false;
  }
  // === Jettons API ===
  /**
   * Jettons API access
   */
  get jettons() {
    return this.jettonsManager;
  }
  /**
   * Get jettons manager for internal use
   */
  getJettonsManager() {
    return this.jettonsManager;
  }
  /**
   * Get the event emitter for this kit instance
   * Allows external components to listen to and emit events
   */
  getEventEmitter() {
    return this.eventEmitter;
  }
  /**
   * Process a bridge request from injected JS Bridge
   * This method is called by extension content scripts
   * @param request - The bridge request to process
   * @returns Promise resolving to the response data
   */
  async processInjectedBridgeRequest(messageInfo, request) {
    await this.ensureInitialized();
    return this.bridgeManager.queueJsBridgeEvent(messageInfo, request);
  }
  /**
   * Initialize TON client (single provider for all downstream classes)
   */
  initializeTonClient(options) {
    if (options.apiClient && "nftItemsByAddress" in options.apiClient && "nftItemsByOwner" in options.apiClient && "fetchEmulation" in options.apiClient && "sendBoc" in options.apiClient && "runGetMethod" in options.apiClient && "getAccountState" in options.apiClient && "getBalance" in options.apiClient) {
      return options.apiClient;
    }
    const defaultEndpoint = options?.network === CHAIN.MAINNET ? "https://toncenter.com" : "https://testnet.toncenter.com";
    const endpoint = options?.apiClient?.url || defaultEndpoint;
    const clientConfig = {
      endpoint,
      apiKey: options?.apiClient?.key,
      network: options?.network
    };
    return new ApiClientToncenter(clientConfig);
  }
}
const WalletV5R1CodeBoc = "b5ee9c7201021401000281000114ff00f4a413f4bcf2c80b01020120020302014804050102f20e02dcd020d749c120915b8f6320d70b1f2082106578746ebd21821073696e74bdb0925f03e082106578746eba8eb48020d72101d074d721fa4030fa44f828fa443058bd915be0ed44d0810141d721f4058307f40e6fa1319130e18040d721707fdb3ce03120d749810280b99130e070e2100f020120060702012008090019be5f0f6a2684080a0eb90fa02c02016e0a0b0201480c0d0019adce76a2684020eb90eb85ffc00019af1df6a2684010eb90eb858fc00017b325fb51341c75c875c2c7e00011b262fb513435c28020011e20d70b1f82107369676ebaf2e08a7f0f01e68ef0eda2edfb218308d722028308d723208020d721d31fd31fd31fed44d0d200d31f20d31fd3ffd70a000af90140ccf9109a28945f0adb31e1f2c087df02b35007b0f2d0845125baf2e0855036baf2e086f823bbf2d0882292f800de01a47fc8ca00cb1f01cf16c9ed542092f80fde70db3cd81003f6eda2edfb02f404216e926c218e4c0221d73930709421c700b38e2d01d72820761e436c20d749c008f2e09320d74ac002f2e09320d71d06c712c2005230b0f2d089d74cd7393001a4e86c128407bbf2e093d74ac000f2e093ed55e2d20001c000915be0ebd72c08142091709601d72c081c12e25210b1e30f20d74a111213009601fa4001fa44f828fa443058baf2e091ed44d0810141d718f405049d7fc8ca0040048307f453f2e08b8e14038307f45bf2e08c22d70a00216e01b3b0f2d090e2c85003cf1612f400c9ed54007230d72c08248e2d21f2e092d200ed44d0d2005113baf2d08f54503091319c01810140d721d70a00f2e08ee2c8ca0058cf16c9ed5493f2c08de20010935bdb31e1d74cd0";
const WalletV5R1CodeCell = distExports$3.Cell.fromBoc(Buffer.from(WalletV5R1CodeBoc, "hex"))[0];
function DefaultSignature(data, privateKey) {
  return Uint8ArrayToHex(distExports$1.sign(Buffer.from(Uint8Array.from(data)), Buffer.from(privateKey)));
}
function createWalletSigner(privateKey) {
  return async (data) => {
    return DefaultSignature(Uint8Array.from(data), privateKey);
  };
}
const fakeKeyPair = distExports$1.keyPairFromSeed(Buffer.alloc(32, 0));
function FakeSignature(data) {
  return Uint8ArrayToHex([...distExports$1.sign(Buffer.from(Uint8Array.from(data)), Buffer.from(fakeKeyPair.secretKey))]);
}
class ActionSendMsg {
  mode;
  outMsg;
  static tag = 247711853;
  tag = ActionSendMsg.tag;
  constructor(mode, outMsg) {
    this.mode = mode;
    this.outMsg = outMsg;
  }
  serialize() {
    return distExports$3.beginCell().storeUint(this.tag, 32).storeUint(this.mode | distExports$3.SendMode.IGNORE_ERRORS, 8).storeRef(distExports$3.beginCell().store(distExports$3.storeMessageRelaxed(this.outMsg)).endCell()).endCell();
  }
}
class ActionAddExtension {
  address;
  static tag = 2;
  tag = ActionAddExtension.tag;
  constructor(address) {
    this.address = address;
  }
  serialize() {
    return distExports$3.beginCell().storeUint(this.tag, 8).storeAddress(this.address).endCell();
  }
}
class ActionRemoveExtension {
  address;
  static tag = 3;
  tag = ActionRemoveExtension.tag;
  constructor(address) {
    this.address = address;
  }
  serialize() {
    return distExports$3.beginCell().storeUint(this.tag, 8).storeAddress(this.address).endCell();
  }
}
class ActionSetSignatureAuthAllowed {
  allowed;
  static tag = 4;
  tag = ActionSetSignatureAuthAllowed.tag;
  constructor(allowed) {
    this.allowed = allowed;
  }
  serialize() {
    return distExports$3.beginCell().storeUint(this.tag, 8).storeUint(this.allowed ? 1 : 0, 1).endCell();
  }
}
function isExtendedAction(action) {
  return action.tag === ActionAddExtension.tag || action.tag === ActionRemoveExtension.tag || action.tag === ActionSetSignatureAuthAllowed.tag;
}
function packActionsListOut(actions) {
  if (actions.length === 0) {
    return distExports$3.beginCell().endCell();
  }
  const [action, ...rest] = actions;
  if (isExtendedAction(action)) {
    throw new Error("Actions bust be in an order: all extended actions, all out actions");
  }
  return distExports$3.beginCell().storeRef(packActionsListOut(rest)).storeSlice(action.serialize().beginParse()).endCell();
}
function packExtendedActions(extendedActions) {
  const first = extendedActions[0];
  const rest = extendedActions.slice(1);
  let builder2 = distExports$3.beginCell().storeSlice(first.serialize().beginParse());
  if (rest.length > 0) {
    builder2 = builder2.storeRef(packExtendedActions(extendedActions.slice(1)));
  }
  return builder2.endCell();
}
function packActionsListExtended(actions) {
  const extendedActions = [];
  const outActions = [];
  actions.forEach((action) => {
    if (isExtendedAction(action)) {
      extendedActions.push(action);
    } else {
      outActions.push(action);
    }
  });
  let builder2 = distExports$3.beginCell();
  if (outActions.length === 0) {
    builder2 = builder2.storeUint(0, 1);
  } else {
    builder2 = builder2.storeMaybeRef(packActionsListOut(outActions.slice().reverse()));
  }
  if (extendedActions.length === 0) {
    builder2 = builder2.storeUint(0, 1);
  } else {
    const first = extendedActions[0];
    const rest = extendedActions.slice(1);
    builder2 = builder2.storeUint(1, 1).storeSlice(first.serialize().beginParse());
    if (rest.length > 0) {
      builder2 = builder2.storeRef(packExtendedActions(rest));
    }
  }
  return builder2.endCell();
}
function packActionsList(actions) {
  return packActionsListExtended(actions);
}
const log$1 = globalLogger.createChild("WalletV5R1Adapter");
const defaultWalletIdV5R1 = 2147483409;
class WalletV5R1Adapter {
  // private keyPair: { publicKey: Uint8Array; secretKey: Uint8Array };
  signer;
  config;
  walletContract;
  client;
  publicKey;
  version = "v5r1";
  /**
   * Static factory method to create a WalletV5R1Adapter
   * @param signer - Signer function with publicKey property (from Signer utility)
   * @param options - Configuration options for the wallet
   */
  static async create(signer, options) {
    return new WalletV5R1Adapter({
      signer,
      publicKey: signer.publicKey,
      tonClient: options.client,
      network: options.network,
      walletId: options.walletId,
      workchain: options.workchain
    });
  }
  constructor(config) {
    this.config = config;
    this.client = config.tonClient;
    this.signer = config.signer;
    this.publicKey = this.config.publicKey;
    this.walletContract = WalletV5.createFromConfig({
      publicKey: HexToBigInt(this.publicKey),
      seqno: 0,
      signatureAllowed: true,
      walletId: typeof config.walletId === "bigint" ? Number(config.walletId) : config.walletId ?? defaultWalletIdV5R1,
      extensions: distExports$3.Dictionary.empty()
    }, {
      code: WalletV5R1CodeCell,
      workchain: config.workchain ?? 0,
      client: this.client
    });
  }
  /**
   * Sign raw bytes with wallet's private key
   */
  async sign(bytes) {
    return await this.signer.sign(bytes);
  }
  getNetwork() {
    return this.config.network;
  }
  /**
   * Get wallet's TON address
   */
  getAddress(options) {
    return formatWalletAddress(this.walletContract.address, options?.testnet);
  }
  async getSignedSendTransaction(input, options) {
    const actions = packActionsList(input.messages.map((m2) => {
      let bounce = true;
      const parsedAddress = distExports$3.Address.parseFriendly(m2.address);
      if (parsedAddress.isBounceable === false) {
        bounce = false;
      }
      const msg = distExports$3.internal({
        to: m2.address,
        value: BigInt(m2.amount),
        bounce,
        extracurrency: m2.extraCurrency ? Object.fromEntries(Object.entries(m2.extraCurrency).map(([k2, v2]) => [Number(k2), BigInt(v2)])) : void 0
      });
      if (m2.payload) {
        try {
          msg.body = distExports$3.Cell.fromBase64(m2.payload);
        } catch (error2) {
          log$1.warn("Failed to load payload", { error: error2 });
          throw WalletKitError.fromError(ERROR_CODES.CONTRACT_VALIDATION_FAILED, "Failed to parse transaction payload", error2);
        }
      }
      if (m2.stateInit) {
        try {
          msg.init = distExports$3.loadStateInit(distExports$3.Cell.fromBase64(m2.stateInit).asSlice());
        } catch (error2) {
          log$1.warn("Failed to load state init", { error: error2 });
          throw WalletKitError.fromError(ERROR_CODES.CONTRACT_VALIDATION_FAILED, "Failed to parse state init", error2);
        }
      }
      return new ActionSendMsg(distExports$3.SendMode.PAY_GAS_SEPARATELY + distExports$3.SendMode.IGNORE_ERRORS, msg);
    }));
    const createBodyOptions = {
      ...options,
      validUntil: void 0
    };
    if (input.valid_until) {
      const now = Math.floor(Date.now() / 1e3);
      const maxValidUntil = now + 600;
      if (input.valid_until < now) {
        throw new WalletKitError(ERROR_CODES.VALIDATION_ERROR, "Transaction valid_until timestamp is in the past", void 0, { validUntil: input.valid_until, currentTime: now });
      } else if (input.valid_until > maxValidUntil) {
        createBodyOptions.validUntil = maxValidUntil;
      } else {
        createBodyOptions.validUntil = input.valid_until;
      }
    }
    let seqno = 0;
    try {
      seqno = await CallForSuccess(async () => this.getSeqno(), 5, 1e3);
    } catch (_) {
    }
    const walletId = (await this.walletContract.walletId).serialized;
    if (!walletId) {
      throw new Error("Failed to get seqno or walletId");
    }
    const transfer = await this.createBodyV5(seqno, walletId, actions, createBodyOptions);
    const ext = distExports$3.external({
      to: this.walletContract.address,
      init: this.walletContract.init,
      body: transfer
    });
    return distExports$3.beginCell().store(distExports$3.storeMessage(ext)).endCell().toBoc().toString("base64");
  }
  /**
   * Get wallet's current balance in nanotons
   */
  async getBalance() {
    try {
      const balance = await CallForSuccess(async () => this.client.getBalance(this.walletContract.address), 5, 1e3);
      return balance;
    } catch (error2) {
      log$1.warn("Failed to get balance", { error: error2 });
      throw error2;
    }
  }
  /**
   * Get state init for wallet deployment
   */
  async getStateInit() {
    if (!this.walletContract.init) {
      throw new Error("Wallet contract not properly initialized");
    }
    const stateInit = distExports$3.beginCell().store(distExports$3.storeStateInit(this.walletContract.init)).endCell();
    return stateInit.toBoc().toString("base64");
  }
  /**
   * Get the underlying WalletV5 contract
   */
  getContract() {
    return this.walletContract;
  }
  /**
   * Get current sequence number
   */
  async getSeqno() {
    try {
      return await this.walletContract.seqno;
    } catch (error2) {
      log$1.warn("Failed to get seqno", { error: error2 });
      throw error2;
    }
  }
  /**
   * Get wallet ID
   */
  async getWalletId() {
    try {
      return this.walletContract.walletId;
    } catch (error2) {
      log$1.warn("Failed to get wallet ID", { error: error2 });
      const walletId = this.config.walletId;
      const subwalletNumber = typeof walletId === "bigint" ? Number(walletId) : walletId || 0;
      return new WalletId({ subwalletNumber });
    }
  }
  /**
   * Check if wallet is deployed on the network
   */
  async isDeployed() {
    try {
      const state = await this.client.getAccountState(this.walletContract.address);
      return state.status === "active";
    } catch (error2) {
      log$1.warn("Failed to check deployment status", { error: error2 });
      return false;
    }
  }
  async createBodyV5(seqno, walletId, actionsList, options) {
    const Opcodes2 = {
      auth_signed: 1936287598
    };
    const expireAt = options.validUntil ?? Math.floor(Date.now() / 1e3) + 300;
    const payload = distExports$3.beginCell().storeUint(Opcodes2.auth_signed, 32).storeUint(walletId, 32).storeUint(expireAt, 32).storeUint(seqno, 32).storeSlice(actionsList.beginParse()).endCell();
    const signingData = payload.hash();
    const signature = options.fakeSignature ? FakeSignature(signingData) : await this.sign(signingData);
    return distExports$3.beginCell().storeSlice(payload.beginParse()).storeBuffer(Buffer.from(HexToUint8Array(signature))).endCell();
  }
  async getSignedSignData(input) {
    const signature = await this.sign(input.hash);
    return signature;
  }
  async getSignedTonProof(input) {
    const message = await CreateTonProofMessageBytes(input);
    const signature = await this.sign(message);
    return signature;
  }
}
function walletV5ConfigToCell(config) {
  return distExports$3.beginCell().storeBit(config.signatureAllowed).storeUint(config.seqno, 32).storeUint(config.walletId, 32).storeUint(config.publicKey, 256).storeDict(config.extensions, distExports$3.Dictionary.Keys.BigUint(256), distExports$3.Dictionary.Values.BigInt(1)).endCell();
}
const Opcodes = {
  auth_extension: 1702392942
};
class WalletId {
  static deserialize(walletId) {
    return new WalletId({
      subwalletNumber: walletId
    });
  }
  subwalletNumber;
  serialized;
  constructor(args) {
    this.subwalletNumber = args?.subwalletNumber ?? 0;
    this.serialized = BigInt(this.subwalletNumber);
  }
}
class WalletV5 {
  client;
  address;
  init;
  subwalletId;
  constructor(client, address, init) {
    this.client = client;
    this.address = address;
    this.init = init;
  }
  static createFromAddress(client, address) {
    return new WalletV5(client, address);
  }
  static createFromConfig(config, options) {
    const data = walletV5ConfigToCell(config);
    const init = { code: options.code, data };
    const wallet = new WalletV5(options.client, distExports$3.contractAddress(options.workchain, init), init);
    wallet.subwalletId = config.walletId;
    return wallet;
  }
  async sendDeploy(provider, via, value) {
    await provider.internal(via, {
      value,
      sendMode: distExports$3.SendMode.PAY_GAS_SEPARATELY,
      body: distExports$3.beginCell().endCell()
    });
  }
  async sendInternalSignedMessage(provider, via, opts) {
    await provider.internal(via, {
      value: opts.value,
      sendMode: distExports$3.SendMode.PAY_GAS_SEPARATELY,
      body: distExports$3.beginCell().storeSlice(opts.body.beginParse()).endCell()
    });
  }
  async sendInternalMessageFromExtension(provider, via, opts) {
    await provider.internal(via, {
      value: opts.value,
      sendMode: distExports$3.SendMode.PAY_GAS_SEPARATELY,
      body: distExports$3.beginCell().storeUint(Opcodes.auth_extension, 32).storeUint(0, 64).storeSlice(opts.body.beginParse()).endCell()
    });
  }
  async sendInternal(provider, via, opts) {
    await provider.internal(via, opts);
  }
  async sendExternalSignedMessage(provider, body) {
    await provider.external(body);
  }
  async sendExternal(provider, body) {
    await provider.external(body);
  }
  get publicKey() {
    return this.client.runGetMethod(this.address, "get_public_key").then((data) => {
      if (data.exitCode === 0) {
        return data.stack.readBigNumber();
      } else if (this.init) {
        return this.init.data.asSlice().skip(1 + 32 + 32).loadUintBig(256);
      } else {
        return 0n;
      }
    });
  }
  get status() {
    return this.client.getAccountState(this.address).then((state) => state.status);
  }
  get seqno() {
    return this.client.runGetMethod(this.address, "seqno").then((data) => {
      if (data.exitCode === 0) {
        return data.stack.readNumber();
      } else {
        return 0;
      }
    });
  }
  get isSignatureAuthAllowed() {
    return this.client.runGetMethod(this.address, "is_signature_allowed").then((data) => {
      if (data.exitCode === 0) {
        return data.stack.readBoolean();
      } else {
        return false;
      }
    });
  }
  get walletId() {
    if (this.subwalletId !== void 0) {
      return new Promise((resolve) => {
        resolve(WalletId.deserialize(this.subwalletId));
      });
    } else {
      return this.client.runGetMethod(this.address, "get_subwallet_id").then((data) => {
        if (data.exitCode === 0) {
          this.subwalletId = data.stack.readNumber();
          return WalletId.deserialize(this.subwalletId);
        } else {
          return WalletId.deserialize(defaultWalletIdV5R1);
        }
      });
    }
  }
  get extensions() {
    return this.client.runGetMethod(this.address, "get_extensions").then((data) => {
      if (data.exitCode === 0) {
        const dict = distExports$3.Dictionary.loadDirect(distExports$3.Dictionary.Keys.BigUint(256), distExports$3.Dictionary.Values.BigInt(1), data.stack.readCellOpt());
        const wc = this.address.workChain;
        return dict.keys().map((key2) => {
          return distExports$3.Address.parseRaw(`${wc}:${key2.toString(16).padStart(64, "0")}`);
        });
      } else {
        return [];
      }
    });
  }
}
class WalletV4R2 {
  address;
  init;
  workchain;
  publicKey;
  subwalletId;
  client;
  constructor(address, init, options) {
    this.address = address;
    this.init = init ?? void 0;
    this.workchain = options.workchain;
    this.client = options.client;
    if (init) {
      const dataSlice = init.data.beginParse();
      dataSlice.loadUint(32);
      this.subwalletId = dataSlice.loadUint(32);
      this.publicKey = dataSlice.loadUintBig(256);
    } else {
      this.subwalletId = 0;
      this.publicKey = 0n;
    }
  }
  static createFromConfig(config, options) {
    const data = distExports$3.beginCell().storeUint(config.seqno, 32).storeUint(config.subwalletId, 32).storeUint(config.publicKey, 256).storeBit(0).endCell();
    const init = { code: options.code, data };
    const address = distExports$3.contractAddress(options.workchain, init);
    return new WalletV4R2(address, init, options);
  }
  static createFromAddress(address, options) {
    return new WalletV4R2(address, null, options);
  }
  async sendDeploy(provider, via, value) {
    await provider.internal(via, {
      value,
      sendMode: distExports$3.SendMode.PAY_GAS_SEPARATELY,
      body: distExports$3.beginCell().endCell()
    });
  }
  /**
   * Get wallet's current sequence number
   */
  async getSeqno() {
    try {
      const state = await this.client.runGetMethod(this.address, "seqno");
      if (state.exitCode !== 0) {
        return 0;
      }
      return state.stack.readNumber();
    } catch (error2) {
      return 0;
    }
  }
  /**
   * Get wallet's current sequence number (async getter)
   */
  get seqno() {
    return this.getSeqno();
  }
  /**
   * Get wallet's subwallet ID
   */
  async getSubwalletId() {
    try {
      const state = await this.client.runGetMethod(this.address, "get_subwallet_id");
      if (state.exitCode !== 0) {
        return this.subwalletId;
      }
      return state.stack.readNumber();
    } catch (error2) {
      return this.subwalletId;
    }
  }
  /**
   * Create transfer message body
   */
  createTransfer(args) {
    const timeout = args.timeout ?? Math.floor(Date.now() / 1e3) + 60;
    let body = distExports$3.beginCell().storeUint(this.subwalletId, 32).storeUint(timeout, 32).storeUint(args.seqno, 32).storeUint(0, 8).storeUint(args.sendMode, 8);
    for (const message of args.messages) {
      body = body.storeRef(distExports$3.beginCell().store(distExports$3.storeMessageRelaxed(message)));
    }
    return body.endCell();
  }
  /**
   * Send internal transfer
   */
  async sendTransfer(provider, via, args) {
    const transfer = this.createTransfer(args);
    await provider.internal(via, {
      sendMode: distExports$3.SendMode.PAY_GAS_SEPARATELY,
      body: transfer,
      value: 0n
    });
  }
}
const WalletV4R2CodeCell = distExports$3.Cell.fromBoc(Buffer.from("te6ccgECFAEAAtQAART/APSkE/S88sgLAQIBIAIDAgFIBAUE+PKDCNcYINMf0x/THwL4I7vyZO1E0NMf0x/T//QE0VFDuvKhUVG68qIF+QFUEGT5EPKj+AAkpMjLH1JAyx9SMMv/UhD0AMntVPgPAdMHIcAAn2xRkyDXSpbTB9QC+wDoMOAhwAHjACHAAuMAAcADkTDjDQOkyMsfEssfy/8QERITAubQAdDTAyFxsJJfBOAi10nBIJJfBOAC0x8hghBwbHVnvSKCEGRzdHK9sJJfBeAD+kAwIPpEAcjKB8v/ydDtRNCBAUDXIfQEMFyBAQj0Cm+hMbOSXwfgBdM/yCWCEHBsdWe6kjgw4w0DghBkc3RyupJfBuMNBgcCASAICQB4AfoA9AQw+CdvIjBQCqEhvvLgUIIQcGx1Z4MesXCAGFAEywUmzxZY+gIZ9ADLaRfLH1Jgyz8gyYBA+wAGAIpQBIEBCPRZMO1E0IEBQNcgyAHPFvQAye1UAXKwjiOCEGRzdHKDHrFwgBhQBcsFUAPPFiP6AhPLassfyz/JgED7AJJfA+ICASAKCwBZvSQrb2omhAgKBrkPoCGEcNQICEekk30pkQzmkD6f+YN4EoAbeBAUiYcVnzGEAgFYDA0AEbjJftRNDXCx+AA9sp37UTQgQFA1yH0BDACyMoHy//J0AGBAQj0Cm+hMYAIBIA4PABmtznaiaEAga5Drhf/AABmvHfaiaEAQa5DrhY/AAG7SB/oA1NQi+QAFyMoHFcv/ydB3dIAYyMsFywIizxZQBfoCFMtrEszMyXP7AMhAFIEBCPRR8qcCAHCBAQjXGPoA0z/IVCBHgQEI9FHyp4IQbm90ZXB0gBjIywXLAlAGzxZQBPoCFMtqEssfyz/Jc/sAAgBsgQEI1xj6ANM/MFIkgQEI9Fnyp4IQZHN0cnB0gBjIywXLAlAFzxZQA/oCE8tqyx8Syz/Jc/sAAAr0AMntVA==", "base64"))[0];
const defaultWalletIdV4R2 = 698983191;
const log = globalLogger.createChild("WalletV4R2Adapter");
class WalletV4R2Adapter {
  signer;
  config;
  walletContract;
  client;
  publicKey;
  version = "v4r2";
  /**
   * Static factory method to create a WalletV4R2Adapter
   * @param signer - Signer function with publicKey property (from Signer utility)
   * @param options - Configuration options for the wallet
   */
  static async create(signer, options) {
    return new WalletV4R2Adapter({
      signer,
      publicKey: signer.publicKey,
      tonClient: options.client,
      network: options.network,
      walletId: typeof options.walletId === "bigint" ? Number(options.walletId) : options.walletId,
      workchain: options.workchain
    });
  }
  constructor(config) {
    this.config = config;
    this.client = config.tonClient;
    this.signer = config.signer;
    this.publicKey = this.config.publicKey;
    const walletConfig = {
      publicKey: HexToBigInt(this.publicKey),
      workchain: config.workchain ?? 0,
      seqno: 0,
      subwalletId: config.walletId ?? defaultWalletIdV4R2
    };
    this.walletContract = WalletV4R2.createFromConfig(walletConfig, {
      code: WalletV4R2CodeCell,
      workchain: config.workchain ?? 0,
      client: this.client
    });
  }
  /**
   * Sign raw bytes with wallet's private key
   */
  async sign(bytes) {
    return await this.signer.sign(bytes);
  }
  getNetwork() {
    return this.config.network;
  }
  /**
   * Get wallet's TON address
   */
  getAddress(options) {
    return formatWalletAddress(this.walletContract.address, options?.testnet);
  }
  async getSignedSendTransaction(input, _options) {
    if (input.messages.length === 0) {
      throw new Error("Ledger does not support empty messages");
    }
    if (input.messages.length > 4) {
      throw new Error("WalletV4R2 does not support more than 4 messages");
    }
    let seqno = 0;
    try {
      seqno = await CallForSuccess(async () => this.getSeqno(), 5, 1e3);
    } catch (_) {
    }
    const timeout = input.valid_until ? Math.min(input.valid_until, Math.floor(Date.now() / 1e3) + 600) : Math.floor(Date.now() / 1e3) + 60;
    try {
      const messages = input.messages.map((m2) => distExports$3.internal({
        to: distExports$3.Address.parse(m2.address),
        value: BigInt(m2.amount),
        bounce: true,
        extracurrency: m2.extraCurrency ? Object.fromEntries(Object.entries(m2.extraCurrency).map(([k2, v2]) => [Number(k2), BigInt(v2)])) : void 0,
        body: m2.payload ? distExports$3.Cell.fromBase64(m2.payload) : void 0,
        init: m2.stateInit ? distExports$3.loadStateInit(distExports$3.Cell.fromBase64(m2.stateInit).asSlice()) : void 0
      }));
      const data = this.walletContract.createTransfer({
        seqno,
        sendMode: distExports$3.SendMode.PAY_GAS_SEPARATELY + distExports$3.SendMode.IGNORE_ERRORS,
        messages,
        timeout
      });
      const signature = await this.sign(Uint8Array.from(data.hash()));
      const signedCell = distExports$3.beginCell().storeBuffer(Buffer.from(HexToUint8Array(signature))).storeSlice(data.asSlice()).endCell();
      const ext = distExports$3.external({
        to: this.walletContract.address,
        init: this.walletContract.init,
        body: signedCell
      });
      return distExports$3.beginCell().store(distExports$3.storeMessage(ext)).endCell().toBoc().toString("base64");
    } catch (error2) {
      log.warn("Failed to get signed send transaction", { error: error2 });
      throw error2;
    }
  }
  /**
   * Get wallet's current balance in nanotons
   */
  async getBalance() {
    try {
      const balance = await CallForSuccess(async () => this.client.getBalance(this.walletContract.address), 5, 1e3);
      return balance;
    } catch (error2) {
      log.warn("Failed to get balance", { error: error2 });
      throw error2;
    }
  }
  /**
   * Get state init for wallet deployment
   */
  async getStateInit() {
    if (!this.walletContract.init) {
      throw new Error("Wallet contract not properly initialized");
    }
    const stateInit = distExports$3.beginCell().store(distExports$3.storeStateInit(this.walletContract.init)).endCell();
    return stateInit.toBoc().toString("base64");
  }
  /**
   * Get the underlying WalletV4R2 contract
   */
  getContract() {
    return this.walletContract;
  }
  /**
   * Get current sequence number
   */
  async getSeqno() {
    try {
      return await this.walletContract.getSeqno();
    } catch (error2) {
      log.warn("Failed to get seqno", { error: error2 });
      throw error2;
    }
  }
  /**
   * Get wallet's subwallet ID
   */
  async getSubwalletId() {
    try {
      return await this.walletContract.getSubwalletId();
    } catch (error2) {
      log.warn("Failed to get subwallet ID", { error: error2 });
      return this.config.walletId ?? defaultWalletIdV4R2;
    }
  }
  /**
   * Check if wallet is deployed on the network
   */
  async isDeployed() {
    try {
      const state = await this.client.getAccountState(this.walletContract.address);
      return state.status === "active";
    } catch (error2) {
      log.warn("Failed to check deployment status", { error: error2 });
      return false;
    }
  }
  async getSignedSignData(input) {
    const signature = await this.sign(input.hash);
    return signature;
  }
  async getSignedTonProof(input) {
    const message = await CreateTonProofMessageBytes(input);
    const signature = await this.sign(message);
    return signature;
  }
}
var src = {};
var sha256 = {};
var sha2 = {};
var _md = {};
var utils = {};
var crypto$1 = {};
var hasRequiredCrypto;
function requireCrypto() {
  if (hasRequiredCrypto) return crypto$1;
  hasRequiredCrypto = 1;
  Object.defineProperty(crypto$1, "__esModule", { value: true });
  crypto$1.crypto = void 0;
  crypto$1.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  return crypto$1;
}
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  (function(exports) {
    /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.Hash = exports.nextTick = exports.swap32IfBE = exports.byteSwapIfBE = exports.swap8IfBE = exports.isLE = void 0;
    exports.isBytes = isBytes;
    exports.anumber = anumber;
    exports.abytes = abytes;
    exports.ahash = ahash;
    exports.aexists = aexists;
    exports.aoutput = aoutput;
    exports.u8 = u8;
    exports.u32 = u32;
    exports.clean = clean;
    exports.createView = createView;
    exports.rotr = rotr;
    exports.rotl = rotl;
    exports.byteSwap = byteSwap;
    exports.byteSwap32 = byteSwap32;
    exports.bytesToHex = bytesToHex;
    exports.hexToBytes = hexToBytes;
    exports.asyncLoop = asyncLoop;
    exports.utf8ToBytes = utf8ToBytes;
    exports.bytesToUtf8 = bytesToUtf8;
    exports.toBytes = toBytes;
    exports.kdfInputToBytes = kdfInputToBytes;
    exports.concatBytes = concatBytes;
    exports.checkOpts = checkOpts;
    exports.createHasher = createHasher;
    exports.createOptHasher = createOptHasher;
    exports.createXOFer = createXOFer;
    exports.randomBytes = randomBytes;
    const crypto_1 = /* @__PURE__ */ requireCrypto();
    function isBytes(a2) {
      return a2 instanceof Uint8Array || ArrayBuffer.isView(a2) && a2.constructor.name === "Uint8Array";
    }
    function anumber(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error("positive integer expected, got " + n);
    }
    function abytes(b2, ...lengths) {
      if (!isBytes(b2))
        throw new Error("Uint8Array expected");
      if (lengths.length > 0 && !lengths.includes(b2.length))
        throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b2.length);
    }
    function ahash(h2) {
      if (typeof h2 !== "function" || typeof h2.create !== "function")
        throw new Error("Hash should be wrapped by utils.createHasher");
      anumber(h2.outputLen);
      anumber(h2.blockLen);
    }
    function aexists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    function aoutput(out, instance) {
      abytes(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error("digestInto() expects output buffer of length at least " + min);
      }
    }
    function u8(arr) {
      return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    function u32(arr) {
      return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    }
    function clean(...arrays) {
      for (let i = 0; i < arrays.length; i++) {
        arrays[i].fill(0);
      }
    }
    function createView(arr) {
      return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    function rotr(word, shift) {
      return word << 32 - shift | word >>> shift;
    }
    function rotl(word, shift) {
      return word << shift | word >>> 32 - shift >>> 0;
    }
    exports.isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
    function byteSwap(word) {
      return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
    }
    exports.swap8IfBE = exports.isLE ? (n) => n : (n) => byteSwap(n);
    exports.byteSwapIfBE = exports.swap8IfBE;
    function byteSwap32(arr) {
      for (let i = 0; i < arr.length; i++) {
        arr[i] = byteSwap(arr[i]);
      }
      return arr;
    }
    exports.swap32IfBE = exports.isLE ? (u) => u : byteSwap32;
    const hasHexBuiltin = /* @__PURE__ */ (() => (
      // @ts-ignore
      typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
    ))();
    const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      abytes(bytes);
      if (hasHexBuiltin)
        return bytes.toHex();
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    const asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    function asciiToBase16(ch) {
      if (ch >= asciis._0 && ch <= asciis._9)
        return ch - asciis._0;
      if (ch >= asciis.A && ch <= asciis.F)
        return ch - (asciis.A - 10);
      if (ch >= asciis.a && ch <= asciis.f)
        return ch - (asciis.a - 10);
      return;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      if (hasHexBuiltin)
        return Uint8Array.fromHex(hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("hex string expected, got unpadded hex of length " + hl);
      const array = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n2 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
      }
      return array;
    }
    const nextTick = async () => {
    };
    exports.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i = 0; i < iters; i++) {
        cb(i);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports.nextTick)();
        ts += diff;
      }
    }
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error("string expected");
      return new Uint8Array(new TextEncoder().encode(str));
    }
    function bytesToUtf8(bytes) {
      return new TextDecoder().decode(bytes);
    }
    function toBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      abytes(data);
      return data;
    }
    function kdfInputToBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      abytes(data);
      return data;
    }
    function concatBytes(...arrays) {
      let sum = 0;
      for (let i = 0; i < arrays.length; i++) {
        const a2 = arrays[i];
        abytes(a2);
        sum += a2.length;
      }
      const res = new Uint8Array(sum);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a2 = arrays[i];
        res.set(a2, pad);
        pad += a2.length;
      }
      return res;
    }
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && {}.toString.call(opts) !== "[object Object]")
        throw new Error("options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    class Hash {
    }
    exports.Hash = Hash;
    function createHasher(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    function createOptHasher(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    function createXOFer(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapConstructor = createHasher;
    exports.wrapConstructorWithOpts = createOptHasher;
    exports.wrapXOFConstructorWithOpts = createXOFer;
    function randomBytes(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === "function") {
        return Uint8Array.from(crypto_1.crypto.randomBytes(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
  })(utils);
  return utils;
}
var hasRequired_md;
function require_md() {
  if (hasRequired_md) return _md;
  hasRequired_md = 1;
  Object.defineProperty(_md, "__esModule", { value: true });
  _md.SHA512_IV = _md.SHA384_IV = _md.SHA224_IV = _md.SHA256_IV = _md.HashMD = void 0;
  _md.setBigUint64 = setBigUint64;
  _md.Chi = Chi;
  _md.Maj = Maj;
  const utils_ts_1 = /* @__PURE__ */ requireUtils();
  function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === "function")
      return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh = Number(value >> _32n & _u32_max);
    const wl = Number(value & _u32_max);
    const h2 = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h2, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
  }
  function Chi(a2, b2, c) {
    return a2 & b2 ^ ~a2 & c;
  }
  function Maj(a2, b2, c) {
    return a2 & b2 ^ a2 & c ^ b2 & c;
  }
  class HashMD extends utils_ts_1.Hash {
    constructor(blockLen, outputLen, padOffset, isLE) {
      super();
      this.finished = false;
      this.length = 0;
      this.pos = 0;
      this.destroyed = false;
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.padOffset = padOffset;
      this.isLE = isLE;
      this.buffer = new Uint8Array(blockLen);
      this.view = (0, utils_ts_1.createView)(this.buffer);
    }
    update(data) {
      (0, utils_ts_1.aexists)(this);
      data = (0, utils_ts_1.toBytes)(data);
      (0, utils_ts_1.abytes)(data);
      const { view, buffer: buffer2, blockLen } = this;
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        if (take === blockLen) {
          const dataView = (0, utils_ts_1.createView)(data);
          for (; blockLen <= len - pos; pos += blockLen)
            this.process(dataView, pos);
          continue;
        }
        buffer2.set(data.subarray(pos, pos + take), this.pos);
        this.pos += take;
        pos += take;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data.length;
      this.roundClean();
      return this;
    }
    digestInto(out) {
      (0, utils_ts_1.aexists)(this);
      (0, utils_ts_1.aoutput)(out, this);
      this.finished = true;
      const { buffer: buffer2, view, blockLen, isLE } = this;
      let { pos } = this;
      buffer2[pos++] = 128;
      (0, utils_ts_1.clean)(this.buffer.subarray(pos));
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (let i = pos; i < blockLen; i++)
        buffer2[i] = 0;
      setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
      this.process(view, 0);
      const oview = (0, utils_ts_1.createView)(out);
      const len = this.outputLen;
      if (len % 4)
        throw new Error("_sha2: outputLen should be aligned to 32bit");
      const outLen = len / 4;
      const state = this.get();
      if (outLen > state.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let i = 0; i < outLen; i++)
        oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
      const { buffer: buffer2, outputLen } = this;
      this.digestInto(buffer2);
      const res = buffer2.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to2) {
      to2 || (to2 = new this.constructor());
      to2.set(...this.get());
      const { blockLen, buffer: buffer2, length, finished, destroyed, pos } = this;
      to2.destroyed = destroyed;
      to2.finished = finished;
      to2.length = length;
      to2.pos = pos;
      if (length % blockLen)
        to2.buffer.set(buffer2);
      return to2;
    }
    clone() {
      return this._cloneInto();
    }
  }
  _md.HashMD = HashMD;
  _md.SHA256_IV = Uint32Array.from([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  _md.SHA224_IV = Uint32Array.from([
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ]);
  _md.SHA384_IV = Uint32Array.from([
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ]);
  _md.SHA512_IV = Uint32Array.from([
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ]);
  return _md;
}
var _u64 = {};
var hasRequired_u64;
function require_u64() {
  if (hasRequired_u64) return _u64;
  hasRequired_u64 = 1;
  Object.defineProperty(_u64, "__esModule", { value: true });
  _u64.toBig = _u64.shrSL = _u64.shrSH = _u64.rotrSL = _u64.rotrSH = _u64.rotrBL = _u64.rotrBH = _u64.rotr32L = _u64.rotr32H = _u64.rotlSL = _u64.rotlSH = _u64.rotlBL = _u64.rotlBH = _u64.add5L = _u64.add5H = _u64.add4L = _u64.add4H = _u64.add3L = _u64.add3H = void 0;
  _u64.add = add;
  _u64.fromBig = fromBig;
  _u64.split = split;
  const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
  const _32n = /* @__PURE__ */ BigInt(32);
  function fromBig(n, le2 = false) {
    if (le2)
      return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
    return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
  }
  function split(lst, le2 = false) {
    const len = lst.length;
    let Ah = new Uint32Array(len);
    let Al = new Uint32Array(len);
    for (let i = 0; i < len; i++) {
      const { h: h2, l } = fromBig(lst[i], le2);
      [Ah[i], Al[i]] = [h2, l];
    }
    return [Ah, Al];
  }
  const toBig = (h2, l) => BigInt(h2 >>> 0) << _32n | BigInt(l >>> 0);
  _u64.toBig = toBig;
  const shrSH = (h2, _l, s2) => h2 >>> s2;
  _u64.shrSH = shrSH;
  const shrSL = (h2, l, s2) => h2 << 32 - s2 | l >>> s2;
  _u64.shrSL = shrSL;
  const rotrSH = (h2, l, s2) => h2 >>> s2 | l << 32 - s2;
  _u64.rotrSH = rotrSH;
  const rotrSL = (h2, l, s2) => h2 << 32 - s2 | l >>> s2;
  _u64.rotrSL = rotrSL;
  const rotrBH = (h2, l, s2) => h2 << 64 - s2 | l >>> s2 - 32;
  _u64.rotrBH = rotrBH;
  const rotrBL = (h2, l, s2) => h2 >>> s2 - 32 | l << 64 - s2;
  _u64.rotrBL = rotrBL;
  const rotr32H = (_h, l) => l;
  _u64.rotr32H = rotr32H;
  const rotr32L = (h2, _l) => h2;
  _u64.rotr32L = rotr32L;
  const rotlSH = (h2, l, s2) => h2 << s2 | l >>> 32 - s2;
  _u64.rotlSH = rotlSH;
  const rotlSL = (h2, l, s2) => l << s2 | h2 >>> 32 - s2;
  _u64.rotlSL = rotlSL;
  const rotlBH = (h2, l, s2) => l << s2 - 32 | h2 >>> 64 - s2;
  _u64.rotlBH = rotlBH;
  const rotlBL = (h2, l, s2) => h2 << s2 - 32 | l >>> 64 - s2;
  _u64.rotlBL = rotlBL;
  function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
  }
  const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
  _u64.add3L = add3L;
  const add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
  _u64.add3H = add3H;
  const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
  _u64.add4L = add4L;
  const add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
  _u64.add4H = add4H;
  const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
  _u64.add5L = add5L;
  const add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
  _u64.add5H = add5H;
  const u64 = {
    fromBig,
    split,
    toBig,
    shrSH,
    shrSL,
    rotrSH,
    rotrSL,
    rotrBH,
    rotrBL,
    rotr32H,
    rotr32L,
    rotlSH,
    rotlSL,
    rotlBH,
    rotlBL,
    add,
    add3L,
    add3H,
    add4L,
    add4H,
    add5H,
    add5L
  };
  _u64.default = u64;
  return _u64;
}
var hasRequiredSha2;
function requireSha2() {
  if (hasRequiredSha2) return sha2;
  hasRequiredSha2 = 1;
  Object.defineProperty(sha2, "__esModule", { value: true });
  sha2.sha512_224 = sha2.sha512_256 = sha2.sha384 = sha2.sha512 = sha2.sha224 = sha2.sha256 = sha2.SHA512_256 = sha2.SHA512_224 = sha2.SHA384 = sha2.SHA512 = sha2.SHA224 = sha2.SHA256 = void 0;
  const _md_ts_1 = /* @__PURE__ */ require_md();
  const u64 = /* @__PURE__ */ require_u64();
  const utils_ts_1 = /* @__PURE__ */ requireUtils();
  const SHA256_K = /* @__PURE__ */ Uint32Array.from([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
  class SHA256 extends _md_ts_1.HashMD {
    constructor(outputLen = 32) {
      super(64, outputLen, 8, false);
      this.A = _md_ts_1.SHA256_IV[0] | 0;
      this.B = _md_ts_1.SHA256_IV[1] | 0;
      this.C = _md_ts_1.SHA256_IV[2] | 0;
      this.D = _md_ts_1.SHA256_IV[3] | 0;
      this.E = _md_ts_1.SHA256_IV[4] | 0;
      this.F = _md_ts_1.SHA256_IV[5] | 0;
      this.G = _md_ts_1.SHA256_IV[6] | 0;
      this.H = _md_ts_1.SHA256_IV[7] | 0;
    }
    get() {
      const { A: A2, B: B2, C: C2, D: D2, E: E2, F: F2, G: G2, H: H2 } = this;
      return [A2, B2, C2, D2, E2, F2, G2, H2];
    }
    // prettier-ignore
    set(A2, B2, C2, D2, E2, F2, G2, H2) {
      this.A = A2 | 0;
      this.B = B2 | 0;
      this.C = C2 | 0;
      this.D = D2 | 0;
      this.E = E2 | 0;
      this.F = F2 | 0;
      this.G = G2 | 0;
      this.H = H2 | 0;
    }
    process(view, offset) {
      for (let i = 0; i < 16; i++, offset += 4)
        SHA256_W[i] = view.getUint32(offset, false);
      for (let i = 16; i < 64; i++) {
        const W15 = SHA256_W[i - 15];
        const W2 = SHA256_W[i - 2];
        const s0 = (0, utils_ts_1.rotr)(W15, 7) ^ (0, utils_ts_1.rotr)(W15, 18) ^ W15 >>> 3;
        const s1 = (0, utils_ts_1.rotr)(W2, 17) ^ (0, utils_ts_1.rotr)(W2, 19) ^ W2 >>> 10;
        SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
      }
      let { A: A2, B: B2, C: C2, D: D2, E: E2, F: F2, G: G2, H: H2 } = this;
      for (let i = 0; i < 64; i++) {
        const sigma1 = (0, utils_ts_1.rotr)(E2, 6) ^ (0, utils_ts_1.rotr)(E2, 11) ^ (0, utils_ts_1.rotr)(E2, 25);
        const T12 = H2 + sigma1 + (0, _md_ts_1.Chi)(E2, F2, G2) + SHA256_K[i] + SHA256_W[i] | 0;
        const sigma0 = (0, utils_ts_1.rotr)(A2, 2) ^ (0, utils_ts_1.rotr)(A2, 13) ^ (0, utils_ts_1.rotr)(A2, 22);
        const T22 = sigma0 + (0, _md_ts_1.Maj)(A2, B2, C2) | 0;
        H2 = G2;
        G2 = F2;
        F2 = E2;
        E2 = D2 + T12 | 0;
        D2 = C2;
        C2 = B2;
        B2 = A2;
        A2 = T12 + T22 | 0;
      }
      A2 = A2 + this.A | 0;
      B2 = B2 + this.B | 0;
      C2 = C2 + this.C | 0;
      D2 = D2 + this.D | 0;
      E2 = E2 + this.E | 0;
      F2 = F2 + this.F | 0;
      G2 = G2 + this.G | 0;
      H2 = H2 + this.H | 0;
      this.set(A2, B2, C2, D2, E2, F2, G2, H2);
    }
    roundClean() {
      (0, utils_ts_1.clean)(SHA256_W);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
      (0, utils_ts_1.clean)(this.buffer);
    }
  }
  sha2.SHA256 = SHA256;
  class SHA224 extends SHA256 {
    constructor() {
      super(28);
      this.A = _md_ts_1.SHA224_IV[0] | 0;
      this.B = _md_ts_1.SHA224_IV[1] | 0;
      this.C = _md_ts_1.SHA224_IV[2] | 0;
      this.D = _md_ts_1.SHA224_IV[3] | 0;
      this.E = _md_ts_1.SHA224_IV[4] | 0;
      this.F = _md_ts_1.SHA224_IV[5] | 0;
      this.G = _md_ts_1.SHA224_IV[6] | 0;
      this.H = _md_ts_1.SHA224_IV[7] | 0;
    }
  }
  sha2.SHA224 = SHA224;
  const K512 = /* @__PURE__ */ (() => u64.split([
    "0x428a2f98d728ae22",
    "0x7137449123ef65cd",
    "0xb5c0fbcfec4d3b2f",
    "0xe9b5dba58189dbbc",
    "0x3956c25bf348b538",
    "0x59f111f1b605d019",
    "0x923f82a4af194f9b",
    "0xab1c5ed5da6d8118",
    "0xd807aa98a3030242",
    "0x12835b0145706fbe",
    "0x243185be4ee4b28c",
    "0x550c7dc3d5ffb4e2",
    "0x72be5d74f27b896f",
    "0x80deb1fe3b1696b1",
    "0x9bdc06a725c71235",
    "0xc19bf174cf692694",
    "0xe49b69c19ef14ad2",
    "0xefbe4786384f25e3",
    "0x0fc19dc68b8cd5b5",
    "0x240ca1cc77ac9c65",
    "0x2de92c6f592b0275",
    "0x4a7484aa6ea6e483",
    "0x5cb0a9dcbd41fbd4",
    "0x76f988da831153b5",
    "0x983e5152ee66dfab",
    "0xa831c66d2db43210",
    "0xb00327c898fb213f",
    "0xbf597fc7beef0ee4",
    "0xc6e00bf33da88fc2",
    "0xd5a79147930aa725",
    "0x06ca6351e003826f",
    "0x142929670a0e6e70",
    "0x27b70a8546d22ffc",
    "0x2e1b21385c26c926",
    "0x4d2c6dfc5ac42aed",
    "0x53380d139d95b3df",
    "0x650a73548baf63de",
    "0x766a0abb3c77b2a8",
    "0x81c2c92e47edaee6",
    "0x92722c851482353b",
    "0xa2bfe8a14cf10364",
    "0xa81a664bbc423001",
    "0xc24b8b70d0f89791",
    "0xc76c51a30654be30",
    "0xd192e819d6ef5218",
    "0xd69906245565a910",
    "0xf40e35855771202a",
    "0x106aa07032bbd1b8",
    "0x19a4c116b8d2d0c8",
    "0x1e376c085141ab53",
    "0x2748774cdf8eeb99",
    "0x34b0bcb5e19b48a8",
    "0x391c0cb3c5c95a63",
    "0x4ed8aa4ae3418acb",
    "0x5b9cca4f7763e373",
    "0x682e6ff3d6b2b8a3",
    "0x748f82ee5defb2fc",
    "0x78a5636f43172f60",
    "0x84c87814a1f0ab72",
    "0x8cc702081a6439ec",
    "0x90befffa23631e28",
    "0xa4506cebde82bde9",
    "0xbef9a3f7b2c67915",
    "0xc67178f2e372532b",
    "0xca273eceea26619c",
    "0xd186b8c721c0c207",
    "0xeada7dd6cde0eb1e",
    "0xf57d4f7fee6ed178",
    "0x06f067aa72176fba",
    "0x0a637dc5a2c898a6",
    "0x113f9804bef90dae",
    "0x1b710b35131c471b",
    "0x28db77f523047d84",
    "0x32caab7b40c72493",
    "0x3c9ebe0a15c9bebc",
    "0x431d67c49c100d4c",
    "0x4cc5d4becb3e42b6",
    "0x597f299cfc657e2a",
    "0x5fcb6fab3ad6faec",
    "0x6c44198c4a475817"
  ].map((n) => BigInt(n))))();
  const SHA512_Kh = /* @__PURE__ */ (() => K512[0])();
  const SHA512_Kl = /* @__PURE__ */ (() => K512[1])();
  const SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
  const SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
  class SHA512 extends _md_ts_1.HashMD {
    constructor(outputLen = 64) {
      super(128, outputLen, 16, false);
      this.Ah = _md_ts_1.SHA512_IV[0] | 0;
      this.Al = _md_ts_1.SHA512_IV[1] | 0;
      this.Bh = _md_ts_1.SHA512_IV[2] | 0;
      this.Bl = _md_ts_1.SHA512_IV[3] | 0;
      this.Ch = _md_ts_1.SHA512_IV[4] | 0;
      this.Cl = _md_ts_1.SHA512_IV[5] | 0;
      this.Dh = _md_ts_1.SHA512_IV[6] | 0;
      this.Dl = _md_ts_1.SHA512_IV[7] | 0;
      this.Eh = _md_ts_1.SHA512_IV[8] | 0;
      this.El = _md_ts_1.SHA512_IV[9] | 0;
      this.Fh = _md_ts_1.SHA512_IV[10] | 0;
      this.Fl = _md_ts_1.SHA512_IV[11] | 0;
      this.Gh = _md_ts_1.SHA512_IV[12] | 0;
      this.Gl = _md_ts_1.SHA512_IV[13] | 0;
      this.Hh = _md_ts_1.SHA512_IV[14] | 0;
      this.Hl = _md_ts_1.SHA512_IV[15] | 0;
    }
    // prettier-ignore
    get() {
      const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
      return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
    }
    // prettier-ignore
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
      this.Ah = Ah | 0;
      this.Al = Al | 0;
      this.Bh = Bh | 0;
      this.Bl = Bl | 0;
      this.Ch = Ch | 0;
      this.Cl = Cl | 0;
      this.Dh = Dh | 0;
      this.Dl = Dl | 0;
      this.Eh = Eh | 0;
      this.El = El | 0;
      this.Fh = Fh | 0;
      this.Fl = Fl | 0;
      this.Gh = Gh | 0;
      this.Gl = Gl | 0;
      this.Hh = Hh | 0;
      this.Hl = Hl | 0;
    }
    process(view, offset) {
      for (let i = 0; i < 16; i++, offset += 4) {
        SHA512_W_H[i] = view.getUint32(offset);
        SHA512_W_L[i] = view.getUint32(offset += 4);
      }
      for (let i = 16; i < 80; i++) {
        const W15h = SHA512_W_H[i - 15] | 0;
        const W15l = SHA512_W_L[i - 15] | 0;
        const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);
        const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);
        const W2h = SHA512_W_H[i - 2] | 0;
        const W2l = SHA512_W_L[i - 2] | 0;
        const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);
        const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);
        const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
        const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
        SHA512_W_H[i] = SUMh | 0;
        SHA512_W_L[i] = SUMl | 0;
      }
      let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
      for (let i = 0; i < 80; i++) {
        const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);
        const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);
        const CHIh = Eh & Fh ^ ~Eh & Gh;
        const CHIl = El & Fl ^ ~El & Gl;
        const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
        const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
        const T1l = T1ll | 0;
        const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);
        const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);
        const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
        const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
        Hh = Gh | 0;
        Hl = Gl | 0;
        Gh = Fh | 0;
        Gl = Fl | 0;
        Fh = Eh | 0;
        Fl = El | 0;
        ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
        Dh = Ch | 0;
        Dl = Cl | 0;
        Ch = Bh | 0;
        Cl = Bl | 0;
        Bh = Ah | 0;
        Bl = Al | 0;
        const All = u64.add3L(T1l, sigma0l, MAJl);
        Ah = u64.add3H(All, T1h, sigma0h, MAJh);
        Al = All | 0;
      }
      ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
      ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
      ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
      ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
      ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
      ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
      ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
      ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
      this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
      (0, utils_ts_1.clean)(SHA512_W_H, SHA512_W_L);
    }
    destroy() {
      (0, utils_ts_1.clean)(this.buffer);
      this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  }
  sha2.SHA512 = SHA512;
  class SHA384 extends SHA512 {
    constructor() {
      super(48);
      this.Ah = _md_ts_1.SHA384_IV[0] | 0;
      this.Al = _md_ts_1.SHA384_IV[1] | 0;
      this.Bh = _md_ts_1.SHA384_IV[2] | 0;
      this.Bl = _md_ts_1.SHA384_IV[3] | 0;
      this.Ch = _md_ts_1.SHA384_IV[4] | 0;
      this.Cl = _md_ts_1.SHA384_IV[5] | 0;
      this.Dh = _md_ts_1.SHA384_IV[6] | 0;
      this.Dl = _md_ts_1.SHA384_IV[7] | 0;
      this.Eh = _md_ts_1.SHA384_IV[8] | 0;
      this.El = _md_ts_1.SHA384_IV[9] | 0;
      this.Fh = _md_ts_1.SHA384_IV[10] | 0;
      this.Fl = _md_ts_1.SHA384_IV[11] | 0;
      this.Gh = _md_ts_1.SHA384_IV[12] | 0;
      this.Gl = _md_ts_1.SHA384_IV[13] | 0;
      this.Hh = _md_ts_1.SHA384_IV[14] | 0;
      this.Hl = _md_ts_1.SHA384_IV[15] | 0;
    }
  }
  sha2.SHA384 = SHA384;
  const T224_IV = /* @__PURE__ */ Uint32Array.from([
    2352822216,
    424955298,
    1944164710,
    2312950998,
    502970286,
    855612546,
    1738396948,
    1479516111,
    258812777,
    2077511080,
    2011393907,
    79989058,
    1067287976,
    1780299464,
    286451373,
    2446758561
  ]);
  const T256_IV = /* @__PURE__ */ Uint32Array.from([
    573645204,
    4230739756,
    2673172387,
    3360449730,
    596883563,
    1867755857,
    2520282905,
    1497426621,
    2519219938,
    2827943907,
    3193839141,
    1401305490,
    721525244,
    746961066,
    246885852,
    2177182882
  ]);
  class SHA512_224 extends SHA512 {
    constructor() {
      super(28);
      this.Ah = T224_IV[0] | 0;
      this.Al = T224_IV[1] | 0;
      this.Bh = T224_IV[2] | 0;
      this.Bl = T224_IV[3] | 0;
      this.Ch = T224_IV[4] | 0;
      this.Cl = T224_IV[5] | 0;
      this.Dh = T224_IV[6] | 0;
      this.Dl = T224_IV[7] | 0;
      this.Eh = T224_IV[8] | 0;
      this.El = T224_IV[9] | 0;
      this.Fh = T224_IV[10] | 0;
      this.Fl = T224_IV[11] | 0;
      this.Gh = T224_IV[12] | 0;
      this.Gl = T224_IV[13] | 0;
      this.Hh = T224_IV[14] | 0;
      this.Hl = T224_IV[15] | 0;
    }
  }
  sha2.SHA512_224 = SHA512_224;
  class SHA512_256 extends SHA512 {
    constructor() {
      super(32);
      this.Ah = T256_IV[0] | 0;
      this.Al = T256_IV[1] | 0;
      this.Bh = T256_IV[2] | 0;
      this.Bl = T256_IV[3] | 0;
      this.Ch = T256_IV[4] | 0;
      this.Cl = T256_IV[5] | 0;
      this.Dh = T256_IV[6] | 0;
      this.Dl = T256_IV[7] | 0;
      this.Eh = T256_IV[8] | 0;
      this.El = T256_IV[9] | 0;
      this.Fh = T256_IV[10] | 0;
      this.Fl = T256_IV[11] | 0;
      this.Gh = T256_IV[12] | 0;
      this.Gl = T256_IV[13] | 0;
      this.Hh = T256_IV[14] | 0;
      this.Hl = T256_IV[15] | 0;
    }
  }
  sha2.SHA512_256 = SHA512_256;
  sha2.sha256 = (0, utils_ts_1.createHasher)(() => new SHA256());
  sha2.sha224 = (0, utils_ts_1.createHasher)(() => new SHA224());
  sha2.sha512 = (0, utils_ts_1.createHasher)(() => new SHA512());
  sha2.sha384 = (0, utils_ts_1.createHasher)(() => new SHA384());
  sha2.sha512_256 = (0, utils_ts_1.createHasher)(() => new SHA512_256());
  sha2.sha512_224 = (0, utils_ts_1.createHasher)(() => new SHA512_224());
  return sha2;
}
var hasRequiredSha256;
function requireSha256() {
  if (hasRequiredSha256) return sha256;
  hasRequiredSha256 = 1;
  Object.defineProperty(sha256, "__esModule", { value: true });
  sha256.sha224 = sha256.SHA224 = sha256.sha256 = sha256.SHA256 = void 0;
  const sha2_ts_1 = /* @__PURE__ */ requireSha2();
  sha256.SHA256 = sha2_ts_1.SHA256;
  sha256.sha256 = sha2_ts_1.sha256;
  sha256.SHA224 = sha2_ts_1.SHA224;
  sha256.sha224 = sha2_ts_1.sha224;
  return sha256;
}
var sha512 = {};
var hasRequiredSha512;
function requireSha512() {
  if (hasRequiredSha512) return sha512;
  hasRequiredSha512 = 1;
  Object.defineProperty(sha512, "__esModule", { value: true });
  sha512.sha512_256 = sha512.SHA512_256 = sha512.sha512_224 = sha512.SHA512_224 = sha512.sha384 = sha512.SHA384 = sha512.sha512 = sha512.SHA512 = void 0;
  const sha2_ts_1 = /* @__PURE__ */ requireSha2();
  sha512.SHA512 = sha2_ts_1.SHA512;
  sha512.sha512 = sha2_ts_1.sha512;
  sha512.SHA384 = sha2_ts_1.SHA384;
  sha512.sha384 = sha2_ts_1.sha384;
  sha512.SHA512_224 = sha2_ts_1.SHA512_224;
  sha512.sha512_224 = sha2_ts_1.sha512_224;
  sha512.SHA512_256 = sha2_ts_1.SHA512_256;
  sha512.sha512_256 = sha2_ts_1.sha512_256;
  return sha512;
}
var pbkdf2 = {};
var hmac = {};
var hasRequiredHmac;
function requireHmac() {
  if (hasRequiredHmac) return hmac;
  hasRequiredHmac = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hmac = exports.HMAC = void 0;
    const utils_ts_1 = /* @__PURE__ */ requireUtils();
    class HMAC extends utils_ts_1.Hash {
      constructor(hash, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        (0, utils_ts_1.ahash)(hash);
        const key2 = (0, utils_ts_1.toBytes)(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== "function")
          throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        pad.set(key2.length > blockLen ? hash.create().update(key2).digest() : key2);
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54;
        this.iHash.update(pad);
        this.oHash = hash.create();
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54 ^ 92;
        this.oHash.update(pad);
        (0, utils_ts_1.clean)(pad);
      }
      update(buf2) {
        (0, utils_ts_1.aexists)(this);
        this.iHash.update(buf2);
        return this;
      }
      digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.abytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to2) {
        to2 || (to2 = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to2 = to2;
        to2.finished = finished;
        to2.destroyed = destroyed;
        to2.blockLen = blockLen;
        to2.outputLen = outputLen;
        to2.oHash = oHash._cloneInto(to2.oHash);
        to2.iHash = iHash._cloneInto(to2.iHash);
        return to2;
      }
      clone() {
        return this._cloneInto();
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    }
    exports.HMAC = HMAC;
    const hmac2 = (hash, key2, message) => new HMAC(hash, key2).update(message).digest();
    exports.hmac = hmac2;
    exports.hmac.create = (hash, key2) => new HMAC(hash, key2);
  })(hmac);
  return hmac;
}
var hasRequiredPbkdf2;
function requirePbkdf2() {
  if (hasRequiredPbkdf2) return pbkdf2;
  hasRequiredPbkdf2 = 1;
  Object.defineProperty(pbkdf2, "__esModule", { value: true });
  pbkdf2.pbkdf2 = pbkdf2$12;
  pbkdf2.pbkdf2Async = pbkdf2Async;
  const hmac_ts_1 = /* @__PURE__ */ requireHmac();
  const utils_ts_1 = /* @__PURE__ */ requireUtils();
  function pbkdf2Init(hash, _password, _salt, _opts) {
    (0, utils_ts_1.ahash)(hash);
    const opts = (0, utils_ts_1.checkOpts)({ dkLen: 32, asyncTick: 10 }, _opts);
    const { c, dkLen, asyncTick } = opts;
    (0, utils_ts_1.anumber)(c);
    (0, utils_ts_1.anumber)(dkLen);
    (0, utils_ts_1.anumber)(asyncTick);
    if (c < 1)
      throw new Error("iterations (c) should be >= 1");
    const password = (0, utils_ts_1.kdfInputToBytes)(_password);
    const salt = (0, utils_ts_1.kdfInputToBytes)(_salt);
    const DK = new Uint8Array(dkLen);
    const PRF = hmac_ts_1.hmac.create(hash, password);
    const PRFSalt = PRF._cloneInto().update(salt);
    return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
  }
  function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
    PRF.destroy();
    PRFSalt.destroy();
    if (prfW)
      prfW.destroy();
    (0, utils_ts_1.clean)(u);
    return DK;
  }
  function pbkdf2$12(hash, password, salt, opts) {
    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
    let prfW;
    const arr = new Uint8Array(4);
    const view = (0, utils_ts_1.createView)(arr);
    const u = new Uint8Array(PRF.outputLen);
    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
      const Ti = DK.subarray(pos, pos + PRF.outputLen);
      view.setInt32(0, ti, false);
      (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
      Ti.set(u.subarray(0, Ti.length));
      for (let ui = 1; ui < c; ui++) {
        PRF._cloneInto(prfW).update(u).digestInto(u);
        for (let i = 0; i < Ti.length; i++)
          Ti[i] ^= u[i];
      }
    }
    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
  }
  async function pbkdf2Async(hash, password, salt, opts) {
    const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
    let prfW;
    const arr = new Uint8Array(4);
    const view = (0, utils_ts_1.createView)(arr);
    const u = new Uint8Array(PRF.outputLen);
    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
      const Ti = DK.subarray(pos, pos + PRF.outputLen);
      view.setInt32(0, ti, false);
      (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
      Ti.set(u.subarray(0, Ti.length));
      await (0, utils_ts_1.asyncLoop)(c - 1, asyncTick, () => {
        PRF._cloneInto(prfW).update(u).digestInto(u);
        for (let i = 0; i < Ti.length; i++)
          Ti[i] ^= u[i];
      });
    }
    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
  }
  return pbkdf2;
}
var _wordlists = {};
const require$$0 = /* @__PURE__ */ JSON.parse('["abdikace","abeceda","adresa","agrese","akce","aktovka","alej","alkohol","amputace","ananas","andulka","anekdota","anketa","antika","anulovat","archa","arogance","asfalt","asistent","aspirace","astma","astronom","atlas","atletika","atol","autobus","azyl","babka","bachor","bacil","baculka","badatel","bageta","bagr","bahno","bakterie","balada","baletka","balkon","balonek","balvan","balza","bambus","bankomat","barbar","baret","barman","baroko","barva","baterka","batoh","bavlna","bazalka","bazilika","bazuka","bedna","beran","beseda","bestie","beton","bezinka","bezmoc","beztak","bicykl","bidlo","biftek","bikiny","bilance","biograf","biolog","bitva","bizon","blahobyt","blatouch","blecha","bledule","blesk","blikat","blizna","blokovat","bloudit","blud","bobek","bobr","bodlina","bodnout","bohatost","bojkot","bojovat","bokorys","bolest","borec","borovice","bota","boubel","bouchat","bouda","boule","bourat","boxer","bradavka","brambora","branka","bratr","brepta","briketa","brko","brloh","bronz","broskev","brunetka","brusinka","brzda","brzy","bublina","bubnovat","buchta","buditel","budka","budova","bufet","bujarost","bukvice","buldok","bulva","bunda","bunkr","burza","butik","buvol","buzola","bydlet","bylina","bytovka","bzukot","capart","carevna","cedr","cedule","cejch","cejn","cela","celer","celkem","celnice","cenina","cennost","cenovka","centrum","cenzor","cestopis","cetka","chalupa","chapadlo","charita","chata","chechtat","chemie","chichot","chirurg","chlad","chleba","chlubit","chmel","chmura","chobot","chochol","chodba","cholera","chomout","chopit","choroba","chov","chrapot","chrlit","chrt","chrup","chtivost","chudina","chutnat","chvat","chvilka","chvost","chyba","chystat","chytit","cibule","cigareta","cihelna","cihla","cinkot","cirkus","cisterna","citace","citrus","cizinec","cizost","clona","cokoliv","couvat","ctitel","ctnost","cudnost","cuketa","cukr","cupot","cvaknout","cval","cvik","cvrkot","cyklista","daleko","dareba","datel","datum","dcera","debata","dechovka","decibel","deficit","deflace","dekl","dekret","demokrat","deprese","derby","deska","detektiv","dikobraz","diktovat","dioda","diplom","disk","displej","divadlo","divoch","dlaha","dlouho","dluhopis","dnes","dobro","dobytek","docent","dochutit","dodnes","dohled","dohoda","dohra","dojem","dojnice","doklad","dokola","doktor","dokument","dolar","doleva","dolina","doma","dominant","domluvit","domov","donutit","dopad","dopis","doplnit","doposud","doprovod","dopustit","dorazit","dorost","dort","dosah","doslov","dostatek","dosud","dosyta","dotaz","dotek","dotknout","doufat","doutnat","dovozce","dozadu","doznat","dozorce","drahota","drak","dramatik","dravec","draze","drdol","drobnost","drogerie","drozd","drsnost","drtit","drzost","duben","duchovno","dudek","duha","duhovka","dusit","dusno","dutost","dvojice","dvorec","dynamit","ekolog","ekonomie","elektron","elipsa","email","emise","emoce","empatie","epizoda","epocha","epopej","epos","esej","esence","eskorta","eskymo","etiketa","euforie","evoluce","exekuce","exkurze","expedice","exploze","export","extrakt","facka","fajfka","fakulta","fanatik","fantazie","farmacie","favorit","fazole","federace","fejeton","fenka","fialka","figurant","filozof","filtr","finance","finta","fixace","fjord","flanel","flirt","flotila","fond","fosfor","fotbal","fotka","foton","frakce","freska","fronta","fukar","funkce","fyzika","galeje","garant","genetika","geolog","gilotina","glazura","glejt","golem","golfista","gotika","graf","gramofon","granule","grep","gril","grog","groteska","guma","hadice","hadr","hala","halenka","hanba","hanopis","harfa","harpuna","havran","hebkost","hejkal","hejno","hejtman","hektar","helma","hematom","herec","herna","heslo","hezky","historik","hladovka","hlasivky","hlava","hledat","hlen","hlodavec","hloh","hloupost","hltat","hlubina","hluchota","hmat","hmota","hmyz","hnis","hnojivo","hnout","hoblina","hoboj","hoch","hodiny","hodlat","hodnota","hodovat","hojnost","hokej","holinka","holka","holub","homole","honitba","honorace","horal","horda","horizont","horko","horlivec","hormon","hornina","horoskop","horstvo","hospoda","hostina","hotovost","houba","houf","houpat","houska","hovor","hradba","hranice","hravost","hrazda","hrbolek","hrdina","hrdlo","hrdost","hrnek","hrobka","hromada","hrot","hrouda","hrozen","hrstka","hrubost","hryzat","hubenost","hubnout","hudba","hukot","humr","husita","hustota","hvozd","hybnost","hydrant","hygiena","hymna","hysterik","idylka","ihned","ikona","iluze","imunita","infekce","inflace","inkaso","inovace","inspekce","internet","invalida","investor","inzerce","ironie","jablko","jachta","jahoda","jakmile","jakost","jalovec","jantar","jarmark","jaro","jasan","jasno","jatka","javor","jazyk","jedinec","jedle","jednatel","jehlan","jekot","jelen","jelito","jemnost","jenom","jepice","jeseter","jevit","jezdec","jezero","jinak","jindy","jinoch","jiskra","jistota","jitrnice","jizva","jmenovat","jogurt","jurta","kabaret","kabel","kabinet","kachna","kadet","kadidlo","kahan","kajak","kajuta","kakao","kaktus","kalamita","kalhoty","kalibr","kalnost","kamera","kamkoliv","kamna","kanibal","kanoe","kantor","kapalina","kapela","kapitola","kapka","kaple","kapota","kapr","kapusta","kapybara","karamel","karotka","karton","kasa","katalog","katedra","kauce","kauza","kavalec","kazajka","kazeta","kazivost","kdekoliv","kdesi","kedluben","kemp","keramika","kino","klacek","kladivo","klam","klapot","klasika","klaun","klec","klenba","klepat","klesnout","klid","klima","klisna","klobouk","klokan","klopa","kloub","klubovna","klusat","kluzkost","kmen","kmitat","kmotr","kniha","knot","koalice","koberec","kobka","kobliha","kobyla","kocour","kohout","kojenec","kokos","koktejl","kolaps","koleda","kolize","kolo","komando","kometa","komik","komnata","komora","kompas","komunita","konat","koncept","kondice","konec","konfese","kongres","konina","konkurs","kontakt","konzerva","kopanec","kopie","kopnout","koprovka","korbel","korektor","kormidlo","koroptev","korpus","koruna","koryto","korzet","kosatec","kostka","kotel","kotleta","kotoul","koukat","koupelna","kousek","kouzlo","kovboj","koza","kozoroh","krabice","krach","krajina","kralovat","krasopis","kravata","kredit","krejcar","kresba","kreveta","kriket","kritik","krize","krkavec","krmelec","krmivo","krocan","krok","kronika","kropit","kroupa","krovka","krtek","kruhadlo","krupice","krutost","krvinka","krychle","krypta","krystal","kryt","kudlanka","kufr","kujnost","kukla","kulajda","kulich","kulka","kulomet","kultura","kuna","kupodivu","kurt","kurzor","kutil","kvalita","kvasinka","kvestor","kynolog","kyselina","kytara","kytice","kytka","kytovec","kyvadlo","labrador","lachtan","ladnost","laik","lakomec","lamela","lampa","lanovka","lasice","laso","lastura","latinka","lavina","lebka","leckdy","leden","lednice","ledovka","ledvina","legenda","legie","legrace","lehce","lehkost","lehnout","lektvar","lenochod","lentilka","lepenka","lepidlo","letadlo","letec","letmo","letokruh","levhart","levitace","levobok","libra","lichotka","lidojed","lidskost","lihovina","lijavec","lilek","limetka","linie","linka","linoleum","listopad","litina","litovat","lobista","lodivod","logika","logoped","lokalita","loket","lomcovat","lopata","lopuch","lord","losos","lotr","loudal","louh","louka","louskat","lovec","lstivost","lucerna","lucifer","lump","lusk","lustrace","lvice","lyra","lyrika","lysina","madam","madlo","magistr","mahagon","majetek","majitel","majorita","makak","makovice","makrela","malba","malina","malovat","malvice","maminka","mandle","manko","marnost","masakr","maskot","masopust","matice","matrika","maturita","mazanec","mazivo","mazlit","mazurka","mdloba","mechanik","meditace","medovina","melasa","meloun","mentolka","metla","metoda","metr","mezera","migrace","mihnout","mihule","mikina","mikrofon","milenec","milimetr","milost","mimika","mincovna","minibar","minomet","minulost","miska","mistr","mixovat","mladost","mlha","mlhovina","mlok","mlsat","mluvit","mnich","mnohem","mobil","mocnost","modelka","modlitba","mohyla","mokro","molekula","momentka","monarcha","monokl","monstrum","montovat","monzun","mosaz","moskyt","most","motivace","motorka","motyka","moucha","moudrost","mozaika","mozek","mozol","mramor","mravenec","mrkev","mrtvola","mrzet","mrzutost","mstitel","mudrc","muflon","mulat","mumie","munice","muset","mutace","muzeum","muzikant","myslivec","mzda","nabourat","nachytat","nadace","nadbytek","nadhoz","nadobro","nadpis","nahlas","nahnat","nahodile","nahradit","naivita","najednou","najisto","najmout","naklonit","nakonec","nakrmit","nalevo","namazat","namluvit","nanometr","naoko","naopak","naostro","napadat","napevno","naplnit","napnout","naposled","naprosto","narodit","naruby","narychlo","nasadit","nasekat","naslepo","nastat","natolik","navenek","navrch","navzdory","nazvat","nebe","nechat","necky","nedaleko","nedbat","neduh","negace","nehet","nehoda","nejen","nejprve","neklid","nelibost","nemilost","nemoc","neochota","neonka","nepokoj","nerost","nerv","nesmysl","nesoulad","netvor","neuron","nevina","nezvykle","nicota","nijak","nikam","nikdy","nikl","nikterak","nitro","nocleh","nohavice","nominace","nora","norek","nositel","nosnost","nouze","noviny","novota","nozdra","nuda","nudle","nuget","nutit","nutnost","nutrie","nymfa","obal","obarvit","obava","obdiv","obec","obehnat","obejmout","obezita","obhajoba","obilnice","objasnit","objekt","obklopit","oblast","oblek","obliba","obloha","obluda","obnos","obohatit","obojek","obout","obrazec","obrna","obruba","obrys","obsah","obsluha","obstarat","obuv","obvaz","obvinit","obvod","obvykle","obyvatel","obzor","ocas","ocel","ocenit","ochladit","ochota","ochrana","ocitnout","odboj","odbyt","odchod","odcizit","odebrat","odeslat","odevzdat","odezva","odhadce","odhodit","odjet","odjinud","odkaz","odkoupit","odliv","odluka","odmlka","odolnost","odpad","odpis","odplout","odpor","odpustit","odpykat","odrazka","odsoudit","odstup","odsun","odtok","odtud","odvaha","odveta","odvolat","odvracet","odznak","ofina","ofsajd","ohlas","ohnisko","ohrada","ohrozit","ohryzek","okap","okenice","oklika","okno","okouzlit","okovy","okrasa","okres","okrsek","okruh","okupant","okurka","okusit","olejnina","olizovat","omak","omeleta","omezit","omladina","omlouvat","omluva","omyl","onehdy","opakovat","opasek","operace","opice","opilost","opisovat","opora","opozice","opravdu","oproti","orbital","orchestr","orgie","orlice","orloj","ortel","osada","oschnout","osika","osivo","oslava","oslepit","oslnit","oslovit","osnova","osoba","osolit","ospalec","osten","ostraha","ostuda","ostych","osvojit","oteplit","otisk","otop","otrhat","otrlost","otrok","otruby","otvor","ovanout","ovar","oves","ovlivnit","ovoce","oxid","ozdoba","pachatel","pacient","padouch","pahorek","pakt","palanda","palec","palivo","paluba","pamflet","pamlsek","panenka","panika","panna","panovat","panstvo","pantofle","paprika","parketa","parodie","parta","paruka","paryba","paseka","pasivita","pastelka","patent","patrona","pavouk","pazneht","pazourek","pecka","pedagog","pejsek","peklo","peloton","penalta","pendrek","penze","periskop","pero","pestrost","petarda","petice","petrolej","pevnina","pexeso","pianista","piha","pijavice","pikle","piknik","pilina","pilnost","pilulka","pinzeta","pipeta","pisatel","pistole","pitevna","pivnice","pivovar","placenta","plakat","plamen","planeta","plastika","platit","plavidlo","plaz","plech","plemeno","plenta","ples","pletivo","plevel","plivat","plnit","plno","plocha","plodina","plomba","plout","pluk","plyn","pobavit","pobyt","pochod","pocit","poctivec","podat","podcenit","podepsat","podhled","podivit","podklad","podmanit","podnik","podoba","podpora","podraz","podstata","podvod","podzim","poezie","pohanka","pohnutka","pohovor","pohroma","pohyb","pointa","pojistka","pojmout","pokazit","pokles","pokoj","pokrok","pokuta","pokyn","poledne","polibek","polknout","poloha","polynom","pomalu","pominout","pomlka","pomoc","pomsta","pomyslet","ponechat","ponorka","ponurost","popadat","popel","popisek","poplach","poprosit","popsat","popud","poradce","porce","porod","porucha","poryv","posadit","posed","posila","poskok","poslanec","posoudit","pospolu","postava","posudek","posyp","potah","potkan","potlesk","potomek","potrava","potupa","potvora","poukaz","pouto","pouzdro","povaha","povidla","povlak","povoz","povrch","povstat","povyk","povzdech","pozdrav","pozemek","poznatek","pozor","pozvat","pracovat","prahory","praktika","prales","praotec","praporek","prase","pravda","princip","prkno","probudit","procento","prodej","profese","prohra","projekt","prolomit","promile","pronikat","propad","prorok","prosba","proton","proutek","provaz","prskavka","prsten","prudkost","prut","prvek","prvohory","psanec","psovod","pstruh","ptactvo","puberta","puch","pudl","pukavec","puklina","pukrle","pult","pumpa","punc","pupen","pusa","pusinka","pustina","putovat","putyka","pyramida","pysk","pytel","racek","rachot","radiace","radnice","radon","raft","ragby","raketa","rakovina","rameno","rampouch","rande","rarach","rarita","rasovna","rastr","ratolest","razance","razidlo","reagovat","reakce","recept","redaktor","referent","reflex","rejnok","reklama","rekord","rekrut","rektor","reputace","revize","revma","revolver","rezerva","riskovat","riziko","robotika","rodokmen","rohovka","rokle","rokoko","romaneto","ropovod","ropucha","rorejs","rosol","rostlina","rotmistr","rotoped","rotunda","roubenka","roucho","roup","roura","rovina","rovnice","rozbor","rozchod","rozdat","rozeznat","rozhodce","rozinka","rozjezd","rozkaz","rozloha","rozmar","rozpad","rozruch","rozsah","roztok","rozum","rozvod","rubrika","ruchadlo","rukavice","rukopis","ryba","rybolov","rychlost","rydlo","rypadlo","rytina","ryzost","sadista","sahat","sako","samec","samizdat","samota","sanitka","sardinka","sasanka","satelit","sazba","sazenice","sbor","schovat","sebranka","secese","sedadlo","sediment","sedlo","sehnat","sejmout","sekera","sekta","sekunda","sekvoje","semeno","seno","servis","sesadit","seshora","seskok","seslat","sestra","sesuv","sesypat","setba","setina","setkat","setnout","setrvat","sever","seznam","shoda","shrnout","sifon","silnice","sirka","sirotek","sirup","situace","skafandr","skalisko","skanzen","skaut","skeptik","skica","skladba","sklenice","sklo","skluz","skoba","skokan","skoro","skripta","skrz","skupina","skvost","skvrna","slabika","sladidlo","slanina","slast","slavnost","sledovat","slepec","sleva","slezina","slib","slina","sliznice","slon","sloupek","slovo","sluch","sluha","slunce","slupka","slza","smaragd","smetana","smilstvo","smlouva","smog","smrad","smrk","smrtka","smutek","smysl","snad","snaha","snob","sobota","socha","sodovka","sokol","sopka","sotva","souboj","soucit","soudce","souhlas","soulad","soumrak","souprava","soused","soutok","souviset","spalovna","spasitel","spis","splav","spodek","spojenec","spolu","sponzor","spornost","spousta","sprcha","spustit","sranda","sraz","srdce","srna","srnec","srovnat","srpen","srst","srub","stanice","starosta","statika","stavba","stehno","stezka","stodola","stolek","stopa","storno","stoupat","strach","stres","strhnout","strom","struna","studna","stupnice","stvol","styk","subjekt","subtropy","suchar","sudost","sukno","sundat","sunout","surikata","surovina","svah","svalstvo","svetr","svatba","svazek","svisle","svitek","svoboda","svodidlo","svorka","svrab","sykavka","sykot","synek","synovec","sypat","sypkost","syrovost","sysel","sytost","tabletka","tabule","tahoun","tajemno","tajfun","tajga","tajit","tajnost","taktika","tamhle","tampon","tancovat","tanec","tanker","tapeta","tavenina","tazatel","technika","tehdy","tekutina","telefon","temnota","tendence","tenista","tenor","teplota","tepna","teprve","terapie","termoska","textil","ticho","tiskopis","titulek","tkadlec","tkanina","tlapka","tleskat","tlukot","tlupa","tmel","toaleta","topinka","topol","torzo","touha","toulec","tradice","traktor","tramp","trasa","traverza","trefit","trest","trezor","trhavina","trhlina","trochu","trojice","troska","trouba","trpce","trpitel","trpkost","trubec","truchlit","truhlice","trus","trvat","tudy","tuhnout","tuhost","tundra","turista","turnaj","tuzemsko","tvaroh","tvorba","tvrdost","tvrz","tygr","tykev","ubohost","uboze","ubrat","ubrousek","ubrus","ubytovna","ucho","uctivost","udivit","uhradit","ujednat","ujistit","ujmout","ukazatel","uklidnit","uklonit","ukotvit","ukrojit","ulice","ulita","ulovit","umyvadlo","unavit","uniforma","uniknout","upadnout","uplatnit","uplynout","upoutat","upravit","uran","urazit","usednout","usilovat","usmrtit","usnadnit","usnout","usoudit","ustlat","ustrnout","utahovat","utkat","utlumit","utonout","utopenec","utrousit","uvalit","uvolnit","uvozovka","uzdravit","uzel","uzenina","uzlina","uznat","vagon","valcha","valoun","vana","vandal","vanilka","varan","varhany","varovat","vcelku","vchod","vdova","vedro","vegetace","vejce","velbloud","veletrh","velitel","velmoc","velryba","venkov","veranda","verze","veselka","veskrze","vesnice","vespodu","vesta","veterina","veverka","vibrace","vichr","videohra","vidina","vidle","vila","vinice","viset","vitalita","vize","vizitka","vjezd","vklad","vkus","vlajka","vlak","vlasec","vlevo","vlhkost","vliv","vlnovka","vloupat","vnucovat","vnuk","voda","vodivost","vodoznak","vodstvo","vojensky","vojna","vojsko","volant","volba","volit","volno","voskovka","vozidlo","vozovna","vpravo","vrabec","vracet","vrah","vrata","vrba","vrcholek","vrhat","vrstva","vrtule","vsadit","vstoupit","vstup","vtip","vybavit","vybrat","vychovat","vydat","vydra","vyfotit","vyhledat","vyhnout","vyhodit","vyhradit","vyhubit","vyjasnit","vyjet","vyjmout","vyklopit","vykonat","vylekat","vymazat","vymezit","vymizet","vymyslet","vynechat","vynikat","vynutit","vypadat","vyplatit","vypravit","vypustit","vyrazit","vyrovnat","vyrvat","vyslovit","vysoko","vystavit","vysunout","vysypat","vytasit","vytesat","vytratit","vyvinout","vyvolat","vyvrhel","vyzdobit","vyznat","vzadu","vzbudit","vzchopit","vzdor","vzduch","vzdychat","vzestup","vzhledem","vzkaz","vzlykat","vznik","vzorek","vzpoura","vztah","vztek","xylofon","zabrat","zabydlet","zachovat","zadarmo","zadusit","zafoukat","zahltit","zahodit","zahrada","zahynout","zajatec","zajet","zajistit","zaklepat","zakoupit","zalepit","zamezit","zamotat","zamyslet","zanechat","zanikat","zaplatit","zapojit","zapsat","zarazit","zastavit","zasunout","zatajit","zatemnit","zatknout","zaujmout","zavalit","zavelet","zavinit","zavolat","zavrtat","zazvonit","zbavit","zbrusu","zbudovat","zbytek","zdaleka","zdarma","zdatnost","zdivo","zdobit","zdroj","zdvih","zdymadlo","zelenina","zeman","zemina","zeptat","zezadu","zezdola","zhatit","zhltnout","zhluboka","zhotovit","zhruba","zima","zimnice","zjemnit","zklamat","zkoumat","zkratka","zkumavka","zlato","zlehka","zloba","zlom","zlost","zlozvyk","zmapovat","zmar","zmatek","zmije","zmizet","zmocnit","zmodrat","zmrzlina","zmutovat","znak","znalost","znamenat","znovu","zobrazit","zotavit","zoubek","zoufale","zplodit","zpomalit","zprava","zprostit","zprudka","zprvu","zrada","zranit","zrcadlo","zrnitost","zrno","zrovna","zrychlit","zrzavost","zticha","ztratit","zubovina","zubr","zvednout","zvenku","zvesela","zvon","zvrat","zvukovod","zvyk"]');
const require$$1 = /* @__PURE__ */ JSON.parse('["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""]');
const require$$2 = /* @__PURE__ */ JSON.parse('["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""]');
const require$$3 = /* @__PURE__ */ JSON.parse('["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""]');
const require$$4 = /* @__PURE__ */ JSON.parse('["abaisser","abandon","abdiquer","abeille","abolir","aborder","aboutir","aboyer","abrasif","abreuver","abriter","abroger","abrupt","absence","absolu","absurde","abusif","abyssal","academie","acajou","acarien","accabler","accepter","acclamer","accolade","accroche","accuser","acerbe","achat","acheter","aciduler","acier","acompte","acquerir","acronyme","acteur","actif","actuel","adepte","adequat","adhesif","adjectif","adjuger","admettre","admirer","adopter","adorer","adoucir","adresse","adroit","adulte","adverbe","aerer","aeronef","affaire","affecter","affiche","affreux","affubler","agacer","agencer","agile","agiter","agrafer","agreable","agrume","aider","aiguille","ailier","aimable","aisance","ajouter","ajuster","alarmer","alchimie","alerte","algebre","algue","aliener","aliment","alleger","alliage","allouer","allumer","alourdir","alpaga","altesse","alveole","amateur","ambigu","ambre","amenager","amertume","amidon","amiral","amorcer","amour","amovible","amphibie","ampleur","amusant","analyse","anaphore","anarchie","anatomie","ancien","aneantir","angle","angoisse","anguleux","animal","annexer","annonce","annuel","anodin","anomalie","anonyme","anormal","antenne","antidote","anxieux","apaiser","aperitif","aplanir","apologie","appareil","appeler","apporter","appuyer","aquarium","aqueduc","arbitre","arbuste","ardeur","ardoise","argent","arlequin","armature","armement","armoire","armure","arpenter","arracher","arriver","arroser","arsenic","arteriel","article","aspect","asphalte","aspirer","assaut","asservir","assiette","associer","assurer","asticot","astre","astuce","atelier","atome","atrium","atroce","attaque","attentif","attirer","attraper","aubaine","auberge","audace","audible","augurer","aurore","automne","autruche","avaler","avancer","avarice","avenir","averse","aveugle","aviateur","avide","avion","aviser","avoine","avouer","avril","axial","axiome","badge","bafouer","bagage","baguette","baignade","balancer","balcon","baleine","balisage","bambin","bancaire","bandage","banlieue","banniere","banquier","barbier","baril","baron","barque","barrage","bassin","bastion","bataille","bateau","batterie","baudrier","bavarder","belette","belier","belote","benefice","berceau","berger","berline","bermuda","besace","besogne","betail","beurre","biberon","bicycle","bidule","bijou","bilan","bilingue","billard","binaire","biologie","biopsie","biotype","biscuit","bison","bistouri","bitume","bizarre","blafard","blague","blanchir","blessant","blinder","blond","bloquer","blouson","bobard","bobine","boire","boiser","bolide","bonbon","bondir","bonheur","bonifier","bonus","bordure","borne","botte","boucle","boueux","bougie","boulon","bouquin","bourse","boussole","boutique","boxeur","branche","brasier","brave","brebis","breche","breuvage","bricoler","brigade","brillant","brioche","brique","brochure","broder","bronzer","brousse","broyeur","brume","brusque","brutal","bruyant","buffle","buisson","bulletin","bureau","burin","bustier","butiner","butoir","buvable","buvette","cabanon","cabine","cachette","cadeau","cadre","cafeine","caillou","caisson","calculer","calepin","calibre","calmer","calomnie","calvaire","camarade","camera","camion","campagne","canal","caneton","canon","cantine","canular","capable","caporal","caprice","capsule","capter","capuche","carabine","carbone","caresser","caribou","carnage","carotte","carreau","carton","cascade","casier","casque","cassure","causer","caution","cavalier","caverne","caviar","cedille","ceinture","celeste","cellule","cendrier","censurer","central","cercle","cerebral","cerise","cerner","cerveau","cesser","chagrin","chaise","chaleur","chambre","chance","chapitre","charbon","chasseur","chaton","chausson","chavirer","chemise","chenille","chequier","chercher","cheval","chien","chiffre","chignon","chimere","chiot","chlorure","chocolat","choisir","chose","chouette","chrome","chute","cigare","cigogne","cimenter","cinema","cintrer","circuler","cirer","cirque","citerne","citoyen","citron","civil","clairon","clameur","claquer","classe","clavier","client","cligner","climat","clivage","cloche","clonage","cloporte","cobalt","cobra","cocasse","cocotier","coder","codifier","coffre","cogner","cohesion","coiffer","coincer","colere","colibri","colline","colmater","colonel","combat","comedie","commande","compact","concert","conduire","confier","congeler","connoter","consonne","contact","convexe","copain","copie","corail","corbeau","cordage","corniche","corpus","correct","cortege","cosmique","costume","coton","coude","coupure","courage","couteau","couvrir","coyote","crabe","crainte","cravate","crayon","creature","crediter","cremeux","creuser","crevette","cribler","crier","cristal","critere","croire","croquer","crotale","crucial","cruel","crypter","cubique","cueillir","cuillere","cuisine","cuivre","culminer","cultiver","cumuler","cupide","curatif","curseur","cyanure","cycle","cylindre","cynique","daigner","damier","danger","danseur","dauphin","debattre","debiter","deborder","debrider","debutant","decaler","decembre","dechirer","decider","declarer","decorer","decrire","decupler","dedale","deductif","deesse","defensif","defiler","defrayer","degager","degivrer","deglutir","degrafer","dejeuner","delice","deloger","demander","demeurer","demolir","denicher","denouer","dentelle","denuder","depart","depenser","dephaser","deplacer","deposer","deranger","derober","desastre","descente","desert","designer","desobeir","dessiner","destrier","detacher","detester","detourer","detresse","devancer","devenir","deviner","devoir","diable","dialogue","diamant","dicter","differer","digerer","digital","digne","diluer","dimanche","diminuer","dioxyde","directif","diriger","discuter","disposer","dissiper","distance","divertir","diviser","docile","docteur","dogme","doigt","domaine","domicile","dompter","donateur","donjon","donner","dopamine","dortoir","dorure","dosage","doseur","dossier","dotation","douanier","double","douceur","douter","doyen","dragon","draper","dresser","dribbler","droiture","duperie","duplexe","durable","durcir","dynastie","eblouir","ecarter","echarpe","echelle","eclairer","eclipse","eclore","ecluse","ecole","economie","ecorce","ecouter","ecraser","ecremer","ecrivain","ecrou","ecume","ecureuil","edifier","eduquer","effacer","effectif","effigie","effort","effrayer","effusion","egaliser","egarer","ejecter","elaborer","elargir","electron","elegant","elephant","eleve","eligible","elitisme","eloge","elucider","eluder","emballer","embellir","embryon","emeraude","emission","emmener","emotion","emouvoir","empereur","employer","emporter","emprise","emulsion","encadrer","enchere","enclave","encoche","endiguer","endosser","endroit","enduire","energie","enfance","enfermer","enfouir","engager","engin","englober","enigme","enjamber","enjeu","enlever","ennemi","ennuyeux","enrichir","enrobage","enseigne","entasser","entendre","entier","entourer","entraver","enumerer","envahir","enviable","envoyer","enzyme","eolien","epaissir","epargne","epatant","epaule","epicerie","epidemie","epier","epilogue","epine","episode","epitaphe","epoque","epreuve","eprouver","epuisant","equerre","equipe","eriger","erosion","erreur","eruption","escalier","espadon","espece","espiegle","espoir","esprit","esquiver","essayer","essence","essieu","essorer","estime","estomac","estrade","etagere","etaler","etanche","etatique","eteindre","etendoir","eternel","ethanol","ethique","ethnie","etirer","etoffer","etoile","etonnant","etourdir","etrange","etroit","etude","euphorie","evaluer","evasion","eventail","evidence","eviter","evolutif","evoquer","exact","exagerer","exaucer","exceller","excitant","exclusif","excuse","executer","exemple","exercer","exhaler","exhorter","exigence","exiler","exister","exotique","expedier","explorer","exposer","exprimer","exquis","extensif","extraire","exulter","fable","fabuleux","facette","facile","facture","faiblir","falaise","fameux","famille","farceur","farfelu","farine","farouche","fasciner","fatal","fatigue","faucon","fautif","faveur","favori","febrile","feconder","federer","felin","femme","femur","fendoir","feodal","fermer","feroce","ferveur","festival","feuille","feutre","fevrier","fiasco","ficeler","fictif","fidele","figure","filature","filetage","filiere","filleul","filmer","filou","filtrer","financer","finir","fiole","firme","fissure","fixer","flairer","flamme","flasque","flatteur","fleau","fleche","fleur","flexion","flocon","flore","fluctuer","fluide","fluvial","folie","fonderie","fongible","fontaine","forcer","forgeron","formuler","fortune","fossile","foudre","fougere","fouiller","foulure","fourmi","fragile","fraise","franchir","frapper","frayeur","fregate","freiner","frelon","fremir","frenesie","frere","friable","friction","frisson","frivole","froid","fromage","frontal","frotter","fruit","fugitif","fuite","fureur","furieux","furtif","fusion","futur","gagner","galaxie","galerie","gambader","garantir","gardien","garnir","garrigue","gazelle","gazon","geant","gelatine","gelule","gendarme","general","genie","genou","gentil","geologie","geometre","geranium","germe","gestuel","geyser","gibier","gicler","girafe","givre","glace","glaive","glisser","globe","gloire","glorieux","golfeur","gomme","gonfler","gorge","gorille","goudron","gouffre","goulot","goupille","gourmand","goutte","graduel","graffiti","graine","grand","grappin","gratuit","gravir","grenat","griffure","griller","grimper","grogner","gronder","grotte","groupe","gruger","grutier","gruyere","guepard","guerrier","guide","guimauve","guitare","gustatif","gymnaste","gyrostat","habitude","hachoir","halte","hameau","hangar","hanneton","haricot","harmonie","harpon","hasard","helium","hematome","herbe","herisson","hermine","heron","hesiter","heureux","hiberner","hibou","hilarant","histoire","hiver","homard","hommage","homogene","honneur","honorer","honteux","horde","horizon","horloge","hormone","horrible","houleux","housse","hublot","huileux","humain","humble","humide","humour","hurler","hydromel","hygiene","hymne","hypnose","idylle","ignorer","iguane","illicite","illusion","image","imbiber","imiter","immense","immobile","immuable","impact","imperial","implorer","imposer","imprimer","imputer","incarner","incendie","incident","incliner","incolore","indexer","indice","inductif","inedit","ineptie","inexact","infini","infliger","informer","infusion","ingerer","inhaler","inhiber","injecter","injure","innocent","inoculer","inonder","inscrire","insecte","insigne","insolite","inspirer","instinct","insulter","intact","intense","intime","intrigue","intuitif","inutile","invasion","inventer","inviter","invoquer","ironique","irradier","irreel","irriter","isoler","ivoire","ivresse","jaguar","jaillir","jambe","janvier","jardin","jauger","jaune","javelot","jetable","jeton","jeudi","jeunesse","joindre","joncher","jongler","joueur","jouissif","journal","jovial","joyau","joyeux","jubiler","jugement","junior","jupon","juriste","justice","juteux","juvenile","kayak","kimono","kiosque","label","labial","labourer","lacerer","lactose","lagune","laine","laisser","laitier","lambeau","lamelle","lampe","lanceur","langage","lanterne","lapin","largeur","larme","laurier","lavabo","lavoir","lecture","legal","leger","legume","lessive","lettre","levier","lexique","lezard","liasse","liberer","libre","licence","licorne","liege","lievre","ligature","ligoter","ligue","limer","limite","limonade","limpide","lineaire","lingot","lionceau","liquide","lisiere","lister","lithium","litige","littoral","livreur","logique","lointain","loisir","lombric","loterie","louer","lourd","loutre","louve","loyal","lubie","lucide","lucratif","lueur","lugubre","luisant","lumiere","lunaire","lundi","luron","lutter","luxueux","machine","magasin","magenta","magique","maigre","maillon","maintien","mairie","maison","majorer","malaxer","malefice","malheur","malice","mallette","mammouth","mandater","maniable","manquant","manteau","manuel","marathon","marbre","marchand","mardi","maritime","marqueur","marron","marteler","mascotte","massif","materiel","matiere","matraque","maudire","maussade","mauve","maximal","mechant","meconnu","medaille","medecin","mediter","meduse","meilleur","melange","melodie","membre","memoire","menacer","mener","menhir","mensonge","mentor","mercredi","merite","merle","messager","mesure","metal","meteore","methode","metier","meuble","miauler","microbe","miette","mignon","migrer","milieu","million","mimique","mince","mineral","minimal","minorer","minute","miracle","miroiter","missile","mixte","mobile","moderne","moelleux","mondial","moniteur","monnaie","monotone","monstre","montagne","monument","moqueur","morceau","morsure","mortier","moteur","motif","mouche","moufle","moulin","mousson","mouton","mouvant","multiple","munition","muraille","murene","murmure","muscle","museum","musicien","mutation","muter","mutuel","myriade","myrtille","mystere","mythique","nageur","nappe","narquois","narrer","natation","nation","nature","naufrage","nautique","navire","nebuleux","nectar","nefaste","negation","negliger","negocier","neige","nerveux","nettoyer","neurone","neutron","neveu","niche","nickel","nitrate","niveau","noble","nocif","nocturne","noirceur","noisette","nomade","nombreux","nommer","normatif","notable","notifier","notoire","nourrir","nouveau","novateur","novembre","novice","nuage","nuancer","nuire","nuisible","numero","nuptial","nuque","nutritif","obeir","objectif","obliger","obscur","observer","obstacle","obtenir","obturer","occasion","occuper","ocean","octobre","octroyer","octupler","oculaire","odeur","odorant","offenser","officier","offrir","ogive","oiseau","oisillon","olfactif","olivier","ombrage","omettre","onctueux","onduler","onereux","onirique","opale","opaque","operer","opinion","opportun","opprimer","opter","optique","orageux","orange","orbite","ordonner","oreille","organe","orgueil","orifice","ornement","orque","ortie","osciller","osmose","ossature","otarie","ouragan","ourson","outil","outrager","ouvrage","ovation","oxyde","oxygene","ozone","paisible","palace","palmares","palourde","palper","panache","panda","pangolin","paniquer","panneau","panorama","pantalon","papaye","papier","papoter","papyrus","paradoxe","parcelle","paresse","parfumer","parler","parole","parrain","parsemer","partager","parure","parvenir","passion","pasteque","paternel","patience","patron","pavillon","pavoiser","payer","paysage","peigne","peintre","pelage","pelican","pelle","pelouse","peluche","pendule","penetrer","penible","pensif","penurie","pepite","peplum","perdrix","perforer","periode","permuter","perplexe","persil","perte","peser","petale","petit","petrir","peuple","pharaon","phobie","phoque","photon","phrase","physique","piano","pictural","piece","pierre","pieuvre","pilote","pinceau","pipette","piquer","pirogue","piscine","piston","pivoter","pixel","pizza","placard","plafond","plaisir","planer","plaque","plastron","plateau","pleurer","plexus","pliage","plomb","plonger","pluie","plumage","pochette","poesie","poete","pointe","poirier","poisson","poivre","polaire","policier","pollen","polygone","pommade","pompier","ponctuel","ponderer","poney","portique","position","posseder","posture","potager","poteau","potion","pouce","poulain","poumon","pourpre","poussin","pouvoir","prairie","pratique","precieux","predire","prefixe","prelude","prenom","presence","pretexte","prevoir","primitif","prince","prison","priver","probleme","proceder","prodige","profond","progres","proie","projeter","prologue","promener","propre","prospere","proteger","prouesse","proverbe","prudence","pruneau","psychose","public","puceron","puiser","pulpe","pulsar","punaise","punitif","pupitre","purifier","puzzle","pyramide","quasar","querelle","question","quietude","quitter","quotient","racine","raconter","radieux","ragondin","raideur","raisin","ralentir","rallonge","ramasser","rapide","rasage","ratisser","ravager","ravin","rayonner","reactif","reagir","realiser","reanimer","recevoir","reciter","reclamer","recolter","recruter","reculer","recycler","rediger","redouter","refaire","reflexe","reformer","refrain","refuge","regalien","region","reglage","regulier","reiterer","rejeter","rejouer","relatif","relever","relief","remarque","remede","remise","remonter","remplir","remuer","renard","renfort","renifler","renoncer","rentrer","renvoi","replier","reporter","reprise","reptile","requin","reserve","resineux","resoudre","respect","rester","resultat","retablir","retenir","reticule","retomber","retracer","reunion","reussir","revanche","revivre","revolte","revulsif","richesse","rideau","rieur","rigide","rigoler","rincer","riposter","risible","risque","rituel","rival","riviere","rocheux","romance","rompre","ronce","rondin","roseau","rosier","rotatif","rotor","rotule","rouge","rouille","rouleau","routine","royaume","ruban","rubis","ruche","ruelle","rugueux","ruiner","ruisseau","ruser","rustique","rythme","sabler","saboter","sabre","sacoche","safari","sagesse","saisir","salade","salive","salon","saluer","samedi","sanction","sanglier","sarcasme","sardine","saturer","saugrenu","saumon","sauter","sauvage","savant","savonner","scalpel","scandale","scelerat","scenario","sceptre","schema","science","scinder","score","scrutin","sculpter","seance","secable","secher","secouer","secreter","sedatif","seduire","seigneur","sejour","selectif","semaine","sembler","semence","seminal","senateur","sensible","sentence","separer","sequence","serein","sergent","serieux","serrure","serum","service","sesame","sevir","sevrage","sextuple","sideral","siecle","sieger","siffler","sigle","signal","silence","silicium","simple","sincere","sinistre","siphon","sirop","sismique","situer","skier","social","socle","sodium","soigneux","soldat","soleil","solitude","soluble","sombre","sommeil","somnoler","sonde","songeur","sonnette","sonore","sorcier","sortir","sosie","sottise","soucieux","soudure","souffle","soulever","soupape","source","soutirer","souvenir","spacieux","spatial","special","sphere","spiral","stable","station","sternum","stimulus","stipuler","strict","studieux","stupeur","styliste","sublime","substrat","subtil","subvenir","succes","sucre","suffixe","suggerer","suiveur","sulfate","superbe","supplier","surface","suricate","surmener","surprise","sursaut","survie","suspect","syllabe","symbole","symetrie","synapse","syntaxe","systeme","tabac","tablier","tactile","tailler","talent","talisman","talonner","tambour","tamiser","tangible","tapis","taquiner","tarder","tarif","tartine","tasse","tatami","tatouage","taupe","taureau","taxer","temoin","temporel","tenaille","tendre","teneur","tenir","tension","terminer","terne","terrible","tetine","texte","theme","theorie","therapie","thorax","tibia","tiede","timide","tirelire","tiroir","tissu","titane","titre","tituber","toboggan","tolerant","tomate","tonique","tonneau","toponyme","torche","tordre","tornade","torpille","torrent","torse","tortue","totem","toucher","tournage","tousser","toxine","traction","trafic","tragique","trahir","train","trancher","travail","trefle","tremper","tresor","treuil","triage","tribunal","tricoter","trilogie","triomphe","tripler","triturer","trivial","trombone","tronc","tropical","troupeau","tuile","tulipe","tumulte","tunnel","turbine","tuteur","tutoyer","tuyau","tympan","typhon","typique","tyran","ubuesque","ultime","ultrason","unanime","unifier","union","unique","unitaire","univers","uranium","urbain","urticant","usage","usine","usuel","usure","utile","utopie","vacarme","vaccin","vagabond","vague","vaillant","vaincre","vaisseau","valable","valise","vallon","valve","vampire","vanille","vapeur","varier","vaseux","vassal","vaste","vecteur","vedette","vegetal","vehicule","veinard","veloce","vendredi","venerer","venger","venimeux","ventouse","verdure","verin","vernir","verrou","verser","vertu","veston","veteran","vetuste","vexant","vexer","viaduc","viande","victoire","vidange","video","vignette","vigueur","vilain","village","vinaigre","violon","vipere","virement","virtuose","virus","visage","viseur","vision","visqueux","visuel","vital","vitesse","viticole","vitrine","vivace","vivipare","vocation","voguer","voile","voisin","voiture","volaille","volcan","voltiger","volume","vorace","vortex","voter","vouloir","voyage","voyelle","wagon","xenon","yacht","zebre","zenith","zeste","zoologie"]');
const require$$5 = /* @__PURE__ */ JSON.parse('["abaco","abbaglio","abbinato","abete","abisso","abolire","abrasivo","abrogato","accadere","accenno","accusato","acetone","achille","acido","acqua","acre","acrilico","acrobata","acuto","adagio","addebito","addome","adeguato","aderire","adipe","adottare","adulare","affabile","affetto","affisso","affranto","aforisma","afoso","africano","agave","agente","agevole","aggancio","agire","agitare","agonismo","agricolo","agrumeto","aguzzo","alabarda","alato","albatro","alberato","albo","albume","alce","alcolico","alettone","alfa","algebra","aliante","alibi","alimento","allagato","allegro","allievo","allodola","allusivo","almeno","alogeno","alpaca","alpestre","altalena","alterno","alticcio","altrove","alunno","alveolo","alzare","amalgama","amanita","amarena","ambito","ambrato","ameba","america","ametista","amico","ammasso","ammenda","ammirare","ammonito","amore","ampio","ampliare","amuleto","anacardo","anagrafe","analista","anarchia","anatra","anca","ancella","ancora","andare","andrea","anello","angelo","angolare","angusto","anima","annegare","annidato","anno","annuncio","anonimo","anticipo","anzi","apatico","apertura","apode","apparire","appetito","appoggio","approdo","appunto","aprile","arabica","arachide","aragosta","araldica","arancio","aratura","arazzo","arbitro","archivio","ardito","arenile","argento","argine","arguto","aria","armonia","arnese","arredato","arringa","arrosto","arsenico","arso","artefice","arzillo","asciutto","ascolto","asepsi","asettico","asfalto","asino","asola","aspirato","aspro","assaggio","asse","assoluto","assurdo","asta","astenuto","astice","astratto","atavico","ateismo","atomico","atono","attesa","attivare","attorno","attrito","attuale","ausilio","austria","autista","autonomo","autunno","avanzato","avere","avvenire","avviso","avvolgere","azione","azoto","azzimo","azzurro","babele","baccano","bacino","baco","badessa","badilata","bagnato","baita","balcone","baldo","balena","ballata","balzano","bambino","bandire","baraonda","barbaro","barca","baritono","barlume","barocco","basilico","basso","batosta","battuto","baule","bava","bavosa","becco","beffa","belgio","belva","benda","benevole","benigno","benzina","bere","berlina","beta","bibita","bici","bidone","bifido","biga","bilancia","bimbo","binocolo","biologo","bipede","bipolare","birbante","birra","biscotto","bisesto","bisnonno","bisonte","bisturi","bizzarro","blando","blatta","bollito","bonifico","bordo","bosco","botanico","bottino","bozzolo","braccio","bradipo","brama","branca","bravura","bretella","brevetto","brezza","briglia","brillante","brindare","broccolo","brodo","bronzina","brullo","bruno","bubbone","buca","budino","buffone","buio","bulbo","buono","burlone","burrasca","bussola","busta","cadetto","caduco","calamaro","calcolo","calesse","calibro","calmo","caloria","cambusa","camerata","camicia","cammino","camola","campale","canapa","candela","cane","canino","canotto","cantina","capace","capello","capitolo","capogiro","cappero","capra","capsula","carapace","carcassa","cardo","carisma","carovana","carretto","cartolina","casaccio","cascata","caserma","caso","cassone","castello","casuale","catasta","catena","catrame","cauto","cavillo","cedibile","cedrata","cefalo","celebre","cellulare","cena","cenone","centesimo","ceramica","cercare","certo","cerume","cervello","cesoia","cespo","ceto","chela","chiaro","chicca","chiedere","chimera","china","chirurgo","chitarra","ciao","ciclismo","cifrare","cigno","cilindro","ciottolo","circa","cirrosi","citrico","cittadino","ciuffo","civetta","civile","classico","clinica","cloro","cocco","codardo","codice","coerente","cognome","collare","colmato","colore","colposo","coltivato","colza","coma","cometa","commando","comodo","computer","comune","conciso","condurre","conferma","congelare","coniuge","connesso","conoscere","consumo","continuo","convegno","coperto","copione","coppia","copricapo","corazza","cordata","coricato","cornice","corolla","corpo","corredo","corsia","cortese","cosmico","costante","cottura","covato","cratere","cravatta","creato","credere","cremoso","crescita","creta","criceto","crinale","crisi","critico","croce","cronaca","crostata","cruciale","crusca","cucire","cuculo","cugino","cullato","cupola","curatore","cursore","curvo","cuscino","custode","dado","daino","dalmata","damerino","daniela","dannoso","danzare","datato","davanti","davvero","debutto","decennio","deciso","declino","decollo","decreto","dedicato","definito","deforme","degno","delegare","delfino","delirio","delta","demenza","denotato","dentro","deposito","derapata","derivare","deroga","descritto","deserto","desiderio","desumere","detersivo","devoto","diametro","dicembre","diedro","difeso","diffuso","digerire","digitale","diluvio","dinamico","dinnanzi","dipinto","diploma","dipolo","diradare","dire","dirotto","dirupo","disagio","discreto","disfare","disgelo","disposto","distanza","disumano","dito","divano","divelto","dividere","divorato","doblone","docente","doganale","dogma","dolce","domato","domenica","dominare","dondolo","dono","dormire","dote","dottore","dovuto","dozzina","drago","druido","dubbio","dubitare","ducale","duna","duomo","duplice","duraturo","ebano","eccesso","ecco","eclissi","economia","edera","edicola","edile","editoria","educare","egemonia","egli","egoismo","egregio","elaborato","elargire","elegante","elencato","eletto","elevare","elfico","elica","elmo","elsa","eluso","emanato","emblema","emesso","emiro","emotivo","emozione","empirico","emulo","endemico","enduro","energia","enfasi","enoteca","entrare","enzima","epatite","epilogo","episodio","epocale","eppure","equatore","erario","erba","erboso","erede","eremita","erigere","ermetico","eroe","erosivo","errante","esagono","esame","esanime","esaudire","esca","esempio","esercito","esibito","esigente","esistere","esito","esofago","esortato","esoso","espanso","espresso","essenza","esso","esteso","estimare","estonia","estroso","esultare","etilico","etnico","etrusco","etto","euclideo","europa","evaso","evidenza","evitato","evoluto","evviva","fabbrica","faccenda","fachiro","falco","famiglia","fanale","fanfara","fango","fantasma","fare","farfalla","farinoso","farmaco","fascia","fastoso","fasullo","faticare","fato","favoloso","febbre","fecola","fede","fegato","felpa","feltro","femmina","fendere","fenomeno","fermento","ferro","fertile","fessura","festivo","fetta","feudo","fiaba","fiducia","fifa","figurato","filo","finanza","finestra","finire","fiore","fiscale","fisico","fiume","flacone","flamenco","flebo","flemma","florido","fluente","fluoro","fobico","focaccia","focoso","foderato","foglio","folata","folclore","folgore","fondente","fonetico","fonia","fontana","forbito","forchetta","foresta","formica","fornaio","foro","fortezza","forzare","fosfato","fosso","fracasso","frana","frassino","fratello","freccetta","frenata","fresco","frigo","frollino","fronde","frugale","frutta","fucilata","fucsia","fuggente","fulmine","fulvo","fumante","fumetto","fumoso","fune","funzione","fuoco","furbo","furgone","furore","fuso","futile","gabbiano","gaffe","galateo","gallina","galoppo","gambero","gamma","garanzia","garbo","garofano","garzone","gasdotto","gasolio","gastrico","gatto","gaudio","gazebo","gazzella","geco","gelatina","gelso","gemello","gemmato","gene","genitore","gennaio","genotipo","gergo","ghepardo","ghiaccio","ghisa","giallo","gilda","ginepro","giocare","gioiello","giorno","giove","girato","girone","gittata","giudizio","giurato","giusto","globulo","glutine","gnomo","gobba","golf","gomito","gommone","gonfio","gonna","governo","gracile","grado","grafico","grammo","grande","grattare","gravoso","grazia","greca","gregge","grifone","grigio","grinza","grotta","gruppo","guadagno","guaio","guanto","guardare","gufo","guidare","ibernato","icona","identico","idillio","idolo","idra","idrico","idrogeno","igiene","ignaro","ignorato","ilare","illeso","illogico","illudere","imballo","imbevuto","imbocco","imbuto","immane","immerso","immolato","impacco","impeto","impiego","importo","impronta","inalare","inarcare","inattivo","incanto","incendio","inchino","incisivo","incluso","incontro","incrocio","incubo","indagine","india","indole","inedito","infatti","infilare","inflitto","ingaggio","ingegno","inglese","ingordo","ingrosso","innesco","inodore","inoltrare","inondato","insano","insetto","insieme","insonnia","insulina","intasato","intero","intonaco","intuito","inumidire","invalido","invece","invito","iperbole","ipnotico","ipotesi","ippica","iride","irlanda","ironico","irrigato","irrorare","isolato","isotopo","isterico","istituto","istrice","italia","iterare","labbro","labirinto","lacca","lacerato","lacrima","lacuna","laddove","lago","lampo","lancetta","lanterna","lardoso","larga","laringe","lastra","latenza","latino","lattuga","lavagna","lavoro","legale","leggero","lembo","lentezza","lenza","leone","lepre","lesivo","lessato","lesto","letterale","leva","levigato","libero","lido","lievito","lilla","limatura","limitare","limpido","lineare","lingua","liquido","lira","lirica","lisca","lite","litigio","livrea","locanda","lode","logica","lombare","londra","longevo","loquace","lorenzo","loto","lotteria","luce","lucidato","lumaca","luminoso","lungo","lupo","luppolo","lusinga","lusso","lutto","macabro","macchina","macero","macinato","madama","magico","maglia","magnete","magro","maiolica","malafede","malgrado","malinteso","malsano","malto","malumore","mana","mancia","mandorla","mangiare","manifesto","mannaro","manovra","mansarda","mantide","manubrio","mappa","maratona","marcire","maretta","marmo","marsupio","maschera","massaia","mastino","materasso","matricola","mattone","maturo","mazurca","meandro","meccanico","mecenate","medesimo","meditare","mega","melassa","melis","melodia","meninge","meno","mensola","mercurio","merenda","merlo","meschino","mese","messere","mestolo","metallo","metodo","mettere","miagolare","mica","micelio","michele","microbo","midollo","miele","migliore","milano","milite","mimosa","minerale","mini","minore","mirino","mirtillo","miscela","missiva","misto","misurare","mitezza","mitigare","mitra","mittente","mnemonico","modello","modifica","modulo","mogano","mogio","mole","molosso","monastero","monco","mondina","monetario","monile","monotono","monsone","montato","monviso","mora","mordere","morsicato","mostro","motivato","motosega","motto","movenza","movimento","mozzo","mucca","mucosa","muffa","mughetto","mugnaio","mulatto","mulinello","multiplo","mummia","munto","muovere","murale","musa","muscolo","musica","mutevole","muto","nababbo","nafta","nanometro","narciso","narice","narrato","nascere","nastrare","naturale","nautica","naviglio","nebulosa","necrosi","negativo","negozio","nemmeno","neofita","neretto","nervo","nessuno","nettuno","neutrale","neve","nevrotico","nicchia","ninfa","nitido","nobile","nocivo","nodo","nome","nomina","nordico","normale","norvegese","nostrano","notare","notizia","notturno","novella","nucleo","nulla","numero","nuovo","nutrire","nuvola","nuziale","oasi","obbedire","obbligo","obelisco","oblio","obolo","obsoleto","occasione","occhio","occidente","occorrere","occultare","ocra","oculato","odierno","odorare","offerta","offrire","offuscato","oggetto","oggi","ognuno","olandese","olfatto","oliato","oliva","ologramma","oltre","omaggio","ombelico","ombra","omega","omissione","ondoso","onere","onice","onnivoro","onorevole","onta","operato","opinione","opposto","oracolo","orafo","ordine","orecchino","orefice","orfano","organico","origine","orizzonte","orma","ormeggio","ornativo","orologio","orrendo","orribile","ortensia","ortica","orzata","orzo","osare","oscurare","osmosi","ospedale","ospite","ossa","ossidare","ostacolo","oste","otite","otre","ottagono","ottimo","ottobre","ovale","ovest","ovino","oviparo","ovocito","ovunque","ovviare","ozio","pacchetto","pace","pacifico","padella","padrone","paese","paga","pagina","palazzina","palesare","pallido","palo","palude","pandoro","pannello","paolo","paonazzo","paprica","parabola","parcella","parere","pargolo","pari","parlato","parola","partire","parvenza","parziale","passivo","pasticca","patacca","patologia","pattume","pavone","peccato","pedalare","pedonale","peggio","peloso","penare","pendice","penisola","pennuto","penombra","pensare","pentola","pepe","pepita","perbene","percorso","perdonato","perforare","pergamena","periodo","permesso","perno","perplesso","persuaso","pertugio","pervaso","pesatore","pesista","peso","pestifero","petalo","pettine","petulante","pezzo","piacere","pianta","piattino","piccino","picozza","piega","pietra","piffero","pigiama","pigolio","pigro","pila","pilifero","pillola","pilota","pimpante","pineta","pinna","pinolo","pioggia","piombo","piramide","piretico","pirite","pirolisi","pitone","pizzico","placebo","planare","plasma","platano","plenario","pochezza","poderoso","podismo","poesia","poggiare","polenta","poligono","pollice","polmonite","polpetta","polso","poltrona","polvere","pomice","pomodoro","ponte","popoloso","porfido","poroso","porpora","porre","portata","posa","positivo","possesso","postulato","potassio","potere","pranzo","prassi","pratica","precluso","predica","prefisso","pregiato","prelievo","premere","prenotare","preparato","presenza","pretesto","prevalso","prima","principe","privato","problema","procura","produrre","profumo","progetto","prolunga","promessa","pronome","proposta","proroga","proteso","prova","prudente","prugna","prurito","psiche","pubblico","pudica","pugilato","pugno","pulce","pulito","pulsante","puntare","pupazzo","pupilla","puro","quadro","qualcosa","quasi","querela","quota","raccolto","raddoppio","radicale","radunato","raffica","ragazzo","ragione","ragno","ramarro","ramingo","ramo","randagio","rantolare","rapato","rapina","rappreso","rasatura","raschiato","rasente","rassegna","rastrello","rata","ravveduto","reale","recepire","recinto","recluta","recondito","recupero","reddito","redimere","regalato","registro","regola","regresso","relazione","remare","remoto","renna","replica","reprimere","reputare","resa","residente","responso","restauro","rete","retina","retorica","rettifica","revocato","riassunto","ribadire","ribelle","ribrezzo","ricarica","ricco","ricevere","riciclato","ricordo","ricreduto","ridicolo","ridurre","rifasare","riflesso","riforma","rifugio","rigare","rigettato","righello","rilassato","rilevato","rimanere","rimbalzo","rimedio","rimorchio","rinascita","rincaro","rinforzo","rinnovo","rinomato","rinsavito","rintocco","rinuncia","rinvenire","riparato","ripetuto","ripieno","riportare","ripresa","ripulire","risata","rischio","riserva","risibile","riso","rispetto","ristoro","risultato","risvolto","ritardo","ritegno","ritmico","ritrovo","riunione","riva","riverso","rivincita","rivolto","rizoma","roba","robotico","robusto","roccia","roco","rodaggio","rodere","roditore","rogito","rollio","romantico","rompere","ronzio","rosolare","rospo","rotante","rotondo","rotula","rovescio","rubizzo","rubrica","ruga","rullino","rumine","rumoroso","ruolo","rupe","russare","rustico","sabato","sabbiare","sabotato","sagoma","salasso","saldatura","salgemma","salivare","salmone","salone","saltare","saluto","salvo","sapere","sapido","saporito","saraceno","sarcasmo","sarto","sassoso","satellite","satira","satollo","saturno","savana","savio","saziato","sbadiglio","sbalzo","sbancato","sbarra","sbattere","sbavare","sbendare","sbirciare","sbloccato","sbocciato","sbrinare","sbruffone","sbuffare","scabroso","scadenza","scala","scambiare","scandalo","scapola","scarso","scatenare","scavato","scelto","scenico","scettro","scheda","schiena","sciarpa","scienza","scindere","scippo","sciroppo","scivolo","sclerare","scodella","scolpito","scomparto","sconforto","scoprire","scorta","scossone","scozzese","scriba","scrollare","scrutinio","scuderia","scultore","scuola","scuro","scusare","sdebitare","sdoganare","seccatura","secondo","sedano","seggiola","segnalato","segregato","seguito","selciato","selettivo","sella","selvaggio","semaforo","sembrare","seme","seminato","sempre","senso","sentire","sepolto","sequenza","serata","serbato","sereno","serio","serpente","serraglio","servire","sestina","setola","settimana","sfacelo","sfaldare","sfamato","sfarzoso","sfaticato","sfera","sfida","sfilato","sfinge","sfocato","sfoderare","sfogo","sfoltire","sforzato","sfratto","sfruttato","sfuggito","sfumare","sfuso","sgabello","sgarbato","sgonfiare","sgorbio","sgrassato","sguardo","sibilo","siccome","sierra","sigla","signore","silenzio","sillaba","simbolo","simpatico","simulato","sinfonia","singolo","sinistro","sino","sintesi","sinusoide","sipario","sisma","sistole","situato","slitta","slogatura","sloveno","smarrito","smemorato","smentito","smeraldo","smilzo","smontare","smottato","smussato","snellire","snervato","snodo","sobbalzo","sobrio","soccorso","sociale","sodale","soffitto","sogno","soldato","solenne","solido","sollazzo","solo","solubile","solvente","somatico","somma","sonda","sonetto","sonnifero","sopire","soppeso","sopra","sorgere","sorpasso","sorriso","sorso","sorteggio","sorvolato","sospiro","sosta","sottile","spada","spalla","spargere","spatola","spavento","spazzola","specie","spedire","spegnere","spelatura","speranza","spessore","spettrale","spezzato","spia","spigoloso","spillato","spinoso","spirale","splendido","sportivo","sposo","spranga","sprecare","spronato","spruzzo","spuntino","squillo","sradicare","srotolato","stabile","stacco","staffa","stagnare","stampato","stantio","starnuto","stasera","statuto","stelo","steppa","sterzo","stiletto","stima","stirpe","stivale","stizzoso","stonato","storico","strappo","stregato","stridulo","strozzare","strutto","stuccare","stufo","stupendo","subentro","succoso","sudore","suggerito","sugo","sultano","suonare","superbo","supporto","surgelato","surrogato","sussurro","sutura","svagare","svedese","sveglio","svelare","svenuto","svezia","sviluppo","svista","svizzera","svolta","svuotare","tabacco","tabulato","tacciare","taciturno","tale","talismano","tampone","tannino","tara","tardivo","targato","tariffa","tarpare","tartaruga","tasto","tattico","taverna","tavolata","tazza","teca","tecnico","telefono","temerario","tempo","temuto","tendone","tenero","tensione","tentacolo","teorema","terme","terrazzo","terzetto","tesi","tesserato","testato","tetro","tettoia","tifare","tigella","timbro","tinto","tipico","tipografo","tiraggio","tiro","titanio","titolo","titubante","tizio","tizzone","toccare","tollerare","tolto","tombola","tomo","tonfo","tonsilla","topazio","topologia","toppa","torba","tornare","torrone","tortora","toscano","tossire","tostatura","totano","trabocco","trachea","trafila","tragedia","tralcio","tramonto","transito","trapano","trarre","trasloco","trattato","trave","treccia","tremolio","trespolo","tributo","tricheco","trifoglio","trillo","trincea","trio","tristezza","triturato","trivella","tromba","trono","troppo","trottola","trovare","truccato","tubatura","tuffato","tulipano","tumulto","tunisia","turbare","turchino","tuta","tutela","ubicato","uccello","uccisore","udire","uditivo","uffa","ufficio","uguale","ulisse","ultimato","umano","umile","umorismo","uncinetto","ungere","ungherese","unicorno","unificato","unisono","unitario","unte","uovo","upupa","uragano","urgenza","urlo","usanza","usato","uscito","usignolo","usuraio","utensile","utilizzo","utopia","vacante","vaccinato","vagabondo","vagliato","valanga","valgo","valico","valletta","valoroso","valutare","valvola","vampata","vangare","vanitoso","vano","vantaggio","vanvera","vapore","varano","varcato","variante","vasca","vedetta","vedova","veduto","vegetale","veicolo","velcro","velina","velluto","veloce","venato","vendemmia","vento","verace","verbale","vergogna","verifica","vero","verruca","verticale","vescica","vessillo","vestale","veterano","vetrina","vetusto","viandante","vibrante","vicenda","vichingo","vicinanza","vidimare","vigilia","vigneto","vigore","vile","villano","vimini","vincitore","viola","vipera","virgola","virologo","virulento","viscoso","visione","vispo","vissuto","visura","vita","vitello","vittima","vivanda","vivido","viziare","voce","voga","volatile","volere","volpe","voragine","vulcano","zampogna","zanna","zappato","zattera","zavorra","zefiro","zelante","zelo","zenzero","zerbino","zibetto","zinco","zircone","zitto","zolla","zotico","zucchero","zufolo","zulu","zuppa"]');
const require$$6 = /* @__PURE__ */ JSON.parse('["abaco","abdomen","abeja","abierto","abogado","abono","aborto","abrazo","abrir","abuelo","abuso","acabar","academia","acceso","accion","aceite","acelga","acento","aceptar","acido","aclarar","acne","acoger","acoso","activo","acto","actriz","actuar","acudir","acuerdo","acusar","adicto","admitir","adoptar","adorno","aduana","adulto","aereo","afectar","aficion","afinar","afirmar","agil","agitar","agonia","agosto","agotar","agregar","agrio","agua","agudo","aguila","aguja","ahogo","ahorro","aire","aislar","ajedrez","ajeno","ajuste","alacran","alambre","alarma","alba","album","alcalde","aldea","alegre","alejar","alerta","aleta","alfiler","alga","algodon","aliado","aliento","alivio","alma","almeja","almibar","altar","alteza","altivo","alto","altura","alumno","alzar","amable","amante","amapola","amargo","amasar","ambar","ambito","ameno","amigo","amistad","amor","amparo","amplio","ancho","anciano","ancla","andar","anden","anemia","angulo","anillo","animo","anis","anotar","antena","antiguo","antojo","anual","anular","anuncio","anadir","anejo","ano","apagar","aparato","apetito","apio","aplicar","apodo","aporte","apoyo","aprender","aprobar","apuesta","apuro","arado","arana","arar","arbitro","arbol","arbusto","archivo","arco","arder","ardilla","arduo","area","arido","aries","armonia","arnes","aroma","arpa","arpon","arreglo","arroz","arruga","arte","artista","asa","asado","asalto","ascenso","asegurar","aseo","asesor","asiento","asilo","asistir","asno","asombro","aspero","astilla","astro","astuto","asumir","asunto","atajo","ataque","atar","atento","ateo","atico","atleta","atomo","atraer","atroz","atun","audaz","audio","auge","aula","aumento","ausente","autor","aval","avance","avaro","ave","avellana","avena","avestruz","avion","aviso","ayer","ayuda","ayuno","azafran","azar","azote","azucar","azufre","azul","baba","babor","bache","bahia","baile","bajar","balanza","balcon","balde","bambu","banco","banda","bano","barba","barco","barniz","barro","bascula","baston","basura","batalla","bateria","batir","batuta","baul","bazar","bebe","bebida","bello","besar","beso","bestia","bicho","bien","bingo","blanco","bloque","blusa","boa","bobina","bobo","boca","bocina","boda","bodega","boina","bola","bolero","bolsa","bomba","bondad","bonito","bono","bonsai","borde","borrar","bosque","bote","botin","boveda","bozal","bravo","brazo","brecha","breve","brillo","brinco","brisa","broca","broma","bronce","brote","bruja","brusco","bruto","buceo","bucle","bueno","buey","bufanda","bufon","buho","buitre","bulto","burbuja","burla","burro","buscar","butaca","buzon","caballo","cabeza","cabina","cabra","cacao","cadaver","cadena","caer","cafe","caida","caiman","caja","cajon","cal","calamar","calcio","caldo","calidad","calle","calma","calor","calvo","cama","cambio","camello","camino","campo","cancer","candil","canela","canguro","canica","canto","cana","canon","caoba","caos","capaz","capitan","capote","captar","capucha","cara","carbon","carcel","careta","carga","carino","carne","carpeta","carro","carta","casa","casco","casero","caspa","castor","catorce","catre","caudal","causa","cazo","cebolla","ceder","cedro","celda","celebre","celoso","celula","cemento","ceniza","centro","cerca","cerdo","cereza","cero","cerrar","certeza","cesped","cetro","chacal","chaleco","champu","chancla","chapa","charla","chico","chiste","chivo","choque","choza","chuleta","chupar","ciclon","ciego","cielo","cien","cierto","cifra","cigarro","cima","cinco","cine","cinta","cipres","circo","ciruela","cisne","cita","ciudad","clamor","clan","claro","clase","clave","cliente","clima","clinica","cobre","coccion","cochino","cocina","coco","codigo","codo","cofre","coger","cohete","cojin","cojo","cola","colcha","colegio","colgar","colina","collar","colmo","columna","combate","comer","comida","comodo","compra","conde","conejo","conga","conocer","consejo","contar","copa","copia","corazon","corbata","corcho","cordon","corona","correr","coser","cosmos","costa","craneo","crater","crear","crecer","creido","crema","cria","crimen","cripta","crisis","cromo","cronica","croqueta","crudo","cruz","cuadro","cuarto","cuatro","cubo","cubrir","cuchara","cuello","cuento","cuerda","cuesta","cueva","cuidar","culebra","culpa","culto","cumbre","cumplir","cuna","cuneta","cuota","cupon","cupula","curar","curioso","curso","curva","cutis","dama","danza","dar","dardo","datil","deber","debil","decada","decir","dedo","defensa","definir","dejar","delfin","delgado","delito","demora","denso","dental","deporte","derecho","derrota","desayuno","deseo","desfile","desnudo","destino","desvio","detalle","detener","deuda","dia","diablo","diadema","diamante","diana","diario","dibujo","dictar","diente","dieta","diez","dificil","digno","dilema","diluir","dinero","directo","dirigir","disco","diseno","disfraz","diva","divino","doble","doce","dolor","domingo","don","donar","dorado","dormir","dorso","dos","dosis","dragon","droga","ducha","duda","duelo","dueno","dulce","duo","duque","durar","dureza","duro","ebano","ebrio","echar","eco","ecuador","edad","edicion","edificio","editor","educar","efecto","eficaz","eje","ejemplo","elefante","elegir","elemento","elevar","elipse","elite","elixir","elogio","eludir","embudo","emitir","emocion","empate","empeno","empleo","empresa","enano","encargo","enchufe","encia","enemigo","enero","enfado","enfermo","engano","enigma","enlace","enorme","enredo","ensayo","ensenar","entero","entrar","envase","envio","epoca","equipo","erizo","escala","escena","escolar","escribir","escudo","esencia","esfera","esfuerzo","espada","espejo","espia","esposa","espuma","esqui","estar","este","estilo","estufa","etapa","eterno","etica","etnia","evadir","evaluar","evento","evitar","exacto","examen","exceso","excusa","exento","exigir","exilio","existir","exito","experto","explicar","exponer","extremo","fabrica","fabula","fachada","facil","factor","faena","faja","falda","fallo","falso","faltar","fama","familia","famoso","faraon","farmacia","farol","farsa","fase","fatiga","fauna","favor","fax","febrero","fecha","feliz","feo","feria","feroz","fertil","fervor","festin","fiable","fianza","fiar","fibra","ficcion","ficha","fideo","fiebre","fiel","fiera","fiesta","figura","fijar","fijo","fila","filete","filial","filtro","fin","finca","fingir","finito","firma","flaco","flauta","flecha","flor","flota","fluir","flujo","fluor","fobia","foca","fogata","fogon","folio","folleto","fondo","forma","forro","fortuna","forzar","fosa","foto","fracaso","fragil","franja","frase","fraude","freir","freno","fresa","frio","frito","fruta","fuego","fuente","fuerza","fuga","fumar","funcion","funda","furgon","furia","fusil","futbol","futuro","gacela","gafas","gaita","gajo","gala","galeria","gallo","gamba","ganar","gancho","ganga","ganso","garaje","garza","gasolina","gastar","gato","gavilan","gemelo","gemir","gen","genero","genio","gente","geranio","gerente","germen","gesto","gigante","gimnasio","girar","giro","glaciar","globo","gloria","gol","golfo","goloso","golpe","goma","gordo","gorila","gorra","gota","goteo","gozar","grada","grafico","grano","grasa","gratis","grave","grieta","grillo","gripe","gris","grito","grosor","grua","grueso","grumo","grupo","guante","guapo","guardia","guerra","guia","guino","guion","guiso","guitarra","gusano","gustar","haber","habil","hablar","hacer","hacha","hada","hallar","hamaca","harina","haz","hazana","hebilla","hebra","hecho","helado","helio","hembra","herir","hermano","heroe","hervir","hielo","hierro","higado","higiene","hijo","himno","historia","hocico","hogar","hoguera","hoja","hombre","hongo","honor","honra","hora","hormiga","horno","hostil","hoyo","hueco","huelga","huerta","hueso","huevo","huida","huir","humano","humedo","humilde","humo","hundir","huracan","hurto","icono","ideal","idioma","idolo","iglesia","iglu","igual","ilegal","ilusion","imagen","iman","imitar","impar","imperio","imponer","impulso","incapaz","indice","inerte","infiel","informe","ingenio","inicio","inmenso","inmune","innato","insecto","instante","interes","intimo","intuir","inutil","invierno","ira","iris","ironia","isla","islote","jabali","jabon","jamon","jarabe","jardin","jarra","jaula","jazmin","jefe","jeringa","jinete","jornada","joroba","joven","joya","juerga","jueves","juez","jugador","jugo","juguete","juicio","junco","jungla","junio","juntar","jupiter","jurar","justo","juvenil","juzgar","kilo","koala","labio","lacio","lacra","lado","ladron","lagarto","lagrima","laguna","laico","lamer","lamina","lampara","lana","lancha","langosta","lanza","lapiz","largo","larva","lastima","lata","latex","latir","laurel","lavar","lazo","leal","leccion","leche","lector","leer","legion","legumbre","lejano","lengua","lento","lena","leon","leopardo","lesion","letal","letra","leve","leyenda","libertad","libro","licor","lider","lidiar","lienzo","liga","ligero","lima","limite","limon","limpio","lince","lindo","linea","lingote","lino","linterna","liquido","liso","lista","litera","litio","litro","llaga","llama","llanto","llave","llegar","llenar","llevar","llorar","llover","lluvia","lobo","locion","loco","locura","logica","logro","lombriz","lomo","lonja","lote","lucha","lucir","lugar","lujo","luna","lunes","lupa","lustro","luto","luz","maceta","macho","madera","madre","maduro","maestro","mafia","magia","mago","maiz","maldad","maleta","malla","malo","mama","mambo","mamut","manco","mando","manejar","manga","maniqui","manjar","mano","manso","manta","manana","mapa","maquina","mar","marco","marea","marfil","margen","marido","marmol","marron","martes","marzo","masa","mascara","masivo","matar","materia","matiz","matriz","maximo","mayor","mazorca","mecha","medalla","medio","medula","mejilla","mejor","melena","melon","memoria","menor","mensaje","mente","menu","mercado","merengue","merito","mes","meson","meta","meter","metodo","metro","mezcla","miedo","miel","miembro","miga","mil","milagro","militar","millon","mimo","mina","minero","minimo","minuto","miope","mirar","misa","miseria","misil","mismo","mitad","mito","mochila","mocion","moda","modelo","moho","mojar","molde","moler","molino","momento","momia","monarca","moneda","monja","monto","mono","morada","morder","moreno","morir","morro","morsa","mortal","mosca","mostrar","motivo","mover","movil","mozo","mucho","mudar","mueble","muela","muerte","muestra","mugre","mujer","mula","muleta","multa","mundo","muneca","mural","muro","musculo","museo","musgo","musica","muslo","nacar","nacion","nadar","naipe","naranja","nariz","narrar","nasal","natal","nativo","natural","nausea","naval","nave","navidad","necio","nectar","negar","negocio","negro","neon","nervio","neto","neutro","nevar","nevera","nicho","nido","niebla","nieto","ninez","nino","nitido","nivel","nobleza","noche","nomina","noria","norma","norte","nota","noticia","novato","novela","novio","nube","nuca","nucleo","nudillo","nudo","nuera","nueve","nuez","nulo","numero","nutria","oasis","obeso","obispo","objeto","obra","obrero","observar","obtener","obvio","oca","ocaso","oceano","ochenta","ocho","ocio","ocre","octavo","octubre","oculto","ocupar","ocurrir","odiar","odio","odisea","oeste","ofensa","oferta","oficio","ofrecer","ogro","oido","oir","ojo","ola","oleada","olfato","olivo","olla","olmo","olor","olvido","ombligo","onda","onza","opaco","opcion","opera","opinar","oponer","optar","optica","opuesto","oracion","orador","oral","orbita","orca","orden","oreja","organo","orgia","orgullo","oriente","origen","orilla","oro","orquesta","oruga","osadia","oscuro","osezno","oso","ostra","otono","otro","oveja","ovulo","oxido","oxigeno","oyente","ozono","pacto","padre","paella","pagina","pago","pais","pajaro","palabra","palco","paleta","palido","palma","paloma","palpar","pan","panal","panico","pantera","panuelo","papa","papel","papilla","paquete","parar","parcela","pared","parir","paro","parpado","parque","parrafo","parte","pasar","paseo","pasion","paso","pasta","pata","patio","patria","pausa","pauta","pavo","payaso","peaton","pecado","pecera","pecho","pedal","pedir","pegar","peine","pelar","peldano","pelea","peligro","pellejo","pelo","peluca","pena","pensar","penon","peon","peor","pepino","pequeno","pera","percha","perder","pereza","perfil","perico","perla","permiso","perro","persona","pesa","pesca","pesimo","pestana","petalo","petroleo","pez","pezuna","picar","pichon","pie","piedra","pierna","pieza","pijama","pilar","piloto","pimienta","pino","pintor","pinza","pina","piojo","pipa","pirata","pisar","piscina","piso","pista","piton","pizca","placa","plan","plata","playa","plaza","pleito","pleno","plomo","pluma","plural","pobre","poco","poder","podio","poema","poesia","poeta","polen","policia","pollo","polvo","pomada","pomelo","pomo","pompa","poner","porcion","portal","posada","poseer","posible","poste","potencia","potro","pozo","prado","precoz","pregunta","premio","prensa","preso","previo","primo","principe","prision","privar","proa","probar","proceso","producto","proeza","profesor","programa","prole","promesa","pronto","propio","proximo","prueba","publico","puchero","pudor","pueblo","puerta","puesto","pulga","pulir","pulmon","pulpo","pulso","puma","punto","punal","puno","pupa","pupila","pure","quedar","queja","quemar","querer","queso","quieto","quimica","quince","quitar","rabano","rabia","rabo","racion","radical","raiz","rama","rampa","rancho","rango","rapaz","rapido","rapto","rasgo","raspa","rato","rayo","raza","razon","reaccion","realidad","rebano","rebote","recaer","receta","rechazo","recoger","recreo","recto","recurso","red","redondo","reducir","reflejo","reforma","refran","refugio","regalo","regir","regla","regreso","rehen","reino","reir","reja","relato","relevo","relieve","relleno","reloj","remar","remedio","remo","rencor","rendir","renta","reparto","repetir","reposo","reptil","res","rescate","resina","respeto","resto","resumen","retiro","retorno","retrato","reunir","reves","revista","rey","rezar","rico","riego","rienda","riesgo","rifa","rigido","rigor","rincon","rinon","rio","riqueza","risa","ritmo","rito","rizo","roble","roce","rociar","rodar","rodeo","rodilla","roer","rojizo","rojo","romero","romper","ron","ronco","ronda","ropa","ropero","rosa","rosca","rostro","rotar","rubi","rubor","rudo","rueda","rugir","ruido","ruina","ruleta","rulo","rumbo","rumor","ruptura","ruta","rutina","sabado","saber","sabio","sable","sacar","sagaz","sagrado","sala","saldo","salero","salir","salmon","salon","salsa","salto","salud","salvar","samba","sancion","sandia","sanear","sangre","sanidad","sano","santo","sapo","saque","sardina","sarten","sastre","satan","sauna","saxofon","seccion","seco","secreto","secta","sed","seguir","seis","sello","selva","semana","semilla","senda","sensor","senal","senor","separar","sepia","sequia","ser","serie","sermon","servir","sesenta","sesion","seta","setenta","severo","sexo","sexto","sidra","siesta","siete","siglo","signo","silaba","silbar","silencio","silla","simbolo","simio","sirena","sistema","sitio","situar","sobre","socio","sodio","sol","solapa","soldado","soledad","solido","soltar","solucion","sombra","sondeo","sonido","sonoro","sonrisa","sopa","soplar","soporte","sordo","sorpresa","sorteo","sosten","sotano","suave","subir","suceso","sudor","suegra","suelo","sueno","suerte","sufrir","sujeto","sultan","sumar","superar","suplir","suponer","supremo","sur","surco","sureno","surgir","susto","sutil","tabaco","tabique","tabla","tabu","taco","tacto","tajo","talar","talco","talento","talla","talon","tamano","tambor","tango","tanque","tapa","tapete","tapia","tapon","taquilla","tarde","tarea","tarifa","tarjeta","tarot","tarro","tarta","tatuaje","tauro","taza","tazon","teatro","techo","tecla","tecnica","tejado","tejer","tejido","tela","telefono","tema","temor","templo","tenaz","tender","tener","tenis","tenso","teoria","terapia","terco","termino","ternura","terror","tesis","tesoro","testigo","tetera","texto","tez","tibio","tiburon","tiempo","tienda","tierra","tieso","tigre","tijera","tilde","timbre","timido","timo","tinta","tio","tipico","tipo","tira","tiron","titan","titere","titulo","tiza","toalla","tobillo","tocar","tocino","todo","toga","toldo","tomar","tono","tonto","topar","tope","toque","torax","torero","tormenta","torneo","toro","torpedo","torre","torso","tortuga","tos","tosco","toser","toxico","trabajo","tractor","traer","trafico","trago","traje","tramo","trance","trato","trauma","trazar","trebol","tregua","treinta","tren","trepar","tres","tribu","trigo","tripa","triste","triunfo","trofeo","trompa","tronco","tropa","trote","trozo","truco","trueno","trufa","tuberia","tubo","tuerto","tumba","tumor","tunel","tunica","turbina","turismo","turno","tutor","ubicar","ulcera","umbral","unidad","unir","universo","uno","untar","una","urbano","urbe","urgente","urna","usar","usuario","util","utopia","uva","vaca","vacio","vacuna","vagar","vago","vaina","vajilla","vale","valido","valle","valor","valvula","vampiro","vara","variar","varon","vaso","vecino","vector","vehiculo","veinte","vejez","vela","velero","veloz","vena","vencer","venda","veneno","vengar","venir","venta","venus","ver","verano","verbo","verde","vereda","verja","verso","verter","via","viaje","vibrar","vicio","victima","vida","video","vidrio","viejo","viernes","vigor","vil","villa","vinagre","vino","vinedo","violin","viral","virgo","virtud","visor","vispera","vista","vitamina","viudo","vivaz","vivero","vivir","vivo","volcan","volumen","volver","voraz","votar","voto","voz","vuelo","vulgar","yacer","yate","yegua","yema","yerno","yeso","yodo","yoga","yogur","zafiro","zanja","zapato","zarza","zona","zorro","zumo","zurdo"]');
const require$$7 = /* @__PURE__ */ JSON.parse('["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""]');
const require$$8 = /* @__PURE__ */ JSON.parse('["abacate","abaixo","abalar","abater","abduzir","abelha","aberto","abismo","abotoar","abranger","abreviar","abrigar","abrupto","absinto","absoluto","absurdo","abutre","acabado","acalmar","acampar","acanhar","acaso","aceitar","acelerar","acenar","acervo","acessar","acetona","achatar","acidez","acima","acionado","acirrar","aclamar","aclive","acolhida","acomodar","acoplar","acordar","acumular","acusador","adaptar","adega","adentro","adepto","adequar","aderente","adesivo","adeus","adiante","aditivo","adjetivo","adjunto","admirar","adorar","adquirir","adubo","adverso","advogado","aeronave","afastar","aferir","afetivo","afinador","afivelar","aflito","afluente","afrontar","agachar","agarrar","agasalho","agenciar","agilizar","agiota","agitado","agora","agradar","agreste","agrupar","aguardar","agulha","ajoelhar","ajudar","ajustar","alameda","alarme","alastrar","alavanca","albergue","albino","alcatra","aldeia","alecrim","alegria","alertar","alface","alfinete","algum","alheio","aliar","alicate","alienar","alinhar","aliviar","almofada","alocar","alpiste","alterar","altitude","alucinar","alugar","aluno","alusivo","alvo","amaciar","amador","amarelo","amassar","ambas","ambiente","ameixa","amenizar","amido","amistoso","amizade","amolador","amontoar","amoroso","amostra","amparar","ampliar","ampola","anagrama","analisar","anarquia","anatomia","andaime","anel","anexo","angular","animar","anjo","anomalia","anotado","ansioso","anterior","anuidade","anunciar","anzol","apagador","apalpar","apanhado","apego","apelido","apertada","apesar","apetite","apito","aplauso","aplicada","apoio","apontar","aposta","aprendiz","aprovar","aquecer","arame","aranha","arara","arcada","ardente","areia","arejar","arenito","aresta","argiloso","argola","arma","arquivo","arraial","arrebate","arriscar","arroba","arrumar","arsenal","arterial","artigo","arvoredo","asfaltar","asilado","aspirar","assador","assinar","assoalho","assunto","astral","atacado","atadura","atalho","atarefar","atear","atender","aterro","ateu","atingir","atirador","ativo","atoleiro","atracar","atrevido","atriz","atual","atum","auditor","aumentar","aura","aurora","autismo","autoria","autuar","avaliar","avante","avaria","avental","avesso","aviador","avisar","avulso","axila","azarar","azedo","azeite","azulejo","babar","babosa","bacalhau","bacharel","bacia","bagagem","baiano","bailar","baioneta","bairro","baixista","bajular","baleia","baliza","balsa","banal","bandeira","banho","banir","banquete","barato","barbado","baronesa","barraca","barulho","baseado","bastante","batata","batedor","batida","batom","batucar","baunilha","beber","beijo","beirada","beisebol","beldade","beleza","belga","beliscar","bendito","bengala","benzer","berimbau","berlinda","berro","besouro","bexiga","bezerro","bico","bicudo","bienal","bifocal","bifurcar","bigorna","bilhete","bimestre","bimotor","biologia","biombo","biosfera","bipolar","birrento","biscoito","bisneto","bispo","bissexto","bitola","bizarro","blindado","bloco","bloquear","boato","bobagem","bocado","bocejo","bochecha","boicotar","bolada","boletim","bolha","bolo","bombeiro","bonde","boneco","bonita","borbulha","borda","boreal","borracha","bovino","boxeador","branco","brasa","braveza","breu","briga","brilho","brincar","broa","brochura","bronzear","broto","bruxo","bucha","budismo","bufar","bule","buraco","busca","busto","buzina","cabana","cabelo","cabide","cabo","cabrito","cacau","cacetada","cachorro","cacique","cadastro","cadeado","cafezal","caiaque","caipira","caixote","cajado","caju","calafrio","calcular","caldeira","calibrar","calmante","calota","camada","cambista","camisa","camomila","campanha","camuflar","canavial","cancelar","caneta","canguru","canhoto","canivete","canoa","cansado","cantar","canudo","capacho","capela","capinar","capotar","capricho","captador","capuz","caracol","carbono","cardeal","careca","carimbar","carneiro","carpete","carreira","cartaz","carvalho","casaco","casca","casebre","castelo","casulo","catarata","cativar","caule","causador","cautelar","cavalo","caverna","cebola","cedilha","cegonha","celebrar","celular","cenoura","censo","centeio","cercar","cerrado","certeiro","cerveja","cetim","cevada","chacota","chaleira","chamado","chapada","charme","chatice","chave","chefe","chegada","cheiro","cheque","chicote","chifre","chinelo","chocalho","chover","chumbo","chutar","chuva","cicatriz","ciclone","cidade","cidreira","ciente","cigana","cimento","cinto","cinza","ciranda","circuito","cirurgia","citar","clareza","clero","clicar","clone","clube","coado","coagir","cobaia","cobertor","cobrar","cocada","coelho","coentro","coeso","cogumelo","coibir","coifa","coiote","colar","coleira","colher","colidir","colmeia","colono","coluna","comando","combinar","comentar","comitiva","comover","complexo","comum","concha","condor","conectar","confuso","congelar","conhecer","conjugar","consumir","contrato","convite","cooperar","copeiro","copiador","copo","coquetel","coragem","cordial","corneta","coronha","corporal","correio","cortejo","coruja","corvo","cosseno","costela","cotonete","couro","couve","covil","cozinha","cratera","cravo","creche","credor","creme","crer","crespo","criada","criminal","crioulo","crise","criticar","crosta","crua","cruzeiro","cubano","cueca","cuidado","cujo","culatra","culminar","culpar","cultura","cumprir","cunhado","cupido","curativo","curral","cursar","curto","cuspir","custear","cutelo","damasco","datar","debater","debitar","deboche","debulhar","decalque","decimal","declive","decote","decretar","dedal","dedicado","deduzir","defesa","defumar","degelo","degrau","degustar","deitado","deixar","delator","delegado","delinear","delonga","demanda","demitir","demolido","dentista","depenado","depilar","depois","depressa","depurar","deriva","derramar","desafio","desbotar","descanso","desenho","desfiado","desgaste","desigual","deslize","desmamar","desova","despesa","destaque","desviar","detalhar","detentor","detonar","detrito","deusa","dever","devido","devotado","dezena","diagrama","dialeto","didata","difuso","digitar","dilatado","diluente","diminuir","dinastia","dinheiro","diocese","direto","discreta","disfarce","disparo","disquete","dissipar","distante","ditador","diurno","diverso","divisor","divulgar","dizer","dobrador","dolorido","domador","dominado","donativo","donzela","dormente","dorsal","dosagem","dourado","doutor","drenagem","drible","drogaria","duelar","duende","dueto","duplo","duquesa","durante","duvidoso","eclodir","ecoar","ecologia","edificar","edital","educado","efeito","efetivar","ejetar","elaborar","eleger","eleitor","elenco","elevador","eliminar","elogiar","embargo","embolado","embrulho","embutido","emenda","emergir","emissor","empatia","empenho","empinado","empolgar","emprego","empurrar","emulador","encaixe","encenado","enchente","encontro","endeusar","endossar","enfaixar","enfeite","enfim","engajado","engenho","englobar","engomado","engraxar","enguia","enjoar","enlatar","enquanto","enraizar","enrolado","enrugar","ensaio","enseada","ensino","ensopado","entanto","enteado","entidade","entortar","entrada","entulho","envergar","enviado","envolver","enxame","enxerto","enxofre","enxuto","epiderme","equipar","ereto","erguido","errata","erva","ervilha","esbanjar","esbelto","escama","escola","escrita","escuta","esfinge","esfolar","esfregar","esfumado","esgrima","esmalte","espanto","espelho","espiga","esponja","espreita","espumar","esquerda","estaca","esteira","esticar","estofado","estrela","estudo","esvaziar","etanol","etiqueta","euforia","europeu","evacuar","evaporar","evasivo","eventual","evidente","evoluir","exagero","exalar","examinar","exato","exausto","excesso","excitar","exclamar","executar","exemplo","exibir","exigente","exonerar","expandir","expelir","expirar","explanar","exposto","expresso","expulsar","externo","extinto","extrato","fabricar","fabuloso","faceta","facial","fada","fadiga","faixa","falar","falta","familiar","fandango","fanfarra","fantoche","fardado","farelo","farinha","farofa","farpa","fartura","fatia","fator","favorita","faxina","fazenda","fechado","feijoada","feirante","felino","feminino","fenda","feno","fera","feriado","ferrugem","ferver","festejar","fetal","feudal","fiapo","fibrose","ficar","ficheiro","figurado","fileira","filho","filme","filtrar","firmeza","fisgada","fissura","fita","fivela","fixador","fixo","flacidez","flamingo","flanela","flechada","flora","flutuar","fluxo","focal","focinho","fofocar","fogo","foguete","foice","folgado","folheto","forjar","formiga","forno","forte","fosco","fossa","fragata","fralda","frango","frasco","fraterno","freira","frente","fretar","frieza","friso","fritura","fronha","frustrar","fruteira","fugir","fulano","fuligem","fundar","fungo","funil","furador","furioso","futebol","gabarito","gabinete","gado","gaiato","gaiola","gaivota","galega","galho","galinha","galocha","ganhar","garagem","garfo","gargalo","garimpo","garoupa","garrafa","gasoduto","gasto","gata","gatilho","gaveta","gazela","gelado","geleia","gelo","gemada","gemer","gemido","generoso","gengiva","genial","genoma","genro","geologia","gerador","germinar","gesso","gestor","ginasta","gincana","gingado","girafa","girino","glacial","glicose","global","glorioso","goela","goiaba","golfe","golpear","gordura","gorjeta","gorro","gostoso","goteira","governar","gracejo","gradual","grafite","gralha","grampo","granada","gratuito","graveto","graxa","grego","grelhar","greve","grilo","grisalho","gritaria","grosso","grotesco","grudado","grunhido","gruta","guache","guarani","guaxinim","guerrear","guiar","guincho","guisado","gula","guloso","guru","habitar","harmonia","haste","haver","hectare","herdar","heresia","hesitar","hiato","hibernar","hidratar","hiena","hino","hipismo","hipnose","hipoteca","hoje","holofote","homem","honesto","honrado","hormonal","hospedar","humorado","iate","ideia","idoso","ignorado","igreja","iguana","ileso","ilha","iludido","iluminar","ilustrar","imagem","imediato","imenso","imersivo","iminente","imitador","imortal","impacto","impedir","implante","impor","imprensa","impune","imunizar","inalador","inapto","inativo","incenso","inchar","incidir","incluir","incolor","indeciso","indireto","indutor","ineficaz","inerente","infantil","infestar","infinito","inflamar","informal","infrator","ingerir","inibido","inicial","inimigo","injetar","inocente","inodoro","inovador","inox","inquieto","inscrito","inseto","insistir","inspetor","instalar","insulto","intacto","integral","intimar","intocado","intriga","invasor","inverno","invicto","invocar","iogurte","iraniano","ironizar","irreal","irritado","isca","isento","isolado","isqueiro","italiano","janeiro","jangada","janta","jararaca","jardim","jarro","jasmim","jato","javali","jazida","jejum","joaninha","joelhada","jogador","joia","jornal","jorrar","jovem","juba","judeu","judoca","juiz","julgador","julho","jurado","jurista","juro","justa","labareda","laboral","lacre","lactante","ladrilho","lagarta","lagoa","laje","lamber","lamentar","laminar","lampejo","lanche","lapidar","lapso","laranja","lareira","largura","lasanha","lastro","lateral","latido","lavanda","lavoura","lavrador","laxante","lazer","lealdade","lebre","legado","legendar","legista","leigo","leiloar","leitura","lembrete","leme","lenhador","lentilha","leoa","lesma","leste","letivo","letreiro","levar","leveza","levitar","liberal","libido","liderar","ligar","ligeiro","limitar","limoeiro","limpador","linda","linear","linhagem","liquidez","listagem","lisura","litoral","livro","lixa","lixeira","locador","locutor","lojista","lombo","lona","longe","lontra","lorde","lotado","loteria","loucura","lousa","louvar","luar","lucidez","lucro","luneta","lustre","lutador","luva","macaco","macete","machado","macio","madeira","madrinha","magnata","magreza","maior","mais","malandro","malha","malote","maluco","mamilo","mamoeiro","mamute","manada","mancha","mandato","manequim","manhoso","manivela","manobrar","mansa","manter","manusear","mapeado","maquinar","marcador","maresia","marfim","margem","marinho","marmita","maroto","marquise","marreco","martelo","marujo","mascote","masmorra","massagem","mastigar","matagal","materno","matinal","matutar","maxilar","medalha","medida","medusa","megafone","meiga","melancia","melhor","membro","memorial","menino","menos","mensagem","mental","merecer","mergulho","mesada","mesclar","mesmo","mesquita","mestre","metade","meteoro","metragem","mexer","mexicano","micro","migalha","migrar","milagre","milenar","milhar","mimado","minerar","minhoca","ministro","minoria","miolo","mirante","mirtilo","misturar","mocidade","moderno","modular","moeda","moer","moinho","moita","moldura","moleza","molho","molinete","molusco","montanha","moqueca","morango","morcego","mordomo","morena","mosaico","mosquete","mostarda","motel","motim","moto","motriz","muda","muito","mulata","mulher","multar","mundial","munido","muralha","murcho","muscular","museu","musical","nacional","nadador","naja","namoro","narina","narrado","nascer","nativa","natureza","navalha","navegar","navio","neblina","nebuloso","negativa","negociar","negrito","nervoso","neta","neural","nevasca","nevoeiro","ninar","ninho","nitidez","nivelar","nobreza","noite","noiva","nomear","nominal","nordeste","nortear","notar","noticiar","noturno","novelo","novilho","novo","nublado","nudez","numeral","nupcial","nutrir","nuvem","obcecado","obedecer","objetivo","obrigado","obscuro","obstetra","obter","obturar","ocidente","ocioso","ocorrer","oculista","ocupado","ofegante","ofensiva","oferenda","oficina","ofuscado","ogiva","olaria","oleoso","olhar","oliveira","ombro","omelete","omisso","omitir","ondulado","oneroso","ontem","opcional","operador","oponente","oportuno","oposto","orar","orbitar","ordem","ordinal","orfanato","orgasmo","orgulho","oriental","origem","oriundo","orla","ortodoxo","orvalho","oscilar","ossada","osso","ostentar","otimismo","ousadia","outono","outubro","ouvido","ovelha","ovular","oxidar","oxigenar","pacato","paciente","pacote","pactuar","padaria","padrinho","pagar","pagode","painel","pairar","paisagem","palavra","palestra","palheta","palito","palmada","palpitar","pancada","panela","panfleto","panqueca","pantanal","papagaio","papelada","papiro","parafina","parcial","pardal","parede","partida","pasmo","passado","pastel","patamar","patente","patinar","patrono","paulada","pausar","peculiar","pedalar","pedestre","pediatra","pedra","pegada","peitoral","peixe","pele","pelicano","penca","pendurar","peneira","penhasco","pensador","pente","perceber","perfeito","pergunta","perito","permitir","perna","perplexo","persiana","pertence","peruca","pescado","pesquisa","pessoa","petiscar","piada","picado","piedade","pigmento","pilastra","pilhado","pilotar","pimenta","pincel","pinguim","pinha","pinote","pintar","pioneiro","pipoca","piquete","piranha","pires","pirueta","piscar","pistola","pitanga","pivete","planta","plaqueta","platina","plebeu","plumagem","pluvial","pneu","poda","poeira","poetisa","polegada","policiar","poluente","polvilho","pomar","pomba","ponderar","pontaria","populoso","porta","possuir","postal","pote","poupar","pouso","povoar","praia","prancha","prato","praxe","prece","predador","prefeito","premiar","prensar","preparar","presilha","pretexto","prevenir","prezar","primata","princesa","prisma","privado","processo","produto","profeta","proibido","projeto","prometer","propagar","prosa","protetor","provador","publicar","pudim","pular","pulmonar","pulseira","punhal","punir","pupilo","pureza","puxador","quadra","quantia","quarto","quase","quebrar","queda","queijo","quente","querido","quimono","quina","quiosque","rabanada","rabisco","rachar","racionar","radial","raiar","rainha","raio","raiva","rajada","ralado","ramal","ranger","ranhura","rapadura","rapel","rapidez","raposa","raquete","raridade","rasante","rascunho","rasgar","raspador","rasteira","rasurar","ratazana","ratoeira","realeza","reanimar","reaver","rebaixar","rebelde","rebolar","recado","recente","recheio","recibo","recordar","recrutar","recuar","rede","redimir","redonda","reduzida","reenvio","refinar","refletir","refogar","refresco","refugiar","regalia","regime","regra","reinado","reitor","rejeitar","relativo","remador","remendo","remorso","renovado","reparo","repelir","repleto","repolho","represa","repudiar","requerer","resenha","resfriar","resgatar","residir","resolver","respeito","ressaca","restante","resumir","retalho","reter","retirar","retomada","retratar","revelar","revisor","revolta","riacho","rica","rigidez","rigoroso","rimar","ringue","risada","risco","risonho","robalo","rochedo","rodada","rodeio","rodovia","roedor","roleta","romano","roncar","rosado","roseira","rosto","rota","roteiro","rotina","rotular","rouco","roupa","roxo","rubro","rugido","rugoso","ruivo","rumo","rupestre","russo","sabor","saciar","sacola","sacudir","sadio","safira","saga","sagrada","saibro","salada","saleiro","salgado","saliva","salpicar","salsicha","saltar","salvador","sambar","samurai","sanar","sanfona","sangue","sanidade","sapato","sarda","sargento","sarjeta","saturar","saudade","saxofone","sazonal","secar","secular","seda","sedento","sediado","sedoso","sedutor","segmento","segredo","segundo","seiva","seleto","selvagem","semanal","semente","senador","senhor","sensual","sentado","separado","sereia","seringa","serra","servo","setembro","setor","sigilo","silhueta","silicone","simetria","simpatia","simular","sinal","sincero","singular","sinopse","sintonia","sirene","siri","situado","soberano","sobra","socorro","sogro","soja","solda","soletrar","solteiro","sombrio","sonata","sondar","sonegar","sonhador","sono","soprano","soquete","sorrir","sorteio","sossego","sotaque","soterrar","sovado","sozinho","suavizar","subida","submerso","subsolo","subtrair","sucata","sucesso","suco","sudeste","sufixo","sugador","sugerir","sujeito","sulfato","sumir","suor","superior","suplicar","suposto","suprimir","surdina","surfista","surpresa","surreal","surtir","suspiro","sustento","tabela","tablete","tabuada","tacho","tagarela","talher","talo","talvez","tamanho","tamborim","tampa","tangente","tanto","tapar","tapioca","tardio","tarefa","tarja","tarraxa","tatuagem","taurino","taxativo","taxista","teatral","tecer","tecido","teclado","tedioso","teia","teimar","telefone","telhado","tempero","tenente","tensor","tentar","termal","terno","terreno","tese","tesoura","testado","teto","textura","texugo","tiara","tigela","tijolo","timbrar","timidez","tingido","tinteiro","tiragem","titular","toalha","tocha","tolerar","tolice","tomada","tomilho","tonel","tontura","topete","tora","torcido","torneio","torque","torrada","torto","tostar","touca","toupeira","toxina","trabalho","tracejar","tradutor","trafegar","trajeto","trama","trancar","trapo","traseiro","tratador","travar","treino","tremer","trepidar","trevo","triagem","tribo","triciclo","tridente","trilogia","trindade","triplo","triturar","triunfal","trocar","trombeta","trova","trunfo","truque","tubular","tucano","tudo","tulipa","tupi","turbo","turma","turquesa","tutelar","tutorial","uivar","umbigo","unha","unidade","uniforme","urologia","urso","urtiga","urubu","usado","usina","usufruir","vacina","vadiar","vagaroso","vaidoso","vala","valente","validade","valores","vantagem","vaqueiro","varanda","vareta","varrer","vascular","vasilha","vassoura","vazar","vazio","veado","vedar","vegetar","veicular","veleiro","velhice","veludo","vencedor","vendaval","venerar","ventre","verbal","verdade","vereador","vergonha","vermelho","verniz","versar","vertente","vespa","vestido","vetorial","viaduto","viagem","viajar","viatura","vibrador","videira","vidraria","viela","viga","vigente","vigiar","vigorar","vilarejo","vinco","vinheta","vinil","violeta","virada","virtude","visitar","visto","vitral","viveiro","vizinho","voador","voar","vogal","volante","voleibol","voltagem","volumoso","vontade","vulto","vuvuzela","xadrez","xarope","xeque","xeretar","xerife","xingar","zangado","zarpar","zebu","zelador","zombar","zoologia","zumbido"]');
const require$$9 = /* @__PURE__ */ JSON.parse('["abandon","ability","able","about","above","absent","absorb","abstract","absurd","abuse","access","accident","account","accuse","achieve","acid","acoustic","acquire","across","act","action","actor","actress","actual","adapt","add","addict","address","adjust","admit","adult","advance","advice","aerobic","affair","afford","afraid","again","age","agent","agree","ahead","aim","air","airport","aisle","alarm","album","alcohol","alert","alien","all","alley","allow","almost","alone","alpha","already","also","alter","always","amateur","amazing","among","amount","amused","analyst","anchor","ancient","anger","angle","angry","animal","ankle","announce","annual","another","answer","antenna","antique","anxiety","any","apart","apology","appear","apple","approve","april","arch","arctic","area","arena","argue","arm","armed","armor","army","around","arrange","arrest","arrive","arrow","art","artefact","artist","artwork","ask","aspect","assault","asset","assist","assume","asthma","athlete","atom","attack","attend","attitude","attract","auction","audit","august","aunt","author","auto","autumn","average","avocado","avoid","awake","aware","away","awesome","awful","awkward","axis","baby","bachelor","bacon","badge","bag","balance","balcony","ball","bamboo","banana","banner","bar","barely","bargain","barrel","base","basic","basket","battle","beach","bean","beauty","because","become","beef","before","begin","behave","behind","believe","below","belt","bench","benefit","best","betray","better","between","beyond","bicycle","bid","bike","bind","biology","bird","birth","bitter","black","blade","blame","blanket","blast","bleak","bless","blind","blood","blossom","blouse","blue","blur","blush","board","boat","body","boil","bomb","bone","bonus","book","boost","border","boring","borrow","boss","bottom","bounce","box","boy","bracket","brain","brand","brass","brave","bread","breeze","brick","bridge","brief","bright","bring","brisk","broccoli","broken","bronze","broom","brother","brown","brush","bubble","buddy","budget","buffalo","build","bulb","bulk","bullet","bundle","bunker","burden","burger","burst","bus","business","busy","butter","buyer","buzz","cabbage","cabin","cable","cactus","cage","cake","call","calm","camera","camp","can","canal","cancel","candy","cannon","canoe","canvas","canyon","capable","capital","captain","car","carbon","card","cargo","carpet","carry","cart","case","cash","casino","castle","casual","cat","catalog","catch","category","cattle","caught","cause","caution","cave","ceiling","celery","cement","census","century","cereal","certain","chair","chalk","champion","change","chaos","chapter","charge","chase","chat","cheap","check","cheese","chef","cherry","chest","chicken","chief","child","chimney","choice","choose","chronic","chuckle","chunk","churn","cigar","cinnamon","circle","citizen","city","civil","claim","clap","clarify","claw","clay","clean","clerk","clever","click","client","cliff","climb","clinic","clip","clock","clog","close","cloth","cloud","clown","club","clump","cluster","clutch","coach","coast","coconut","code","coffee","coil","coin","collect","color","column","combine","come","comfort","comic","common","company","concert","conduct","confirm","congress","connect","consider","control","convince","cook","cool","copper","copy","coral","core","corn","correct","cost","cotton","couch","country","couple","course","cousin","cover","coyote","crack","cradle","craft","cram","crane","crash","crater","crawl","crazy","cream","credit","creek","crew","cricket","crime","crisp","critic","crop","cross","crouch","crowd","crucial","cruel","cruise","crumble","crunch","crush","cry","crystal","cube","culture","cup","cupboard","curious","current","curtain","curve","cushion","custom","cute","cycle","dad","damage","damp","dance","danger","daring","dash","daughter","dawn","day","deal","debate","debris","decade","december","decide","decline","decorate","decrease","deer","defense","define","defy","degree","delay","deliver","demand","demise","denial","dentist","deny","depart","depend","deposit","depth","deputy","derive","describe","desert","design","desk","despair","destroy","detail","detect","develop","device","devote","diagram","dial","diamond","diary","dice","diesel","diet","differ","digital","dignity","dilemma","dinner","dinosaur","direct","dirt","disagree","discover","disease","dish","dismiss","disorder","display","distance","divert","divide","divorce","dizzy","doctor","document","dog","doll","dolphin","domain","donate","donkey","donor","door","dose","double","dove","draft","dragon","drama","drastic","draw","dream","dress","drift","drill","drink","drip","drive","drop","drum","dry","duck","dumb","dune","during","dust","dutch","duty","dwarf","dynamic","eager","eagle","early","earn","earth","easily","east","easy","echo","ecology","economy","edge","edit","educate","effort","egg","eight","either","elbow","elder","electric","elegant","element","elephant","elevator","elite","else","embark","embody","embrace","emerge","emotion","employ","empower","empty","enable","enact","end","endless","endorse","enemy","energy","enforce","engage","engine","enhance","enjoy","enlist","enough","enrich","enroll","ensure","enter","entire","entry","envelope","episode","equal","equip","era","erase","erode","erosion","error","erupt","escape","essay","essence","estate","eternal","ethics","evidence","evil","evoke","evolve","exact","example","excess","exchange","excite","exclude","excuse","execute","exercise","exhaust","exhibit","exile","exist","exit","exotic","expand","expect","expire","explain","expose","express","extend","extra","eye","eyebrow","fabric","face","faculty","fade","faint","faith","fall","false","fame","family","famous","fan","fancy","fantasy","farm","fashion","fat","fatal","father","fatigue","fault","favorite","feature","february","federal","fee","feed","feel","female","fence","festival","fetch","fever","few","fiber","fiction","field","figure","file","film","filter","final","find","fine","finger","finish","fire","firm","first","fiscal","fish","fit","fitness","fix","flag","flame","flash","flat","flavor","flee","flight","flip","float","flock","floor","flower","fluid","flush","fly","foam","focus","fog","foil","fold","follow","food","foot","force","forest","forget","fork","fortune","forum","forward","fossil","foster","found","fox","fragile","frame","frequent","fresh","friend","fringe","frog","front","frost","frown","frozen","fruit","fuel","fun","funny","furnace","fury","future","gadget","gain","galaxy","gallery","game","gap","garage","garbage","garden","garlic","garment","gas","gasp","gate","gather","gauge","gaze","general","genius","genre","gentle","genuine","gesture","ghost","giant","gift","giggle","ginger","giraffe","girl","give","glad","glance","glare","glass","glide","glimpse","globe","gloom","glory","glove","glow","glue","goat","goddess","gold","good","goose","gorilla","gospel","gossip","govern","gown","grab","grace","grain","grant","grape","grass","gravity","great","green","grid","grief","grit","grocery","group","grow","grunt","guard","guess","guide","guilt","guitar","gun","gym","habit","hair","half","hammer","hamster","hand","happy","harbor","hard","harsh","harvest","hat","have","hawk","hazard","head","health","heart","heavy","hedgehog","height","hello","helmet","help","hen","hero","hidden","high","hill","hint","hip","hire","history","hobby","hockey","hold","hole","holiday","hollow","home","honey","hood","hope","horn","horror","horse","hospital","host","hotel","hour","hover","hub","huge","human","humble","humor","hundred","hungry","hunt","hurdle","hurry","hurt","husband","hybrid","ice","icon","idea","identify","idle","ignore","ill","illegal","illness","image","imitate","immense","immune","impact","impose","improve","impulse","inch","include","income","increase","index","indicate","indoor","industry","infant","inflict","inform","inhale","inherit","initial","inject","injury","inmate","inner","innocent","input","inquiry","insane","insect","inside","inspire","install","intact","interest","into","invest","invite","involve","iron","island","isolate","issue","item","ivory","jacket","jaguar","jar","jazz","jealous","jeans","jelly","jewel","job","join","joke","journey","joy","judge","juice","jump","jungle","junior","junk","just","kangaroo","keen","keep","ketchup","key","kick","kid","kidney","kind","kingdom","kiss","kit","kitchen","kite","kitten","kiwi","knee","knife","knock","know","lab","label","labor","ladder","lady","lake","lamp","language","laptop","large","later","latin","laugh","laundry","lava","law","lawn","lawsuit","layer","lazy","leader","leaf","learn","leave","lecture","left","leg","legal","legend","leisure","lemon","lend","length","lens","leopard","lesson","letter","level","liar","liberty","library","license","life","lift","light","like","limb","limit","link","lion","liquid","list","little","live","lizard","load","loan","lobster","local","lock","logic","lonely","long","loop","lottery","loud","lounge","love","loyal","lucky","luggage","lumber","lunar","lunch","luxury","lyrics","machine","mad","magic","magnet","maid","mail","main","major","make","mammal","man","manage","mandate","mango","mansion","manual","maple","marble","march","margin","marine","market","marriage","mask","mass","master","match","material","math","matrix","matter","maximum","maze","meadow","mean","measure","meat","mechanic","medal","media","melody","melt","member","memory","mention","menu","mercy","merge","merit","merry","mesh","message","metal","method","middle","midnight","milk","million","mimic","mind","minimum","minor","minute","miracle","mirror","misery","miss","mistake","mix","mixed","mixture","mobile","model","modify","mom","moment","monitor","monkey","monster","month","moon","moral","more","morning","mosquito","mother","motion","motor","mountain","mouse","move","movie","much","muffin","mule","multiply","muscle","museum","mushroom","music","must","mutual","myself","mystery","myth","naive","name","napkin","narrow","nasty","nation","nature","near","neck","need","negative","neglect","neither","nephew","nerve","nest","net","network","neutral","never","news","next","nice","night","noble","noise","nominee","noodle","normal","north","nose","notable","note","nothing","notice","novel","now","nuclear","number","nurse","nut","oak","obey","object","oblige","obscure","observe","obtain","obvious","occur","ocean","october","odor","off","offer","office","often","oil","okay","old","olive","olympic","omit","once","one","onion","online","only","open","opera","opinion","oppose","option","orange","orbit","orchard","order","ordinary","organ","orient","original","orphan","ostrich","other","outdoor","outer","output","outside","oval","oven","over","own","owner","oxygen","oyster","ozone","pact","paddle","page","pair","palace","palm","panda","panel","panic","panther","paper","parade","parent","park","parrot","party","pass","patch","path","patient","patrol","pattern","pause","pave","payment","peace","peanut","pear","peasant","pelican","pen","penalty","pencil","people","pepper","perfect","permit","person","pet","phone","photo","phrase","physical","piano","picnic","picture","piece","pig","pigeon","pill","pilot","pink","pioneer","pipe","pistol","pitch","pizza","place","planet","plastic","plate","play","please","pledge","pluck","plug","plunge","poem","poet","point","polar","pole","police","pond","pony","pool","popular","portion","position","possible","post","potato","pottery","poverty","powder","power","practice","praise","predict","prefer","prepare","present","pretty","prevent","price","pride","primary","print","priority","prison","private","prize","problem","process","produce","profit","program","project","promote","proof","property","prosper","protect","proud","provide","public","pudding","pull","pulp","pulse","pumpkin","punch","pupil","puppy","purchase","purity","purpose","purse","push","put","puzzle","pyramid","quality","quantum","quarter","question","quick","quit","quiz","quote","rabbit","raccoon","race","rack","radar","radio","rail","rain","raise","rally","ramp","ranch","random","range","rapid","rare","rate","rather","raven","raw","razor","ready","real","reason","rebel","rebuild","recall","receive","recipe","record","recycle","reduce","reflect","reform","refuse","region","regret","regular","reject","relax","release","relief","rely","remain","remember","remind","remove","render","renew","rent","reopen","repair","repeat","replace","report","require","rescue","resemble","resist","resource","response","result","retire","retreat","return","reunion","reveal","review","reward","rhythm","rib","ribbon","rice","rich","ride","ridge","rifle","right","rigid","ring","riot","ripple","risk","ritual","rival","river","road","roast","robot","robust","rocket","romance","roof","rookie","room","rose","rotate","rough","round","route","royal","rubber","rude","rug","rule","run","runway","rural","sad","saddle","sadness","safe","sail","salad","salmon","salon","salt","salute","same","sample","sand","satisfy","satoshi","sauce","sausage","save","say","scale","scan","scare","scatter","scene","scheme","school","science","scissors","scorpion","scout","scrap","screen","script","scrub","sea","search","season","seat","second","secret","section","security","seed","seek","segment","select","sell","seminar","senior","sense","sentence","series","service","session","settle","setup","seven","shadow","shaft","shallow","share","shed","shell","sheriff","shield","shift","shine","ship","shiver","shock","shoe","shoot","shop","short","shoulder","shove","shrimp","shrug","shuffle","shy","sibling","sick","side","siege","sight","sign","silent","silk","silly","silver","similar","simple","since","sing","siren","sister","situate","six","size","skate","sketch","ski","skill","skin","skirt","skull","slab","slam","sleep","slender","slice","slide","slight","slim","slogan","slot","slow","slush","small","smart","smile","smoke","smooth","snack","snake","snap","sniff","snow","soap","soccer","social","sock","soda","soft","solar","soldier","solid","solution","solve","someone","song","soon","sorry","sort","soul","sound","soup","source","south","space","spare","spatial","spawn","speak","special","speed","spell","spend","sphere","spice","spider","spike","spin","spirit","split","spoil","sponsor","spoon","sport","spot","spray","spread","spring","spy","square","squeeze","squirrel","stable","stadium","staff","stage","stairs","stamp","stand","start","state","stay","steak","steel","stem","step","stereo","stick","still","sting","stock","stomach","stone","stool","story","stove","strategy","street","strike","strong","struggle","student","stuff","stumble","style","subject","submit","subway","success","such","sudden","suffer","sugar","suggest","suit","summer","sun","sunny","sunset","super","supply","supreme","sure","surface","surge","surprise","surround","survey","suspect","sustain","swallow","swamp","swap","swarm","swear","sweet","swift","swim","swing","switch","sword","symbol","symptom","syrup","system","table","tackle","tag","tail","talent","talk","tank","tape","target","task","taste","tattoo","taxi","teach","team","tell","ten","tenant","tennis","tent","term","test","text","thank","that","theme","then","theory","there","they","thing","this","thought","three","thrive","throw","thumb","thunder","ticket","tide","tiger","tilt","timber","time","tiny","tip","tired","tissue","title","toast","tobacco","today","toddler","toe","together","toilet","token","tomato","tomorrow","tone","tongue","tonight","tool","tooth","top","topic","topple","torch","tornado","tortoise","toss","total","tourist","toward","tower","town","toy","track","trade","traffic","tragic","train","transfer","trap","trash","travel","tray","treat","tree","trend","trial","tribe","trick","trigger","trim","trip","trophy","trouble","truck","true","truly","trumpet","trust","truth","try","tube","tuition","tumble","tuna","tunnel","turkey","turn","turtle","twelve","twenty","twice","twin","twist","two","type","typical","ugly","umbrella","unable","unaware","uncle","uncover","under","undo","unfair","unfold","unhappy","uniform","unique","unit","universe","unknown","unlock","until","unusual","unveil","update","upgrade","uphold","upon","upper","upset","urban","urge","usage","use","used","useful","useless","usual","utility","vacant","vacuum","vague","valid","valley","valve","van","vanish","vapor","various","vast","vault","vehicle","velvet","vendor","venture","venue","verb","verify","version","very","vessel","veteran","viable","vibrant","vicious","victory","video","view","village","vintage","violin","virtual","virus","visa","visit","visual","vital","vivid","vocal","voice","void","volcano","volume","vote","voyage","wage","wagon","wait","walk","wall","walnut","want","warfare","warm","warrior","wash","wasp","waste","water","wave","way","wealth","weapon","wear","weasel","weather","web","wedding","weekend","weird","welcome","west","wet","whale","what","wheat","wheel","when","where","whip","whisper","wide","width","wife","wild","will","win","window","wine","wing","wink","winner","winter","wire","wisdom","wise","wish","witness","wolf","woman","wonder","wood","wool","word","work","world","worry","worth","wrap","wreck","wrestle","wrist","write","wrong","yard","year","yellow","you","young","youth","zebra","zero","zone","zoo"]');
var hasRequired_wordlists;
function require_wordlists() {
  if (hasRequired_wordlists) return _wordlists;
  hasRequired_wordlists = 1;
  Object.defineProperty(_wordlists, "__esModule", { value: true });
  const wordlists = {};
  _wordlists.wordlists = wordlists;
  let _default;
  _wordlists._default = _default;
  try {
    _wordlists._default = _default = require$$0;
    wordlists.czech = _default;
  } catch (err) {
  }
  try {
    _wordlists._default = _default = require$$1;
    wordlists.chinese_simplified = _default;
  } catch (err) {
  }
  try {
    _wordlists._default = _default = require$$2;
    wordlists.chinese_traditional = _default;
  } catch (err) {
  }
  try {
    _wordlists._default = _default = require$$3;
    wordlists.korean = _default;
  } catch (err) {
  }
  try {
    _wordlists._default = _default = require$$4;
    wordlists.french = _default;
  } catch (err) {
  }
  try {
    _wordlists._default = _default = require$$5;
    wordlists.italian = _default;
  } catch (err) {
  }
  try {
    _wordlists._default = _default = require$$6;
    wordlists.spanish = _default;
  } catch (err) {
  }
  try {
    _wordlists._default = _default = require$$7;
    wordlists.japanese = _default;
    wordlists.JA = _default;
  } catch (err) {
  }
  try {
    _wordlists._default = _default = require$$8;
    wordlists.portuguese = _default;
  } catch (err) {
  }
  try {
    _wordlists._default = _default = require$$9;
    wordlists.english = _default;
    wordlists.EN = _default;
  } catch (err) {
  }
  return _wordlists;
}
var hasRequiredSrc;
function requireSrc() {
  if (hasRequiredSrc) return src;
  hasRequiredSrc = 1;
  Object.defineProperty(src, "__esModule", { value: true });
  const sha256_1 = /* @__PURE__ */ requireSha256();
  const sha512_1 = /* @__PURE__ */ requireSha512();
  const pbkdf2_1 = /* @__PURE__ */ requirePbkdf2();
  const utils_1 = /* @__PURE__ */ requireUtils();
  const _wordlists_1 = require_wordlists();
  let DEFAULT_WORDLIST = _wordlists_1._default;
  const INVALID_MNEMONIC = "Invalid mnemonic";
  const INVALID_ENTROPY = "Invalid entropy";
  const INVALID_CHECKSUM = "Invalid mnemonic checksum";
  const WORDLIST_REQUIRED = "A wordlist is required but a default could not be found.\nPlease pass a 2048 word array explicitly.";
  function normalize(str) {
    return (str || "").normalize("NFKD");
  }
  function lpad(str, padString, length) {
    while (str.length < length) {
      str = padString + str;
    }
    return str;
  }
  function binaryToByte(bin) {
    return parseInt(bin, 2);
  }
  function bytesToBinary(bytes) {
    return bytes.map((x2) => lpad(x2.toString(2), "0", 8)).join("");
  }
  function deriveChecksumBits(entropyBuffer) {
    const ENT = entropyBuffer.length * 8;
    const CS = ENT / 32;
    const hash = sha256_1.sha256(Uint8Array.from(entropyBuffer));
    return bytesToBinary(Array.from(hash)).slice(0, CS);
  }
  function salt(password) {
    return "mnemonic" + (password || "");
  }
  function mnemonicToSeedSync(mnemonic2, password) {
    const mnemonicBuffer = Uint8Array.from(Buffer.from(normalize(mnemonic2), "utf8"));
    const saltBuffer = Uint8Array.from(Buffer.from(salt(normalize(password)), "utf8"));
    const res = pbkdf2_1.pbkdf2(sha512_1.sha512, mnemonicBuffer, saltBuffer, {
      c: 2048,
      dkLen: 64
    });
    return Buffer.from(res);
  }
  src.mnemonicToSeedSync = mnemonicToSeedSync;
  function mnemonicToSeed(mnemonic2, password) {
    const mnemonicBuffer = Uint8Array.from(Buffer.from(normalize(mnemonic2), "utf8"));
    const saltBuffer = Uint8Array.from(Buffer.from(salt(normalize(password)), "utf8"));
    return pbkdf2_1.pbkdf2Async(sha512_1.sha512, mnemonicBuffer, saltBuffer, {
      c: 2048,
      dkLen: 64
    }).then((res) => Buffer.from(res));
  }
  src.mnemonicToSeed = mnemonicToSeed;
  function mnemonicToEntropy(mnemonic2, wordlist2) {
    wordlist2 = wordlist2 || DEFAULT_WORDLIST;
    if (!wordlist2) {
      throw new Error(WORDLIST_REQUIRED);
    }
    const words = normalize(mnemonic2).split(" ");
    if (words.length % 3 !== 0) {
      throw new Error(INVALID_MNEMONIC);
    }
    const bits = words.map((word) => {
      const index = wordlist2.indexOf(word);
      if (index === -1) {
        throw new Error(INVALID_MNEMONIC);
      }
      return lpad(index.toString(2), "0", 11);
    }).join("");
    const dividerIndex = Math.floor(bits.length / 33) * 32;
    const entropyBits = bits.slice(0, dividerIndex);
    const checksumBits = bits.slice(dividerIndex);
    const entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);
    if (entropyBytes.length < 16) {
      throw new Error(INVALID_ENTROPY);
    }
    if (entropyBytes.length > 32) {
      throw new Error(INVALID_ENTROPY);
    }
    if (entropyBytes.length % 4 !== 0) {
      throw new Error(INVALID_ENTROPY);
    }
    const entropy = Buffer.from(entropyBytes);
    const newChecksum = deriveChecksumBits(entropy);
    if (newChecksum !== checksumBits) {
      throw new Error(INVALID_CHECKSUM);
    }
    return entropy.toString("hex");
  }
  src.mnemonicToEntropy = mnemonicToEntropy;
  function entropyToMnemonic(entropy, wordlist2) {
    if (!Buffer.isBuffer(entropy)) {
      entropy = Buffer.from(entropy, "hex");
    }
    wordlist2 = wordlist2 || DEFAULT_WORDLIST;
    if (!wordlist2) {
      throw new Error(WORDLIST_REQUIRED);
    }
    if (entropy.length < 16) {
      throw new TypeError(INVALID_ENTROPY);
    }
    if (entropy.length > 32) {
      throw new TypeError(INVALID_ENTROPY);
    }
    if (entropy.length % 4 !== 0) {
      throw new TypeError(INVALID_ENTROPY);
    }
    const entropyBits = bytesToBinary(Array.from(entropy));
    const checksumBits = deriveChecksumBits(entropy);
    const bits = entropyBits + checksumBits;
    const chunks = bits.match(/(.{1,11})/g);
    const words = chunks.map((binary2) => {
      const index = binaryToByte(binary2);
      return wordlist2[index];
    });
    return wordlist2[0] === "" ? words.join("") : words.join(" ");
  }
  src.entropyToMnemonic = entropyToMnemonic;
  function generateMnemonic(strength, rng, wordlist2) {
    strength = strength || 128;
    if (strength % 32 !== 0) {
      throw new TypeError(INVALID_ENTROPY);
    }
    rng = rng || ((size) => Buffer.from(utils_1.randomBytes(size)));
    return entropyToMnemonic(rng(strength / 8), wordlist2);
  }
  src.generateMnemonic = generateMnemonic;
  function validateMnemonic(mnemonic2, wordlist2) {
    try {
      mnemonicToEntropy(mnemonic2, wordlist2);
    } catch (e) {
      return false;
    }
    return true;
  }
  src.validateMnemonic = validateMnemonic;
  function setDefaultWordlist(language) {
    const result = _wordlists_1.wordlists[language];
    if (result) {
      DEFAULT_WORDLIST = result;
    } else {
      throw new Error('Could not find wordlist for language "' + language + '"');
    }
  }
  src.setDefaultWordlist = setDefaultWordlist;
  function getDefaultWordlist() {
    if (!DEFAULT_WORDLIST) {
      throw new Error("No Default Wordlist set");
    }
    return Object.keys(_wordlists_1.wordlists).filter((lang) => {
      if (lang === "JA" || lang === "EN") {
        return false;
      }
      return _wordlists_1.wordlists[lang].every((word, index) => word === DEFAULT_WORDLIST[index]);
    })[0];
  }
  src.getDefaultWordlist = getDefaultWordlist;
  var _wordlists_2 = require_wordlists();
  src.wordlists = _wordlists_2.wordlists;
  return src;
}
var srcExports = requireSrc();
async function bip39ToPrivateKey(mnemonic2) {
  const seed = await srcExports.mnemonicToSeed(mnemonic2.join(" "));
  const TON_DERIVATION_PATH = [44, 607, 0];
  const seedContainer = await distExports$1.deriveEd25519Path(seed, TON_DERIVATION_PATH);
  return distExports$1.keyPairFromSeed(seedContainer.subarray(0, 32));
}
async function MnemonicToKeyPair(mnemonic2, mnemonicType = "ton") {
  const mnemonicArray = Array.isArray(mnemonic2) ? mnemonic2 : mnemonic2.split(" ");
  if (mnemonicArray.length !== 12 && mnemonicArray.length !== 24) {
    throw new WalletKitError(ERROR_CODES.VALIDATION_ERROR, `Invalid mnemonic length: expected 12 or 24 words, got ${mnemonicArray.length}`);
  }
  if (mnemonicType === "ton") {
    const key2 = await distExports$1.mnemonicToWalletKey(mnemonicArray);
    return {
      publicKey: new Uint8Array(key2.publicKey),
      secretKey: new Uint8Array(key2.secretKey)
    };
  }
  if (mnemonicType === "bip39") {
    const key2 = await bip39ToPrivateKey(mnemonicArray);
    return {
      publicKey: new Uint8Array(key2.publicKey),
      secretKey: new Uint8Array(key2.secretKey)
    };
  }
  throw new WalletKitError(ERROR_CODES.VALIDATION_ERROR, `Invalid mnemonic type: expected "ton" or "bip39", got "${mnemonicType}"`, void 0, { receivedType: mnemonicType, supportedTypes: ["ton", "bip39"] });
}
class Signer {
  /**
   * Create a signer from a mnemonic phrase
   * @param mnemonic - Mnemonic phrase as string or array of words
   * @param options - Optional configuration for mnemonic type
   * @returns Signer function with publicKey property
   */
  static async fromMnemonic(mnemonic2, options) {
    const keyPair = await MnemonicToKeyPair(mnemonic2, options?.type ?? "ton");
    const signer = createWalletSigner(keyPair.secretKey);
    return {
      sign: signer,
      publicKey: Uint8ArrayToHex(keyPair.publicKey)
    };
  }
  /**
   * Create a signer from a private key
   * @param privateKey - Private key as hex string or Uint8Array
   * @returns Signer function with publicKey property
   */
  static async fromPrivateKey(privateKey) {
    const privateKeyBytes = typeof privateKey === "string" ? Uint8Array.from(Buffer.from(privateKey.replace("0x", ""), "hex")) : privateKey;
    const keyPair = distExports$1.keyPairFromSeed(Buffer.from(privateKeyBytes));
    const signer = createWalletSigner(keyPair.secretKey);
    return {
      sign: signer,
      publicKey: Uint8ArrayToHex(keyPair.publicKey)
    };
  }
}
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __publicField = (obj, key2, value) => __defNormalProp(obj, key2 + "", value);
var __async$1 = (__this, __arguments, generator2) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator2.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator2.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator2 = generator2.apply(__this, __arguments)).next());
  });
};
class SwiftStorageAdapter {
  constructor(swiftStorage) {
    __publicField(this, "swiftStorage");
    this.swiftStorage = swiftStorage;
  }
  get(key2) {
    return __async$1(this, null, function* () {
      const value = yield this.swiftStorage.get(key2);
      return value ? JSON.parse(value) : null;
    });
  }
  set(key2, value) {
    return __async$1(this, null, function* () {
      yield this.swiftStorage.set(key2, JSON.stringify(value));
    });
  }
  remove(key2) {
    return __async$1(this, null, function* () {
      yield this.swiftStorage.remove(key2);
    });
  }
  clear() {
    return __async$1(this, null, function* () {
      yield this.swiftStorage.clear();
    });
  }
}
var __async = (__this, __arguments, generator2) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator2.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator2.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator2 = generator2.apply(__this, __arguments)).next());
  });
};
window.initWalletKit = (configuration, storage) => __async(null, null, function* () {
  console.log(" WalletKit iOS Bridge starting...");
  console.log("Creating WalletKit instance with configuration", configuration);
  console.log("Storage", storage);
  const walletKit = new TonWalletKit({
    network: configuration.network,
    walletManifest: configuration.walletManifest,
    deviceInfo: configuration.deviceInfo,
    // apiUrl: 'https://tonapi.io',
    // config: {
    bridge: configuration.bridge,
    eventProcessor: {
      // disableEvents: true,
    },
    // },
    apiClient: configuration.apiClient,
    storage: storage ? new SwiftStorageAdapter(storage) : new MemoryStorageAdapter({})
  });
  console.log(" WalletKit iOS Bridge starting...");
  let initialized = false;
  console.log(" Initializing WalletKit Bridge");
  console.log(" WalletKit instance ready");
  initialized = true;
  console.log(" WalletKit Bridge initialized successfully");
  window.walletKit = {
    // Check if initialized
    isReady() {
      return initialized && walletKit;
    },
    setEventsListeners(callback) {
      if (!initialized) throw new Error("WalletKit Bridge not initialized");
      console.log(" Bridge: Adding event listeners");
      walletKit.onConnectRequest((event) => {
        console.log(" Connect request received:", event);
        callback("connectRequest", event);
      });
      walletKit.onTransactionRequest((event) => {
        console.log(" Transaction request received:", event);
        callback("transactionRequest", event);
      });
      walletKit.onSignDataRequest((event) => {
        console.log(" Sign data request received:", event);
        callback("signDataRequest", event);
      });
      walletKit.onDisconnect((event) => {
        console.log(" Disconnect event received:", event);
        callback("disconnect", event);
      });
    },
    removeEventListeners() {
      if (!initialized) throw new Error("WalletKit Bridge not initialized");
      console.log(" Bridge: Removing all event listeners");
      walletKit.removeConnectRequestCallback();
      walletKit.removeTransactionRequestCallback();
      walletKit.removeSignDataRequestCallback();
      walletKit.removeDisconnectCallback();
      console.log(" All event listeners removed");
    },
    createV4R2WalletUsingMnemonic(mnemonic2, parameters) {
      return __async(this, null, function* () {
        if (!initialized) throw new Error("WalletKit Bridge not initialized");
        console.log(" Bridge: Creating V4R2 wallet using mnemonic");
        if (!mnemonic2) {
          throw new Error("Mnemonic required for mnemonic wallet type");
        }
        const signer = yield Signer.fromMnemonic(mnemonic2, { type: "ton" });
        return yield WalletV4R2Adapter.create(signer, {
          client: walletKit.getApiClient(),
          network: parameters.network
        });
      });
    },
    createV4R2WalletUsingSecretKey(secretKey, parameters) {
      return __async(this, null, function* () {
        if (!initialized) throw new Error("WalletKit Bridge not initialized");
        console.log(" Bridge: Creating V4R2 wallet using secret key");
        if (!secretKey) {
          throw new Error("Secret key required for secret key wallet type");
        }
        const signer = yield Signer.fromPrivateKey(secretKey);
        return yield WalletV4R2Adapter.create(signer, {
          client: walletKit.getApiClient(),
          network: parameters.network
        });
      });
    },
    createV4R2WalletUsingSigner(signer, parameters) {
      return __async(this, null, function* () {
        if (!initialized) throw new Error("WalletKit Bridge not initialized");
        console.log(" Bridge: Creating V4R2 wallet");
        if (!signer) {
          throw new Error("Signer required for wallet creation");
        }
        const customSigner = {
          sign: (bytes) => __async(null, null, function* () {
            return yield signer.sign(bytes);
          }),
          publicKey: signer.publicKey()
        };
        return yield WalletV4R2Adapter.create(customSigner, {
          client: walletKit.getApiClient(),
          network: parameters.network
        });
      });
    },
    createV5R1WalletUsingMnemonic(mnemonic2, parameters) {
      return __async(this, null, function* () {
        if (!initialized) throw new Error("WalletKit Bridge not initialized");
        console.log(" Bridge: Creating V5R1 wallet using mnemonic");
        if (!mnemonic2) {
          throw new Error("Mnemonic required for mnemonic wallet type");
        }
        const signer = yield Signer.fromMnemonic(mnemonic2, { type: "ton" });
        return yield WalletV5R1Adapter.create(signer, {
          client: walletKit.getApiClient(),
          network: parameters.network
        });
      });
    },
    createV5R1WalletUsingSecretKey(secretKey, parameters) {
      return __async(this, null, function* () {
        if (!initialized) throw new Error("WalletKit Bridge not initialized");
        console.log(" Bridge: Creating V5R1 wallet using secret key");
        if (!secretKey) {
          throw new Error("Secret key required for secret key wallet type");
        }
        const signer = yield Signer.fromPrivateKey(secretKey);
        return yield WalletV5R1Adapter.create(signer, {
          client: walletKit.getApiClient(),
          network: parameters.network
        });
      });
    },
    createV5R1WalletUsingSigner(signer, parameters) {
      return __async(this, null, function* () {
        if (!initialized) throw new Error("WalletKit Bridge not initialized");
        console.log(" Bridge: Creating V5R1 wallet");
        if (!signer) {
          throw new Error("Signer required for wallet creation");
        }
        const customSigner = {
          sign: (bytes) => __async(null, null, function* () {
            return yield signer.sign(bytes);
          }),
          publicKey: signer.publicKey()
        };
        return yield WalletV5R1Adapter.create(customSigner, {
          client: walletKit.getApiClient(),
          network: parameters.network
        });
      });
    },
    // Wallet management
    addWallet(walletAdapter) {
      return __async(this, null, function* () {
        if (!initialized) throw new Error("WalletKit Bridge not initialized");
        console.log(" Bridge: Adding wallet:");
        try {
          const wallet = yield walletKit.addWallet(walletAdapter);
          if (wallet) {
            console.log(" Wallet added:", wallet.getAddress());
          } else {
            console.log(" Wallet added: undefined");
          }
          return wallet;
        } catch (error2) {
          throw error2;
        }
      });
    },
    removeWallet(address) {
      return __async(this, null, function* () {
        if (!initialized) throw new Error("WalletKit Bridge not initialized");
        console.log(" Bridge: Removing wallet:", address);
        try {
          yield walletKit.removeWallet(address);
          console.log(" Wallet removed");
        } catch (error2) {
          console.error(" Failed to remove wallet:", error2);
          throw error2;
        }
      });
    },
    clearWallets() {
      return __async(this, null, function* () {
        if (!initialized) throw new Error("WalletKit Bridge not initialized");
        console.log(" Bridge: Clearing all wallets");
        try {
          const result = yield walletKit.clearWallets();
          console.log(" All wallets cleared:", result);
          return result;
        } catch (error2) {
          console.error(" Failed to clear wallets:", error2);
          throw error2;
        }
      });
    },
    getWallets() {
      return __async(this, null, function* () {
        if (!initialized) throw new Error("WalletKit Bridge not initialized");
        console.log(" Bridge: Getting wallets");
        try {
          const wallets2 = yield walletKit.getWallets();
          console.log(
            " Got wallets:",
            JSON.stringify(wallets2, (_, v2) => typeof v2 === "bigint" ? v2.toString() : v2)
          );
          return wallets2;
        } catch (error2) {
          console.error(" Failed to get wallets:", error2.toString());
          throw error2;
        }
      });
    },
    getSessions() {
      return __async(this, null, function* () {
        if (!initialized) throw new Error("WalletKit Bridge not initialized");
        console.log(" Bridge: Getting sessions");
        try {
          const sessions = yield walletKit.listSessions();
          console.log(" Got sessions:", sessions);
          return sessions;
        } catch (error2) {
          console.error(" Failed to get sessions:", error2);
          throw error2;
        }
      });
    },
    // Connection handling
    handleTonConnectUrl(url) {
      return __async(this, null, function* () {
        if (!initialized) throw new Error("WalletKit Bridge not initialized");
        console.log(" Bridge: Handling TON Connect URL:", url);
        try {
          const result = yield walletKit.handleTonConnectUrl(url);
          console.log(" Bridge: Handled TON Connect URL:", result);
          return result;
        } catch (error2) {
          console.error(" Error processing TonConnect URL:", error2);
          throw error2;
        }
      });
    },
    approveConnectRequest(request) {
      return __async(this, null, function* () {
        if (!initialized) throw new Error("WalletKit Bridge not initialized");
        console.log(" Bridge: Approving connect request:", request, request.walletAddress);
        try {
          const result = yield walletKit.approveConnectRequest(request);
          console.log(" Connect request approved for wallet:", request.walletAddress, result);
          return result;
        } catch (error2) {
          console.error(" Failed to approve connect request:", error2);
          throw error2;
        }
      });
    },
    rejectConnectRequest(request, reason) {
      return __async(this, null, function* () {
        if (!initialized) throw new Error("WalletKit Bridge not initialized");
        console.log(" Bridge: Rejecting connect request:", request.id, reason || "User rejected");
        try {
          const result = yield walletKit.rejectConnectRequest(request, reason);
          console.log(" Connect request rejected:", result);
          return result;
        } catch (error2) {
          console.error(" Failed to reject connect request:", error2);
          throw error2;
        }
      });
    },
    // Transaction handling
    approveTransactionRequest(request) {
      return __async(this, null, function* () {
        if (!initialized) throw new Error("WalletKit Bridge not initialized");
        console.log(" Bridge: Approving transaction request:", request);
        try {
          const result = yield walletKit.approveTransactionRequest(request);
          console.log(" Transaction request approved:", result);
          return result;
        } catch (error2) {
          console.error(" Failed to approve transaction request:", error2);
          throw error2;
        }
      });
    },
    rejectTransactionRequest(request, reason) {
      return __async(this, null, function* () {
        if (!initialized) throw new Error("WalletKit Bridge not initialized");
        console.log(" Bridge: Rejecting transaction request:", request, reason);
        try {
          const result = yield walletKit.rejectTransactionRequest(request, reason);
          console.log(" Transaction request rejected:", result);
          return result;
        } catch (error2) {
          console.error(" Failed to reject transaction request:", error2);
          throw error2;
        }
      });
    },
    // Sign data handling
    approveSignDataRequest(request) {
      return __async(this, null, function* () {
        if (!initialized) throw new Error("WalletKit Bridge not initialized");
        console.log(" Bridge: Approving sign data request:", request);
        try {
          const result = yield walletKit.signDataRequest(request);
          console.log(" Sign data request approved:", result);
          return result;
        } catch (error2) {
          console.error(" Failed to approve sign data request:", error2);
          throw error2;
        }
      });
    },
    rejectSignDataRequest(request, reason) {
      return __async(this, null, function* () {
        if (!initialized) throw new Error("WalletKit Bridge not initialized");
        console.log(" Bridge: Rejecting sign data request:", request, reason);
        try {
          const result = yield walletKit.rejectSignDataRequest(request, reason);
          console.log(" Sign data request rejected:", result);
          return result;
        } catch (error2) {
          console.error(" Failed to reject sign data request:", error2);
          throw error2;
        }
      });
    },
    // Session management
    disconnect(sessionId) {
      return __async(this, null, function* () {
        if (!initialized) throw new Error("WalletKit Bridge not initialized");
        console.log(" Bridge: Disconnecting session:", sessionId);
        try {
          const result = yield walletKit.disconnect(sessionId);
          console.log(" Session disconnected:", result);
          return result;
        } catch (error2) {
          console.error(" Failed to disconnect session:", error2);
          throw error2;
        }
      });
    },
    // Jettons
    getJettons(walletAddress) {
      return __async(this, null, function* () {
        if (!initialized) throw new Error("WalletKit Bridge not initialized");
        console.log(" Bridge: Getting jettons for:", walletAddress);
        try {
          const jettons = yield walletKit.jettons.getAddressJettons(walletAddress);
          console.log(" Got jettons for", walletAddress, ":", jettons);
          return jettons;
        } catch (error2) {
          console.error(" Failed to get jettons:", error2);
          throw error2;
        }
      });
    }
  };
});
const main = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" }));
//# sourceMappingURL=walletkit-ios-bridge.mjs.map
