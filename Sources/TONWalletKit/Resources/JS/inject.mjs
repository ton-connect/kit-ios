const DEFAULT_DEVICE_INFO = {
  platform: "browser",
  appName: "Wallet",
  appVersion: "1.0.0",
  maxProtocolVersion: 2,
  features: [
    "SendTransaction",
    {
      name: "SendTransaction",
      maxMessages: 1
    }
  ]
};
const DEFAULT_WALLET_INFO = {
  name: "Wallet",
  appName: "Wallet",
  imageUrl: "https://example.com/image.png",
  bridgeUrl: "https://example.com/bridge.png",
  universalLink: "https://example.com/universal-link",
  aboutUrl: "https://example.com/about",
  platforms: ["chrome", "firefox", "safari", "android", "ios", "windows", "macos", "linux"],
  jsBridgeKey: "wallet"
};
function getDeviceInfoWithDefaults(options) {
  const deviceInfo = {
    ...DEFAULT_DEVICE_INFO,
    ...options
  };
  return deviceInfo;
}
function getWalletInfoWithDefaults(options) {
  const walletInfo = {
    ...DEFAULT_WALLET_INFO,
    ...options
  };
  return walletInfo;
}
function validateBridgeConfig(config) {
  if (!config.deviceInfo) {
    throw new Error("deviceInfo is required");
  }
  if (!config.walletInfo) {
    throw new Error("walletInfo is required");
  }
  if (!config.jsBridgeKey || typeof config.jsBridgeKey !== "string") {
    throw new Error("jsBridgeKey must be a non-empty string");
  }
  if (config.protocolVersion < 2) {
    throw new Error("protocolVersion must be at least 2");
  }
}
class TonConnectBridge {
  // Public properties as per TonConnect spec
  deviceInfo;
  walletInfo;
  protocolVersion;
  isWalletBrowser;
  // Private state
  transport;
  eventListeners = [];
  constructor(config, transport) {
    this.deviceInfo = config.deviceInfo;
    this.walletInfo = config.walletInfo;
    this.protocolVersion = config.protocolVersion;
    this.isWalletBrowser = config.isWalletBrowser;
    this.transport = transport;
    this.transport.onEvent((event) => {
      this.notifyListeners(event);
    });
  }
  /**
   * Initiates connect request - forwards to transport
   */
  async connect(protocolVersion, message) {
    if (protocolVersion < 2) {
      throw new Error("Unsupported protocol version");
    }
    return this.transport.send({
      method: "connect",
      params: { protocolVersion, ...message }
    });
  }
  /**
   * Attempts to restore previous connection - forwards to transport
   */
  async restoreConnection() {
    return this.transport.send({
      method: "restoreConnection",
      params: []
    });
  }
  /**
   * Sends a message to the bridge - forwards to transport
   */
  async send(message) {
    return this.transport.send({
      method: "send",
      params: [message]
    });
  }
  /**
   * Registers a listener for events from the wallet
   * Returns unsubscribe function
   */
  listen(callback) {
    if (typeof callback !== "function") {
      throw new Error("Callback must be a function");
    }
    this.eventListeners.push(callback);
    return () => {
      const index = this.eventListeners.indexOf(callback);
      if (index > -1) {
        this.eventListeners.splice(index, 1);
      }
    };
  }
  /**
   * Expose listener count for environments that need to fan-out events across frames.
   */
  hasListeners() {
    return this.eventListeners.length > 0;
  }
  /**
   * Notify all registered listeners of an event
   */
  notifyListeners(event) {
    this.eventListeners.forEach((callback) => {
      try {
        callback(event);
      } catch (error2) {
        console.error("TonConnect event listener error:", error2);
      }
    });
  }
  /**
   * Check if transport is available
   */
  isTransportAvailable() {
    return this.transport.isAvailable();
  }
  /**
   * Cleanup resources
   */
  destroy() {
    this.eventListeners.length = 0;
    this.transport.destroy();
  }
}
const TONCONNECT_BRIDGE_REQUEST = "TONCONNECT_BRIDGE_REQUEST";
const TONCONNECT_BRIDGE_RESPONSE = "TONCONNECT_BRIDGE_RESPONSE";
const TONCONNECT_BRIDGE_EVENT = "TONCONNECT_BRIDGE_EVENT";
const INJECT_CONTENT_SCRIPT = "INJECT_CONTENT_SCRIPT";
const DEFAULT_REQUEST_TIMEOUT = 3e5;
const RESTORE_CONNECTION_TIMEOUT = 1e4;
const SUPPORTED_PROTOCOL_VERSION = 2;
class ExtensionTransport {
  extensionId = null;
  source;
  window;
  pendingRequests = /* @__PURE__ */ new Map();
  eventCallback = null;
  messageListener = null;
  constructor(window2, source) {
    this.window = window2;
    this.source = source;
    this.setupMessageListener();
  }
  /**
   * Setup listener for messages from extension
   */
  setupMessageListener() {
    this.messageListener = (event) => {
      if (event.source !== this.window)
        return;
      const data = event.data;
      if (!data || typeof data !== "object")
        return;
      if (data.type === "INJECT_EXTENSION_ID") {
        this.extensionId = data.extensionId;
        return;
      }
      if (data.type === TONCONNECT_BRIDGE_RESPONSE && data.source === this.source) {
        this.handleResponse(data);
        return;
      }
      if (data.type === TONCONNECT_BRIDGE_EVENT && data.source === this.source) {
        this.handleEvent(data.event);
        return;
      }
    };
    this.window.addEventListener("message", this.messageListener);
  }
  /**
   * Handle response from extension
   */
  handleResponse(data) {
    const pendingRequest = this.pendingRequests.get(data.messageId);
    if (!pendingRequest)
      return;
    const { resolve, reject, timeoutId } = pendingRequest;
    this.pendingRequests.delete(data.messageId);
    clearTimeout(timeoutId);
    if (data.success) {
      resolve(data.payload);
    } else {
      reject(data.error);
    }
  }
  /**
   * Handle event from extension
   */
  handleEvent(event) {
    if (this.eventCallback) {
      try {
        this.eventCallback(event);
      } catch (error2) {
        console.error("TonConnect event callback error:", error2);
      }
    }
  }
  /**
   * Send request to extension
   */
  async send(request) {
    if (!this.isAvailable()) {
      throw new Error("Chrome extension transport is not available");
    }
    return new Promise((resolve, reject) => {
      const messageId = crypto.randomUUID();
      const timeout = request.method === "restoreConnection" ? RESTORE_CONNECTION_TIMEOUT : DEFAULT_REQUEST_TIMEOUT;
      const timeoutId = setTimeout(() => {
        if (this.pendingRequests.has(messageId)) {
          this.pendingRequests.delete(messageId);
          reject(new Error(`Request timeout: ${request.method}`));
        }
      }, timeout);
      this.pendingRequests.set(messageId, { resolve, reject, timeoutId });
      try {
        chrome.runtime.sendMessage(this.extensionId, {
          type: TONCONNECT_BRIDGE_REQUEST,
          source: this.source,
          payload: request,
          messageId
        });
      } catch (error2) {
        this.pendingRequests.delete(messageId);
        clearTimeout(timeoutId);
        reject(error2);
      }
    });
  }
  /**
   * Register event callback
   */
  onEvent(callback) {
    this.eventCallback = callback;
  }
  /**
   * Check if transport is available
   */
  isAvailable() {
    return typeof chrome !== "undefined" && this.extensionId !== null;
  }
  /**
   * Request content script injection for iframes
   */
  requestContentScriptInjection() {
    if (!this.isAvailable())
      return;
    try {
      chrome.runtime.sendMessage(this.extensionId, {
        type: INJECT_CONTENT_SCRIPT
      });
    } catch (error2) {
      console.error("Failed to request content script injection:", error2);
    }
  }
  /**
   * Cleanup resources
   */
  destroy() {
    this.pendingRequests.forEach(({ timeoutId }) => clearTimeout(timeoutId));
    this.pendingRequests.clear();
    if (this.messageListener) {
      this.window.removeEventListener("message", this.messageListener);
      this.messageListener = null;
    }
    this.eventCallback = null;
    this.extensionId = null;
  }
}
class IframeWatcher {
  onIframeDetected;
  observer = null;
  constructor(onIframeDetected) {
    this.onIframeDetected = onIframeDetected;
  }
  /**
   * Start watching for iframes
   */
  start() {
    if (this.observer) {
      return;
    }
    this.observer = new MutationObserver((mutations) => {
      this.handleMutations(mutations);
    });
    this.observer.observe(document.body, {
      childList: true,
      subtree: true
    });
  }
  /**
   * Stop watching for iframes
   */
  stop() {
    if (this.observer) {
      this.observer.disconnect();
      this.observer = null;
    }
  }
  /**
   * Handle DOM mutations
   */
  handleMutations(mutations) {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        this.handleAddedNode(node);
      }
    }
  }
  /**
   * Handle a single added node
   */
  handleAddedNode(node) {
    if (node.nodeType !== Node.ELEMENT_NODE) {
      return;
    }
    const element = node;
    if (element.tagName === "IFRAME") {
      this.setupIframeListeners(element);
      this.onIframeDetected();
      return;
    }
    const iframes = element.querySelectorAll("iframe");
    if (iframes.length > 0) {
      iframes.forEach((iframe) => {
        this.setupIframeListeners(iframe);
      });
      this.onIframeDetected();
    }
  }
  /**
   * Setup event listeners for iframe
   */
  setupIframeListeners(iframe) {
    const handleIframeEvent = () => {
      this.onIframeDetected();
    };
    iframe.removeEventListener("load", handleIframeEvent);
    iframe.removeEventListener("error", handleIframeEvent);
    iframe.addEventListener("load", handleIframeEvent);
    iframe.addEventListener("error", handleIframeEvent);
  }
}
class WindowAccessor {
  window;
  bridgeKey;
  injectTonKey;
  constructor(window2, { bridgeKey, injectTonKey }) {
    this.window = window2;
    this.bridgeKey = bridgeKey;
    this.injectTonKey = injectTonKey ?? true;
  }
  /**
   * Check if bridge already exists
   */
  exists() {
    const windowObj = this.window;
    return !!(windowObj[this.bridgeKey] && windowObj[this.bridgeKey].tonconnect);
  }
  /**
   * Get bridge key name
   */
  getBridgeKey() {
    return this.bridgeKey;
  }
  get tonKey() {
    return "ton";
  }
  /**
   * Ensure wallet object exists on window
   */
  ensureWalletObject() {
    const windowObj = this.window;
    if (!windowObj[this.bridgeKey]) {
      windowObj[this.bridgeKey] = {};
    }
    if (this.injectTonKey) {
      if (!windowObj[this.tonKey]) {
        windowObj[this.tonKey] = {};
      }
    }
  }
  /**
   * Inject bridge into window object
   */
  injectBridge(bridge) {
    this.ensureWalletObject();
    const windowObj = this.window;
    Object.defineProperty(windowObj[this.bridgeKey], "tonconnect", {
      value: bridge,
      writable: false,
      enumerable: true,
      configurable: false
    });
    if (this.injectTonKey) {
      Object.defineProperty(windowObj[this.tonKey], "tonconnect", {
        value: bridge,
        writable: false,
        enumerable: true,
        configurable: false
      });
    }
  }
}
function resolveJsBridgeKey(options) {
  if (options.jsBridgeKey) {
    return options.jsBridgeKey;
  }
  if (options.walletInfo) {
    if ("jsBridgeKey" in options.walletInfo) {
      return options.walletInfo.jsBridgeKey;
    }
    if ("name" in options.walletInfo) {
      return options.walletInfo.name;
    }
  }
  return "unknown-wallet";
}
function createBridgeConfig(options) {
  const deviceInfo = getDeviceInfoWithDefaults(options.deviceInfo);
  const walletInfo = getWalletInfoWithDefaults(options.walletInfo);
  const jsBridgeKey = resolveJsBridgeKey(options);
  return {
    deviceInfo,
    walletInfo,
    jsBridgeKey,
    isWalletBrowser: options.isWalletBrowser ?? false,
    protocolVersion: SUPPORTED_PROTOCOL_VERSION
  };
}
function injectBridge(window2, options, argsTransport) {
  const config = createBridgeConfig(options);
  validateBridgeConfig(config);
  let shouldInjectTonKey = void 0;
  if (options.injectTonKey !== void 0) {
    shouldInjectTonKey = options.injectTonKey;
  } else if (options.isWalletBrowser === true) {
    shouldInjectTonKey = true;
  } else {
    shouldInjectTonKey = true;
  }
  const windowAccessor = new WindowAccessor(window2, {
    bridgeKey: config.jsBridgeKey,
    injectTonKey: shouldInjectTonKey
  });
  if (windowAccessor.exists()) {
    console.log(`${config.jsBridgeKey}.tonconnect already exists, skipping injection`);
    return;
  }
  let transport;
  if (argsTransport) {
    transport = argsTransport;
  } else {
    const source = `${config.jsBridgeKey}-tonconnect`;
    transport = new ExtensionTransport(window2, source);
  }
  const bridge = new TonConnectBridge(config, transport);
  windowAccessor.injectBridge(bridge);
  console.log(`TonConnect JS Bridge injected for ${config.jsBridgeKey} - forwarding to extension`);
  const iframeWatcher = new IframeWatcher(() => {
    transport.requestContentScriptInjection();
  });
  iframeWatcher.start();
  return;
}
function injectBridgeCode(window2, options, transport) {
  injectBridge(window2, options, transport);
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getAugmentedNamespace(n) {
  if (Object.prototype.hasOwnProperty.call(n, "__esModule")) return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      var isInstance = false;
      try {
        isInstance = this instanceof a2;
      } catch {
      }
      if (isInstance) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var naclUtil$1 = { exports: {} };
var naclUtil = naclUtil$1.exports;
var hasRequiredNaclUtil;
function requireNaclUtil() {
  if (hasRequiredNaclUtil) return naclUtil$1.exports;
  hasRequiredNaclUtil = 1;
  (function(module) {
    (function(root, f) {
      if (module.exports) module.exports = f();
      else if (root.nacl) root.nacl.util = f();
      else {
        root.nacl = {};
        root.nacl.util = f();
      }
    })(naclUtil, function() {
      var util2 = {};
      function validateBase64(s) {
        if (!/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(s)) {
          throw new TypeError("invalid encoding");
        }
      }
      util2.decodeUTF8 = function(s) {
        if (typeof s !== "string") throw new TypeError("expected string");
        var i, d = unescape(encodeURIComponent(s)), b = new Uint8Array(d.length);
        for (i = 0; i < d.length; i++) b[i] = d.charCodeAt(i);
        return b;
      };
      util2.encodeUTF8 = function(arr) {
        var i, s = [];
        for (i = 0; i < arr.length; i++) s.push(String.fromCharCode(arr[i]));
        return decodeURIComponent(escape(s.join("")));
      };
      if (typeof atob === "undefined") {
        if (typeof Buffer.from !== "undefined") {
          util2.encodeBase64 = function(arr) {
            return Buffer.from(arr).toString("base64");
          };
          util2.decodeBase64 = function(s) {
            validateBase64(s);
            return new Uint8Array(Array.prototype.slice.call(Buffer.from(s, "base64"), 0));
          };
        } else {
          util2.encodeBase64 = function(arr) {
            return new Buffer(arr).toString("base64");
          };
          util2.decodeBase64 = function(s) {
            validateBase64(s);
            return new Uint8Array(Array.prototype.slice.call(new Buffer(s, "base64"), 0));
          };
        }
      } else {
        util2.encodeBase64 = function(arr) {
          var i, s = [], len = arr.length;
          for (i = 0; i < len; i++) s.push(String.fromCharCode(arr[i]));
          return btoa(s.join(""));
        };
        util2.decodeBase64 = function(s) {
          validateBase64(s);
          var i, d = atob(s), b = new Uint8Array(d.length);
          for (i = 0; i < d.length; i++) b[i] = d.charCodeAt(i);
          return b;
        };
      }
      return util2;
    });
  })(naclUtil$1);
  return naclUtil$1.exports;
}
requireNaclUtil();
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var naclFast = { exports: {} };
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$4$2 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var hasRequiredNaclFast;
function requireNaclFast() {
  if (hasRequiredNaclFast) return naclFast.exports;
  hasRequiredNaclFast = 1;
  (function(module) {
    (function(nacl2) {
      var gf = function(init) {
        var i, r = new Float64Array(16);
        if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
        return r;
      };
      var randombytes = function() {
        throw new Error("no PRNG");
      };
      var _0 = new Uint8Array(16);
      var _9 = new Uint8Array(32);
      _9[0] = 9;
      var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D2 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function ts64(x, i, h, l) {
        x[i] = h >> 24 & 255;
        x[i + 1] = h >> 16 & 255;
        x[i + 2] = h >> 8 & 255;
        x[i + 3] = h & 255;
        x[i + 4] = l >> 24 & 255;
        x[i + 5] = l >> 16 & 255;
        x[i + 6] = l >> 8 & 255;
        x[i + 7] = l & 255;
      }
      function vn(x, xi, y, yi, n) {
        var i, d = 0;
        for (i = 0; i < n; i++) d |= x[xi + i] ^ y[yi + i];
        return (1 & d - 1 >>> 8) - 1;
      }
      function crypto_verify_16(x, xi, y, yi) {
        return vn(x, xi, y, yi, 16);
      }
      function crypto_verify_32(x, xi, y, yi) {
        return vn(x, xi, y, yi, 32);
      }
      function core_salsa20(o, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        x0 = x0 + j0 | 0;
        x1 = x1 + j1 | 0;
        x2 = x2 + j2 | 0;
        x3 = x3 + j3 | 0;
        x4 = x4 + j4 | 0;
        x5 = x5 + j5 | 0;
        x6 = x6 + j6 | 0;
        x7 = x7 + j7 | 0;
        x8 = x8 + j8 | 0;
        x9 = x9 + j9 | 0;
        x10 = x10 + j10 | 0;
        x11 = x11 + j11 | 0;
        x12 = x12 + j12 | 0;
        x13 = x13 + j13 | 0;
        x14 = x14 + j14 | 0;
        x15 = x15 + j15 | 0;
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x1 >>> 0 & 255;
        o[5] = x1 >>> 8 & 255;
        o[6] = x1 >>> 16 & 255;
        o[7] = x1 >>> 24 & 255;
        o[8] = x2 >>> 0 & 255;
        o[9] = x2 >>> 8 & 255;
        o[10] = x2 >>> 16 & 255;
        o[11] = x2 >>> 24 & 255;
        o[12] = x3 >>> 0 & 255;
        o[13] = x3 >>> 8 & 255;
        o[14] = x3 >>> 16 & 255;
        o[15] = x3 >>> 24 & 255;
        o[16] = x4 >>> 0 & 255;
        o[17] = x4 >>> 8 & 255;
        o[18] = x4 >>> 16 & 255;
        o[19] = x4 >>> 24 & 255;
        o[20] = x5 >>> 0 & 255;
        o[21] = x5 >>> 8 & 255;
        o[22] = x5 >>> 16 & 255;
        o[23] = x5 >>> 24 & 255;
        o[24] = x6 >>> 0 & 255;
        o[25] = x6 >>> 8 & 255;
        o[26] = x6 >>> 16 & 255;
        o[27] = x6 >>> 24 & 255;
        o[28] = x7 >>> 0 & 255;
        o[29] = x7 >>> 8 & 255;
        o[30] = x7 >>> 16 & 255;
        o[31] = x7 >>> 24 & 255;
        o[32] = x8 >>> 0 & 255;
        o[33] = x8 >>> 8 & 255;
        o[34] = x8 >>> 16 & 255;
        o[35] = x8 >>> 24 & 255;
        o[36] = x9 >>> 0 & 255;
        o[37] = x9 >>> 8 & 255;
        o[38] = x9 >>> 16 & 255;
        o[39] = x9 >>> 24 & 255;
        o[40] = x10 >>> 0 & 255;
        o[41] = x10 >>> 8 & 255;
        o[42] = x10 >>> 16 & 255;
        o[43] = x10 >>> 24 & 255;
        o[44] = x11 >>> 0 & 255;
        o[45] = x11 >>> 8 & 255;
        o[46] = x11 >>> 16 & 255;
        o[47] = x11 >>> 24 & 255;
        o[48] = x12 >>> 0 & 255;
        o[49] = x12 >>> 8 & 255;
        o[50] = x12 >>> 16 & 255;
        o[51] = x12 >>> 24 & 255;
        o[52] = x13 >>> 0 & 255;
        o[53] = x13 >>> 8 & 255;
        o[54] = x13 >>> 16 & 255;
        o[55] = x13 >>> 24 & 255;
        o[56] = x14 >>> 0 & 255;
        o[57] = x14 >>> 8 & 255;
        o[58] = x14 >>> 16 & 255;
        o[59] = x14 >>> 24 & 255;
        o[60] = x15 >>> 0 & 255;
        o[61] = x15 >>> 8 & 255;
        o[62] = x15 >>> 16 & 255;
        o[63] = x15 >>> 24 & 255;
      }
      function core_hsalsa20(o, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x5 >>> 0 & 255;
        o[5] = x5 >>> 8 & 255;
        o[6] = x5 >>> 16 & 255;
        o[7] = x5 >>> 24 & 255;
        o[8] = x10 >>> 0 & 255;
        o[9] = x10 >>> 8 & 255;
        o[10] = x10 >>> 16 & 255;
        o[11] = x10 >>> 24 & 255;
        o[12] = x15 >>> 0 & 255;
        o[13] = x15 >>> 8 & 255;
        o[14] = x15 >>> 16 & 255;
        o[15] = x15 >>> 24 & 255;
        o[16] = x6 >>> 0 & 255;
        o[17] = x6 >>> 8 & 255;
        o[18] = x6 >>> 16 & 255;
        o[19] = x6 >>> 24 & 255;
        o[20] = x7 >>> 0 & 255;
        o[21] = x7 >>> 8 & 255;
        o[22] = x7 >>> 16 & 255;
        o[23] = x7 >>> 24 & 255;
        o[24] = x8 >>> 0 & 255;
        o[25] = x8 >>> 8 & 255;
        o[26] = x8 >>> 16 & 255;
        o[27] = x8 >>> 24 & 255;
        o[28] = x9 >>> 0 & 255;
        o[29] = x9 >>> 8 & 255;
        o[30] = x9 >>> 16 & 255;
        o[31] = x9 >>> 24 & 255;
      }
      function crypto_core_salsa20(out, inp, k, c) {
        core_salsa20(out, inp, k, c);
      }
      function crypto_core_hsalsa20(out, inp, k, c) {
        core_hsalsa20(out, inp, k, c);
      }
      var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
      function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++) z[i] = 0;
        for (i = 0; i < 8; i++) z[i] = n[i];
        while (b >= 64) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < 64; i++) c[cpos + i] = m[mpos + i] ^ x[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = u + (z[i] & 255) | 0;
            z[i] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
          mpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < b; i++) c[cpos + i] = m[mpos + i] ^ x[i];
        }
        return 0;
      }
      function crypto_stream_salsa20(c, cpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++) z[i] = 0;
        for (i = 0; i < 8; i++) z[i] = n[i];
        while (b >= 64) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < 64; i++) c[cpos + i] = x[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = u + (z[i] & 255) | 0;
            z[i] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < b; i++) c[cpos + i] = x[i];
        }
        return 0;
      }
      function crypto_stream(c, cpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i = 0; i < 8; i++) sn[i] = n[i + 16];
        return crypto_stream_salsa20(c, cpos, d, sn, s);
      }
      function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i = 0; i < 8; i++) sn[i] = n[i + 16];
        return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s);
      }
      var poly1305 = function(key2) {
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.leftover = 0;
        this.fin = 0;
        var t0, t1, t2, t3, t4, t5, t6, t7;
        t0 = key2[0] & 255 | (key2[1] & 255) << 8;
        this.r[0] = t0 & 8191;
        t1 = key2[2] & 255 | (key2[3] & 255) << 8;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        t2 = key2[4] & 255 | (key2[5] & 255) << 8;
        this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        t3 = key2[6] & 255 | (key2[7] & 255) << 8;
        this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        t4 = key2[8] & 255 | (key2[9] & 255) << 8;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this.r[5] = t4 >>> 1 & 8190;
        t5 = key2[10] & 255 | (key2[11] & 255) << 8;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        t6 = key2[12] & 255 | (key2[13] & 255) << 8;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        t7 = key2[14] & 255 | (key2[15] & 255) << 8;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this.r[9] = t7 >>> 5 & 127;
        this.pad[0] = key2[16] & 255 | (key2[17] & 255) << 8;
        this.pad[1] = key2[18] & 255 | (key2[19] & 255) << 8;
        this.pad[2] = key2[20] & 255 | (key2[21] & 255) << 8;
        this.pad[3] = key2[22] & 255 | (key2[23] & 255) << 8;
        this.pad[4] = key2[24] & 255 | (key2[25] & 255) << 8;
        this.pad[5] = key2[26] & 255 | (key2[27] & 255) << 8;
        this.pad[6] = key2[28] & 255 | (key2[29] & 255) << 8;
        this.pad[7] = key2[30] & 255 | (key2[31] & 255) << 8;
      };
      poly1305.prototype.blocks = function(m, mpos, bytes) {
        var hibit = this.fin ? 0 : 1 << 11;
        var t0, t1, t2, t3, t4, t5, t6, t7, c;
        var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
        var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
        var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
        while (bytes >= 16) {
          t0 = m[mpos + 0] & 255 | (m[mpos + 1] & 255) << 8;
          h0 += t0 & 8191;
          t1 = m[mpos + 2] & 255 | (m[mpos + 3] & 255) << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          t2 = m[mpos + 4] & 255 | (m[mpos + 5] & 255) << 8;
          h2 += (t1 >>> 10 | t2 << 6) & 8191;
          t3 = m[mpos + 6] & 255 | (m[mpos + 7] & 255) << 8;
          h3 += (t2 >>> 7 | t3 << 9) & 8191;
          t4 = m[mpos + 8] & 255 | (m[mpos + 9] & 255) << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          t5 = m[mpos + 10] & 255 | (m[mpos + 11] & 255) << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          t6 = m[mpos + 12] & 255 | (m[mpos + 13] & 255) << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          t7 = m[mpos + 14] & 255 | (m[mpos + 15] & 255) << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          c = 0;
          d0 = c;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h2 * (5 * r8);
          d0 += h3 * (5 * r7);
          d0 += h4 * (5 * r6);
          c = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c += d0 >>> 13;
          d0 &= 8191;
          d1 = c;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h2 * (5 * r9);
          d1 += h3 * (5 * r8);
          d1 += h4 * (5 * r7);
          c = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c += d1 >>> 13;
          d1 &= 8191;
          d2 = c;
          d2 += h0 * r2;
          d2 += h1 * r1;
          d2 += h2 * r0;
          d2 += h3 * (5 * r9);
          d2 += h4 * (5 * r8);
          c = d2 >>> 13;
          d2 &= 8191;
          d2 += h5 * (5 * r7);
          d2 += h6 * (5 * r6);
          d2 += h7 * (5 * r5);
          d2 += h8 * (5 * r4);
          d2 += h9 * (5 * r3);
          c += d2 >>> 13;
          d2 &= 8191;
          d3 = c;
          d3 += h0 * r3;
          d3 += h1 * r2;
          d3 += h2 * r1;
          d3 += h3 * r0;
          d3 += h4 * (5 * r9);
          c = d3 >>> 13;
          d3 &= 8191;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c += d3 >>> 13;
          d3 &= 8191;
          d4 = c;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h2 * r2;
          d4 += h3 * r1;
          d4 += h4 * r0;
          c = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c += d4 >>> 13;
          d4 &= 8191;
          d5 = c;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h2 * r3;
          d5 += h3 * r2;
          d5 += h4 * r1;
          c = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c += d5 >>> 13;
          d5 &= 8191;
          d6 = c;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h2 * r4;
          d6 += h3 * r3;
          d6 += h4 * r2;
          c = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c += d6 >>> 13;
          d6 &= 8191;
          d7 = c;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h2 * r5;
          d7 += h3 * r4;
          d7 += h4 * r3;
          c = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c += d7 >>> 13;
          d7 &= 8191;
          d8 = c;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h2 * r6;
          d8 += h3 * r5;
          d8 += h4 * r4;
          c = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c += d8 >>> 13;
          d8 &= 8191;
          d9 = c;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h2 * r7;
          d9 += h3 * r6;
          d9 += h4 * r5;
          c = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c += d9 >>> 13;
          d9 &= 8191;
          c = (c << 2) + c | 0;
          c = c + d0 | 0;
          d0 = c & 8191;
          c = c >>> 13;
          d1 += c;
          h0 = d0;
          h1 = d1;
          h2 = d2;
          h3 = d3;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes -= 16;
        }
        this.h[0] = h0;
        this.h[1] = h1;
        this.h[2] = h2;
        this.h[3] = h3;
        this.h[4] = h4;
        this.h[5] = h5;
        this.h[6] = h6;
        this.h[7] = h7;
        this.h[8] = h8;
        this.h[9] = h9;
      };
      poly1305.prototype.finish = function(mac, macpos) {
        var g2 = new Uint16Array(10);
        var c, mask, f, i;
        if (this.leftover) {
          i = this.leftover;
          this.buffer[i++] = 1;
          for (; i < 16; i++) this.buffer[i] = 0;
          this.fin = 1;
          this.blocks(this.buffer, 0, 16);
        }
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        for (i = 2; i < 10; i++) {
          this.h[i] += c;
          c = this.h[i] >>> 13;
          this.h[i] &= 8191;
        }
        this.h[0] += c * 5;
        c = this.h[0] >>> 13;
        this.h[0] &= 8191;
        this.h[1] += c;
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        this.h[2] += c;
        g2[0] = this.h[0] + 5;
        c = g2[0] >>> 13;
        g2[0] &= 8191;
        for (i = 1; i < 10; i++) {
          g2[i] = this.h[i] + c;
          c = g2[i] >>> 13;
          g2[i] &= 8191;
        }
        g2[9] -= 1 << 13;
        mask = (c ^ 1) - 1;
        for (i = 0; i < 10; i++) g2[i] &= mask;
        mask = ~mask;
        for (i = 0; i < 10; i++) this.h[i] = this.h[i] & mask | g2[i];
        this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
        this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
        this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
        this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
        this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
        this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
        this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
        this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
        f = this.h[0] + this.pad[0];
        this.h[0] = f & 65535;
        for (i = 1; i < 8; i++) {
          f = (this.h[i] + this.pad[i] | 0) + (f >>> 16) | 0;
          this.h[i] = f & 65535;
        }
        mac[macpos + 0] = this.h[0] >>> 0 & 255;
        mac[macpos + 1] = this.h[0] >>> 8 & 255;
        mac[macpos + 2] = this.h[1] >>> 0 & 255;
        mac[macpos + 3] = this.h[1] >>> 8 & 255;
        mac[macpos + 4] = this.h[2] >>> 0 & 255;
        mac[macpos + 5] = this.h[2] >>> 8 & 255;
        mac[macpos + 6] = this.h[3] >>> 0 & 255;
        mac[macpos + 7] = this.h[3] >>> 8 & 255;
        mac[macpos + 8] = this.h[4] >>> 0 & 255;
        mac[macpos + 9] = this.h[4] >>> 8 & 255;
        mac[macpos + 10] = this.h[5] >>> 0 & 255;
        mac[macpos + 11] = this.h[5] >>> 8 & 255;
        mac[macpos + 12] = this.h[6] >>> 0 & 255;
        mac[macpos + 13] = this.h[6] >>> 8 & 255;
        mac[macpos + 14] = this.h[7] >>> 0 & 255;
        mac[macpos + 15] = this.h[7] >>> 8 & 255;
      };
      poly1305.prototype.update = function(m, mpos, bytes) {
        var i, want;
        if (this.leftover) {
          want = 16 - this.leftover;
          if (want > bytes)
            want = bytes;
          for (i = 0; i < want; i++)
            this.buffer[this.leftover + i] = m[mpos + i];
          bytes -= want;
          mpos += want;
          this.leftover += want;
          if (this.leftover < 16)
            return;
          this.blocks(this.buffer, 0, 16);
          this.leftover = 0;
        }
        if (bytes >= 16) {
          want = bytes - bytes % 16;
          this.blocks(m, mpos, want);
          mpos += want;
          bytes -= want;
        }
        if (bytes) {
          for (i = 0; i < bytes; i++)
            this.buffer[this.leftover + i] = m[mpos + i];
          this.leftover += bytes;
        }
      };
      function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
        var s = new poly1305(k);
        s.update(m, mpos, n);
        s.finish(out, outpos);
        return 0;
      }
      function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
        var x = new Uint8Array(16);
        crypto_onetimeauth(x, 0, m, mpos, n, k);
        return crypto_verify_16(h, hpos, x, 0);
      }
      function crypto_secretbox(c, m, d, n, k) {
        var i;
        if (d < 32) return -1;
        crypto_stream_xor(c, 0, m, 0, d, n, k);
        crypto_onetimeauth(c, 16, c, 32, d - 32, c);
        for (i = 0; i < 16; i++) c[i] = 0;
        return 0;
      }
      function crypto_secretbox_open(m, c, d, n, k) {
        var i;
        var x = new Uint8Array(32);
        if (d < 32) return -1;
        crypto_stream(x, 0, 32, n, k);
        if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0) return -1;
        crypto_stream_xor(m, 0, c, 0, d, n, k);
        for (i = 0; i < 32; i++) m[i] = 0;
        return 0;
      }
      function set25519(r, a) {
        var i;
        for (i = 0; i < 16; i++) r[i] = a[i] | 0;
      }
      function car25519(o) {
        var i, v2, c = 1;
        for (i = 0; i < 16; i++) {
          v2 = o[i] + c + 65535;
          c = Math.floor(v2 / 65536);
          o[i] = v2 - c * 65536;
        }
        o[0] += c - 1 + 37 * (c - 1);
      }
      function sel25519(p, q, b) {
        var t, c = ~(b - 1);
        for (var i = 0; i < 16; i++) {
          t = c & (p[i] ^ q[i]);
          p[i] ^= t;
          q[i] ^= t;
        }
      }
      function pack25519(o, n) {
        var i, j, b;
        var m = gf(), t = gf();
        for (i = 0; i < 16; i++) t[i] = n[i];
        car25519(t);
        car25519(t);
        car25519(t);
        for (j = 0; j < 2; j++) {
          m[0] = t[0] - 65517;
          for (i = 1; i < 15; i++) {
            m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
            m[i - 1] &= 65535;
          }
          m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
          b = m[15] >> 16 & 1;
          m[14] &= 65535;
          sel25519(t, m, 1 - b);
        }
        for (i = 0; i < 16; i++) {
          o[2 * i] = t[i] & 255;
          o[2 * i + 1] = t[i] >> 8;
        }
      }
      function neq25519(a, b) {
        var c = new Uint8Array(32), d = new Uint8Array(32);
        pack25519(c, a);
        pack25519(d, b);
        return crypto_verify_32(c, 0, d, 0);
      }
      function par25519(a) {
        var d = new Uint8Array(32);
        pack25519(d, a);
        return d[0] & 1;
      }
      function unpack25519(o, n) {
        var i;
        for (i = 0; i < 16; i++) o[i] = n[2 * i] + (n[2 * i + 1] << 8);
        o[15] &= 32767;
      }
      function A2(o, a, b) {
        for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];
      }
      function Z(o, a, b) {
        for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];
      }
      function M(o, a, b) {
        var v2, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
        v2 = a[0];
        t0 += v2 * b0;
        t1 += v2 * b1;
        t2 += v2 * b2;
        t3 += v2 * b3;
        t4 += v2 * b4;
        t5 += v2 * b5;
        t6 += v2 * b6;
        t7 += v2 * b7;
        t8 += v2 * b8;
        t9 += v2 * b9;
        t10 += v2 * b10;
        t11 += v2 * b11;
        t12 += v2 * b12;
        t13 += v2 * b13;
        t14 += v2 * b14;
        t15 += v2 * b15;
        v2 = a[1];
        t1 += v2 * b0;
        t2 += v2 * b1;
        t3 += v2 * b2;
        t4 += v2 * b3;
        t5 += v2 * b4;
        t6 += v2 * b5;
        t7 += v2 * b6;
        t8 += v2 * b7;
        t9 += v2 * b8;
        t10 += v2 * b9;
        t11 += v2 * b10;
        t12 += v2 * b11;
        t13 += v2 * b12;
        t14 += v2 * b13;
        t15 += v2 * b14;
        t16 += v2 * b15;
        v2 = a[2];
        t2 += v2 * b0;
        t3 += v2 * b1;
        t4 += v2 * b2;
        t5 += v2 * b3;
        t6 += v2 * b4;
        t7 += v2 * b5;
        t8 += v2 * b6;
        t9 += v2 * b7;
        t10 += v2 * b8;
        t11 += v2 * b9;
        t12 += v2 * b10;
        t13 += v2 * b11;
        t14 += v2 * b12;
        t15 += v2 * b13;
        t16 += v2 * b14;
        t17 += v2 * b15;
        v2 = a[3];
        t3 += v2 * b0;
        t4 += v2 * b1;
        t5 += v2 * b2;
        t6 += v2 * b3;
        t7 += v2 * b4;
        t8 += v2 * b5;
        t9 += v2 * b6;
        t10 += v2 * b7;
        t11 += v2 * b8;
        t12 += v2 * b9;
        t13 += v2 * b10;
        t14 += v2 * b11;
        t15 += v2 * b12;
        t16 += v2 * b13;
        t17 += v2 * b14;
        t18 += v2 * b15;
        v2 = a[4];
        t4 += v2 * b0;
        t5 += v2 * b1;
        t6 += v2 * b2;
        t7 += v2 * b3;
        t8 += v2 * b4;
        t9 += v2 * b5;
        t10 += v2 * b6;
        t11 += v2 * b7;
        t12 += v2 * b8;
        t13 += v2 * b9;
        t14 += v2 * b10;
        t15 += v2 * b11;
        t16 += v2 * b12;
        t17 += v2 * b13;
        t18 += v2 * b14;
        t19 += v2 * b15;
        v2 = a[5];
        t5 += v2 * b0;
        t6 += v2 * b1;
        t7 += v2 * b2;
        t8 += v2 * b3;
        t9 += v2 * b4;
        t10 += v2 * b5;
        t11 += v2 * b6;
        t12 += v2 * b7;
        t13 += v2 * b8;
        t14 += v2 * b9;
        t15 += v2 * b10;
        t16 += v2 * b11;
        t17 += v2 * b12;
        t18 += v2 * b13;
        t19 += v2 * b14;
        t20 += v2 * b15;
        v2 = a[6];
        t6 += v2 * b0;
        t7 += v2 * b1;
        t8 += v2 * b2;
        t9 += v2 * b3;
        t10 += v2 * b4;
        t11 += v2 * b5;
        t12 += v2 * b6;
        t13 += v2 * b7;
        t14 += v2 * b8;
        t15 += v2 * b9;
        t16 += v2 * b10;
        t17 += v2 * b11;
        t18 += v2 * b12;
        t19 += v2 * b13;
        t20 += v2 * b14;
        t21 += v2 * b15;
        v2 = a[7];
        t7 += v2 * b0;
        t8 += v2 * b1;
        t9 += v2 * b2;
        t10 += v2 * b3;
        t11 += v2 * b4;
        t12 += v2 * b5;
        t13 += v2 * b6;
        t14 += v2 * b7;
        t15 += v2 * b8;
        t16 += v2 * b9;
        t17 += v2 * b10;
        t18 += v2 * b11;
        t19 += v2 * b12;
        t20 += v2 * b13;
        t21 += v2 * b14;
        t22 += v2 * b15;
        v2 = a[8];
        t8 += v2 * b0;
        t9 += v2 * b1;
        t10 += v2 * b2;
        t11 += v2 * b3;
        t12 += v2 * b4;
        t13 += v2 * b5;
        t14 += v2 * b6;
        t15 += v2 * b7;
        t16 += v2 * b8;
        t17 += v2 * b9;
        t18 += v2 * b10;
        t19 += v2 * b11;
        t20 += v2 * b12;
        t21 += v2 * b13;
        t22 += v2 * b14;
        t23 += v2 * b15;
        v2 = a[9];
        t9 += v2 * b0;
        t10 += v2 * b1;
        t11 += v2 * b2;
        t12 += v2 * b3;
        t13 += v2 * b4;
        t14 += v2 * b5;
        t15 += v2 * b6;
        t16 += v2 * b7;
        t17 += v2 * b8;
        t18 += v2 * b9;
        t19 += v2 * b10;
        t20 += v2 * b11;
        t21 += v2 * b12;
        t22 += v2 * b13;
        t23 += v2 * b14;
        t24 += v2 * b15;
        v2 = a[10];
        t10 += v2 * b0;
        t11 += v2 * b1;
        t12 += v2 * b2;
        t13 += v2 * b3;
        t14 += v2 * b4;
        t15 += v2 * b5;
        t16 += v2 * b6;
        t17 += v2 * b7;
        t18 += v2 * b8;
        t19 += v2 * b9;
        t20 += v2 * b10;
        t21 += v2 * b11;
        t22 += v2 * b12;
        t23 += v2 * b13;
        t24 += v2 * b14;
        t25 += v2 * b15;
        v2 = a[11];
        t11 += v2 * b0;
        t12 += v2 * b1;
        t13 += v2 * b2;
        t14 += v2 * b3;
        t15 += v2 * b4;
        t16 += v2 * b5;
        t17 += v2 * b6;
        t18 += v2 * b7;
        t19 += v2 * b8;
        t20 += v2 * b9;
        t21 += v2 * b10;
        t22 += v2 * b11;
        t23 += v2 * b12;
        t24 += v2 * b13;
        t25 += v2 * b14;
        t26 += v2 * b15;
        v2 = a[12];
        t12 += v2 * b0;
        t13 += v2 * b1;
        t14 += v2 * b2;
        t15 += v2 * b3;
        t16 += v2 * b4;
        t17 += v2 * b5;
        t18 += v2 * b6;
        t19 += v2 * b7;
        t20 += v2 * b8;
        t21 += v2 * b9;
        t22 += v2 * b10;
        t23 += v2 * b11;
        t24 += v2 * b12;
        t25 += v2 * b13;
        t26 += v2 * b14;
        t27 += v2 * b15;
        v2 = a[13];
        t13 += v2 * b0;
        t14 += v2 * b1;
        t15 += v2 * b2;
        t16 += v2 * b3;
        t17 += v2 * b4;
        t18 += v2 * b5;
        t19 += v2 * b6;
        t20 += v2 * b7;
        t21 += v2 * b8;
        t22 += v2 * b9;
        t23 += v2 * b10;
        t24 += v2 * b11;
        t25 += v2 * b12;
        t26 += v2 * b13;
        t27 += v2 * b14;
        t28 += v2 * b15;
        v2 = a[14];
        t14 += v2 * b0;
        t15 += v2 * b1;
        t16 += v2 * b2;
        t17 += v2 * b3;
        t18 += v2 * b4;
        t19 += v2 * b5;
        t20 += v2 * b6;
        t21 += v2 * b7;
        t22 += v2 * b8;
        t23 += v2 * b9;
        t24 += v2 * b10;
        t25 += v2 * b11;
        t26 += v2 * b12;
        t27 += v2 * b13;
        t28 += v2 * b14;
        t29 += v2 * b15;
        v2 = a[15];
        t15 += v2 * b0;
        t16 += v2 * b1;
        t17 += v2 * b2;
        t18 += v2 * b3;
        t19 += v2 * b4;
        t20 += v2 * b5;
        t21 += v2 * b6;
        t22 += v2 * b7;
        t23 += v2 * b8;
        t24 += v2 * b9;
        t25 += v2 * b10;
        t26 += v2 * b11;
        t27 += v2 * b12;
        t28 += v2 * b13;
        t29 += v2 * b14;
        t30 += v2 * b15;
        t0 += 38 * t16;
        t1 += 38 * t17;
        t2 += 38 * t18;
        t3 += 38 * t19;
        t4 += 38 * t20;
        t5 += 38 * t21;
        t6 += 38 * t22;
        t7 += 38 * t23;
        t8 += 38 * t24;
        t9 += 38 * t25;
        t10 += 38 * t26;
        t11 += 38 * t27;
        t12 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        c = 1;
        v2 = t0 + c + 65535;
        c = Math.floor(v2 / 65536);
        t0 = v2 - c * 65536;
        v2 = t1 + c + 65535;
        c = Math.floor(v2 / 65536);
        t1 = v2 - c * 65536;
        v2 = t2 + c + 65535;
        c = Math.floor(v2 / 65536);
        t2 = v2 - c * 65536;
        v2 = t3 + c + 65535;
        c = Math.floor(v2 / 65536);
        t3 = v2 - c * 65536;
        v2 = t4 + c + 65535;
        c = Math.floor(v2 / 65536);
        t4 = v2 - c * 65536;
        v2 = t5 + c + 65535;
        c = Math.floor(v2 / 65536);
        t5 = v2 - c * 65536;
        v2 = t6 + c + 65535;
        c = Math.floor(v2 / 65536);
        t6 = v2 - c * 65536;
        v2 = t7 + c + 65535;
        c = Math.floor(v2 / 65536);
        t7 = v2 - c * 65536;
        v2 = t8 + c + 65535;
        c = Math.floor(v2 / 65536);
        t8 = v2 - c * 65536;
        v2 = t9 + c + 65535;
        c = Math.floor(v2 / 65536);
        t9 = v2 - c * 65536;
        v2 = t10 + c + 65535;
        c = Math.floor(v2 / 65536);
        t10 = v2 - c * 65536;
        v2 = t11 + c + 65535;
        c = Math.floor(v2 / 65536);
        t11 = v2 - c * 65536;
        v2 = t12 + c + 65535;
        c = Math.floor(v2 / 65536);
        t12 = v2 - c * 65536;
        v2 = t13 + c + 65535;
        c = Math.floor(v2 / 65536);
        t13 = v2 - c * 65536;
        v2 = t14 + c + 65535;
        c = Math.floor(v2 / 65536);
        t14 = v2 - c * 65536;
        v2 = t15 + c + 65535;
        c = Math.floor(v2 / 65536);
        t15 = v2 - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        c = 1;
        v2 = t0 + c + 65535;
        c = Math.floor(v2 / 65536);
        t0 = v2 - c * 65536;
        v2 = t1 + c + 65535;
        c = Math.floor(v2 / 65536);
        t1 = v2 - c * 65536;
        v2 = t2 + c + 65535;
        c = Math.floor(v2 / 65536);
        t2 = v2 - c * 65536;
        v2 = t3 + c + 65535;
        c = Math.floor(v2 / 65536);
        t3 = v2 - c * 65536;
        v2 = t4 + c + 65535;
        c = Math.floor(v2 / 65536);
        t4 = v2 - c * 65536;
        v2 = t5 + c + 65535;
        c = Math.floor(v2 / 65536);
        t5 = v2 - c * 65536;
        v2 = t6 + c + 65535;
        c = Math.floor(v2 / 65536);
        t6 = v2 - c * 65536;
        v2 = t7 + c + 65535;
        c = Math.floor(v2 / 65536);
        t7 = v2 - c * 65536;
        v2 = t8 + c + 65535;
        c = Math.floor(v2 / 65536);
        t8 = v2 - c * 65536;
        v2 = t9 + c + 65535;
        c = Math.floor(v2 / 65536);
        t9 = v2 - c * 65536;
        v2 = t10 + c + 65535;
        c = Math.floor(v2 / 65536);
        t10 = v2 - c * 65536;
        v2 = t11 + c + 65535;
        c = Math.floor(v2 / 65536);
        t11 = v2 - c * 65536;
        v2 = t12 + c + 65535;
        c = Math.floor(v2 / 65536);
        t12 = v2 - c * 65536;
        v2 = t13 + c + 65535;
        c = Math.floor(v2 / 65536);
        t13 = v2 - c * 65536;
        v2 = t14 + c + 65535;
        c = Math.floor(v2 / 65536);
        t14 = v2 - c * 65536;
        v2 = t15 + c + 65535;
        c = Math.floor(v2 / 65536);
        t15 = v2 - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        o[0] = t0;
        o[1] = t1;
        o[2] = t2;
        o[3] = t3;
        o[4] = t4;
        o[5] = t5;
        o[6] = t6;
        o[7] = t7;
        o[8] = t8;
        o[9] = t9;
        o[10] = t10;
        o[11] = t11;
        o[12] = t12;
        o[13] = t13;
        o[14] = t14;
        o[15] = t15;
      }
      function S(o, a) {
        M(o, a, a);
      }
      function inv25519(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++) c[a] = i[a];
        for (a = 253; a >= 0; a--) {
          S(c, c);
          if (a !== 2 && a !== 4) M(c, c, i);
        }
        for (a = 0; a < 16; a++) o[a] = c[a];
      }
      function pow2523(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++) c[a] = i[a];
        for (a = 250; a >= 0; a--) {
          S(c, c);
          if (a !== 1) M(c, c, i);
        }
        for (a = 0; a < 16; a++) o[a] = c[a];
      }
      function crypto_scalarmult(q, n, p) {
        var z = new Uint8Array(32);
        var x = new Float64Array(80), r, i;
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
        for (i = 0; i < 31; i++) z[i] = n[i];
        z[31] = n[31] & 127 | 64;
        z[0] &= 248;
        unpack25519(x, p);
        for (i = 0; i < 16; i++) {
          b[i] = x[i];
          d[i] = a[i] = c[i] = 0;
        }
        a[0] = d[0] = 1;
        for (i = 254; i >= 0; --i) {
          r = z[i >>> 3] >>> (i & 7) & 1;
          sel25519(a, b, r);
          sel25519(c, d, r);
          A2(e, a, c);
          Z(a, a, c);
          A2(c, b, d);
          Z(b, b, d);
          S(d, e);
          S(f, a);
          M(a, c, a);
          M(c, b, e);
          A2(e, a, c);
          Z(a, a, c);
          S(b, a);
          Z(c, d, f);
          M(a, c, _121665);
          A2(a, a, d);
          M(c, c, a);
          M(a, d, f);
          M(d, b, x);
          S(b, e);
          sel25519(a, b, r);
          sel25519(c, d, r);
        }
        for (i = 0; i < 16; i++) {
          x[i + 16] = a[i];
          x[i + 32] = c[i];
          x[i + 48] = b[i];
          x[i + 64] = d[i];
        }
        var x32 = x.subarray(32);
        var x16 = x.subarray(16);
        inv25519(x32, x32);
        M(x16, x16, x32);
        pack25519(q, x16);
        return 0;
      }
      function crypto_scalarmult_base(q, n) {
        return crypto_scalarmult(q, n, _9);
      }
      function crypto_box_keypair(y, x) {
        randombytes(x, 32);
        return crypto_scalarmult_base(y, x);
      }
      function crypto_box_beforenm(k, y, x) {
        var s = new Uint8Array(32);
        crypto_scalarmult(s, x, y);
        return crypto_core_hsalsa20(k, _0, s, sigma);
      }
      var crypto_box_afternm = crypto_secretbox;
      var crypto_box_open_afternm = crypto_secretbox_open;
      function crypto_box(c, m, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_afternm(c, m, d, n, k);
      }
      function crypto_box_open(m, c, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_open_afternm(m, c, d, n, k);
      }
      var K = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function crypto_hashblocks_hl(hh, hl, m, n) {
        var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j, h, l, a, b, c, d;
        var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
        var pos = 0;
        while (n >= 128) {
          for (i = 0; i < 16; i++) {
            j = 8 * i + pos;
            wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
            wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
          }
          for (i = 0; i < 80; i++) {
            bh0 = ah0;
            bh1 = ah1;
            bh2 = ah2;
            bh3 = ah3;
            bh4 = ah4;
            bh5 = ah5;
            bh6 = ah6;
            bh7 = ah7;
            bl0 = al0;
            bl1 = al1;
            bl2 = al2;
            bl3 = al3;
            bl4 = al4;
            bl5 = al5;
            bl6 = al6;
            bl7 = al7;
            h = ah7;
            l = al7;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
            l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah4 & ah5 ^ ~ah4 & ah6;
            l = al4 & al5 ^ ~al4 & al6;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = K[i * 2];
            l = K[i * 2 + 1];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = wh[i % 16];
            l = wl[i % 16];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            th = c & 65535 | d << 16;
            tl = a & 65535 | b << 16;
            h = th;
            l = tl;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
            l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
            l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh7 = c & 65535 | d << 16;
            bl7 = a & 65535 | b << 16;
            h = bh3;
            l = bl3;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = th;
            l = tl;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh3 = c & 65535 | d << 16;
            bl3 = a & 65535 | b << 16;
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i % 16 === 15) {
              for (j = 0; j < 16; j++) {
                h = wh[j];
                l = wl[j];
                a = l & 65535;
                b = l >>> 16;
                c = h & 65535;
                d = h >>> 16;
                h = wh[(j + 9) % 16];
                l = wl[(j + 9) % 16];
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 1) % 16];
                tl = wl[(j + 1) % 16];
                h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 14) % 16];
                tl = wl[(j + 14) % 16];
                h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                wh[j] = c & 65535 | d << 16;
                wl[j] = a & 65535 | b << 16;
              }
            }
          }
          h = ah0;
          l = al0;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[0];
          l = hl[0];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[0] = ah0 = c & 65535 | d << 16;
          hl[0] = al0 = a & 65535 | b << 16;
          h = ah1;
          l = al1;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[1];
          l = hl[1];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[1] = ah1 = c & 65535 | d << 16;
          hl[1] = al1 = a & 65535 | b << 16;
          h = ah2;
          l = al2;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[2];
          l = hl[2];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[2] = ah2 = c & 65535 | d << 16;
          hl[2] = al2 = a & 65535 | b << 16;
          h = ah3;
          l = al3;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[3];
          l = hl[3];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[3] = ah3 = c & 65535 | d << 16;
          hl[3] = al3 = a & 65535 | b << 16;
          h = ah4;
          l = al4;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[4];
          l = hl[4];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[4] = ah4 = c & 65535 | d << 16;
          hl[4] = al4 = a & 65535 | b << 16;
          h = ah5;
          l = al5;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[5];
          l = hl[5];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[5] = ah5 = c & 65535 | d << 16;
          hl[5] = al5 = a & 65535 | b << 16;
          h = ah6;
          l = al6;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[6];
          l = hl[6];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[6] = ah6 = c & 65535 | d << 16;
          hl[6] = al6 = a & 65535 | b << 16;
          h = ah7;
          l = al7;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[7];
          l = hl[7];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[7] = ah7 = c & 65535 | d << 16;
          hl[7] = al7 = a & 65535 | b << 16;
          pos += 128;
          n -= 128;
        }
        return n;
      }
      function crypto_hash(out, m, n) {
        var hh = new Int32Array(8), hl = new Int32Array(8), x = new Uint8Array(256), i, b = n;
        hh[0] = 1779033703;
        hh[1] = 3144134277;
        hh[2] = 1013904242;
        hh[3] = 2773480762;
        hh[4] = 1359893119;
        hh[5] = 2600822924;
        hh[6] = 528734635;
        hh[7] = 1541459225;
        hl[0] = 4089235720;
        hl[1] = 2227873595;
        hl[2] = 4271175723;
        hl[3] = 1595750129;
        hl[4] = 2917565137;
        hl[5] = 725511199;
        hl[6] = 4215389547;
        hl[7] = 327033209;
        crypto_hashblocks_hl(hh, hl, m, n);
        n %= 128;
        for (i = 0; i < n; i++) x[i] = m[b - n + i];
        x[n] = 128;
        n = 256 - 128 * (n < 112 ? 1 : 0);
        x[n - 9] = 0;
        ts64(x, n - 8, b / 536870912 | 0, b << 3);
        crypto_hashblocks_hl(hh, hl, x, n);
        for (i = 0; i < 8; i++) ts64(out, 8 * i, hh[i], hl[i]);
        return 0;
      }
      function add(p, q) {
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g2 = gf(), h = gf(), t = gf();
        Z(a, p[1], p[0]);
        Z(t, q[1], q[0]);
        M(a, a, t);
        A2(b, p[0], p[1]);
        A2(t, q[0], q[1]);
        M(b, b, t);
        M(c, p[3], q[3]);
        M(c, c, D2);
        M(d, p[2], q[2]);
        A2(d, d, d);
        Z(e, b, a);
        Z(f, d, c);
        A2(g2, d, c);
        A2(h, b, a);
        M(p[0], e, f);
        M(p[1], h, g2);
        M(p[2], g2, f);
        M(p[3], e, h);
      }
      function cswap(p, q, b) {
        var i;
        for (i = 0; i < 4; i++) {
          sel25519(p[i], q[i], b);
        }
      }
      function pack(r, p) {
        var tx = gf(), ty = gf(), zi = gf();
        inv25519(zi, p[2]);
        M(tx, p[0], zi);
        M(ty, p[1], zi);
        pack25519(r, ty);
        r[31] ^= par25519(tx) << 7;
      }
      function scalarmult(p, q, s) {
        var b, i;
        set25519(p[0], gf0);
        set25519(p[1], gf1);
        set25519(p[2], gf1);
        set25519(p[3], gf0);
        for (i = 255; i >= 0; --i) {
          b = s[i / 8 | 0] >> (i & 7) & 1;
          cswap(p, q, b);
          add(q, p);
          add(p, p);
          cswap(p, q, b);
        }
      }
      function scalarbase(p, s) {
        var q = [gf(), gf(), gf(), gf()];
        set25519(q[0], X);
        set25519(q[1], Y);
        set25519(q[2], gf1);
        M(q[3], X, Y);
        scalarmult(p, q, s);
      }
      function crypto_sign_keypair(pk, sk, seeded) {
        var d = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()];
        var i;
        if (!seeded) randombytes(sk, 32);
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        scalarbase(p, d);
        pack(pk, p);
        for (i = 0; i < 32; i++) sk[i + 32] = pk[i];
        return 0;
      }
      var L = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
      function modL(r, x) {
        var carry, i, j, k;
        for (i = 63; i >= 32; --i) {
          carry = 0;
          for (j = i - 32, k = i - 12; j < k; ++j) {
            x[j] += carry - 16 * x[i] * L[j - (i - 32)];
            carry = Math.floor((x[j] + 128) / 256);
            x[j] -= carry * 256;
          }
          x[j] += carry;
          x[i] = 0;
        }
        carry = 0;
        for (j = 0; j < 32; j++) {
          x[j] += carry - (x[31] >> 4) * L[j];
          carry = x[j] >> 8;
          x[j] &= 255;
        }
        for (j = 0; j < 32; j++) x[j] -= carry * L[j];
        for (i = 0; i < 32; i++) {
          x[i + 1] += x[i] >> 8;
          r[i] = x[i] & 255;
        }
      }
      function reduce(r) {
        var x = new Float64Array(64), i;
        for (i = 0; i < 64; i++) x[i] = r[i];
        for (i = 0; i < 64; i++) r[i] = 0;
        modL(r, x);
      }
      function crypto_sign(sm, m, n, sk) {
        var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
        var i, j, x = new Float64Array(64);
        var p = [gf(), gf(), gf(), gf()];
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        var smlen = n + 64;
        for (i = 0; i < n; i++) sm[64 + i] = m[i];
        for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];
        crypto_hash(r, sm.subarray(32), n + 32);
        reduce(r);
        scalarbase(p, r);
        pack(sm, p);
        for (i = 32; i < 64; i++) sm[i] = sk[i];
        crypto_hash(h, sm, n + 64);
        reduce(h);
        for (i = 0; i < 64; i++) x[i] = 0;
        for (i = 0; i < 32; i++) x[i] = r[i];
        for (i = 0; i < 32; i++) {
          for (j = 0; j < 32; j++) {
            x[i + j] += h[i] * d[j];
          }
        }
        modL(sm.subarray(32), x);
        return smlen;
      }
      function unpackneg(r, p) {
        var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r[2], gf1);
        unpack25519(r[1], p);
        S(num, r[1]);
        M(den, num, D);
        Z(num, num, r[2]);
        A2(den, r[2], den);
        S(den2, den);
        S(den4, den2);
        M(den6, den4, den2);
        M(t, den6, num);
        M(t, t, den);
        pow2523(t, t);
        M(t, t, num);
        M(t, t, den);
        M(t, t, den);
        M(r[0], t, den);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num)) M(r[0], r[0], I);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num)) return -1;
        if (par25519(r[0]) === p[31] >> 7) Z(r[0], gf0, r[0]);
        M(r[3], r[0], r[1]);
        return 0;
      }
      function crypto_sign_open(m, sm, n, pk) {
        var i;
        var t = new Uint8Array(32), h = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
        if (n < 64) return -1;
        if (unpackneg(q, pk)) return -1;
        for (i = 0; i < n; i++) m[i] = sm[i];
        for (i = 0; i < 32; i++) m[i + 32] = pk[i];
        crypto_hash(h, m, n);
        reduce(h);
        scalarmult(p, q, h);
        scalarbase(q, sm.subarray(32));
        add(p, q);
        pack(t, p);
        n -= 64;
        if (crypto_verify_32(sm, 0, t, 0)) {
          for (i = 0; i < n; i++) m[i] = 0;
          return -1;
        }
        for (i = 0; i < n; i++) m[i] = sm[i + 64];
        return n;
      }
      var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
      nacl2.lowlevel = {
        crypto_core_hsalsa20,
        crypto_stream_xor,
        crypto_stream,
        crypto_stream_salsa20_xor,
        crypto_stream_salsa20,
        crypto_onetimeauth,
        crypto_onetimeauth_verify,
        crypto_verify_16,
        crypto_verify_32,
        crypto_secretbox,
        crypto_secretbox_open,
        crypto_scalarmult,
        crypto_scalarmult_base,
        crypto_box_beforenm,
        crypto_box_afternm,
        crypto_box,
        crypto_box_open,
        crypto_box_keypair,
        crypto_hash,
        crypto_sign,
        crypto_sign_keypair,
        crypto_sign_open,
        crypto_secretbox_KEYBYTES,
        crypto_secretbox_NONCEBYTES,
        crypto_secretbox_ZEROBYTES,
        crypto_secretbox_BOXZEROBYTES,
        crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES,
        crypto_box_PUBLICKEYBYTES,
        crypto_box_SECRETKEYBYTES,
        crypto_box_BEFORENMBYTES,
        crypto_box_NONCEBYTES,
        crypto_box_ZEROBYTES,
        crypto_box_BOXZEROBYTES,
        crypto_sign_BYTES,
        crypto_sign_PUBLICKEYBYTES,
        crypto_sign_SECRETKEYBYTES,
        crypto_sign_SEEDBYTES,
        crypto_hash_BYTES,
        gf,
        D,
        L,
        pack25519,
        unpack25519,
        M,
        A: A2,
        S,
        Z,
        pow2523,
        add,
        set25519,
        modL,
        scalarmult,
        scalarbase
      };
      function checkLengths(k, n) {
        if (k.length !== crypto_secretbox_KEYBYTES) throw new Error("bad key size");
        if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error("bad nonce size");
      }
      function checkBoxLengths(pk, sk) {
        if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error("bad public key size");
        if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error("bad secret key size");
      }
      function checkArrayTypes() {
        for (var i = 0; i < arguments.length; i++) {
          if (!(arguments[i] instanceof Uint8Array))
            throw new TypeError("unexpected type, use Uint8Array");
        }
      }
      function cleanup(arr) {
        for (var i = 0; i < arr.length; i++) arr[i] = 0;
      }
      nacl2.randomBytes = function(n) {
        var b = new Uint8Array(n);
        randombytes(b, n);
        return b;
      };
      nacl2.secretbox = function(msg, nonce, key2) {
        checkArrayTypes(msg, nonce, key2);
        checkLengths(key2, nonce);
        var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
        var c = new Uint8Array(m.length);
        for (var i = 0; i < msg.length; i++) m[i + crypto_secretbox_ZEROBYTES] = msg[i];
        crypto_secretbox(c, m, m.length, nonce, key2);
        return c.subarray(crypto_secretbox_BOXZEROBYTES);
      };
      nacl2.secretbox.open = function(box, nonce, key2) {
        checkArrayTypes(box, nonce, key2);
        checkLengths(key2, nonce);
        var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
        var m = new Uint8Array(c.length);
        for (var i = 0; i < box.length; i++) c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
        if (c.length < 32) return null;
        if (crypto_secretbox_open(m, c, c.length, nonce, key2) !== 0) return null;
        return m.subarray(crypto_secretbox_ZEROBYTES);
      };
      nacl2.secretbox.keyLength = crypto_secretbox_KEYBYTES;
      nacl2.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
      nacl2.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
      nacl2.scalarMult = function(n, p) {
        checkArrayTypes(n, p);
        if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
        if (p.length !== crypto_scalarmult_BYTES) throw new Error("bad p size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult(q, n, p);
        return q;
      };
      nacl2.scalarMult.base = function(n) {
        checkArrayTypes(n);
        if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult_base(q, n);
        return q;
      };
      nacl2.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
      nacl2.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
      nacl2.box = function(msg, nonce, publicKey, secretKey) {
        var k = nacl2.box.before(publicKey, secretKey);
        return nacl2.secretbox(msg, nonce, k);
      };
      nacl2.box.before = function(publicKey, secretKey) {
        checkArrayTypes(publicKey, secretKey);
        checkBoxLengths(publicKey, secretKey);
        var k = new Uint8Array(crypto_box_BEFORENMBYTES);
        crypto_box_beforenm(k, publicKey, secretKey);
        return k;
      };
      nacl2.box.after = nacl2.secretbox;
      nacl2.box.open = function(msg, nonce, publicKey, secretKey) {
        var k = nacl2.box.before(publicKey, secretKey);
        return nacl2.secretbox.open(msg, nonce, k);
      };
      nacl2.box.open.after = nacl2.secretbox.open;
      nacl2.box.keyPair = function() {
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
        crypto_box_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl2.box.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        crypto_scalarmult_base(pk, secretKey);
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl2.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
      nacl2.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
      nacl2.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
      nacl2.box.nonceLength = crypto_box_NONCEBYTES;
      nacl2.box.overheadLength = nacl2.secretbox.overheadLength;
      nacl2.sign = function(msg, secretKey) {
        checkArrayTypes(msg, secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
        crypto_sign(signedMsg, msg, msg.length, secretKey);
        return signedMsg;
      };
      nacl2.sign.open = function(signedMsg, publicKey) {
        checkArrayTypes(signedMsg, publicKey);
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var tmp = new Uint8Array(signedMsg.length);
        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
        if (mlen < 0) return null;
        var m = new Uint8Array(mlen);
        for (var i = 0; i < m.length; i++) m[i] = tmp[i];
        return m;
      };
      nacl2.sign.detached = function(msg, secretKey) {
        var signedMsg = nacl2.sign(msg, secretKey);
        var sig = new Uint8Array(crypto_sign_BYTES);
        for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
        return sig;
      };
      nacl2.sign.detached.verify = function(msg, sig, publicKey) {
        checkArrayTypes(msg, sig, publicKey);
        if (sig.length !== crypto_sign_BYTES)
          throw new Error("bad signature size");
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
        var m = new Uint8Array(crypto_sign_BYTES + msg.length);
        var i;
        for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
        for (i = 0; i < msg.length; i++) sm[i + crypto_sign_BYTES] = msg[i];
        return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
      };
      nacl2.sign.keyPair = function() {
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        crypto_sign_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl2.sign.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32 + i];
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl2.sign.keyPair.fromSeed = function(seed) {
        checkArrayTypes(seed);
        if (seed.length !== crypto_sign_SEEDBYTES)
          throw new Error("bad seed size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        for (var i = 0; i < 32; i++) sk[i] = seed[i];
        crypto_sign_keypair(pk, sk, true);
        return { publicKey: pk, secretKey: sk };
      };
      nacl2.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
      nacl2.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
      nacl2.sign.seedLength = crypto_sign_SEEDBYTES;
      nacl2.sign.signatureLength = crypto_sign_BYTES;
      nacl2.hash = function(msg) {
        checkArrayTypes(msg);
        var h = new Uint8Array(crypto_hash_BYTES);
        crypto_hash(h, msg, msg.length);
        return h;
      };
      nacl2.hash.hashLength = crypto_hash_BYTES;
      nacl2.verify = function(x, y) {
        checkArrayTypes(x, y);
        if (x.length === 0 || y.length === 0) return false;
        if (x.length !== y.length) return false;
        return vn(x, 0, y, 0, x.length) === 0 ? true : false;
      };
      nacl2.setPRNG = function(fn) {
        randombytes = fn;
      };
      (function() {
        var crypto2 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (crypto2 && crypto2.getRandomValues) {
          var QUOTA = 65536;
          nacl2.setPRNG(function(x, n) {
            var i, v2 = new Uint8Array(n);
            for (i = 0; i < n; i += QUOTA) {
              crypto2.getRandomValues(v2.subarray(i, i + Math.min(n - i, QUOTA)));
            }
            for (i = 0; i < n; i++) x[i] = v2[i];
            cleanup(v2);
          });
        } else if (typeof commonjsRequire !== "undefined") {
          crypto2 = require$$4$2;
          if (crypto2 && crypto2.randomBytes) {
            nacl2.setPRNG(function(x, n) {
              var i, v2 = crypto2.randomBytes(n);
              for (i = 0; i < n; i++) x[i] = v2[i];
              cleanup(v2);
            });
          }
        }
      })();
    })(module.exports ? module.exports : self.nacl = self.nacl || {});
  })(naclFast);
  return naclFast.exports;
}
requireNaclFast();
var CONNECT_EVENT_ERROR_CODES;
(function(CONNECT_EVENT_ERROR_CODES2) {
  CONNECT_EVENT_ERROR_CODES2[CONNECT_EVENT_ERROR_CODES2["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR";
  CONNECT_EVENT_ERROR_CODES2[CONNECT_EVENT_ERROR_CODES2["BAD_REQUEST_ERROR"] = 1] = "BAD_REQUEST_ERROR";
  CONNECT_EVENT_ERROR_CODES2[CONNECT_EVENT_ERROR_CODES2["MANIFEST_NOT_FOUND_ERROR"] = 2] = "MANIFEST_NOT_FOUND_ERROR";
  CONNECT_EVENT_ERROR_CODES2[CONNECT_EVENT_ERROR_CODES2["MANIFEST_CONTENT_ERROR"] = 3] = "MANIFEST_CONTENT_ERROR";
  CONNECT_EVENT_ERROR_CODES2[CONNECT_EVENT_ERROR_CODES2["UNKNOWN_APP_ERROR"] = 100] = "UNKNOWN_APP_ERROR";
  CONNECT_EVENT_ERROR_CODES2[CONNECT_EVENT_ERROR_CODES2["USER_REJECTS_ERROR"] = 300] = "USER_REJECTS_ERROR";
  CONNECT_EVENT_ERROR_CODES2[CONNECT_EVENT_ERROR_CODES2["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED";
})(CONNECT_EVENT_ERROR_CODES || (CONNECT_EVENT_ERROR_CODES = {}));
var CONNECT_ITEM_ERROR_CODES;
(function(CONNECT_ITEM_ERROR_CODES2) {
  CONNECT_ITEM_ERROR_CODES2[CONNECT_ITEM_ERROR_CODES2["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR";
  CONNECT_ITEM_ERROR_CODES2[CONNECT_ITEM_ERROR_CODES2["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED";
})(CONNECT_ITEM_ERROR_CODES || (CONNECT_ITEM_ERROR_CODES = {}));
var SEND_TRANSACTION_ERROR_CODES;
(function(SEND_TRANSACTION_ERROR_CODES2) {
  SEND_TRANSACTION_ERROR_CODES2[SEND_TRANSACTION_ERROR_CODES2["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR";
  SEND_TRANSACTION_ERROR_CODES2[SEND_TRANSACTION_ERROR_CODES2["BAD_REQUEST_ERROR"] = 1] = "BAD_REQUEST_ERROR";
  SEND_TRANSACTION_ERROR_CODES2[SEND_TRANSACTION_ERROR_CODES2["UNKNOWN_APP_ERROR"] = 100] = "UNKNOWN_APP_ERROR";
  SEND_TRANSACTION_ERROR_CODES2[SEND_TRANSACTION_ERROR_CODES2["USER_REJECTS_ERROR"] = 300] = "USER_REJECTS_ERROR";
  SEND_TRANSACTION_ERROR_CODES2[SEND_TRANSACTION_ERROR_CODES2["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED";
})(SEND_TRANSACTION_ERROR_CODES || (SEND_TRANSACTION_ERROR_CODES = {}));
var SIGN_DATA_ERROR_CODES;
(function(SIGN_DATA_ERROR_CODES2) {
  SIGN_DATA_ERROR_CODES2[SIGN_DATA_ERROR_CODES2["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR";
  SIGN_DATA_ERROR_CODES2[SIGN_DATA_ERROR_CODES2["BAD_REQUEST_ERROR"] = 1] = "BAD_REQUEST_ERROR";
  SIGN_DATA_ERROR_CODES2[SIGN_DATA_ERROR_CODES2["UNKNOWN_APP_ERROR"] = 100] = "UNKNOWN_APP_ERROR";
  SIGN_DATA_ERROR_CODES2[SIGN_DATA_ERROR_CODES2["USER_REJECTS_ERROR"] = 300] = "USER_REJECTS_ERROR";
  SIGN_DATA_ERROR_CODES2[SIGN_DATA_ERROR_CODES2["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED";
})(SIGN_DATA_ERROR_CODES || (SIGN_DATA_ERROR_CODES = {}));
var DISCONNECT_ERROR_CODES;
(function(DISCONNECT_ERROR_CODES2) {
  DISCONNECT_ERROR_CODES2[DISCONNECT_ERROR_CODES2["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR";
  DISCONNECT_ERROR_CODES2[DISCONNECT_ERROR_CODES2["BAD_REQUEST_ERROR"] = 1] = "BAD_REQUEST_ERROR";
  DISCONNECT_ERROR_CODES2[DISCONNECT_ERROR_CODES2["UNKNOWN_APP_ERROR"] = 100] = "UNKNOWN_APP_ERROR";
  DISCONNECT_ERROR_CODES2[DISCONNECT_ERROR_CODES2["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED";
})(DISCONNECT_ERROR_CODES || (DISCONNECT_ERROR_CODES = {}));
var CHAIN;
(function(CHAIN2) {
  CHAIN2["MAINNET"] = "-239";
  CHAIN2["TESTNET"] = "-3";
})(CHAIN || (CHAIN = {}));
var dist$6 = {};
var Address$1 = {};
var symbol_inspect;
var hasRequiredSymbol_inspect;
function requireSymbol_inspect() {
  if (hasRequiredSymbol_inspect) return symbol_inspect;
  hasRequiredSymbol_inspect = 1;
  const SymbolInspect = Symbol.for("nodejs.util.inspect.custom");
  symbol_inspect = SymbolInspect;
  return symbol_inspect;
}
var crc16$1 = {};
var hasRequiredCrc16$1;
function requireCrc16$1() {
  if (hasRequiredCrc16$1) return crc16$1;
  hasRequiredCrc16$1 = 1;
  Object.defineProperty(crc16$1, "__esModule", { value: true });
  crc16$1.crc16 = void 0;
  function crc162(data) {
    const poly = 4129;
    let reg = 0;
    const message = Buffer.alloc(data.length + 2);
    message.set(data);
    for (let byte of message) {
      let mask = 128;
      while (mask > 0) {
        reg <<= 1;
        if (byte & mask) {
          reg += 1;
        }
        mask >>= 1;
        if (reg > 65535) {
          reg &= 65535;
          reg ^= poly;
        }
      }
    }
    return Buffer.from([Math.floor(reg / 256), reg % 256]);
  }
  crc16$1.crc16 = crc162;
  return crc16$1;
}
var hasRequiredAddress$1;
function requireAddress$1() {
  if (hasRequiredAddress$1) return Address$1;
  hasRequiredAddress$1 = 1;
  var __importDefault = Address$1 && Address$1.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  var _a;
  Object.defineProperty(Address$1, "__esModule", { value: true });
  Address$1.address = Address$1.Address = void 0;
  const symbol_inspect_1 = __importDefault(requireSymbol_inspect());
  const crc16_1 = requireCrc16$1();
  const bounceable_tag = 17;
  const non_bounceable_tag = 81;
  const test_flag = 128;
  function parseFriendlyAddress(src2) {
    if (typeof src2 === "string" && !Address2.isFriendly(src2)) {
      throw new Error("Unknown address type");
    }
    const data = Buffer.isBuffer(src2) ? src2 : Buffer.from(src2, "base64");
    if (data.length !== 36) {
      throw new Error("Unknown address type: byte length is not equal to 36");
    }
    const addr = data.subarray(0, 34);
    const crc = data.subarray(34, 36);
    const calcedCrc = (0, crc16_1.crc16)(addr);
    if (!(calcedCrc[0] === crc[0] && calcedCrc[1] === crc[1])) {
      throw new Error("Invalid checksum: " + src2);
    }
    let tag = addr[0];
    let isTestOnly = false;
    let isBounceable = false;
    if (tag & test_flag) {
      isTestOnly = true;
      tag = tag ^ test_flag;
    }
    if (tag !== bounceable_tag && tag !== non_bounceable_tag)
      throw "Unknown address tag";
    isBounceable = tag === bounceable_tag;
    let workchain = null;
    if (addr[1] === 255) {
      workchain = -1;
    } else {
      workchain = addr[1];
    }
    const hashPart = addr.subarray(2, 34);
    return { isTestOnly, isBounceable, workchain, hashPart };
  }
  class Address2 {
    static isAddress(src2) {
      return src2 instanceof Address2;
    }
    static isFriendly(source) {
      if (source.length !== 48) {
        return false;
      }
      if (!/^[A-Za-z0-9+/_-]+$/.test(source)) {
        return false;
      }
      return true;
    }
    static isRaw(source) {
      if (source.indexOf(":") === -1) {
        return false;
      }
      let [wc, hash] = source.split(":");
      if (!Number.isInteger(parseFloat(wc))) {
        return false;
      }
      if (!/[a-f0-9]+/.test(hash.toLowerCase())) {
        return false;
      }
      if (hash.length !== 64) {
        return false;
      }
      return true;
    }
    static normalize(source) {
      if (typeof source === "string") {
        return Address2.parse(source).toString();
      } else {
        return source.toString();
      }
    }
    static parse(source) {
      if (Address2.isFriendly(source)) {
        return this.parseFriendly(source).address;
      } else if (Address2.isRaw(source)) {
        return this.parseRaw(source);
      } else {
        throw new Error("Unknown address type: " + source);
      }
    }
    static parseRaw(source) {
      let workChain = parseInt(source.split(":")[0]);
      let hash = Buffer.from(source.split(":")[1], "hex");
      return new Address2(workChain, hash);
    }
    static parseFriendly(source) {
      if (Buffer.isBuffer(source)) {
        let r = parseFriendlyAddress(source);
        return {
          isBounceable: r.isBounceable,
          isTestOnly: r.isTestOnly,
          address: new Address2(r.workchain, r.hashPart)
        };
      } else {
        let addr = source.replace(/\-/g, "+").replace(/_/g, "/");
        let r = parseFriendlyAddress(addr);
        return {
          isBounceable: r.isBounceable,
          isTestOnly: r.isTestOnly,
          address: new Address2(r.workchain, r.hashPart)
        };
      }
    }
    constructor(workChain, hash) {
      this.toRawString = () => {
        return this.workChain + ":" + this.hash.toString("hex");
      };
      this.toRaw = () => {
        const addressWithChecksum = Buffer.alloc(36);
        addressWithChecksum.set(this.hash);
        addressWithChecksum.set([this.workChain, this.workChain, this.workChain, this.workChain], 32);
        return addressWithChecksum;
      };
      this.toStringBuffer = (args) => {
        let testOnly = args && args.testOnly !== void 0 ? args.testOnly : false;
        let bounceable = args && args.bounceable !== void 0 ? args.bounceable : true;
        let tag = bounceable ? bounceable_tag : non_bounceable_tag;
        if (testOnly) {
          tag |= test_flag;
        }
        const addr = Buffer.alloc(34);
        addr[0] = tag;
        addr[1] = this.workChain;
        addr.set(this.hash, 2);
        const addressWithChecksum = Buffer.alloc(36);
        addressWithChecksum.set(addr);
        addressWithChecksum.set((0, crc16_1.crc16)(addr), 34);
        return addressWithChecksum;
      };
      this.toString = (args) => {
        let urlSafe = args && args.urlSafe !== void 0 ? args.urlSafe : true;
        let buffer = this.toStringBuffer(args);
        if (urlSafe) {
          return buffer.toString("base64").replace(/\+/g, "-").replace(/\//g, "_");
        } else {
          return buffer.toString("base64");
        }
      };
      this[_a] = () => this.toString();
      if (hash.length !== 32) {
        throw new Error("Invalid address hash length: " + hash.length);
      }
      this.workChain = workChain;
      this.hash = hash;
      Object.freeze(this);
    }
    equals(src2) {
      if (src2.workChain !== this.workChain) {
        return false;
      }
      return src2.hash.equals(this.hash);
    }
  }
  Address$1.Address = Address2;
  _a = symbol_inspect_1.default;
  function address(src2) {
    return Address2.parse(src2);
  }
  Address$1.address = address;
  return Address$1;
}
var ExternalAddress$1 = {};
var hasRequiredExternalAddress$1;
function requireExternalAddress$1() {
  if (hasRequiredExternalAddress$1) return ExternalAddress$1;
  hasRequiredExternalAddress$1 = 1;
  var __importDefault = ExternalAddress$1 && ExternalAddress$1.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  var _a;
  Object.defineProperty(ExternalAddress$1, "__esModule", { value: true });
  ExternalAddress$1.ExternalAddress = void 0;
  const symbol_inspect_1 = __importDefault(requireSymbol_inspect());
  class ExternalAddress2 {
    static isAddress(src2) {
      return src2 instanceof ExternalAddress2;
    }
    constructor(value, bits) {
      this[_a] = () => this.toString();
      this.value = value;
      this.bits = bits;
    }
    toString() {
      return `External<${this.bits}:${this.value}>`;
    }
  }
  ExternalAddress$1.ExternalAddress = ExternalAddress2;
  _a = symbol_inspect_1.default;
  return ExternalAddress$1;
}
var ADNLAddress$1 = {};
var base32$1 = {};
var hasRequiredBase32$1;
function requireBase32$1() {
  if (hasRequiredBase32$1) return base32$1;
  hasRequiredBase32$1 = 1;
  Object.defineProperty(base32$1, "__esModule", { value: true });
  base32$1.base32Decode = base32$1.base32Encode = void 0;
  const alphabet = "abcdefghijklmnopqrstuvwxyz234567";
  function base32Encode(buffer) {
    const length = buffer.byteLength;
    let bits = 0;
    let value = 0;
    let output = "";
    for (let i = 0; i < length; i++) {
      value = value << 8 | buffer[i];
      bits += 8;
      while (bits >= 5) {
        output += alphabet[value >>> bits - 5 & 31];
        bits -= 5;
      }
    }
    if (bits > 0) {
      output += alphabet[value << 5 - bits & 31];
    }
    return output;
  }
  base32$1.base32Encode = base32Encode;
  function readChar(alphabet2, char) {
    const idx = alphabet2.indexOf(char);
    if (idx === -1) {
      throw new Error("Invalid character found: " + char);
    }
    return idx;
  }
  function base32Decode(input) {
    let cleanedInput;
    cleanedInput = input.toLowerCase();
    const { length } = cleanedInput;
    let bits = 0;
    let value = 0;
    let index = 0;
    const output = Buffer.alloc(length * 5 / 8 | 0);
    for (let i = 0; i < length; i++) {
      value = value << 5 | readChar(alphabet, cleanedInput[i]);
      bits += 5;
      if (bits >= 8) {
        output[index++] = value >>> bits - 8 & 255;
        bits -= 8;
      }
    }
    return output;
  }
  base32$1.base32Decode = base32Decode;
  return base32$1;
}
var hasRequiredADNLAddress$1;
function requireADNLAddress$1() {
  if (hasRequiredADNLAddress$1) return ADNLAddress$1;
  hasRequiredADNLAddress$1 = 1;
  var __importDefault = ADNLAddress$1 && ADNLAddress$1.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  var _a;
  Object.defineProperty(ADNLAddress$1, "__esModule", { value: true });
  ADNLAddress$1.ADNLAddress = void 0;
  const symbol_inspect_1 = __importDefault(requireSymbol_inspect());
  const base32_1 = requireBase32$1();
  const crc16_1 = requireCrc16$1();
  class ADNLAddress2 {
    static parseFriendly(src2) {
      if (src2.length !== 55) {
        throw Error("Invalid address");
      }
      src2 = "f" + src2;
      let decoded = (0, base32_1.base32Decode)(src2);
      if (decoded[0] !== 45) {
        throw Error("Invalid address");
      }
      let gotHash = decoded.slice(33);
      let hash = (0, crc16_1.crc16)(decoded.slice(0, 33));
      if (!hash.equals(gotHash)) {
        throw Error("Invalid address");
      }
      return new ADNLAddress2(decoded.slice(1, 33));
    }
    static parseRaw(src2) {
      const data = Buffer.from(src2, "base64");
      return new ADNLAddress2(data);
    }
    constructor(address) {
      this.toRaw = () => {
        return this.address.toString("hex").toUpperCase();
      };
      this.toString = () => {
        let data = Buffer.concat([Buffer.from([45]), this.address]);
        let hash = (0, crc16_1.crc16)(data);
        data = Buffer.concat([data, hash]);
        return (0, base32_1.base32Encode)(data).slice(1);
      };
      this[_a] = () => this.toString();
      if (address.length !== 32) {
        throw Error("Invalid address");
      }
      this.address = address;
    }
    equals(b) {
      return this.address.equals(b.address);
    }
  }
  ADNLAddress$1.ADNLAddress = ADNLAddress2;
  _a = symbol_inspect_1.default;
  return ADNLAddress$1;
}
var contractAddress$1 = {};
var Builder$4 = {};
var BitBuilder$1 = {};
var BitString$1 = {};
var paddedBits$1 = {};
var hasRequiredPaddedBits$1;
function requirePaddedBits$1() {
  if (hasRequiredPaddedBits$1) return paddedBits$1;
  hasRequiredPaddedBits$1 = 1;
  Object.defineProperty(paddedBits$1, "__esModule", { value: true });
  paddedBits$1.paddedBufferToBits = paddedBits$1.bitsToPaddedBuffer = void 0;
  const BitBuilder_1 = requireBitBuilder$1();
  const BitString_1 = requireBitString$1();
  function bitsToPaddedBuffer(bits) {
    let builder2 = new BitBuilder_1.BitBuilder(Math.ceil(bits.length / 8) * 8);
    builder2.writeBits(bits);
    let padding = Math.ceil(bits.length / 8) * 8 - bits.length;
    for (let i = 0; i < padding; i++) {
      if (i === 0) {
        builder2.writeBit(1);
      } else {
        builder2.writeBit(0);
      }
    }
    return builder2.buffer();
  }
  paddedBits$1.bitsToPaddedBuffer = bitsToPaddedBuffer;
  function paddedBufferToBits(buff) {
    let bitLen = 0;
    for (let i = buff.length - 1; i >= 0; i--) {
      if (buff[i] !== 0) {
        const testByte = buff[i];
        let bitPos = testByte & -testByte;
        if ((bitPos & 1) == 0) {
          bitPos = Math.log2(bitPos) + 1;
        }
        if (i > 0) {
          bitLen = i << 3;
        }
        bitLen += 8 - bitPos;
        break;
      }
    }
    return new BitString_1.BitString(buff, 0, bitLen);
  }
  paddedBits$1.paddedBufferToBits = paddedBufferToBits;
  return paddedBits$1;
}
var hasRequiredBitString$1;
function requireBitString$1() {
  if (hasRequiredBitString$1) return BitString$1;
  hasRequiredBitString$1 = 1;
  var __importDefault = BitString$1 && BitString$1.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  var _a;
  Object.defineProperty(BitString$1, "__esModule", { value: true });
  BitString$1.BitString = void 0;
  const paddedBits_1 = requirePaddedBits$1();
  const symbol_inspect_1 = __importDefault(requireSymbol_inspect());
  class BitString2 {
    /**
     * Checks if supplied object is BitString
     * @param src is unknow object
     * @returns true if object is BitString and false otherwise
     **/
    static isBitString(src2) {
      return src2 instanceof BitString2;
    }
    /**
     * Constructing BitString from a buffer
     * @param data data that contains the bitstring data. NOTE: We are expecting this buffer to be NOT modified
     * @param offset offset in bits from the start of the buffer
     * @param length length of the bitstring in bits
     */
    constructor(data, offset, length) {
      this[_a] = () => this.toString();
      if (length < 0) {
        throw new Error(`Length ${length} is out of bounds`);
      }
      this._length = length;
      this._data = data;
      this._offset = offset;
    }
    /**
     * Returns the length of the bitstring
     */
    get length() {
      return this._length;
    }
    /**
     * Returns the bit at the specified index
     * @param index index of the bit
     * @throws Error if index is out of bounds
     * @returns true if the bit is set, false otherwise
     */
    at(index) {
      if (index >= this._length) {
        throw new Error(`Index ${index} > ${this._length} is out of bounds`);
      }
      if (index < 0) {
        throw new Error(`Index ${index} < 0 is out of bounds`);
      }
      let byteIndex = this._offset + index >> 3;
      let bitIndex = 7 - (this._offset + index) % 8;
      return (this._data[byteIndex] & 1 << bitIndex) !== 0;
    }
    /**
     * Get a subscring of the bitstring
     * @param offset
     * @param length
     * @returns
     */
    substring(offset, length) {
      if (offset > this._length) {
        throw new Error(`Offset(${offset}) > ${this._length} is out of bounds`);
      }
      if (offset < 0) {
        throw new Error(`Offset(${offset}) < 0 is out of bounds`);
      }
      if (length === 0) {
        return BitString2.EMPTY;
      }
      if (offset + length > this._length) {
        throw new Error(`Offset ${offset} + Length ${length} > ${this._length} is out of bounds`);
      }
      return new BitString2(this._data, this._offset + offset, length);
    }
    /**
     * Try to get a buffer from the bitstring without allocations
     * @param offset offset in bits
     * @param length length in bits
     * @returns buffer if the bitstring is aligned to bytes, null otherwise
     */
    subbuffer(offset, length) {
      if (offset > this._length) {
        throw new Error(`Offset ${offset} is out of bounds`);
      }
      if (offset < 0) {
        throw new Error(`Offset ${offset} is out of bounds`);
      }
      if (offset + length > this._length) {
        throw new Error(`Offset + Lenght = ${offset + length} is out of bounds`);
      }
      if (length % 8 !== 0) {
        return null;
      }
      if ((this._offset + offset) % 8 !== 0) {
        return null;
      }
      let start = this._offset + offset >> 3;
      let end2 = start + (length >> 3);
      return this._data.subarray(start, end2);
    }
    /**
     * Checks for equality
     * @param b other bitstring
     * @returns true if the bitstrings are equal, false otherwise
     */
    equals(b) {
      if (this._length !== b._length) {
        return false;
      }
      for (let i = 0; i < this._length; i++) {
        if (this.at(i) !== b.at(i)) {
          return false;
        }
      }
      return true;
    }
    /**
     * Format to canonical string
     * @returns formatted bits as a string
     */
    toString() {
      const padded = (0, paddedBits_1.bitsToPaddedBuffer)(this);
      if (this._length % 4 === 0) {
        const s = padded.subarray(0, Math.ceil(this._length / 8)).toString("hex").toUpperCase();
        if (this._length % 8 === 0) {
          return s;
        } else {
          return s.substring(0, s.length - 1);
        }
      } else {
        const hex = padded.toString("hex").toUpperCase();
        if (this._length % 8 <= 4) {
          return hex.substring(0, hex.length - 1) + "_";
        } else {
          return hex + "_";
        }
      }
    }
  }
  BitString$1.BitString = BitString2;
  _a = symbol_inspect_1.default;
  BitString2.EMPTY = new BitString2(Buffer.alloc(0), 0, 0);
  return BitString$1;
}
var hasRequiredBitBuilder$1;
function requireBitBuilder$1() {
  if (hasRequiredBitBuilder$1) return BitBuilder$1;
  hasRequiredBitBuilder$1 = 1;
  Object.defineProperty(BitBuilder$1, "__esModule", { value: true });
  BitBuilder$1.BitBuilder = void 0;
  const Address_1 = requireAddress$1();
  const ExternalAddress_1 = requireExternalAddress$1();
  const BitString_1 = requireBitString$1();
  class BitBuilder2 {
    constructor(size = 1023) {
      this._buffer = Buffer.alloc(Math.ceil(size / 8));
      this._length = 0;
    }
    /**
     * Current number of bits written
     */
    get length() {
      return this._length;
    }
    /**
     * Write a single bit
     * @param value bit to write, true or positive number for 1, false or zero or negative for 0
     */
    writeBit(value) {
      let n = this._length;
      if (n > this._buffer.length * 8) {
        throw new Error("BitBuilder overflow");
      }
      if (typeof value === "boolean" && value === true || typeof value === "number" && value > 0) {
        this._buffer[n / 8 | 0] |= 1 << 7 - n % 8;
      }
      this._length++;
    }
    /**
     * Copy bits from BitString
     * @param src source bits
     */
    writeBits(src2) {
      for (let i = 0; i < src2.length; i++) {
        this.writeBit(src2.at(i));
      }
    }
    /**
     * Write bits from buffer
     * @param src source buffer
     */
    writeBuffer(src2) {
      if (this._length % 8 === 0) {
        if (this._length + src2.length * 8 > this._buffer.length * 8) {
          throw new Error("BitBuilder overflow");
        }
        src2.copy(this._buffer, this._length / 8);
        this._length += src2.length * 8;
      } else {
        for (let i = 0; i < src2.length; i++) {
          this.writeUint(src2[i], 8);
        }
      }
    }
    /**
     * Write uint value
     * @param value value as bigint or number
     * @param bits number of bits to write
     */
    writeUint(value, bits) {
      if (bits < 0 || !Number.isSafeInteger(bits)) {
        throw Error(`invalid bit length. Got ${bits}`);
      }
      const v2 = BigInt(value);
      if (bits === 0) {
        if (v2 !== 0n) {
          throw Error(`value is not zero for ${bits} bits. Got ${value}`);
        } else {
          return;
        }
      }
      const vBits = 1n << BigInt(bits);
      if (v2 < 0 || v2 >= vBits) {
        throw Error(`bitLength is too small for a value ${value}. Got ${bits}`);
      }
      if (this._length + bits > this._buffer.length * 8) {
        throw new Error("BitBuilder overflow");
      }
      const tillByte = 8 - this._length % 8;
      if (tillByte > 0) {
        const bidx = Math.floor(this._length / 8);
        if (bits < tillByte) {
          const wb = Number(v2);
          this._buffer[bidx] |= wb << tillByte - bits;
          this._length += bits;
        } else {
          const wb = Number(v2 >> BigInt(bits - tillByte));
          this._buffer[bidx] |= wb;
          this._length += tillByte;
        }
      }
      bits -= tillByte;
      while (bits > 0) {
        if (bits >= 8) {
          this._buffer[this._length / 8] = Number(v2 >> BigInt(bits - 8) & 0xffn);
          this._length += 8;
          bits -= 8;
        } else {
          this._buffer[this._length / 8] = Number(v2 << BigInt(8 - bits) & 0xffn);
          this._length += bits;
          bits = 0;
        }
      }
    }
    /**
     * Write int value
     * @param value value as bigint or number
     * @param bits number of bits to write
     */
    writeInt(value, bits) {
      let v2 = BigInt(value);
      if (bits < 0 || !Number.isSafeInteger(bits)) {
        throw Error(`invalid bit length. Got ${bits}`);
      }
      if (bits === 0) {
        if (v2 !== 0n) {
          throw Error(`value is not zero for ${bits} bits. Got ${value}`);
        } else {
          return;
        }
      }
      if (bits === 1) {
        if (v2 !== -1n && v2 !== 0n) {
          throw Error(`value is not zero or -1 for ${bits} bits. Got ${value}`);
        } else {
          this.writeBit(v2 === -1n);
          return;
        }
      }
      let vBits = 1n << BigInt(bits) - 1n;
      if (v2 < -vBits || v2 >= vBits) {
        throw Error(`value is out of range for ${bits} bits. Got ${value}`);
      }
      if (v2 < 0) {
        this.writeBit(true);
        v2 = vBits + v2;
      } else {
        this.writeBit(false);
      }
      this.writeUint(v2, bits - 1);
    }
    /**
     * Wrtie var uint value, used for serializing coins
     * @param value value to write as bigint or number
     * @param bits header bits to write size
     */
    writeVarUint(value, bits) {
      let v2 = BigInt(value);
      if (bits < 0 || !Number.isSafeInteger(bits)) {
        throw Error(`invalid bit length. Got ${bits}`);
      }
      if (v2 < 0) {
        throw Error(`value is negative. Got ${value}`);
      }
      if (v2 === 0n) {
        this.writeUint(0, bits);
        return;
      }
      const sizeBytes = Math.ceil(v2.toString(2).length / 8);
      const sizeBits = sizeBytes * 8;
      this.writeUint(sizeBytes, bits);
      this.writeUint(v2, sizeBits);
    }
    /**
     * Wrtie var int value, used for serializing coins
     * @param value value to write as bigint or number
     * @param bits header bits to write size
     */
    writeVarInt(value, bits) {
      let v2 = BigInt(value);
      if (bits < 0 || !Number.isSafeInteger(bits)) {
        throw Error(`invalid bit length. Got ${bits}`);
      }
      if (v2 === 0n) {
        this.writeUint(0, bits);
        return;
      }
      let v22 = v2 > 0 ? v2 : -v2;
      const sizeBytes = Math.ceil((v22.toString(2).length + 1) / 8);
      const sizeBits = sizeBytes * 8;
      this.writeUint(sizeBytes, bits);
      this.writeInt(v2, sizeBits);
    }
    /**
     * Write coins in var uint format
     * @param amount amount to write
     */
    writeCoins(amount) {
      this.writeVarUint(amount, 4);
    }
    /**
     * Write address
     * @param address write address or address external
     */
    writeAddress(address) {
      if (address === null || address === void 0) {
        this.writeUint(0, 2);
        return;
      }
      if (Address_1.Address.isAddress(address)) {
        this.writeUint(2, 2);
        this.writeUint(0, 1);
        this.writeInt(address.workChain, 8);
        this.writeBuffer(address.hash);
        return;
      }
      if (ExternalAddress_1.ExternalAddress.isAddress(address)) {
        this.writeUint(1, 2);
        this.writeUint(address.bits, 9);
        this.writeUint(address.value, address.bits);
        return;
      }
      throw Error(`Invalid address. Got ${address}`);
    }
    /**
     * Build BitString
     * @returns result bit string
     */
    build() {
      return new BitString_1.BitString(this._buffer, 0, this._length);
    }
    /**
     * Build into Buffer
     * @returns result buffer
     */
    buffer() {
      if (this._length % 8 !== 0) {
        throw new Error("BitBuilder buffer is not byte aligned");
      }
      return this._buffer.subarray(0, this._length / 8);
    }
  }
  BitBuilder$1.BitBuilder = BitBuilder2;
  return BitBuilder$1;
}
var Cell$1 = {};
var CellType$1 = {};
var hasRequiredCellType$1;
function requireCellType$1() {
  if (hasRequiredCellType$1) return CellType$1;
  hasRequiredCellType$1 = 1;
  Object.defineProperty(CellType$1, "__esModule", { value: true });
  CellType$1.CellType = void 0;
  var CellType2;
  (function(CellType3) {
    CellType3[CellType3["Ordinary"] = -1] = "Ordinary";
    CellType3[CellType3["PrunedBranch"] = 1] = "PrunedBranch";
    CellType3[CellType3["Library"] = 2] = "Library";
    CellType3[CellType3["MerkleProof"] = 3] = "MerkleProof";
    CellType3[CellType3["MerkleUpdate"] = 4] = "MerkleUpdate";
  })(CellType2 || (CellType$1.CellType = CellType2 = {}));
  return CellType$1;
}
var Slice$1 = {};
var Dictionary$1 = {};
var generateMerkleProof$1 = {};
var readUnaryLength$1 = {};
var hasRequiredReadUnaryLength$1;
function requireReadUnaryLength$1() {
  if (hasRequiredReadUnaryLength$1) return readUnaryLength$1;
  hasRequiredReadUnaryLength$1 = 1;
  Object.defineProperty(readUnaryLength$1, "__esModule", { value: true });
  readUnaryLength$1.readUnaryLength = void 0;
  function readUnaryLength2(slice) {
    let res = 0;
    while (slice.loadBit()) {
      res++;
    }
    return res;
  }
  readUnaryLength$1.readUnaryLength = readUnaryLength2;
  return readUnaryLength$1;
}
var exoticMerkleProof$1 = {};
var BitReader$1 = {};
var hasRequiredBitReader$1;
function requireBitReader$1() {
  if (hasRequiredBitReader$1) return BitReader$1;
  hasRequiredBitReader$1 = 1;
  Object.defineProperty(BitReader$1, "__esModule", { value: true });
  BitReader$1.BitReader = void 0;
  const Address_1 = requireAddress$1();
  const ExternalAddress_1 = requireExternalAddress$1();
  class BitReader2 {
    constructor(bits, offset = 0) {
      this._checkpoints = [];
      this._bits = bits;
      this._offset = offset;
    }
    /**
     * Offset in source bit string
     */
    get offset() {
      return this._offset;
    }
    /**
     * Number of bits remaining
     */
    get remaining() {
      return this._bits.length - this._offset;
    }
    /**
     * Skip bits
     * @param bits number of bits to skip
     */
    skip(bits) {
      if (bits < 0 || this._offset + bits > this._bits.length) {
        throw new Error(`Index ${this._offset + bits} is out of bounds`);
      }
      this._offset += bits;
    }
    /**
     * Reset to the beginning or latest checkpoint
     */
    reset() {
      if (this._checkpoints.length > 0) {
        this._offset = this._checkpoints.pop();
      } else {
        this._offset = 0;
      }
    }
    /**
     * Save checkpoint
     */
    save() {
      this._checkpoints.push(this._offset);
    }
    /**
     * Load a single bit
     * @returns true if the bit is set, false otherwise
     */
    loadBit() {
      let r = this._bits.at(this._offset);
      this._offset++;
      return r;
    }
    /**
     * Preload bit
     * @returns true if the bit is set, false otherwise
     */
    preloadBit() {
      return this._bits.at(this._offset);
    }
    /**
     * Load bit string
     * @param bits number of bits to read
     * @returns new bitstring
     */
    loadBits(bits) {
      let r = this._bits.substring(this._offset, bits);
      this._offset += bits;
      return r;
    }
    /**
     * Preload bit string
     * @param bits number of bits to read
     * @returns new bitstring
     */
    preloadBits(bits) {
      return this._bits.substring(this._offset, bits);
    }
    /**
     * Load buffer
     * @param bytes number of bytes
     * @returns new buffer
     */
    loadBuffer(bytes) {
      let buf = this._preloadBuffer(bytes, this._offset);
      this._offset += bytes * 8;
      return buf;
    }
    /**
     * Preload buffer
     * @param bytes number of bytes
     * @returns new buffer
     */
    preloadBuffer(bytes) {
      return this._preloadBuffer(bytes, this._offset);
    }
    /**
     * Load uint value
     * @param bits uint bits
     * @returns read value as number
     */
    loadUint(bits) {
      return this._toSafeInteger(this.loadUintBig(bits), "loadUintBig");
    }
    /**
     * Load uint value as bigint
     * @param bits uint bits
     * @returns read value as bigint
     */
    loadUintBig(bits) {
      let loaded = this.preloadUintBig(bits);
      this._offset += bits;
      return loaded;
    }
    /**
     * Preload uint value
     * @param bits uint bits
     * @returns read value as number
     */
    preloadUint(bits) {
      return this._toSafeInteger(this._preloadUint(bits, this._offset), "preloadUintBig");
    }
    /**
     * Preload uint value as bigint
     * @param bits uint bits
     * @returns read value as bigint
     */
    preloadUintBig(bits) {
      return this._preloadUint(bits, this._offset);
    }
    /**
     * Load int value
     * @param bits int bits
     * @returns read value as bigint
     */
    loadInt(bits) {
      let res = this._preloadInt(bits, this._offset);
      this._offset += bits;
      return this._toSafeInteger(res, "loadUintBig");
    }
    /**
     * Load int value as bigint
     * @param bits int bits
     * @returns read value as bigint
     */
    loadIntBig(bits) {
      let res = this._preloadInt(bits, this._offset);
      this._offset += bits;
      return res;
    }
    /**
     * Preload int value
     * @param bits int bits
     * @returns read value as bigint
     */
    preloadInt(bits) {
      return this._toSafeInteger(this._preloadInt(bits, this._offset), "preloadIntBig");
    }
    /**
     * Preload int value
     * @param bits int bits
     * @returns read value as bigint
     */
    preloadIntBig(bits) {
      return this._preloadInt(bits, this._offset);
    }
    /**
     * Load varuint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    loadVarUint(bits) {
      let size = Number(this.loadUint(bits));
      return this._toSafeInteger(this.loadUintBig(size * 8), "loadVarUintBig");
    }
    /**
     * Load varuint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    loadVarUintBig(bits) {
      let size = Number(this.loadUint(bits));
      return this.loadUintBig(size * 8);
    }
    /**
     * Preload varuint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    preloadVarUint(bits) {
      let size = Number(this._preloadUint(bits, this._offset));
      return this._toSafeInteger(this._preloadUint(size * 8, this._offset + bits), "preloadVarUintBig");
    }
    /**
     * Preload varuint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    preloadVarUintBig(bits) {
      let size = Number(this._preloadUint(bits, this._offset));
      return this._preloadUint(size * 8, this._offset + bits);
    }
    /**
     * Load varint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    loadVarInt(bits) {
      let size = Number(this.loadUint(bits));
      return this._toSafeInteger(this.loadIntBig(size * 8), "loadVarIntBig");
    }
    /**
     * Load varint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    loadVarIntBig(bits) {
      let size = Number(this.loadUint(bits));
      return this.loadIntBig(size * 8);
    }
    /**
     * Preload varint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    preloadVarInt(bits) {
      let size = Number(this._preloadUint(bits, this._offset));
      return this._toSafeInteger(this._preloadInt(size * 8, this._offset + bits), "preloadVarIntBig");
    }
    /**
     * Preload varint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    preloadVarIntBig(bits) {
      let size = Number(this._preloadUint(bits, this._offset));
      return this._preloadInt(size * 8, this._offset + bits);
    }
    /**
     * Load coins value
     * @returns read value as bigint
     */
    loadCoins() {
      return this.loadVarUintBig(4);
    }
    /**
     * Preload coins value
     * @returns read value as bigint
     */
    preloadCoins() {
      return this.preloadVarUintBig(4);
    }
    /**
     * Load Address
     * @returns Address
     */
    loadAddress() {
      let type = Number(this._preloadUint(2, this._offset));
      if (type === 2) {
        return this._loadInternalAddress();
      } else {
        throw new Error("Invalid address: " + type);
      }
    }
    /**
     * Load internal address
     * @returns Address or null
     */
    loadMaybeAddress() {
      let type = Number(this._preloadUint(2, this._offset));
      if (type === 0) {
        this._offset += 2;
        return null;
      } else if (type === 2) {
        return this._loadInternalAddress();
      } else {
        throw new Error("Invalid address");
      }
    }
    /**
     * Load external address
     * @returns ExternalAddress
     */
    loadExternalAddress() {
      let type = Number(this._preloadUint(2, this._offset));
      if (type === 1) {
        return this._loadExternalAddress();
      } else {
        throw new Error("Invalid address");
      }
    }
    /**
     * Load external address
     * @returns ExternalAddress or null
     */
    loadMaybeExternalAddress() {
      let type = Number(this._preloadUint(2, this._offset));
      if (type === 0) {
        this._offset += 2;
        return null;
      } else if (type === 1) {
        return this._loadExternalAddress();
      } else {
        throw new Error("Invalid address");
      }
    }
    /**
     * Read address of any type
     * @returns Address or ExternalAddress or null
     */
    loadAddressAny() {
      let type = Number(this._preloadUint(2, this._offset));
      if (type === 0) {
        this._offset += 2;
        return null;
      } else if (type === 2) {
        return this._loadInternalAddress();
      } else if (type === 1) {
        return this._loadExternalAddress();
      } else if (type === 3) {
        throw Error("Unsupported");
      } else {
        throw Error("Unreachable");
      }
    }
    /**
     * Load bit string that was padded to make it byte alligned. Used in BOC serialization
     * @param bytes number of bytes to read
     */
    loadPaddedBits(bits) {
      if (bits % 8 !== 0) {
        throw new Error("Invalid number of bits");
      }
      let length = bits;
      while (true) {
        if (this._bits.at(this._offset + length - 1)) {
          length--;
          break;
        } else {
          length--;
        }
      }
      let r = this._bits.substring(this._offset, length);
      this._offset += bits;
      return r;
    }
    /**
     * Clone BitReader
     */
    clone() {
      return new BitReader2(this._bits, this._offset);
    }
    /**
     * Preload int from specific offset
     * @param bits bits to preload
     * @param offset offset to start from
     * @returns read value as bigint
     */
    _preloadInt(bits, offset) {
      if (bits == 0) {
        return 0n;
      }
      let sign = this._bits.at(offset);
      let res = 0n;
      for (let i = 0; i < bits - 1; i++) {
        if (this._bits.at(offset + 1 + i)) {
          res += 1n << BigInt(bits - i - 1 - 1);
        }
      }
      if (sign) {
        res = res - (1n << BigInt(bits - 1));
      }
      return res;
    }
    /**
     * Preload uint from specific offset
     * @param bits bits to preload
     * @param offset offset to start from
     * @returns read value as bigint
     */
    _preloadUint(bits, offset) {
      if (bits == 0) {
        return 0n;
      }
      let res = 0n;
      for (let i = 0; i < bits; i++) {
        if (this._bits.at(offset + i)) {
          res += 1n << BigInt(bits - i - 1);
        }
      }
      return res;
    }
    _preloadBuffer(bytes, offset) {
      let fastBuffer = this._bits.subbuffer(offset, bytes * 8);
      if (fastBuffer) {
        return fastBuffer;
      }
      let buf = Buffer.alloc(bytes);
      for (let i = 0; i < bytes; i++) {
        buf[i] = Number(this._preloadUint(8, offset + i * 8));
      }
      return buf;
    }
    _loadInternalAddress() {
      let type = Number(this._preloadUint(2, this._offset));
      if (type !== 2) {
        throw Error("Invalid address");
      }
      let rewrite_pfx = void 0;
      let rewrite_depth = void 0;
      if (this._preloadUint(1, this._offset + 2) !== 0n) {
        rewrite_depth = Number(this._preloadUint(5, this._offset + 3));
        rewrite_pfx = this._preloadUint(rewrite_depth, this._offset + 8);
        this._offset += 5 + rewrite_depth;
      }
      let wc = Number(this._preloadInt(8, this._offset + 3));
      let hash = this._preloadBuffer(32, this._offset + 11);
      if (rewrite_depth !== void 0 && rewrite_pfx !== void 0) {
        let pfx = Number(rewrite_pfx);
        let byteIndex = 0;
        let bitIndex = 0;
        let bitsRemaining = rewrite_depth;
        while (bitsRemaining > 0) {
          let bitsInThisByte = Math.min(8 - bitIndex, bitsRemaining);
          let mask = (1 << bitsInThisByte) - 1 << 8 - bitIndex - bitsInThisByte;
          let bits = (pfx >> bitsRemaining - bitsInThisByte & (1 << bitsInThisByte) - 1) << 8 - bitIndex - bitsInThisByte;
          hash[byteIndex] = hash[byteIndex] & ~mask | bits;
          bitsRemaining -= bitsInThisByte;
          bitIndex += bitsInThisByte;
          if (bitIndex === 8) {
            byteIndex++;
            bitIndex = 0;
          }
        }
      }
      this._offset += 267;
      return new Address_1.Address(wc, hash);
    }
    _loadExternalAddress() {
      let type = Number(this._preloadUint(2, this._offset));
      if (type !== 1) {
        throw Error("Invalid address");
      }
      let bits = Number(this._preloadUint(9, this._offset + 2));
      let value = this._preloadUint(bits, this._offset + 11);
      this._offset += 11 + bits;
      return new ExternalAddress_1.ExternalAddress(value, bits);
    }
    _toSafeInteger(src2, alt) {
      if (BigInt(Number.MAX_SAFE_INTEGER) < src2 || src2 < BigInt(Number.MIN_SAFE_INTEGER)) {
        throw new TypeError(`${src2} is out of safe integer range. Use ${alt} instead`);
      }
      return Number(src2);
    }
  }
  BitReader$1.BitReader = BitReader2;
  return BitReader$1;
}
var hasRequiredExoticMerkleProof$1;
function requireExoticMerkleProof$1() {
  if (hasRequiredExoticMerkleProof$1) return exoticMerkleProof$1;
  hasRequiredExoticMerkleProof$1 = 1;
  Object.defineProperty(exoticMerkleProof$1, "__esModule", { value: true });
  exoticMerkleProof$1.convertToMerkleProof = exoticMerkleProof$1.exoticMerkleProof = void 0;
  const BitReader_1 = requireBitReader$1();
  const Builder_12 = requireBuilder$3();
  function exoticMerkleProof2(bits, refs) {
    const reader2 = new BitReader_1.BitReader(bits);
    const size = 8 + 256 + 16;
    if (bits.length !== size) {
      throw new Error(`Merkle Proof cell must have exactly (8 + 256 + 16) bits, got "${bits.length}"`);
    }
    if (refs.length !== 1) {
      throw new Error(`Merkle Proof cell must have exactly 1 ref, got "${refs.length}"`);
    }
    let type = reader2.loadUint(8);
    if (type !== 3) {
      throw new Error(`Merkle Proof cell must have type 3, got "${type}"`);
    }
    const proofHash = reader2.loadBuffer(32);
    const proofDepth = reader2.loadUint(16);
    const refHash = refs[0].hash(0);
    const refDepth = refs[0].depth(0);
    if (proofDepth !== refDepth) {
      throw new Error(`Merkle Proof cell ref depth must be exactly "${proofDepth}", got "${refDepth}"`);
    }
    if (!proofHash.equals(refHash)) {
      throw new Error(`Merkle Proof cell ref hash must be exactly "${proofHash.toString("hex")}", got "${refHash.toString("hex")}"`);
    }
    return {
      proofDepth,
      proofHash
    };
  }
  exoticMerkleProof$1.exoticMerkleProof = exoticMerkleProof2;
  function convertToMerkleProof(c) {
    return (0, Builder_12.beginCell)().storeUint(3, 8).storeBuffer(c.hash(0)).storeUint(c.depth(0), 16).storeRef(c).endCell({ exotic: true });
  }
  exoticMerkleProof$1.convertToMerkleProof = convertToMerkleProof;
  return exoticMerkleProof$1;
}
var hasRequiredGenerateMerkleProof$1;
function requireGenerateMerkleProof$1() {
  if (hasRequiredGenerateMerkleProof$1) return generateMerkleProof$1;
  hasRequiredGenerateMerkleProof$1 = 1;
  Object.defineProperty(generateMerkleProof$1, "__esModule", { value: true });
  generateMerkleProof$1.generateMerkleProof = generateMerkleProof$1.generateMerkleProofDirect = void 0;
  const Builder_12 = requireBuilder$3();
  const readUnaryLength_1 = requireReadUnaryLength$1();
  const exoticMerkleProof_1 = requireExoticMerkleProof$1();
  function convertToPrunedBranch(c) {
    return (0, Builder_12.beginCell)().storeUint(1, 8).storeUint(1, 8).storeBuffer(c.hash(0)).storeUint(c.depth(0), 16).endCell({ exotic: true });
  }
  function doGenerateMerkleProof(prefix, slice, n, keys) {
    const originalCell = slice.asCell();
    if (keys.length == 0) {
      return convertToPrunedBranch(originalCell);
    }
    let lb0 = slice.loadBit() ? 1 : 0;
    let prefixLength = 0;
    let pp = prefix;
    if (lb0 === 0) {
      prefixLength = (0, readUnaryLength_1.readUnaryLength)(slice);
      for (let i = 0; i < prefixLength; i++) {
        pp += slice.loadBit() ? "1" : "0";
      }
    } else {
      let lb1 = slice.loadBit() ? 1 : 0;
      if (lb1 === 0) {
        prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));
        for (let i = 0; i < prefixLength; i++) {
          pp += slice.loadBit() ? "1" : "0";
        }
      } else {
        let bit = slice.loadBit() ? "1" : "0";
        prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));
        for (let i = 0; i < prefixLength; i++) {
          pp += bit;
        }
      }
    }
    if (n - prefixLength === 0) {
      return originalCell;
    } else {
      let sl = originalCell.beginParse();
      let left = sl.loadRef();
      let right = sl.loadRef();
      if (!left.isExotic) {
        const leftKeys = keys.filter((key2) => {
          return pp + "0" === key2.slice(0, pp.length + 1);
        });
        left = doGenerateMerkleProof(pp + "0", left.beginParse(), n - prefixLength - 1, leftKeys);
      }
      if (!right.isExotic) {
        const rightKeys = keys.filter((key2) => {
          return pp + "1" === key2.slice(0, pp.length + 1);
        });
        right = doGenerateMerkleProof(pp + "1", right.beginParse(), n - prefixLength - 1, rightKeys);
      }
      return (0, Builder_12.beginCell)().storeSlice(sl).storeRef(left).storeRef(right).endCell();
    }
  }
  function generateMerkleProofDirect(dict, keys, keyObject) {
    keys.forEach((key2) => {
      if (!dict.has(key2)) {
        throw new Error(`Trying to generate merkle proof for a missing key "${key2}"`);
      }
    });
    const s = (0, Builder_12.beginCell)().storeDictDirect(dict).asSlice();
    return doGenerateMerkleProof("", s, keyObject.bits, keys.map((key2) => keyObject.serialize(key2).toString(2).padStart(keyObject.bits, "0")));
  }
  generateMerkleProof$1.generateMerkleProofDirect = generateMerkleProofDirect;
  function generateMerkleProof2(dict, keys, keyObject) {
    return (0, exoticMerkleProof_1.convertToMerkleProof)(generateMerkleProofDirect(dict, keys, keyObject));
  }
  generateMerkleProof$1.generateMerkleProof = generateMerkleProof2;
  return generateMerkleProof$1;
}
var generateMerkleUpdate$1 = {};
var hasRequiredGenerateMerkleUpdate$1;
function requireGenerateMerkleUpdate$1() {
  if (hasRequiredGenerateMerkleUpdate$1) return generateMerkleUpdate$1;
  hasRequiredGenerateMerkleUpdate$1 = 1;
  Object.defineProperty(generateMerkleUpdate$1, "__esModule", { value: true });
  generateMerkleUpdate$1.generateMerkleUpdate = void 0;
  const Builder_12 = requireBuilder$3();
  const generateMerkleProof_1 = requireGenerateMerkleProof$1();
  function convertToMerkleUpdate(c1, c2) {
    return (0, Builder_12.beginCell)().storeUint(4, 8).storeBuffer(c1.hash(0)).storeBuffer(c2.hash(0)).storeUint(c1.depth(0), 16).storeUint(c2.depth(0), 16).storeRef(c1).storeRef(c2).endCell({ exotic: true });
  }
  function generateMerkleUpdate2(dict, key2, keyObject, newValue) {
    const oldProof = (0, generateMerkleProof_1.generateMerkleProof)(dict, [key2], keyObject).refs[0];
    dict.set(key2, newValue);
    const newProof = (0, generateMerkleProof_1.generateMerkleProof)(dict, [key2], keyObject).refs[0];
    return convertToMerkleUpdate(oldProof, newProof);
  }
  generateMerkleUpdate$1.generateMerkleUpdate = generateMerkleUpdate2;
  return generateMerkleUpdate$1;
}
var parseDict$1 = {};
var hasRequiredParseDict$1;
function requireParseDict$1() {
  if (hasRequiredParseDict$1) return parseDict$1;
  hasRequiredParseDict$1 = 1;
  Object.defineProperty(parseDict$1, "__esModule", { value: true });
  parseDict$1.parseDict = void 0;
  function readUnaryLength2(slice) {
    let res = 0;
    while (slice.loadBit()) {
      res++;
    }
    return res;
  }
  function doParse(prefix, slice, n, res, extractor) {
    let lb0 = slice.loadBit() ? 1 : 0;
    let prefixLength = 0;
    let pp = prefix;
    if (lb0 === 0) {
      prefixLength = readUnaryLength2(slice);
      for (let i = 0; i < prefixLength; i++) {
        pp += slice.loadBit() ? "1" : "0";
      }
    } else {
      let lb1 = slice.loadBit() ? 1 : 0;
      if (lb1 === 0) {
        prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));
        for (let i = 0; i < prefixLength; i++) {
          pp += slice.loadBit() ? "1" : "0";
        }
      } else {
        let bit = slice.loadBit() ? "1" : "0";
        prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));
        for (let i = 0; i < prefixLength; i++) {
          pp += bit;
        }
      }
    }
    if (n - prefixLength === 0) {
      res.set(BigInt("0b" + pp), extractor(slice));
    } else {
      let left = slice.loadRef();
      let right = slice.loadRef();
      if (!left.isExotic) {
        doParse(pp + "0", left.beginParse(), n - prefixLength - 1, res, extractor);
      }
      if (!right.isExotic) {
        doParse(pp + "1", right.beginParse(), n - prefixLength - 1, res, extractor);
      }
    }
  }
  function parseDict2(sc, keySize, extractor) {
    let res = /* @__PURE__ */ new Map();
    if (sc) {
      doParse("", sc, keySize, res, extractor);
    }
    return res;
  }
  parseDict$1.parseDict = parseDict2;
  return parseDict$1;
}
var serializeDict$1 = {};
var findCommonPrefix$1 = {};
var hasRequiredFindCommonPrefix$1;
function requireFindCommonPrefix$1() {
  if (hasRequiredFindCommonPrefix$1) return findCommonPrefix$1;
  hasRequiredFindCommonPrefix$1 = 1;
  Object.defineProperty(findCommonPrefix$1, "__esModule", { value: true });
  findCommonPrefix$1.findCommonPrefix = void 0;
  function findCommonPrefix2(src2, startPos = 0) {
    if (src2.length === 0) {
      return "";
    }
    let r = src2[0].slice(startPos);
    for (let i = 1; i < src2.length; i++) {
      const s = src2[i];
      while (s.indexOf(r, startPos) !== startPos) {
        r = r.substring(0, r.length - 1);
        if (r === "") {
          return r;
        }
      }
    }
    return r;
  }
  findCommonPrefix$1.findCommonPrefix = findCommonPrefix2;
  return findCommonPrefix$1;
}
var hasRequiredSerializeDict$1;
function requireSerializeDict$1() {
  if (hasRequiredSerializeDict$1) return serializeDict$1;
  hasRequiredSerializeDict$1 = 1;
  Object.defineProperty(serializeDict$1, "__esModule", { value: true });
  serializeDict$1.serializeDict = serializeDict$1.detectLabelType = serializeDict$1.writeLabelSame = serializeDict$1.writeLabelLong = serializeDict$1.writeLabelShort = serializeDict$1.buildTree = void 0;
  const Builder_12 = requireBuilder$3();
  const findCommonPrefix_1 = requireFindCommonPrefix$1();
  function pad(src2, size) {
    while (src2.length < size) {
      src2 = "0" + src2;
    }
    return src2;
  }
  function forkMap(src2, prefixLen) {
    if (src2.size === 0) {
      throw Error("Internal inconsistency");
    }
    let left = /* @__PURE__ */ new Map();
    let right = /* @__PURE__ */ new Map();
    for (let [k, d] of src2.entries()) {
      if (k[prefixLen] === "0") {
        left.set(k, d);
      } else {
        right.set(k, d);
      }
    }
    if (left.size === 0) {
      throw Error("Internal inconsistency. Left emtpy.");
    }
    if (right.size === 0) {
      throw Error("Internal inconsistency. Right emtpy.");
    }
    return { left, right };
  }
  function buildNode(src2, prefixLen) {
    if (src2.size === 0) {
      throw Error("Internal inconsistency");
    }
    if (src2.size === 1) {
      return { type: "leaf", value: Array.from(src2.values())[0] };
    }
    let { left, right } = forkMap(src2, prefixLen);
    return {
      type: "fork",
      left: buildEdge(left, prefixLen + 1),
      right: buildEdge(right, prefixLen + 1)
    };
  }
  function buildEdge(src2, prefixLen = 0) {
    if (src2.size === 0) {
      throw Error("Internal inconsistency");
    }
    const label = (0, findCommonPrefix_1.findCommonPrefix)(Array.from(src2.keys()), prefixLen);
    return { label, node: buildNode(src2, label.length + prefixLen) };
  }
  function buildTree(src2, keyLength) {
    let converted = /* @__PURE__ */ new Map();
    for (let k of Array.from(src2.keys())) {
      const padded = pad(k.toString(2), keyLength);
      converted.set(padded, src2.get(k));
    }
    return buildEdge(converted);
  }
  serializeDict$1.buildTree = buildTree;
  function writeLabelShort(src2, to) {
    to.storeBit(0);
    for (let i = 0; i < src2.length; i++) {
      to.storeBit(1);
    }
    to.storeBit(0);
    if (src2.length > 0) {
      to.storeUint(BigInt("0b" + src2), src2.length);
    }
    return to;
  }
  serializeDict$1.writeLabelShort = writeLabelShort;
  function labelShortLength(src2) {
    return 1 + src2.length + 1 + src2.length;
  }
  function writeLabelLong(src2, keyLength, to) {
    to.storeBit(1);
    to.storeBit(0);
    let length = Math.ceil(Math.log2(keyLength + 1));
    to.storeUint(src2.length, length);
    if (src2.length > 0) {
      to.storeUint(BigInt("0b" + src2), src2.length);
    }
    return to;
  }
  serializeDict$1.writeLabelLong = writeLabelLong;
  function labelLongLength(src2, keyLength) {
    return 1 + 1 + Math.ceil(Math.log2(keyLength + 1)) + src2.length;
  }
  function writeLabelSame(value, length, keyLength, to) {
    to.storeBit(1);
    to.storeBit(1);
    to.storeBit(value);
    let lenLen = Math.ceil(Math.log2(keyLength + 1));
    to.storeUint(length, lenLen);
  }
  serializeDict$1.writeLabelSame = writeLabelSame;
  function labelSameLength(keyLength) {
    return 1 + 1 + 1 + Math.ceil(Math.log2(keyLength + 1));
  }
  function isSame(src2) {
    if (src2.length === 0 || src2.length === 1) {
      return true;
    }
    for (let i = 1; i < src2.length; i++) {
      if (src2[i] !== src2[0]) {
        return false;
      }
    }
    return true;
  }
  function detectLabelType(src2, keyLength) {
    let kind = "short";
    let kindLength = labelShortLength(src2);
    let longLength = labelLongLength(src2, keyLength);
    if (longLength < kindLength) {
      kindLength = longLength;
      kind = "long";
    }
    if (isSame(src2)) {
      let sameLength = labelSameLength(keyLength);
      if (sameLength < kindLength) {
        kindLength = sameLength;
        kind = "same";
      }
    }
    return kind;
  }
  serializeDict$1.detectLabelType = detectLabelType;
  function writeLabel(src2, keyLength, to) {
    let type = detectLabelType(src2, keyLength);
    if (type === "short") {
      writeLabelShort(src2, to);
    } else if (type === "long") {
      writeLabelLong(src2, keyLength, to);
    } else if (type === "same") {
      writeLabelSame(src2[0] === "1", src2.length, keyLength, to);
    }
  }
  function writeNode(src2, keyLength, serializer, to) {
    if (src2.type === "leaf") {
      serializer(src2.value, to);
    }
    if (src2.type === "fork") {
      const leftCell = (0, Builder_12.beginCell)();
      const rightCell = (0, Builder_12.beginCell)();
      writeEdge(src2.left, keyLength - 1, serializer, leftCell);
      writeEdge(src2.right, keyLength - 1, serializer, rightCell);
      to.storeRef(leftCell);
      to.storeRef(rightCell);
    }
  }
  function writeEdge(src2, keyLength, serializer, to) {
    writeLabel(src2.label, keyLength, to);
    writeNode(src2.node, keyLength - src2.label.length, serializer, to);
  }
  function serializeDict2(src2, keyLength, serializer, to) {
    const tree = buildTree(src2, keyLength);
    writeEdge(tree, keyLength, serializer, to);
  }
  serializeDict$1.serializeDict = serializeDict2;
  return serializeDict$1;
}
var internalKeySerializer$1 = {};
var hasRequiredInternalKeySerializer$1;
function requireInternalKeySerializer$1() {
  if (hasRequiredInternalKeySerializer$1) return internalKeySerializer$1;
  hasRequiredInternalKeySerializer$1 = 1;
  Object.defineProperty(internalKeySerializer$1, "__esModule", { value: true });
  internalKeySerializer$1.deserializeInternalKey = internalKeySerializer$1.serializeInternalKey = void 0;
  const Address_1 = requireAddress$1();
  const BitString_1 = requireBitString$1();
  const paddedBits_1 = requirePaddedBits$1();
  function serializeInternalKey(value) {
    if (typeof value === "number") {
      if (!Number.isSafeInteger(value)) {
        throw Error("Invalid key type: not a safe integer: " + value);
      }
      return "n:" + value.toString(10);
    } else if (typeof value === "bigint") {
      return "b:" + value.toString(10);
    } else if (Address_1.Address.isAddress(value)) {
      return "a:" + value.toString();
    } else if (Buffer.isBuffer(value)) {
      return "f:" + value.toString("hex");
    } else if (BitString_1.BitString.isBitString(value)) {
      return "B:" + value.toString();
    } else {
      throw Error("Invalid key type");
    }
  }
  internalKeySerializer$1.serializeInternalKey = serializeInternalKey;
  function deserializeInternalKey(value) {
    let k = value.slice(0, 2);
    let v2 = value.slice(2);
    if (k === "n:") {
      return parseInt(v2, 10);
    } else if (k === "b:") {
      return BigInt(v2);
    } else if (k === "a:") {
      return Address_1.Address.parse(v2);
    } else if (k === "f:") {
      return Buffer.from(v2, "hex");
    } else if (k === "B:") {
      const lastDash = v2.slice(-1) == "_";
      const isPadded = lastDash || v2.length % 2 != 0;
      if (isPadded) {
        let charLen = lastDash ? v2.length - 1 : v2.length;
        const padded = v2.substr(0, charLen) + "0";
        if (!lastDash && (charLen & 1) !== 0) {
          return new BitString_1.BitString(Buffer.from(padded, "hex"), 0, charLen << 2);
        } else {
          return (0, paddedBits_1.paddedBufferToBits)(Buffer.from(padded, "hex"));
        }
      } else {
        return new BitString_1.BitString(Buffer.from(v2, "hex"), 0, v2.length << 2);
      }
    }
    throw Error("Invalid key type: " + k);
  }
  internalKeySerializer$1.deserializeInternalKey = deserializeInternalKey;
  return internalKeySerializer$1;
}
var hasRequiredDictionary$1;
function requireDictionary$1() {
  if (hasRequiredDictionary$1) return Dictionary$1;
  hasRequiredDictionary$1 = 1;
  Object.defineProperty(Dictionary$1, "__esModule", { value: true });
  Dictionary$1.Dictionary = void 0;
  const Address_1 = requireAddress$1();
  const Builder_12 = requireBuilder$3();
  const Cell_1 = requireCell$1();
  const BitString_1 = requireBitString$1();
  const generateMerkleProof_1 = requireGenerateMerkleProof$1();
  const generateMerkleUpdate_1 = requireGenerateMerkleUpdate$1();
  const parseDict_1 = requireParseDict$1();
  const serializeDict_1 = requireSerializeDict$1();
  const internalKeySerializer_1 = requireInternalKeySerializer$1();
  class Dictionary2 {
    /**
     * Create an empty map
     * @param key key type
     * @param value value type
     * @returns Dictionary<K, V>
     */
    static empty(key2, value) {
      if (key2 && value) {
        return new Dictionary2(/* @__PURE__ */ new Map(), key2, value);
      } else {
        return new Dictionary2(/* @__PURE__ */ new Map(), null, null);
      }
    }
    /**
     * Load dictionary from slice
     * @param key key description
     * @param value value description
     * @param src slice
     * @returns Dictionary<K, V>
     */
    static load(key2, value, sc) {
      let slice;
      if (sc instanceof Cell_1.Cell) {
        if (sc.isExotic) {
          return Dictionary2.empty(key2, value);
        }
        slice = sc.beginParse();
      } else {
        slice = sc;
      }
      let cell = slice.loadMaybeRef();
      if (cell && !cell.isExotic) {
        return Dictionary2.loadDirect(key2, value, cell.beginParse());
      } else {
        return Dictionary2.empty(key2, value);
      }
    }
    /**
     * Low level method for rare dictionaries from system contracts.
     * Loads dictionary from slice directly without going to the ref.
     *
     * @param key key description
     * @param value value description
     * @param sc slice
     * @returns Dictionary<K, V>
     */
    static loadDirect(key2, value, sc) {
      if (!sc) {
        return Dictionary2.empty(key2, value);
      }
      let slice;
      if (sc instanceof Cell_1.Cell) {
        slice = sc.beginParse();
      } else {
        slice = sc;
      }
      let values = (0, parseDict_1.parseDict)(slice, key2.bits, value.parse);
      let prepare = /* @__PURE__ */ new Map();
      for (let [k, v2] of values) {
        prepare.set((0, internalKeySerializer_1.serializeInternalKey)(key2.parse(k)), v2);
      }
      return new Dictionary2(prepare, key2, value);
    }
    constructor(values, key2, value) {
      this._key = key2;
      this._value = value;
      this._map = values;
    }
    get size() {
      return this._map.size;
    }
    get(key2) {
      return this._map.get((0, internalKeySerializer_1.serializeInternalKey)(key2));
    }
    has(key2) {
      return this._map.has((0, internalKeySerializer_1.serializeInternalKey)(key2));
    }
    set(key2, value) {
      this._map.set((0, internalKeySerializer_1.serializeInternalKey)(key2), value);
      return this;
    }
    delete(key2) {
      const k = (0, internalKeySerializer_1.serializeInternalKey)(key2);
      return this._map.delete(k);
    }
    clear() {
      this._map.clear();
    }
    *[Symbol.iterator]() {
      for (const [k, v2] of this._map) {
        const key2 = (0, internalKeySerializer_1.deserializeInternalKey)(k);
        yield [key2, v2];
      }
    }
    keys() {
      return Array.from(this._map.keys()).map((v2) => (0, internalKeySerializer_1.deserializeInternalKey)(v2));
    }
    values() {
      return Array.from(this._map.values());
    }
    store(builder2, key2, value) {
      if (this._map.size === 0) {
        builder2.storeBit(0);
      } else {
        let resolvedKey = this._key;
        if (key2 !== null && key2 !== void 0) {
          resolvedKey = key2;
        }
        let resolvedValue = this._value;
        if (value !== null && value !== void 0) {
          resolvedValue = value;
        }
        if (!resolvedKey) {
          throw Error("Key serializer is not defined");
        }
        if (!resolvedValue) {
          throw Error("Value serializer is not defined");
        }
        let prepared = /* @__PURE__ */ new Map();
        for (const [k, v2] of this._map) {
          prepared.set(resolvedKey.serialize((0, internalKeySerializer_1.deserializeInternalKey)(k)), v2);
        }
        builder2.storeBit(1);
        let dd = (0, Builder_12.beginCell)();
        (0, serializeDict_1.serializeDict)(prepared, resolvedKey.bits, resolvedValue.serialize, dd);
        builder2.storeRef(dd.endCell());
      }
    }
    storeDirect(builder2, key2, value) {
      if (this._map.size === 0) {
        throw Error("Cannot store empty dictionary directly");
      }
      let resolvedKey = this._key;
      if (key2 !== null && key2 !== void 0) {
        resolvedKey = key2;
      }
      let resolvedValue = this._value;
      if (value !== null && value !== void 0) {
        resolvedValue = value;
      }
      if (!resolvedKey) {
        throw Error("Key serializer is not defined");
      }
      if (!resolvedValue) {
        throw Error("Value serializer is not defined");
      }
      let prepared = /* @__PURE__ */ new Map();
      for (const [k, v2] of this._map) {
        prepared.set(resolvedKey.serialize((0, internalKeySerializer_1.deserializeInternalKey)(k)), v2);
      }
      (0, serializeDict_1.serializeDict)(prepared, resolvedKey.bits, resolvedValue.serialize, builder2);
    }
    /**
     * Generate merkle proof for multiple keys in the dictionary
     * @param keys an array of the keys
     * @returns generated merkle proof cell
     */
    generateMerkleProof(keys) {
      return (0, generateMerkleProof_1.generateMerkleProof)(this, keys, this._key);
    }
    /**
     * Low level method for generating pruned dictionary directly.
     * The result can be used as a part of a bigger merkle proof
     * @param keys an array of the keys
     * @returns cell that contains the pruned dictionary
     */
    generateMerkleProofDirect(keys) {
      return (0, generateMerkleProof_1.generateMerkleProofDirect)(this, keys, this._key);
    }
    generateMerkleUpdate(key2, newValue) {
      return (0, generateMerkleUpdate_1.generateMerkleUpdate)(this, key2, this._key, newValue);
    }
  }
  Dictionary$1.Dictionary = Dictionary2;
  Dictionary2.Keys = {
    /**
     * Standard address key
     * @returns DictionaryKey<Address>
     */
    Address: () => {
      return createAddressKey();
    },
    /**
     * Create standard big integer key
     * @param bits number of bits
     * @returns DictionaryKey<bigint>
     */
    BigInt: (bits) => {
      return createBigIntKey(bits);
    },
    /**
     * Create integer key
     * @param bits bits of integer
     * @returns DictionaryKey<number>
     */
    Int: (bits) => {
      return createIntKey(bits);
    },
    /**
     * Create standard unsigned big integer key
     * @param bits number of bits
     * @returns DictionaryKey<bigint>
     */
    BigUint: (bits) => {
      return createBigUintKey(bits);
    },
    /**
     * Create standard unsigned integer key
     * @param bits number of bits
     * @returns DictionaryKey<number>
     */
    Uint: (bits) => {
      return createUintKey(bits);
    },
    /**
     * Create standard buffer key
     * @param bytes number of bytes of a buffer
     * @returns DictionaryKey<Buffer>
     */
    Buffer: (bytes) => {
      return createBufferKey(bytes);
    },
    /**
     * Create BitString key
     * @param bits key length
     * @returns DictionaryKey<BitString>
     * Point is that Buffer has to be 8 bit aligned,
     * while key is TVM dictionary doesn't have to be
     * aligned at all.
     */
    BitString: (bits) => {
      return createBitStringKey(bits);
    }
  };
  Dictionary2.Values = {
    /**
     * Create standard integer value
     * @returns DictionaryValue<bigint>
     */
    BigInt: (bits) => {
      return createBigIntValue(bits);
    },
    /**
     * Create standard integer value
     * @returns DictionaryValue<number>
     */
    Int: (bits) => {
      return createIntValue(bits);
    },
    /**
     * Create big var int
     * @param bits nubmer of header bits
     * @returns DictionaryValue<bigint>
     */
    BigVarInt: (bits) => {
      return createBigVarIntValue(bits);
    },
    /**
     * Create standard unsigned integer value
     * @param bits number of bits
     * @returns DictionaryValue<bigint>
     */
    BigUint: (bits) => {
      return createBigUintValue(bits);
    },
    /**
     * Create standard unsigned integer value
     * @param bits number of bits
     * @returns DictionaryValue<bigint>
     */
    Uint: (bits) => {
      return createUintValue(bits);
    },
    /**
     * Create big var int
     * @param bits nubmer of header bits
     * @returns DictionaryValue<bigint>
     */
    BigVarUint: (bits) => {
      return createBigVarUintValue(bits);
    },
    /**
     * Create standard boolean value
     * @returns DictionaryValue<boolean>
     */
    Bool: () => {
      return createBooleanValue();
    },
    /**
     * Create standard address value
     * @returns DictionaryValue<Address>
     */
    Address: () => {
      return createAddressValue();
    },
    /**
     * Create standard cell value
     * @returns DictionaryValue<Cell>
     */
    Cell: () => {
      return createCellValue();
    },
    /**
     * Create Builder value
     * @param bytes number of bytes of a buffer
     * @returns DictionaryValue<Builder>
     */
    Buffer: (bytes) => {
      return createBufferValue(bytes);
    },
    /**
     * Create BitString value
     * @param requested bit length
     * @returns DictionaryValue<BitString>
     * Point is that Buffer is not applicable
     * when length is not 8 bit alligned.
     */
    BitString: (bits) => {
      return createBitStringValue(bits);
    },
    /**
     * Create dictionary value
     * @param key
     * @param value
     */
    Dictionary: (key2, value) => {
      return createDictionaryValue(key2, value);
    }
  };
  function createAddressKey() {
    return {
      bits: 267,
      serialize: (src2) => {
        if (!Address_1.Address.isAddress(src2)) {
          throw Error("Key is not an address");
        }
        return (0, Builder_12.beginCell)().storeAddress(src2).endCell().beginParse().preloadUintBig(267);
      },
      parse: (src2) => {
        return (0, Builder_12.beginCell)().storeUint(src2, 267).endCell().beginParse().loadAddress();
      }
    };
  }
  function createBigIntKey(bits) {
    return {
      bits,
      serialize: (src2) => {
        if (typeof src2 !== "bigint") {
          throw Error("Key is not a bigint");
        }
        return (0, Builder_12.beginCell)().storeInt(src2, bits).endCell().beginParse().loadUintBig(bits);
      },
      parse: (src2) => {
        return (0, Builder_12.beginCell)().storeUint(src2, bits).endCell().beginParse().loadIntBig(bits);
      }
    };
  }
  function createIntKey(bits) {
    return {
      bits,
      serialize: (src2) => {
        if (typeof src2 !== "number") {
          throw Error("Key is not a number");
        }
        if (!Number.isSafeInteger(src2)) {
          throw Error("Key is not a safe integer: " + src2);
        }
        return (0, Builder_12.beginCell)().storeInt(src2, bits).endCell().beginParse().loadUintBig(bits);
      },
      parse: (src2) => {
        return (0, Builder_12.beginCell)().storeUint(src2, bits).endCell().beginParse().loadInt(bits);
      }
    };
  }
  function createBigUintKey(bits) {
    return {
      bits,
      serialize: (src2) => {
        if (typeof src2 !== "bigint") {
          throw Error("Key is not a bigint");
        }
        if (src2 < 0) {
          throw Error("Key is negative: " + src2);
        }
        return (0, Builder_12.beginCell)().storeUint(src2, bits).endCell().beginParse().loadUintBig(bits);
      },
      parse: (src2) => {
        return (0, Builder_12.beginCell)().storeUint(src2, bits).endCell().beginParse().loadUintBig(bits);
      }
    };
  }
  function createUintKey(bits) {
    return {
      bits,
      serialize: (src2) => {
        if (typeof src2 !== "number") {
          throw Error("Key is not a number");
        }
        if (!Number.isSafeInteger(src2)) {
          throw Error("Key is not a safe integer: " + src2);
        }
        if (src2 < 0) {
          throw Error("Key is negative: " + src2);
        }
        return (0, Builder_12.beginCell)().storeUint(src2, bits).endCell().beginParse().loadUintBig(bits);
      },
      parse: (src2) => {
        return Number((0, Builder_12.beginCell)().storeUint(src2, bits).endCell().beginParse().loadUint(bits));
      }
    };
  }
  function createBufferKey(bytes) {
    return {
      bits: bytes * 8,
      serialize: (src2) => {
        if (!Buffer.isBuffer(src2)) {
          throw Error("Key is not a buffer");
        }
        return (0, Builder_12.beginCell)().storeBuffer(src2).endCell().beginParse().loadUintBig(bytes * 8);
      },
      parse: (src2) => {
        return (0, Builder_12.beginCell)().storeUint(src2, bytes * 8).endCell().beginParse().loadBuffer(bytes);
      }
    };
  }
  function createBitStringKey(bits) {
    return {
      bits,
      serialize: (src2) => {
        if (!BitString_1.BitString.isBitString(src2))
          throw Error("Key is not a BitString");
        return (0, Builder_12.beginCell)().storeBits(src2).endCell().beginParse().loadUintBig(bits);
      },
      parse: (src2) => {
        return (0, Builder_12.beginCell)().storeUint(src2, bits).endCell().beginParse().loadBits(bits);
      }
    };
  }
  function createIntValue(bits) {
    return {
      serialize: (src2, buidler) => {
        buidler.storeInt(src2, bits);
      },
      parse: (src2) => {
        let value = src2.loadInt(bits);
        src2.endParse();
        return value;
      }
    };
  }
  function createBigIntValue(bits) {
    return {
      serialize: (src2, buidler) => {
        buidler.storeInt(src2, bits);
      },
      parse: (src2) => {
        let value = src2.loadIntBig(bits);
        src2.endParse();
        return value;
      }
    };
  }
  function createBigVarIntValue(bits) {
    return {
      serialize: (src2, buidler) => {
        buidler.storeVarInt(src2, bits);
      },
      parse: (src2) => {
        let value = src2.loadVarIntBig(bits);
        src2.endParse();
        return value;
      }
    };
  }
  function createBigVarUintValue(bits) {
    return {
      serialize: (src2, buidler) => {
        buidler.storeVarUint(src2, bits);
      },
      parse: (src2) => {
        let value = src2.loadVarUintBig(bits);
        src2.endParse();
        return value;
      }
    };
  }
  function createUintValue(bits) {
    return {
      serialize: (src2, buidler) => {
        buidler.storeUint(src2, bits);
      },
      parse: (src2) => {
        let value = src2.loadUint(bits);
        src2.endParse();
        return value;
      }
    };
  }
  function createBigUintValue(bits) {
    return {
      serialize: (src2, buidler) => {
        buidler.storeUint(src2, bits);
      },
      parse: (src2) => {
        let value = src2.loadUintBig(bits);
        src2.endParse();
        return value;
      }
    };
  }
  function createBooleanValue() {
    return {
      serialize: (src2, buidler) => {
        buidler.storeBit(src2);
      },
      parse: (src2) => {
        let value = src2.loadBit();
        src2.endParse();
        return value;
      }
    };
  }
  function createAddressValue() {
    return {
      serialize: (src2, buidler) => {
        buidler.storeAddress(src2);
      },
      parse: (src2) => {
        let addr = src2.loadAddress();
        src2.endParse();
        return addr;
      }
    };
  }
  function createCellValue() {
    return {
      serialize: (src2, buidler) => {
        buidler.storeRef(src2);
      },
      parse: (src2) => {
        let value = src2.loadRef();
        src2.endParse();
        return value;
      }
    };
  }
  function createDictionaryValue(key2, value) {
    return {
      serialize: (src2, buidler) => {
        src2.store(buidler);
      },
      parse: (src2) => {
        let dict = Dictionary2.load(key2, value, src2);
        src2.endParse();
        return dict;
      }
    };
  }
  function createBufferValue(size) {
    return {
      serialize: (src2, buidler) => {
        if (src2.length !== size) {
          throw Error("Invalid buffer size");
        }
        buidler.storeBuffer(src2);
      },
      parse: (src2) => {
        let value = src2.loadBuffer(size);
        src2.endParse();
        return value;
      }
    };
  }
  function createBitStringValue(bits) {
    return {
      serialize: (src2, builder2) => {
        if (src2.length !== bits) {
          throw Error("Invalid BitString size");
        }
        builder2.storeBits(src2);
      },
      parse: (src2) => {
        let value = src2.loadBits(bits);
        src2.endParse();
        return value;
      }
    };
  }
  return Dictionary$1;
}
var strings$1 = {};
var hasRequiredStrings$1;
function requireStrings$1() {
  if (hasRequiredStrings$1) return strings$1;
  hasRequiredStrings$1 = 1;
  Object.defineProperty(strings$1, "__esModule", { value: true });
  strings$1.writeString = strings$1.stringToCell = strings$1.readString = void 0;
  const Builder_12 = requireBuilder$3();
  function readBuffer(slice) {
    if (slice.remainingBits % 8 !== 0) {
      throw new Error(`Invalid string length: ${slice.remainingBits}`);
    }
    if (slice.remainingRefs !== 0 && slice.remainingRefs !== 1) {
      throw new Error(`invalid number of refs: ${slice.remainingRefs}`);
    }
    let res;
    if (slice.remainingBits === 0) {
      res = Buffer.alloc(0);
    } else {
      res = slice.loadBuffer(slice.remainingBits / 8);
    }
    if (slice.remainingRefs === 1) {
      res = Buffer.concat([res, readBuffer(slice.loadRef().beginParse())]);
    }
    return res;
  }
  function readString(slice) {
    return readBuffer(slice).toString();
  }
  strings$1.readString = readString;
  function writeBuffer(src2, builder2) {
    if (src2.length > 0) {
      let bytes = Math.floor(builder2.availableBits / 8);
      if (src2.length > bytes) {
        let a = src2.subarray(0, bytes);
        let t = src2.subarray(bytes);
        builder2 = builder2.storeBuffer(a);
        let bb = (0, Builder_12.beginCell)();
        writeBuffer(t, bb);
        builder2 = builder2.storeRef(bb.endCell());
      } else {
        builder2 = builder2.storeBuffer(src2);
      }
    }
  }
  function stringToCell(src2) {
    let builder2 = (0, Builder_12.beginCell)();
    writeBuffer(Buffer.from(src2), builder2);
    return builder2.endCell();
  }
  strings$1.stringToCell = stringToCell;
  function writeString(src2, builder2) {
    writeBuffer(Buffer.from(src2), builder2);
  }
  strings$1.writeString = writeString;
  return strings$1;
}
var hasRequiredSlice$1;
function requireSlice$1() {
  if (hasRequiredSlice$1) return Slice$1;
  hasRequiredSlice$1 = 1;
  var __importDefault = Slice$1 && Slice$1.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  var _a;
  Object.defineProperty(Slice$1, "__esModule", { value: true });
  Slice$1.Slice = void 0;
  const symbol_inspect_1 = __importDefault(requireSymbol_inspect());
  const Dictionary_1 = requireDictionary$1();
  const Builder_12 = requireBuilder$3();
  const strings_1 = requireStrings$1();
  class Slice2 {
    constructor(reader2, refs) {
      this[_a] = () => this.toString();
      this._reader = reader2.clone();
      this._refs = [...refs];
      this._refsOffset = 0;
    }
    /**
     * Get remaining bits
     */
    get remainingBits() {
      return this._reader.remaining;
    }
    /**
     * Get offset bits
     */
    get offsetBits() {
      return this._reader.offset;
    }
    /**
     * Get remaining refs
     */
    get remainingRefs() {
      return this._refs.length - this._refsOffset;
    }
    /**
     * Get offset refs
     */
    get offsetRefs() {
      return this._refsOffset;
    }
    /**
     * Skip bits
     * @param bits
     */
    skip(bits) {
      this._reader.skip(bits);
      return this;
    }
    /**
     * Load a single bit
     * @returns true or false depending on the bit value
     */
    loadBit() {
      return this._reader.loadBit();
    }
    /**
     * Preload a signle bit
     * @returns true or false depending on the bit value
     */
    preloadBit() {
      return this._reader.preloadBit();
    }
    /**
     * Load a boolean
     * @returns true or false depending on the bit value
     */
    loadBoolean() {
      return this.loadBit();
    }
    /**
     * Load maybe boolean
     * @returns true or false depending on the bit value or null
     */
    loadMaybeBoolean() {
      if (this.loadBit()) {
        return this.loadBoolean();
      } else {
        return null;
      }
    }
    /**
     * Load bits as a new BitString
     * @param bits number of bits to read
     * @returns new BitString
     */
    loadBits(bits) {
      return this._reader.loadBits(bits);
    }
    /**
     * Preload bits as a new BitString
     * @param bits number of bits to read
     * @returns new BitString
     */
    preloadBits(bits) {
      return this._reader.preloadBits(bits);
    }
    /**
     * Load uint
     * @param bits number of bits to read
     * @returns uint value
     */
    loadUint(bits) {
      return this._reader.loadUint(bits);
    }
    /**
     * Load uint
     * @param bits number of bits to read
     * @returns uint value
     */
    loadUintBig(bits) {
      return this._reader.loadUintBig(bits);
    }
    /**
     * Preload uint
     * @param bits number of bits to read
     * @returns uint value
     */
    preloadUint(bits) {
      return this._reader.preloadUint(bits);
    }
    /**
     * Preload uint
     * @param bits number of bits to read
     * @returns uint value
     */
    preloadUintBig(bits) {
      return this._reader.preloadUintBig(bits);
    }
    /**
     * Load maybe uint
     * @param bits number of bits to read
     * @returns uint value or null
     */
    loadMaybeUint(bits) {
      if (this.loadBit()) {
        return this.loadUint(bits);
      } else {
        return null;
      }
    }
    /**
     * Load maybe uint
     * @param bits number of bits to read
     * @returns uint value or null
     */
    loadMaybeUintBig(bits) {
      if (this.loadBit()) {
        return this.loadUintBig(bits);
      } else {
        return null;
      }
    }
    /**
     * Load int
     * @param bits number of bits to read
     * @returns int value
     */
    loadInt(bits) {
      return this._reader.loadInt(bits);
    }
    /**
     * Load int
     * @param bits number of bits to read
     * @returns int value
     */
    loadIntBig(bits) {
      return this._reader.loadIntBig(bits);
    }
    /**
     * Preload int
     * @param bits number of bits to read
     * @returns int value
     */
    preloadInt(bits) {
      return this._reader.preloadInt(bits);
    }
    /**
     * Preload int
     * @param bits number of bits to read
     * @returns int value
     */
    preloadIntBig(bits) {
      return this._reader.preloadIntBig(bits);
    }
    /**
     * Load maybe uint
     * @param bits number of bits to read
     * @returns uint value or null
     */
    loadMaybeInt(bits) {
      if (this.loadBit()) {
        return this.loadInt(bits);
      } else {
        return null;
      }
    }
    /**
     * Load maybe uint
     * @param bits number of bits to read
     * @returns uint value or null
     */
    loadMaybeIntBig(bits) {
      if (this.loadBit()) {
        return this.loadIntBig(bits);
      } else {
        return null;
      }
    }
    /**
     * Load varuint
     * @param bits number of bits to read in header
     * @returns varuint value
     */
    loadVarUint(bits) {
      return this._reader.loadVarUint(bits);
    }
    /**
     * Load varuint
     * @param bits number of bits to read in header
     * @returns varuint value
     */
    loadVarUintBig(bits) {
      return this._reader.loadVarUintBig(bits);
    }
    /**
     * Preload varuint
     * @param bits number of bits to read in header
     * @returns varuint value
     */
    preloadVarUint(bits) {
      return this._reader.preloadVarUint(bits);
    }
    /**
     * Preload varuint
     * @param bits number of bits to read in header
     * @returns varuint value
     */
    preloadVarUintBig(bits) {
      return this._reader.preloadVarUintBig(bits);
    }
    /**
     * Load varint
     * @param bits number of bits to read in header
     * @returns varint value
     */
    loadVarInt(bits) {
      return this._reader.loadVarInt(bits);
    }
    /**
     * Load varint
     * @param bits number of bits to read in header
     * @returns varint value
     */
    loadVarIntBig(bits) {
      return this._reader.loadVarIntBig(bits);
    }
    /**
     * Preload varint
     * @param bits number of bits to read in header
     * @returns varint value
     */
    preloadVarInt(bits) {
      return this._reader.preloadVarInt(bits);
    }
    /**
     * Preload varint
     * @param bits number of bits to read in header
     * @returns varint value
     */
    preloadVarIntBig(bits) {
      return this._reader.preloadVarIntBig(bits);
    }
    /**
     * Load coins
     * @returns coins value
     */
    loadCoins() {
      return this._reader.loadCoins();
    }
    /**
     * Preload coins
     * @returns coins value
     */
    preloadCoins() {
      return this._reader.preloadCoins();
    }
    /**
     * Load maybe coins
     * @returns coins value or null
     */
    loadMaybeCoins() {
      if (this._reader.loadBit()) {
        return this._reader.loadCoins();
      } else {
        return null;
      }
    }
    /**
     * Load internal Address
     * @returns Address
     */
    loadAddress() {
      return this._reader.loadAddress();
    }
    /**
     * Load optional internal Address
     * @returns Address or null
     */
    loadMaybeAddress() {
      return this._reader.loadMaybeAddress();
    }
    /**
     * Load external address
     * @returns ExternalAddress
     */
    loadExternalAddress() {
      return this._reader.loadExternalAddress();
    }
    /**
     * Load optional external address
     * @returns ExternalAddress or null
     */
    loadMaybeExternalAddress() {
      return this._reader.loadMaybeExternalAddress();
    }
    /**
     * Load address
     * @returns Address, ExternalAddress or null
     */
    loadAddressAny() {
      return this._reader.loadAddressAny();
    }
    /**
     * Load reference
     * @returns Cell
     */
    loadRef() {
      if (this._refsOffset >= this._refs.length) {
        throw new Error("No more references");
      }
      return this._refs[this._refsOffset++];
    }
    /**
     * Preload reference
     * @returns Cell
     */
    preloadRef() {
      if (this._refsOffset >= this._refs.length) {
        throw new Error("No more references");
      }
      return this._refs[this._refsOffset];
    }
    /**
     * Load optional reference
     * @returns Cell or null
     */
    loadMaybeRef() {
      if (this.loadBit()) {
        return this.loadRef();
      } else {
        return null;
      }
    }
    /**
     * Preload optional reference
     * @returns Cell or null
     */
    preloadMaybeRef() {
      if (this.preloadBit()) {
        return this.preloadRef();
      } else {
        return null;
      }
    }
    /**
     * Load byte buffer
     * @param bytes number of bytes to load
     * @returns Buffer
     */
    loadBuffer(bytes) {
      return this._reader.loadBuffer(bytes);
    }
    /**
     * Load byte buffer
     * @param bytes number of bytes to load
     * @returns Buffer
     */
    preloadBuffer(bytes) {
      return this._reader.preloadBuffer(bytes);
    }
    /**
     * Load string tail
     */
    loadStringTail() {
      return (0, strings_1.readString)(this);
    }
    /**
     * Load maybe string tail
     * @returns string or null
     */
    loadMaybeStringTail() {
      if (this.loadBit()) {
        return (0, strings_1.readString)(this);
      } else {
        return null;
      }
    }
    /**
     * Load string tail from ref
     * @returns string
     */
    loadStringRefTail() {
      return (0, strings_1.readString)(this.loadRef().beginParse());
    }
    /**
     * Load maybe string tail from ref
     * @returns string or null
     */
    loadMaybeStringRefTail() {
      const ref = this.loadMaybeRef();
      if (ref) {
        return (0, strings_1.readString)(ref.beginParse());
      } else {
        return null;
      }
    }
    /**
     * Loads dictionary
     * @param key key description
     * @param value value description
     * @returns Dictionary<K, V>
     */
    loadDict(key2, value) {
      return Dictionary_1.Dictionary.load(key2, value, this);
    }
    /**
     * Loads dictionary directly from current slice
     * @param key key description
     * @param value value description
     * @returns Dictionary<K, V>
     */
    loadDictDirect(key2, value) {
      return Dictionary_1.Dictionary.loadDirect(key2, value, this);
    }
    /**
     * Checks if slice is empty
     */
    endParse() {
      if (this.remainingBits > 0 || this.remainingRefs > 0) {
        throw new Error("Slice is not empty");
      }
    }
    /**
     * Convert slice to cell
     */
    asCell() {
      return (0, Builder_12.beginCell)().storeSlice(this).endCell();
    }
    /**
     *
     * @returns
     */
    asBuilder() {
      return (0, Builder_12.beginCell)().storeSlice(this);
    }
    /**
     * Clone slice
     * @returns cloned slice
     */
    clone(fromStart = false) {
      if (fromStart) {
        let reader2 = this._reader.clone();
        reader2.reset();
        return new Slice2(reader2, this._refs);
      } else {
        let res = new Slice2(this._reader, this._refs);
        res._refsOffset = this._refsOffset;
        return res;
      }
    }
    /**
     * Print slice as string by converting it to cell
     * @returns string
     */
    toString() {
      return this.asCell().toString();
    }
  }
  Slice$1.Slice = Slice2;
  _a = symbol_inspect_1.default;
  return Slice$1;
}
var resolveExotic$1 = {};
var exoticLibrary$1 = {};
var hasRequiredExoticLibrary$1;
function requireExoticLibrary$1() {
  if (hasRequiredExoticLibrary$1) return exoticLibrary$1;
  hasRequiredExoticLibrary$1 = 1;
  Object.defineProperty(exoticLibrary$1, "__esModule", { value: true });
  exoticLibrary$1.exoticLibrary = void 0;
  const BitReader_1 = requireBitReader$1();
  function exoticLibrary2(bits, refs) {
    const reader2 = new BitReader_1.BitReader(bits);
    const size = 8 + 256;
    if (bits.length !== size) {
      throw new Error(`Library cell must have exactly (8 + 256) bits, got "${bits.length}"`);
    }
    let type = reader2.loadUint(8);
    if (type !== 2) {
      throw new Error(`Library cell must have type 2, got "${type}"`);
    }
    return {};
  }
  exoticLibrary$1.exoticLibrary = exoticLibrary2;
  return exoticLibrary$1;
}
var exoticMerkleUpdate$1 = {};
var hasRequiredExoticMerkleUpdate$1;
function requireExoticMerkleUpdate$1() {
  if (hasRequiredExoticMerkleUpdate$1) return exoticMerkleUpdate$1;
  hasRequiredExoticMerkleUpdate$1 = 1;
  Object.defineProperty(exoticMerkleUpdate$1, "__esModule", { value: true });
  exoticMerkleUpdate$1.exoticMerkleUpdate = void 0;
  const BitReader_1 = requireBitReader$1();
  function exoticMerkleUpdate2(bits, refs) {
    const reader2 = new BitReader_1.BitReader(bits);
    const size = 8 + 2 * (256 + 16);
    if (bits.length !== size) {
      throw new Error(`Merkle Update cell must have exactly (8 + (2 * (256 + 16))) bits, got "${bits.length}"`);
    }
    if (refs.length !== 2) {
      throw new Error(`Merkle Update cell must have exactly 2 refs, got "${refs.length}"`);
    }
    let type = reader2.loadUint(8);
    if (type !== 4) {
      throw new Error(`Merkle Update cell type must be exactly 4, got "${type}"`);
    }
    const proofHash1 = reader2.loadBuffer(32);
    const proofHash2 = reader2.loadBuffer(32);
    const proofDepth1 = reader2.loadUint(16);
    const proofDepth2 = reader2.loadUint(16);
    if (proofDepth1 !== refs[0].depth(0)) {
      throw new Error(`Merkle Update cell ref depth must be exactly "${proofDepth1}", got "${refs[0].depth(0)}"`);
    }
    if (!proofHash1.equals(refs[0].hash(0))) {
      throw new Error(`Merkle Update cell ref hash must be exactly "${proofHash1.toString("hex")}", got "${refs[0].hash(0).toString("hex")}"`);
    }
    if (proofDepth2 !== refs[1].depth(0)) {
      throw new Error(`Merkle Update cell ref depth must be exactly "${proofDepth2}", got "${refs[1].depth(0)}"`);
    }
    if (!proofHash2.equals(refs[1].hash(0))) {
      throw new Error(`Merkle Update cell ref hash must be exactly "${proofHash2.toString("hex")}", got "${refs[1].hash(0).toString("hex")}"`);
    }
    return {
      proofDepth1,
      proofDepth2,
      proofHash1,
      proofHash2
    };
  }
  exoticMerkleUpdate$1.exoticMerkleUpdate = exoticMerkleUpdate2;
  return exoticMerkleUpdate$1;
}
var exoticPruned$1 = {};
var LevelMask$1 = {};
var hasRequiredLevelMask$1;
function requireLevelMask$1() {
  if (hasRequiredLevelMask$1) return LevelMask$1;
  hasRequiredLevelMask$1 = 1;
  Object.defineProperty(LevelMask$1, "__esModule", { value: true });
  LevelMask$1.LevelMask = void 0;
  class LevelMask2 {
    constructor(mask = 0) {
      this._mask = 0;
      this._mask = mask;
      this._hashIndex = countSetBits(this._mask);
      this._hashCount = this._hashIndex + 1;
    }
    get value() {
      return this._mask;
    }
    get level() {
      return 32 - Math.clz32(this._mask);
    }
    get hashIndex() {
      return this._hashIndex;
    }
    get hashCount() {
      return this._hashCount;
    }
    apply(level) {
      return new LevelMask2(this._mask & (1 << level) - 1);
    }
    isSignificant(level) {
      let res = level === 0 || (this._mask >> level - 1) % 2 !== 0;
      return res;
    }
  }
  LevelMask$1.LevelMask = LevelMask2;
  function countSetBits(n) {
    n = n - (n >> 1 & 1431655765);
    n = (n & 858993459) + (n >> 2 & 858993459);
    return (n + (n >> 4) & 252645135) * 16843009 >> 24;
  }
  return LevelMask$1;
}
var hasRequiredExoticPruned$1;
function requireExoticPruned$1() {
  if (hasRequiredExoticPruned$1) return exoticPruned$1;
  hasRequiredExoticPruned$1 = 1;
  Object.defineProperty(exoticPruned$1, "__esModule", { value: true });
  exoticPruned$1.exoticPruned = void 0;
  const BitReader_1 = requireBitReader$1();
  const LevelMask_1 = requireLevelMask$1();
  function exoticPruned2(bits, refs) {
    let reader2 = new BitReader_1.BitReader(bits);
    let type = reader2.loadUint(8);
    if (type !== 1) {
      throw new Error(`Pruned branch cell must have type 1, got "${type}"`);
    }
    if (refs.length !== 0) {
      throw new Error(`Pruned Branch cell can't has refs, got "${refs.length}"`);
    }
    let mask;
    if (bits.length === 280) {
      mask = new LevelMask_1.LevelMask(1);
    } else {
      mask = new LevelMask_1.LevelMask(reader2.loadUint(8));
      if (mask.level < 1 || mask.level > 3) {
        throw new Error(`Pruned Branch cell level must be >= 1 and <= 3, got "${mask.level}/${mask.value}"`);
      }
      const size = 8 + 8 + mask.apply(mask.level - 1).hashCount * (256 + 16);
      if (bits.length !== size) {
        throw new Error(`Pruned branch cell must have exactly ${size} bits, got "${bits.length}"`);
      }
    }
    let pruned = [];
    let hashes = [];
    let depths = [];
    for (let i = 0; i < mask.level; i++) {
      hashes.push(reader2.loadBuffer(32));
    }
    for (let i = 0; i < mask.level; i++) {
      depths.push(reader2.loadUint(16));
    }
    for (let i = 0; i < mask.level; i++) {
      pruned.push({
        depth: depths[i],
        hash: hashes[i]
      });
    }
    return {
      mask: mask.value,
      pruned
    };
  }
  exoticPruned$1.exoticPruned = exoticPruned2;
  return exoticPruned$1;
}
var hasRequiredResolveExotic$1;
function requireResolveExotic$1() {
  if (hasRequiredResolveExotic$1) return resolveExotic$1;
  hasRequiredResolveExotic$1 = 1;
  Object.defineProperty(resolveExotic$1, "__esModule", { value: true });
  resolveExotic$1.resolveExotic = void 0;
  const BitReader_1 = requireBitReader$1();
  const CellType_1 = requireCellType$1();
  const exoticLibrary_1 = requireExoticLibrary$1();
  const exoticMerkleProof_1 = requireExoticMerkleProof$1();
  const exoticMerkleUpdate_1 = requireExoticMerkleUpdate$1();
  const exoticPruned_1 = requireExoticPruned$1();
  const LevelMask_1 = requireLevelMask$1();
  function resolvePruned(bits, refs) {
    let pruned = (0, exoticPruned_1.exoticPruned)(bits, refs);
    let depths = [];
    let hashes = [];
    let mask = new LevelMask_1.LevelMask(pruned.mask);
    for (let i = 0; i < pruned.pruned.length; i++) {
      depths.push(pruned.pruned[i].depth);
      hashes.push(pruned.pruned[i].hash);
    }
    return {
      type: CellType_1.CellType.PrunedBranch,
      depths,
      hashes,
      mask
    };
  }
  function resolveLibrary(bits, refs) {
    (0, exoticLibrary_1.exoticLibrary)(bits, refs);
    let depths = [];
    let hashes = [];
    let mask = new LevelMask_1.LevelMask();
    return {
      type: CellType_1.CellType.Library,
      depths,
      hashes,
      mask
    };
  }
  function resolveMerkleProof(bits, refs) {
    (0, exoticMerkleProof_1.exoticMerkleProof)(bits, refs);
    let depths = [];
    let hashes = [];
    let mask = new LevelMask_1.LevelMask(refs[0].level() >> 1);
    return {
      type: CellType_1.CellType.MerkleProof,
      depths,
      hashes,
      mask
    };
  }
  function resolveMerkleUpdate(bits, refs) {
    (0, exoticMerkleUpdate_1.exoticMerkleUpdate)(bits, refs);
    let depths = [];
    let hashes = [];
    let mask = new LevelMask_1.LevelMask((refs[0].level() | refs[1].level()) >> 1);
    return {
      type: CellType_1.CellType.MerkleUpdate,
      depths,
      hashes,
      mask
    };
  }
  function resolveExotic2(bits, refs) {
    let reader2 = new BitReader_1.BitReader(bits);
    let type = reader2.preloadUint(8);
    if (type === 1) {
      return resolvePruned(bits, refs);
    }
    if (type === 2) {
      return resolveLibrary(bits, refs);
    }
    if (type === 3) {
      return resolveMerkleProof(bits, refs);
    }
    if (type === 4) {
      return resolveMerkleUpdate(bits, refs);
    }
    throw Error("Invalid exotic cell type: " + type);
  }
  resolveExotic$1.resolveExotic = resolveExotic2;
  return resolveExotic$1;
}
var wonderCalculator$1 = {};
var descriptor$1 = {};
var hasRequiredDescriptor$1;
function requireDescriptor$1() {
  if (hasRequiredDescriptor$1) return descriptor$1;
  hasRequiredDescriptor$1 = 1;
  Object.defineProperty(descriptor$1, "__esModule", { value: true });
  descriptor$1.getRepr = descriptor$1.getBitsDescriptor = descriptor$1.getRefsDescriptor = void 0;
  const CellType_1 = requireCellType$1();
  const paddedBits_1 = requirePaddedBits$1();
  function getRefsDescriptor(refs, levelMask, type) {
    return refs.length + (type !== CellType_1.CellType.Ordinary ? 1 : 0) * 8 + levelMask * 32;
  }
  descriptor$1.getRefsDescriptor = getRefsDescriptor;
  function getBitsDescriptor(bits) {
    let len = bits.length;
    return Math.ceil(len / 8) + Math.floor(len / 8);
  }
  descriptor$1.getBitsDescriptor = getBitsDescriptor;
  function getRepr(originalBits, bits, refs, level, levelMask, type) {
    const bitsLen = Math.ceil(bits.length / 8);
    const repr = Buffer.alloc(2 + bitsLen + (2 + 32) * refs.length);
    let reprCursor = 0;
    repr[reprCursor++] = getRefsDescriptor(refs, levelMask, type);
    repr[reprCursor++] = getBitsDescriptor(originalBits);
    (0, paddedBits_1.bitsToPaddedBuffer)(bits).copy(repr, reprCursor);
    reprCursor += bitsLen;
    for (const c of refs) {
      let childDepth;
      if (type == CellType_1.CellType.MerkleProof || type == CellType_1.CellType.MerkleUpdate) {
        childDepth = c.depth(level + 1);
      } else {
        childDepth = c.depth(level);
      }
      repr[reprCursor++] = Math.floor(childDepth / 256);
      repr[reprCursor++] = childDepth % 256;
    }
    for (const c of refs) {
      let childHash;
      if (type == CellType_1.CellType.MerkleProof || type == CellType_1.CellType.MerkleUpdate) {
        childHash = c.hash(level + 1);
      } else {
        childHash = c.hash(level);
      }
      childHash.copy(repr, reprCursor);
      reprCursor += 32;
    }
    return repr;
  }
  descriptor$1.getRepr = getRepr;
  return descriptor$1;
}
var dist$5 = {};
var sha256$2 = {};
var sha$1 = { exports: {} };
var sha = sha$1.exports;
var hasRequiredSha;
function requireSha() {
  if (hasRequiredSha) return sha$1.exports;
  hasRequiredSha = 1;
  (function(module, exports) {
    !(function(n, r) {
      module.exports = r();
    })(sha, (function() {
      var n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      function r(n2, r2, t2, e2) {
        var i2, o2, u2, f2 = r2 || [0], w2 = (t2 = t2 || 0) >>> 3, s2 = -1 === e2 ? 3 : 0;
        for (i2 = 0; i2 < n2.length; i2 += 1) o2 = (u2 = i2 + w2) >>> 2, f2.length <= o2 && f2.push(0), f2[o2] |= n2[i2] << 8 * (s2 + e2 * (u2 % 4));
        return { value: f2, binLen: 8 * n2.length + t2 };
      }
      function t(t2, e2, i2) {
        switch (e2) {
          case "UTF8":
          case "UTF16BE":
          case "UTF16LE":
            break;
          default:
            throw new Error("encoding must be UTF8, UTF16BE, or UTF16LE");
        }
        switch (t2) {
          case "HEX":
            return function(n2, r2, t3) {
              return (function(n3, r3, t4, e3) {
                var i3, o2, u2, f2;
                if (0 != n3.length % 2) throw new Error("String of HEX type must be in byte increments");
                var w2 = r3 || [0], s2 = (t4 = t4 || 0) >>> 3, a2 = -1 === e3 ? 3 : 0;
                for (i3 = 0; i3 < n3.length; i3 += 2) {
                  if (o2 = parseInt(n3.substr(i3, 2), 16), isNaN(o2)) throw new Error("String of HEX type contains invalid characters");
                  for (u2 = (f2 = (i3 >>> 1) + s2) >>> 2; w2.length <= u2; ) w2.push(0);
                  w2[u2] |= o2 << 8 * (a2 + e3 * (f2 % 4));
                }
                return { value: w2, binLen: 4 * n3.length + t4 };
              })(n2, r2, t3, i2);
            };
          case "TEXT":
            return function(n2, r2, t3) {
              return (function(n3, r3, t4, e3, i3) {
                var o2, u2, f2, w2, s2, a2, h2, c2, v3 = 0, A3 = t4 || [0], E2 = (e3 = e3 || 0) >>> 3;
                if ("UTF8" === r3) for (h2 = -1 === i3 ? 3 : 0, f2 = 0; f2 < n3.length; f2 += 1) for (u2 = [], 128 > (o2 = n3.charCodeAt(f2)) ? u2.push(o2) : 2048 > o2 ? (u2.push(192 | o2 >>> 6), u2.push(128 | 63 & o2)) : 55296 > o2 || 57344 <= o2 ? u2.push(224 | o2 >>> 12, 128 | o2 >>> 6 & 63, 128 | 63 & o2) : (f2 += 1, o2 = 65536 + ((1023 & o2) << 10 | 1023 & n3.charCodeAt(f2)), u2.push(240 | o2 >>> 18, 128 | o2 >>> 12 & 63, 128 | o2 >>> 6 & 63, 128 | 63 & o2)), w2 = 0; w2 < u2.length; w2 += 1) {
                  for (s2 = (a2 = v3 + E2) >>> 2; A3.length <= s2; ) A3.push(0);
                  A3[s2] |= u2[w2] << 8 * (h2 + i3 * (a2 % 4)), v3 += 1;
                }
                else for (h2 = -1 === i3 ? 2 : 0, c2 = "UTF16LE" === r3 && 1 !== i3 || "UTF16LE" !== r3 && 1 === i3, f2 = 0; f2 < n3.length; f2 += 1) {
                  for (o2 = n3.charCodeAt(f2), true === c2 && (o2 = (w2 = 255 & o2) << 8 | o2 >>> 8), s2 = (a2 = v3 + E2) >>> 2; A3.length <= s2; ) A3.push(0);
                  A3[s2] |= o2 << 8 * (h2 + i3 * (a2 % 4)), v3 += 2;
                }
                return { value: A3, binLen: 8 * v3 + e3 };
              })(n2, e2, r2, t3, i2);
            };
          case "B64":
            return function(r2, t3, e3) {
              return (function(r3, t4, e4, i3) {
                var o2, u2, f2, w2, s2, a2, h2 = 0, c2 = t4 || [0], v3 = (e4 = e4 || 0) >>> 3, A3 = -1 === i3 ? 3 : 0, E2 = r3.indexOf("=");
                if (-1 === r3.search(/^[a-zA-Z0-9=+/]+$/)) throw new Error("Invalid character in base-64 string");
                if (r3 = r3.replace(/=/g, ""), -1 !== E2 && E2 < r3.length) throw new Error("Invalid '=' found in base-64 string");
                for (o2 = 0; o2 < r3.length; o2 += 4) {
                  for (w2 = r3.substr(o2, 4), f2 = 0, u2 = 0; u2 < w2.length; u2 += 1) f2 |= n.indexOf(w2.charAt(u2)) << 18 - 6 * u2;
                  for (u2 = 0; u2 < w2.length - 1; u2 += 1) {
                    for (s2 = (a2 = h2 + v3) >>> 2; c2.length <= s2; ) c2.push(0);
                    c2[s2] |= (f2 >>> 16 - 8 * u2 & 255) << 8 * (A3 + i3 * (a2 % 4)), h2 += 1;
                  }
                }
                return { value: c2, binLen: 8 * h2 + e4 };
              })(r2, t3, e3, i2);
            };
          case "BYTES":
            return function(n2, r2, t3) {
              return (function(n3, r3, t4, e3) {
                var i3, o2, u2, f2, w2 = r3 || [0], s2 = (t4 = t4 || 0) >>> 3, a2 = -1 === e3 ? 3 : 0;
                for (o2 = 0; o2 < n3.length; o2 += 1) i3 = n3.charCodeAt(o2), u2 = (f2 = o2 + s2) >>> 2, w2.length <= u2 && w2.push(0), w2[u2] |= i3 << 8 * (a2 + e3 * (f2 % 4));
                return { value: w2, binLen: 8 * n3.length + t4 };
              })(n2, r2, t3, i2);
            };
          case "ARRAYBUFFER":
            try {
              new ArrayBuffer(0);
            } catch (n2) {
              throw new Error("ARRAYBUFFER not supported by this environment");
            }
            return function(n2, t3, e3) {
              return (function(n3, t4, e4, i3) {
                return r(new Uint8Array(n3), t4, e4, i3);
              })(n2, t3, e3, i2);
            };
          case "UINT8ARRAY":
            try {
              new Uint8Array(0);
            } catch (n2) {
              throw new Error("UINT8ARRAY not supported by this environment");
            }
            return function(n2, t3, e3) {
              return r(n2, t3, e3, i2);
            };
          default:
            throw new Error("format must be HEX, TEXT, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY");
        }
      }
      function e(r2, t2, e2, i2) {
        switch (r2) {
          case "HEX":
            return function(n2) {
              return (function(n3, r3, t3, e3) {
                var i3, o2, u2 = "", f2 = r3 / 8, w2 = -1 === t3 ? 3 : 0;
                for (i3 = 0; i3 < f2; i3 += 1) o2 = n3[i3 >>> 2] >>> 8 * (w2 + t3 * (i3 % 4)), u2 += "0123456789abcdef".charAt(o2 >>> 4 & 15) + "0123456789abcdef".charAt(15 & o2);
                return e3.outputUpper ? u2.toUpperCase() : u2;
              })(n2, t2, e2, i2);
            };
          case "B64":
            return function(r3) {
              return (function(r4, t3, e3, i3) {
                var o2, u2, f2, w2, s2, a2 = "", h2 = t3 / 8, c2 = -1 === e3 ? 3 : 0;
                for (o2 = 0; o2 < h2; o2 += 3) for (w2 = o2 + 1 < h2 ? r4[o2 + 1 >>> 2] : 0, s2 = o2 + 2 < h2 ? r4[o2 + 2 >>> 2] : 0, f2 = (r4[o2 >>> 2] >>> 8 * (c2 + e3 * (o2 % 4)) & 255) << 16 | (w2 >>> 8 * (c2 + e3 * ((o2 + 1) % 4)) & 255) << 8 | s2 >>> 8 * (c2 + e3 * ((o2 + 2) % 4)) & 255, u2 = 0; u2 < 4; u2 += 1) a2 += 8 * o2 + 6 * u2 <= t3 ? n.charAt(f2 >>> 6 * (3 - u2) & 63) : i3.b64Pad;
                return a2;
              })(r3, t2, e2, i2);
            };
          case "BYTES":
            return function(n2) {
              return (function(n3, r3, t3) {
                var e3, i3, o2 = "", u2 = r3 / 8, f2 = -1 === t3 ? 3 : 0;
                for (e3 = 0; e3 < u2; e3 += 1) i3 = n3[e3 >>> 2] >>> 8 * (f2 + t3 * (e3 % 4)) & 255, o2 += String.fromCharCode(i3);
                return o2;
              })(n2, t2, e2);
            };
          case "ARRAYBUFFER":
            try {
              new ArrayBuffer(0);
            } catch (n2) {
              throw new Error("ARRAYBUFFER not supported by this environment");
            }
            return function(n2) {
              return (function(n3, r3, t3) {
                var e3, i3 = r3 / 8, o2 = new ArrayBuffer(i3), u2 = new Uint8Array(o2), f2 = -1 === t3 ? 3 : 0;
                for (e3 = 0; e3 < i3; e3 += 1) u2[e3] = n3[e3 >>> 2] >>> 8 * (f2 + t3 * (e3 % 4)) & 255;
                return o2;
              })(n2, t2, e2);
            };
          case "UINT8ARRAY":
            try {
              new Uint8Array(0);
            } catch (n2) {
              throw new Error("UINT8ARRAY not supported by this environment");
            }
            return function(n2) {
              return (function(n3, r3, t3) {
                var e3, i3 = r3 / 8, o2 = -1 === t3 ? 3 : 0, u2 = new Uint8Array(i3);
                for (e3 = 0; e3 < i3; e3 += 1) u2[e3] = n3[e3 >>> 2] >>> 8 * (o2 + t3 * (e3 % 4)) & 255;
                return u2;
              })(n2, t2, e2);
            };
          default:
            throw new Error("format must be HEX, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY");
        }
      }
      var i = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], o = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428], u = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], f = "Chosen SHA variant is not supported";
      function w(n2, r2) {
        var t2, e2, i2 = n2.binLen >>> 3, o2 = r2.binLen >>> 3, u2 = i2 << 3, f2 = 4 - i2 << 3;
        if (i2 % 4 != 0) {
          for (t2 = 0; t2 < o2; t2 += 4) e2 = i2 + t2 >>> 2, n2.value[e2] |= r2.value[t2 >>> 2] << u2, n2.value.push(0), n2.value[e2 + 1] |= r2.value[t2 >>> 2] >>> f2;
          return (n2.value.length << 2) - 4 >= o2 + i2 && n2.value.pop(), { value: n2.value, binLen: n2.binLen + r2.binLen };
        }
        return { value: n2.value.concat(r2.value), binLen: n2.binLen + r2.binLen };
      }
      function s(n2) {
        var r2 = { outputUpper: false, b64Pad: "=", outputLen: -1 }, t2 = n2 || {}, e2 = "Output length must be a multiple of 8";
        if (r2.outputUpper = t2.outputUpper || false, t2.b64Pad && (r2.b64Pad = t2.b64Pad), t2.outputLen) {
          if (t2.outputLen % 8 != 0) throw new Error(e2);
          r2.outputLen = t2.outputLen;
        } else if (t2.shakeLen) {
          if (t2.shakeLen % 8 != 0) throw new Error(e2);
          r2.outputLen = t2.shakeLen;
        }
        if ("boolean" != typeof r2.outputUpper) throw new Error("Invalid outputUpper formatting option");
        if ("string" != typeof r2.b64Pad) throw new Error("Invalid b64Pad formatting option");
        return r2;
      }
      function a(n2, r2, e2, i2) {
        var o2 = n2 + " must include a value and format";
        if (!r2) {
          if (!i2) throw new Error(o2);
          return i2;
        }
        if (void 0 === r2.value || !r2.format) throw new Error(o2);
        return t(r2.format, r2.encoding || "UTF8", e2)(r2.value);
      }
      var h = (function() {
        function n2(n3, r2, t2) {
          var e2 = t2 || {};
          if (this.t = r2, this.i = e2.encoding || "UTF8", this.numRounds = e2.numRounds || 1, isNaN(this.numRounds) || this.numRounds !== parseInt(this.numRounds, 10) || 1 > this.numRounds) throw new Error("numRounds must a integer >= 1");
          this.o = n3, this.u = [], this.s = 0, this.h = false, this.v = 0, this.A = false, this.l = [], this.H = [];
        }
        return n2.prototype.update = function(n3) {
          var r2, t2 = 0, e2 = this.S >>> 5, i2 = this.p(n3, this.u, this.s), o2 = i2.binLen, u2 = i2.value, f2 = o2 >>> 5;
          for (r2 = 0; r2 < f2; r2 += e2) t2 + this.S <= o2 && (this.m = this.R(u2.slice(r2, r2 + e2), this.m), t2 += this.S);
          this.v += t2, this.u = u2.slice(t2 >>> 5), this.s = o2 % this.S, this.h = true;
        }, n2.prototype.getHash = function(n3, r2) {
          var t2, i2, o2 = this.U, u2 = s(r2);
          if (this.T) {
            if (-1 === u2.outputLen) throw new Error("Output length must be specified in options");
            o2 = u2.outputLen;
          }
          var f2 = e(n3, o2, this.C, u2);
          if (this.A && this.F) return f2(this.F(u2));
          for (i2 = this.K(this.u.slice(), this.s, this.v, this.B(this.m), o2), t2 = 1; t2 < this.numRounds; t2 += 1) this.T && o2 % 32 != 0 && (i2[i2.length - 1] &= 16777215 >>> 24 - o2 % 32), i2 = this.K(i2, o2, 0, this.L(this.o), o2);
          return f2(i2);
        }, n2.prototype.setHMACKey = function(n3, r2, e2) {
          if (!this.g) throw new Error("Variant does not support HMAC");
          if (this.h) throw new Error("Cannot set MAC key after calling update");
          var i2 = t(r2, (e2 || {}).encoding || "UTF8", this.C);
          this.k(i2(n3));
        }, n2.prototype.k = function(n3) {
          var r2, t2 = this.S >>> 3, e2 = t2 / 4 - 1;
          if (1 !== this.numRounds) throw new Error("Cannot set numRounds with MAC");
          if (this.A) throw new Error("MAC key already set");
          for (t2 < n3.binLen / 8 && (n3.value = this.K(n3.value, n3.binLen, 0, this.L(this.o), this.U)); n3.value.length <= e2; ) n3.value.push(0);
          for (r2 = 0; r2 <= e2; r2 += 1) this.l[r2] = 909522486 ^ n3.value[r2], this.H[r2] = 1549556828 ^ n3.value[r2];
          this.m = this.R(this.l, this.m), this.v = this.S, this.A = true;
        }, n2.prototype.getHMAC = function(n3, r2) {
          var t2 = s(r2);
          return e(n3, this.U, this.C, t2)(this.Y());
        }, n2.prototype.Y = function() {
          var n3;
          if (!this.A) throw new Error("Cannot call getHMAC without first setting MAC key");
          var r2 = this.K(this.u.slice(), this.s, this.v, this.B(this.m), this.U);
          return n3 = this.R(this.H, this.L(this.o)), n3 = this.K(r2, this.U, this.S, n3, this.U);
        }, n2;
      })(), c = function(n2, r2) {
        return (c = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n3, r3) {
          n3.__proto__ = r3;
        } || function(n3, r3) {
          for (var t2 in r3) Object.prototype.hasOwnProperty.call(r3, t2) && (n3[t2] = r3[t2]);
        })(n2, r2);
      };
      function v2(n2, r2) {
        function t2() {
          this.constructor = n2;
        }
        c(n2, r2), n2.prototype = null === r2 ? Object.create(r2) : (t2.prototype = r2.prototype, new t2());
      }
      function A2(n2, r2) {
        return n2 << r2 | n2 >>> 32 - r2;
      }
      function E(n2, r2) {
        return n2 >>> r2 | n2 << 32 - r2;
      }
      function l(n2, r2) {
        return n2 >>> r2;
      }
      function b(n2, r2, t2) {
        return n2 ^ r2 ^ t2;
      }
      function H(n2, r2, t2) {
        return n2 & r2 ^ ~n2 & t2;
      }
      function d(n2, r2, t2) {
        return n2 & r2 ^ n2 & t2 ^ r2 & t2;
      }
      function S(n2) {
        return E(n2, 2) ^ E(n2, 13) ^ E(n2, 22);
      }
      function p(n2, r2) {
        var t2 = (65535 & n2) + (65535 & r2);
        return (65535 & (n2 >>> 16) + (r2 >>> 16) + (t2 >>> 16)) << 16 | 65535 & t2;
      }
      function m(n2, r2, t2, e2) {
        var i2 = (65535 & n2) + (65535 & r2) + (65535 & t2) + (65535 & e2);
        return (65535 & (n2 >>> 16) + (r2 >>> 16) + (t2 >>> 16) + (e2 >>> 16) + (i2 >>> 16)) << 16 | 65535 & i2;
      }
      function y(n2, r2, t2, e2, i2) {
        var o2 = (65535 & n2) + (65535 & r2) + (65535 & t2) + (65535 & e2) + (65535 & i2);
        return (65535 & (n2 >>> 16) + (r2 >>> 16) + (t2 >>> 16) + (e2 >>> 16) + (i2 >>> 16) + (o2 >>> 16)) << 16 | 65535 & o2;
      }
      function R(n2) {
        return E(n2, 7) ^ E(n2, 18) ^ l(n2, 3);
      }
      function U(n2) {
        return E(n2, 6) ^ E(n2, 11) ^ E(n2, 25);
      }
      function T2(n2) {
        return [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      }
      function C(n2, r2) {
        var t2, e2, i2, o2, u2, f2, w2, s2 = [];
        for (t2 = r2[0], e2 = r2[1], i2 = r2[2], o2 = r2[3], u2 = r2[4], w2 = 0; w2 < 80; w2 += 1) s2[w2] = w2 < 16 ? n2[w2] : A2(s2[w2 - 3] ^ s2[w2 - 8] ^ s2[w2 - 14] ^ s2[w2 - 16], 1), f2 = w2 < 20 ? y(A2(t2, 5), H(e2, i2, o2), u2, 1518500249, s2[w2]) : w2 < 40 ? y(A2(t2, 5), b(e2, i2, o2), u2, 1859775393, s2[w2]) : w2 < 60 ? y(A2(t2, 5), d(e2, i2, o2), u2, 2400959708, s2[w2]) : y(A2(t2, 5), b(e2, i2, o2), u2, 3395469782, s2[w2]), u2 = o2, o2 = i2, i2 = A2(e2, 30), e2 = t2, t2 = f2;
        return r2[0] = p(t2, r2[0]), r2[1] = p(e2, r2[1]), r2[2] = p(i2, r2[2]), r2[3] = p(o2, r2[3]), r2[4] = p(u2, r2[4]), r2;
      }
      function F(n2, r2, t2, e2) {
        for (var i2, o2 = 15 + (r2 + 65 >>> 9 << 4), u2 = r2 + t2; n2.length <= o2; ) n2.push(0);
        for (n2[r2 >>> 5] |= 128 << 24 - r2 % 32, n2[o2] = 4294967295 & u2, n2[o2 - 1] = u2 / 4294967296 | 0, i2 = 0; i2 < n2.length; i2 += 16) e2 = C(n2.slice(i2, i2 + 16), e2);
        return e2;
      }
      var K = (function(n2) {
        function r2(r3, e2, i2) {
          var o2 = this;
          if ("SHA-1" !== r3) throw new Error(f);
          var u2 = i2 || {};
          return (o2 = n2.call(this, r3, e2, i2) || this).g = true, o2.F = o2.Y, o2.C = -1, o2.p = t(o2.t, o2.i, o2.C), o2.R = C, o2.B = function(n3) {
            return n3.slice();
          }, o2.L = T2, o2.K = F, o2.m = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], o2.S = 512, o2.U = 160, o2.T = false, u2.hmacKey && o2.k(a("hmacKey", u2.hmacKey, o2.C)), o2;
        }
        return v2(r2, n2), r2;
      })(h);
      function B2(n2) {
        return "SHA-224" == n2 ? o.slice() : u.slice();
      }
      function L(n2, r2) {
        var t2, e2, o2, u2, f2, w2, s2, a2, h2, c2, v3, A3, b2 = [];
        for (t2 = r2[0], e2 = r2[1], o2 = r2[2], u2 = r2[3], f2 = r2[4], w2 = r2[5], s2 = r2[6], a2 = r2[7], v3 = 0; v3 < 64; v3 += 1) b2[v3] = v3 < 16 ? n2[v3] : m(E(A3 = b2[v3 - 2], 17) ^ E(A3, 19) ^ l(A3, 10), b2[v3 - 7], R(b2[v3 - 15]), b2[v3 - 16]), h2 = y(a2, U(f2), H(f2, w2, s2), i[v3], b2[v3]), c2 = p(S(t2), d(t2, e2, o2)), a2 = s2, s2 = w2, w2 = f2, f2 = p(u2, h2), u2 = o2, o2 = e2, e2 = t2, t2 = p(h2, c2);
        return r2[0] = p(t2, r2[0]), r2[1] = p(e2, r2[1]), r2[2] = p(o2, r2[2]), r2[3] = p(u2, r2[3]), r2[4] = p(f2, r2[4]), r2[5] = p(w2, r2[5]), r2[6] = p(s2, r2[6]), r2[7] = p(a2, r2[7]), r2;
      }
      var g2 = (function(n2) {
        function r2(r3, e2, i2) {
          var o2 = this;
          if ("SHA-224" !== r3 && "SHA-256" !== r3) throw new Error(f);
          var u2 = i2 || {};
          return (o2 = n2.call(this, r3, e2, i2) || this).F = o2.Y, o2.g = true, o2.C = -1, o2.p = t(o2.t, o2.i, o2.C), o2.R = L, o2.B = function(n3) {
            return n3.slice();
          }, o2.L = B2, o2.K = function(n3, t2, e3, i3) {
            return (function(n4, r4, t3, e4, i4) {
              for (var o3, u3 = 15 + (r4 + 65 >>> 9 << 4), f2 = r4 + t3; n4.length <= u3; ) n4.push(0);
              for (n4[r4 >>> 5] |= 128 << 24 - r4 % 32, n4[u3] = 4294967295 & f2, n4[u3 - 1] = f2 / 4294967296 | 0, o3 = 0; o3 < n4.length; o3 += 16) e4 = L(n4.slice(o3, o3 + 16), e4);
              return "SHA-224" === i4 ? [e4[0], e4[1], e4[2], e4[3], e4[4], e4[5], e4[6]] : e4;
            })(n3, t2, e3, i3, r3);
          }, o2.m = B2(r3), o2.S = 512, o2.U = "SHA-224" === r3 ? 224 : 256, o2.T = false, u2.hmacKey && o2.k(a("hmacKey", u2.hmacKey, o2.C)), o2;
        }
        return v2(r2, n2), r2;
      })(h), k = function(n2, r2) {
        this.N = n2, this.I = r2;
      };
      function Y(n2, r2) {
        var t2;
        return r2 > 32 ? (t2 = 64 - r2, new k(n2.I << r2 | n2.N >>> t2, n2.N << r2 | n2.I >>> t2)) : 0 !== r2 ? (t2 = 32 - r2, new k(n2.N << r2 | n2.I >>> t2, n2.I << r2 | n2.N >>> t2)) : n2;
      }
      function N(n2, r2) {
        var t2;
        return r2 < 32 ? (t2 = 32 - r2, new k(n2.N >>> r2 | n2.I << t2, n2.I >>> r2 | n2.N << t2)) : (t2 = 64 - r2, new k(n2.I >>> r2 | n2.N << t2, n2.N >>> r2 | n2.I << t2));
      }
      function I(n2, r2) {
        return new k(n2.N >>> r2, n2.I >>> r2 | n2.N << 32 - r2);
      }
      function M(n2, r2, t2) {
        return new k(n2.N & r2.N ^ ~n2.N & t2.N, n2.I & r2.I ^ ~n2.I & t2.I);
      }
      function X(n2, r2, t2) {
        return new k(n2.N & r2.N ^ n2.N & t2.N ^ r2.N & t2.N, n2.I & r2.I ^ n2.I & t2.I ^ r2.I & t2.I);
      }
      function z(n2) {
        var r2 = N(n2, 28), t2 = N(n2, 34), e2 = N(n2, 39);
        return new k(r2.N ^ t2.N ^ e2.N, r2.I ^ t2.I ^ e2.I);
      }
      function O(n2, r2) {
        var t2, e2;
        t2 = (65535 & n2.I) + (65535 & r2.I);
        var i2 = (65535 & (e2 = (n2.I >>> 16) + (r2.I >>> 16) + (t2 >>> 16))) << 16 | 65535 & t2;
        return t2 = (65535 & n2.N) + (65535 & r2.N) + (e2 >>> 16), e2 = (n2.N >>> 16) + (r2.N >>> 16) + (t2 >>> 16), new k((65535 & e2) << 16 | 65535 & t2, i2);
      }
      function j(n2, r2, t2, e2) {
        var i2, o2;
        i2 = (65535 & n2.I) + (65535 & r2.I) + (65535 & t2.I) + (65535 & e2.I);
        var u2 = (65535 & (o2 = (n2.I >>> 16) + (r2.I >>> 16) + (t2.I >>> 16) + (e2.I >>> 16) + (i2 >>> 16))) << 16 | 65535 & i2;
        return i2 = (65535 & n2.N) + (65535 & r2.N) + (65535 & t2.N) + (65535 & e2.N) + (o2 >>> 16), o2 = (n2.N >>> 16) + (r2.N >>> 16) + (t2.N >>> 16) + (e2.N >>> 16) + (i2 >>> 16), new k((65535 & o2) << 16 | 65535 & i2, u2);
      }
      function _(n2, r2, t2, e2, i2) {
        var o2, u2;
        o2 = (65535 & n2.I) + (65535 & r2.I) + (65535 & t2.I) + (65535 & e2.I) + (65535 & i2.I);
        var f2 = (65535 & (u2 = (n2.I >>> 16) + (r2.I >>> 16) + (t2.I >>> 16) + (e2.I >>> 16) + (i2.I >>> 16) + (o2 >>> 16))) << 16 | 65535 & o2;
        return o2 = (65535 & n2.N) + (65535 & r2.N) + (65535 & t2.N) + (65535 & e2.N) + (65535 & i2.N) + (u2 >>> 16), u2 = (n2.N >>> 16) + (r2.N >>> 16) + (t2.N >>> 16) + (e2.N >>> 16) + (i2.N >>> 16) + (o2 >>> 16), new k((65535 & u2) << 16 | 65535 & o2, f2);
      }
      function P2(n2, r2) {
        return new k(n2.N ^ r2.N, n2.I ^ r2.I);
      }
      function x(n2) {
        var r2 = N(n2, 1), t2 = N(n2, 8), e2 = I(n2, 7);
        return new k(r2.N ^ t2.N ^ e2.N, r2.I ^ t2.I ^ e2.I);
      }
      function V(n2) {
        var r2 = N(n2, 14), t2 = N(n2, 18), e2 = N(n2, 41);
        return new k(r2.N ^ t2.N ^ e2.N, r2.I ^ t2.I ^ e2.I);
      }
      var Z = [new k(i[0], 3609767458), new k(i[1], 602891725), new k(i[2], 3964484399), new k(i[3], 2173295548), new k(i[4], 4081628472), new k(i[5], 3053834265), new k(i[6], 2937671579), new k(i[7], 3664609560), new k(i[8], 2734883394), new k(i[9], 1164996542), new k(i[10], 1323610764), new k(i[11], 3590304994), new k(i[12], 4068182383), new k(i[13], 991336113), new k(i[14], 633803317), new k(i[15], 3479774868), new k(i[16], 2666613458), new k(i[17], 944711139), new k(i[18], 2341262773), new k(i[19], 2007800933), new k(i[20], 1495990901), new k(i[21], 1856431235), new k(i[22], 3175218132), new k(i[23], 2198950837), new k(i[24], 3999719339), new k(i[25], 766784016), new k(i[26], 2566594879), new k(i[27], 3203337956), new k(i[28], 1034457026), new k(i[29], 2466948901), new k(i[30], 3758326383), new k(i[31], 168717936), new k(i[32], 1188179964), new k(i[33], 1546045734), new k(i[34], 1522805485), new k(i[35], 2643833823), new k(i[36], 2343527390), new k(i[37], 1014477480), new k(i[38], 1206759142), new k(i[39], 344077627), new k(i[40], 1290863460), new k(i[41], 3158454273), new k(i[42], 3505952657), new k(i[43], 106217008), new k(i[44], 3606008344), new k(i[45], 1432725776), new k(i[46], 1467031594), new k(i[47], 851169720), new k(i[48], 3100823752), new k(i[49], 1363258195), new k(i[50], 3750685593), new k(i[51], 3785050280), new k(i[52], 3318307427), new k(i[53], 3812723403), new k(i[54], 2003034995), new k(i[55], 3602036899), new k(i[56], 1575990012), new k(i[57], 1125592928), new k(i[58], 2716904306), new k(i[59], 442776044), new k(i[60], 593698344), new k(i[61], 3733110249), new k(i[62], 2999351573), new k(i[63], 3815920427), new k(3391569614, 3928383900), new k(3515267271, 566280711), new k(3940187606, 3454069534), new k(4118630271, 4000239992), new k(116418474, 1914138554), new k(174292421, 2731055270), new k(289380356, 3203993006), new k(460393269, 320620315), new k(685471733, 587496836), new k(852142971, 1086792851), new k(1017036298, 365543100), new k(1126000580, 2618297676), new k(1288033470, 3409855158), new k(1501505948, 4234509866), new k(1607167915, 987167468), new k(1816402316, 1246189591)];
      function q(n2) {
        return "SHA-384" === n2 ? [new k(3418070365, o[0]), new k(1654270250, o[1]), new k(2438529370, o[2]), new k(355462360, o[3]), new k(1731405415, o[4]), new k(41048885895, o[5]), new k(3675008525, o[6]), new k(1203062813, o[7])] : [new k(u[0], 4089235720), new k(u[1], 2227873595), new k(u[2], 4271175723), new k(u[3], 1595750129), new k(u[4], 2917565137), new k(u[5], 725511199), new k(u[6], 4215389547), new k(u[7], 327033209)];
      }
      function D(n2, r2) {
        var t2, e2, i2, o2, u2, f2, w2, s2, a2, h2, c2, v3, A3, E2, l2, b2, H2 = [];
        for (t2 = r2[0], e2 = r2[1], i2 = r2[2], o2 = r2[3], u2 = r2[4], f2 = r2[5], w2 = r2[6], s2 = r2[7], c2 = 0; c2 < 80; c2 += 1) c2 < 16 ? (v3 = 2 * c2, H2[c2] = new k(n2[v3], n2[v3 + 1])) : H2[c2] = j((A3 = H2[c2 - 2], E2 = void 0, l2 = void 0, b2 = void 0, E2 = N(A3, 19), l2 = N(A3, 61), b2 = I(A3, 6), new k(E2.N ^ l2.N ^ b2.N, E2.I ^ l2.I ^ b2.I)), H2[c2 - 7], x(H2[c2 - 15]), H2[c2 - 16]), a2 = _(s2, V(u2), M(u2, f2, w2), Z[c2], H2[c2]), h2 = O(z(t2), X(t2, e2, i2)), s2 = w2, w2 = f2, f2 = u2, u2 = O(o2, a2), o2 = i2, i2 = e2, e2 = t2, t2 = O(a2, h2);
        return r2[0] = O(t2, r2[0]), r2[1] = O(e2, r2[1]), r2[2] = O(i2, r2[2]), r2[3] = O(o2, r2[3]), r2[4] = O(u2, r2[4]), r2[5] = O(f2, r2[5]), r2[6] = O(w2, r2[6]), r2[7] = O(s2, r2[7]), r2;
      }
      var G = (function(n2) {
        function r2(r3, e2, i2) {
          var o2 = this;
          if ("SHA-384" !== r3 && "SHA-512" !== r3) throw new Error(f);
          var u2 = i2 || {};
          return (o2 = n2.call(this, r3, e2, i2) || this).F = o2.Y, o2.g = true, o2.C = -1, o2.p = t(o2.t, o2.i, o2.C), o2.R = D, o2.B = function(n3) {
            return n3.slice();
          }, o2.L = q, o2.K = function(n3, t2, e3, i3) {
            return (function(n4, r4, t3, e4, i4) {
              for (var o3, u3 = 31 + (r4 + 129 >>> 10 << 5), f2 = r4 + t3; n4.length <= u3; ) n4.push(0);
              for (n4[r4 >>> 5] |= 128 << 24 - r4 % 32, n4[u3] = 4294967295 & f2, n4[u3 - 1] = f2 / 4294967296 | 0, o3 = 0; o3 < n4.length; o3 += 32) e4 = D(n4.slice(o3, o3 + 32), e4);
              return "SHA-384" === i4 ? [(e4 = e4)[0].N, e4[0].I, e4[1].N, e4[1].I, e4[2].N, e4[2].I, e4[3].N, e4[3].I, e4[4].N, e4[4].I, e4[5].N, e4[5].I] : [e4[0].N, e4[0].I, e4[1].N, e4[1].I, e4[2].N, e4[2].I, e4[3].N, e4[3].I, e4[4].N, e4[4].I, e4[5].N, e4[5].I, e4[6].N, e4[6].I, e4[7].N, e4[7].I];
            })(n3, t2, e3, i3, r3);
          }, o2.m = q(r3), o2.S = 1024, o2.U = "SHA-384" === r3 ? 384 : 512, o2.T = false, u2.hmacKey && o2.k(a("hmacKey", u2.hmacKey, o2.C)), o2;
        }
        return v2(r2, n2), r2;
      })(h), J = [new k(0, 1), new k(0, 32898), new k(2147483648, 32906), new k(2147483648, 2147516416), new k(0, 32907), new k(0, 2147483649), new k(2147483648, 2147516545), new k(2147483648, 32777), new k(0, 138), new k(0, 136), new k(0, 2147516425), new k(0, 2147483658), new k(0, 2147516555), new k(2147483648, 139), new k(2147483648, 32905), new k(2147483648, 32771), new k(2147483648, 32770), new k(2147483648, 128), new k(0, 32778), new k(2147483648, 2147483658), new k(2147483648, 2147516545), new k(2147483648, 32896), new k(0, 2147483649), new k(2147483648, 2147516424)], Q = [[0, 36, 3, 41, 18], [1, 44, 10, 45, 2], [62, 6, 43, 15, 61], [28, 55, 25, 21, 56], [27, 20, 39, 8, 14]];
      function W(n2) {
        var r2, t2 = [];
        for (r2 = 0; r2 < 5; r2 += 1) t2[r2] = [new k(0, 0), new k(0, 0), new k(0, 0), new k(0, 0), new k(0, 0)];
        return t2;
      }
      function $2(n2) {
        var r2, t2 = [];
        for (r2 = 0; r2 < 5; r2 += 1) t2[r2] = n2[r2].slice();
        return t2;
      }
      function nn(n2, r2) {
        var t2, e2, i2, o2, u2, f2, w2, s2, a2, h2 = [], c2 = [];
        if (null !== n2) for (e2 = 0; e2 < n2.length; e2 += 2) r2[(e2 >>> 1) % 5][(e2 >>> 1) / 5 | 0] = P2(r2[(e2 >>> 1) % 5][(e2 >>> 1) / 5 | 0], new k(n2[e2 + 1], n2[e2]));
        for (t2 = 0; t2 < 24; t2 += 1) {
          for (o2 = W(), e2 = 0; e2 < 5; e2 += 1) h2[e2] = (u2 = r2[e2][0], f2 = r2[e2][1], w2 = r2[e2][2], s2 = r2[e2][3], a2 = r2[e2][4], new k(u2.N ^ f2.N ^ w2.N ^ s2.N ^ a2.N, u2.I ^ f2.I ^ w2.I ^ s2.I ^ a2.I));
          for (e2 = 0; e2 < 5; e2 += 1) c2[e2] = P2(h2[(e2 + 4) % 5], Y(h2[(e2 + 1) % 5], 1));
          for (e2 = 0; e2 < 5; e2 += 1) for (i2 = 0; i2 < 5; i2 += 1) r2[e2][i2] = P2(r2[e2][i2], c2[e2]);
          for (e2 = 0; e2 < 5; e2 += 1) for (i2 = 0; i2 < 5; i2 += 1) o2[i2][(2 * e2 + 3 * i2) % 5] = Y(r2[e2][i2], Q[e2][i2]);
          for (e2 = 0; e2 < 5; e2 += 1) for (i2 = 0; i2 < 5; i2 += 1) r2[e2][i2] = P2(o2[e2][i2], new k(~o2[(e2 + 1) % 5][i2].N & o2[(e2 + 2) % 5][i2].N, ~o2[(e2 + 1) % 5][i2].I & o2[(e2 + 2) % 5][i2].I));
          r2[0][0] = P2(r2[0][0], J[t2]);
        }
        return r2;
      }
      function rn(n2) {
        var r2, t2, e2 = 0, i2 = [0, 0], o2 = [4294967295 & n2, n2 / 4294967296 & 2097151];
        for (r2 = 6; r2 >= 0; r2--) 0 === (t2 = o2[r2 >> 2] >>> 8 * r2 & 255) && 0 === e2 || (i2[e2 + 1 >> 2] |= t2 << 8 * (e2 + 1), e2 += 1);
        return e2 = 0 !== e2 ? e2 : 1, i2[0] |= e2, { value: e2 + 1 > 4 ? i2 : [i2[0]], binLen: 8 + 8 * e2 };
      }
      function tn(n2) {
        return w(rn(n2.binLen), n2);
      }
      function en2(n2, r2) {
        var t2, e2 = rn(r2), i2 = r2 >>> 2, o2 = (i2 - (e2 = w(e2, n2)).value.length % i2) % i2;
        for (t2 = 0; t2 < o2; t2++) e2.value.push(0);
        return e2.value;
      }
      var on = (function(n2) {
        function r2(r3, e2, i2) {
          var o2 = this, u2 = 6, w2 = 0, s2 = i2 || {};
          if (1 !== (o2 = n2.call(this, r3, e2, i2) || this).numRounds) {
            if (s2.kmacKey || s2.hmacKey) throw new Error("Cannot set numRounds with MAC");
            if ("CSHAKE128" === o2.o || "CSHAKE256" === o2.o) throw new Error("Cannot set numRounds for CSHAKE variants");
          }
          switch (o2.C = 1, o2.p = t(o2.t, o2.i, o2.C), o2.R = nn, o2.B = $2, o2.L = W, o2.m = W(), o2.T = false, r3) {
            case "SHA3-224":
              o2.S = w2 = 1152, o2.U = 224, o2.g = true, o2.F = o2.Y;
              break;
            case "SHA3-256":
              o2.S = w2 = 1088, o2.U = 256, o2.g = true, o2.F = o2.Y;
              break;
            case "SHA3-384":
              o2.S = w2 = 832, o2.U = 384, o2.g = true, o2.F = o2.Y;
              break;
            case "SHA3-512":
              o2.S = w2 = 576, o2.U = 512, o2.g = true, o2.F = o2.Y;
              break;
            case "SHAKE128":
              u2 = 31, o2.S = w2 = 1344, o2.U = -1, o2.T = true, o2.g = false, o2.F = null;
              break;
            case "SHAKE256":
              u2 = 31, o2.S = w2 = 1088, o2.U = -1, o2.T = true, o2.g = false, o2.F = null;
              break;
            case "KMAC128":
              u2 = 4, o2.S = w2 = 1344, o2.M(i2), o2.U = -1, o2.T = true, o2.g = false, o2.F = o2.X;
              break;
            case "KMAC256":
              u2 = 4, o2.S = w2 = 1088, o2.M(i2), o2.U = -1, o2.T = true, o2.g = false, o2.F = o2.X;
              break;
            case "CSHAKE128":
              o2.S = w2 = 1344, u2 = o2.O(i2), o2.U = -1, o2.T = true, o2.g = false, o2.F = null;
              break;
            case "CSHAKE256":
              o2.S = w2 = 1088, u2 = o2.O(i2), o2.U = -1, o2.T = true, o2.g = false, o2.F = null;
              break;
            default:
              throw new Error(f);
          }
          return o2.K = function(n3, r4, t2, e3, i3) {
            return (function(n4, r5, t3, e4, i4, o3, u3) {
              var f2, w3, s4 = 0, a2 = [], h2 = i4 >>> 5, c2 = r5 >>> 5;
              for (f2 = 0; f2 < c2 && r5 >= i4; f2 += h2) e4 = nn(n4.slice(f2, f2 + h2), e4), r5 -= i4;
              for (n4 = n4.slice(f2), r5 %= i4; n4.length < h2; ) n4.push(0);
              for (n4[(f2 = r5 >>> 3) >> 2] ^= o3 << f2 % 4 * 8, n4[h2 - 1] ^= 2147483648, e4 = nn(n4, e4); 32 * a2.length < u3 && (w3 = e4[s4 % 5][s4 / 5 | 0], a2.push(w3.I), !(32 * a2.length >= u3)); ) a2.push(w3.N), 0 == 64 * (s4 += 1) % i4 && (nn(null, e4), s4 = 0);
              return a2;
            })(n3, r4, 0, e3, w2, u2, i3);
          }, s2.hmacKey && o2.k(a("hmacKey", s2.hmacKey, o2.C)), o2;
        }
        return v2(r2, n2), r2.prototype.O = function(n3, r3) {
          var t2 = (function(n4) {
            var r4 = n4 || {};
            return { funcName: a("funcName", r4.funcName, 1, { value: [], binLen: 0 }), customization: a("Customization", r4.customization, 1, { value: [], binLen: 0 }) };
          })(n3 || {});
          r3 && (t2.funcName = r3);
          var e2 = w(tn(t2.funcName), tn(t2.customization));
          if (0 !== t2.customization.binLen || 0 !== t2.funcName.binLen) {
            for (var i2 = en2(e2, this.S >>> 3), o2 = 0; o2 < i2.length; o2 += this.S >>> 5) this.m = this.R(i2.slice(o2, o2 + (this.S >>> 5)), this.m), this.v += this.S;
            return 4;
          }
          return 31;
        }, r2.prototype.M = function(n3) {
          var r3 = (function(n4) {
            var r4 = n4 || {};
            return { kmacKey: a("kmacKey", r4.kmacKey, 1), funcName: { value: [1128353099], binLen: 32 }, customization: a("Customization", r4.customization, 1, { value: [], binLen: 0 }) };
          })(n3 || {});
          this.O(n3, r3.funcName);
          for (var t2 = en2(tn(r3.kmacKey), this.S >>> 3), e2 = 0; e2 < t2.length; e2 += this.S >>> 5) this.m = this.R(t2.slice(e2, e2 + (this.S >>> 5)), this.m), this.v += this.S;
          this.A = true;
        }, r2.prototype.X = function(n3) {
          var r3 = w({ value: this.u.slice(), binLen: this.s }, (function(n4) {
            var r4, t2, e2 = 0, i2 = [0, 0], o2 = [4294967295 & n4, n4 / 4294967296 & 2097151];
            for (r4 = 6; r4 >= 0; r4--) 0 == (t2 = o2[r4 >> 2] >>> 8 * r4 & 255) && 0 === e2 || (i2[e2 >> 2] |= t2 << 8 * e2, e2 += 1);
            return i2[(e2 = 0 !== e2 ? e2 : 1) >> 2] |= e2 << 8 * e2, { value: e2 + 1 > 4 ? i2 : [i2[0]], binLen: 8 + 8 * e2 };
          })(n3.outputLen));
          return this.K(r3.value, r3.binLen, this.v, this.B(this.m), n3.outputLen);
        }, r2;
      })(h);
      return (function() {
        function n2(n3, r2, t2) {
          if ("SHA-1" == n3) this.j = new K(n3, r2, t2);
          else if ("SHA-224" == n3 || "SHA-256" == n3) this.j = new g2(n3, r2, t2);
          else if ("SHA-384" == n3 || "SHA-512" == n3) this.j = new G(n3, r2, t2);
          else {
            if ("SHA3-224" != n3 && "SHA3-256" != n3 && "SHA3-384" != n3 && "SHA3-512" != n3 && "SHAKE128" != n3 && "SHAKE256" != n3 && "CSHAKE128" != n3 && "CSHAKE256" != n3 && "KMAC128" != n3 && "KMAC256" != n3) throw new Error(f);
            this.j = new on(n3, r2, t2);
          }
        }
        return n2.prototype.update = function(n3) {
          this.j.update(n3);
        }, n2.prototype.getHash = function(n3, r2) {
          return this.j.getHash(n3, r2);
        }, n2.prototype.setHMACKey = function(n3, r2, t2) {
          this.j.setHMACKey(n3, r2, t2);
        }, n2.prototype.getHMAC = function(n3, r2) {
          return this.j.getHMAC(n3, r2);
        }, n2;
      })();
    }));
  })(sha$1);
  return sha$1.exports;
}
var native = {};
var getSecureRandom$1 = {};
const expoCrypto = {};
function getRandomBytes(size) {
  const array = new Uint8Array(size);
  return crypto.getRandomValues(array);
}
const expoCrypto$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: expoCrypto,
  getRandomBytes
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$4 = /* @__PURE__ */ getAugmentedNamespace(expoCrypto$1);
var hasRequiredGetSecureRandom$1;
function requireGetSecureRandom$1() {
  if (hasRequiredGetSecureRandom$1) return getSecureRandom$1;
  hasRequiredGetSecureRandom$1 = 1;
  Object.defineProperty(getSecureRandom$1, "__esModule", { value: true });
  getSecureRandom$1.getSecureRandomWords = getSecureRandom$1.getSecureRandomBytes = void 0;
  const getRandomBytes2 = require$$0$4.getRandomBytes;
  function getSecureRandomBytes(size) {
    return Buffer.from(getRandomBytes2(size));
  }
  getSecureRandom$1.getSecureRandomBytes = getSecureRandomBytes;
  function getSecureRandomWords(size) {
    const bytes = getSecureRandomBytes(size * 2);
    return new Uint16Array(bytes.buffer, bytes.byteOffset, size);
  }
  getSecureRandom$1.getSecureRandomWords = getSecureRandomWords;
  return getSecureRandom$1;
}
var hmac_sha512$1 = {};
var hasRequiredHmac_sha512$1;
function requireHmac_sha512$1() {
  if (hasRequiredHmac_sha512$1) return hmac_sha512$1;
  hasRequiredHmac_sha512$1 = 1;
  var __importDefault = hmac_sha512$1 && hmac_sha512$1.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(hmac_sha512$1, "__esModule", { value: true });
  hmac_sha512$1.hmac_sha512 = void 0;
  const jssha_1 = __importDefault(requireSha());
  async function hmac_sha5122(key2, data) {
    let keyBuffer = typeof key2 === "string" ? Buffer.from(key2, "utf-8") : key2;
    let dataBuffer = typeof data === "string" ? Buffer.from(data, "utf-8") : data;
    const shaObj = new jssha_1.default("SHA-512", "HEX", {
      hmacKey: { value: keyBuffer.toString("hex"), format: "HEX" }
    });
    shaObj.update(dataBuffer.toString("hex"));
    const hmac2 = shaObj.getHash("HEX");
    return Buffer.from(hmac2, "hex");
  }
  hmac_sha512$1.hmac_sha512 = hmac_sha5122;
  return hmac_sha512$1;
}
var pbkdf2_sha512$1 = {};
const implementation = {
  derive(password, salt, iterations, keySize, hash) {
    return window.Pbkdf2.derive(password, salt, iterations, keySize, hash);
  }
};
const pbkdf2$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: implementation
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$3 = /* @__PURE__ */ getAugmentedNamespace(pbkdf2$1);
var hasRequiredPbkdf2_sha512$1;
function requirePbkdf2_sha512$1() {
  if (hasRequiredPbkdf2_sha512$1) return pbkdf2_sha512$1;
  hasRequiredPbkdf2_sha512$1 = 1;
  Object.defineProperty(pbkdf2_sha512$1, "__esModule", { value: true });
  pbkdf2_sha512$1.pbkdf2_sha512 = void 0;
  async function pbkdf2_sha5122(key2, salt, iterations, keyLen) {
    const keyBuffer = typeof key2 === "string" ? Buffer.from(key2, "utf-8") : key2;
    const saltBuffer = typeof salt === "string" ? Buffer.from(salt, "utf-8") : salt;
    let pbkdf22 = require$$0$3.default;
    let res = await pbkdf22.derive(keyBuffer.toString("base64"), saltBuffer.toString("base64"), iterations, keyLen, "sha-512");
    return Buffer.from(res, "base64");
  }
  pbkdf2_sha512$1.pbkdf2_sha512 = pbkdf2_sha5122;
  return pbkdf2_sha512$1;
}
var sha256$1 = {};
var hasRequiredSha256$2;
function requireSha256$2() {
  if (hasRequiredSha256$2) return sha256$1;
  hasRequiredSha256$2 = 1;
  var __importDefault = sha256$1 && sha256$1.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(sha256$1, "__esModule", { value: true });
  sha256$1.sha256 = void 0;
  const jssha_1 = __importDefault(requireSha());
  async function sha2562(source) {
    let src2;
    if (typeof source === "string") {
      src2 = Buffer.from(source, "utf-8").toString("hex");
    } else {
      src2 = source.toString("hex");
    }
    let hasher = new jssha_1.default("SHA-256", "HEX");
    hasher.update(src2);
    let res = hasher.getHash("HEX");
    return Buffer.from(res, "hex");
  }
  sha256$1.sha256 = sha2562;
  return sha256$1;
}
var sha512$2 = {};
var hasRequiredSha512$2;
function requireSha512$2() {
  if (hasRequiredSha512$2) return sha512$2;
  hasRequiredSha512$2 = 1;
  var __importDefault = sha512$2 && sha512$2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(sha512$2, "__esModule", { value: true });
  sha512$2.sha512 = void 0;
  const jssha_1 = __importDefault(requireSha());
  async function sha5122(source) {
    let src2;
    if (typeof source === "string") {
      src2 = Buffer.from(source, "utf-8").toString("hex");
    } else {
      src2 = source.toString("hex");
    }
    let hasher = new jssha_1.default("SHA-512", "HEX");
    hasher.update(src2);
    let res = hasher.getHash("HEX");
    return Buffer.from(res, "hex");
  }
  sha512$2.sha512 = sha5122;
  return sha512$2;
}
var hasRequiredNative;
function requireNative() {
  if (hasRequiredNative) return native;
  hasRequiredNative = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha512 = exports.sha256 = exports.pbkdf2_sha512 = exports.hmac_sha512 = exports.getSecureRandomWords = exports.getSecureRandomBytes = void 0;
    var getSecureRandom_1 = requireGetSecureRandom$1();
    Object.defineProperty(exports, "getSecureRandomBytes", { enumerable: true, get: function() {
      return getSecureRandom_1.getSecureRandomBytes;
    } });
    Object.defineProperty(exports, "getSecureRandomWords", { enumerable: true, get: function() {
      return getSecureRandom_1.getSecureRandomWords;
    } });
    var hmac_sha512_1 = requireHmac_sha512$1();
    Object.defineProperty(exports, "hmac_sha512", { enumerable: true, get: function() {
      return hmac_sha512_1.hmac_sha512;
    } });
    var pbkdf2_sha512_1 = requirePbkdf2_sha512$1();
    Object.defineProperty(exports, "pbkdf2_sha512", { enumerable: true, get: function() {
      return pbkdf2_sha512_1.pbkdf2_sha512;
    } });
    var sha256_1 = requireSha256$2();
    Object.defineProperty(exports, "sha256", { enumerable: true, get: function() {
      return sha256_1.sha256;
    } });
    var sha512_1 = requireSha512$2();
    Object.defineProperty(exports, "sha512", { enumerable: true, get: function() {
      return sha512_1.sha512;
    } });
  })(native);
  return native;
}
var hasRequiredSha256$1;
function requireSha256$1() {
  if (hasRequiredSha256$1) return sha256$2;
  hasRequiredSha256$1 = 1;
  var __importDefault = sha256$2 && sha256$2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(sha256$2, "__esModule", { value: true });
  sha256$2.sha256 = sha256$2.sha256_fallback = sha256$2.sha256_sync = void 0;
  const jssha_1 = __importDefault(requireSha());
  const crypto_primitives_1 = requireNative();
  function sha256_sync(source) {
    let src2;
    if (typeof source === "string") {
      src2 = Buffer.from(source, "utf-8").toString("hex");
    } else {
      src2 = source.toString("hex");
    }
    let hasher = new jssha_1.default("SHA-256", "HEX");
    hasher.update(src2);
    let res = hasher.getHash("HEX");
    return Buffer.from(res, "hex");
  }
  sha256$2.sha256_sync = sha256_sync;
  async function sha256_fallback(source) {
    return sha256_sync(source);
  }
  sha256$2.sha256_fallback = sha256_fallback;
  function sha2562(source) {
    return (0, crypto_primitives_1.sha256)(source);
  }
  sha256$2.sha256 = sha2562;
  return sha256$2;
}
var sha512$1 = {};
var hasRequiredSha512$1;
function requireSha512$1() {
  if (hasRequiredSha512$1) return sha512$1;
  hasRequiredSha512$1 = 1;
  var __importDefault = sha512$1 && sha512$1.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(sha512$1, "__esModule", { value: true });
  sha512$1.sha512 = sha512$1.sha512_fallback = sha512$1.sha512_sync = void 0;
  const jssha_1 = __importDefault(requireSha());
  const crypto_primitives_1 = requireNative();
  function sha512_sync(source) {
    let src2;
    if (typeof source === "string") {
      src2 = Buffer.from(source, "utf-8").toString("hex");
    } else {
      src2 = source.toString("hex");
    }
    let hasher = new jssha_1.default("SHA-512", "HEX");
    hasher.update(src2);
    let res = hasher.getHash("HEX");
    return Buffer.from(res, "hex");
  }
  sha512$1.sha512_sync = sha512_sync;
  async function sha512_fallback(source) {
    return sha512_sync(source);
  }
  sha512$1.sha512_fallback = sha512_fallback;
  async function sha5122(source) {
    return (0, crypto_primitives_1.sha512)(source);
  }
  sha512$1.sha512 = sha5122;
  return sha512$1;
}
var pbkdf2_sha512 = {};
var hasRequiredPbkdf2_sha512;
function requirePbkdf2_sha512() {
  if (hasRequiredPbkdf2_sha512) return pbkdf2_sha512;
  hasRequiredPbkdf2_sha512 = 1;
  Object.defineProperty(pbkdf2_sha512, "__esModule", { value: true });
  pbkdf2_sha512.pbkdf2_sha512 = void 0;
  const crypto_primitives_1 = requireNative();
  function pbkdf2_sha512$12(key2, salt, iterations, keyLen) {
    return (0, crypto_primitives_1.pbkdf2_sha512)(key2, salt, iterations, keyLen);
  }
  pbkdf2_sha512.pbkdf2_sha512 = pbkdf2_sha512$12;
  return pbkdf2_sha512;
}
var hmac_sha512 = {};
var hasRequiredHmac_sha512;
function requireHmac_sha512() {
  if (hasRequiredHmac_sha512) return hmac_sha512;
  hasRequiredHmac_sha512 = 1;
  var __importDefault = hmac_sha512 && hmac_sha512.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(hmac_sha512, "__esModule", { value: true });
  hmac_sha512.hmac_sha512 = hmac_sha512.hmac_sha512_fallback = void 0;
  const jssha_1 = __importDefault(requireSha());
  const crypto_primitives_1 = requireNative();
  async function hmac_sha512_fallback(key2, data) {
    let keyBuffer = typeof key2 === "string" ? Buffer.from(key2, "utf-8") : key2;
    let dataBuffer = typeof data === "string" ? Buffer.from(data, "utf-8") : data;
    const shaObj = new jssha_1.default("SHA-512", "HEX", {
      hmacKey: { value: keyBuffer.toString("hex"), format: "HEX" }
    });
    shaObj.update(dataBuffer.toString("hex"));
    const hmac2 = shaObj.getHash("HEX");
    return Buffer.from(hmac2, "hex");
  }
  hmac_sha512.hmac_sha512_fallback = hmac_sha512_fallback;
  function hmac_sha512$12(key2, data) {
    return (0, crypto_primitives_1.hmac_sha512)(key2, data);
  }
  hmac_sha512.hmac_sha512 = hmac_sha512$12;
  return hmac_sha512;
}
var getSecureRandom = {};
var hasRequiredGetSecureRandom;
function requireGetSecureRandom() {
  if (hasRequiredGetSecureRandom) return getSecureRandom;
  hasRequiredGetSecureRandom = 1;
  Object.defineProperty(getSecureRandom, "__esModule", { value: true });
  getSecureRandom.getSecureRandomNumber = getSecureRandom.getSecureRandomWords = getSecureRandom.getSecureRandomBytes = void 0;
  const crypto_primitives_1 = requireNative();
  async function getSecureRandomBytes(size) {
    return (0, crypto_primitives_1.getSecureRandomBytes)(size);
  }
  getSecureRandom.getSecureRandomBytes = getSecureRandomBytes;
  async function getSecureRandomWords(size) {
    return getSecureRandomWords();
  }
  getSecureRandom.getSecureRandomWords = getSecureRandomWords;
  async function getSecureRandomNumber(min, max) {
    let range = max - min;
    var bitsNeeded = Math.ceil(Math.log2(range));
    if (bitsNeeded > 53) {
      throw new Error("Range is too large");
    }
    var bytesNeeded = Math.ceil(bitsNeeded / 8);
    var mask = Math.pow(2, bitsNeeded) - 1;
    while (true) {
      let res = await getSecureRandomBytes(bitsNeeded);
      let power = (bytesNeeded - 1) * 8;
      let numberValue = 0;
      for (var i = 0; i < bytesNeeded; i++) {
        numberValue += res[i] * Math.pow(2, power);
        power -= 8;
      }
      numberValue = numberValue & mask;
      if (numberValue >= range) {
        continue;
      }
      return min + numberValue;
    }
  }
  getSecureRandom.getSecureRandomNumber = getSecureRandomNumber;
  return getSecureRandom;
}
var newSecureWords = {};
var wordlist$1 = {};
var hasRequiredWordlist$1;
function requireWordlist$1() {
  if (hasRequiredWordlist$1) return wordlist$1;
  hasRequiredWordlist$1 = 1;
  Object.defineProperty(wordlist$1, "__esModule", { value: true });
  wordlist$1.wordlist = void 0;
  wordlist$1.wordlist = [
    "abacus",
    "abdomen",
    "abdominal",
    "abide",
    "abiding",
    "ability",
    "ablaze",
    "able",
    "abnormal",
    "abrasion",
    "abrasive",
    "abreast",
    "abridge",
    "abroad",
    "abruptly",
    "absence",
    "absentee",
    "absently",
    "absinthe",
    "absolute",
    "absolve",
    "abstain",
    "abstract",
    "absurd",
    "accent",
    "acclaim",
    "acclimate",
    "accompany",
    "account",
    "accuracy",
    "accurate",
    "accustom",
    "acetone",
    "achiness",
    "aching",
    "acid",
    "acorn",
    "acquaint",
    "acquire",
    "acre",
    "acrobat",
    "acronym",
    "acting",
    "action",
    "activate",
    "activator",
    "active",
    "activism",
    "activist",
    "activity",
    "actress",
    "acts",
    "acutely",
    "acuteness",
    "aeration",
    "aerobics",
    "aerosol",
    "aerospace",
    "afar",
    "affair",
    "affected",
    "affecting",
    "affection",
    "affidavit",
    "affiliate",
    "affirm",
    "affix",
    "afflicted",
    "affluent",
    "afford",
    "affront",
    "aflame",
    "afloat",
    "aflutter",
    "afoot",
    "afraid",
    "afterglow",
    "afterlife",
    "aftermath",
    "aftermost",
    "afternoon",
    "aged",
    "ageless",
    "agency",
    "agenda",
    "agent",
    "aggregate",
    "aghast",
    "agile",
    "agility",
    "aging",
    "agnostic",
    "agonize",
    "agonizing",
    "agony",
    "agreeable",
    "agreeably",
    "agreed",
    "agreeing",
    "agreement",
    "aground",
    "ahead",
    "ahoy",
    "aide",
    "aids",
    "aim",
    "ajar",
    "alabaster",
    "alarm",
    "albatross",
    "album",
    "alfalfa",
    "algebra",
    "algorithm",
    "alias",
    "alibi",
    "alienable",
    "alienate",
    "aliens",
    "alike",
    "alive",
    "alkaline",
    "alkalize",
    "almanac",
    "almighty",
    "almost",
    "aloe",
    "aloft",
    "aloha",
    "alone",
    "alongside",
    "aloof",
    "alphabet",
    "alright",
    "although",
    "altitude",
    "alto",
    "aluminum",
    "alumni",
    "always",
    "amaretto",
    "amaze",
    "amazingly",
    "amber",
    "ambiance",
    "ambiguity",
    "ambiguous",
    "ambition",
    "ambitious",
    "ambulance",
    "ambush",
    "amendable",
    "amendment",
    "amends",
    "amenity",
    "amiable",
    "amicably",
    "amid",
    "amigo",
    "amino",
    "amiss",
    "ammonia",
    "ammonium",
    "amnesty",
    "amniotic",
    "among",
    "amount",
    "amperage",
    "ample",
    "amplifier",
    "amplify",
    "amply",
    "amuck",
    "amulet",
    "amusable",
    "amused",
    "amusement",
    "amuser",
    "amusing",
    "anaconda",
    "anaerobic",
    "anagram",
    "anatomist",
    "anatomy",
    "anchor",
    "anchovy",
    "ancient",
    "android",
    "anemia",
    "anemic",
    "aneurism",
    "anew",
    "angelfish",
    "angelic",
    "anger",
    "angled",
    "angler",
    "angles",
    "angling",
    "angrily",
    "angriness",
    "anguished",
    "angular",
    "animal",
    "animate",
    "animating",
    "animation",
    "animator",
    "anime",
    "animosity",
    "ankle",
    "annex",
    "annotate",
    "announcer",
    "annoying",
    "annually",
    "annuity",
    "anointer",
    "another",
    "answering",
    "antacid",
    "antarctic",
    "anteater",
    "antelope",
    "antennae",
    "anthem",
    "anthill",
    "anthology",
    "antibody",
    "antics",
    "antidote",
    "antihero",
    "antiquely",
    "antiques",
    "antiquity",
    "antirust",
    "antitoxic",
    "antitrust",
    "antiviral",
    "antivirus",
    "antler",
    "antonym",
    "antsy",
    "anvil",
    "anybody",
    "anyhow",
    "anymore",
    "anyone",
    "anyplace",
    "anything",
    "anytime",
    "anyway",
    "anywhere",
    "aorta",
    "apache",
    "apostle",
    "appealing",
    "appear",
    "appease",
    "appeasing",
    "appendage",
    "appendix",
    "appetite",
    "appetizer",
    "applaud",
    "applause",
    "apple",
    "appliance",
    "applicant",
    "applied",
    "apply",
    "appointee",
    "appraisal",
    "appraiser",
    "apprehend",
    "approach",
    "approval",
    "approve",
    "apricot",
    "april",
    "apron",
    "aptitude",
    "aptly",
    "aqua",
    "aqueduct",
    "arbitrary",
    "arbitrate",
    "ardently",
    "area",
    "arena",
    "arguable",
    "arguably",
    "argue",
    "arise",
    "armadillo",
    "armband",
    "armchair",
    "armed",
    "armful",
    "armhole",
    "arming",
    "armless",
    "armoire",
    "armored",
    "armory",
    "armrest",
    "army",
    "aroma",
    "arose",
    "around",
    "arousal",
    "arrange",
    "array",
    "arrest",
    "arrival",
    "arrive",
    "arrogance",
    "arrogant",
    "arson",
    "art",
    "ascend",
    "ascension",
    "ascent",
    "ascertain",
    "ashamed",
    "ashen",
    "ashes",
    "ashy",
    "aside",
    "askew",
    "asleep",
    "asparagus",
    "aspect",
    "aspirate",
    "aspire",
    "aspirin",
    "astonish",
    "astound",
    "astride",
    "astrology",
    "astronaut",
    "astronomy",
    "astute",
    "atlantic",
    "atlas",
    "atom",
    "atonable",
    "atop",
    "atrium",
    "atrocious",
    "atrophy",
    "attach",
    "attain",
    "attempt",
    "attendant",
    "attendee",
    "attention",
    "attentive",
    "attest",
    "attic",
    "attire",
    "attitude",
    "attractor",
    "attribute",
    "atypical",
    "auction",
    "audacious",
    "audacity",
    "audible",
    "audibly",
    "audience",
    "audio",
    "audition",
    "augmented",
    "august",
    "authentic",
    "author",
    "autism",
    "autistic",
    "autograph",
    "automaker",
    "automated",
    "automatic",
    "autopilot",
    "available",
    "avalanche",
    "avatar",
    "avenge",
    "avenging",
    "avenue",
    "average",
    "aversion",
    "avert",
    "aviation",
    "aviator",
    "avid",
    "avoid",
    "await",
    "awaken",
    "award",
    "aware",
    "awhile",
    "awkward",
    "awning",
    "awoke",
    "awry",
    "axis",
    "babble",
    "babbling",
    "babied",
    "baboon",
    "backache",
    "backboard",
    "backboned",
    "backdrop",
    "backed",
    "backer",
    "backfield",
    "backfire",
    "backhand",
    "backing",
    "backlands",
    "backlash",
    "backless",
    "backlight",
    "backlit",
    "backlog",
    "backpack",
    "backpedal",
    "backrest",
    "backroom",
    "backshift",
    "backside",
    "backslid",
    "backspace",
    "backspin",
    "backstab",
    "backstage",
    "backtalk",
    "backtrack",
    "backup",
    "backward",
    "backwash",
    "backwater",
    "backyard",
    "bacon",
    "bacteria",
    "bacterium",
    "badass",
    "badge",
    "badland",
    "badly",
    "badness",
    "baffle",
    "baffling",
    "bagel",
    "bagful",
    "baggage",
    "bagged",
    "baggie",
    "bagginess",
    "bagging",
    "baggy",
    "bagpipe",
    "baguette",
    "baked",
    "bakery",
    "bakeshop",
    "baking",
    "balance",
    "balancing",
    "balcony",
    "balmy",
    "balsamic",
    "bamboo",
    "banana",
    "banish",
    "banister",
    "banjo",
    "bankable",
    "bankbook",
    "banked",
    "banker",
    "banking",
    "banknote",
    "bankroll",
    "banner",
    "bannister",
    "banshee",
    "banter",
    "barbecue",
    "barbed",
    "barbell",
    "barber",
    "barcode",
    "barge",
    "bargraph",
    "barista",
    "baritone",
    "barley",
    "barmaid",
    "barman",
    "barn",
    "barometer",
    "barrack",
    "barracuda",
    "barrel",
    "barrette",
    "barricade",
    "barrier",
    "barstool",
    "bartender",
    "barterer",
    "bash",
    "basically",
    "basics",
    "basil",
    "basin",
    "basis",
    "basket",
    "batboy",
    "batch",
    "bath",
    "baton",
    "bats",
    "battalion",
    "battered",
    "battering",
    "battery",
    "batting",
    "battle",
    "bauble",
    "bazooka",
    "blabber",
    "bladder",
    "blade",
    "blah",
    "blame",
    "blaming",
    "blanching",
    "blandness",
    "blank",
    "blaspheme",
    "blasphemy",
    "blast",
    "blatancy",
    "blatantly",
    "blazer",
    "blazing",
    "bleach",
    "bleak",
    "bleep",
    "blemish",
    "blend",
    "bless",
    "blighted",
    "blimp",
    "bling",
    "blinked",
    "blinker",
    "blinking",
    "blinks",
    "blip",
    "blissful",
    "blitz",
    "blizzard",
    "bloated",
    "bloating",
    "blob",
    "blog",
    "bloomers",
    "blooming",
    "blooper",
    "blot",
    "blouse",
    "blubber",
    "bluff",
    "bluish",
    "blunderer",
    "blunt",
    "blurb",
    "blurred",
    "blurry",
    "blurt",
    "blush",
    "blustery",
    "boaster",
    "boastful",
    "boasting",
    "boat",
    "bobbed",
    "bobbing",
    "bobble",
    "bobcat",
    "bobsled",
    "bobtail",
    "bodacious",
    "body",
    "bogged",
    "boggle",
    "bogus",
    "boil",
    "bok",
    "bolster",
    "bolt",
    "bonanza",
    "bonded",
    "bonding",
    "bondless",
    "boned",
    "bonehead",
    "boneless",
    "bonelike",
    "boney",
    "bonfire",
    "bonnet",
    "bonsai",
    "bonus",
    "bony",
    "boogeyman",
    "boogieman",
    "book",
    "boondocks",
    "booted",
    "booth",
    "bootie",
    "booting",
    "bootlace",
    "bootleg",
    "boots",
    "boozy",
    "borax",
    "boring",
    "borough",
    "borrower",
    "borrowing",
    "boss",
    "botanical",
    "botanist",
    "botany",
    "botch",
    "both",
    "bottle",
    "bottling",
    "bottom",
    "bounce",
    "bouncing",
    "bouncy",
    "bounding",
    "boundless",
    "bountiful",
    "bovine",
    "boxcar",
    "boxer",
    "boxing",
    "boxlike",
    "boxy",
    "breach",
    "breath",
    "breeches",
    "breeching",
    "breeder",
    "breeding",
    "breeze",
    "breezy",
    "brethren",
    "brewery",
    "brewing",
    "briar",
    "bribe",
    "brick",
    "bride",
    "bridged",
    "brigade",
    "bright",
    "brilliant",
    "brim",
    "bring",
    "brink",
    "brisket",
    "briskly",
    "briskness",
    "bristle",
    "brittle",
    "broadband",
    "broadcast",
    "broaden",
    "broadly",
    "broadness",
    "broadside",
    "broadways",
    "broiler",
    "broiling",
    "broken",
    "broker",
    "bronchial",
    "bronco",
    "bronze",
    "bronzing",
    "brook",
    "broom",
    "brought",
    "browbeat",
    "brownnose",
    "browse",
    "browsing",
    "bruising",
    "brunch",
    "brunette",
    "brunt",
    "brush",
    "brussels",
    "brute",
    "brutishly",
    "bubble",
    "bubbling",
    "bubbly",
    "buccaneer",
    "bucked",
    "bucket",
    "buckle",
    "buckshot",
    "buckskin",
    "bucktooth",
    "buckwheat",
    "buddhism",
    "buddhist",
    "budding",
    "buddy",
    "budget",
    "buffalo",
    "buffed",
    "buffer",
    "buffing",
    "buffoon",
    "buggy",
    "bulb",
    "bulge",
    "bulginess",
    "bulgur",
    "bulk",
    "bulldog",
    "bulldozer",
    "bullfight",
    "bullfrog",
    "bullhorn",
    "bullion",
    "bullish",
    "bullpen",
    "bullring",
    "bullseye",
    "bullwhip",
    "bully",
    "bunch",
    "bundle",
    "bungee",
    "bunion",
    "bunkbed",
    "bunkhouse",
    "bunkmate",
    "bunny",
    "bunt",
    "busboy",
    "bush",
    "busily",
    "busload",
    "bust",
    "busybody",
    "buzz",
    "cabana",
    "cabbage",
    "cabbie",
    "cabdriver",
    "cable",
    "caboose",
    "cache",
    "cackle",
    "cacti",
    "cactus",
    "caddie",
    "caddy",
    "cadet",
    "cadillac",
    "cadmium",
    "cage",
    "cahoots",
    "cake",
    "calamari",
    "calamity",
    "calcium",
    "calculate",
    "calculus",
    "caliber",
    "calibrate",
    "calm",
    "caloric",
    "calorie",
    "calzone",
    "camcorder",
    "cameo",
    "camera",
    "camisole",
    "camper",
    "campfire",
    "camping",
    "campsite",
    "campus",
    "canal",
    "canary",
    "cancel",
    "candied",
    "candle",
    "candy",
    "cane",
    "canine",
    "canister",
    "cannabis",
    "canned",
    "canning",
    "cannon",
    "cannot",
    "canola",
    "canon",
    "canopener",
    "canopy",
    "canteen",
    "canyon",
    "capable",
    "capably",
    "capacity",
    "cape",
    "capillary",
    "capital",
    "capitol",
    "capped",
    "capricorn",
    "capsize",
    "capsule",
    "caption",
    "captivate",
    "captive",
    "captivity",
    "capture",
    "caramel",
    "carat",
    "caravan",
    "carbon",
    "cardboard",
    "carded",
    "cardiac",
    "cardigan",
    "cardinal",
    "cardstock",
    "carefully",
    "caregiver",
    "careless",
    "caress",
    "caretaker",
    "cargo",
    "caring",
    "carless",
    "carload",
    "carmaker",
    "carnage",
    "carnation",
    "carnival",
    "carnivore",
    "carol",
    "carpenter",
    "carpentry",
    "carpool",
    "carport",
    "carried",
    "carrot",
    "carrousel",
    "carry",
    "cartel",
    "cartload",
    "carton",
    "cartoon",
    "cartridge",
    "cartwheel",
    "carve",
    "carving",
    "carwash",
    "cascade",
    "case",
    "cash",
    "casing",
    "casino",
    "casket",
    "cassette",
    "casually",
    "casualty",
    "catacomb",
    "catalog",
    "catalyst",
    "catalyze",
    "catapult",
    "cataract",
    "catatonic",
    "catcall",
    "catchable",
    "catcher",
    "catching",
    "catchy",
    "caterer",
    "catering",
    "catfight",
    "catfish",
    "cathedral",
    "cathouse",
    "catlike",
    "catnap",
    "catnip",
    "catsup",
    "cattail",
    "cattishly",
    "cattle",
    "catty",
    "catwalk",
    "caucasian",
    "caucus",
    "causal",
    "causation",
    "cause",
    "causing",
    "cauterize",
    "caution",
    "cautious",
    "cavalier",
    "cavalry",
    "caviar",
    "cavity",
    "cedar",
    "celery",
    "celestial",
    "celibacy",
    "celibate",
    "celtic",
    "cement",
    "census",
    "ceramics",
    "ceremony",
    "certainly",
    "certainty",
    "certified",
    "certify",
    "cesarean",
    "cesspool",
    "chafe",
    "chaffing",
    "chain",
    "chair",
    "chalice",
    "challenge",
    "chamber",
    "chamomile",
    "champion",
    "chance",
    "change",
    "channel",
    "chant",
    "chaos",
    "chaperone",
    "chaplain",
    "chapped",
    "chaps",
    "chapter",
    "character",
    "charbroil",
    "charcoal",
    "charger",
    "charging",
    "chariot",
    "charity",
    "charm",
    "charred",
    "charter",
    "charting",
    "chase",
    "chasing",
    "chaste",
    "chastise",
    "chastity",
    "chatroom",
    "chatter",
    "chatting",
    "chatty",
    "cheating",
    "cheddar",
    "cheek",
    "cheer",
    "cheese",
    "cheesy",
    "chef",
    "chemicals",
    "chemist",
    "chemo",
    "cherisher",
    "cherub",
    "chess",
    "chest",
    "chevron",
    "chevy",
    "chewable",
    "chewer",
    "chewing",
    "chewy",
    "chief",
    "chihuahua",
    "childcare",
    "childhood",
    "childish",
    "childless",
    "childlike",
    "chili",
    "chill",
    "chimp",
    "chip",
    "chirping",
    "chirpy",
    "chitchat",
    "chivalry",
    "chive",
    "chloride",
    "chlorine",
    "choice",
    "chokehold",
    "choking",
    "chomp",
    "chooser",
    "choosing",
    "choosy",
    "chop",
    "chosen",
    "chowder",
    "chowtime",
    "chrome",
    "chubby",
    "chuck",
    "chug",
    "chummy",
    "chump",
    "chunk",
    "churn",
    "chute",
    "cider",
    "cilantro",
    "cinch",
    "cinema",
    "cinnamon",
    "circle",
    "circling",
    "circular",
    "circulate",
    "circus",
    "citable",
    "citadel",
    "citation",
    "citizen",
    "citric",
    "citrus",
    "city",
    "civic",
    "civil",
    "clad",
    "claim",
    "clambake",
    "clammy",
    "clamor",
    "clamp",
    "clamshell",
    "clang",
    "clanking",
    "clapped",
    "clapper",
    "clapping",
    "clarify",
    "clarinet",
    "clarity",
    "clash",
    "clasp",
    "class",
    "clatter",
    "clause",
    "clavicle",
    "claw",
    "clay",
    "clean",
    "clear",
    "cleat",
    "cleaver",
    "cleft",
    "clench",
    "clergyman",
    "clerical",
    "clerk",
    "clever",
    "clicker",
    "client",
    "climate",
    "climatic",
    "cling",
    "clinic",
    "clinking",
    "clip",
    "clique",
    "cloak",
    "clobber",
    "clock",
    "clone",
    "cloning",
    "closable",
    "closure",
    "clothes",
    "clothing",
    "cloud",
    "clover",
    "clubbed",
    "clubbing",
    "clubhouse",
    "clump",
    "clumsily",
    "clumsy",
    "clunky",
    "clustered",
    "clutch",
    "clutter",
    "coach",
    "coagulant",
    "coastal",
    "coaster",
    "coasting",
    "coastland",
    "coastline",
    "coat",
    "coauthor",
    "cobalt",
    "cobbler",
    "cobweb",
    "cocoa",
    "coconut",
    "cod",
    "coeditor",
    "coerce",
    "coexist",
    "coffee",
    "cofounder",
    "cognition",
    "cognitive",
    "cogwheel",
    "coherence",
    "coherent",
    "cohesive",
    "coil",
    "coke",
    "cola",
    "cold",
    "coleslaw",
    "coliseum",
    "collage",
    "collapse",
    "collar",
    "collected",
    "collector",
    "collide",
    "collie",
    "collision",
    "colonial",
    "colonist",
    "colonize",
    "colony",
    "colossal",
    "colt",
    "coma",
    "come",
    "comfort",
    "comfy",
    "comic",
    "coming",
    "comma",
    "commence",
    "commend",
    "comment",
    "commerce",
    "commode",
    "commodity",
    "commodore",
    "common",
    "commotion",
    "commute",
    "commuting",
    "compacted",
    "compacter",
    "compactly",
    "compactor",
    "companion",
    "company",
    "compare",
    "compel",
    "compile",
    "comply",
    "component",
    "composed",
    "composer",
    "composite",
    "compost",
    "composure",
    "compound",
    "compress",
    "comprised",
    "computer",
    "computing",
    "comrade",
    "concave",
    "conceal",
    "conceded",
    "concept",
    "concerned",
    "concert",
    "conch",
    "concierge",
    "concise",
    "conclude",
    "concrete",
    "concur",
    "condense",
    "condiment",
    "condition",
    "condone",
    "conducive",
    "conductor",
    "conduit",
    "cone",
    "confess",
    "confetti",
    "confidant",
    "confident",
    "confider",
    "confiding",
    "configure",
    "confined",
    "confining",
    "confirm",
    "conflict",
    "conform",
    "confound",
    "confront",
    "confused",
    "confusing",
    "confusion",
    "congenial",
    "congested",
    "congrats",
    "congress",
    "conical",
    "conjoined",
    "conjure",
    "conjuror",
    "connected",
    "connector",
    "consensus",
    "consent",
    "console",
    "consoling",
    "consonant",
    "constable",
    "constant",
    "constrain",
    "constrict",
    "construct",
    "consult",
    "consumer",
    "consuming",
    "contact",
    "container",
    "contempt",
    "contend",
    "contented",
    "contently",
    "contents",
    "contest",
    "context",
    "contort",
    "contour",
    "contrite",
    "control",
    "contusion",
    "convene",
    "convent",
    "copartner",
    "cope",
    "copied",
    "copier",
    "copilot",
    "coping",
    "copious",
    "copper",
    "copy",
    "coral",
    "cork",
    "cornball",
    "cornbread",
    "corncob",
    "cornea",
    "corned",
    "corner",
    "cornfield",
    "cornflake",
    "cornhusk",
    "cornmeal",
    "cornstalk",
    "corny",
    "coronary",
    "coroner",
    "corporal",
    "corporate",
    "corral",
    "correct",
    "corridor",
    "corrode",
    "corroding",
    "corrosive",
    "corsage",
    "corset",
    "cortex",
    "cosigner",
    "cosmetics",
    "cosmic",
    "cosmos",
    "cosponsor",
    "cost",
    "cottage",
    "cotton",
    "couch",
    "cough",
    "could",
    "countable",
    "countdown",
    "counting",
    "countless",
    "country",
    "county",
    "courier",
    "covenant",
    "cover",
    "coveted",
    "coveting",
    "coyness",
    "cozily",
    "coziness",
    "cozy",
    "crabbing",
    "crabgrass",
    "crablike",
    "crabmeat",
    "cradle",
    "cradling",
    "crafter",
    "craftily",
    "craftsman",
    "craftwork",
    "crafty",
    "cramp",
    "cranberry",
    "crane",
    "cranial",
    "cranium",
    "crank",
    "crate",
    "crave",
    "craving",
    "crawfish",
    "crawlers",
    "crawling",
    "crayfish",
    "crayon",
    "crazed",
    "crazily",
    "craziness",
    "crazy",
    "creamed",
    "creamer",
    "creamlike",
    "crease",
    "creasing",
    "creatable",
    "create",
    "creation",
    "creative",
    "creature",
    "credible",
    "credibly",
    "credit",
    "creed",
    "creme",
    "creole",
    "crepe",
    "crept",
    "crescent",
    "crested",
    "cresting",
    "crestless",
    "crevice",
    "crewless",
    "crewman",
    "crewmate",
    "crib",
    "cricket",
    "cried",
    "crier",
    "crimp",
    "crimson",
    "cringe",
    "cringing",
    "crinkle",
    "crinkly",
    "crisped",
    "crisping",
    "crisply",
    "crispness",
    "crispy",
    "criteria",
    "critter",
    "croak",
    "crock",
    "crook",
    "croon",
    "crop",
    "cross",
    "crouch",
    "crouton",
    "crowbar",
    "crowd",
    "crown",
    "crucial",
    "crudely",
    "crudeness",
    "cruelly",
    "cruelness",
    "cruelty",
    "crumb",
    "crummiest",
    "crummy",
    "crumpet",
    "crumpled",
    "cruncher",
    "crunching",
    "crunchy",
    "crusader",
    "crushable",
    "crushed",
    "crusher",
    "crushing",
    "crust",
    "crux",
    "crying",
    "cryptic",
    "crystal",
    "cubbyhole",
    "cube",
    "cubical",
    "cubicle",
    "cucumber",
    "cuddle",
    "cuddly",
    "cufflink",
    "culinary",
    "culminate",
    "culpable",
    "culprit",
    "cultivate",
    "cultural",
    "culture",
    "cupbearer",
    "cupcake",
    "cupid",
    "cupped",
    "cupping",
    "curable",
    "curator",
    "curdle",
    "cure",
    "curfew",
    "curing",
    "curled",
    "curler",
    "curliness",
    "curling",
    "curly",
    "curry",
    "curse",
    "cursive",
    "cursor",
    "curtain",
    "curtly",
    "curtsy",
    "curvature",
    "curve",
    "curvy",
    "cushy",
    "cusp",
    "cussed",
    "custard",
    "custodian",
    "custody",
    "customary",
    "customer",
    "customize",
    "customs",
    "cut",
    "cycle",
    "cyclic",
    "cycling",
    "cyclist",
    "cylinder",
    "cymbal",
    "cytoplasm",
    "cytoplast",
    "dab",
    "dad",
    "daffodil",
    "dagger",
    "daily",
    "daintily",
    "dainty",
    "dairy",
    "daisy",
    "dallying",
    "dance",
    "dancing",
    "dandelion",
    "dander",
    "dandruff",
    "dandy",
    "danger",
    "dangle",
    "dangling",
    "daredevil",
    "dares",
    "daringly",
    "darkened",
    "darkening",
    "darkish",
    "darkness",
    "darkroom",
    "darling",
    "darn",
    "dart",
    "darwinism",
    "dash",
    "dastardly",
    "data",
    "datebook",
    "dating",
    "daughter",
    "daunting",
    "dawdler",
    "dawn",
    "daybed",
    "daybreak",
    "daycare",
    "daydream",
    "daylight",
    "daylong",
    "dayroom",
    "daytime",
    "dazzler",
    "dazzling",
    "deacon",
    "deafening",
    "deafness",
    "dealer",
    "dealing",
    "dealmaker",
    "dealt",
    "dean",
    "debatable",
    "debate",
    "debating",
    "debit",
    "debrief",
    "debtless",
    "debtor",
    "debug",
    "debunk",
    "decade",
    "decaf",
    "decal",
    "decathlon",
    "decay",
    "deceased",
    "deceit",
    "deceiver",
    "deceiving",
    "december",
    "decency",
    "decent",
    "deception",
    "deceptive",
    "decibel",
    "decidable",
    "decimal",
    "decimeter",
    "decipher",
    "deck",
    "declared",
    "decline",
    "decode",
    "decompose",
    "decorated",
    "decorator",
    "decoy",
    "decrease",
    "decree",
    "dedicate",
    "dedicator",
    "deduce",
    "deduct",
    "deed",
    "deem",
    "deepen",
    "deeply",
    "deepness",
    "deface",
    "defacing",
    "defame",
    "default",
    "defeat",
    "defection",
    "defective",
    "defendant",
    "defender",
    "defense",
    "defensive",
    "deferral",
    "deferred",
    "defiance",
    "defiant",
    "defile",
    "defiling",
    "define",
    "definite",
    "deflate",
    "deflation",
    "deflator",
    "deflected",
    "deflector",
    "defog",
    "deforest",
    "defraud",
    "defrost",
    "deftly",
    "defuse",
    "defy",
    "degraded",
    "degrading",
    "degrease",
    "degree",
    "dehydrate",
    "deity",
    "dejected",
    "delay",
    "delegate",
    "delegator",
    "delete",
    "deletion",
    "delicacy",
    "delicate",
    "delicious",
    "delighted",
    "delirious",
    "delirium",
    "deliverer",
    "delivery",
    "delouse",
    "delta",
    "deluge",
    "delusion",
    "deluxe",
    "demanding",
    "demeaning",
    "demeanor",
    "demise",
    "democracy",
    "democrat",
    "demote",
    "demotion",
    "demystify",
    "denatured",
    "deniable",
    "denial",
    "denim",
    "denote",
    "dense",
    "density",
    "dental",
    "dentist",
    "denture",
    "deny",
    "deodorant",
    "deodorize",
    "departed",
    "departure",
    "depict",
    "deplete",
    "depletion",
    "deplored",
    "deploy",
    "deport",
    "depose",
    "depraved",
    "depravity",
    "deprecate",
    "depress",
    "deprive",
    "depth",
    "deputize",
    "deputy",
    "derail",
    "deranged",
    "derby",
    "derived",
    "desecrate",
    "deserve",
    "deserving",
    "designate",
    "designed",
    "designer",
    "designing",
    "deskbound",
    "desktop",
    "deskwork",
    "desolate",
    "despair",
    "despise",
    "despite",
    "destiny",
    "destitute",
    "destruct",
    "detached",
    "detail",
    "detection",
    "detective",
    "detector",
    "detention",
    "detergent",
    "detest",
    "detonate",
    "detonator",
    "detoxify",
    "detract",
    "deuce",
    "devalue",
    "deviancy",
    "deviant",
    "deviate",
    "deviation",
    "deviator",
    "device",
    "devious",
    "devotedly",
    "devotee",
    "devotion",
    "devourer",
    "devouring",
    "devoutly",
    "dexterity",
    "dexterous",
    "diabetes",
    "diabetic",
    "diabolic",
    "diagnoses",
    "diagnosis",
    "diagram",
    "dial",
    "diameter",
    "diaper",
    "diaphragm",
    "diary",
    "dice",
    "dicing",
    "dictate",
    "dictation",
    "dictator",
    "difficult",
    "diffused",
    "diffuser",
    "diffusion",
    "diffusive",
    "dig",
    "dilation",
    "diligence",
    "diligent",
    "dill",
    "dilute",
    "dime",
    "diminish",
    "dimly",
    "dimmed",
    "dimmer",
    "dimness",
    "dimple",
    "diner",
    "dingbat",
    "dinghy",
    "dinginess",
    "dingo",
    "dingy",
    "dining",
    "dinner",
    "diocese",
    "dioxide",
    "diploma",
    "dipped",
    "dipper",
    "dipping",
    "directed",
    "direction",
    "directive",
    "directly",
    "directory",
    "direness",
    "dirtiness",
    "disabled",
    "disagree",
    "disallow",
    "disarm",
    "disarray",
    "disaster",
    "disband",
    "disbelief",
    "disburse",
    "discard",
    "discern",
    "discharge",
    "disclose",
    "discolor",
    "discount",
    "discourse",
    "discover",
    "discuss",
    "disdain",
    "disengage",
    "disfigure",
    "disgrace",
    "dish",
    "disinfect",
    "disjoin",
    "disk",
    "dislike",
    "disliking",
    "dislocate",
    "dislodge",
    "disloyal",
    "dismantle",
    "dismay",
    "dismiss",
    "dismount",
    "disobey",
    "disorder",
    "disown",
    "disparate",
    "disparity",
    "dispatch",
    "dispense",
    "dispersal",
    "dispersed",
    "disperser",
    "displace",
    "display",
    "displease",
    "disposal",
    "dispose",
    "disprove",
    "dispute",
    "disregard",
    "disrupt",
    "dissuade",
    "distance",
    "distant",
    "distaste",
    "distill",
    "distinct",
    "distort",
    "distract",
    "distress",
    "district",
    "distrust",
    "ditch",
    "ditto",
    "ditzy",
    "dividable",
    "divided",
    "dividend",
    "dividers",
    "dividing",
    "divinely",
    "diving",
    "divinity",
    "divisible",
    "divisibly",
    "division",
    "divisive",
    "divorcee",
    "dizziness",
    "dizzy",
    "doable",
    "docile",
    "dock",
    "doctrine",
    "document",
    "dodge",
    "dodgy",
    "doily",
    "doing",
    "dole",
    "dollar",
    "dollhouse",
    "dollop",
    "dolly",
    "dolphin",
    "domain",
    "domelike",
    "domestic",
    "dominion",
    "dominoes",
    "donated",
    "donation",
    "donator",
    "donor",
    "donut",
    "doodle",
    "doorbell",
    "doorframe",
    "doorknob",
    "doorman",
    "doormat",
    "doornail",
    "doorpost",
    "doorstep",
    "doorstop",
    "doorway",
    "doozy",
    "dork",
    "dormitory",
    "dorsal",
    "dosage",
    "dose",
    "dotted",
    "doubling",
    "douche",
    "dove",
    "down",
    "dowry",
    "doze",
    "drab",
    "dragging",
    "dragonfly",
    "dragonish",
    "dragster",
    "drainable",
    "drainage",
    "drained",
    "drainer",
    "drainpipe",
    "dramatic",
    "dramatize",
    "drank",
    "drapery",
    "drastic",
    "draw",
    "dreaded",
    "dreadful",
    "dreadlock",
    "dreamboat",
    "dreamily",
    "dreamland",
    "dreamless",
    "dreamlike",
    "dreamt",
    "dreamy",
    "drearily",
    "dreary",
    "drench",
    "dress",
    "drew",
    "dribble",
    "dried",
    "drier",
    "drift",
    "driller",
    "drilling",
    "drinkable",
    "drinking",
    "dripping",
    "drippy",
    "drivable",
    "driven",
    "driver",
    "driveway",
    "driving",
    "drizzle",
    "drizzly",
    "drone",
    "drool",
    "droop",
    "drop-down",
    "dropbox",
    "dropkick",
    "droplet",
    "dropout",
    "dropper",
    "drove",
    "drown",
    "drowsily",
    "drudge",
    "drum",
    "dry",
    "dubbed",
    "dubiously",
    "duchess",
    "duckbill",
    "ducking",
    "duckling",
    "ducktail",
    "ducky",
    "duct",
    "dude",
    "duffel",
    "dugout",
    "duh",
    "duke",
    "duller",
    "dullness",
    "duly",
    "dumping",
    "dumpling",
    "dumpster",
    "duo",
    "dupe",
    "duplex",
    "duplicate",
    "duplicity",
    "durable",
    "durably",
    "duration",
    "duress",
    "during",
    "dusk",
    "dust",
    "dutiful",
    "duty",
    "duvet",
    "dwarf",
    "dweeb",
    "dwelled",
    "dweller",
    "dwelling",
    "dwindle",
    "dwindling",
    "dynamic",
    "dynamite",
    "dynasty",
    "dyslexia",
    "dyslexic",
    "each",
    "eagle",
    "earache",
    "eardrum",
    "earflap",
    "earful",
    "earlobe",
    "early",
    "earmark",
    "earmuff",
    "earphone",
    "earpiece",
    "earplugs",
    "earring",
    "earshot",
    "earthen",
    "earthlike",
    "earthling",
    "earthly",
    "earthworm",
    "earthy",
    "earwig",
    "easeful",
    "easel",
    "easiest",
    "easily",
    "easiness",
    "easing",
    "eastbound",
    "eastcoast",
    "easter",
    "eastward",
    "eatable",
    "eaten",
    "eatery",
    "eating",
    "eats",
    "ebay",
    "ebony",
    "ebook",
    "ecard",
    "eccentric",
    "echo",
    "eclair",
    "eclipse",
    "ecologist",
    "ecology",
    "economic",
    "economist",
    "economy",
    "ecosphere",
    "ecosystem",
    "edge",
    "edginess",
    "edging",
    "edgy",
    "edition",
    "editor",
    "educated",
    "education",
    "educator",
    "eel",
    "effective",
    "effects",
    "efficient",
    "effort",
    "eggbeater",
    "egging",
    "eggnog",
    "eggplant",
    "eggshell",
    "egomaniac",
    "egotism",
    "egotistic",
    "either",
    "eject",
    "elaborate",
    "elastic",
    "elated",
    "elbow",
    "eldercare",
    "elderly",
    "eldest",
    "electable",
    "election",
    "elective",
    "elephant",
    "elevate",
    "elevating",
    "elevation",
    "elevator",
    "eleven",
    "elf",
    "eligible",
    "eligibly",
    "eliminate",
    "elite",
    "elitism",
    "elixir",
    "elk",
    "ellipse",
    "elliptic",
    "elm",
    "elongated",
    "elope",
    "eloquence",
    "eloquent",
    "elsewhere",
    "elude",
    "elusive",
    "elves",
    "email",
    "embargo",
    "embark",
    "embassy",
    "embattled",
    "embellish",
    "ember",
    "embezzle",
    "emblaze",
    "emblem",
    "embody",
    "embolism",
    "emboss",
    "embroider",
    "emcee",
    "emerald",
    "emergency",
    "emission",
    "emit",
    "emote",
    "emoticon",
    "emotion",
    "empathic",
    "empathy",
    "emperor",
    "emphases",
    "emphasis",
    "emphasize",
    "emphatic",
    "empirical",
    "employed",
    "employee",
    "employer",
    "emporium",
    "empower",
    "emptier",
    "emptiness",
    "empty",
    "emu",
    "enable",
    "enactment",
    "enamel",
    "enchanted",
    "enchilada",
    "encircle",
    "enclose",
    "enclosure",
    "encode",
    "encore",
    "encounter",
    "encourage",
    "encroach",
    "encrust",
    "encrypt",
    "endanger",
    "endeared",
    "endearing",
    "ended",
    "ending",
    "endless",
    "endnote",
    "endocrine",
    "endorphin",
    "endorse",
    "endowment",
    "endpoint",
    "endurable",
    "endurance",
    "enduring",
    "energetic",
    "energize",
    "energy",
    "enforced",
    "enforcer",
    "engaged",
    "engaging",
    "engine",
    "engorge",
    "engraved",
    "engraver",
    "engraving",
    "engross",
    "engulf",
    "enhance",
    "enigmatic",
    "enjoyable",
    "enjoyably",
    "enjoyer",
    "enjoying",
    "enjoyment",
    "enlarged",
    "enlarging",
    "enlighten",
    "enlisted",
    "enquirer",
    "enrage",
    "enrich",
    "enroll",
    "enslave",
    "ensnare",
    "ensure",
    "entail",
    "entangled",
    "entering",
    "entertain",
    "enticing",
    "entire",
    "entitle",
    "entity",
    "entomb",
    "entourage",
    "entrap",
    "entree",
    "entrench",
    "entrust",
    "entryway",
    "entwine",
    "enunciate",
    "envelope",
    "enviable",
    "enviably",
    "envious",
    "envision",
    "envoy",
    "envy",
    "enzyme",
    "epic",
    "epidemic",
    "epidermal",
    "epidermis",
    "epidural",
    "epilepsy",
    "epileptic",
    "epilogue",
    "epiphany",
    "episode",
    "equal",
    "equate",
    "equation",
    "equator",
    "equinox",
    "equipment",
    "equity",
    "equivocal",
    "eradicate",
    "erasable",
    "erased",
    "eraser",
    "erasure",
    "ergonomic",
    "errand",
    "errant",
    "erratic",
    "error",
    "erupt",
    "escalate",
    "escalator",
    "escapable",
    "escapade",
    "escapist",
    "escargot",
    "eskimo",
    "esophagus",
    "espionage",
    "espresso",
    "esquire",
    "essay",
    "essence",
    "essential",
    "establish",
    "estate",
    "esteemed",
    "estimate",
    "estimator",
    "estranged",
    "estrogen",
    "etching",
    "eternal",
    "eternity",
    "ethanol",
    "ether",
    "ethically",
    "ethics",
    "euphemism",
    "evacuate",
    "evacuee",
    "evade",
    "evaluate",
    "evaluator",
    "evaporate",
    "evasion",
    "evasive",
    "even",
    "everglade",
    "evergreen",
    "everybody",
    "everyday",
    "everyone",
    "evict",
    "evidence",
    "evident",
    "evil",
    "evoke",
    "evolution",
    "evolve",
    "exact",
    "exalted",
    "example",
    "excavate",
    "excavator",
    "exceeding",
    "exception",
    "excess",
    "exchange",
    "excitable",
    "exciting",
    "exclaim",
    "exclude",
    "excluding",
    "exclusion",
    "exclusive",
    "excretion",
    "excretory",
    "excursion",
    "excusable",
    "excusably",
    "excuse",
    "exemplary",
    "exemplify",
    "exemption",
    "exerciser",
    "exert",
    "exes",
    "exfoliate",
    "exhale",
    "exhaust",
    "exhume",
    "exile",
    "existing",
    "exit",
    "exodus",
    "exonerate",
    "exorcism",
    "exorcist",
    "expand",
    "expanse",
    "expansion",
    "expansive",
    "expectant",
    "expedited",
    "expediter",
    "expel",
    "expend",
    "expenses",
    "expensive",
    "expert",
    "expire",
    "expiring",
    "explain",
    "expletive",
    "explicit",
    "explode",
    "exploit",
    "explore",
    "exploring",
    "exponent",
    "exporter",
    "exposable",
    "expose",
    "exposure",
    "express",
    "expulsion",
    "exquisite",
    "extended",
    "extending",
    "extent",
    "extenuate",
    "exterior",
    "external",
    "extinct",
    "extortion",
    "extradite",
    "extras",
    "extrovert",
    "extrude",
    "extruding",
    "exuberant",
    "fable",
    "fabric",
    "fabulous",
    "facebook",
    "facecloth",
    "facedown",
    "faceless",
    "facelift",
    "faceplate",
    "faceted",
    "facial",
    "facility",
    "facing",
    "facsimile",
    "faction",
    "factoid",
    "factor",
    "factsheet",
    "factual",
    "faculty",
    "fade",
    "fading",
    "failing",
    "falcon",
    "fall",
    "false",
    "falsify",
    "fame",
    "familiar",
    "family",
    "famine",
    "famished",
    "fanatic",
    "fancied",
    "fanciness",
    "fancy",
    "fanfare",
    "fang",
    "fanning",
    "fantasize",
    "fantastic",
    "fantasy",
    "fascism",
    "fastball",
    "faster",
    "fasting",
    "fastness",
    "faucet",
    "favorable",
    "favorably",
    "favored",
    "favoring",
    "favorite",
    "fax",
    "feast",
    "federal",
    "fedora",
    "feeble",
    "feed",
    "feel",
    "feisty",
    "feline",
    "felt-tip",
    "feminine",
    "feminism",
    "feminist",
    "feminize",
    "femur",
    "fence",
    "fencing",
    "fender",
    "ferment",
    "fernlike",
    "ferocious",
    "ferocity",
    "ferret",
    "ferris",
    "ferry",
    "fervor",
    "fester",
    "festival",
    "festive",
    "festivity",
    "fetal",
    "fetch",
    "fever",
    "fiber",
    "fiction",
    "fiddle",
    "fiddling",
    "fidelity",
    "fidgeting",
    "fidgety",
    "fifteen",
    "fifth",
    "fiftieth",
    "fifty",
    "figment",
    "figure",
    "figurine",
    "filing",
    "filled",
    "filler",
    "filling",
    "film",
    "filter",
    "filth",
    "filtrate",
    "finale",
    "finalist",
    "finalize",
    "finally",
    "finance",
    "financial",
    "finch",
    "fineness",
    "finer",
    "finicky",
    "finished",
    "finisher",
    "finishing",
    "finite",
    "finless",
    "finlike",
    "fiscally",
    "fit",
    "five",
    "flaccid",
    "flagman",
    "flagpole",
    "flagship",
    "flagstick",
    "flagstone",
    "flail",
    "flakily",
    "flaky",
    "flame",
    "flammable",
    "flanked",
    "flanking",
    "flannels",
    "flap",
    "flaring",
    "flashback",
    "flashbulb",
    "flashcard",
    "flashily",
    "flashing",
    "flashy",
    "flask",
    "flatbed",
    "flatfoot",
    "flatly",
    "flatness",
    "flatten",
    "flattered",
    "flatterer",
    "flattery",
    "flattop",
    "flatware",
    "flatworm",
    "flavored",
    "flavorful",
    "flavoring",
    "flaxseed",
    "fled",
    "fleshed",
    "fleshy",
    "flick",
    "flier",
    "flight",
    "flinch",
    "fling",
    "flint",
    "flip",
    "flirt",
    "float",
    "flock",
    "flogging",
    "flop",
    "floral",
    "florist",
    "floss",
    "flounder",
    "flyable",
    "flyaway",
    "flyer",
    "flying",
    "flyover",
    "flypaper",
    "foam",
    "foe",
    "fog",
    "foil",
    "folic",
    "folk",
    "follicle",
    "follow",
    "fondling",
    "fondly",
    "fondness",
    "fondue",
    "font",
    "food",
    "fool",
    "footage",
    "football",
    "footbath",
    "footboard",
    "footer",
    "footgear",
    "foothill",
    "foothold",
    "footing",
    "footless",
    "footman",
    "footnote",
    "footpad",
    "footpath",
    "footprint",
    "footrest",
    "footsie",
    "footsore",
    "footwear",
    "footwork",
    "fossil",
    "foster",
    "founder",
    "founding",
    "fountain",
    "fox",
    "foyer",
    "fraction",
    "fracture",
    "fragile",
    "fragility",
    "fragment",
    "fragrance",
    "fragrant",
    "frail",
    "frame",
    "framing",
    "frantic",
    "fraternal",
    "frayed",
    "fraying",
    "frays",
    "freckled",
    "freckles",
    "freebase",
    "freebee",
    "freebie",
    "freedom",
    "freefall",
    "freehand",
    "freeing",
    "freeload",
    "freely",
    "freemason",
    "freeness",
    "freestyle",
    "freeware",
    "freeway",
    "freewill",
    "freezable",
    "freezing",
    "freight",
    "french",
    "frenzied",
    "frenzy",
    "frequency",
    "frequent",
    "fresh",
    "fretful",
    "fretted",
    "friction",
    "friday",
    "fridge",
    "fried",
    "friend",
    "frighten",
    "frightful",
    "frigidity",
    "frigidly",
    "frill",
    "fringe",
    "frisbee",
    "frisk",
    "fritter",
    "frivolous",
    "frolic",
    "from",
    "front",
    "frostbite",
    "frosted",
    "frostily",
    "frosting",
    "frostlike",
    "frosty",
    "froth",
    "frown",
    "frozen",
    "fructose",
    "frugality",
    "frugally",
    "fruit",
    "frustrate",
    "frying",
    "gab",
    "gaffe",
    "gag",
    "gainfully",
    "gaining",
    "gains",
    "gala",
    "gallantly",
    "galleria",
    "gallery",
    "galley",
    "gallon",
    "gallows",
    "gallstone",
    "galore",
    "galvanize",
    "gambling",
    "game",
    "gaming",
    "gamma",
    "gander",
    "gangly",
    "gangrene",
    "gangway",
    "gap",
    "garage",
    "garbage",
    "garden",
    "gargle",
    "garland",
    "garlic",
    "garment",
    "garnet",
    "garnish",
    "garter",
    "gas",
    "gatherer",
    "gathering",
    "gating",
    "gauging",
    "gauntlet",
    "gauze",
    "gave",
    "gawk",
    "gazing",
    "gear",
    "gecko",
    "geek",
    "geiger",
    "gem",
    "gender",
    "generic",
    "generous",
    "genetics",
    "genre",
    "gentile",
    "gentleman",
    "gently",
    "gents",
    "geography",
    "geologic",
    "geologist",
    "geology",
    "geometric",
    "geometry",
    "geranium",
    "gerbil",
    "geriatric",
    "germicide",
    "germinate",
    "germless",
    "germproof",
    "gestate",
    "gestation",
    "gesture",
    "getaway",
    "getting",
    "getup",
    "giant",
    "gibberish",
    "giblet",
    "giddily",
    "giddiness",
    "giddy",
    "gift",
    "gigabyte",
    "gigahertz",
    "gigantic",
    "giggle",
    "giggling",
    "giggly",
    "gigolo",
    "gilled",
    "gills",
    "gimmick",
    "girdle",
    "giveaway",
    "given",
    "giver",
    "giving",
    "gizmo",
    "gizzard",
    "glacial",
    "glacier",
    "glade",
    "gladiator",
    "gladly",
    "glamorous",
    "glamour",
    "glance",
    "glancing",
    "glandular",
    "glare",
    "glaring",
    "glass",
    "glaucoma",
    "glazing",
    "gleaming",
    "gleeful",
    "glider",
    "gliding",
    "glimmer",
    "glimpse",
    "glisten",
    "glitch",
    "glitter",
    "glitzy",
    "gloater",
    "gloating",
    "gloomily",
    "gloomy",
    "glorified",
    "glorifier",
    "glorify",
    "glorious",
    "glory",
    "gloss",
    "glove",
    "glowing",
    "glowworm",
    "glucose",
    "glue",
    "gluten",
    "glutinous",
    "glutton",
    "gnarly",
    "gnat",
    "goal",
    "goatskin",
    "goes",
    "goggles",
    "going",
    "goldfish",
    "goldmine",
    "goldsmith",
    "golf",
    "goliath",
    "gonad",
    "gondola",
    "gone",
    "gong",
    "good",
    "gooey",
    "goofball",
    "goofiness",
    "goofy",
    "google",
    "goon",
    "gopher",
    "gore",
    "gorged",
    "gorgeous",
    "gory",
    "gosling",
    "gossip",
    "gothic",
    "gotten",
    "gout",
    "gown",
    "grab",
    "graceful",
    "graceless",
    "gracious",
    "gradation",
    "graded",
    "grader",
    "gradient",
    "grading",
    "gradually",
    "graduate",
    "graffiti",
    "grafted",
    "grafting",
    "grain",
    "granddad",
    "grandkid",
    "grandly",
    "grandma",
    "grandpa",
    "grandson",
    "granite",
    "granny",
    "granola",
    "grant",
    "granular",
    "grape",
    "graph",
    "grapple",
    "grappling",
    "grasp",
    "grass",
    "gratified",
    "gratify",
    "grating",
    "gratitude",
    "gratuity",
    "gravel",
    "graveness",
    "graves",
    "graveyard",
    "gravitate",
    "gravity",
    "gravy",
    "gray",
    "grazing",
    "greasily",
    "greedily",
    "greedless",
    "greedy",
    "green",
    "greeter",
    "greeting",
    "grew",
    "greyhound",
    "grid",
    "grief",
    "grievance",
    "grieving",
    "grievous",
    "grill",
    "grimace",
    "grimacing",
    "grime",
    "griminess",
    "grimy",
    "grinch",
    "grinning",
    "grip",
    "gristle",
    "grit",
    "groggily",
    "groggy",
    "groin",
    "groom",
    "groove",
    "grooving",
    "groovy",
    "grope",
    "ground",
    "grouped",
    "grout",
    "grove",
    "grower",
    "growing",
    "growl",
    "grub",
    "grudge",
    "grudging",
    "grueling",
    "gruffly",
    "grumble",
    "grumbling",
    "grumbly",
    "grumpily",
    "grunge",
    "grunt",
    "guacamole",
    "guidable",
    "guidance",
    "guide",
    "guiding",
    "guileless",
    "guise",
    "gulf",
    "gullible",
    "gully",
    "gulp",
    "gumball",
    "gumdrop",
    "gumminess",
    "gumming",
    "gummy",
    "gurgle",
    "gurgling",
    "guru",
    "gush",
    "gusto",
    "gusty",
    "gutless",
    "guts",
    "gutter",
    "guy",
    "guzzler",
    "gyration",
    "habitable",
    "habitant",
    "habitat",
    "habitual",
    "hacked",
    "hacker",
    "hacking",
    "hacksaw",
    "had",
    "haggler",
    "haiku",
    "half",
    "halogen",
    "halt",
    "halved",
    "halves",
    "hamburger",
    "hamlet",
    "hammock",
    "hamper",
    "hamster",
    "hamstring",
    "handbag",
    "handball",
    "handbook",
    "handbrake",
    "handcart",
    "handclap",
    "handclasp",
    "handcraft",
    "handcuff",
    "handed",
    "handful",
    "handgrip",
    "handgun",
    "handheld",
    "handiness",
    "handiwork",
    "handlebar",
    "handled",
    "handler",
    "handling",
    "handmade",
    "handoff",
    "handpick",
    "handprint",
    "handrail",
    "handsaw",
    "handset",
    "handsfree",
    "handshake",
    "handstand",
    "handwash",
    "handwork",
    "handwoven",
    "handwrite",
    "handyman",
    "hangnail",
    "hangout",
    "hangover",
    "hangup",
    "hankering",
    "hankie",
    "hanky",
    "haphazard",
    "happening",
    "happier",
    "happiest",
    "happily",
    "happiness",
    "happy",
    "harbor",
    "hardcopy",
    "hardcore",
    "hardcover",
    "harddisk",
    "hardened",
    "hardener",
    "hardening",
    "hardhat",
    "hardhead",
    "hardiness",
    "hardly",
    "hardness",
    "hardship",
    "hardware",
    "hardwired",
    "hardwood",
    "hardy",
    "harmful",
    "harmless",
    "harmonica",
    "harmonics",
    "harmonize",
    "harmony",
    "harness",
    "harpist",
    "harsh",
    "harvest",
    "hash",
    "hassle",
    "haste",
    "hastily",
    "hastiness",
    "hasty",
    "hatbox",
    "hatchback",
    "hatchery",
    "hatchet",
    "hatching",
    "hatchling",
    "hate",
    "hatless",
    "hatred",
    "haunt",
    "haven",
    "hazard",
    "hazelnut",
    "hazily",
    "haziness",
    "hazing",
    "hazy",
    "headache",
    "headband",
    "headboard",
    "headcount",
    "headdress",
    "headed",
    "header",
    "headfirst",
    "headgear",
    "heading",
    "headlamp",
    "headless",
    "headlock",
    "headphone",
    "headpiece",
    "headrest",
    "headroom",
    "headscarf",
    "headset",
    "headsman",
    "headstand",
    "headstone",
    "headway",
    "headwear",
    "heap",
    "heat",
    "heave",
    "heavily",
    "heaviness",
    "heaving",
    "hedge",
    "hedging",
    "heftiness",
    "hefty",
    "helium",
    "helmet",
    "helper",
    "helpful",
    "helping",
    "helpless",
    "helpline",
    "hemlock",
    "hemstitch",
    "hence",
    "henchman",
    "henna",
    "herald",
    "herbal",
    "herbicide",
    "herbs",
    "heritage",
    "hermit",
    "heroics",
    "heroism",
    "herring",
    "herself",
    "hertz",
    "hesitancy",
    "hesitant",
    "hesitate",
    "hexagon",
    "hexagram",
    "hubcap",
    "huddle",
    "huddling",
    "huff",
    "hug",
    "hula",
    "hulk",
    "hull",
    "human",
    "humble",
    "humbling",
    "humbly",
    "humid",
    "humiliate",
    "humility",
    "humming",
    "hummus",
    "humongous",
    "humorist",
    "humorless",
    "humorous",
    "humpback",
    "humped",
    "humvee",
    "hunchback",
    "hundredth",
    "hunger",
    "hungrily",
    "hungry",
    "hunk",
    "hunter",
    "hunting",
    "huntress",
    "huntsman",
    "hurdle",
    "hurled",
    "hurler",
    "hurling",
    "hurray",
    "hurricane",
    "hurried",
    "hurry",
    "hurt",
    "husband",
    "hush",
    "husked",
    "huskiness",
    "hut",
    "hybrid",
    "hydrant",
    "hydrated",
    "hydration",
    "hydrogen",
    "hydroxide",
    "hyperlink",
    "hypertext",
    "hyphen",
    "hypnoses",
    "hypnosis",
    "hypnotic",
    "hypnotism",
    "hypnotist",
    "hypnotize",
    "hypocrisy",
    "hypocrite",
    "ibuprofen",
    "ice",
    "iciness",
    "icing",
    "icky",
    "icon",
    "icy",
    "idealism",
    "idealist",
    "idealize",
    "ideally",
    "idealness",
    "identical",
    "identify",
    "identity",
    "ideology",
    "idiocy",
    "idiom",
    "idly",
    "igloo",
    "ignition",
    "ignore",
    "iguana",
    "illicitly",
    "illusion",
    "illusive",
    "image",
    "imaginary",
    "imagines",
    "imaging",
    "imbecile",
    "imitate",
    "imitation",
    "immature",
    "immerse",
    "immersion",
    "imminent",
    "immobile",
    "immodest",
    "immorally",
    "immortal",
    "immovable",
    "immovably",
    "immunity",
    "immunize",
    "impaired",
    "impale",
    "impart",
    "impatient",
    "impeach",
    "impeding",
    "impending",
    "imperfect",
    "imperial",
    "impish",
    "implant",
    "implement",
    "implicate",
    "implicit",
    "implode",
    "implosion",
    "implosive",
    "imply",
    "impolite",
    "important",
    "importer",
    "impose",
    "imposing",
    "impotence",
    "impotency",
    "impotent",
    "impound",
    "imprecise",
    "imprint",
    "imprison",
    "impromptu",
    "improper",
    "improve",
    "improving",
    "improvise",
    "imprudent",
    "impulse",
    "impulsive",
    "impure",
    "impurity",
    "iodine",
    "iodize",
    "ion",
    "ipad",
    "iphone",
    "ipod",
    "irate",
    "irk",
    "iron",
    "irregular",
    "irrigate",
    "irritable",
    "irritably",
    "irritant",
    "irritate",
    "islamic",
    "islamist",
    "isolated",
    "isolating",
    "isolation",
    "isotope",
    "issue",
    "issuing",
    "italicize",
    "italics",
    "item",
    "itinerary",
    "itunes",
    "ivory",
    "ivy",
    "jab",
    "jackal",
    "jacket",
    "jackknife",
    "jackpot",
    "jailbird",
    "jailbreak",
    "jailer",
    "jailhouse",
    "jalapeno",
    "jam",
    "janitor",
    "january",
    "jargon",
    "jarring",
    "jasmine",
    "jaundice",
    "jaunt",
    "java",
    "jawed",
    "jawless",
    "jawline",
    "jaws",
    "jaybird",
    "jaywalker",
    "jazz",
    "jeep",
    "jeeringly",
    "jellied",
    "jelly",
    "jersey",
    "jester",
    "jet",
    "jiffy",
    "jigsaw",
    "jimmy",
    "jingle",
    "jingling",
    "jinx",
    "jitters",
    "jittery",
    "job",
    "jockey",
    "jockstrap",
    "jogger",
    "jogging",
    "john",
    "joining",
    "jokester",
    "jokingly",
    "jolliness",
    "jolly",
    "jolt",
    "jot",
    "jovial",
    "joyfully",
    "joylessly",
    "joyous",
    "joyride",
    "joystick",
    "jubilance",
    "jubilant",
    "judge",
    "judgingly",
    "judicial",
    "judiciary",
    "judo",
    "juggle",
    "juggling",
    "jugular",
    "juice",
    "juiciness",
    "juicy",
    "jujitsu",
    "jukebox",
    "july",
    "jumble",
    "jumbo",
    "jump",
    "junction",
    "juncture",
    "june",
    "junior",
    "juniper",
    "junkie",
    "junkman",
    "junkyard",
    "jurist",
    "juror",
    "jury",
    "justice",
    "justifier",
    "justify",
    "justly",
    "justness",
    "juvenile",
    "kabob",
    "kangaroo",
    "karaoke",
    "karate",
    "karma",
    "kebab",
    "keenly",
    "keenness",
    "keep",
    "keg",
    "kelp",
    "kennel",
    "kept",
    "kerchief",
    "kerosene",
    "kettle",
    "kick",
    "kiln",
    "kilobyte",
    "kilogram",
    "kilometer",
    "kilowatt",
    "kilt",
    "kimono",
    "kindle",
    "kindling",
    "kindly",
    "kindness",
    "kindred",
    "kinetic",
    "kinfolk",
    "king",
    "kinship",
    "kinsman",
    "kinswoman",
    "kissable",
    "kisser",
    "kissing",
    "kitchen",
    "kite",
    "kitten",
    "kitty",
    "kiwi",
    "kleenex",
    "knapsack",
    "knee",
    "knelt",
    "knickers",
    "knoll",
    "koala",
    "kooky",
    "kosher",
    "krypton",
    "kudos",
    "kung",
    "labored",
    "laborer",
    "laboring",
    "laborious",
    "labrador",
    "ladder",
    "ladies",
    "ladle",
    "ladybug",
    "ladylike",
    "lagged",
    "lagging",
    "lagoon",
    "lair",
    "lake",
    "lance",
    "landed",
    "landfall",
    "landfill",
    "landing",
    "landlady",
    "landless",
    "landline",
    "landlord",
    "landmark",
    "landmass",
    "landmine",
    "landowner",
    "landscape",
    "landside",
    "landslide",
    "language",
    "lankiness",
    "lanky",
    "lantern",
    "lapdog",
    "lapel",
    "lapped",
    "lapping",
    "laptop",
    "lard",
    "large",
    "lark",
    "lash",
    "lasso",
    "last",
    "latch",
    "late",
    "lather",
    "latitude",
    "latrine",
    "latter",
    "latticed",
    "launch",
    "launder",
    "laundry",
    "laurel",
    "lavender",
    "lavish",
    "laxative",
    "lazily",
    "laziness",
    "lazy",
    "lecturer",
    "left",
    "legacy",
    "legal",
    "legend",
    "legged",
    "leggings",
    "legible",
    "legibly",
    "legislate",
    "lego",
    "legroom",
    "legume",
    "legwarmer",
    "legwork",
    "lemon",
    "lend",
    "length",
    "lens",
    "lent",
    "leotard",
    "lesser",
    "letdown",
    "lethargic",
    "lethargy",
    "letter",
    "lettuce",
    "level",
    "leverage",
    "levers",
    "levitate",
    "levitator",
    "liability",
    "liable",
    "liberty",
    "librarian",
    "library",
    "licking",
    "licorice",
    "lid",
    "life",
    "lifter",
    "lifting",
    "liftoff",
    "ligament",
    "likely",
    "likeness",
    "likewise",
    "liking",
    "lilac",
    "lilly",
    "lily",
    "limb",
    "limeade",
    "limelight",
    "limes",
    "limit",
    "limping",
    "limpness",
    "line",
    "lingo",
    "linguini",
    "linguist",
    "lining",
    "linked",
    "linoleum",
    "linseed",
    "lint",
    "lion",
    "lip",
    "liquefy",
    "liqueur",
    "liquid",
    "lisp",
    "list",
    "litigate",
    "litigator",
    "litmus",
    "litter",
    "little",
    "livable",
    "lived",
    "lively",
    "liver",
    "livestock",
    "lividly",
    "living",
    "lizard",
    "lubricant",
    "lubricate",
    "lucid",
    "luckily",
    "luckiness",
    "luckless",
    "lucrative",
    "ludicrous",
    "lugged",
    "lukewarm",
    "lullaby",
    "lumber",
    "luminance",
    "luminous",
    "lumpiness",
    "lumping",
    "lumpish",
    "lunacy",
    "lunar",
    "lunchbox",
    "luncheon",
    "lunchroom",
    "lunchtime",
    "lung",
    "lurch",
    "lure",
    "luridness",
    "lurk",
    "lushly",
    "lushness",
    "luster",
    "lustfully",
    "lustily",
    "lustiness",
    "lustrous",
    "lusty",
    "luxurious",
    "luxury",
    "lying",
    "lyrically",
    "lyricism",
    "lyricist",
    "lyrics",
    "macarena",
    "macaroni",
    "macaw",
    "mace",
    "machine",
    "machinist",
    "magazine",
    "magenta",
    "maggot",
    "magical",
    "magician",
    "magma",
    "magnesium",
    "magnetic",
    "magnetism",
    "magnetize",
    "magnifier",
    "magnify",
    "magnitude",
    "magnolia",
    "mahogany",
    "maimed",
    "majestic",
    "majesty",
    "majorette",
    "majority",
    "makeover",
    "maker",
    "makeshift",
    "making",
    "malformed",
    "malt",
    "mama",
    "mammal",
    "mammary",
    "mammogram",
    "manager",
    "managing",
    "manatee",
    "mandarin",
    "mandate",
    "mandatory",
    "mandolin",
    "manger",
    "mangle",
    "mango",
    "mangy",
    "manhandle",
    "manhole",
    "manhood",
    "manhunt",
    "manicotti",
    "manicure",
    "manifesto",
    "manila",
    "mankind",
    "manlike",
    "manliness",
    "manly",
    "manmade",
    "manned",
    "mannish",
    "manor",
    "manpower",
    "mantis",
    "mantra",
    "manual",
    "many",
    "map",
    "marathon",
    "marauding",
    "marbled",
    "marbles",
    "marbling",
    "march",
    "mardi",
    "margarine",
    "margarita",
    "margin",
    "marigold",
    "marina",
    "marine",
    "marital",
    "maritime",
    "marlin",
    "marmalade",
    "maroon",
    "married",
    "marrow",
    "marry",
    "marshland",
    "marshy",
    "marsupial",
    "marvelous",
    "marxism",
    "mascot",
    "masculine",
    "mashed",
    "mashing",
    "massager",
    "masses",
    "massive",
    "mastiff",
    "matador",
    "matchbook",
    "matchbox",
    "matcher",
    "matching",
    "matchless",
    "material",
    "maternal",
    "maternity",
    "math",
    "mating",
    "matriarch",
    "matrimony",
    "matrix",
    "matron",
    "matted",
    "matter",
    "maturely",
    "maturing",
    "maturity",
    "mauve",
    "maverick",
    "maximize",
    "maximum",
    "maybe",
    "mayday",
    "mayflower",
    "moaner",
    "moaning",
    "mobile",
    "mobility",
    "mobilize",
    "mobster",
    "mocha",
    "mocker",
    "mockup",
    "modified",
    "modify",
    "modular",
    "modulator",
    "module",
    "moisten",
    "moistness",
    "moisture",
    "molar",
    "molasses",
    "mold",
    "molecular",
    "molecule",
    "molehill",
    "mollusk",
    "mom",
    "monastery",
    "monday",
    "monetary",
    "monetize",
    "moneybags",
    "moneyless",
    "moneywise",
    "mongoose",
    "mongrel",
    "monitor",
    "monkhood",
    "monogamy",
    "monogram",
    "monologue",
    "monopoly",
    "monorail",
    "monotone",
    "monotype",
    "monoxide",
    "monsieur",
    "monsoon",
    "monstrous",
    "monthly",
    "monument",
    "moocher",
    "moodiness",
    "moody",
    "mooing",
    "moonbeam",
    "mooned",
    "moonlight",
    "moonlike",
    "moonlit",
    "moonrise",
    "moonscape",
    "moonshine",
    "moonstone",
    "moonwalk",
    "mop",
    "morale",
    "morality",
    "morally",
    "morbidity",
    "morbidly",
    "morphine",
    "morphing",
    "morse",
    "mortality",
    "mortally",
    "mortician",
    "mortified",
    "mortify",
    "mortuary",
    "mosaic",
    "mossy",
    "most",
    "mothball",
    "mothproof",
    "motion",
    "motivate",
    "motivator",
    "motive",
    "motocross",
    "motor",
    "motto",
    "mountable",
    "mountain",
    "mounted",
    "mounting",
    "mourner",
    "mournful",
    "mouse",
    "mousiness",
    "moustache",
    "mousy",
    "mouth",
    "movable",
    "move",
    "movie",
    "moving",
    "mower",
    "mowing",
    "much",
    "muck",
    "mud",
    "mug",
    "mulberry",
    "mulch",
    "mule",
    "mulled",
    "mullets",
    "multiple",
    "multiply",
    "multitask",
    "multitude",
    "mumble",
    "mumbling",
    "mumbo",
    "mummified",
    "mummify",
    "mummy",
    "mumps",
    "munchkin",
    "mundane",
    "municipal",
    "muppet",
    "mural",
    "murkiness",
    "murky",
    "murmuring",
    "muscular",
    "museum",
    "mushily",
    "mushiness",
    "mushroom",
    "mushy",
    "music",
    "musket",
    "muskiness",
    "musky",
    "mustang",
    "mustard",
    "muster",
    "mustiness",
    "musty",
    "mutable",
    "mutate",
    "mutation",
    "mute",
    "mutilated",
    "mutilator",
    "mutiny",
    "mutt",
    "mutual",
    "muzzle",
    "myself",
    "myspace",
    "mystified",
    "mystify",
    "myth",
    "nacho",
    "nag",
    "nail",
    "name",
    "naming",
    "nanny",
    "nanometer",
    "nape",
    "napkin",
    "napped",
    "napping",
    "nappy",
    "narrow",
    "nastily",
    "nastiness",
    "national",
    "native",
    "nativity",
    "natural",
    "nature",
    "naturist",
    "nautical",
    "navigate",
    "navigator",
    "navy",
    "nearby",
    "nearest",
    "nearly",
    "nearness",
    "neatly",
    "neatness",
    "nebula",
    "nebulizer",
    "nectar",
    "negate",
    "negation",
    "negative",
    "neglector",
    "negligee",
    "negligent",
    "negotiate",
    "nemeses",
    "nemesis",
    "neon",
    "nephew",
    "nerd",
    "nervous",
    "nervy",
    "nest",
    "net",
    "neurology",
    "neuron",
    "neurosis",
    "neurotic",
    "neuter",
    "neutron",
    "never",
    "next",
    "nibble",
    "nickname",
    "nicotine",
    "niece",
    "nifty",
    "nimble",
    "nimbly",
    "nineteen",
    "ninetieth",
    "ninja",
    "nintendo",
    "ninth",
    "nuclear",
    "nuclei",
    "nucleus",
    "nugget",
    "nullify",
    "number",
    "numbing",
    "numbly",
    "numbness",
    "numeral",
    "numerate",
    "numerator",
    "numeric",
    "numerous",
    "nuptials",
    "nursery",
    "nursing",
    "nurture",
    "nutcase",
    "nutlike",
    "nutmeg",
    "nutrient",
    "nutshell",
    "nuttiness",
    "nutty",
    "nuzzle",
    "nylon",
    "oaf",
    "oak",
    "oasis",
    "oat",
    "obedience",
    "obedient",
    "obituary",
    "object",
    "obligate",
    "obliged",
    "oblivion",
    "oblivious",
    "oblong",
    "obnoxious",
    "oboe",
    "obscure",
    "obscurity",
    "observant",
    "observer",
    "observing",
    "obsessed",
    "obsession",
    "obsessive",
    "obsolete",
    "obstacle",
    "obstinate",
    "obstruct",
    "obtain",
    "obtrusive",
    "obtuse",
    "obvious",
    "occultist",
    "occupancy",
    "occupant",
    "occupier",
    "occupy",
    "ocean",
    "ocelot",
    "octagon",
    "octane",
    "october",
    "octopus",
    "ogle",
    "oil",
    "oink",
    "ointment",
    "okay",
    "old",
    "olive",
    "olympics",
    "omega",
    "omen",
    "ominous",
    "omission",
    "omit",
    "omnivore",
    "onboard",
    "oncoming",
    "ongoing",
    "onion",
    "online",
    "onlooker",
    "only",
    "onscreen",
    "onset",
    "onshore",
    "onslaught",
    "onstage",
    "onto",
    "onward",
    "onyx",
    "oops",
    "ooze",
    "oozy",
    "opacity",
    "opal",
    "open",
    "operable",
    "operate",
    "operating",
    "operation",
    "operative",
    "operator",
    "opium",
    "opossum",
    "opponent",
    "oppose",
    "opposing",
    "opposite",
    "oppressed",
    "oppressor",
    "opt",
    "opulently",
    "osmosis",
    "other",
    "otter",
    "ouch",
    "ought",
    "ounce",
    "outage",
    "outback",
    "outbid",
    "outboard",
    "outbound",
    "outbreak",
    "outburst",
    "outcast",
    "outclass",
    "outcome",
    "outdated",
    "outdoors",
    "outer",
    "outfield",
    "outfit",
    "outflank",
    "outgoing",
    "outgrow",
    "outhouse",
    "outing",
    "outlast",
    "outlet",
    "outline",
    "outlook",
    "outlying",
    "outmatch",
    "outmost",
    "outnumber",
    "outplayed",
    "outpost",
    "outpour",
    "output",
    "outrage",
    "outrank",
    "outreach",
    "outright",
    "outscore",
    "outsell",
    "outshine",
    "outshoot",
    "outsider",
    "outskirts",
    "outsmart",
    "outsource",
    "outspoken",
    "outtakes",
    "outthink",
    "outward",
    "outweigh",
    "outwit",
    "oval",
    "ovary",
    "oven",
    "overact",
    "overall",
    "overarch",
    "overbid",
    "overbill",
    "overbite",
    "overblown",
    "overboard",
    "overbook",
    "overbuilt",
    "overcast",
    "overcoat",
    "overcome",
    "overcook",
    "overcrowd",
    "overdraft",
    "overdrawn",
    "overdress",
    "overdrive",
    "overdue",
    "overeager",
    "overeater",
    "overexert",
    "overfed",
    "overfeed",
    "overfill",
    "overflow",
    "overfull",
    "overgrown",
    "overhand",
    "overhang",
    "overhaul",
    "overhead",
    "overhear",
    "overheat",
    "overhung",
    "overjoyed",
    "overkill",
    "overlabor",
    "overlaid",
    "overlap",
    "overlay",
    "overload",
    "overlook",
    "overlord",
    "overlying",
    "overnight",
    "overpass",
    "overpay",
    "overplant",
    "overplay",
    "overpower",
    "overprice",
    "overrate",
    "overreach",
    "overreact",
    "override",
    "overripe",
    "overrule",
    "overrun",
    "overshoot",
    "overshot",
    "oversight",
    "oversized",
    "oversleep",
    "oversold",
    "overspend",
    "overstate",
    "overstay",
    "overstep",
    "overstock",
    "overstuff",
    "oversweet",
    "overtake",
    "overthrow",
    "overtime",
    "overtly",
    "overtone",
    "overture",
    "overturn",
    "overuse",
    "overvalue",
    "overview",
    "overwrite",
    "owl",
    "oxford",
    "oxidant",
    "oxidation",
    "oxidize",
    "oxidizing",
    "oxygen",
    "oxymoron",
    "oyster",
    "ozone",
    "paced",
    "pacemaker",
    "pacific",
    "pacifier",
    "pacifism",
    "pacifist",
    "pacify",
    "padded",
    "padding",
    "paddle",
    "paddling",
    "padlock",
    "pagan",
    "pager",
    "paging",
    "pajamas",
    "palace",
    "palatable",
    "palm",
    "palpable",
    "palpitate",
    "paltry",
    "pampered",
    "pamperer",
    "pampers",
    "pamphlet",
    "panama",
    "pancake",
    "pancreas",
    "panda",
    "pandemic",
    "pang",
    "panhandle",
    "panic",
    "panning",
    "panorama",
    "panoramic",
    "panther",
    "pantomime",
    "pantry",
    "pants",
    "pantyhose",
    "paparazzi",
    "papaya",
    "paper",
    "paprika",
    "papyrus",
    "parabola",
    "parachute",
    "parade",
    "paradox",
    "paragraph",
    "parakeet",
    "paralegal",
    "paralyses",
    "paralysis",
    "paralyze",
    "paramedic",
    "parameter",
    "paramount",
    "parasail",
    "parasite",
    "parasitic",
    "parcel",
    "parched",
    "parchment",
    "pardon",
    "parish",
    "parka",
    "parking",
    "parkway",
    "parlor",
    "parmesan",
    "parole",
    "parrot",
    "parsley",
    "parsnip",
    "partake",
    "parted",
    "parting",
    "partition",
    "partly",
    "partner",
    "partridge",
    "party",
    "passable",
    "passably",
    "passage",
    "passcode",
    "passenger",
    "passerby",
    "passing",
    "passion",
    "passive",
    "passivism",
    "passover",
    "passport",
    "password",
    "pasta",
    "pasted",
    "pastel",
    "pastime",
    "pastor",
    "pastrami",
    "pasture",
    "pasty",
    "patchwork",
    "patchy",
    "paternal",
    "paternity",
    "path",
    "patience",
    "patient",
    "patio",
    "patriarch",
    "patriot",
    "patrol",
    "patronage",
    "patronize",
    "pauper",
    "pavement",
    "paver",
    "pavestone",
    "pavilion",
    "paving",
    "pawing",
    "payable",
    "payback",
    "paycheck",
    "payday",
    "payee",
    "payer",
    "paying",
    "payment",
    "payphone",
    "payroll",
    "pebble",
    "pebbly",
    "pecan",
    "pectin",
    "peculiar",
    "peddling",
    "pediatric",
    "pedicure",
    "pedigree",
    "pedometer",
    "pegboard",
    "pelican",
    "pellet",
    "pelt",
    "pelvis",
    "penalize",
    "penalty",
    "pencil",
    "pendant",
    "pending",
    "penholder",
    "penknife",
    "pennant",
    "penniless",
    "penny",
    "penpal",
    "pension",
    "pentagon",
    "pentagram",
    "pep",
    "perceive",
    "percent",
    "perch",
    "percolate",
    "perennial",
    "perfected",
    "perfectly",
    "perfume",
    "periscope",
    "perish",
    "perjurer",
    "perjury",
    "perkiness",
    "perky",
    "perm",
    "peroxide",
    "perpetual",
    "perplexed",
    "persecute",
    "persevere",
    "persuaded",
    "persuader",
    "pesky",
    "peso",
    "pessimism",
    "pessimist",
    "pester",
    "pesticide",
    "petal",
    "petite",
    "petition",
    "petri",
    "petroleum",
    "petted",
    "petticoat",
    "pettiness",
    "petty",
    "petunia",
    "phantom",
    "phobia",
    "phoenix",
    "phonebook",
    "phoney",
    "phonics",
    "phoniness",
    "phony",
    "phosphate",
    "photo",
    "phrase",
    "phrasing",
    "placard",
    "placate",
    "placidly",
    "plank",
    "planner",
    "plant",
    "plasma",
    "plaster",
    "plastic",
    "plated",
    "platform",
    "plating",
    "platinum",
    "platonic",
    "platter",
    "platypus",
    "plausible",
    "plausibly",
    "playable",
    "playback",
    "player",
    "playful",
    "playgroup",
    "playhouse",
    "playing",
    "playlist",
    "playmaker",
    "playmate",
    "playoff",
    "playpen",
    "playroom",
    "playset",
    "plaything",
    "playtime",
    "plaza",
    "pleading",
    "pleat",
    "pledge",
    "plentiful",
    "plenty",
    "plethora",
    "plexiglas",
    "pliable",
    "plod",
    "plop",
    "plot",
    "plow",
    "ploy",
    "pluck",
    "plug",
    "plunder",
    "plunging",
    "plural",
    "plus",
    "plutonium",
    "plywood",
    "poach",
    "pod",
    "poem",
    "poet",
    "pogo",
    "pointed",
    "pointer",
    "pointing",
    "pointless",
    "pointy",
    "poise",
    "poison",
    "poker",
    "poking",
    "polar",
    "police",
    "policy",
    "polio",
    "polish",
    "politely",
    "polka",
    "polo",
    "polyester",
    "polygon",
    "polygraph",
    "polymer",
    "poncho",
    "pond",
    "pony",
    "popcorn",
    "pope",
    "poplar",
    "popper",
    "poppy",
    "popsicle",
    "populace",
    "popular",
    "populate",
    "porcupine",
    "pork",
    "porous",
    "porridge",
    "portable",
    "portal",
    "portfolio",
    "porthole",
    "portion",
    "portly",
    "portside",
    "poser",
    "posh",
    "posing",
    "possible",
    "possibly",
    "possum",
    "postage",
    "postal",
    "postbox",
    "postcard",
    "posted",
    "poster",
    "posting",
    "postnasal",
    "posture",
    "postwar",
    "pouch",
    "pounce",
    "pouncing",
    "pound",
    "pouring",
    "pout",
    "powdered",
    "powdering",
    "powdery",
    "power",
    "powwow",
    "pox",
    "praising",
    "prance",
    "prancing",
    "pranker",
    "prankish",
    "prankster",
    "prayer",
    "praying",
    "preacher",
    "preaching",
    "preachy",
    "preamble",
    "precinct",
    "precise",
    "precision",
    "precook",
    "precut",
    "predator",
    "predefine",
    "predict",
    "preface",
    "prefix",
    "preflight",
    "preformed",
    "pregame",
    "pregnancy",
    "pregnant",
    "preheated",
    "prelaunch",
    "prelaw",
    "prelude",
    "premiere",
    "premises",
    "premium",
    "prenatal",
    "preoccupy",
    "preorder",
    "prepaid",
    "prepay",
    "preplan",
    "preppy",
    "preschool",
    "prescribe",
    "preseason",
    "preset",
    "preshow",
    "president",
    "presoak",
    "press",
    "presume",
    "presuming",
    "preteen",
    "pretended",
    "pretender",
    "pretense",
    "pretext",
    "pretty",
    "pretzel",
    "prevail",
    "prevalent",
    "prevent",
    "preview",
    "previous",
    "prewar",
    "prewashed",
    "prideful",
    "pried",
    "primal",
    "primarily",
    "primary",
    "primate",
    "primer",
    "primp",
    "princess",
    "print",
    "prior",
    "prism",
    "prison",
    "prissy",
    "pristine",
    "privacy",
    "private",
    "privatize",
    "prize",
    "proactive",
    "probable",
    "probably",
    "probation",
    "probe",
    "probing",
    "probiotic",
    "problem",
    "procedure",
    "process",
    "proclaim",
    "procreate",
    "procurer",
    "prodigal",
    "prodigy",
    "produce",
    "product",
    "profane",
    "profanity",
    "professed",
    "professor",
    "profile",
    "profound",
    "profusely",
    "progeny",
    "prognosis",
    "program",
    "progress",
    "projector",
    "prologue",
    "prolonged",
    "promenade",
    "prominent",
    "promoter",
    "promotion",
    "prompter",
    "promptly",
    "prone",
    "prong",
    "pronounce",
    "pronto",
    "proofing",
    "proofread",
    "proofs",
    "propeller",
    "properly",
    "property",
    "proponent",
    "proposal",
    "propose",
    "props",
    "prorate",
    "protector",
    "protegee",
    "proton",
    "prototype",
    "protozoan",
    "protract",
    "protrude",
    "proud",
    "provable",
    "proved",
    "proven",
    "provided",
    "provider",
    "providing",
    "province",
    "proving",
    "provoke",
    "provoking",
    "provolone",
    "prowess",
    "prowler",
    "prowling",
    "proximity",
    "proxy",
    "prozac",
    "prude",
    "prudishly",
    "prune",
    "pruning",
    "pry",
    "psychic",
    "public",
    "publisher",
    "pucker",
    "pueblo",
    "pug",
    "pull",
    "pulmonary",
    "pulp",
    "pulsate",
    "pulse",
    "pulverize",
    "puma",
    "pumice",
    "pummel",
    "punch",
    "punctual",
    "punctuate",
    "punctured",
    "pungent",
    "punisher",
    "punk",
    "pupil",
    "puppet",
    "puppy",
    "purchase",
    "pureblood",
    "purebred",
    "purely",
    "pureness",
    "purgatory",
    "purge",
    "purging",
    "purifier",
    "purify",
    "purist",
    "puritan",
    "purity",
    "purple",
    "purplish",
    "purposely",
    "purr",
    "purse",
    "pursuable",
    "pursuant",
    "pursuit",
    "purveyor",
    "pushcart",
    "pushchair",
    "pusher",
    "pushiness",
    "pushing",
    "pushover",
    "pushpin",
    "pushup",
    "pushy",
    "putdown",
    "putt",
    "puzzle",
    "puzzling",
    "pyramid",
    "pyromania",
    "python",
    "quack",
    "quadrant",
    "quail",
    "quaintly",
    "quake",
    "quaking",
    "qualified",
    "qualifier",
    "qualify",
    "quality",
    "qualm",
    "quantum",
    "quarrel",
    "quarry",
    "quartered",
    "quarterly",
    "quarters",
    "quartet",
    "quench",
    "query",
    "quicken",
    "quickly",
    "quickness",
    "quicksand",
    "quickstep",
    "quiet",
    "quill",
    "quilt",
    "quintet",
    "quintuple",
    "quirk",
    "quit",
    "quiver",
    "quizzical",
    "quotable",
    "quotation",
    "quote",
    "rabid",
    "race",
    "racing",
    "racism",
    "rack",
    "racoon",
    "radar",
    "radial",
    "radiance",
    "radiantly",
    "radiated",
    "radiation",
    "radiator",
    "radio",
    "radish",
    "raffle",
    "raft",
    "rage",
    "ragged",
    "raging",
    "ragweed",
    "raider",
    "railcar",
    "railing",
    "railroad",
    "railway",
    "raisin",
    "rake",
    "raking",
    "rally",
    "ramble",
    "rambling",
    "ramp",
    "ramrod",
    "ranch",
    "rancidity",
    "random",
    "ranged",
    "ranger",
    "ranging",
    "ranked",
    "ranking",
    "ransack",
    "ranting",
    "rants",
    "rare",
    "rarity",
    "rascal",
    "rash",
    "rasping",
    "ravage",
    "raven",
    "ravine",
    "raving",
    "ravioli",
    "ravishing",
    "reabsorb",
    "reach",
    "reacquire",
    "reaction",
    "reactive",
    "reactor",
    "reaffirm",
    "ream",
    "reanalyze",
    "reappear",
    "reapply",
    "reappoint",
    "reapprove",
    "rearrange",
    "rearview",
    "reason",
    "reassign",
    "reassure",
    "reattach",
    "reawake",
    "rebalance",
    "rebate",
    "rebel",
    "rebirth",
    "reboot",
    "reborn",
    "rebound",
    "rebuff",
    "rebuild",
    "rebuilt",
    "reburial",
    "rebuttal",
    "recall",
    "recant",
    "recapture",
    "recast",
    "recede",
    "recent",
    "recess",
    "recharger",
    "recipient",
    "recital",
    "recite",
    "reckless",
    "reclaim",
    "recliner",
    "reclining",
    "recluse",
    "reclusive",
    "recognize",
    "recoil",
    "recollect",
    "recolor",
    "reconcile",
    "reconfirm",
    "reconvene",
    "recopy",
    "record",
    "recount",
    "recoup",
    "recovery",
    "recreate",
    "rectal",
    "rectangle",
    "rectified",
    "rectify",
    "recycled",
    "recycler",
    "recycling",
    "reemerge",
    "reenact",
    "reenter",
    "reentry",
    "reexamine",
    "referable",
    "referee",
    "reference",
    "refill",
    "refinance",
    "refined",
    "refinery",
    "refining",
    "refinish",
    "reflected",
    "reflector",
    "reflex",
    "reflux",
    "refocus",
    "refold",
    "reforest",
    "reformat",
    "reformed",
    "reformer",
    "reformist",
    "refract",
    "refrain",
    "refreeze",
    "refresh",
    "refried",
    "refueling",
    "refund",
    "refurbish",
    "refurnish",
    "refusal",
    "refuse",
    "refusing",
    "refutable",
    "refute",
    "regain",
    "regalia",
    "regally",
    "reggae",
    "regime",
    "region",
    "register",
    "registrar",
    "registry",
    "regress",
    "regretful",
    "regroup",
    "regular",
    "regulate",
    "regulator",
    "rehab",
    "reheat",
    "rehire",
    "rehydrate",
    "reimburse",
    "reissue",
    "reiterate",
    "rejoice",
    "rejoicing",
    "rejoin",
    "rekindle",
    "relapse",
    "relapsing",
    "relatable",
    "related",
    "relation",
    "relative",
    "relax",
    "relay",
    "relearn",
    "release",
    "relenting",
    "reliable",
    "reliably",
    "reliance",
    "reliant",
    "relic",
    "relieve",
    "relieving",
    "relight",
    "relish",
    "relive",
    "reload",
    "relocate",
    "relock",
    "reluctant",
    "rely",
    "remake",
    "remark",
    "remarry",
    "rematch",
    "remedial",
    "remedy",
    "remember",
    "reminder",
    "remindful",
    "remission",
    "remix",
    "remnant",
    "remodeler",
    "remold",
    "remorse",
    "remote",
    "removable",
    "removal",
    "removed",
    "remover",
    "removing",
    "rename",
    "renderer",
    "rendering",
    "rendition",
    "renegade",
    "renewable",
    "renewably",
    "renewal",
    "renewed",
    "renounce",
    "renovate",
    "renovator",
    "rentable",
    "rental",
    "rented",
    "renter",
    "reoccupy",
    "reoccur",
    "reopen",
    "reorder",
    "repackage",
    "repacking",
    "repaint",
    "repair",
    "repave",
    "repaying",
    "repayment",
    "repeal",
    "repeated",
    "repeater",
    "repent",
    "rephrase",
    "replace",
    "replay",
    "replica",
    "reply",
    "reporter",
    "repose",
    "repossess",
    "repost",
    "repressed",
    "reprimand",
    "reprint",
    "reprise",
    "reproach",
    "reprocess",
    "reproduce",
    "reprogram",
    "reps",
    "reptile",
    "reptilian",
    "repugnant",
    "repulsion",
    "repulsive",
    "repurpose",
    "reputable",
    "reputably",
    "request",
    "require",
    "requisite",
    "reroute",
    "rerun",
    "resale",
    "resample",
    "rescuer",
    "reseal",
    "research",
    "reselect",
    "reseller",
    "resemble",
    "resend",
    "resent",
    "reset",
    "reshape",
    "reshoot",
    "reshuffle",
    "residence",
    "residency",
    "resident",
    "residual",
    "residue",
    "resigned",
    "resilient",
    "resistant",
    "resisting",
    "resize",
    "resolute",
    "resolved",
    "resonant",
    "resonate",
    "resort",
    "resource",
    "respect",
    "resubmit",
    "result",
    "resume",
    "resupply",
    "resurface",
    "resurrect",
    "retail",
    "retainer",
    "retaining",
    "retake",
    "retaliate",
    "retention",
    "rethink",
    "retinal",
    "retired",
    "retiree",
    "retiring",
    "retold",
    "retool",
    "retorted",
    "retouch",
    "retrace",
    "retract",
    "retrain",
    "retread",
    "retreat",
    "retrial",
    "retrieval",
    "retriever",
    "retry",
    "return",
    "retying",
    "retype",
    "reunion",
    "reunite",
    "reusable",
    "reuse",
    "reveal",
    "reveler",
    "revenge",
    "revenue",
    "reverb",
    "revered",
    "reverence",
    "reverend",
    "reversal",
    "reverse",
    "reversing",
    "reversion",
    "revert",
    "revisable",
    "revise",
    "revision",
    "revisit",
    "revivable",
    "revival",
    "reviver",
    "reviving",
    "revocable",
    "revoke",
    "revolt",
    "revolver",
    "revolving",
    "reward",
    "rewash",
    "rewind",
    "rewire",
    "reword",
    "rework",
    "rewrap",
    "rewrite",
    "rhyme",
    "ribbon",
    "ribcage",
    "rice",
    "riches",
    "richly",
    "richness",
    "rickety",
    "ricotta",
    "riddance",
    "ridden",
    "ride",
    "riding",
    "rifling",
    "rift",
    "rigging",
    "rigid",
    "rigor",
    "rimless",
    "rimmed",
    "rind",
    "rink",
    "rinse",
    "rinsing",
    "riot",
    "ripcord",
    "ripeness",
    "ripening",
    "ripping",
    "ripple",
    "rippling",
    "riptide",
    "rise",
    "rising",
    "risk",
    "risotto",
    "ritalin",
    "ritzy",
    "rival",
    "riverbank",
    "riverbed",
    "riverboat",
    "riverside",
    "riveter",
    "riveting",
    "roamer",
    "roaming",
    "roast",
    "robbing",
    "robe",
    "robin",
    "robotics",
    "robust",
    "rockband",
    "rocker",
    "rocket",
    "rockfish",
    "rockiness",
    "rocking",
    "rocklike",
    "rockslide",
    "rockstar",
    "rocky",
    "rogue",
    "roman",
    "romp",
    "rope",
    "roping",
    "roster",
    "rosy",
    "rotten",
    "rotting",
    "rotunda",
    "roulette",
    "rounding",
    "roundish",
    "roundness",
    "roundup",
    "roundworm",
    "routine",
    "routing",
    "rover",
    "roving",
    "royal",
    "rubbed",
    "rubber",
    "rubbing",
    "rubble",
    "rubdown",
    "ruby",
    "ruckus",
    "rudder",
    "rug",
    "ruined",
    "rule",
    "rumble",
    "rumbling",
    "rummage",
    "rumor",
    "runaround",
    "rundown",
    "runner",
    "running",
    "runny",
    "runt",
    "runway",
    "rupture",
    "rural",
    "ruse",
    "rush",
    "rust",
    "rut",
    "sabbath",
    "sabotage",
    "sacrament",
    "sacred",
    "sacrifice",
    "sadden",
    "saddlebag",
    "saddled",
    "saddling",
    "sadly",
    "sadness",
    "safari",
    "safeguard",
    "safehouse",
    "safely",
    "safeness",
    "saffron",
    "saga",
    "sage",
    "sagging",
    "saggy",
    "said",
    "saint",
    "sake",
    "salad",
    "salami",
    "salaried",
    "salary",
    "saline",
    "salon",
    "saloon",
    "salsa",
    "salt",
    "salutary",
    "salute",
    "salvage",
    "salvaging",
    "salvation",
    "same",
    "sample",
    "sampling",
    "sanction",
    "sanctity",
    "sanctuary",
    "sandal",
    "sandbag",
    "sandbank",
    "sandbar",
    "sandblast",
    "sandbox",
    "sanded",
    "sandfish",
    "sanding",
    "sandlot",
    "sandpaper",
    "sandpit",
    "sandstone",
    "sandstorm",
    "sandworm",
    "sandy",
    "sanitary",
    "sanitizer",
    "sank",
    "santa",
    "sapling",
    "sappiness",
    "sappy",
    "sarcasm",
    "sarcastic",
    "sardine",
    "sash",
    "sasquatch",
    "sassy",
    "satchel",
    "satiable",
    "satin",
    "satirical",
    "satisfied",
    "satisfy",
    "saturate",
    "saturday",
    "sauciness",
    "saucy",
    "sauna",
    "savage",
    "savanna",
    "saved",
    "savings",
    "savior",
    "savor",
    "saxophone",
    "say",
    "scabbed",
    "scabby",
    "scalded",
    "scalding",
    "scale",
    "scaling",
    "scallion",
    "scallop",
    "scalping",
    "scam",
    "scandal",
    "scanner",
    "scanning",
    "scant",
    "scapegoat",
    "scarce",
    "scarcity",
    "scarecrow",
    "scared",
    "scarf",
    "scarily",
    "scariness",
    "scarring",
    "scary",
    "scavenger",
    "scenic",
    "schedule",
    "schematic",
    "scheme",
    "scheming",
    "schilling",
    "schnapps",
    "scholar",
    "science",
    "scientist",
    "scion",
    "scoff",
    "scolding",
    "scone",
    "scoop",
    "scooter",
    "scope",
    "scorch",
    "scorebook",
    "scorecard",
    "scored",
    "scoreless",
    "scorer",
    "scoring",
    "scorn",
    "scorpion",
    "scotch",
    "scoundrel",
    "scoured",
    "scouring",
    "scouting",
    "scouts",
    "scowling",
    "scrabble",
    "scraggly",
    "scrambled",
    "scrambler",
    "scrap",
    "scratch",
    "scrawny",
    "screen",
    "scribble",
    "scribe",
    "scribing",
    "scrimmage",
    "script",
    "scroll",
    "scrooge",
    "scrounger",
    "scrubbed",
    "scrubber",
    "scruffy",
    "scrunch",
    "scrutiny",
    "scuba",
    "scuff",
    "sculptor",
    "sculpture",
    "scurvy",
    "scuttle",
    "secluded",
    "secluding",
    "seclusion",
    "second",
    "secrecy",
    "secret",
    "sectional",
    "sector",
    "secular",
    "securely",
    "security",
    "sedan",
    "sedate",
    "sedation",
    "sedative",
    "sediment",
    "seduce",
    "seducing",
    "segment",
    "seismic",
    "seizing",
    "seldom",
    "selected",
    "selection",
    "selective",
    "selector",
    "self",
    "seltzer",
    "semantic",
    "semester",
    "semicolon",
    "semifinal",
    "seminar",
    "semisoft",
    "semisweet",
    "senate",
    "senator",
    "send",
    "senior",
    "senorita",
    "sensation",
    "sensitive",
    "sensitize",
    "sensually",
    "sensuous",
    "sepia",
    "september",
    "septic",
    "septum",
    "sequel",
    "sequence",
    "sequester",
    "series",
    "sermon",
    "serotonin",
    "serpent",
    "serrated",
    "serve",
    "service",
    "serving",
    "sesame",
    "sessions",
    "setback",
    "setting",
    "settle",
    "settling",
    "setup",
    "sevenfold",
    "seventeen",
    "seventh",
    "seventy",
    "severity",
    "shabby",
    "shack",
    "shaded",
    "shadily",
    "shadiness",
    "shading",
    "shadow",
    "shady",
    "shaft",
    "shakable",
    "shakily",
    "shakiness",
    "shaking",
    "shaky",
    "shale",
    "shallot",
    "shallow",
    "shame",
    "shampoo",
    "shamrock",
    "shank",
    "shanty",
    "shape",
    "shaping",
    "share",
    "sharpener",
    "sharper",
    "sharpie",
    "sharply",
    "sharpness",
    "shawl",
    "sheath",
    "shed",
    "sheep",
    "sheet",
    "shelf",
    "shell",
    "shelter",
    "shelve",
    "shelving",
    "sherry",
    "shield",
    "shifter",
    "shifting",
    "shiftless",
    "shifty",
    "shimmer",
    "shimmy",
    "shindig",
    "shine",
    "shingle",
    "shininess",
    "shining",
    "shiny",
    "ship",
    "shirt",
    "shivering",
    "shock",
    "shone",
    "shoplift",
    "shopper",
    "shopping",
    "shoptalk",
    "shore",
    "shortage",
    "shortcake",
    "shortcut",
    "shorten",
    "shorter",
    "shorthand",
    "shortlist",
    "shortly",
    "shortness",
    "shorts",
    "shortwave",
    "shorty",
    "shout",
    "shove",
    "showbiz",
    "showcase",
    "showdown",
    "shower",
    "showgirl",
    "showing",
    "showman",
    "shown",
    "showoff",
    "showpiece",
    "showplace",
    "showroom",
    "showy",
    "shrank",
    "shrapnel",
    "shredder",
    "shredding",
    "shrewdly",
    "shriek",
    "shrill",
    "shrimp",
    "shrine",
    "shrink",
    "shrivel",
    "shrouded",
    "shrubbery",
    "shrubs",
    "shrug",
    "shrunk",
    "shucking",
    "shudder",
    "shuffle",
    "shuffling",
    "shun",
    "shush",
    "shut",
    "shy",
    "siamese",
    "siberian",
    "sibling",
    "siding",
    "sierra",
    "siesta",
    "sift",
    "sighing",
    "silenced",
    "silencer",
    "silent",
    "silica",
    "silicon",
    "silk",
    "silliness",
    "silly",
    "silo",
    "silt",
    "silver",
    "similarly",
    "simile",
    "simmering",
    "simple",
    "simplify",
    "simply",
    "sincere",
    "sincerity",
    "singer",
    "singing",
    "single",
    "singular",
    "sinister",
    "sinless",
    "sinner",
    "sinuous",
    "sip",
    "siren",
    "sister",
    "sitcom",
    "sitter",
    "sitting",
    "situated",
    "situation",
    "sixfold",
    "sixteen",
    "sixth",
    "sixties",
    "sixtieth",
    "sixtyfold",
    "sizable",
    "sizably",
    "size",
    "sizing",
    "sizzle",
    "sizzling",
    "skater",
    "skating",
    "skedaddle",
    "skeletal",
    "skeleton",
    "skeptic",
    "sketch",
    "skewed",
    "skewer",
    "skid",
    "skied",
    "skier",
    "skies",
    "skiing",
    "skilled",
    "skillet",
    "skillful",
    "skimmed",
    "skimmer",
    "skimming",
    "skimpily",
    "skincare",
    "skinhead",
    "skinless",
    "skinning",
    "skinny",
    "skintight",
    "skipper",
    "skipping",
    "skirmish",
    "skirt",
    "skittle",
    "skydiver",
    "skylight",
    "skyline",
    "skype",
    "skyrocket",
    "skyward",
    "slab",
    "slacked",
    "slacker",
    "slacking",
    "slackness",
    "slacks",
    "slain",
    "slam",
    "slander",
    "slang",
    "slapping",
    "slapstick",
    "slashed",
    "slashing",
    "slate",
    "slather",
    "slaw",
    "sled",
    "sleek",
    "sleep",
    "sleet",
    "sleeve",
    "slept",
    "sliceable",
    "sliced",
    "slicer",
    "slicing",
    "slick",
    "slider",
    "slideshow",
    "sliding",
    "slighted",
    "slighting",
    "slightly",
    "slimness",
    "slimy",
    "slinging",
    "slingshot",
    "slinky",
    "slip",
    "slit",
    "sliver",
    "slobbery",
    "slogan",
    "sloped",
    "sloping",
    "sloppily",
    "sloppy",
    "slot",
    "slouching",
    "slouchy",
    "sludge",
    "slug",
    "slum",
    "slurp",
    "slush",
    "sly",
    "small",
    "smartly",
    "smartness",
    "smasher",
    "smashing",
    "smashup",
    "smell",
    "smelting",
    "smile",
    "smilingly",
    "smirk",
    "smite",
    "smith",
    "smitten",
    "smock",
    "smog",
    "smoked",
    "smokeless",
    "smokiness",
    "smoking",
    "smoky",
    "smolder",
    "smooth",
    "smother",
    "smudge",
    "smudgy",
    "smuggler",
    "smuggling",
    "smugly",
    "smugness",
    "snack",
    "snagged",
    "snaking",
    "snap",
    "snare",
    "snarl",
    "snazzy",
    "sneak",
    "sneer",
    "sneeze",
    "sneezing",
    "snide",
    "sniff",
    "snippet",
    "snipping",
    "snitch",
    "snooper",
    "snooze",
    "snore",
    "snoring",
    "snorkel",
    "snort",
    "snout",
    "snowbird",
    "snowboard",
    "snowbound",
    "snowcap",
    "snowdrift",
    "snowdrop",
    "snowfall",
    "snowfield",
    "snowflake",
    "snowiness",
    "snowless",
    "snowman",
    "snowplow",
    "snowshoe",
    "snowstorm",
    "snowsuit",
    "snowy",
    "snub",
    "snuff",
    "snuggle",
    "snugly",
    "snugness",
    "speak",
    "spearfish",
    "spearhead",
    "spearman",
    "spearmint",
    "species",
    "specimen",
    "specked",
    "speckled",
    "specks",
    "spectacle",
    "spectator",
    "spectrum",
    "speculate",
    "speech",
    "speed",
    "spellbind",
    "speller",
    "spelling",
    "spendable",
    "spender",
    "spending",
    "spent",
    "spew",
    "sphere",
    "spherical",
    "sphinx",
    "spider",
    "spied",
    "spiffy",
    "spill",
    "spilt",
    "spinach",
    "spinal",
    "spindle",
    "spinner",
    "spinning",
    "spinout",
    "spinster",
    "spiny",
    "spiral",
    "spirited",
    "spiritism",
    "spirits",
    "spiritual",
    "splashed",
    "splashing",
    "splashy",
    "splatter",
    "spleen",
    "splendid",
    "splendor",
    "splice",
    "splicing",
    "splinter",
    "splotchy",
    "splurge",
    "spoilage",
    "spoiled",
    "spoiler",
    "spoiling",
    "spoils",
    "spoken",
    "spokesman",
    "sponge",
    "spongy",
    "sponsor",
    "spoof",
    "spookily",
    "spooky",
    "spool",
    "spoon",
    "spore",
    "sporting",
    "sports",
    "sporty",
    "spotless",
    "spotlight",
    "spotted",
    "spotter",
    "spotting",
    "spotty",
    "spousal",
    "spouse",
    "spout",
    "sprain",
    "sprang",
    "sprawl",
    "spray",
    "spree",
    "sprig",
    "spring",
    "sprinkled",
    "sprinkler",
    "sprint",
    "sprite",
    "sprout",
    "spruce",
    "sprung",
    "spry",
    "spud",
    "spur",
    "sputter",
    "spyglass",
    "squabble",
    "squad",
    "squall",
    "squander",
    "squash",
    "squatted",
    "squatter",
    "squatting",
    "squeak",
    "squealer",
    "squealing",
    "squeamish",
    "squeegee",
    "squeeze",
    "squeezing",
    "squid",
    "squiggle",
    "squiggly",
    "squint",
    "squire",
    "squirt",
    "squishier",
    "squishy",
    "stability",
    "stabilize",
    "stable",
    "stack",
    "stadium",
    "staff",
    "stage",
    "staging",
    "stagnant",
    "stagnate",
    "stainable",
    "stained",
    "staining",
    "stainless",
    "stalemate",
    "staleness",
    "stalling",
    "stallion",
    "stamina",
    "stammer",
    "stamp",
    "stand",
    "stank",
    "staple",
    "stapling",
    "starboard",
    "starch",
    "stardom",
    "stardust",
    "starfish",
    "stargazer",
    "staring",
    "stark",
    "starless",
    "starlet",
    "starlight",
    "starlit",
    "starring",
    "starry",
    "starship",
    "starter",
    "starting",
    "startle",
    "startling",
    "startup",
    "starved",
    "starving",
    "stash",
    "state",
    "static",
    "statistic",
    "statue",
    "stature",
    "status",
    "statute",
    "statutory",
    "staunch",
    "stays",
    "steadfast",
    "steadier",
    "steadily",
    "steadying",
    "steam",
    "steed",
    "steep",
    "steerable",
    "steering",
    "steersman",
    "stegosaur",
    "stellar",
    "stem",
    "stench",
    "stencil",
    "step",
    "stereo",
    "sterile",
    "sterility",
    "sterilize",
    "sterling",
    "sternness",
    "sternum",
    "stew",
    "stick",
    "stiffen",
    "stiffly",
    "stiffness",
    "stifle",
    "stifling",
    "stillness",
    "stilt",
    "stimulant",
    "stimulate",
    "stimuli",
    "stimulus",
    "stinger",
    "stingily",
    "stinging",
    "stingray",
    "stingy",
    "stinking",
    "stinky",
    "stipend",
    "stipulate",
    "stir",
    "stitch",
    "stock",
    "stoic",
    "stoke",
    "stole",
    "stomp",
    "stonewall",
    "stoneware",
    "stonework",
    "stoning",
    "stony",
    "stood",
    "stooge",
    "stool",
    "stoop",
    "stoplight",
    "stoppable",
    "stoppage",
    "stopped",
    "stopper",
    "stopping",
    "stopwatch",
    "storable",
    "storage",
    "storeroom",
    "storewide",
    "storm",
    "stout",
    "stove",
    "stowaway",
    "stowing",
    "straddle",
    "straggler",
    "strained",
    "strainer",
    "straining",
    "strangely",
    "stranger",
    "strangle",
    "strategic",
    "strategy",
    "stratus",
    "straw",
    "stray",
    "streak",
    "stream",
    "street",
    "strength",
    "strenuous",
    "strep",
    "stress",
    "stretch",
    "strewn",
    "stricken",
    "strict",
    "stride",
    "strife",
    "strike",
    "striking",
    "strive",
    "striving",
    "strobe",
    "strode",
    "stroller",
    "strongbox",
    "strongly",
    "strongman",
    "struck",
    "structure",
    "strudel",
    "struggle",
    "strum",
    "strung",
    "strut",
    "stubbed",
    "stubble",
    "stubbly",
    "stubborn",
    "stucco",
    "stuck",
    "student",
    "studied",
    "studio",
    "study",
    "stuffed",
    "stuffing",
    "stuffy",
    "stumble",
    "stumbling",
    "stump",
    "stung",
    "stunned",
    "stunner",
    "stunning",
    "stunt",
    "stupor",
    "sturdily",
    "sturdy",
    "styling",
    "stylishly",
    "stylist",
    "stylized",
    "stylus",
    "suave",
    "subarctic",
    "subatomic",
    "subdivide",
    "subdued",
    "subduing",
    "subfloor",
    "subgroup",
    "subheader",
    "subject",
    "sublease",
    "sublet",
    "sublevel",
    "sublime",
    "submarine",
    "submerge",
    "submersed",
    "submitter",
    "subpanel",
    "subpar",
    "subplot",
    "subprime",
    "subscribe",
    "subscript",
    "subsector",
    "subside",
    "subsiding",
    "subsidize",
    "subsidy",
    "subsoil",
    "subsonic",
    "substance",
    "subsystem",
    "subtext",
    "subtitle",
    "subtly",
    "subtotal",
    "subtract",
    "subtype",
    "suburb",
    "subway",
    "subwoofer",
    "subzero",
    "succulent",
    "such",
    "suction",
    "sudden",
    "sudoku",
    "suds",
    "sufferer",
    "suffering",
    "suffice",
    "suffix",
    "suffocate",
    "suffrage",
    "sugar",
    "suggest",
    "suing",
    "suitable",
    "suitably",
    "suitcase",
    "suitor",
    "sulfate",
    "sulfide",
    "sulfite",
    "sulfur",
    "sulk",
    "sullen",
    "sulphate",
    "sulphuric",
    "sultry",
    "superbowl",
    "superglue",
    "superhero",
    "superior",
    "superjet",
    "superman",
    "supermom",
    "supernova",
    "supervise",
    "supper",
    "supplier",
    "supply",
    "support",
    "supremacy",
    "supreme",
    "surcharge",
    "surely",
    "sureness",
    "surface",
    "surfacing",
    "surfboard",
    "surfer",
    "surgery",
    "surgical",
    "surging",
    "surname",
    "surpass",
    "surplus",
    "surprise",
    "surreal",
    "surrender",
    "surrogate",
    "surround",
    "survey",
    "survival",
    "survive",
    "surviving",
    "survivor",
    "sushi",
    "suspect",
    "suspend",
    "suspense",
    "sustained",
    "sustainer",
    "swab",
    "swaddling",
    "swagger",
    "swampland",
    "swan",
    "swapping",
    "swarm",
    "sway",
    "swear",
    "sweat",
    "sweep",
    "swell",
    "swept",
    "swerve",
    "swifter",
    "swiftly",
    "swiftness",
    "swimmable",
    "swimmer",
    "swimming",
    "swimsuit",
    "swimwear",
    "swinger",
    "swinging",
    "swipe",
    "swirl",
    "switch",
    "swivel",
    "swizzle",
    "swooned",
    "swoop",
    "swoosh",
    "swore",
    "sworn",
    "swung",
    "sycamore",
    "sympathy",
    "symphonic",
    "symphony",
    "symptom",
    "synapse",
    "syndrome",
    "synergy",
    "synopses",
    "synopsis",
    "synthesis",
    "synthetic",
    "syrup",
    "system",
    "t-shirt",
    "tabasco",
    "tabby",
    "tableful",
    "tables",
    "tablet",
    "tableware",
    "tabloid",
    "tackiness",
    "tacking",
    "tackle",
    "tackling",
    "tacky",
    "taco",
    "tactful",
    "tactical",
    "tactics",
    "tactile",
    "tactless",
    "tadpole",
    "taekwondo",
    "tag",
    "tainted",
    "take",
    "taking",
    "talcum",
    "talisman",
    "tall",
    "talon",
    "tamale",
    "tameness",
    "tamer",
    "tamper",
    "tank",
    "tanned",
    "tannery",
    "tanning",
    "tantrum",
    "tapeless",
    "tapered",
    "tapering",
    "tapestry",
    "tapioca",
    "tapping",
    "taps",
    "tarantula",
    "target",
    "tarmac",
    "tarnish",
    "tarot",
    "tartar",
    "tartly",
    "tartness",
    "task",
    "tassel",
    "taste",
    "tastiness",
    "tasting",
    "tasty",
    "tattered",
    "tattle",
    "tattling",
    "tattoo",
    "taunt",
    "tavern",
    "thank",
    "that",
    "thaw",
    "theater",
    "theatrics",
    "thee",
    "theft",
    "theme",
    "theology",
    "theorize",
    "thermal",
    "thermos",
    "thesaurus",
    "these",
    "thesis",
    "thespian",
    "thicken",
    "thicket",
    "thickness",
    "thieving",
    "thievish",
    "thigh",
    "thimble",
    "thing",
    "think",
    "thinly",
    "thinner",
    "thinness",
    "thinning",
    "thirstily",
    "thirsting",
    "thirsty",
    "thirteen",
    "thirty",
    "thong",
    "thorn",
    "those",
    "thousand",
    "thrash",
    "thread",
    "threaten",
    "threefold",
    "thrift",
    "thrill",
    "thrive",
    "thriving",
    "throat",
    "throbbing",
    "throng",
    "throttle",
    "throwaway",
    "throwback",
    "thrower",
    "throwing",
    "thud",
    "thumb",
    "thumping",
    "thursday",
    "thus",
    "thwarting",
    "thyself",
    "tiara",
    "tibia",
    "tidal",
    "tidbit",
    "tidiness",
    "tidings",
    "tidy",
    "tiger",
    "tighten",
    "tightly",
    "tightness",
    "tightrope",
    "tightwad",
    "tigress",
    "tile",
    "tiling",
    "till",
    "tilt",
    "timid",
    "timing",
    "timothy",
    "tinderbox",
    "tinfoil",
    "tingle",
    "tingling",
    "tingly",
    "tinker",
    "tinkling",
    "tinsel",
    "tinsmith",
    "tint",
    "tinwork",
    "tiny",
    "tipoff",
    "tipped",
    "tipper",
    "tipping",
    "tiptoeing",
    "tiptop",
    "tiring",
    "tissue",
    "trace",
    "tracing",
    "track",
    "traction",
    "tractor",
    "trade",
    "trading",
    "tradition",
    "traffic",
    "tragedy",
    "trailing",
    "trailside",
    "train",
    "traitor",
    "trance",
    "tranquil",
    "transfer",
    "transform",
    "translate",
    "transpire",
    "transport",
    "transpose",
    "trapdoor",
    "trapeze",
    "trapezoid",
    "trapped",
    "trapper",
    "trapping",
    "traps",
    "trash",
    "travel",
    "traverse",
    "travesty",
    "tray",
    "treachery",
    "treading",
    "treadmill",
    "treason",
    "treat",
    "treble",
    "tree",
    "trekker",
    "tremble",
    "trembling",
    "tremor",
    "trench",
    "trend",
    "trespass",
    "triage",
    "trial",
    "triangle",
    "tribesman",
    "tribunal",
    "tribune",
    "tributary",
    "tribute",
    "triceps",
    "trickery",
    "trickily",
    "tricking",
    "trickle",
    "trickster",
    "tricky",
    "tricolor",
    "tricycle",
    "trident",
    "tried",
    "trifle",
    "trifocals",
    "trillion",
    "trilogy",
    "trimester",
    "trimmer",
    "trimming",
    "trimness",
    "trinity",
    "trio",
    "tripod",
    "tripping",
    "triumph",
    "trivial",
    "trodden",
    "trolling",
    "trombone",
    "trophy",
    "tropical",
    "tropics",
    "trouble",
    "troubling",
    "trough",
    "trousers",
    "trout",
    "trowel",
    "truce",
    "truck",
    "truffle",
    "trump",
    "trunks",
    "trustable",
    "trustee",
    "trustful",
    "trusting",
    "trustless",
    "truth",
    "try",
    "tubby",
    "tubeless",
    "tubular",
    "tucking",
    "tuesday",
    "tug",
    "tuition",
    "tulip",
    "tumble",
    "tumbling",
    "tummy",
    "turban",
    "turbine",
    "turbofan",
    "turbojet",
    "turbulent",
    "turf",
    "turkey",
    "turmoil",
    "turret",
    "turtle",
    "tusk",
    "tutor",
    "tutu",
    "tux",
    "tweak",
    "tweed",
    "tweet",
    "tweezers",
    "twelve",
    "twentieth",
    "twenty",
    "twerp",
    "twice",
    "twiddle",
    "twiddling",
    "twig",
    "twilight",
    "twine",
    "twins",
    "twirl",
    "twistable",
    "twisted",
    "twister",
    "twisting",
    "twisty",
    "twitch",
    "twitter",
    "tycoon",
    "tying",
    "tyke",
    "udder",
    "ultimate",
    "ultimatum",
    "ultra",
    "umbilical",
    "umbrella",
    "umpire",
    "unabashed",
    "unable",
    "unadorned",
    "unadvised",
    "unafraid",
    "unaired",
    "unaligned",
    "unaltered",
    "unarmored",
    "unashamed",
    "unaudited",
    "unawake",
    "unaware",
    "unbaked",
    "unbalance",
    "unbeaten",
    "unbend",
    "unbent",
    "unbiased",
    "unbitten",
    "unblended",
    "unblessed",
    "unblock",
    "unbolted",
    "unbounded",
    "unboxed",
    "unbraided",
    "unbridle",
    "unbroken",
    "unbuckled",
    "unbundle",
    "unburned",
    "unbutton",
    "uncanny",
    "uncapped",
    "uncaring",
    "uncertain",
    "unchain",
    "unchanged",
    "uncharted",
    "uncheck",
    "uncivil",
    "unclad",
    "unclaimed",
    "unclamped",
    "unclasp",
    "uncle",
    "unclip",
    "uncloak",
    "unclog",
    "unclothed",
    "uncoated",
    "uncoiled",
    "uncolored",
    "uncombed",
    "uncommon",
    "uncooked",
    "uncork",
    "uncorrupt",
    "uncounted",
    "uncouple",
    "uncouth",
    "uncover",
    "uncross",
    "uncrown",
    "uncrushed",
    "uncured",
    "uncurious",
    "uncurled",
    "uncut",
    "undamaged",
    "undated",
    "undaunted",
    "undead",
    "undecided",
    "undefined",
    "underage",
    "underarm",
    "undercoat",
    "undercook",
    "undercut",
    "underdog",
    "underdone",
    "underfed",
    "underfeed",
    "underfoot",
    "undergo",
    "undergrad",
    "underhand",
    "underline",
    "underling",
    "undermine",
    "undermost",
    "underpaid",
    "underpass",
    "underpay",
    "underrate",
    "undertake",
    "undertone",
    "undertook",
    "undertow",
    "underuse",
    "underwear",
    "underwent",
    "underwire",
    "undesired",
    "undiluted",
    "undivided",
    "undocked",
    "undoing",
    "undone",
    "undrafted",
    "undress",
    "undrilled",
    "undusted",
    "undying",
    "unearned",
    "unearth",
    "unease",
    "uneasily",
    "uneasy",
    "uneatable",
    "uneaten",
    "unedited",
    "unelected",
    "unending",
    "unengaged",
    "unenvied",
    "unequal",
    "unethical",
    "uneven",
    "unexpired",
    "unexposed",
    "unfailing",
    "unfair",
    "unfasten",
    "unfazed",
    "unfeeling",
    "unfiled",
    "unfilled",
    "unfitted",
    "unfitting",
    "unfixable",
    "unfixed",
    "unflawed",
    "unfocused",
    "unfold",
    "unfounded",
    "unframed",
    "unfreeze",
    "unfrosted",
    "unfrozen",
    "unfunded",
    "unglazed",
    "ungloved",
    "unglue",
    "ungodly",
    "ungraded",
    "ungreased",
    "unguarded",
    "unguided",
    "unhappily",
    "unhappy",
    "unharmed",
    "unhealthy",
    "unheard",
    "unhearing",
    "unheated",
    "unhelpful",
    "unhidden",
    "unhinge",
    "unhitched",
    "unholy",
    "unhook",
    "unicorn",
    "unicycle",
    "unified",
    "unifier",
    "uniformed",
    "uniformly",
    "unify",
    "unimpeded",
    "uninjured",
    "uninstall",
    "uninsured",
    "uninvited",
    "union",
    "uniquely",
    "unisexual",
    "unison",
    "unissued",
    "unit",
    "universal",
    "universe",
    "unjustly",
    "unkempt",
    "unkind",
    "unknotted",
    "unknowing",
    "unknown",
    "unlaced",
    "unlatch",
    "unlawful",
    "unleaded",
    "unlearned",
    "unleash",
    "unless",
    "unleveled",
    "unlighted",
    "unlikable",
    "unlimited",
    "unlined",
    "unlinked",
    "unlisted",
    "unlit",
    "unlivable",
    "unloaded",
    "unloader",
    "unlocked",
    "unlocking",
    "unlovable",
    "unloved",
    "unlovely",
    "unloving",
    "unluckily",
    "unlucky",
    "unmade",
    "unmanaged",
    "unmanned",
    "unmapped",
    "unmarked",
    "unmasked",
    "unmasking",
    "unmatched",
    "unmindful",
    "unmixable",
    "unmixed",
    "unmolded",
    "unmoral",
    "unmovable",
    "unmoved",
    "unmoving",
    "unnamable",
    "unnamed",
    "unnatural",
    "unneeded",
    "unnerve",
    "unnerving",
    "unnoticed",
    "unopened",
    "unopposed",
    "unpack",
    "unpadded",
    "unpaid",
    "unpainted",
    "unpaired",
    "unpaved",
    "unpeeled",
    "unpicked",
    "unpiloted",
    "unpinned",
    "unplanned",
    "unplanted",
    "unpleased",
    "unpledged",
    "unplowed",
    "unplug",
    "unpopular",
    "unproven",
    "unquote",
    "unranked",
    "unrated",
    "unraveled",
    "unreached",
    "unread",
    "unreal",
    "unreeling",
    "unrefined",
    "unrelated",
    "unrented",
    "unrest",
    "unretired",
    "unrevised",
    "unrigged",
    "unripe",
    "unrivaled",
    "unroasted",
    "unrobed",
    "unroll",
    "unruffled",
    "unruly",
    "unrushed",
    "unsaddle",
    "unsafe",
    "unsaid",
    "unsalted",
    "unsaved",
    "unsavory",
    "unscathed",
    "unscented",
    "unscrew",
    "unsealed",
    "unseated",
    "unsecured",
    "unseeing",
    "unseemly",
    "unseen",
    "unselect",
    "unselfish",
    "unsent",
    "unsettled",
    "unshackle",
    "unshaken",
    "unshaved",
    "unshaven",
    "unsheathe",
    "unshipped",
    "unsightly",
    "unsigned",
    "unskilled",
    "unsliced",
    "unsmooth",
    "unsnap",
    "unsocial",
    "unsoiled",
    "unsold",
    "unsolved",
    "unsorted",
    "unspoiled",
    "unspoken",
    "unstable",
    "unstaffed",
    "unstamped",
    "unsteady",
    "unsterile",
    "unstirred",
    "unstitch",
    "unstopped",
    "unstuck",
    "unstuffed",
    "unstylish",
    "unsubtle",
    "unsubtly",
    "unsuited",
    "unsure",
    "unsworn",
    "untagged",
    "untainted",
    "untaken",
    "untamed",
    "untangled",
    "untapped",
    "untaxed",
    "unthawed",
    "unthread",
    "untidy",
    "untie",
    "until",
    "untimed",
    "untimely",
    "untitled",
    "untoasted",
    "untold",
    "untouched",
    "untracked",
    "untrained",
    "untreated",
    "untried",
    "untrimmed",
    "untrue",
    "untruth",
    "unturned",
    "untwist",
    "untying",
    "unusable",
    "unused",
    "unusual",
    "unvalued",
    "unvaried",
    "unvarying",
    "unveiled",
    "unveiling",
    "unvented",
    "unviable",
    "unvisited",
    "unvocal",
    "unwanted",
    "unwarlike",
    "unwary",
    "unwashed",
    "unwatched",
    "unweave",
    "unwed",
    "unwelcome",
    "unwell",
    "unwieldy",
    "unwilling",
    "unwind",
    "unwired",
    "unwitting",
    "unwomanly",
    "unworldly",
    "unworn",
    "unworried",
    "unworthy",
    "unwound",
    "unwoven",
    "unwrapped",
    "unwritten",
    "unzip",
    "upbeat",
    "upchuck",
    "upcoming",
    "upcountry",
    "update",
    "upfront",
    "upgrade",
    "upheaval",
    "upheld",
    "uphill",
    "uphold",
    "uplifted",
    "uplifting",
    "upload",
    "upon",
    "upper",
    "upright",
    "uprising",
    "upriver",
    "uproar",
    "uproot",
    "upscale",
    "upside",
    "upstage",
    "upstairs",
    "upstart",
    "upstate",
    "upstream",
    "upstroke",
    "upswing",
    "uptake",
    "uptight",
    "uptown",
    "upturned",
    "upward",
    "upwind",
    "uranium",
    "urban",
    "urchin",
    "urethane",
    "urgency",
    "urgent",
    "urging",
    "urologist",
    "urology",
    "usable",
    "usage",
    "useable",
    "used",
    "uselessly",
    "user",
    "usher",
    "usual",
    "utensil",
    "utility",
    "utilize",
    "utmost",
    "utopia",
    "utter",
    "vacancy",
    "vacant",
    "vacate",
    "vacation",
    "vagabond",
    "vagrancy",
    "vagrantly",
    "vaguely",
    "vagueness",
    "valiant",
    "valid",
    "valium",
    "valley",
    "valuables",
    "value",
    "vanilla",
    "vanish",
    "vanity",
    "vanquish",
    "vantage",
    "vaporizer",
    "variable",
    "variably",
    "varied",
    "variety",
    "various",
    "varmint",
    "varnish",
    "varsity",
    "varying",
    "vascular",
    "vaseline",
    "vastly",
    "vastness",
    "veal",
    "vegan",
    "veggie",
    "vehicular",
    "velcro",
    "velocity",
    "velvet",
    "vendetta",
    "vending",
    "vendor",
    "veneering",
    "vengeful",
    "venomous",
    "ventricle",
    "venture",
    "venue",
    "venus",
    "verbalize",
    "verbally",
    "verbose",
    "verdict",
    "verify",
    "verse",
    "version",
    "versus",
    "vertebrae",
    "vertical",
    "vertigo",
    "very",
    "vessel",
    "vest",
    "veteran",
    "veto",
    "vexingly",
    "viability",
    "viable",
    "vibes",
    "vice",
    "vicinity",
    "victory",
    "video",
    "viewable",
    "viewer",
    "viewing",
    "viewless",
    "viewpoint",
    "vigorous",
    "village",
    "villain",
    "vindicate",
    "vineyard",
    "vintage",
    "violate",
    "violation",
    "violator",
    "violet",
    "violin",
    "viper",
    "viral",
    "virtual",
    "virtuous",
    "virus",
    "visa",
    "viscosity",
    "viscous",
    "viselike",
    "visible",
    "visibly",
    "vision",
    "visiting",
    "visitor",
    "visor",
    "vista",
    "vitality",
    "vitalize",
    "vitally",
    "vitamins",
    "vivacious",
    "vividly",
    "vividness",
    "vixen",
    "vocalist",
    "vocalize",
    "vocally",
    "vocation",
    "voice",
    "voicing",
    "void",
    "volatile",
    "volley",
    "voltage",
    "volumes",
    "voter",
    "voting",
    "voucher",
    "vowed",
    "vowel",
    "voyage",
    "wackiness",
    "wad",
    "wafer",
    "waffle",
    "waged",
    "wager",
    "wages",
    "waggle",
    "wagon",
    "wake",
    "waking",
    "walk",
    "walmart",
    "walnut",
    "walrus",
    "waltz",
    "wand",
    "wannabe",
    "wanted",
    "wanting",
    "wasabi",
    "washable",
    "washbasin",
    "washboard",
    "washbowl",
    "washcloth",
    "washday",
    "washed",
    "washer",
    "washhouse",
    "washing",
    "washout",
    "washroom",
    "washstand",
    "washtub",
    "wasp",
    "wasting",
    "watch",
    "water",
    "waviness",
    "waving",
    "wavy",
    "whacking",
    "whacky",
    "wham",
    "wharf",
    "wheat",
    "whenever",
    "whiff",
    "whimsical",
    "whinny",
    "whiny",
    "whisking",
    "whoever",
    "whole",
    "whomever",
    "whoopee",
    "whooping",
    "whoops",
    "why",
    "wick",
    "widely",
    "widen",
    "widget",
    "widow",
    "width",
    "wieldable",
    "wielder",
    "wife",
    "wifi",
    "wikipedia",
    "wildcard",
    "wildcat",
    "wilder",
    "wildfire",
    "wildfowl",
    "wildland",
    "wildlife",
    "wildly",
    "wildness",
    "willed",
    "willfully",
    "willing",
    "willow",
    "willpower",
    "wilt",
    "wimp",
    "wince",
    "wincing",
    "wind",
    "wing",
    "winking",
    "winner",
    "winnings",
    "winter",
    "wipe",
    "wired",
    "wireless",
    "wiring",
    "wiry",
    "wisdom",
    "wise",
    "wish",
    "wisplike",
    "wispy",
    "wistful",
    "wizard",
    "wobble",
    "wobbling",
    "wobbly",
    "wok",
    "wolf",
    "wolverine",
    "womanhood",
    "womankind",
    "womanless",
    "womanlike",
    "womanly",
    "womb",
    "woof",
    "wooing",
    "wool",
    "woozy",
    "word",
    "work",
    "worried",
    "worrier",
    "worrisome",
    "worry",
    "worsening",
    "worshiper",
    "worst",
    "wound",
    "woven",
    "wow",
    "wrangle",
    "wrath",
    "wreath",
    "wreckage",
    "wrecker",
    "wrecking",
    "wrench",
    "wriggle",
    "wriggly",
    "wrinkle",
    "wrinkly",
    "wrist",
    "writing",
    "written",
    "wrongdoer",
    "wronged",
    "wrongful",
    "wrongly",
    "wrongness",
    "wrought",
    "xbox",
    "xerox",
    "yahoo",
    "yam",
    "yanking",
    "yapping",
    "yard",
    "yarn",
    "yeah",
    "yearbook",
    "yearling",
    "yearly",
    "yearning",
    "yeast",
    "yelling",
    "yelp",
    "yen",
    "yesterday",
    "yiddish",
    "yield",
    "yin",
    "yippee",
    "yo-yo",
    "yodel",
    "yoga",
    "yogurt",
    "yonder",
    "yoyo",
    "yummy",
    "zap",
    "zealous",
    "zebra",
    "zen",
    "zeppelin",
    "zero",
    "zestfully",
    "zesty",
    "zigzagged",
    "zipfile",
    "zipping",
    "zippy",
    "zips",
    "zit",
    "zodiac",
    "zombie",
    "zone",
    "zoning",
    "zookeeper",
    "zoologist",
    "zoology",
    "zoom"
  ];
  return wordlist$1;
}
var hasRequiredNewSecureWords;
function requireNewSecureWords() {
  if (hasRequiredNewSecureWords) return newSecureWords;
  hasRequiredNewSecureWords = 1;
  Object.defineProperty(newSecureWords, "__esModule", { value: true });
  newSecureWords.newSecureWords = void 0;
  const getSecureRandom_1 = requireGetSecureRandom();
  const wordlist_1 = requireWordlist$1();
  async function newSecureWords$1(size = 6) {
    let words = [];
    for (let i = 0; i < size; i++) {
      words.push(wordlist_1.wordlist[await (0, getSecureRandom_1.getSecureRandomNumber)(0, wordlist_1.wordlist.length)]);
    }
    return words;
  }
  newSecureWords.newSecureWords = newSecureWords$1;
  return newSecureWords;
}
var newSecurePassphrase = {};
var hasRequiredNewSecurePassphrase;
function requireNewSecurePassphrase() {
  if (hasRequiredNewSecurePassphrase) return newSecurePassphrase;
  hasRequiredNewSecurePassphrase = 1;
  Object.defineProperty(newSecurePassphrase, "__esModule", { value: true });
  newSecurePassphrase.newSecurePassphrase = void 0;
  const __1 = requireDist$6();
  async function newSecurePassphrase$1(size = 6) {
    return (await (0, __1.newSecureWords)(size)).join("-");
  }
  newSecurePassphrase.newSecurePassphrase = newSecurePassphrase$1;
  return newSecurePassphrase;
}
var mnemonic = {};
var binary = {};
var hasRequiredBinary;
function requireBinary() {
  if (hasRequiredBinary) return binary;
  hasRequiredBinary = 1;
  Object.defineProperty(binary, "__esModule", { value: true });
  binary.bitsToBytes = binary.bytesToBits = binary.lpad = void 0;
  function lpad(str, padString, length) {
    while (str.length < length) {
      str = padString + str;
    }
    return str;
  }
  binary.lpad = lpad;
  function bytesToBits(bytes) {
    let res = "";
    for (let i = 0; i < bytes.length; i++) {
      let x = bytes.at(i);
      res += lpad(x.toString(2), "0", 8);
    }
    return res;
  }
  binary.bytesToBits = bytesToBits;
  function bitsToBytes(src2) {
    if (src2.length % 8 !== 0) {
      throw Error("Uneven bits");
    }
    let res = [];
    while (src2.length > 0) {
      res.push(parseInt(src2.slice(0, 8), 2));
      src2 = src2.slice(8);
    }
    return Buffer.from(res);
  }
  binary.bitsToBytes = bitsToBytes;
  return binary;
}
var wordlist = {};
var hasRequiredWordlist;
function requireWordlist() {
  if (hasRequiredWordlist) return wordlist;
  hasRequiredWordlist = 1;
  Object.defineProperty(wordlist, "__esModule", { value: true });
  wordlist.wordlist = void 0;
  const EN = [
    "abandon",
    "ability",
    "able",
    "about",
    "above",
    "absent",
    "absorb",
    "abstract",
    "absurd",
    "abuse",
    "access",
    "accident",
    "account",
    "accuse",
    "achieve",
    "acid",
    "acoustic",
    "acquire",
    "across",
    "act",
    "action",
    "actor",
    "actress",
    "actual",
    "adapt",
    "add",
    "addict",
    "address",
    "adjust",
    "admit",
    "adult",
    "advance",
    "advice",
    "aerobic",
    "affair",
    "afford",
    "afraid",
    "again",
    "age",
    "agent",
    "agree",
    "ahead",
    "aim",
    "air",
    "airport",
    "aisle",
    "alarm",
    "album",
    "alcohol",
    "alert",
    "alien",
    "all",
    "alley",
    "allow",
    "almost",
    "alone",
    "alpha",
    "already",
    "also",
    "alter",
    "always",
    "amateur",
    "amazing",
    "among",
    "amount",
    "amused",
    "analyst",
    "anchor",
    "ancient",
    "anger",
    "angle",
    "angry",
    "animal",
    "ankle",
    "announce",
    "annual",
    "another",
    "answer",
    "antenna",
    "antique",
    "anxiety",
    "any",
    "apart",
    "apology",
    "appear",
    "apple",
    "approve",
    "april",
    "arch",
    "arctic",
    "area",
    "arena",
    "argue",
    "arm",
    "armed",
    "armor",
    "army",
    "around",
    "arrange",
    "arrest",
    "arrive",
    "arrow",
    "art",
    "artefact",
    "artist",
    "artwork",
    "ask",
    "aspect",
    "assault",
    "asset",
    "assist",
    "assume",
    "asthma",
    "athlete",
    "atom",
    "attack",
    "attend",
    "attitude",
    "attract",
    "auction",
    "audit",
    "august",
    "aunt",
    "author",
    "auto",
    "autumn",
    "average",
    "avocado",
    "avoid",
    "awake",
    "aware",
    "away",
    "awesome",
    "awful",
    "awkward",
    "axis",
    "baby",
    "bachelor",
    "bacon",
    "badge",
    "bag",
    "balance",
    "balcony",
    "ball",
    "bamboo",
    "banana",
    "banner",
    "bar",
    "barely",
    "bargain",
    "barrel",
    "base",
    "basic",
    "basket",
    "battle",
    "beach",
    "bean",
    "beauty",
    "because",
    "become",
    "beef",
    "before",
    "begin",
    "behave",
    "behind",
    "believe",
    "below",
    "belt",
    "bench",
    "benefit",
    "best",
    "betray",
    "better",
    "between",
    "beyond",
    "bicycle",
    "bid",
    "bike",
    "bind",
    "biology",
    "bird",
    "birth",
    "bitter",
    "black",
    "blade",
    "blame",
    "blanket",
    "blast",
    "bleak",
    "bless",
    "blind",
    "blood",
    "blossom",
    "blouse",
    "blue",
    "blur",
    "blush",
    "board",
    "boat",
    "body",
    "boil",
    "bomb",
    "bone",
    "bonus",
    "book",
    "boost",
    "border",
    "boring",
    "borrow",
    "boss",
    "bottom",
    "bounce",
    "box",
    "boy",
    "bracket",
    "brain",
    "brand",
    "brass",
    "brave",
    "bread",
    "breeze",
    "brick",
    "bridge",
    "brief",
    "bright",
    "bring",
    "brisk",
    "broccoli",
    "broken",
    "bronze",
    "broom",
    "brother",
    "brown",
    "brush",
    "bubble",
    "buddy",
    "budget",
    "buffalo",
    "build",
    "bulb",
    "bulk",
    "bullet",
    "bundle",
    "bunker",
    "burden",
    "burger",
    "burst",
    "bus",
    "business",
    "busy",
    "butter",
    "buyer",
    "buzz",
    "cabbage",
    "cabin",
    "cable",
    "cactus",
    "cage",
    "cake",
    "call",
    "calm",
    "camera",
    "camp",
    "can",
    "canal",
    "cancel",
    "candy",
    "cannon",
    "canoe",
    "canvas",
    "canyon",
    "capable",
    "capital",
    "captain",
    "car",
    "carbon",
    "card",
    "cargo",
    "carpet",
    "carry",
    "cart",
    "case",
    "cash",
    "casino",
    "castle",
    "casual",
    "cat",
    "catalog",
    "catch",
    "category",
    "cattle",
    "caught",
    "cause",
    "caution",
    "cave",
    "ceiling",
    "celery",
    "cement",
    "census",
    "century",
    "cereal",
    "certain",
    "chair",
    "chalk",
    "champion",
    "change",
    "chaos",
    "chapter",
    "charge",
    "chase",
    "chat",
    "cheap",
    "check",
    "cheese",
    "chef",
    "cherry",
    "chest",
    "chicken",
    "chief",
    "child",
    "chimney",
    "choice",
    "choose",
    "chronic",
    "chuckle",
    "chunk",
    "churn",
    "cigar",
    "cinnamon",
    "circle",
    "citizen",
    "city",
    "civil",
    "claim",
    "clap",
    "clarify",
    "claw",
    "clay",
    "clean",
    "clerk",
    "clever",
    "click",
    "client",
    "cliff",
    "climb",
    "clinic",
    "clip",
    "clock",
    "clog",
    "close",
    "cloth",
    "cloud",
    "clown",
    "club",
    "clump",
    "cluster",
    "clutch",
    "coach",
    "coast",
    "coconut",
    "code",
    "coffee",
    "coil",
    "coin",
    "collect",
    "color",
    "column",
    "combine",
    "come",
    "comfort",
    "comic",
    "common",
    "company",
    "concert",
    "conduct",
    "confirm",
    "congress",
    "connect",
    "consider",
    "control",
    "convince",
    "cook",
    "cool",
    "copper",
    "copy",
    "coral",
    "core",
    "corn",
    "correct",
    "cost",
    "cotton",
    "couch",
    "country",
    "couple",
    "course",
    "cousin",
    "cover",
    "coyote",
    "crack",
    "cradle",
    "craft",
    "cram",
    "crane",
    "crash",
    "crater",
    "crawl",
    "crazy",
    "cream",
    "credit",
    "creek",
    "crew",
    "cricket",
    "crime",
    "crisp",
    "critic",
    "crop",
    "cross",
    "crouch",
    "crowd",
    "crucial",
    "cruel",
    "cruise",
    "crumble",
    "crunch",
    "crush",
    "cry",
    "crystal",
    "cube",
    "culture",
    "cup",
    "cupboard",
    "curious",
    "current",
    "curtain",
    "curve",
    "cushion",
    "custom",
    "cute",
    "cycle",
    "dad",
    "damage",
    "damp",
    "dance",
    "danger",
    "daring",
    "dash",
    "daughter",
    "dawn",
    "day",
    "deal",
    "debate",
    "debris",
    "decade",
    "december",
    "decide",
    "decline",
    "decorate",
    "decrease",
    "deer",
    "defense",
    "define",
    "defy",
    "degree",
    "delay",
    "deliver",
    "demand",
    "demise",
    "denial",
    "dentist",
    "deny",
    "depart",
    "depend",
    "deposit",
    "depth",
    "deputy",
    "derive",
    "describe",
    "desert",
    "design",
    "desk",
    "despair",
    "destroy",
    "detail",
    "detect",
    "develop",
    "device",
    "devote",
    "diagram",
    "dial",
    "diamond",
    "diary",
    "dice",
    "diesel",
    "diet",
    "differ",
    "digital",
    "dignity",
    "dilemma",
    "dinner",
    "dinosaur",
    "direct",
    "dirt",
    "disagree",
    "discover",
    "disease",
    "dish",
    "dismiss",
    "disorder",
    "display",
    "distance",
    "divert",
    "divide",
    "divorce",
    "dizzy",
    "doctor",
    "document",
    "dog",
    "doll",
    "dolphin",
    "domain",
    "donate",
    "donkey",
    "donor",
    "door",
    "dose",
    "double",
    "dove",
    "draft",
    "dragon",
    "drama",
    "drastic",
    "draw",
    "dream",
    "dress",
    "drift",
    "drill",
    "drink",
    "drip",
    "drive",
    "drop",
    "drum",
    "dry",
    "duck",
    "dumb",
    "dune",
    "during",
    "dust",
    "dutch",
    "duty",
    "dwarf",
    "dynamic",
    "eager",
    "eagle",
    "early",
    "earn",
    "earth",
    "easily",
    "east",
    "easy",
    "echo",
    "ecology",
    "economy",
    "edge",
    "edit",
    "educate",
    "effort",
    "egg",
    "eight",
    "either",
    "elbow",
    "elder",
    "electric",
    "elegant",
    "element",
    "elephant",
    "elevator",
    "elite",
    "else",
    "embark",
    "embody",
    "embrace",
    "emerge",
    "emotion",
    "employ",
    "empower",
    "empty",
    "enable",
    "enact",
    "end",
    "endless",
    "endorse",
    "enemy",
    "energy",
    "enforce",
    "engage",
    "engine",
    "enhance",
    "enjoy",
    "enlist",
    "enough",
    "enrich",
    "enroll",
    "ensure",
    "enter",
    "entire",
    "entry",
    "envelope",
    "episode",
    "equal",
    "equip",
    "era",
    "erase",
    "erode",
    "erosion",
    "error",
    "erupt",
    "escape",
    "essay",
    "essence",
    "estate",
    "eternal",
    "ethics",
    "evidence",
    "evil",
    "evoke",
    "evolve",
    "exact",
    "example",
    "excess",
    "exchange",
    "excite",
    "exclude",
    "excuse",
    "execute",
    "exercise",
    "exhaust",
    "exhibit",
    "exile",
    "exist",
    "exit",
    "exotic",
    "expand",
    "expect",
    "expire",
    "explain",
    "expose",
    "express",
    "extend",
    "extra",
    "eye",
    "eyebrow",
    "fabric",
    "face",
    "faculty",
    "fade",
    "faint",
    "faith",
    "fall",
    "false",
    "fame",
    "family",
    "famous",
    "fan",
    "fancy",
    "fantasy",
    "farm",
    "fashion",
    "fat",
    "fatal",
    "father",
    "fatigue",
    "fault",
    "favorite",
    "feature",
    "february",
    "federal",
    "fee",
    "feed",
    "feel",
    "female",
    "fence",
    "festival",
    "fetch",
    "fever",
    "few",
    "fiber",
    "fiction",
    "field",
    "figure",
    "file",
    "film",
    "filter",
    "final",
    "find",
    "fine",
    "finger",
    "finish",
    "fire",
    "firm",
    "first",
    "fiscal",
    "fish",
    "fit",
    "fitness",
    "fix",
    "flag",
    "flame",
    "flash",
    "flat",
    "flavor",
    "flee",
    "flight",
    "flip",
    "float",
    "flock",
    "floor",
    "flower",
    "fluid",
    "flush",
    "fly",
    "foam",
    "focus",
    "fog",
    "foil",
    "fold",
    "follow",
    "food",
    "foot",
    "force",
    "forest",
    "forget",
    "fork",
    "fortune",
    "forum",
    "forward",
    "fossil",
    "foster",
    "found",
    "fox",
    "fragile",
    "frame",
    "frequent",
    "fresh",
    "friend",
    "fringe",
    "frog",
    "front",
    "frost",
    "frown",
    "frozen",
    "fruit",
    "fuel",
    "fun",
    "funny",
    "furnace",
    "fury",
    "future",
    "gadget",
    "gain",
    "galaxy",
    "gallery",
    "game",
    "gap",
    "garage",
    "garbage",
    "garden",
    "garlic",
    "garment",
    "gas",
    "gasp",
    "gate",
    "gather",
    "gauge",
    "gaze",
    "general",
    "genius",
    "genre",
    "gentle",
    "genuine",
    "gesture",
    "ghost",
    "giant",
    "gift",
    "giggle",
    "ginger",
    "giraffe",
    "girl",
    "give",
    "glad",
    "glance",
    "glare",
    "glass",
    "glide",
    "glimpse",
    "globe",
    "gloom",
    "glory",
    "glove",
    "glow",
    "glue",
    "goat",
    "goddess",
    "gold",
    "good",
    "goose",
    "gorilla",
    "gospel",
    "gossip",
    "govern",
    "gown",
    "grab",
    "grace",
    "grain",
    "grant",
    "grape",
    "grass",
    "gravity",
    "great",
    "green",
    "grid",
    "grief",
    "grit",
    "grocery",
    "group",
    "grow",
    "grunt",
    "guard",
    "guess",
    "guide",
    "guilt",
    "guitar",
    "gun",
    "gym",
    "habit",
    "hair",
    "half",
    "hammer",
    "hamster",
    "hand",
    "happy",
    "harbor",
    "hard",
    "harsh",
    "harvest",
    "hat",
    "have",
    "hawk",
    "hazard",
    "head",
    "health",
    "heart",
    "heavy",
    "hedgehog",
    "height",
    "hello",
    "helmet",
    "help",
    "hen",
    "hero",
    "hidden",
    "high",
    "hill",
    "hint",
    "hip",
    "hire",
    "history",
    "hobby",
    "hockey",
    "hold",
    "hole",
    "holiday",
    "hollow",
    "home",
    "honey",
    "hood",
    "hope",
    "horn",
    "horror",
    "horse",
    "hospital",
    "host",
    "hotel",
    "hour",
    "hover",
    "hub",
    "huge",
    "human",
    "humble",
    "humor",
    "hundred",
    "hungry",
    "hunt",
    "hurdle",
    "hurry",
    "hurt",
    "husband",
    "hybrid",
    "ice",
    "icon",
    "idea",
    "identify",
    "idle",
    "ignore",
    "ill",
    "illegal",
    "illness",
    "image",
    "imitate",
    "immense",
    "immune",
    "impact",
    "impose",
    "improve",
    "impulse",
    "inch",
    "include",
    "income",
    "increase",
    "index",
    "indicate",
    "indoor",
    "industry",
    "infant",
    "inflict",
    "inform",
    "inhale",
    "inherit",
    "initial",
    "inject",
    "injury",
    "inmate",
    "inner",
    "innocent",
    "input",
    "inquiry",
    "insane",
    "insect",
    "inside",
    "inspire",
    "install",
    "intact",
    "interest",
    "into",
    "invest",
    "invite",
    "involve",
    "iron",
    "island",
    "isolate",
    "issue",
    "item",
    "ivory",
    "jacket",
    "jaguar",
    "jar",
    "jazz",
    "jealous",
    "jeans",
    "jelly",
    "jewel",
    "job",
    "join",
    "joke",
    "journey",
    "joy",
    "judge",
    "juice",
    "jump",
    "jungle",
    "junior",
    "junk",
    "just",
    "kangaroo",
    "keen",
    "keep",
    "ketchup",
    "key",
    "kick",
    "kid",
    "kidney",
    "kind",
    "kingdom",
    "kiss",
    "kit",
    "kitchen",
    "kite",
    "kitten",
    "kiwi",
    "knee",
    "knife",
    "knock",
    "know",
    "lab",
    "label",
    "labor",
    "ladder",
    "lady",
    "lake",
    "lamp",
    "language",
    "laptop",
    "large",
    "later",
    "latin",
    "laugh",
    "laundry",
    "lava",
    "law",
    "lawn",
    "lawsuit",
    "layer",
    "lazy",
    "leader",
    "leaf",
    "learn",
    "leave",
    "lecture",
    "left",
    "leg",
    "legal",
    "legend",
    "leisure",
    "lemon",
    "lend",
    "length",
    "lens",
    "leopard",
    "lesson",
    "letter",
    "level",
    "liar",
    "liberty",
    "library",
    "license",
    "life",
    "lift",
    "light",
    "like",
    "limb",
    "limit",
    "link",
    "lion",
    "liquid",
    "list",
    "little",
    "live",
    "lizard",
    "load",
    "loan",
    "lobster",
    "local",
    "lock",
    "logic",
    "lonely",
    "long",
    "loop",
    "lottery",
    "loud",
    "lounge",
    "love",
    "loyal",
    "lucky",
    "luggage",
    "lumber",
    "lunar",
    "lunch",
    "luxury",
    "lyrics",
    "machine",
    "mad",
    "magic",
    "magnet",
    "maid",
    "mail",
    "main",
    "major",
    "make",
    "mammal",
    "man",
    "manage",
    "mandate",
    "mango",
    "mansion",
    "manual",
    "maple",
    "marble",
    "march",
    "margin",
    "marine",
    "market",
    "marriage",
    "mask",
    "mass",
    "master",
    "match",
    "material",
    "math",
    "matrix",
    "matter",
    "maximum",
    "maze",
    "meadow",
    "mean",
    "measure",
    "meat",
    "mechanic",
    "medal",
    "media",
    "melody",
    "melt",
    "member",
    "memory",
    "mention",
    "menu",
    "mercy",
    "merge",
    "merit",
    "merry",
    "mesh",
    "message",
    "metal",
    "method",
    "middle",
    "midnight",
    "milk",
    "million",
    "mimic",
    "mind",
    "minimum",
    "minor",
    "minute",
    "miracle",
    "mirror",
    "misery",
    "miss",
    "mistake",
    "mix",
    "mixed",
    "mixture",
    "mobile",
    "model",
    "modify",
    "mom",
    "moment",
    "monitor",
    "monkey",
    "monster",
    "month",
    "moon",
    "moral",
    "more",
    "morning",
    "mosquito",
    "mother",
    "motion",
    "motor",
    "mountain",
    "mouse",
    "move",
    "movie",
    "much",
    "muffin",
    "mule",
    "multiply",
    "muscle",
    "museum",
    "mushroom",
    "music",
    "must",
    "mutual",
    "myself",
    "mystery",
    "myth",
    "naive",
    "name",
    "napkin",
    "narrow",
    "nasty",
    "nation",
    "nature",
    "near",
    "neck",
    "need",
    "negative",
    "neglect",
    "neither",
    "nephew",
    "nerve",
    "nest",
    "net",
    "network",
    "neutral",
    "never",
    "news",
    "next",
    "nice",
    "night",
    "noble",
    "noise",
    "nominee",
    "noodle",
    "normal",
    "north",
    "nose",
    "notable",
    "note",
    "nothing",
    "notice",
    "novel",
    "now",
    "nuclear",
    "number",
    "nurse",
    "nut",
    "oak",
    "obey",
    "object",
    "oblige",
    "obscure",
    "observe",
    "obtain",
    "obvious",
    "occur",
    "ocean",
    "october",
    "odor",
    "off",
    "offer",
    "office",
    "often",
    "oil",
    "okay",
    "old",
    "olive",
    "olympic",
    "omit",
    "once",
    "one",
    "onion",
    "online",
    "only",
    "open",
    "opera",
    "opinion",
    "oppose",
    "option",
    "orange",
    "orbit",
    "orchard",
    "order",
    "ordinary",
    "organ",
    "orient",
    "original",
    "orphan",
    "ostrich",
    "other",
    "outdoor",
    "outer",
    "output",
    "outside",
    "oval",
    "oven",
    "over",
    "own",
    "owner",
    "oxygen",
    "oyster",
    "ozone",
    "pact",
    "paddle",
    "page",
    "pair",
    "palace",
    "palm",
    "panda",
    "panel",
    "panic",
    "panther",
    "paper",
    "parade",
    "parent",
    "park",
    "parrot",
    "party",
    "pass",
    "patch",
    "path",
    "patient",
    "patrol",
    "pattern",
    "pause",
    "pave",
    "payment",
    "peace",
    "peanut",
    "pear",
    "peasant",
    "pelican",
    "pen",
    "penalty",
    "pencil",
    "people",
    "pepper",
    "perfect",
    "permit",
    "person",
    "pet",
    "phone",
    "photo",
    "phrase",
    "physical",
    "piano",
    "picnic",
    "picture",
    "piece",
    "pig",
    "pigeon",
    "pill",
    "pilot",
    "pink",
    "pioneer",
    "pipe",
    "pistol",
    "pitch",
    "pizza",
    "place",
    "planet",
    "plastic",
    "plate",
    "play",
    "please",
    "pledge",
    "pluck",
    "plug",
    "plunge",
    "poem",
    "poet",
    "point",
    "polar",
    "pole",
    "police",
    "pond",
    "pony",
    "pool",
    "popular",
    "portion",
    "position",
    "possible",
    "post",
    "potato",
    "pottery",
    "poverty",
    "powder",
    "power",
    "practice",
    "praise",
    "predict",
    "prefer",
    "prepare",
    "present",
    "pretty",
    "prevent",
    "price",
    "pride",
    "primary",
    "print",
    "priority",
    "prison",
    "private",
    "prize",
    "problem",
    "process",
    "produce",
    "profit",
    "program",
    "project",
    "promote",
    "proof",
    "property",
    "prosper",
    "protect",
    "proud",
    "provide",
    "public",
    "pudding",
    "pull",
    "pulp",
    "pulse",
    "pumpkin",
    "punch",
    "pupil",
    "puppy",
    "purchase",
    "purity",
    "purpose",
    "purse",
    "push",
    "put",
    "puzzle",
    "pyramid",
    "quality",
    "quantum",
    "quarter",
    "question",
    "quick",
    "quit",
    "quiz",
    "quote",
    "rabbit",
    "raccoon",
    "race",
    "rack",
    "radar",
    "radio",
    "rail",
    "rain",
    "raise",
    "rally",
    "ramp",
    "ranch",
    "random",
    "range",
    "rapid",
    "rare",
    "rate",
    "rather",
    "raven",
    "raw",
    "razor",
    "ready",
    "real",
    "reason",
    "rebel",
    "rebuild",
    "recall",
    "receive",
    "recipe",
    "record",
    "recycle",
    "reduce",
    "reflect",
    "reform",
    "refuse",
    "region",
    "regret",
    "regular",
    "reject",
    "relax",
    "release",
    "relief",
    "rely",
    "remain",
    "remember",
    "remind",
    "remove",
    "render",
    "renew",
    "rent",
    "reopen",
    "repair",
    "repeat",
    "replace",
    "report",
    "require",
    "rescue",
    "resemble",
    "resist",
    "resource",
    "response",
    "result",
    "retire",
    "retreat",
    "return",
    "reunion",
    "reveal",
    "review",
    "reward",
    "rhythm",
    "rib",
    "ribbon",
    "rice",
    "rich",
    "ride",
    "ridge",
    "rifle",
    "right",
    "rigid",
    "ring",
    "riot",
    "ripple",
    "risk",
    "ritual",
    "rival",
    "river",
    "road",
    "roast",
    "robot",
    "robust",
    "rocket",
    "romance",
    "roof",
    "rookie",
    "room",
    "rose",
    "rotate",
    "rough",
    "round",
    "route",
    "royal",
    "rubber",
    "rude",
    "rug",
    "rule",
    "run",
    "runway",
    "rural",
    "sad",
    "saddle",
    "sadness",
    "safe",
    "sail",
    "salad",
    "salmon",
    "salon",
    "salt",
    "salute",
    "same",
    "sample",
    "sand",
    "satisfy",
    "satoshi",
    "sauce",
    "sausage",
    "save",
    "say",
    "scale",
    "scan",
    "scare",
    "scatter",
    "scene",
    "scheme",
    "school",
    "science",
    "scissors",
    "scorpion",
    "scout",
    "scrap",
    "screen",
    "script",
    "scrub",
    "sea",
    "search",
    "season",
    "seat",
    "second",
    "secret",
    "section",
    "security",
    "seed",
    "seek",
    "segment",
    "select",
    "sell",
    "seminar",
    "senior",
    "sense",
    "sentence",
    "series",
    "service",
    "session",
    "settle",
    "setup",
    "seven",
    "shadow",
    "shaft",
    "shallow",
    "share",
    "shed",
    "shell",
    "sheriff",
    "shield",
    "shift",
    "shine",
    "ship",
    "shiver",
    "shock",
    "shoe",
    "shoot",
    "shop",
    "short",
    "shoulder",
    "shove",
    "shrimp",
    "shrug",
    "shuffle",
    "shy",
    "sibling",
    "sick",
    "side",
    "siege",
    "sight",
    "sign",
    "silent",
    "silk",
    "silly",
    "silver",
    "similar",
    "simple",
    "since",
    "sing",
    "siren",
    "sister",
    "situate",
    "six",
    "size",
    "skate",
    "sketch",
    "ski",
    "skill",
    "skin",
    "skirt",
    "skull",
    "slab",
    "slam",
    "sleep",
    "slender",
    "slice",
    "slide",
    "slight",
    "slim",
    "slogan",
    "slot",
    "slow",
    "slush",
    "small",
    "smart",
    "smile",
    "smoke",
    "smooth",
    "snack",
    "snake",
    "snap",
    "sniff",
    "snow",
    "soap",
    "soccer",
    "social",
    "sock",
    "soda",
    "soft",
    "solar",
    "soldier",
    "solid",
    "solution",
    "solve",
    "someone",
    "song",
    "soon",
    "sorry",
    "sort",
    "soul",
    "sound",
    "soup",
    "source",
    "south",
    "space",
    "spare",
    "spatial",
    "spawn",
    "speak",
    "special",
    "speed",
    "spell",
    "spend",
    "sphere",
    "spice",
    "spider",
    "spike",
    "spin",
    "spirit",
    "split",
    "spoil",
    "sponsor",
    "spoon",
    "sport",
    "spot",
    "spray",
    "spread",
    "spring",
    "spy",
    "square",
    "squeeze",
    "squirrel",
    "stable",
    "stadium",
    "staff",
    "stage",
    "stairs",
    "stamp",
    "stand",
    "start",
    "state",
    "stay",
    "steak",
    "steel",
    "stem",
    "step",
    "stereo",
    "stick",
    "still",
    "sting",
    "stock",
    "stomach",
    "stone",
    "stool",
    "story",
    "stove",
    "strategy",
    "street",
    "strike",
    "strong",
    "struggle",
    "student",
    "stuff",
    "stumble",
    "style",
    "subject",
    "submit",
    "subway",
    "success",
    "such",
    "sudden",
    "suffer",
    "sugar",
    "suggest",
    "suit",
    "summer",
    "sun",
    "sunny",
    "sunset",
    "super",
    "supply",
    "supreme",
    "sure",
    "surface",
    "surge",
    "surprise",
    "surround",
    "survey",
    "suspect",
    "sustain",
    "swallow",
    "swamp",
    "swap",
    "swarm",
    "swear",
    "sweet",
    "swift",
    "swim",
    "swing",
    "switch",
    "sword",
    "symbol",
    "symptom",
    "syrup",
    "system",
    "table",
    "tackle",
    "tag",
    "tail",
    "talent",
    "talk",
    "tank",
    "tape",
    "target",
    "task",
    "taste",
    "tattoo",
    "taxi",
    "teach",
    "team",
    "tell",
    "ten",
    "tenant",
    "tennis",
    "tent",
    "term",
    "test",
    "text",
    "thank",
    "that",
    "theme",
    "then",
    "theory",
    "there",
    "they",
    "thing",
    "this",
    "thought",
    "three",
    "thrive",
    "throw",
    "thumb",
    "thunder",
    "ticket",
    "tide",
    "tiger",
    "tilt",
    "timber",
    "time",
    "tiny",
    "tip",
    "tired",
    "tissue",
    "title",
    "toast",
    "tobacco",
    "today",
    "toddler",
    "toe",
    "together",
    "toilet",
    "token",
    "tomato",
    "tomorrow",
    "tone",
    "tongue",
    "tonight",
    "tool",
    "tooth",
    "top",
    "topic",
    "topple",
    "torch",
    "tornado",
    "tortoise",
    "toss",
    "total",
    "tourist",
    "toward",
    "tower",
    "town",
    "toy",
    "track",
    "trade",
    "traffic",
    "tragic",
    "train",
    "transfer",
    "trap",
    "trash",
    "travel",
    "tray",
    "treat",
    "tree",
    "trend",
    "trial",
    "tribe",
    "trick",
    "trigger",
    "trim",
    "trip",
    "trophy",
    "trouble",
    "truck",
    "true",
    "truly",
    "trumpet",
    "trust",
    "truth",
    "try",
    "tube",
    "tuition",
    "tumble",
    "tuna",
    "tunnel",
    "turkey",
    "turn",
    "turtle",
    "twelve",
    "twenty",
    "twice",
    "twin",
    "twist",
    "two",
    "type",
    "typical",
    "ugly",
    "umbrella",
    "unable",
    "unaware",
    "uncle",
    "uncover",
    "under",
    "undo",
    "unfair",
    "unfold",
    "unhappy",
    "uniform",
    "unique",
    "unit",
    "universe",
    "unknown",
    "unlock",
    "until",
    "unusual",
    "unveil",
    "update",
    "upgrade",
    "uphold",
    "upon",
    "upper",
    "upset",
    "urban",
    "urge",
    "usage",
    "use",
    "used",
    "useful",
    "useless",
    "usual",
    "utility",
    "vacant",
    "vacuum",
    "vague",
    "valid",
    "valley",
    "valve",
    "van",
    "vanish",
    "vapor",
    "various",
    "vast",
    "vault",
    "vehicle",
    "velvet",
    "vendor",
    "venture",
    "venue",
    "verb",
    "verify",
    "version",
    "very",
    "vessel",
    "veteran",
    "viable",
    "vibrant",
    "vicious",
    "victory",
    "video",
    "view",
    "village",
    "vintage",
    "violin",
    "virtual",
    "virus",
    "visa",
    "visit",
    "visual",
    "vital",
    "vivid",
    "vocal",
    "voice",
    "void",
    "volcano",
    "volume",
    "vote",
    "voyage",
    "wage",
    "wagon",
    "wait",
    "walk",
    "wall",
    "walnut",
    "want",
    "warfare",
    "warm",
    "warrior",
    "wash",
    "wasp",
    "waste",
    "water",
    "wave",
    "way",
    "wealth",
    "weapon",
    "wear",
    "weasel",
    "weather",
    "web",
    "wedding",
    "weekend",
    "weird",
    "welcome",
    "west",
    "wet",
    "whale",
    "what",
    "wheat",
    "wheel",
    "when",
    "where",
    "whip",
    "whisper",
    "wide",
    "width",
    "wife",
    "wild",
    "will",
    "win",
    "window",
    "wine",
    "wing",
    "wink",
    "winner",
    "winter",
    "wire",
    "wisdom",
    "wise",
    "wish",
    "witness",
    "wolf",
    "woman",
    "wonder",
    "wood",
    "wool",
    "word",
    "work",
    "world",
    "worry",
    "worth",
    "wrap",
    "wreck",
    "wrestle",
    "wrist",
    "write",
    "wrong",
    "yard",
    "year",
    "yellow",
    "you",
    "young",
    "youth",
    "zebra",
    "zero",
    "zone",
    "zoo"
  ];
  wordlist.wordlist = EN;
  return wordlist;
}
var hasRequiredMnemonic;
function requireMnemonic() {
  if (hasRequiredMnemonic) return mnemonic;
  hasRequiredMnemonic = 1;
  var __importDefault = mnemonic && mnemonic.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(mnemonic, "__esModule", { value: true });
  mnemonic.mnemonicFromRandomSeed = mnemonic.mnemonicIndexesToBytes = mnemonic.bytesToMnemonics = mnemonic.bytesToMnemonicIndexes = mnemonic.mnemonicNew = mnemonic.mnemonicValidate = mnemonic.mnemonicToHDSeed = mnemonic.mnemonicToWalletKey = mnemonic.mnemonicToPrivateKey = mnemonic.mnemonicToSeed = mnemonic.mnemonicToEntropy = void 0;
  const tweetnacl_1 = __importDefault(requireNaclFast());
  const getSecureRandom_1 = requireGetSecureRandom();
  const hmac_sha512_1 = requireHmac_sha512();
  const pbkdf2_sha512_1 = requirePbkdf2_sha512();
  const binary_1 = requireBinary();
  const wordlist_1 = requireWordlist();
  const PBKDF_ITERATIONS = 1e5;
  async function isPasswordNeeded(mnemonicArray) {
    const passlessEntropy = await mnemonicToEntropy(mnemonicArray);
    return await isPasswordSeed(passlessEntropy) && !await isBasicSeed(passlessEntropy);
  }
  function normalizeMnemonic(src2) {
    return src2.map((v2) => v2.toLowerCase().trim());
  }
  async function isBasicSeed(entropy) {
    const seed = await (0, pbkdf2_sha512_1.pbkdf2_sha512)(entropy, "TON seed version", Math.max(1, Math.floor(PBKDF_ITERATIONS / 256)), 64);
    return seed[0] == 0;
  }
  async function isPasswordSeed(entropy) {
    const seed = await (0, pbkdf2_sha512_1.pbkdf2_sha512)(entropy, "TON fast seed version", 1, 64);
    return seed[0] == 1;
  }
  async function mnemonicToEntropy(mnemonicArray, password) {
    return await (0, hmac_sha512_1.hmac_sha512)(mnemonicArray.join(" "), password && password.length > 0 ? password : "");
  }
  mnemonic.mnemonicToEntropy = mnemonicToEntropy;
  async function mnemonicToSeed(mnemonicArray, seed, password) {
    const entropy = await mnemonicToEntropy(mnemonicArray, password);
    return await (0, pbkdf2_sha512_1.pbkdf2_sha512)(entropy, seed, PBKDF_ITERATIONS, 64);
  }
  mnemonic.mnemonicToSeed = mnemonicToSeed;
  async function mnemonicToPrivateKey(mnemonicArray, password) {
    mnemonicArray = normalizeMnemonic(mnemonicArray);
    const seed = await mnemonicToSeed(mnemonicArray, "TON default seed", password);
    let keyPair = tweetnacl_1.default.sign.keyPair.fromSeed(seed.slice(0, 32));
    return {
      publicKey: Buffer.from(keyPair.publicKey),
      secretKey: Buffer.from(keyPair.secretKey)
    };
  }
  mnemonic.mnemonicToPrivateKey = mnemonicToPrivateKey;
  async function mnemonicToWalletKey(mnemonicArray, password) {
    let seedPk = await mnemonicToPrivateKey(mnemonicArray, password);
    let seedSecret = seedPk.secretKey.slice(0, 32);
    const keyPair = tweetnacl_1.default.sign.keyPair.fromSeed(seedSecret);
    return {
      publicKey: Buffer.from(keyPair.publicKey),
      secretKey: Buffer.from(keyPair.secretKey)
    };
  }
  mnemonic.mnemonicToWalletKey = mnemonicToWalletKey;
  async function mnemonicToHDSeed(mnemonicArray, password) {
    mnemonicArray = normalizeMnemonic(mnemonicArray);
    return await mnemonicToSeed(mnemonicArray, "TON HD Keys seed", password);
  }
  mnemonic.mnemonicToHDSeed = mnemonicToHDSeed;
  async function mnemonicValidate(mnemonicArray, password) {
    mnemonicArray = normalizeMnemonic(mnemonicArray);
    for (let word of mnemonicArray) {
      if (wordlist_1.wordlist.indexOf(word) < 0) {
        return false;
      }
    }
    if (password && password.length > 0) {
      if (!await isPasswordNeeded(mnemonicArray)) {
        return false;
      }
    }
    return await isBasicSeed(await mnemonicToEntropy(mnemonicArray, password));
  }
  mnemonic.mnemonicValidate = mnemonicValidate;
  async function mnemonicNew(wordsCount = 24, password) {
    let mnemonicArray = [];
    while (true) {
      mnemonicArray = [];
      for (let i = 0; i < wordsCount; i++) {
        let ind = await (0, getSecureRandom_1.getSecureRandomNumber)(0, wordlist_1.wordlist.length);
        mnemonicArray.push(wordlist_1.wordlist[ind]);
      }
      if (password && password.length > 0) {
        if (!await isPasswordNeeded(mnemonicArray)) {
          continue;
        }
      }
      if (!await isBasicSeed(await mnemonicToEntropy(mnemonicArray, password))) {
        continue;
      }
      break;
    }
    return mnemonicArray;
  }
  mnemonic.mnemonicNew = mnemonicNew;
  function bytesToMnemonicIndexes(src2, wordsCount) {
    let bits = (0, binary_1.bytesToBits)(src2);
    let indexes = [];
    for (let i = 0; i < wordsCount; i++) {
      let sl = bits.slice(i * 11, i * 11 + 11);
      indexes.push(parseInt(sl, 2));
    }
    return indexes;
  }
  mnemonic.bytesToMnemonicIndexes = bytesToMnemonicIndexes;
  function bytesToMnemonics(src2, wordsCount) {
    let mnemonics2 = bytesToMnemonicIndexes(src2, wordsCount);
    let res = [];
    for (let m of mnemonics2) {
      res.push(wordlist_1.wordlist[m]);
    }
    return res;
  }
  mnemonic.bytesToMnemonics = bytesToMnemonics;
  function mnemonicIndexesToBytes(src2) {
    let res = "";
    for (let s of src2) {
      if (!Number.isSafeInteger(s)) {
        throw Error("Invalid input");
      }
      if (s < 0 || s >= 2028) {
        throw Error("Invalid input");
      }
      res += (0, binary_1.lpad)(s.toString(2), "0", 11);
    }
    while (res.length % 8 !== 0) {
      res = res + "0";
    }
    return (0, binary_1.bitsToBytes)(res);
  }
  mnemonic.mnemonicIndexesToBytes = mnemonicIndexesToBytes;
  async function mnemonicFromRandomSeed(seed, wordsCount = 24, password) {
    const bytesLength = Math.ceil(wordsCount * 11 / 8);
    let currentSeed = seed;
    while (true) {
      let entropy = await (0, pbkdf2_sha512_1.pbkdf2_sha512)(currentSeed, "TON mnemonic seed", Math.max(1, Math.floor(PBKDF_ITERATIONS / 256)), bytesLength);
      let mnemonics2 = bytesToMnemonics(entropy, wordsCount);
      if (await mnemonicValidate(mnemonics2, password)) {
        return mnemonics2;
      }
      currentSeed = entropy;
    }
  }
  mnemonic.mnemonicFromRandomSeed = mnemonicFromRandomSeed;
  return mnemonic;
}
var nacl = {};
var hasRequiredNacl;
function requireNacl() {
  if (hasRequiredNacl) return nacl;
  hasRequiredNacl = 1;
  var __importDefault = nacl && nacl.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(nacl, "__esModule", { value: true });
  nacl.openBox = nacl.sealBox = nacl.signVerify = nacl.sign = nacl.keyPairFromSeed = nacl.keyPairFromSecretKey = void 0;
  const tweetnacl_1 = __importDefault(requireNaclFast());
  function keyPairFromSecretKey(secretKey) {
    let res = tweetnacl_1.default.sign.keyPair.fromSecretKey(new Uint8Array(secretKey));
    return {
      publicKey: Buffer.from(res.publicKey),
      secretKey: Buffer.from(res.secretKey)
    };
  }
  nacl.keyPairFromSecretKey = keyPairFromSecretKey;
  function keyPairFromSeed(secretKey) {
    let res = tweetnacl_1.default.sign.keyPair.fromSeed(new Uint8Array(secretKey));
    return {
      publicKey: Buffer.from(res.publicKey),
      secretKey: Buffer.from(res.secretKey)
    };
  }
  nacl.keyPairFromSeed = keyPairFromSeed;
  function sign(data, secretKey) {
    return Buffer.from(tweetnacl_1.default.sign.detached(new Uint8Array(data), new Uint8Array(secretKey)));
  }
  nacl.sign = sign;
  function signVerify(data, signature, publicKey) {
    return tweetnacl_1.default.sign.detached.verify(new Uint8Array(data), new Uint8Array(signature), new Uint8Array(publicKey));
  }
  nacl.signVerify = signVerify;
  function sealBox(data, nonce, key2) {
    return Buffer.from(tweetnacl_1.default.secretbox(data, nonce, key2));
  }
  nacl.sealBox = sealBox;
  function openBox(data, nonce, key2) {
    let res = tweetnacl_1.default.secretbox.open(data, nonce, key2);
    if (!res) {
      return null;
    }
    return Buffer.from(res);
  }
  nacl.openBox = openBox;
  return nacl;
}
var ed25519 = {};
var hasRequiredEd25519;
function requireEd25519() {
  if (hasRequiredEd25519) return ed25519;
  hasRequiredEd25519 = 1;
  Object.defineProperty(ed25519, "__esModule", { value: true });
  ed25519.deriveEd25519Path = ed25519.deriveED25519HardenedKey = ed25519.getED25519MasterKeyFromSeed = void 0;
  const hmac_sha512_1 = requireHmac_sha512();
  const ED25519_CURVE = "ed25519 seed";
  const HARDENED_OFFSET = 2147483648;
  async function getED25519MasterKeyFromSeed(seed) {
    const I = await (0, hmac_sha512_1.hmac_sha512)(ED25519_CURVE, seed);
    const IL = I.slice(0, 32);
    const IR = I.slice(32);
    return {
      key: IL,
      chainCode: IR
    };
  }
  ed25519.getED25519MasterKeyFromSeed = getED25519MasterKeyFromSeed;
  async function deriveED25519HardenedKey(parent, index) {
    if (index >= HARDENED_OFFSET) {
      throw Error("Key index must be less than offset");
    }
    const indexBuffer = Buffer.alloc(4);
    indexBuffer.writeUInt32BE(index + HARDENED_OFFSET, 0);
    const data = Buffer.concat([Buffer.alloc(1, 0), parent.key, indexBuffer]);
    const I = await (0, hmac_sha512_1.hmac_sha512)(parent.chainCode, data);
    const IL = I.slice(0, 32);
    const IR = I.slice(32);
    return {
      key: IL,
      chainCode: IR
    };
  }
  ed25519.deriveED25519HardenedKey = deriveED25519HardenedKey;
  async function deriveEd25519Path(seed, path) {
    let state = await getED25519MasterKeyFromSeed(seed);
    let remaining = [...path];
    while (remaining.length > 0) {
      let index = remaining[0];
      remaining = remaining.slice(1);
      state = await deriveED25519HardenedKey(state, index);
    }
    return state.key;
  }
  ed25519.deriveEd25519Path = deriveEd25519Path;
  return ed25519;
}
var symmetric = {};
var hasRequiredSymmetric;
function requireSymmetric() {
  if (hasRequiredSymmetric) return symmetric;
  hasRequiredSymmetric = 1;
  Object.defineProperty(symmetric, "__esModule", { value: true });
  symmetric.deriveSymmetricPath = symmetric.deriveSymmetricHardenedKey = symmetric.getSymmetricMasterKeyFromSeed = void 0;
  const hmac_sha512_1 = requireHmac_sha512();
  const SYMMETRIC_SEED = "Symmetric key seed";
  async function getSymmetricMasterKeyFromSeed(seed) {
    const I = await (0, hmac_sha512_1.hmac_sha512)(SYMMETRIC_SEED, seed);
    const IL = I.slice(32);
    const IR = I.slice(0, 32);
    return {
      key: IL,
      chainCode: IR
    };
  }
  symmetric.getSymmetricMasterKeyFromSeed = getSymmetricMasterKeyFromSeed;
  async function deriveSymmetricHardenedKey(parent, offset) {
    const data = Buffer.concat([Buffer.alloc(1, 0), Buffer.from(offset)]);
    const I = await (0, hmac_sha512_1.hmac_sha512)(parent.chainCode, data);
    const IL = I.slice(32);
    const IR = I.slice(0, 32);
    return {
      key: IL,
      chainCode: IR
    };
  }
  symmetric.deriveSymmetricHardenedKey = deriveSymmetricHardenedKey;
  async function deriveSymmetricPath(seed, path) {
    let state = await getSymmetricMasterKeyFromSeed(seed);
    let remaining = [...path];
    while (remaining.length > 0) {
      let index = remaining[0];
      remaining = remaining.slice(1);
      state = await deriveSymmetricHardenedKey(state, index);
    }
    return state.key;
  }
  symmetric.deriveSymmetricPath = deriveSymmetricPath;
  return symmetric;
}
var mnemonics = {};
var hasRequiredMnemonics;
function requireMnemonics() {
  if (hasRequiredMnemonics) return mnemonics;
  hasRequiredMnemonics = 1;
  Object.defineProperty(mnemonics, "__esModule", { value: true });
  mnemonics.deriveMnemonicsPath = mnemonics.deriveMnemonicHardenedKey = mnemonics.getMnemonicsMasterKeyFromSeed = void 0;
  const mnemonic_1 = requireMnemonic();
  const hmac_sha512_1 = requireHmac_sha512();
  const HARDENED_OFFSET = 2147483648;
  const MNEMONICS_SEED = "TON Mnemonics HD seed";
  async function getMnemonicsMasterKeyFromSeed(seed) {
    const I = await (0, hmac_sha512_1.hmac_sha512)(MNEMONICS_SEED, seed);
    const IL = I.slice(0, 32);
    const IR = I.slice(32);
    return {
      key: IL,
      chainCode: IR
    };
  }
  mnemonics.getMnemonicsMasterKeyFromSeed = getMnemonicsMasterKeyFromSeed;
  async function deriveMnemonicHardenedKey(parent, index) {
    if (index >= HARDENED_OFFSET) {
      throw Error("Key index must be less than offset");
    }
    const indexBuffer = Buffer.alloc(4);
    indexBuffer.writeUInt32BE(index + HARDENED_OFFSET, 0);
    const data = Buffer.concat([Buffer.alloc(1, 0), parent.key, indexBuffer]);
    const I = await (0, hmac_sha512_1.hmac_sha512)(parent.chainCode, data);
    const IL = I.slice(0, 32);
    const IR = I.slice(32);
    return {
      key: IL,
      chainCode: IR
    };
  }
  mnemonics.deriveMnemonicHardenedKey = deriveMnemonicHardenedKey;
  async function deriveMnemonicsPath(seed, path, wordsCount = 24, password) {
    let state = await getMnemonicsMasterKeyFromSeed(seed);
    let remaining = [...path];
    while (remaining.length > 0) {
      let index = remaining[0];
      remaining = remaining.slice(1);
      state = await deriveMnemonicHardenedKey(state, index);
    }
    return await (0, mnemonic_1.mnemonicFromRandomSeed)(state.key, wordsCount, password);
  }
  mnemonics.deriveMnemonicsPath = deriveMnemonicsPath;
  return mnemonics;
}
var hasRequiredDist$6;
function requireDist$6() {
  if (hasRequiredDist$6) return dist$5;
  hasRequiredDist$6 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMnemonicsMasterKeyFromSeed = exports.deriveMnemonicHardenedKey = exports.deriveMnemonicsPath = exports.deriveSymmetricPath = exports.deriveSymmetricHardenedKey = exports.getSymmetricMasterKeyFromSeed = exports.deriveEd25519Path = exports.deriveED25519HardenedKey = exports.getED25519MasterKeyFromSeed = exports.signVerify = exports.sign = exports.keyPairFromSecretKey = exports.keyPairFromSeed = exports.openBox = exports.sealBox = exports.mnemonicWordList = exports.mnemonicToHDSeed = exports.mnemonicToSeed = exports.mnemonicToWalletKey = exports.mnemonicToPrivateKey = exports.mnemonicValidate = exports.mnemonicNew = exports.newSecurePassphrase = exports.newSecureWords = exports.getSecureRandomNumber = exports.getSecureRandomWords = exports.getSecureRandomBytes = exports.hmac_sha512 = exports.pbkdf2_sha512 = exports.sha512_sync = exports.sha512 = exports.sha256_sync = exports.sha256 = void 0;
    var sha256_1 = requireSha256$1();
    Object.defineProperty(exports, "sha256", { enumerable: true, get: function() {
      return sha256_1.sha256;
    } });
    Object.defineProperty(exports, "sha256_sync", { enumerable: true, get: function() {
      return sha256_1.sha256_sync;
    } });
    var sha512_1 = requireSha512$1();
    Object.defineProperty(exports, "sha512", { enumerable: true, get: function() {
      return sha512_1.sha512;
    } });
    Object.defineProperty(exports, "sha512_sync", { enumerable: true, get: function() {
      return sha512_1.sha512_sync;
    } });
    var pbkdf2_sha512_1 = requirePbkdf2_sha512();
    Object.defineProperty(exports, "pbkdf2_sha512", { enumerable: true, get: function() {
      return pbkdf2_sha512_1.pbkdf2_sha512;
    } });
    var hmac_sha512_1 = requireHmac_sha512();
    Object.defineProperty(exports, "hmac_sha512", { enumerable: true, get: function() {
      return hmac_sha512_1.hmac_sha512;
    } });
    var getSecureRandom_1 = requireGetSecureRandom();
    Object.defineProperty(exports, "getSecureRandomBytes", { enumerable: true, get: function() {
      return getSecureRandom_1.getSecureRandomBytes;
    } });
    Object.defineProperty(exports, "getSecureRandomWords", { enumerable: true, get: function() {
      return getSecureRandom_1.getSecureRandomWords;
    } });
    Object.defineProperty(exports, "getSecureRandomNumber", { enumerable: true, get: function() {
      return getSecureRandom_1.getSecureRandomNumber;
    } });
    var newSecureWords_1 = requireNewSecureWords();
    Object.defineProperty(exports, "newSecureWords", { enumerable: true, get: function() {
      return newSecureWords_1.newSecureWords;
    } });
    var newSecurePassphrase_1 = requireNewSecurePassphrase();
    Object.defineProperty(exports, "newSecurePassphrase", { enumerable: true, get: function() {
      return newSecurePassphrase_1.newSecurePassphrase;
    } });
    var mnemonic_1 = requireMnemonic();
    Object.defineProperty(exports, "mnemonicNew", { enumerable: true, get: function() {
      return mnemonic_1.mnemonicNew;
    } });
    Object.defineProperty(exports, "mnemonicValidate", { enumerable: true, get: function() {
      return mnemonic_1.mnemonicValidate;
    } });
    Object.defineProperty(exports, "mnemonicToPrivateKey", { enumerable: true, get: function() {
      return mnemonic_1.mnemonicToPrivateKey;
    } });
    Object.defineProperty(exports, "mnemonicToWalletKey", { enumerable: true, get: function() {
      return mnemonic_1.mnemonicToWalletKey;
    } });
    Object.defineProperty(exports, "mnemonicToSeed", { enumerable: true, get: function() {
      return mnemonic_1.mnemonicToSeed;
    } });
    Object.defineProperty(exports, "mnemonicToHDSeed", { enumerable: true, get: function() {
      return mnemonic_1.mnemonicToHDSeed;
    } });
    var wordlist_1 = requireWordlist();
    Object.defineProperty(exports, "mnemonicWordList", { enumerable: true, get: function() {
      return wordlist_1.wordlist;
    } });
    var nacl_1 = requireNacl();
    Object.defineProperty(exports, "sealBox", { enumerable: true, get: function() {
      return nacl_1.sealBox;
    } });
    Object.defineProperty(exports, "openBox", { enumerable: true, get: function() {
      return nacl_1.openBox;
    } });
    var nacl_2 = requireNacl();
    Object.defineProperty(exports, "keyPairFromSeed", { enumerable: true, get: function() {
      return nacl_2.keyPairFromSeed;
    } });
    Object.defineProperty(exports, "keyPairFromSecretKey", { enumerable: true, get: function() {
      return nacl_2.keyPairFromSecretKey;
    } });
    Object.defineProperty(exports, "sign", { enumerable: true, get: function() {
      return nacl_2.sign;
    } });
    Object.defineProperty(exports, "signVerify", { enumerable: true, get: function() {
      return nacl_2.signVerify;
    } });
    var ed25519_1 = requireEd25519();
    Object.defineProperty(exports, "getED25519MasterKeyFromSeed", { enumerable: true, get: function() {
      return ed25519_1.getED25519MasterKeyFromSeed;
    } });
    Object.defineProperty(exports, "deriveED25519HardenedKey", { enumerable: true, get: function() {
      return ed25519_1.deriveED25519HardenedKey;
    } });
    Object.defineProperty(exports, "deriveEd25519Path", { enumerable: true, get: function() {
      return ed25519_1.deriveEd25519Path;
    } });
    var symmetric_1 = requireSymmetric();
    Object.defineProperty(exports, "getSymmetricMasterKeyFromSeed", { enumerable: true, get: function() {
      return symmetric_1.getSymmetricMasterKeyFromSeed;
    } });
    Object.defineProperty(exports, "deriveSymmetricHardenedKey", { enumerable: true, get: function() {
      return symmetric_1.deriveSymmetricHardenedKey;
    } });
    Object.defineProperty(exports, "deriveSymmetricPath", { enumerable: true, get: function() {
      return symmetric_1.deriveSymmetricPath;
    } });
    var mnemonics_1 = requireMnemonics();
    Object.defineProperty(exports, "deriveMnemonicsPath", { enumerable: true, get: function() {
      return mnemonics_1.deriveMnemonicsPath;
    } });
    Object.defineProperty(exports, "deriveMnemonicHardenedKey", { enumerable: true, get: function() {
      return mnemonics_1.deriveMnemonicHardenedKey;
    } });
    Object.defineProperty(exports, "getMnemonicsMasterKeyFromSeed", { enumerable: true, get: function() {
      return mnemonics_1.getMnemonicsMasterKeyFromSeed;
    } });
  })(dist$5);
  return dist$5;
}
var hasRequiredWonderCalculator$1;
function requireWonderCalculator$1() {
  if (hasRequiredWonderCalculator$1) return wonderCalculator$1;
  hasRequiredWonderCalculator$1 = 1;
  Object.defineProperty(wonderCalculator$1, "__esModule", { value: true });
  wonderCalculator$1.wonderCalculator = void 0;
  const BitString_1 = requireBitString$1();
  const CellType_1 = requireCellType$1();
  const LevelMask_1 = requireLevelMask$1();
  const exoticPruned_1 = requireExoticPruned$1();
  const exoticMerkleProof_1 = requireExoticMerkleProof$1();
  const descriptor_1 = requireDescriptor$1();
  const crypto_1 = requireDist$6();
  const exoticMerkleUpdate_1 = requireExoticMerkleUpdate$1();
  const exoticLibrary_1 = requireExoticLibrary$1();
  function wonderCalculator2(type, bits, refs) {
    let levelMask;
    let pruned = null;
    if (type === CellType_1.CellType.Ordinary) {
      let mask = 0;
      for (let r of refs) {
        mask = mask | r.mask.value;
      }
      levelMask = new LevelMask_1.LevelMask(mask);
    } else if (type === CellType_1.CellType.PrunedBranch) {
      pruned = (0, exoticPruned_1.exoticPruned)(bits, refs);
      levelMask = new LevelMask_1.LevelMask(pruned.mask);
    } else if (type === CellType_1.CellType.MerkleProof) {
      (0, exoticMerkleProof_1.exoticMerkleProof)(bits, refs);
      levelMask = new LevelMask_1.LevelMask(refs[0].mask.value >> 1);
    } else if (type === CellType_1.CellType.MerkleUpdate) {
      (0, exoticMerkleUpdate_1.exoticMerkleUpdate)(bits, refs);
      levelMask = new LevelMask_1.LevelMask((refs[0].mask.value | refs[1].mask.value) >> 1);
    } else if (type === CellType_1.CellType.Library) {
      (0, exoticLibrary_1.exoticLibrary)(bits, refs);
      levelMask = new LevelMask_1.LevelMask();
    } else {
      throw new Error("Unsupported exotic type");
    }
    let depths = [];
    let hashes = [];
    let hashCount = type === CellType_1.CellType.PrunedBranch ? 1 : levelMask.hashCount;
    let totalHashCount = levelMask.hashCount;
    let hashIOffset = totalHashCount - hashCount;
    for (let levelI = 0, hashI = 0; levelI <= levelMask.level; levelI++) {
      if (!levelMask.isSignificant(levelI)) {
        continue;
      }
      if (hashI < hashIOffset) {
        hashI++;
        continue;
      }
      let currentBits;
      if (hashI === hashIOffset) {
        if (!(levelI === 0 || type === CellType_1.CellType.PrunedBranch)) {
          throw Error("Invalid");
        }
        currentBits = bits;
      } else {
        if (!(levelI !== 0 && type !== CellType_1.CellType.PrunedBranch)) {
          throw Error("Invalid: " + levelI + ", " + type);
        }
        currentBits = new BitString_1.BitString(hashes[hashI - hashIOffset - 1], 0, 256);
      }
      let currentDepth = 0;
      for (let c of refs) {
        let childDepth;
        if (type == CellType_1.CellType.MerkleProof || type == CellType_1.CellType.MerkleUpdate) {
          childDepth = c.depth(levelI + 1);
        } else {
          childDepth = c.depth(levelI);
        }
        currentDepth = Math.max(currentDepth, childDepth);
      }
      if (refs.length > 0) {
        currentDepth++;
      }
      let repr = (0, descriptor_1.getRepr)(bits, currentBits, refs, levelI, levelMask.apply(levelI).value, type);
      let hash = (0, crypto_1.sha256_sync)(repr);
      let destI = hashI - hashIOffset;
      depths[destI] = currentDepth;
      hashes[destI] = hash;
      hashI++;
    }
    let resolvedHashes = [];
    let resolvedDepths = [];
    if (pruned) {
      for (let i = 0; i < 4; i++) {
        const { hashIndex } = levelMask.apply(i);
        const { hashIndex: thisHashIndex } = levelMask;
        if (hashIndex !== thisHashIndex) {
          resolvedHashes.push(pruned.pruned[hashIndex].hash);
          resolvedDepths.push(pruned.pruned[hashIndex].depth);
        } else {
          resolvedHashes.push(hashes[0]);
          resolvedDepths.push(depths[0]);
        }
      }
    } else {
      for (let i = 0; i < 4; i++) {
        resolvedHashes.push(hashes[levelMask.apply(i).hashIndex]);
        resolvedDepths.push(depths[levelMask.apply(i).hashIndex]);
      }
    }
    return {
      mask: levelMask,
      hashes: resolvedHashes,
      depths: resolvedDepths
    };
  }
  wonderCalculator$1.wonderCalculator = wonderCalculator2;
  return wonderCalculator$1;
}
var serialization$1 = {};
var topologicalSort$1 = {};
var hasRequiredTopologicalSort$1;
function requireTopologicalSort$1() {
  if (hasRequiredTopologicalSort$1) return topologicalSort$1;
  hasRequiredTopologicalSort$1 = 1;
  Object.defineProperty(topologicalSort$1, "__esModule", { value: true });
  topologicalSort$1.topologicalSort = void 0;
  function topologicalSort2(src2) {
    let pending = [src2];
    let allCells = /* @__PURE__ */ new Map();
    let notPermCells = /* @__PURE__ */ new Set();
    let sorted = [];
    while (pending.length > 0) {
      const cells = [...pending];
      pending = [];
      for (let cell of cells) {
        const hash = cell.hash().toString("hex");
        if (allCells.has(hash)) {
          continue;
        }
        notPermCells.add(hash);
        allCells.set(hash, { cell, refs: cell.refs.map((v2) => v2.hash().toString("hex")) });
        for (let r of cell.refs) {
          pending.push(r);
        }
      }
    }
    let tempMark = /* @__PURE__ */ new Set();
    function visit2(hash) {
      if (!notPermCells.has(hash)) {
        return;
      }
      if (tempMark.has(hash)) {
        throw Error("Not a DAG");
      }
      tempMark.add(hash);
      let refs = allCells.get(hash).refs;
      for (let ci = refs.length - 1; ci >= 0; ci--) {
        visit2(refs[ci]);
      }
      sorted.push(hash);
      tempMark.delete(hash);
      notPermCells.delete(hash);
    }
    while (notPermCells.size > 0) {
      const id = Array.from(notPermCells)[0];
      visit2(id);
    }
    let indexes = /* @__PURE__ */ new Map();
    for (let i = 0; i < sorted.length; i++) {
      indexes.set(sorted[sorted.length - i - 1], i);
    }
    let result = [];
    for (let i = sorted.length - 1; i >= 0; i--) {
      let ent = sorted[i];
      const rrr = allCells.get(ent);
      result.push({ cell: rrr.cell, refs: rrr.refs.map((v2) => indexes.get(v2)) });
    }
    return result;
  }
  topologicalSort$1.topologicalSort = topologicalSort2;
  return topologicalSort$1;
}
var bitsForNumber$1 = {};
var hasRequiredBitsForNumber$1;
function requireBitsForNumber$1() {
  if (hasRequiredBitsForNumber$1) return bitsForNumber$1;
  hasRequiredBitsForNumber$1 = 1;
  Object.defineProperty(bitsForNumber$1, "__esModule", { value: true });
  bitsForNumber$1.bitsForNumber = void 0;
  function bitsForNumber2(src2, mode) {
    let v2 = BigInt(src2);
    if (mode === "int") {
      if (v2 === 0n || v2 === -1n) {
        return 1;
      }
      let v22 = v2 > 0 ? v2 : -v2;
      return v22.toString(2).length + 1;
    } else if (mode === "uint") {
      if (v2 < 0) {
        throw Error(`value is negative. Got ${src2}`);
      }
      return v2.toString(2).length;
    } else {
      throw Error(`invalid mode. Got ${mode}`);
    }
  }
  bitsForNumber$1.bitsForNumber = bitsForNumber2;
  return bitsForNumber$1;
}
var crc32c$1 = {};
var hasRequiredCrc32c$1;
function requireCrc32c$1() {
  if (hasRequiredCrc32c$1) return crc32c$1;
  hasRequiredCrc32c$1 = 1;
  Object.defineProperty(crc32c$1, "__esModule", { value: true });
  crc32c$1.crc32c = void 0;
  const POLY = 2197175160;
  function crc32c2(source) {
    let crc = 0 ^ 4294967295;
    for (let n = 0; n < source.length; n++) {
      crc ^= source[n];
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
    }
    crc = crc ^ 4294967295;
    let res = Buffer.alloc(4);
    res.writeInt32LE(crc);
    return res;
  }
  crc32c$1.crc32c = crc32c2;
  return crc32c$1;
}
var hasRequiredSerialization$1;
function requireSerialization$1() {
  if (hasRequiredSerialization$1) return serialization$1;
  hasRequiredSerialization$1 = 1;
  Object.defineProperty(serialization$1, "__esModule", { value: true });
  serialization$1.serializeBoc = serialization$1.deserializeBoc = serialization$1.parseBoc = void 0;
  const BitReader_1 = requireBitReader$1();
  const BitString_1 = requireBitString$1();
  const Cell_1 = requireCell$1();
  const topologicalSort_1 = requireTopologicalSort$1();
  const bitsForNumber_1 = requireBitsForNumber$1();
  const BitBuilder_1 = requireBitBuilder$1();
  const descriptor_1 = requireDescriptor$1();
  const paddedBits_1 = requirePaddedBits$1();
  const crc32c_1 = requireCrc32c$1();
  function getHashesCount(levelMask) {
    return getHashesCountFromMask(levelMask & 7);
  }
  function getHashesCountFromMask(mask) {
    let n = 0;
    for (let i = 0; i < 3; i++) {
      n += mask & 1;
      mask = mask >> 1;
    }
    return n + 1;
  }
  function readCell(reader2, sizeBytes) {
    const d1 = reader2.loadUint(8);
    const refsCount = d1 % 8;
    const exotic = !!(d1 & 8);
    const d2 = reader2.loadUint(8);
    const dataBytesize = Math.ceil(d2 / 2);
    const paddingAdded = !!(d2 % 2);
    const levelMask = d1 >> 5;
    const hasHashes = (d1 & 16) != 0;
    const hash_bytes = 32;
    const hashesSize = hasHashes ? getHashesCount(levelMask) * hash_bytes : 0;
    const depthSize = hasHashes ? getHashesCount(levelMask) * 2 : 0;
    reader2.skip(hashesSize * 8);
    reader2.skip(depthSize * 8);
    let bits = BitString_1.BitString.EMPTY;
    if (dataBytesize > 0) {
      if (paddingAdded) {
        bits = reader2.loadPaddedBits(dataBytesize * 8);
      } else {
        bits = reader2.loadBits(dataBytesize * 8);
      }
    }
    let refs = [];
    for (let i = 0; i < refsCount; i++) {
      refs.push(reader2.loadUint(sizeBytes * 8));
    }
    return {
      bits,
      refs,
      exotic
    };
  }
  function calcCellSize(cell, sizeBytes) {
    return 2 + Math.ceil(cell.bits.length / 8) + cell.refs.length * sizeBytes;
  }
  function parseBoc(src2) {
    let reader2 = new BitReader_1.BitReader(new BitString_1.BitString(src2, 0, src2.length * 8));
    let magic = reader2.loadUint(32);
    if (magic === 1761568243) {
      let size = reader2.loadUint(8);
      let offBytes = reader2.loadUint(8);
      let cells = reader2.loadUint(size * 8);
      let roots = reader2.loadUint(size * 8);
      let absent = reader2.loadUint(size * 8);
      let totalCellSize = reader2.loadUint(offBytes * 8);
      let index = reader2.loadBuffer(cells * offBytes);
      let cellData = reader2.loadBuffer(totalCellSize);
      return {
        size,
        offBytes,
        cells,
        roots,
        absent,
        totalCellSize,
        index,
        cellData,
        root: [0]
      };
    } else if (magic === 2898503464) {
      let size = reader2.loadUint(8);
      let offBytes = reader2.loadUint(8);
      let cells = reader2.loadUint(size * 8);
      let roots = reader2.loadUint(size * 8);
      let absent = reader2.loadUint(size * 8);
      let totalCellSize = reader2.loadUint(offBytes * 8);
      let index = reader2.loadBuffer(cells * offBytes);
      let cellData = reader2.loadBuffer(totalCellSize);
      let crc32 = reader2.loadBuffer(4);
      if (!(0, crc32c_1.crc32c)(src2.subarray(0, src2.length - 4)).equals(crc32)) {
        throw Error("Invalid CRC32C");
      }
      return {
        size,
        offBytes,
        cells,
        roots,
        absent,
        totalCellSize,
        index,
        cellData,
        root: [0]
      };
    } else if (magic === 3052313714) {
      let hasIdx = reader2.loadUint(1);
      let hasCrc32c = reader2.loadUint(1);
      reader2.loadUint(1);
      reader2.loadUint(2);
      let size = reader2.loadUint(3);
      let offBytes = reader2.loadUint(8);
      let cells = reader2.loadUint(size * 8);
      let roots = reader2.loadUint(size * 8);
      let absent = reader2.loadUint(size * 8);
      let totalCellSize = reader2.loadUint(offBytes * 8);
      let root = [];
      for (let i = 0; i < roots; i++) {
        root.push(reader2.loadUint(size * 8));
      }
      let index = null;
      if (hasIdx) {
        index = reader2.loadBuffer(cells * offBytes);
      }
      let cellData = reader2.loadBuffer(totalCellSize);
      if (hasCrc32c) {
        let crc32 = reader2.loadBuffer(4);
        if (!(0, crc32c_1.crc32c)(src2.subarray(0, src2.length - 4)).equals(crc32)) {
          throw Error("Invalid CRC32C");
        }
      }
      return {
        size,
        offBytes,
        cells,
        roots,
        absent,
        totalCellSize,
        index,
        cellData,
        root
      };
    } else {
      throw Error("Invalid magic");
    }
  }
  serialization$1.parseBoc = parseBoc;
  function deserializeBoc(src2) {
    let boc = parseBoc(src2);
    let reader2 = new BitReader_1.BitReader(new BitString_1.BitString(boc.cellData, 0, boc.cellData.length * 8));
    let cells = [];
    for (let i = 0; i < boc.cells; i++) {
      let cll = readCell(reader2, boc.size);
      cells.push({ ...cll, result: null });
    }
    for (let i = cells.length - 1; i >= 0; i--) {
      if (cells[i].result) {
        throw Error("Impossible");
      }
      let refs = [];
      for (let r of cells[i].refs) {
        if (!cells[r].result) {
          throw Error("Invalid BOC file");
        }
        refs.push(cells[r].result);
      }
      cells[i].result = new Cell_1.Cell({ bits: cells[i].bits, refs, exotic: cells[i].exotic });
    }
    let roots = [];
    for (let i = 0; i < boc.root.length; i++) {
      roots.push(cells[boc.root[i]].result);
    }
    return roots;
  }
  serialization$1.deserializeBoc = deserializeBoc;
  function writeCellToBuilder(cell, refs, sizeBytes, to) {
    let d1 = (0, descriptor_1.getRefsDescriptor)(cell.refs, cell.mask.value, cell.type);
    let d2 = (0, descriptor_1.getBitsDescriptor)(cell.bits);
    to.writeUint(d1, 8);
    to.writeUint(d2, 8);
    to.writeBuffer((0, paddedBits_1.bitsToPaddedBuffer)(cell.bits));
    for (let r of refs) {
      to.writeUint(r, sizeBytes * 8);
    }
  }
  function serializeBoc(root, opts) {
    let allCells = (0, topologicalSort_1.topologicalSort)(root);
    let cellsNum = allCells.length;
    let has_idx = opts.idx;
    let has_crc32c = opts.crc32;
    let has_cache_bits = false;
    let flags = 0;
    let sizeBytes = Math.max(Math.ceil((0, bitsForNumber_1.bitsForNumber)(cellsNum, "uint") / 8), 1);
    let totalCellSize = 0;
    let index = [];
    for (let c of allCells) {
      let sz = calcCellSize(c.cell, sizeBytes);
      totalCellSize += sz;
      index.push(totalCellSize);
    }
    let offsetBytes = Math.max(Math.ceil((0, bitsForNumber_1.bitsForNumber)(totalCellSize, "uint") / 8), 1);
    let totalSize = (4 + // magic
    1 + // flags and s_bytes
    1 + // offset_bytes
    3 * sizeBytes + // cells_num, roots, complete
    offsetBytes + // full_size
    1 * sizeBytes + // root_idx
    (has_idx ? cellsNum * offsetBytes : 0) + totalCellSize + (has_crc32c ? 4 : 0)) * 8;
    let builder2 = new BitBuilder_1.BitBuilder(totalSize);
    builder2.writeUint(3052313714, 32);
    builder2.writeBit(has_idx);
    builder2.writeBit(has_crc32c);
    builder2.writeBit(has_cache_bits);
    builder2.writeUint(flags, 2);
    builder2.writeUint(sizeBytes, 3);
    builder2.writeUint(offsetBytes, 8);
    builder2.writeUint(cellsNum, sizeBytes * 8);
    builder2.writeUint(1, sizeBytes * 8);
    builder2.writeUint(0, sizeBytes * 8);
    builder2.writeUint(totalCellSize, offsetBytes * 8);
    builder2.writeUint(0, sizeBytes * 8);
    if (has_idx) {
      for (let i = 0; i < cellsNum; i++) {
        builder2.writeUint(index[i], offsetBytes * 8);
      }
    }
    for (let i = 0; i < cellsNum; i++) {
      writeCellToBuilder(allCells[i].cell, allCells[i].refs, sizeBytes, builder2);
    }
    if (has_crc32c) {
      let crc32 = (0, crc32c_1.crc32c)(builder2.buffer());
      builder2.writeBuffer(crc32);
    }
    let res = builder2.buffer();
    if (res.length !== totalSize / 8) {
      throw Error("Internal error");
    }
    return res;
  }
  serialization$1.serializeBoc = serializeBoc;
  return serialization$1;
}
var hasRequiredCell$1;
function requireCell$1() {
  if (hasRequiredCell$1) return Cell$1;
  hasRequiredCell$1 = 1;
  var __importDefault = Cell$1 && Cell$1.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  var _a;
  Object.defineProperty(Cell$1, "__esModule", { value: true });
  Cell$1.Cell = void 0;
  const symbol_inspect_1 = __importDefault(requireSymbol_inspect());
  const BitString_1 = requireBitString$1();
  const CellType_1 = requireCellType$1();
  const Slice_1 = requireSlice$1();
  const resolveExotic_1 = requireResolveExotic$1();
  const wonderCalculator_1 = requireWonderCalculator$1();
  const serialization_1 = requireSerialization$1();
  const BitReader_1 = requireBitReader$1();
  const Builder_12 = requireBuilder$3();
  class Cell2 {
    /**
     * Deserialize cells from BOC
     * @param src source buffer
     * @returns array of cells
     */
    static fromBoc(src2) {
      return (0, serialization_1.deserializeBoc)(src2);
    }
    /**
     * Helper function that deserializes a single cell from BOC in base64
     * @param src source string
     */
    static fromBase64(src2) {
      let parsed = Cell2.fromBoc(Buffer.from(src2, "base64"));
      if (parsed.length !== 1) {
        throw new Error("Deserialized more than one cell");
      }
      return parsed[0];
    }
    /**
     * Helper function that deserializes a single cell from BOC in hex
     * @param src source string
     */
    static fromHex(src2) {
      let parsed = Cell2.fromBoc(Buffer.from(src2, "hex"));
      if (parsed.length !== 1) {
        throw new Error("Deserialized more than one cell");
      }
      return parsed[0];
    }
    constructor(opts) {
      this._hashes = [];
      this._depths = [];
      this.beginParse = (allowExotic = false) => {
        if (this.isExotic && !allowExotic) {
          throw new Error("Exotic cells cannot be parsed");
        }
        return new Slice_1.Slice(new BitReader_1.BitReader(this.bits), this.refs);
      };
      this.hash = (level = 3) => {
        return this._hashes[Math.min(this._hashes.length - 1, level)];
      };
      this.depth = (level = 3) => {
        return this._depths[Math.min(this._depths.length - 1, level)];
      };
      this.level = () => {
        return this.mask.level;
      };
      this.equals = (other) => {
        return this.hash().equals(other.hash());
      };
      this[_a] = () => this.toString();
      let bits = BitString_1.BitString.EMPTY;
      if (opts && opts.bits) {
        bits = opts.bits;
      }
      let refs = [];
      if (opts && opts.refs) {
        refs = [...opts.refs];
      }
      let hashes;
      let depths;
      let mask;
      let type = CellType_1.CellType.Ordinary;
      if (opts && opts.exotic) {
        let resolved = (0, resolveExotic_1.resolveExotic)(bits, refs);
        let wonders = (0, wonderCalculator_1.wonderCalculator)(resolved.type, bits, refs);
        mask = wonders.mask;
        depths = wonders.depths;
        hashes = wonders.hashes;
        type = resolved.type;
      } else {
        if (refs.length > 4) {
          throw new Error("Invalid number of references");
        }
        if (bits.length > 1023) {
          throw new Error(`Bits overflow: ${bits.length} > 1023`);
        }
        let wonders = (0, wonderCalculator_1.wonderCalculator)(CellType_1.CellType.Ordinary, bits, refs);
        mask = wonders.mask;
        depths = wonders.depths;
        hashes = wonders.hashes;
        type = CellType_1.CellType.Ordinary;
      }
      this.type = type;
      this.bits = bits;
      this.refs = refs;
      this.mask = mask;
      this._depths = depths;
      this._hashes = hashes;
      Object.freeze(this);
      Object.freeze(this.refs);
      Object.freeze(this.bits);
      Object.freeze(this.mask);
      Object.freeze(this._depths);
      Object.freeze(this._hashes);
    }
    /**
     * Check if cell is exotic
     */
    get isExotic() {
      return this.type !== CellType_1.CellType.Ordinary;
    }
    /**
     * Serializes cell to BOC
     * @param opts options
     */
    toBoc(opts) {
      let idx = opts && opts.idx !== null && opts.idx !== void 0 ? opts.idx : false;
      let crc32 = opts && opts.crc32 !== null && opts.crc32 !== void 0 ? opts.crc32 : true;
      return (0, serialization_1.serializeBoc)(this, { idx, crc32 });
    }
    /**
     * Format cell to string
     * @param indent indentation
     * @returns string representation
     */
    toString(indent) {
      let id = indent || "";
      let t = "x";
      if (this.isExotic) {
        if (this.type === CellType_1.CellType.MerkleProof) {
          t = "p";
        } else if (this.type === CellType_1.CellType.MerkleUpdate) {
          t = "u";
        } else if (this.type === CellType_1.CellType.PrunedBranch) {
          t = "p";
        }
      }
      let s = id + (this.isExotic ? t : "x") + "{" + this.bits.toString() + "}";
      for (let k in this.refs) {
        const i = this.refs[k];
        s += "\n" + i.toString(id + " ");
      }
      return s;
    }
    /**
     * Covnert cell to slice
     * @returns slice
     */
    asSlice() {
      return this.beginParse();
    }
    /**
     * Convert cell to a builder that has this cell stored
     * @returns builder
     */
    asBuilder() {
      return (0, Builder_12.beginCell)().storeSlice(this.asSlice());
    }
  }
  Cell$1.Cell = Cell2;
  _a = symbol_inspect_1.default;
  Cell2.EMPTY = new Cell2();
  return Cell$1;
}
var hasRequiredBuilder$3;
function requireBuilder$3() {
  if (hasRequiredBuilder$3) return Builder$4;
  hasRequiredBuilder$3 = 1;
  Object.defineProperty(Builder$4, "__esModule", { value: true });
  Builder$4.Builder = Builder$4.beginCell = void 0;
  const BitBuilder_1 = requireBitBuilder$1();
  const Cell_1 = requireCell$1();
  const strings_1 = requireStrings$1();
  function beginCell() {
    return new Builder2();
  }
  Builder$4.beginCell = beginCell;
  class Builder2 {
    constructor() {
      this._bits = new BitBuilder_1.BitBuilder();
      this._refs = [];
    }
    /**
     * Bits written so far
     */
    get bits() {
      return this._bits.length;
    }
    /**
     * References written so far
     */
    get refs() {
      return this._refs.length;
    }
    /**
     * Available bits
     */
    get availableBits() {
      return 1023 - this.bits;
    }
    /**
     * Available references
     */
    get availableRefs() {
      return 4 - this.refs;
    }
    /**
     * Write a single bit
     * @param value bit to write, true or positive number for 1, false or zero or negative for 0
     * @returns this builder
     */
    storeBit(value) {
      this._bits.writeBit(value);
      return this;
    }
    /**
     * Write bits from BitString
     * @param src source bits
     * @returns this builder
     */
    storeBits(src2) {
      this._bits.writeBits(src2);
      return this;
    }
    /**
     * Store Buffer
     * @param src source buffer
     * @param bytes optional number of bytes to write
     * @returns this builder
     */
    storeBuffer(src2, bytes) {
      if (bytes !== void 0 && bytes !== null) {
        if (src2.length !== bytes) {
          throw Error(`Buffer length ${src2.length} is not equal to ${bytes}`);
        }
      }
      this._bits.writeBuffer(src2);
      return this;
    }
    /**
     * Store Maybe Buffer
     * @param src source buffer or null
     * @param bytes optional number of bytes to write
     * @returns this builder
     */
    storeMaybeBuffer(src2, bytes) {
      if (src2 !== null) {
        this.storeBit(1);
        this.storeBuffer(src2, bytes);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store uint value
     * @param value value as bigint or number
     * @param bits number of bits to write
     * @returns this builder
     */
    storeUint(value, bits) {
      this._bits.writeUint(value, bits);
      return this;
    }
    /**
     * Store maybe uint value
     * @param value value as bigint or number, null or undefined
     * @param bits number of bits to write
     * @returns this builder
     */
    storeMaybeUint(value, bits) {
      if (value !== null && value !== void 0) {
        this.storeBit(1);
        this.storeUint(value, bits);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store int value
     * @param value value as bigint or number
     * @param bits number of bits to write
     * @returns this builder
     */
    storeInt(value, bits) {
      this._bits.writeInt(value, bits);
      return this;
    }
    /**
     * Store maybe int value
     * @param value value as bigint or number, null or undefined
     * @param bits number of bits to write
     * @returns this builder
     */
    storeMaybeInt(value, bits) {
      if (value !== null && value !== void 0) {
        this.storeBit(1);
        this.storeInt(value, bits);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store varuint value
     * @param value value as bigint or number
     * @param bits number of bits to write to header
     * @returns this builder
     */
    storeVarUint(value, bits) {
      this._bits.writeVarUint(value, bits);
      return this;
    }
    /**
     * Store maybe varuint value
     * @param value value as bigint or number, null or undefined
     * @param bits number of bits to write to header
     * @returns this builder
     */
    storeMaybeVarUint(value, bits) {
      if (value !== null && value !== void 0) {
        this.storeBit(1);
        this.storeVarUint(value, bits);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store varint value
     * @param value value as bigint or number
     * @param bits number of bits to write to header
     * @returns this builder
     */
    storeVarInt(value, bits) {
      this._bits.writeVarInt(value, bits);
      return this;
    }
    /**
     * Store maybe varint value
     * @param value value as bigint or number, null or undefined
     * @param bits number of bits to write to header
     * @returns this builder
     */
    storeMaybeVarInt(value, bits) {
      if (value !== null && value !== void 0) {
        this.storeBit(1);
        this.storeVarInt(value, bits);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store coins value
     * @param amount amount of coins
     * @returns this builder
     */
    storeCoins(amount) {
      this._bits.writeCoins(amount);
      return this;
    }
    /**
     * Store maybe coins value
     * @param amount amount of coins, null or undefined
     * @returns this builder
     */
    storeMaybeCoins(amount) {
      if (amount !== null && amount !== void 0) {
        this.storeBit(1);
        this.storeCoins(amount);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store address
     * @param addres address to store
     * @returns this builder
     */
    storeAddress(address) {
      this._bits.writeAddress(address);
      return this;
    }
    /**
     * Store reference
     * @param cell cell or builder to store
     * @returns this builder
     */
    storeRef(cell) {
      if (this._refs.length >= 4) {
        throw new Error("Too many references");
      }
      if (cell instanceof Cell_1.Cell) {
        this._refs.push(cell);
      } else if (cell instanceof Builder2) {
        this._refs.push(cell.endCell());
      } else {
        throw new Error("Invalid argument");
      }
      return this;
    }
    /**
     * Store reference if not null
     * @param cell cell or builder to store
     * @returns this builder
     */
    storeMaybeRef(cell) {
      if (cell) {
        this.storeBit(1);
        this.storeRef(cell);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store slice it in this builder
     * @param src source slice
     */
    storeSlice(src2) {
      let c = src2.clone();
      if (c.remainingBits > 0) {
        this.storeBits(c.loadBits(c.remainingBits));
      }
      while (c.remainingRefs > 0) {
        this.storeRef(c.loadRef());
      }
      return this;
    }
    /**
     * Store slice in this builder if not null
     * @param src source slice
     */
    storeMaybeSlice(src2) {
      if (src2) {
        this.storeBit(1);
        this.storeSlice(src2);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store builder
     * @param src builder to store
     * @returns this builder
     */
    storeBuilder(src2) {
      return this.storeSlice(src2.endCell().beginParse());
    }
    /**
     * Store builder if not null
     * @param src builder to store
     * @returns this builder
     */
    storeMaybeBuilder(src2) {
      if (src2) {
        this.storeBit(1);
        this.storeBuilder(src2);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store writer or builder
     * @param writer writer or builder to store
     * @returns this builder
     */
    storeWritable(writer) {
      if (typeof writer === "object") {
        writer.writeTo(this);
      } else {
        writer(this);
      }
      return this;
    }
    /**
     * Store writer or builder if not null
     * @param writer writer or builder to store
     * @returns this builder
     */
    storeMaybeWritable(writer) {
      if (writer) {
        this.storeBit(1);
        this.storeWritable(writer);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store object in this builder
     * @param writer Writable or writer functuin
     */
    store(writer) {
      this.storeWritable(writer);
      return this;
    }
    /**
     * Store string tail
     * @param src source string
     * @returns this builder
     */
    storeStringTail(src2) {
      (0, strings_1.writeString)(src2, this);
      return this;
    }
    /**
     * Store string tail
     * @param src source string
     * @returns this builder
     */
    storeMaybeStringTail(src2) {
      if (src2 !== null && src2 !== void 0) {
        this.storeBit(1);
        (0, strings_1.writeString)(src2, this);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store string tail in ref
     * @param src source string
     * @returns this builder
     */
    storeStringRefTail(src2) {
      this.storeRef(beginCell().storeStringTail(src2));
      return this;
    }
    /**
     * Store maybe string tail in ref
     * @param src source string
     * @returns this builder
     */
    storeMaybeStringRefTail(src2) {
      if (src2 !== null && src2 !== void 0) {
        this.storeBit(1);
        this.storeStringRefTail(src2);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store dictionary in this builder
     * @param dict dictionary to store
     * @returns this builder
     */
    storeDict(dict, key2, value) {
      if (dict) {
        dict.store(this, key2, value);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store dictionary in this builder directly
     * @param dict dictionary to store
     * @returns this builder
     */
    storeDictDirect(dict, key2, value) {
      dict.storeDirect(this, key2, value);
      return this;
    }
    /**
     * Complete cell
     * @param opts options
     * @returns cell
     */
    endCell(opts) {
      return new Cell_1.Cell({
        bits: this._bits.build(),
        refs: this._refs,
        exotic: opts?.exotic
      });
    }
    /**
     * Convert to cell
     * @returns cell
     */
    asCell() {
      return this.endCell();
    }
    /**
     * Convert to slice
     * @returns slice
     */
    asSlice() {
      return this.endCell().beginParse();
    }
  }
  Builder$4.Builder = Builder2;
  return Builder$4;
}
var StateInit$1 = {};
var SimpleLibrary$1 = {};
var hasRequiredSimpleLibrary$1;
function requireSimpleLibrary$1() {
  if (hasRequiredSimpleLibrary$1) return SimpleLibrary$1;
  hasRequiredSimpleLibrary$1 = 1;
  Object.defineProperty(SimpleLibrary$1, "__esModule", { value: true });
  SimpleLibrary$1.SimpleLibraryValue = SimpleLibrary$1.storeSimpleLibrary = SimpleLibrary$1.loadSimpleLibrary = void 0;
  function loadSimpleLibrary(slice) {
    return {
      public: slice.loadBit(),
      root: slice.loadRef()
    };
  }
  SimpleLibrary$1.loadSimpleLibrary = loadSimpleLibrary;
  function storeSimpleLibrary(src2) {
    return (builder2) => {
      builder2.storeBit(src2.public);
      builder2.storeRef(src2.root);
    };
  }
  SimpleLibrary$1.storeSimpleLibrary = storeSimpleLibrary;
  SimpleLibrary$1.SimpleLibraryValue = {
    serialize(src2, builder2) {
      storeSimpleLibrary(src2)(builder2);
    },
    parse(src2) {
      return loadSimpleLibrary(src2);
    }
  };
  return SimpleLibrary$1;
}
var TickTock$1 = {};
var hasRequiredTickTock$1;
function requireTickTock$1() {
  if (hasRequiredTickTock$1) return TickTock$1;
  hasRequiredTickTock$1 = 1;
  Object.defineProperty(TickTock$1, "__esModule", { value: true });
  TickTock$1.storeTickTock = TickTock$1.loadTickTock = void 0;
  function loadTickTock(slice) {
    return {
      tick: slice.loadBit(),
      tock: slice.loadBit()
    };
  }
  TickTock$1.loadTickTock = loadTickTock;
  function storeTickTock(src2) {
    return (builder2) => {
      builder2.storeBit(src2.tick);
      builder2.storeBit(src2.tock);
    };
  }
  TickTock$1.storeTickTock = storeTickTock;
  return TickTock$1;
}
var hasRequiredStateInit$1;
function requireStateInit$1() {
  if (hasRequiredStateInit$1) return StateInit$1;
  hasRequiredStateInit$1 = 1;
  Object.defineProperty(StateInit$1, "__esModule", { value: true });
  StateInit$1.storeStateInit = StateInit$1.loadStateInit = void 0;
  const Dictionary_1 = requireDictionary$1();
  const SimpleLibrary_1 = requireSimpleLibrary$1();
  const TickTock_1 = requireTickTock$1();
  function loadStateInit(slice) {
    let splitDepth;
    if (slice.loadBit()) {
      splitDepth = slice.loadUint(5);
    }
    let special;
    if (slice.loadBit()) {
      special = (0, TickTock_1.loadTickTock)(slice);
    }
    let code = slice.loadMaybeRef();
    let data = slice.loadMaybeRef();
    let libraries = slice.loadDict(Dictionary_1.Dictionary.Keys.BigUint(256), SimpleLibrary_1.SimpleLibraryValue);
    if (libraries.size === 0) {
      libraries = void 0;
    }
    return {
      splitDepth,
      special,
      code,
      data,
      libraries
    };
  }
  StateInit$1.loadStateInit = loadStateInit;
  function storeStateInit(src2) {
    return (builder2) => {
      if (src2.splitDepth !== null && src2.splitDepth !== void 0) {
        builder2.storeBit(true);
        builder2.storeUint(src2.splitDepth, 5);
      } else {
        builder2.storeBit(false);
      }
      if (src2.special !== null && src2.special !== void 0) {
        builder2.storeBit(true);
        builder2.store((0, TickTock_1.storeTickTock)(src2.special));
      } else {
        builder2.storeBit(false);
      }
      builder2.storeMaybeRef(src2.code);
      builder2.storeMaybeRef(src2.data);
      builder2.storeDict(src2.libraries);
    };
  }
  StateInit$1.storeStateInit = storeStateInit;
  return StateInit$1;
}
var hasRequiredContractAddress$1;
function requireContractAddress$1() {
  if (hasRequiredContractAddress$1) return contractAddress$1;
  hasRequiredContractAddress$1 = 1;
  Object.defineProperty(contractAddress$1, "__esModule", { value: true });
  contractAddress$1.contractAddress = void 0;
  const Builder_12 = requireBuilder$3();
  const StateInit_1 = requireStateInit$1();
  const Address_1 = requireAddress$1();
  function contractAddress2(workchain, init) {
    let hash = (0, Builder_12.beginCell)().store((0, StateInit_1.storeStateInit)(init)).endCell().hash();
    return new Address_1.Address(workchain, hash);
  }
  contractAddress$1.contractAddress = contractAddress2;
  return contractAddress$1;
}
var tuple$1 = {};
var hasRequiredTuple$1;
function requireTuple$1() {
  if (hasRequiredTuple$1) return tuple$1;
  hasRequiredTuple$1 = 1;
  Object.defineProperty(tuple$1, "__esModule", { value: true });
  tuple$1.parseTuple = tuple$1.serializeTuple = tuple$1.parseTupleItem = tuple$1.serializeTupleItem = void 0;
  const Builder_12 = requireBuilder$3();
  const INT64_MIN = BigInt("-9223372036854775808");
  const INT64_MAX = BigInt("9223372036854775807");
  function serializeTupleItem(src2, builder2) {
    if (src2.type === "null") {
      builder2.storeUint(0, 8);
    } else if (src2.type === "int") {
      if (src2.value <= INT64_MAX && src2.value >= INT64_MIN) {
        builder2.storeUint(1, 8);
        builder2.storeInt(src2.value, 64);
      } else {
        builder2.storeUint(256, 15);
        builder2.storeInt(src2.value, 257);
      }
    } else if (src2.type === "nan") {
      builder2.storeInt(767, 16);
    } else if (src2.type === "cell") {
      builder2.storeUint(3, 8);
      builder2.storeRef(src2.cell);
    } else if (src2.type === "slice") {
      builder2.storeUint(4, 8);
      builder2.storeUint(0, 10);
      builder2.storeUint(src2.cell.bits.length, 10);
      builder2.storeUint(0, 3);
      builder2.storeUint(src2.cell.refs.length, 3);
      builder2.storeRef(src2.cell);
    } else if (src2.type === "builder") {
      builder2.storeUint(5, 8);
      builder2.storeRef(src2.cell);
    } else if (src2.type === "tuple") {
      let head = null;
      let tail = null;
      for (let i = 0; i < src2.items.length; i++) {
        let s = head;
        head = tail;
        tail = s;
        if (i > 1) {
          head = (0, Builder_12.beginCell)().storeRef(tail).storeRef(head).endCell();
        }
        let bc = (0, Builder_12.beginCell)();
        serializeTupleItem(src2.items[i], bc);
        tail = bc.endCell();
      }
      builder2.storeUint(7, 8);
      builder2.storeUint(src2.items.length, 16);
      if (head) {
        builder2.storeRef(head);
      }
      if (tail) {
        builder2.storeRef(tail);
      }
    } else {
      throw Error("Invalid value");
    }
  }
  tuple$1.serializeTupleItem = serializeTupleItem;
  function parseTupleItem(cs) {
    let kind = cs.loadUint(8);
    if (kind === 0) {
      return { type: "null" };
    } else if (kind === 1) {
      return { type: "int", value: cs.loadIntBig(64) };
    } else if (kind === 2) {
      if (cs.loadUint(7) === 0) {
        return { type: "int", value: cs.loadIntBig(257) };
      } else {
        cs.loadBit();
        return { type: "nan" };
      }
    } else if (kind === 3) {
      return { type: "cell", cell: cs.loadRef() };
    } else if (kind === 4) {
      let startBits = cs.loadUint(10);
      let endBits = cs.loadUint(10);
      let startRefs = cs.loadUint(3);
      let endRefs = cs.loadUint(3);
      let rs = cs.loadRef().beginParse();
      rs.skip(startBits);
      let dt2 = rs.loadBits(endBits - startBits);
      let builder2 = (0, Builder_12.beginCell)().storeBits(dt2);
      if (startRefs < endRefs) {
        for (let i = 0; i < startRefs; i++) {
          rs.loadRef();
        }
        for (let i = 0; i < endRefs - startRefs; i++) {
          builder2.storeRef(rs.loadRef());
        }
      }
      return { type: "slice", cell: builder2.endCell() };
    } else if (kind === 5) {
      return { type: "builder", cell: cs.loadRef() };
    } else if (kind === 7) {
      let length = cs.loadUint(16);
      let items = [];
      if (length > 1) {
        let head = cs.loadRef().beginParse();
        let tail = cs.loadRef().beginParse();
        items.unshift(parseTupleItem(tail));
        for (let i = 0; i < length - 2; i++) {
          let ohead = head;
          head = ohead.loadRef().beginParse();
          tail = ohead.loadRef().beginParse();
          items.unshift(parseTupleItem(tail));
        }
        items.unshift(parseTupleItem(head));
      } else if (length === 1) {
        items.push(parseTupleItem(cs.loadRef().beginParse()));
      }
      return { type: "tuple", items };
    } else {
      throw Error("Unsupported stack item");
    }
  }
  tuple$1.parseTupleItem = parseTupleItem;
  function serializeTupleTail(src2, builder2) {
    if (src2.length > 0) {
      let tail = (0, Builder_12.beginCell)();
      serializeTupleTail(src2.slice(0, src2.length - 1), tail);
      builder2.storeRef(tail.endCell());
      serializeTupleItem(src2[src2.length - 1], builder2);
    }
  }
  function serializeTuple(src2) {
    let builder2 = (0, Builder_12.beginCell)();
    builder2.storeUint(src2.length, 24);
    let r = [...src2];
    serializeTupleTail(r, builder2);
    return builder2.endCell();
  }
  tuple$1.serializeTuple = serializeTuple;
  function parseTuple(src2) {
    let res = [];
    let cs = src2.beginParse();
    let size = cs.loadUint(24);
    for (let i = 0; i < size; i++) {
      let next = cs.loadRef();
      res.unshift(parseTupleItem(cs));
      cs = next.beginParse();
    }
    return res;
  }
  tuple$1.parseTuple = parseTuple;
  return tuple$1;
}
var reader$1 = {};
var hasRequiredReader$1;
function requireReader$1() {
  if (hasRequiredReader$1) return reader$1;
  hasRequiredReader$1 = 1;
  Object.defineProperty(reader$1, "__esModule", { value: true });
  reader$1.TupleReader = void 0;
  class TupleReader {
    constructor(items) {
      this.items = [...items];
    }
    get remaining() {
      return this.items.length;
    }
    peek() {
      if (this.items.length === 0) {
        throw Error("EOF");
      }
      return this.items[0];
    }
    pop() {
      if (this.items.length === 0) {
        throw Error("EOF");
      }
      let res = this.items[0];
      this.items.splice(0, 1);
      return res;
    }
    skip(num = 1) {
      for (let i = 0; i < num; i++) {
        this.pop();
      }
      return this;
    }
    readBigNumber() {
      let popped = this.pop();
      if (popped.type !== "int") {
        throw Error("Not a number");
      }
      return popped.value;
    }
    readBigNumberOpt() {
      let popped = this.pop();
      if (popped.type === "null") {
        return null;
      }
      if (popped.type !== "int") {
        throw Error("Not a number");
      }
      return popped.value;
    }
    readNumber() {
      return Number(this.readBigNumber());
    }
    readNumberOpt() {
      let r = this.readBigNumberOpt();
      if (r !== null) {
        return Number(r);
      } else {
        return null;
      }
    }
    readBoolean() {
      let res = this.readNumber();
      return res === 0 ? false : true;
    }
    readBooleanOpt() {
      let res = this.readNumberOpt();
      if (res !== null) {
        return res === 0 ? false : true;
      } else {
        return null;
      }
    }
    readAddress() {
      let r = this.readCell().beginParse().loadAddress();
      if (r !== null) {
        return r;
      } else {
        throw Error("Not an address");
      }
    }
    readAddressOpt() {
      let r = this.readCellOpt();
      if (r !== null) {
        return r.beginParse().loadMaybeAddress();
      } else {
        return null;
      }
    }
    readCell() {
      let popped = this.pop();
      if (popped.type !== "cell" && popped.type !== "slice" && popped.type !== "builder") {
        throw Error("Not a cell: " + popped.type);
      }
      return popped.cell;
    }
    readCellOpt() {
      let popped = this.pop();
      if (popped.type === "null") {
        return null;
      }
      if (popped.type !== "cell" && popped.type !== "slice" && popped.type !== "builder") {
        throw Error("Not a cell");
      }
      return popped.cell;
    }
    readTuple() {
      let popped = this.pop();
      if (popped.type !== "tuple") {
        throw Error("Not a tuple");
      }
      return new TupleReader(popped.items);
    }
    readTupleOpt() {
      let popped = this.pop();
      if (popped.type === "null") {
        return null;
      }
      if (popped.type !== "tuple") {
        throw Error("Not a tuple");
      }
      return new TupleReader(popped.items);
    }
    static readLispList(reader2) {
      const result = [];
      let tail = reader2;
      while (tail !== null) {
        var head = tail.pop();
        if (tail.items.length === 0 || tail.items[0].type !== "tuple" && tail.items[0].type !== "null") {
          throw Error("Lisp list consists only from (any, tuple) elements and ends with null");
        }
        tail = tail.readTupleOpt();
        result.push(head);
      }
      return result;
    }
    readLispListDirect() {
      if (this.items.length === 1 && this.items[0].type === "null") {
        return [];
      }
      return TupleReader.readLispList(this);
    }
    readLispList() {
      return TupleReader.readLispList(this.readTupleOpt());
    }
    readBuffer() {
      let s = this.readCell().beginParse();
      if (s.remainingRefs !== 0) {
        throw Error("Not a buffer");
      }
      if (s.remainingBits % 8 !== 0) {
        throw Error("Not a buffer");
      }
      return s.loadBuffer(s.remainingBits / 8);
    }
    readBufferOpt() {
      let r = this.readCellOpt();
      if (r !== null) {
        let s = r.beginParse();
        if (s.remainingRefs !== 0 || s.remainingBits % 8 !== 0) {
          throw Error("Not a buffer");
        }
        return s.loadBuffer(s.remainingBits / 8);
      } else {
        return null;
      }
    }
    readString() {
      let s = this.readCell().beginParse();
      return s.loadStringTail();
    }
    readStringOpt() {
      let r = this.readCellOpt();
      if (r !== null) {
        let s = r.beginParse();
        return s.loadStringTail();
      } else {
        return null;
      }
    }
  }
  reader$1.TupleReader = TupleReader;
  return reader$1;
}
var builder$1 = {};
var hasRequiredBuilder$2;
function requireBuilder$2() {
  if (hasRequiredBuilder$2) return builder$1;
  hasRequiredBuilder$2 = 1;
  Object.defineProperty(builder$1, "__esModule", { value: true });
  builder$1.TupleBuilder = void 0;
  const Builder_12 = requireBuilder$3();
  const Cell_1 = requireCell$1();
  const Slice_1 = requireSlice$1();
  class TupleBuilder {
    constructor() {
      this._tuple = [];
    }
    writeNumber(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        this._tuple.push({ type: "int", value: BigInt(v2) });
      }
    }
    writeBoolean(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        this._tuple.push({ type: "int", value: v2 ? -1n : 0n });
      }
    }
    writeBuffer(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        this._tuple.push({ type: "slice", cell: (0, Builder_12.beginCell)().storeBuffer(v2).endCell() });
      }
    }
    writeString(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        this._tuple.push({ type: "slice", cell: (0, Builder_12.beginCell)().storeStringTail(v2).endCell() });
      }
    }
    writeCell(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        if (v2 instanceof Cell_1.Cell) {
          this._tuple.push({ type: "cell", cell: v2 });
        } else if (v2 instanceof Slice_1.Slice) {
          this._tuple.push({ type: "cell", cell: v2.asCell() });
        }
      }
    }
    writeSlice(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        if (v2 instanceof Cell_1.Cell) {
          this._tuple.push({ type: "slice", cell: v2 });
        } else if (v2 instanceof Slice_1.Slice) {
          this._tuple.push({ type: "slice", cell: v2.asCell() });
        }
      }
    }
    writeBuilder(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        if (v2 instanceof Cell_1.Cell) {
          this._tuple.push({ type: "builder", cell: v2 });
        } else if (v2 instanceof Slice_1.Slice) {
          this._tuple.push({ type: "builder", cell: v2.asCell() });
        }
      }
    }
    writeTuple(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        this._tuple.push({ type: "tuple", items: v2 });
      }
    }
    writeAddress(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        this._tuple.push({ type: "slice", cell: (0, Builder_12.beginCell)().storeAddress(v2).endCell() });
      }
    }
    build() {
      return [...this._tuple];
    }
  }
  builder$1.TupleBuilder = TupleBuilder;
  return builder$1;
}
var _export$1 = {};
var _helpers$1 = {};
var convert$1 = {};
var hasRequiredConvert$1;
function requireConvert$1() {
  if (hasRequiredConvert$1) return convert$1;
  hasRequiredConvert$1 = 1;
  Object.defineProperty(convert$1, "__esModule", { value: true });
  convert$1.fromNano = convert$1.toNano = void 0;
  function toNano(src2) {
    if (typeof src2 === "bigint") {
      return src2 * 1000000000n;
    } else {
      if (typeof src2 === "number") {
        if (!Number.isFinite(src2)) {
          throw Error("Invalid number");
        }
        if (Math.log10(src2) <= 6) {
          src2 = src2.toLocaleString("en", { minimumFractionDigits: 9, useGrouping: false });
        } else if (src2 - Math.trunc(src2) === 0) {
          src2 = src2.toLocaleString("en", { maximumFractionDigits: 0, useGrouping: false });
        } else {
          throw Error("Not enough precision for a number value. Use string value instead");
        }
      }
      let neg = false;
      while (src2.startsWith("-")) {
        neg = !neg;
        src2 = src2.slice(1);
      }
      if (src2 === ".") {
        throw Error("Invalid number");
      }
      let parts = src2.split(".");
      if (parts.length > 2) {
        throw Error("Invalid number");
      }
      let whole = parts[0];
      let frac = parts[1];
      if (!whole) {
        whole = "0";
      }
      if (!frac) {
        frac = "0";
      }
      if (frac.length > 9) {
        throw Error("Invalid number");
      }
      while (frac.length < 9) {
        frac += "0";
      }
      let r = BigInt(whole) * 1000000000n + BigInt(frac);
      if (neg) {
        r = -r;
      }
      return r;
    }
  }
  convert$1.toNano = toNano;
  function fromNano(src2) {
    let v2 = BigInt(src2);
    let neg = false;
    if (v2 < 0) {
      neg = true;
      v2 = -v2;
    }
    let frac = v2 % 1000000000n;
    let facStr = frac.toString();
    while (facStr.length < 9) {
      facStr = "0" + facStr;
    }
    facStr = facStr.match(/^([0-9]*[1-9]|0)(0*)/)[1];
    let whole = v2 / 1000000000n;
    let wholeStr = whole.toString();
    let value = `${wholeStr}${facStr === "0" ? "" : `.${facStr}`}`;
    if (neg) {
      value = "-" + value;
    }
    return value;
  }
  convert$1.fromNano = fromNano;
  return convert$1;
}
var ExtraCurrency$1 = {};
var hasRequiredExtraCurrency$1;
function requireExtraCurrency$1() {
  if (hasRequiredExtraCurrency$1) return ExtraCurrency$1;
  hasRequiredExtraCurrency$1 = 1;
  Object.defineProperty(ExtraCurrency$1, "__esModule", { value: true });
  ExtraCurrency$1.packExtraCurrencyCell = ExtraCurrency$1.packExtraCurrencyDict = ExtraCurrency$1.storeExtraCurrency = ExtraCurrency$1.loadMaybeExtraCurrency = ExtraCurrency$1.loadExtraCurrency = void 0;
  const Builder_12 = requireBuilder$3();
  const Dictionary_1 = requireDictionary$1();
  function loadExtraCurrency(data) {
    let ecDict = data instanceof Dictionary_1.Dictionary ? data : Dictionary_1.Dictionary.loadDirect(Dictionary_1.Dictionary.Keys.Uint(32), Dictionary_1.Dictionary.Values.BigVarUint(5), data);
    let ecMap = {};
    for (let [k, v2] of ecDict) {
      ecMap[k] = v2;
    }
    return ecMap;
  }
  ExtraCurrency$1.loadExtraCurrency = loadExtraCurrency;
  function loadMaybeExtraCurrency(data) {
    const ecData = data.loadMaybeRef();
    return ecData === null ? ecData : loadExtraCurrency(ecData);
  }
  ExtraCurrency$1.loadMaybeExtraCurrency = loadMaybeExtraCurrency;
  function storeExtraCurrency(extracurrency) {
    return (builder2) => {
      builder2.storeDict(packExtraCurrencyDict(extracurrency));
    };
  }
  ExtraCurrency$1.storeExtraCurrency = storeExtraCurrency;
  function packExtraCurrencyDict(extracurrency) {
    const resEc = Dictionary_1.Dictionary.empty(Dictionary_1.Dictionary.Keys.Uint(32), Dictionary_1.Dictionary.Values.BigVarUint(5));
    Object.entries(extracurrency).map(([k, v2]) => resEc.set(Number(k), v2));
    return resEc;
  }
  ExtraCurrency$1.packExtraCurrencyDict = packExtraCurrencyDict;
  function packExtraCurrencyCell(extracurrency) {
    return (0, Builder_12.beginCell)().storeDictDirect(packExtraCurrencyDict(extracurrency)).endCell();
  }
  ExtraCurrency$1.packExtraCurrencyCell = packExtraCurrencyCell;
  return ExtraCurrency$1;
}
var hasRequired_helpers$1;
function require_helpers$1() {
  if (hasRequired_helpers$1) return _helpers$1;
  hasRequired_helpers$1 = 1;
  Object.defineProperty(_helpers$1, "__esModule", { value: true });
  _helpers$1.comment = _helpers$1.external = _helpers$1.internal = void 0;
  const Address_1 = requireAddress$1();
  const Cell_1 = requireCell$1();
  const Builder_12 = requireBuilder$3();
  const convert_1 = requireConvert$1();
  const ExtraCurrency_1 = requireExtraCurrency$1();
  function internal(src2) {
    let bounce = true;
    if (src2.bounce !== null && src2.bounce !== void 0) {
      bounce = src2.bounce;
    }
    let to;
    if (typeof src2.to === "string") {
      to = Address_1.Address.parse(src2.to);
    } else if (Address_1.Address.isAddress(src2.to)) {
      to = src2.to;
    } else {
      throw new Error(`Invalid address ${src2.to}`);
    }
    let value;
    if (typeof src2.value === "string") {
      value = (0, convert_1.toNano)(src2.value);
    } else {
      value = src2.value;
    }
    let other;
    if (src2.extracurrency) {
      other = (0, ExtraCurrency_1.packExtraCurrencyDict)(src2.extracurrency);
    }
    let body = Cell_1.Cell.EMPTY;
    if (typeof src2.body === "string") {
      body = (0, Builder_12.beginCell)().storeUint(0, 32).storeStringTail(src2.body).endCell();
    } else if (src2.body) {
      body = src2.body;
    }
    return {
      info: {
        type: "internal",
        dest: to,
        value: { coins: value, other },
        bounce,
        ihrDisabled: true,
        bounced: false,
        ihrFee: 0n,
        forwardFee: 0n,
        createdAt: 0,
        createdLt: 0n
      },
      init: src2.init ?? void 0,
      body
    };
  }
  _helpers$1.internal = internal;
  function external2(src2) {
    let to;
    if (typeof src2.to === "string") {
      to = Address_1.Address.parse(src2.to);
    } else if (Address_1.Address.isAddress(src2.to)) {
      to = src2.to;
    } else {
      throw new Error(`Invalid address ${src2.to}`);
    }
    return {
      info: {
        type: "external-in",
        dest: to,
        importFee: 0n
      },
      init: src2.init ?? void 0,
      body: src2.body || Cell_1.Cell.EMPTY
    };
  }
  _helpers$1.external = external2;
  function comment(src2) {
    return (0, Builder_12.beginCell)().storeUint(0, 32).storeStringTail(src2).endCell();
  }
  _helpers$1.comment = comment;
  return _helpers$1;
}
var Account$1 = {};
var AccountStorage$1 = {};
var AccountState$1 = {};
var hasRequiredAccountState$1;
function requireAccountState$1() {
  if (hasRequiredAccountState$1) return AccountState$1;
  hasRequiredAccountState$1 = 1;
  Object.defineProperty(AccountState$1, "__esModule", { value: true });
  AccountState$1.storeAccountState = AccountState$1.loadAccountState = void 0;
  const StateInit_1 = requireStateInit$1();
  function loadAccountState(cs) {
    if (cs.loadBit()) {
      return { type: "active", state: (0, StateInit_1.loadStateInit)(cs) };
    } else if (cs.loadBit()) {
      return { type: "frozen", stateHash: cs.loadUintBig(256) };
    } else {
      return { type: "uninit" };
    }
  }
  AccountState$1.loadAccountState = loadAccountState;
  function storeAccountState(src2) {
    return (builder2) => {
      if (src2.type === "active") {
        builder2.storeBit(true);
        builder2.store((0, StateInit_1.storeStateInit)(src2.state));
      } else if (src2.type === "frozen") {
        builder2.storeBit(false);
        builder2.storeBit(true);
        builder2.storeUint(src2.stateHash, 256);
      } else if (src2.type === "uninit") {
        builder2.storeBit(false);
        builder2.storeBit(false);
      }
    };
  }
  AccountState$1.storeAccountState = storeAccountState;
  return AccountState$1;
}
var CurrencyCollection$1 = {};
var hasRequiredCurrencyCollection$1;
function requireCurrencyCollection$1() {
  if (hasRequiredCurrencyCollection$1) return CurrencyCollection$1;
  hasRequiredCurrencyCollection$1 = 1;
  Object.defineProperty(CurrencyCollection$1, "__esModule", { value: true });
  CurrencyCollection$1.storeCurrencyCollection = CurrencyCollection$1.loadCurrencyCollection = void 0;
  const Dictionary_1 = requireDictionary$1();
  function loadCurrencyCollection(slice) {
    const coins = slice.loadCoins();
    const other = slice.loadDict(Dictionary_1.Dictionary.Keys.Uint(32), Dictionary_1.Dictionary.Values.BigVarUint(
      5
      /* log2(32) */
    ));
    if (other.size === 0) {
      return { coins };
    } else {
      return { other, coins };
    }
  }
  CurrencyCollection$1.loadCurrencyCollection = loadCurrencyCollection;
  function storeCurrencyCollection(collection) {
    return (builder2) => {
      builder2.storeCoins(collection.coins);
      if (collection.other) {
        builder2.storeDict(collection.other);
      } else {
        builder2.storeBit(0);
      }
    };
  }
  CurrencyCollection$1.storeCurrencyCollection = storeCurrencyCollection;
  return CurrencyCollection$1;
}
var hasRequiredAccountStorage$1;
function requireAccountStorage$1() {
  if (hasRequiredAccountStorage$1) return AccountStorage$1;
  hasRequiredAccountStorage$1 = 1;
  Object.defineProperty(AccountStorage$1, "__esModule", { value: true });
  AccountStorage$1.storeAccountStorage = AccountStorage$1.loadAccountStorage = void 0;
  const AccountState_1 = requireAccountState$1();
  const CurrencyCollection_1 = requireCurrencyCollection$1();
  function loadAccountStorage(slice) {
    return {
      lastTransLt: slice.loadUintBig(64),
      balance: (0, CurrencyCollection_1.loadCurrencyCollection)(slice),
      state: (0, AccountState_1.loadAccountState)(slice)
    };
  }
  AccountStorage$1.loadAccountStorage = loadAccountStorage;
  function storeAccountStorage(src2) {
    return (builder2) => {
      builder2.storeUint(src2.lastTransLt, 64);
      builder2.store((0, CurrencyCollection_1.storeCurrencyCollection)(src2.balance));
      builder2.store((0, AccountState_1.storeAccountState)(src2.state));
    };
  }
  AccountStorage$1.storeAccountStorage = storeAccountStorage;
  return AccountStorage$1;
}
var StorageInfo$1 = {};
var StorageExtraInfo$1 = {};
var hasRequiredStorageExtraInfo$1;
function requireStorageExtraInfo$1() {
  if (hasRequiredStorageExtraInfo$1) return StorageExtraInfo$1;
  hasRequiredStorageExtraInfo$1 = 1;
  Object.defineProperty(StorageExtraInfo$1, "__esModule", { value: true });
  StorageExtraInfo$1.storeStorageExtraInfo = StorageExtraInfo$1.loadStorageExtraInfo = void 0;
  function loadStorageExtraInfo(slice) {
    let header = slice.loadUint(3);
    if (header === 0) {
      return null;
    }
    if (header === 1) {
      return {
        dictHash: slice.loadUintBig(256)
      };
    }
    throw new Error(`Invalid storage extra info header: ${header}`);
  }
  StorageExtraInfo$1.loadStorageExtraInfo = loadStorageExtraInfo;
  function storeStorageExtraInfo(src2) {
    return (builder2) => {
      if (src2 === null || typeof src2 === "undefined") {
        builder2.storeUint(0, 3);
      } else {
        builder2.storeUint(1, 3);
        builder2.storeUint(src2.dictHash, 256);
      }
    };
  }
  StorageExtraInfo$1.storeStorageExtraInfo = storeStorageExtraInfo;
  return StorageExtraInfo$1;
}
var StorageUsed$1 = {};
var hasRequiredStorageUsed$1;
function requireStorageUsed$1() {
  if (hasRequiredStorageUsed$1) return StorageUsed$1;
  hasRequiredStorageUsed$1 = 1;
  Object.defineProperty(StorageUsed$1, "__esModule", { value: true });
  StorageUsed$1.storeStorageUsed = StorageUsed$1.loadStorageUsed = void 0;
  function loadStorageUsed(cs) {
    return {
      cells: cs.loadVarUintBig(3),
      bits: cs.loadVarUintBig(3)
    };
  }
  StorageUsed$1.loadStorageUsed = loadStorageUsed;
  function storeStorageUsed(src2) {
    return (builder2) => {
      builder2.storeVarUint(src2.cells, 3);
      builder2.storeVarUint(src2.bits, 3);
    };
  }
  StorageUsed$1.storeStorageUsed = storeStorageUsed;
  return StorageUsed$1;
}
var hasRequiredStorageInfo$1;
function requireStorageInfo$1() {
  if (hasRequiredStorageInfo$1) return StorageInfo$1;
  hasRequiredStorageInfo$1 = 1;
  Object.defineProperty(StorageInfo$1, "__esModule", { value: true });
  StorageInfo$1.storeStorageInfo = StorageInfo$1.loadStorageInfo = void 0;
  const StorageExtraInfo_1 = requireStorageExtraInfo$1();
  const StorageUsed_1 = requireStorageUsed$1();
  function loadStorageInfo(slice) {
    return {
      used: (0, StorageUsed_1.loadStorageUsed)(slice),
      storageExtra: (0, StorageExtraInfo_1.loadStorageExtraInfo)(slice),
      lastPaid: slice.loadUint(32),
      duePayment: slice.loadMaybeCoins()
    };
  }
  StorageInfo$1.loadStorageInfo = loadStorageInfo;
  function storeStorageInfo(src2) {
    return (builder2) => {
      builder2.store((0, StorageUsed_1.storeStorageUsed)(src2.used));
      builder2.store((0, StorageExtraInfo_1.storeStorageExtraInfo)(src2.storageExtra));
      builder2.storeUint(src2.lastPaid, 32);
      builder2.storeMaybeCoins(src2.duePayment);
    };
  }
  StorageInfo$1.storeStorageInfo = storeStorageInfo;
  return StorageInfo$1;
}
var hasRequiredAccount$1;
function requireAccount$1() {
  if (hasRequiredAccount$1) return Account$1;
  hasRequiredAccount$1 = 1;
  Object.defineProperty(Account$1, "__esModule", { value: true });
  Account$1.storeAccount = Account$1.loadAccount = void 0;
  const AccountStorage_1 = requireAccountStorage$1();
  const StorageInfo_1 = requireStorageInfo$1();
  function loadAccount(slice) {
    return {
      addr: slice.loadAddress(),
      storageStats: (0, StorageInfo_1.loadStorageInfo)(slice),
      storage: (0, AccountStorage_1.loadAccountStorage)(slice)
    };
  }
  Account$1.loadAccount = loadAccount;
  function storeAccount(src2) {
    return (builder2) => {
      builder2.storeAddress(src2.addr);
      builder2.store((0, StorageInfo_1.storeStorageInfo)(src2.storageStats));
      builder2.store((0, AccountStorage_1.storeAccountStorage)(src2.storage));
    };
  }
  Account$1.storeAccount = storeAccount;
  return Account$1;
}
var AccountStatus$1 = {};
var hasRequiredAccountStatus$1;
function requireAccountStatus$1() {
  if (hasRequiredAccountStatus$1) return AccountStatus$1;
  hasRequiredAccountStatus$1 = 1;
  Object.defineProperty(AccountStatus$1, "__esModule", { value: true });
  AccountStatus$1.storeAccountStatus = AccountStatus$1.loadAccountStatus = void 0;
  function loadAccountStatus(slice) {
    const status = slice.loadUint(2);
    if (status === 0) {
      return "uninitialized";
    }
    if (status === 1) {
      return "frozen";
    }
    if (status === 2) {
      return "active";
    }
    if (status === 3) {
      return "non-existing";
    }
    throw Error("Invalid data");
  }
  AccountStatus$1.loadAccountStatus = loadAccountStatus;
  function storeAccountStatus(src2) {
    return (builder2) => {
      if (src2 === "uninitialized") {
        builder2.storeUint(0, 2);
      } else if (src2 === "frozen") {
        builder2.storeUint(1, 2);
      } else if (src2 === "active") {
        builder2.storeUint(2, 2);
      } else if (src2 === "non-existing") {
        builder2.storeUint(3, 2);
      } else {
        throw Error("Invalid data");
      }
      return builder2;
    };
  }
  AccountStatus$1.storeAccountStatus = storeAccountStatus;
  return AccountStatus$1;
}
var AccountStatusChange$1 = {};
var hasRequiredAccountStatusChange$1;
function requireAccountStatusChange$1() {
  if (hasRequiredAccountStatusChange$1) return AccountStatusChange$1;
  hasRequiredAccountStatusChange$1 = 1;
  Object.defineProperty(AccountStatusChange$1, "__esModule", { value: true });
  AccountStatusChange$1.storeAccountStatusChange = AccountStatusChange$1.loadAccountStatusChange = void 0;
  function loadAccountStatusChange(slice) {
    if (!slice.loadBit()) {
      return "unchanged";
    }
    if (slice.loadBit()) {
      return "deleted";
    } else {
      return "frozen";
    }
  }
  AccountStatusChange$1.loadAccountStatusChange = loadAccountStatusChange;
  function storeAccountStatusChange(src2) {
    return (builder2) => {
      if (src2 == "unchanged") {
        builder2.storeBit(0);
      } else if (src2 === "frozen") {
        builder2.storeBit(1);
        builder2.storeBit(0);
      } else if (src2 === "deleted") {
        builder2.storeBit(1);
        builder2.storeBit(1);
      } else {
        throw Error("Invalid account status change");
      }
    };
  }
  AccountStatusChange$1.storeAccountStatusChange = storeAccountStatusChange;
  return AccountStatusChange$1;
}
var OutList$1 = {};
var MessageRelaxed$1 = {};
var CommonMessageInfoRelaxed$1 = {};
var hasRequiredCommonMessageInfoRelaxed$1;
function requireCommonMessageInfoRelaxed$1() {
  if (hasRequiredCommonMessageInfoRelaxed$1) return CommonMessageInfoRelaxed$1;
  hasRequiredCommonMessageInfoRelaxed$1 = 1;
  Object.defineProperty(CommonMessageInfoRelaxed$1, "__esModule", { value: true });
  CommonMessageInfoRelaxed$1.storeCommonMessageInfoRelaxed = CommonMessageInfoRelaxed$1.loadCommonMessageInfoRelaxed = void 0;
  const CurrencyCollection_1 = requireCurrencyCollection$1();
  function loadCommonMessageInfoRelaxed(slice) {
    if (!slice.loadBit()) {
      const ihrDisabled = slice.loadBit();
      const bounce = slice.loadBit();
      const bounced = slice.loadBit();
      const src3 = slice.loadMaybeAddress();
      const dest2 = slice.loadAddress();
      const value = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
      const ihrFee = slice.loadCoins();
      const forwardFee = slice.loadCoins();
      const createdLt2 = slice.loadUintBig(64);
      const createdAt2 = slice.loadUint(32);
      return {
        type: "internal",
        ihrDisabled,
        bounce,
        bounced,
        src: src3,
        dest: dest2,
        value,
        ihrFee,
        forwardFee,
        createdLt: createdLt2,
        createdAt: createdAt2
      };
    }
    if (!slice.loadBit()) {
      throw Error("External In message is not possible for CommonMessageInfoRelaxed");
    }
    const src2 = slice.loadMaybeAddress();
    const dest = slice.loadMaybeExternalAddress();
    const createdLt = slice.loadUintBig(64);
    const createdAt = slice.loadUint(32);
    return {
      type: "external-out",
      src: src2,
      dest,
      createdLt,
      createdAt
    };
  }
  CommonMessageInfoRelaxed$1.loadCommonMessageInfoRelaxed = loadCommonMessageInfoRelaxed;
  function storeCommonMessageInfoRelaxed(source) {
    return (builder2) => {
      if (source.type === "internal") {
        builder2.storeBit(0);
        builder2.storeBit(source.ihrDisabled);
        builder2.storeBit(source.bounce);
        builder2.storeBit(source.bounced);
        builder2.storeAddress(source.src);
        builder2.storeAddress(source.dest);
        builder2.store((0, CurrencyCollection_1.storeCurrencyCollection)(source.value));
        builder2.storeCoins(source.ihrFee);
        builder2.storeCoins(source.forwardFee);
        builder2.storeUint(source.createdLt, 64);
        builder2.storeUint(source.createdAt, 32);
      } else if (source.type === "external-out") {
        builder2.storeBit(1);
        builder2.storeBit(1);
        builder2.storeAddress(source.src);
        builder2.storeAddress(source.dest);
        builder2.storeUint(source.createdLt, 64);
        builder2.storeUint(source.createdAt, 32);
      } else {
        throw new Error("Unknown CommonMessageInfo type");
      }
    };
  }
  CommonMessageInfoRelaxed$1.storeCommonMessageInfoRelaxed = storeCommonMessageInfoRelaxed;
  return CommonMessageInfoRelaxed$1;
}
var hasRequiredMessageRelaxed$1;
function requireMessageRelaxed$1() {
  if (hasRequiredMessageRelaxed$1) return MessageRelaxed$1;
  hasRequiredMessageRelaxed$1 = 1;
  Object.defineProperty(MessageRelaxed$1, "__esModule", { value: true });
  MessageRelaxed$1.storeMessageRelaxed = MessageRelaxed$1.loadMessageRelaxed = void 0;
  const Builder_12 = requireBuilder$3();
  const CommonMessageInfoRelaxed_1 = requireCommonMessageInfoRelaxed$1();
  const StateInit_1 = requireStateInit$1();
  function loadMessageRelaxed(slice) {
    const info = (0, CommonMessageInfoRelaxed_1.loadCommonMessageInfoRelaxed)(slice);
    let init = null;
    if (slice.loadBit()) {
      if (!slice.loadBit()) {
        init = (0, StateInit_1.loadStateInit)(slice);
      } else {
        init = (0, StateInit_1.loadStateInit)(slice.loadRef().beginParse());
      }
    }
    const body = slice.loadBit() ? slice.loadRef() : slice.asCell();
    return {
      info,
      init,
      body
    };
  }
  MessageRelaxed$1.loadMessageRelaxed = loadMessageRelaxed;
  function storeMessageRelaxed(message, opts) {
    return (builder2) => {
      builder2.store((0, CommonMessageInfoRelaxed_1.storeCommonMessageInfoRelaxed)(message.info));
      if (message.init) {
        builder2.storeBit(true);
        let initCell = (0, Builder_12.beginCell)().store((0, StateInit_1.storeStateInit)(message.init));
        let needRef2 = false;
        if (opts && opts.forceRef) {
          needRef2 = true;
        } else {
          if (builder2.availableBits - 2 >= initCell.bits) {
            needRef2 = false;
          } else {
            needRef2 = true;
          }
        }
        if (needRef2) {
          builder2.storeBit(true);
          builder2.storeRef(initCell);
        } else {
          builder2.storeBit(false);
          builder2.storeBuilder(initCell);
        }
      } else {
        builder2.storeBit(false);
      }
      let needRef = false;
      if (opts && opts.forceRef) {
        needRef = true;
      } else {
        if (builder2.availableBits - 1 >= message.body.bits.length && builder2.refs + message.body.refs.length <= 4 && !message.body.isExotic) {
          needRef = false;
        } else {
          needRef = true;
        }
      }
      if (needRef) {
        builder2.storeBit(true);
        builder2.storeRef(message.body);
      } else {
        builder2.storeBit(false);
        builder2.storeBuilder(message.body.asBuilder());
      }
    };
  }
  MessageRelaxed$1.storeMessageRelaxed = storeMessageRelaxed;
  return MessageRelaxed$1;
}
var LibRef$1 = {};
var hasRequiredLibRef$1;
function requireLibRef$1() {
  if (hasRequiredLibRef$1) return LibRef$1;
  hasRequiredLibRef$1 = 1;
  Object.defineProperty(LibRef$1, "__esModule", { value: true });
  LibRef$1.storeLibRef = LibRef$1.loadLibRef = void 0;
  function loadLibRef(slice) {
    const type = slice.loadUint(1);
    if (type === 0) {
      return {
        type: "hash",
        libHash: slice.loadBuffer(32)
      };
    } else {
      return {
        type: "ref",
        library: slice.loadRef()
      };
    }
  }
  LibRef$1.loadLibRef = loadLibRef;
  function storeLibRef(src2) {
    return (builder2) => {
      if (src2.type === "hash") {
        builder2.storeUint(0, 1);
        builder2.storeBuffer(src2.libHash);
      } else {
        builder2.storeUint(1, 1);
        builder2.storeRef(src2.library);
      }
    };
  }
  LibRef$1.storeLibRef = storeLibRef;
  return LibRef$1;
}
var hasRequiredOutList$1;
function requireOutList$1() {
  if (hasRequiredOutList$1) return OutList$1;
  hasRequiredOutList$1 = 1;
  Object.defineProperty(OutList$1, "__esModule", { value: true });
  OutList$1.loadOutList = OutList$1.storeOutList = OutList$1.loadOutAction = OutList$1.storeOutAction = void 0;
  const MessageRelaxed_1 = requireMessageRelaxed$1();
  const Builder_12 = requireBuilder$3();
  const CurrencyCollection_1 = requireCurrencyCollection$1();
  const LibRef_1 = requireLibRef$1();
  function storeOutAction(action) {
    switch (action.type) {
      case "sendMsg":
        return storeOutActionSendMsg(action);
      case "setCode":
        return storeOutActionSetCode(action);
      case "reserve":
        return storeOutActionReserve(action);
      case "changeLibrary":
        return storeOutActionChangeLibrary(action);
      default:
        throw new Error(`Unknown action type ${action.type}`);
    }
  }
  OutList$1.storeOutAction = storeOutAction;
  const outActionSendMsgTag = 247711853;
  function storeOutActionSendMsg(action) {
    return (builder2) => {
      builder2.storeUint(outActionSendMsgTag, 32).storeUint(action.mode, 8).storeRef((0, Builder_12.beginCell)().store((0, MessageRelaxed_1.storeMessageRelaxed)(action.outMsg)).endCell());
    };
  }
  const outActionSetCodeTag = 2907562126;
  function storeOutActionSetCode(action) {
    return (builder2) => {
      builder2.storeUint(outActionSetCodeTag, 32).storeRef(action.newCode);
    };
  }
  const outActionReserveTag = 921090057;
  function storeOutActionReserve(action) {
    return (builder2) => {
      builder2.storeUint(outActionReserveTag, 32).storeUint(action.mode, 8).store((0, CurrencyCollection_1.storeCurrencyCollection)(action.currency));
    };
  }
  const outActionChangeLibraryTag = 653925844;
  function storeOutActionChangeLibrary(action) {
    return (builder2) => {
      builder2.storeUint(outActionChangeLibraryTag, 32).storeUint(action.mode, 7).store((0, LibRef_1.storeLibRef)(action.libRef));
    };
  }
  function loadOutAction(slice) {
    const tag = slice.loadUint(32);
    if (tag === outActionSendMsgTag) {
      const mode = slice.loadUint(8);
      const outMsg = (0, MessageRelaxed_1.loadMessageRelaxed)(slice.loadRef().beginParse());
      return {
        type: "sendMsg",
        mode,
        outMsg
      };
    }
    if (tag === outActionSetCodeTag) {
      const newCode = slice.loadRef();
      return {
        type: "setCode",
        newCode
      };
    }
    if (tag === outActionReserveTag) {
      const mode = slice.loadUint(8);
      const currency = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
      return {
        type: "reserve",
        mode,
        currency
      };
    }
    if (tag === outActionChangeLibraryTag) {
      const mode = slice.loadUint(7);
      const libRef = (0, LibRef_1.loadLibRef)(slice);
      return {
        type: "changeLibrary",
        mode,
        libRef
      };
    }
    throw new Error(`Unknown out action tag 0x${tag.toString(16)}`);
  }
  OutList$1.loadOutAction = loadOutAction;
  function storeOutList(actions) {
    const cell = actions.reduce((cell2, action) => (0, Builder_12.beginCell)().storeRef(cell2).store(storeOutAction(action)).endCell(), (0, Builder_12.beginCell)().endCell());
    return (builder2) => {
      builder2.storeSlice(cell.beginParse());
    };
  }
  OutList$1.storeOutList = storeOutList;
  function loadOutList(slice) {
    const actions = [];
    while (slice.remainingRefs) {
      const nextCell = slice.loadRef();
      actions.push(loadOutAction(slice));
      slice = nextCell.beginParse();
    }
    return actions.reverse();
  }
  OutList$1.loadOutList = loadOutList;
  return OutList$1;
}
var CommonMessageInfo$1 = {};
var hasRequiredCommonMessageInfo$1;
function requireCommonMessageInfo$1() {
  if (hasRequiredCommonMessageInfo$1) return CommonMessageInfo$1;
  hasRequiredCommonMessageInfo$1 = 1;
  Object.defineProperty(CommonMessageInfo$1, "__esModule", { value: true });
  CommonMessageInfo$1.storeCommonMessageInfo = CommonMessageInfo$1.loadCommonMessageInfo = void 0;
  const CurrencyCollection_1 = requireCurrencyCollection$1();
  function loadCommonMessageInfo(slice) {
    if (!slice.loadBit()) {
      const ihrDisabled = slice.loadBit();
      const bounce = slice.loadBit();
      const bounced = slice.loadBit();
      const src3 = slice.loadAddress();
      const dest2 = slice.loadAddress();
      const value = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
      const ihrFee = slice.loadCoins();
      const forwardFee = slice.loadCoins();
      const createdLt2 = slice.loadUintBig(64);
      const createdAt2 = slice.loadUint(32);
      return {
        type: "internal",
        ihrDisabled,
        bounce,
        bounced,
        src: src3,
        dest: dest2,
        value,
        ihrFee,
        forwardFee,
        createdLt: createdLt2,
        createdAt: createdAt2
      };
    }
    if (!slice.loadBit()) {
      const src3 = slice.loadMaybeExternalAddress();
      const dest2 = slice.loadAddress();
      const importFee = slice.loadCoins();
      return {
        type: "external-in",
        src: src3,
        dest: dest2,
        importFee
      };
    }
    const src2 = slice.loadAddress();
    const dest = slice.loadMaybeExternalAddress();
    const createdLt = slice.loadUintBig(64);
    const createdAt = slice.loadUint(32);
    return {
      type: "external-out",
      src: src2,
      dest,
      createdLt,
      createdAt
    };
  }
  CommonMessageInfo$1.loadCommonMessageInfo = loadCommonMessageInfo;
  function storeCommonMessageInfo(source) {
    return (builder2) => {
      if (source.type === "internal") {
        builder2.storeBit(0);
        builder2.storeBit(source.ihrDisabled);
        builder2.storeBit(source.bounce);
        builder2.storeBit(source.bounced);
        builder2.storeAddress(source.src);
        builder2.storeAddress(source.dest);
        builder2.store((0, CurrencyCollection_1.storeCurrencyCollection)(source.value));
        builder2.storeCoins(source.ihrFee);
        builder2.storeCoins(source.forwardFee);
        builder2.storeUint(source.createdLt, 64);
        builder2.storeUint(source.createdAt, 32);
      } else if (source.type === "external-in") {
        builder2.storeBit(1);
        builder2.storeBit(0);
        builder2.storeAddress(source.src);
        builder2.storeAddress(source.dest);
        builder2.storeCoins(source.importFee);
      } else if (source.type === "external-out") {
        builder2.storeBit(1);
        builder2.storeBit(1);
        builder2.storeAddress(source.src);
        builder2.storeAddress(source.dest);
        builder2.storeUint(source.createdLt, 64);
        builder2.storeUint(source.createdAt, 32);
      } else {
        throw new Error("Unknown CommonMessageInfo type");
      }
    };
  }
  CommonMessageInfo$1.storeCommonMessageInfo = storeCommonMessageInfo;
  return CommonMessageInfo$1;
}
var ComputeSkipReason$1 = {};
var hasRequiredComputeSkipReason$1;
function requireComputeSkipReason$1() {
  if (hasRequiredComputeSkipReason$1) return ComputeSkipReason$1;
  hasRequiredComputeSkipReason$1 = 1;
  Object.defineProperty(ComputeSkipReason$1, "__esModule", { value: true });
  ComputeSkipReason$1.storeComputeSkipReason = ComputeSkipReason$1.loadComputeSkipReason = void 0;
  function loadComputeSkipReason(slice) {
    let reason = slice.loadUint(2);
    if (reason === 0) {
      return "no-state";
    } else if (reason === 1) {
      return "bad-state";
    } else if (reason === 2) {
      return "no-gas";
    }
    throw new Error(`Unknown ComputeSkipReason: ${reason}`);
  }
  ComputeSkipReason$1.loadComputeSkipReason = loadComputeSkipReason;
  function storeComputeSkipReason(src2) {
    return (builder2) => {
      if (src2 === "no-state") {
        builder2.storeUint(0, 2);
      } else if (src2 === "bad-state") {
        builder2.storeUint(1, 2);
      } else if (src2 === "no-gas") {
        builder2.storeUint(2, 2);
      } else {
        throw new Error(`Unknown ComputeSkipReason: ${src2}`);
      }
    };
  }
  ComputeSkipReason$1.storeComputeSkipReason = storeComputeSkipReason;
  return ComputeSkipReason$1;
}
var DepthBalanceInfo$1 = {};
var hasRequiredDepthBalanceInfo$1;
function requireDepthBalanceInfo$1() {
  if (hasRequiredDepthBalanceInfo$1) return DepthBalanceInfo$1;
  hasRequiredDepthBalanceInfo$1 = 1;
  Object.defineProperty(DepthBalanceInfo$1, "__esModule", { value: true });
  DepthBalanceInfo$1.storeDepthBalanceInfo = DepthBalanceInfo$1.loadDepthBalanceInfo = void 0;
  const CurrencyCollection_1 = requireCurrencyCollection$1();
  function loadDepthBalanceInfo(slice) {
    let splitDepth = slice.loadUint(5);
    return {
      splitDepth,
      balance: (0, CurrencyCollection_1.loadCurrencyCollection)(slice)
    };
  }
  DepthBalanceInfo$1.loadDepthBalanceInfo = loadDepthBalanceInfo;
  function storeDepthBalanceInfo(src2) {
    return (builder2) => {
      builder2.storeUint(src2.splitDepth, 5);
      builder2.store((0, CurrencyCollection_1.storeCurrencyCollection)(src2.balance));
    };
  }
  DepthBalanceInfo$1.storeDepthBalanceInfo = storeDepthBalanceInfo;
  return DepthBalanceInfo$1;
}
var HashUpdate$1 = {};
var hasRequiredHashUpdate$1;
function requireHashUpdate$1() {
  if (hasRequiredHashUpdate$1) return HashUpdate$1;
  hasRequiredHashUpdate$1 = 1;
  Object.defineProperty(HashUpdate$1, "__esModule", { value: true });
  HashUpdate$1.storeHashUpdate = HashUpdate$1.loadHashUpdate = void 0;
  function loadHashUpdate(slice) {
    if (slice.loadUint(8) !== 114) {
      throw Error("Invalid data");
    }
    const oldHash = slice.loadBuffer(32);
    const newHash = slice.loadBuffer(32);
    return { oldHash, newHash };
  }
  HashUpdate$1.loadHashUpdate = loadHashUpdate;
  function storeHashUpdate(src2) {
    return (builder2) => {
      builder2.storeUint(114, 8);
      builder2.storeBuffer(src2.oldHash);
      builder2.storeBuffer(src2.newHash);
    };
  }
  HashUpdate$1.storeHashUpdate = storeHashUpdate;
  return HashUpdate$1;
}
var MasterchainStateExtra$1 = {};
var hasRequiredMasterchainStateExtra$1;
function requireMasterchainStateExtra$1() {
  if (hasRequiredMasterchainStateExtra$1) return MasterchainStateExtra$1;
  hasRequiredMasterchainStateExtra$1 = 1;
  Object.defineProperty(MasterchainStateExtra$1, "__esModule", { value: true });
  MasterchainStateExtra$1.loadMasterchainStateExtra = void 0;
  const Dictionary_1 = requireDictionary$1();
  const CurrencyCollection_1 = requireCurrencyCollection$1();
  function loadMasterchainStateExtra(cs) {
    if (cs.loadUint(16) !== 52262) {
      throw Error("Invalid data");
    }
    if (cs.loadBit()) {
      cs.loadRef();
    }
    let configAddress = cs.loadUintBig(256);
    let config = Dictionary_1.Dictionary.load(Dictionary_1.Dictionary.Keys.Int(32), Dictionary_1.Dictionary.Values.Cell(), cs);
    const globalBalance = (0, CurrencyCollection_1.loadCurrencyCollection)(cs);
    return {
      config,
      configAddress,
      globalBalance
    };
  }
  MasterchainStateExtra$1.loadMasterchainStateExtra = loadMasterchainStateExtra;
  return MasterchainStateExtra$1;
}
var Message$1 = {};
var hasRequiredMessage$1;
function requireMessage$1() {
  if (hasRequiredMessage$1) return Message$1;
  hasRequiredMessage$1 = 1;
  Object.defineProperty(Message$1, "__esModule", { value: true });
  Message$1.MessageValue = Message$1.storeMessage = Message$1.loadMessage = void 0;
  const Builder_12 = requireBuilder$3();
  const CommonMessageInfo_1 = requireCommonMessageInfo$1();
  const StateInit_1 = requireStateInit$1();
  function loadMessage(slice) {
    const info = (0, CommonMessageInfo_1.loadCommonMessageInfo)(slice);
    let init = null;
    if (slice.loadBit()) {
      if (!slice.loadBit()) {
        init = (0, StateInit_1.loadStateInit)(slice);
      } else {
        init = (0, StateInit_1.loadStateInit)(slice.loadRef().beginParse());
      }
    }
    const body = slice.loadBit() ? slice.loadRef() : slice.asCell();
    return {
      info,
      init,
      body
    };
  }
  Message$1.loadMessage = loadMessage;
  function storeMessage(message, opts) {
    return (builder2) => {
      builder2.store((0, CommonMessageInfo_1.storeCommonMessageInfo)(message.info));
      if (message.init) {
        builder2.storeBit(true);
        let initCell = (0, Builder_12.beginCell)().store((0, StateInit_1.storeStateInit)(message.init));
        let needRef2 = false;
        if (opts && opts.forceRef) {
          needRef2 = true;
        } else {
          needRef2 = builder2.availableBits - 2 < initCell.bits + message.body.bits.length;
        }
        if (needRef2) {
          builder2.storeBit(true);
          builder2.storeRef(initCell);
        } else {
          builder2.storeBit(false);
          builder2.storeBuilder(initCell);
        }
      } else {
        builder2.storeBit(false);
      }
      let needRef = false;
      if (opts && opts.forceRef) {
        needRef = true;
      } else {
        needRef = builder2.availableBits - 1 < message.body.bits.length || builder2.refs + message.body.refs.length > 4;
      }
      if (needRef) {
        builder2.storeBit(true);
        builder2.storeRef(message.body);
      } else {
        builder2.storeBit(false);
        builder2.storeBuilder(message.body.asBuilder());
      }
    };
  }
  Message$1.storeMessage = storeMessage;
  Message$1.MessageValue = {
    serialize(src2, builder2) {
      builder2.storeRef((0, Builder_12.beginCell)().store(storeMessage(src2)));
    },
    parse(slice) {
      return loadMessage(slice.loadRef().beginParse());
    }
  };
  return Message$1;
}
var SendMode$1 = {};
var hasRequiredSendMode$1;
function requireSendMode$1() {
  if (hasRequiredSendMode$1) return SendMode$1;
  hasRequiredSendMode$1 = 1;
  Object.defineProperty(SendMode$1, "__esModule", { value: true });
  SendMode$1.SendMode = void 0;
  var SendMode2;
  (function(SendMode3) {
    SendMode3[SendMode3["CARRY_ALL_REMAINING_BALANCE"] = 128] = "CARRY_ALL_REMAINING_BALANCE";
    SendMode3[SendMode3["CARRY_ALL_REMAINING_INCOMING_VALUE"] = 64] = "CARRY_ALL_REMAINING_INCOMING_VALUE";
    SendMode3[SendMode3["DESTROY_ACCOUNT_IF_ZERO"] = 32] = "DESTROY_ACCOUNT_IF_ZERO";
    SendMode3[SendMode3["PAY_GAS_SEPARATELY"] = 1] = "PAY_GAS_SEPARATELY";
    SendMode3[SendMode3["IGNORE_ERRORS"] = 2] = "IGNORE_ERRORS";
    SendMode3[SendMode3["NONE"] = 0] = "NONE";
  })(SendMode2 || (SendMode$1.SendMode = SendMode2 = {}));
  return SendMode$1;
}
var ReserveMode$1 = {};
var hasRequiredReserveMode$1;
function requireReserveMode$1() {
  if (hasRequiredReserveMode$1) return ReserveMode$1;
  hasRequiredReserveMode$1 = 1;
  Object.defineProperty(ReserveMode$1, "__esModule", { value: true });
  ReserveMode$1.ReserveMode = void 0;
  var ReserveMode2;
  (function(ReserveMode3) {
    ReserveMode3[ReserveMode3["THIS_AMOUNT"] = 0] = "THIS_AMOUNT";
    ReserveMode3[ReserveMode3["LEAVE_THIS_AMOUNT"] = 1] = "LEAVE_THIS_AMOUNT";
    ReserveMode3[ReserveMode3["AT_MOST_THIS_AMOUNT"] = 2] = "AT_MOST_THIS_AMOUNT";
    ReserveMode3[ReserveMode3["LEAVE_MAX_THIS_AMOUNT"] = 3] = "LEAVE_MAX_THIS_AMOUNT";
    ReserveMode3[ReserveMode3["BEFORE_BALANCE_PLUS_THIS_AMOUNT"] = 4] = "BEFORE_BALANCE_PLUS_THIS_AMOUNT";
    ReserveMode3[ReserveMode3["LEAVE_BBALANCE_PLUS_THIS_AMOUNT"] = 5] = "LEAVE_BBALANCE_PLUS_THIS_AMOUNT";
    ReserveMode3[ReserveMode3["BEFORE_BALANCE_MINUS_THIS_AMOUNT"] = 12] = "BEFORE_BALANCE_MINUS_THIS_AMOUNT";
    ReserveMode3[ReserveMode3["LEAVE_BEFORE_BALANCE_MINUS_THIS_AMOUNT"] = 13] = "LEAVE_BEFORE_BALANCE_MINUS_THIS_AMOUNT";
  })(ReserveMode2 || (ReserveMode$1.ReserveMode = ReserveMode2 = {}));
  return ReserveMode$1;
}
var ShardAccount$1 = {};
var hasRequiredShardAccount$1;
function requireShardAccount$1() {
  if (hasRequiredShardAccount$1) return ShardAccount$1;
  hasRequiredShardAccount$1 = 1;
  Object.defineProperty(ShardAccount$1, "__esModule", { value: true });
  ShardAccount$1.storeShardAccount = ShardAccount$1.loadShardAccount = void 0;
  const Builder_12 = requireBuilder$3();
  const Account_1 = requireAccount$1();
  function loadShardAccount(slice) {
    let accountRef = slice.loadRef();
    let account = void 0;
    if (!accountRef.isExotic) {
      let accountSlice = accountRef.beginParse();
      if (accountSlice.loadBit()) {
        account = (0, Account_1.loadAccount)(accountSlice);
      }
    }
    return {
      account,
      lastTransactionHash: slice.loadUintBig(256),
      lastTransactionLt: slice.loadUintBig(64)
    };
  }
  ShardAccount$1.loadShardAccount = loadShardAccount;
  function storeShardAccount(src2) {
    return (builder2) => {
      if (src2.account) {
        builder2.storeRef((0, Builder_12.beginCell)().storeBit(true).store((0, Account_1.storeAccount)(src2.account)));
      } else {
        builder2.storeRef((0, Builder_12.beginCell)().storeBit(false));
      }
      builder2.storeUint(src2.lastTransactionHash, 256);
      builder2.storeUint(src2.lastTransactionLt, 64);
    };
  }
  ShardAccount$1.storeShardAccount = storeShardAccount;
  return ShardAccount$1;
}
var ShardAccounts$1 = {};
var hasRequiredShardAccounts$1;
function requireShardAccounts$1() {
  if (hasRequiredShardAccounts$1) return ShardAccounts$1;
  hasRequiredShardAccounts$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeShardAccounts = exports.loadShardAccounts = exports.ShardAccountRefValue = void 0;
    const Dictionary_1 = requireDictionary$1();
    const DepthBalanceInfo_1 = requireDepthBalanceInfo$1();
    const ShardAccount_1 = requireShardAccount$1();
    exports.ShardAccountRefValue = {
      parse: (cs) => {
        let depthBalanceInfo = (0, DepthBalanceInfo_1.loadDepthBalanceInfo)(cs);
        let shardAccount = (0, ShardAccount_1.loadShardAccount)(cs);
        return {
          depthBalanceInfo,
          shardAccount
        };
      },
      serialize(src2, builder2) {
        builder2.store((0, DepthBalanceInfo_1.storeDepthBalanceInfo)(src2.depthBalanceInfo));
        builder2.store((0, ShardAccount_1.storeShardAccount)(src2.shardAccount));
      }
    };
    function loadShardAccounts(cs) {
      return Dictionary_1.Dictionary.load(Dictionary_1.Dictionary.Keys.BigUint(256), exports.ShardAccountRefValue, cs);
    }
    exports.loadShardAccounts = loadShardAccounts;
    function storeShardAccounts(src2) {
      return (Builder2) => {
        Builder2.storeDict(src2);
      };
    }
    exports.storeShardAccounts = storeShardAccounts;
  })(ShardAccounts$1);
  return ShardAccounts$1;
}
var ShardIdent$1 = {};
var hasRequiredShardIdent$1;
function requireShardIdent$1() {
  if (hasRequiredShardIdent$1) return ShardIdent$1;
  hasRequiredShardIdent$1 = 1;
  Object.defineProperty(ShardIdent$1, "__esModule", { value: true });
  ShardIdent$1.storeShardIdent = ShardIdent$1.loadShardIdent = void 0;
  function loadShardIdent(slice) {
    if (slice.loadUint(2) !== 0) {
      throw Error("Invalid data");
    }
    return {
      shardPrefixBits: slice.loadUint(6),
      workchainId: slice.loadInt(32),
      shardPrefix: slice.loadUintBig(64)
    };
  }
  ShardIdent$1.loadShardIdent = loadShardIdent;
  function storeShardIdent(src2) {
    return (builder2) => {
      builder2.storeUint(0, 2);
      builder2.storeUint(src2.shardPrefixBits, 6);
      builder2.storeInt(src2.workchainId, 32);
      builder2.storeUint(src2.shardPrefix, 64);
    };
  }
  ShardIdent$1.storeShardIdent = storeShardIdent;
  return ShardIdent$1;
}
var ShardStateUnsplit$1 = {};
var hasRequiredShardStateUnsplit$1;
function requireShardStateUnsplit$1() {
  if (hasRequiredShardStateUnsplit$1) return ShardStateUnsplit$1;
  hasRequiredShardStateUnsplit$1 = 1;
  Object.defineProperty(ShardStateUnsplit$1, "__esModule", { value: true });
  ShardStateUnsplit$1.loadShardStateUnsplit = void 0;
  const MasterchainStateExtra_1 = requireMasterchainStateExtra$1();
  const ShardAccounts_1 = requireShardAccounts$1();
  const ShardIdent_1 = requireShardIdent$1();
  function loadShardStateUnsplit(cs) {
    if (cs.loadUint(32) !== 2418257890) {
      throw Error("Invalid data");
    }
    let globalId = cs.loadInt(32);
    let shardId = (0, ShardIdent_1.loadShardIdent)(cs);
    let seqno = cs.loadUint(32);
    let vertSeqNo = cs.loadUint(32);
    let genUtime = cs.loadUint(32);
    let genLt = cs.loadUintBig(64);
    let minRefMcSeqno = cs.loadUint(32);
    cs.loadRef();
    let beforeSplit = cs.loadBit();
    let shardAccountsRef = cs.loadRef();
    let accounts = void 0;
    if (!shardAccountsRef.isExotic) {
      accounts = (0, ShardAccounts_1.loadShardAccounts)(shardAccountsRef.beginParse());
    }
    cs.loadRef();
    let mcStateExtra = cs.loadBit();
    let extras2 = null;
    if (mcStateExtra) {
      let cell = cs.loadRef();
      if (!cell.isExotic) {
        extras2 = (0, MasterchainStateExtra_1.loadMasterchainStateExtra)(cell.beginParse());
      }
    }
    return {
      globalId,
      shardId,
      seqno,
      vertSeqNo,
      genUtime,
      genLt,
      minRefMcSeqno,
      beforeSplit,
      accounts,
      extras: extras2
    };
  }
  ShardStateUnsplit$1.loadShardStateUnsplit = loadShardStateUnsplit;
  return ShardStateUnsplit$1;
}
var SplitMergeInfo$1 = {};
var hasRequiredSplitMergeInfo$1;
function requireSplitMergeInfo$1() {
  if (hasRequiredSplitMergeInfo$1) return SplitMergeInfo$1;
  hasRequiredSplitMergeInfo$1 = 1;
  Object.defineProperty(SplitMergeInfo$1, "__esModule", { value: true });
  SplitMergeInfo$1.storeSplitMergeInfo = SplitMergeInfo$1.loadSplitMergeInfo = void 0;
  function loadSplitMergeInfo(slice) {
    let currentShardPrefixLength = slice.loadUint(6);
    let accountSplitDepth = slice.loadUint(6);
    let thisAddress = slice.loadUintBig(256);
    let siblingAddress = slice.loadUintBig(256);
    return {
      currentShardPrefixLength,
      accountSplitDepth,
      thisAddress,
      siblingAddress
    };
  }
  SplitMergeInfo$1.loadSplitMergeInfo = loadSplitMergeInfo;
  function storeSplitMergeInfo(src2) {
    return (builder2) => {
      builder2.storeUint(src2.currentShardPrefixLength, 6);
      builder2.storeUint(src2.accountSplitDepth, 6);
      builder2.storeUint(src2.thisAddress, 256);
      builder2.storeUint(src2.siblingAddress, 256);
    };
  }
  SplitMergeInfo$1.storeSplitMergeInfo = storeSplitMergeInfo;
  return SplitMergeInfo$1;
}
var Transaction$1 = {};
var TransactionDescription$1 = {};
var TransactionActionPhase$1 = {};
var hasRequiredTransactionActionPhase$1;
function requireTransactionActionPhase$1() {
  if (hasRequiredTransactionActionPhase$1) return TransactionActionPhase$1;
  hasRequiredTransactionActionPhase$1 = 1;
  Object.defineProperty(TransactionActionPhase$1, "__esModule", { value: true });
  TransactionActionPhase$1.storeTransactionActionPhase = TransactionActionPhase$1.loadTransactionActionPhase = void 0;
  const AccountStatusChange_1 = requireAccountStatusChange$1();
  const StorageUsed_1 = requireStorageUsed$1();
  function loadTransactionActionPhase(slice) {
    let success = slice.loadBit();
    let valid = slice.loadBit();
    let noFunds = slice.loadBit();
    let statusChange = (0, AccountStatusChange_1.loadAccountStatusChange)(slice);
    let totalFwdFees = slice.loadBit() ? slice.loadCoins() : void 0;
    let totalActionFees = slice.loadBit() ? slice.loadCoins() : void 0;
    let resultCode = slice.loadInt(32);
    let resultArg = slice.loadBit() ? slice.loadInt(32) : void 0;
    let totalActions = slice.loadUint(16);
    let specActions = slice.loadUint(16);
    let skippedActions = slice.loadUint(16);
    let messagesCreated = slice.loadUint(16);
    let actionListHash = slice.loadUintBig(256);
    let totalMessageSize = (0, StorageUsed_1.loadStorageUsed)(slice);
    return {
      success,
      valid,
      noFunds,
      statusChange,
      totalFwdFees,
      totalActionFees,
      resultCode,
      resultArg,
      totalActions,
      specActions,
      skippedActions,
      messagesCreated,
      actionListHash,
      totalMessageSize
    };
  }
  TransactionActionPhase$1.loadTransactionActionPhase = loadTransactionActionPhase;
  function storeTransactionActionPhase(src2) {
    return (builder2) => {
      builder2.storeBit(src2.success);
      builder2.storeBit(src2.valid);
      builder2.storeBit(src2.noFunds);
      builder2.store((0, AccountStatusChange_1.storeAccountStatusChange)(src2.statusChange));
      builder2.storeMaybeCoins(src2.totalFwdFees);
      builder2.storeMaybeCoins(src2.totalActionFees);
      builder2.storeInt(src2.resultCode, 32);
      builder2.storeMaybeInt(src2.resultArg, 32);
      builder2.storeUint(src2.totalActions, 16);
      builder2.storeUint(src2.specActions, 16);
      builder2.storeUint(src2.skippedActions, 16);
      builder2.storeUint(src2.messagesCreated, 16);
      builder2.storeUint(src2.actionListHash, 256);
      builder2.store((0, StorageUsed_1.storeStorageUsed)(src2.totalMessageSize));
    };
  }
  TransactionActionPhase$1.storeTransactionActionPhase = storeTransactionActionPhase;
  return TransactionActionPhase$1;
}
var TransactionBouncePhase$1 = {};
var hasRequiredTransactionBouncePhase$1;
function requireTransactionBouncePhase$1() {
  if (hasRequiredTransactionBouncePhase$1) return TransactionBouncePhase$1;
  hasRequiredTransactionBouncePhase$1 = 1;
  Object.defineProperty(TransactionBouncePhase$1, "__esModule", { value: true });
  TransactionBouncePhase$1.storeTransactionBouncePhase = TransactionBouncePhase$1.loadTransactionBouncePhase = void 0;
  const StorageUsed_1 = requireStorageUsed$1();
  function loadTransactionBouncePhase(slice) {
    if (slice.loadBit()) {
      let messageSize = (0, StorageUsed_1.loadStorageUsed)(slice);
      let messageFees = slice.loadCoins();
      let forwardFees = slice.loadCoins();
      return {
        type: "ok",
        messageSize,
        messageFees,
        forwardFees
      };
    }
    if (slice.loadBit()) {
      let messageSize = (0, StorageUsed_1.loadStorageUsed)(slice);
      let requiredForwardFees = slice.loadCoins();
      return {
        type: "no-funds",
        messageSize,
        requiredForwardFees
      };
    }
    return {
      type: "negative-funds"
    };
  }
  TransactionBouncePhase$1.loadTransactionBouncePhase = loadTransactionBouncePhase;
  function storeTransactionBouncePhase(src2) {
    return (builder2) => {
      if (src2.type === "ok") {
        builder2.storeBit(true);
        builder2.store((0, StorageUsed_1.storeStorageUsed)(src2.messageSize));
        builder2.storeCoins(src2.messageFees);
        builder2.storeCoins(src2.forwardFees);
      } else if (src2.type === "negative-funds") {
        builder2.storeBit(false);
        builder2.storeBit(false);
      } else if (src2.type === "no-funds") {
        builder2.storeBit(false);
        builder2.storeBit(true);
        builder2.store((0, StorageUsed_1.storeStorageUsed)(src2.messageSize));
        builder2.storeCoins(src2.requiredForwardFees);
      } else {
        throw new Error("Invalid TransactionBouncePhase type");
      }
    };
  }
  TransactionBouncePhase$1.storeTransactionBouncePhase = storeTransactionBouncePhase;
  return TransactionBouncePhase$1;
}
var TransactionComputePhase$1 = {};
var hasRequiredTransactionComputePhase$1;
function requireTransactionComputePhase$1() {
  if (hasRequiredTransactionComputePhase$1) return TransactionComputePhase$1;
  hasRequiredTransactionComputePhase$1 = 1;
  Object.defineProperty(TransactionComputePhase$1, "__esModule", { value: true });
  TransactionComputePhase$1.storeTransactionComputePhase = TransactionComputePhase$1.loadTransactionComputePhase = void 0;
  const Builder_12 = requireBuilder$3();
  const ComputeSkipReason_1 = requireComputeSkipReason$1();
  function loadTransactionComputePhase(slice) {
    if (!slice.loadBit()) {
      let reason = (0, ComputeSkipReason_1.loadComputeSkipReason)(slice);
      return {
        type: "skipped",
        reason
      };
    }
    let success = slice.loadBit();
    let messageStateUsed = slice.loadBit();
    let accountActivated = slice.loadBit();
    let gasFees = slice.loadCoins();
    const vmState = slice.loadRef().beginParse();
    let gasUsed = vmState.loadVarUintBig(3);
    let gasLimit = vmState.loadVarUintBig(3);
    let gasCredit = vmState.loadBit() ? vmState.loadVarUintBig(2) : void 0;
    let mode = vmState.loadUint(8);
    let exitCode = vmState.loadInt(32);
    let exitArg = vmState.loadBit() ? vmState.loadInt(32) : void 0;
    let vmSteps = vmState.loadUint(32);
    let vmInitStateHash = vmState.loadUintBig(256);
    let vmFinalStateHash = vmState.loadUintBig(256);
    return {
      type: "vm",
      success,
      messageStateUsed,
      accountActivated,
      gasFees,
      gasUsed,
      gasLimit,
      gasCredit,
      mode,
      exitCode,
      exitArg,
      vmSteps,
      vmInitStateHash,
      vmFinalStateHash
    };
  }
  TransactionComputePhase$1.loadTransactionComputePhase = loadTransactionComputePhase;
  function storeTransactionComputePhase(src2) {
    return (builder2) => {
      if (src2.type === "skipped") {
        builder2.storeBit(0);
        builder2.store((0, ComputeSkipReason_1.storeComputeSkipReason)(src2.reason));
        return;
      }
      builder2.storeBit(1);
      builder2.storeBit(src2.success);
      builder2.storeBit(src2.messageStateUsed);
      builder2.storeBit(src2.accountActivated);
      builder2.storeCoins(src2.gasFees);
      builder2.storeRef((0, Builder_12.beginCell)().storeVarUint(src2.gasUsed, 3).storeVarUint(src2.gasLimit, 3).store((b) => src2.gasCredit !== void 0 && src2.gasCredit !== null ? b.storeBit(1).storeVarUint(src2.gasCredit, 2) : b.storeBit(0)).storeUint(src2.mode, 8).storeInt(src2.exitCode, 32).store((b) => src2.exitArg !== void 0 && src2.exitArg !== null ? b.storeBit(1).storeInt(src2.exitArg, 32) : b.storeBit(0)).storeUint(src2.vmSteps, 32).storeUint(src2.vmInitStateHash, 256).storeUint(src2.vmFinalStateHash, 256).endCell());
    };
  }
  TransactionComputePhase$1.storeTransactionComputePhase = storeTransactionComputePhase;
  return TransactionComputePhase$1;
}
var TransactionCreditPhase$1 = {};
var hasRequiredTransactionCreditPhase$1;
function requireTransactionCreditPhase$1() {
  if (hasRequiredTransactionCreditPhase$1) return TransactionCreditPhase$1;
  hasRequiredTransactionCreditPhase$1 = 1;
  Object.defineProperty(TransactionCreditPhase$1, "__esModule", { value: true });
  TransactionCreditPhase$1.storeTransactionCreditPhase = TransactionCreditPhase$1.loadTransactionCreditPhase = void 0;
  const CurrencyCollection_1 = requireCurrencyCollection$1();
  function loadTransactionCreditPhase(slice) {
    const dueFeesColelcted = slice.loadBit() ? slice.loadCoins() : void 0;
    const credit = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
    return {
      dueFeesColelcted,
      credit
    };
  }
  TransactionCreditPhase$1.loadTransactionCreditPhase = loadTransactionCreditPhase;
  function storeTransactionCreditPhase(src2) {
    return (builder2) => {
      if (src2.dueFeesColelcted === null || src2.dueFeesColelcted === void 0) {
        builder2.storeBit(false);
      } else {
        builder2.storeBit(true);
        builder2.storeCoins(src2.dueFeesColelcted);
      }
      builder2.store((0, CurrencyCollection_1.storeCurrencyCollection)(src2.credit));
    };
  }
  TransactionCreditPhase$1.storeTransactionCreditPhase = storeTransactionCreditPhase;
  return TransactionCreditPhase$1;
}
var TransactionStoragePhase$1 = {};
var hasRequiredTransactionStoragePhase$1;
function requireTransactionStoragePhase$1() {
  if (hasRequiredTransactionStoragePhase$1) return TransactionStoragePhase$1;
  hasRequiredTransactionStoragePhase$1 = 1;
  Object.defineProperty(TransactionStoragePhase$1, "__esModule", { value: true });
  TransactionStoragePhase$1.storeTransactionsStoragePhase = TransactionStoragePhase$1.loadTransactionStoragePhase = void 0;
  const AccountStatusChange_1 = requireAccountStatusChange$1();
  function loadTransactionStoragePhase(slice) {
    const storageFeesCollected = slice.loadCoins();
    let storageFeesDue = void 0;
    if (slice.loadBit()) {
      storageFeesDue = slice.loadCoins();
    }
    const statusChange = (0, AccountStatusChange_1.loadAccountStatusChange)(slice);
    return {
      storageFeesCollected,
      storageFeesDue,
      statusChange
    };
  }
  TransactionStoragePhase$1.loadTransactionStoragePhase = loadTransactionStoragePhase;
  function storeTransactionsStoragePhase(src2) {
    return (builder2) => {
      builder2.storeCoins(src2.storageFeesCollected);
      if (src2.storageFeesDue === null || src2.storageFeesDue === void 0) {
        builder2.storeBit(false);
      } else {
        builder2.storeBit(true);
        builder2.storeCoins(src2.storageFeesDue);
      }
      builder2.store((0, AccountStatusChange_1.storeAccountStatusChange)(src2.statusChange));
    };
  }
  TransactionStoragePhase$1.storeTransactionsStoragePhase = storeTransactionsStoragePhase;
  return TransactionStoragePhase$1;
}
var hasRequiredTransactionDescription$1;
function requireTransactionDescription$1() {
  if (hasRequiredTransactionDescription$1) return TransactionDescription$1;
  hasRequiredTransactionDescription$1 = 1;
  Object.defineProperty(TransactionDescription$1, "__esModule", { value: true });
  TransactionDescription$1.storeTransactionDescription = TransactionDescription$1.loadTransactionDescription = void 0;
  const Builder_12 = requireBuilder$3();
  const SplitMergeInfo_1 = requireSplitMergeInfo$1();
  const Transaction_1 = requireTransaction$1();
  const TransactionActionPhase_1 = requireTransactionActionPhase$1();
  const TransactionBouncePhase_1 = requireTransactionBouncePhase$1();
  const TransactionComputePhase_1 = requireTransactionComputePhase$1();
  const TransactionCreditPhase_1 = requireTransactionCreditPhase$1();
  const TransactionStoragePhase_1 = requireTransactionStoragePhase$1();
  function loadTransactionDescription(slice) {
    let type = slice.loadUint(4);
    if (type === 0) {
      const creditFirst = slice.loadBit();
      let storagePhase = void 0;
      if (slice.loadBit()) {
        storagePhase = (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice);
      }
      let creditPhase = void 0;
      if (slice.loadBit()) {
        creditPhase = (0, TransactionCreditPhase_1.loadTransactionCreditPhase)(slice);
      }
      let computePhase = (0, TransactionComputePhase_1.loadTransactionComputePhase)(slice);
      let actionPhase = void 0;
      if (slice.loadBit()) {
        actionPhase = (0, TransactionActionPhase_1.loadTransactionActionPhase)(slice.loadRef().beginParse());
      }
      let aborted = slice.loadBit();
      let bouncePhase = void 0;
      if (slice.loadBit()) {
        bouncePhase = (0, TransactionBouncePhase_1.loadTransactionBouncePhase)(slice);
      }
      const destroyed = slice.loadBit();
      return {
        type: "generic",
        creditFirst,
        storagePhase,
        creditPhase,
        computePhase,
        actionPhase,
        bouncePhase,
        aborted,
        destroyed
      };
    }
    if (type === 1) {
      return {
        type: "storage",
        storagePhase: (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice)
      };
    }
    if (type === 2 || type === 3) {
      const isTock = type === 3;
      let storagePhase = (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice);
      let computePhase = (0, TransactionComputePhase_1.loadTransactionComputePhase)(slice);
      let actionPhase = void 0;
      if (slice.loadBit()) {
        actionPhase = (0, TransactionActionPhase_1.loadTransactionActionPhase)(slice.loadRef().beginParse());
      }
      const aborted = slice.loadBit();
      const destroyed = slice.loadBit();
      return {
        type: "tick-tock",
        isTock,
        storagePhase,
        computePhase,
        actionPhase,
        aborted,
        destroyed
      };
    }
    if (type === 4) {
      let splitInfo = (0, SplitMergeInfo_1.loadSplitMergeInfo)(slice);
      let storagePhase = void 0;
      if (slice.loadBit()) {
        storagePhase = (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice);
      }
      let computePhase = (0, TransactionComputePhase_1.loadTransactionComputePhase)(slice);
      let actionPhase = void 0;
      if (slice.loadBit()) {
        actionPhase = (0, TransactionActionPhase_1.loadTransactionActionPhase)(slice.loadRef().beginParse());
      }
      const aborted = slice.loadBit();
      const destroyed = slice.loadBit();
      return {
        type: "split-prepare",
        splitInfo,
        storagePhase,
        computePhase,
        actionPhase,
        aborted,
        destroyed
      };
    }
    if (type === 5) {
      let splitInfo = (0, SplitMergeInfo_1.loadSplitMergeInfo)(slice);
      let prepareTransaction = (0, Transaction_1.loadTransaction)(slice.loadRef().beginParse());
      const installed = slice.loadBit();
      return {
        type: "split-install",
        splitInfo,
        prepareTransaction,
        installed
      };
    }
    throw Error(`Unsupported transaction description type ${type}`);
  }
  TransactionDescription$1.loadTransactionDescription = loadTransactionDescription;
  function storeTransactionDescription(src2) {
    return (builder2) => {
      if (src2.type === "generic") {
        builder2.storeUint(0, 4);
        builder2.storeBit(src2.creditFirst);
        if (src2.storagePhase) {
          builder2.storeBit(true);
          builder2.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src2.storagePhase));
        } else {
          builder2.storeBit(false);
        }
        if (src2.creditPhase) {
          builder2.storeBit(true);
          builder2.store((0, TransactionCreditPhase_1.storeTransactionCreditPhase)(src2.creditPhase));
        } else {
          builder2.storeBit(false);
        }
        builder2.store((0, TransactionComputePhase_1.storeTransactionComputePhase)(src2.computePhase));
        if (src2.actionPhase) {
          builder2.storeBit(true);
          builder2.storeRef((0, Builder_12.beginCell)().store((0, TransactionActionPhase_1.storeTransactionActionPhase)(src2.actionPhase)));
        } else {
          builder2.storeBit(false);
        }
        builder2.storeBit(src2.aborted);
        if (src2.bouncePhase) {
          builder2.storeBit(true);
          builder2.store((0, TransactionBouncePhase_1.storeTransactionBouncePhase)(src2.bouncePhase));
        } else {
          builder2.storeBit(false);
        }
        builder2.storeBit(src2.destroyed);
      } else if (src2.type === "storage") {
        builder2.storeUint(1, 4);
        builder2.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src2.storagePhase));
      } else if (src2.type === "tick-tock") {
        builder2.storeUint(src2.isTock ? 3 : 2, 4);
        builder2.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src2.storagePhase));
        builder2.store((0, TransactionComputePhase_1.storeTransactionComputePhase)(src2.computePhase));
        if (src2.actionPhase) {
          builder2.storeBit(true);
          builder2.storeRef((0, Builder_12.beginCell)().store((0, TransactionActionPhase_1.storeTransactionActionPhase)(src2.actionPhase)));
        } else {
          builder2.storeBit(false);
        }
        builder2.storeBit(src2.aborted);
        builder2.storeBit(src2.destroyed);
      } else if (src2.type === "split-prepare") {
        builder2.storeUint(4, 4);
        builder2.store((0, SplitMergeInfo_1.storeSplitMergeInfo)(src2.splitInfo));
        if (src2.storagePhase) {
          builder2.storeBit(true);
          builder2.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src2.storagePhase));
        } else {
          builder2.storeBit(false);
        }
        builder2.store((0, TransactionComputePhase_1.storeTransactionComputePhase)(src2.computePhase));
        if (src2.actionPhase) {
          builder2.storeBit(true);
          builder2.store((0, TransactionActionPhase_1.storeTransactionActionPhase)(src2.actionPhase));
        } else {
          builder2.storeBit(false);
        }
        builder2.storeBit(src2.aborted);
        builder2.storeBit(src2.destroyed);
      } else if (src2.type === "split-install") {
        builder2.storeUint(5, 4);
        builder2.store((0, SplitMergeInfo_1.storeSplitMergeInfo)(src2.splitInfo));
        builder2.storeRef((0, Builder_12.beginCell)().store((0, Transaction_1.storeTransaction)(src2.prepareTransaction)));
        builder2.storeBit(src2.installed);
      } else {
        throw Error(`Unsupported transaction description type ${src2.type}`);
      }
    };
  }
  TransactionDescription$1.storeTransactionDescription = storeTransactionDescription;
  return TransactionDescription$1;
}
var hasRequiredTransaction$1;
function requireTransaction$1() {
  if (hasRequiredTransaction$1) return Transaction$1;
  hasRequiredTransaction$1 = 1;
  Object.defineProperty(Transaction$1, "__esModule", { value: true });
  Transaction$1.storeTransaction = Transaction$1.loadTransaction = void 0;
  const Builder_12 = requireBuilder$3();
  const Dictionary_1 = requireDictionary$1();
  const AccountStatus_1 = requireAccountStatus$1();
  const CurrencyCollection_1 = requireCurrencyCollection$1();
  const HashUpdate_1 = requireHashUpdate$1();
  const Message_1 = requireMessage$1();
  const TransactionDescription_1 = requireTransactionDescription$1();
  function loadTransaction(slice) {
    let raw = slice.asCell();
    if (slice.loadUint(4) !== 7) {
      throw Error("Invalid data");
    }
    let address = slice.loadUintBig(256);
    let lt = slice.loadUintBig(64);
    let prevTransactionHash = slice.loadUintBig(256);
    let prevTransactionLt = slice.loadUintBig(64);
    let now = slice.loadUint(32);
    let outMessagesCount = slice.loadUint(15);
    let oldStatus = (0, AccountStatus_1.loadAccountStatus)(slice);
    let endStatus = (0, AccountStatus_1.loadAccountStatus)(slice);
    let msgRef = slice.loadRef();
    let msgSlice = msgRef.beginParse();
    let inMessage = msgSlice.loadBit() ? (0, Message_1.loadMessage)(msgSlice.loadRef().beginParse()) : void 0;
    let outMessages = msgSlice.loadDict(Dictionary_1.Dictionary.Keys.Uint(15), Message_1.MessageValue);
    msgSlice.endParse();
    let totalFees = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
    let stateUpdate = (0, HashUpdate_1.loadHashUpdate)(slice.loadRef().beginParse());
    let description = (0, TransactionDescription_1.loadTransactionDescription)(slice.loadRef().beginParse());
    return {
      address,
      lt,
      prevTransactionHash,
      prevTransactionLt,
      now,
      outMessagesCount,
      oldStatus,
      endStatus,
      inMessage,
      outMessages,
      totalFees,
      stateUpdate,
      description,
      raw,
      hash: () => raw.hash()
    };
  }
  Transaction$1.loadTransaction = loadTransaction;
  function storeTransaction(src2) {
    return (builder2) => {
      builder2.storeUint(7, 4);
      builder2.storeUint(src2.address, 256);
      builder2.storeUint(src2.lt, 64);
      builder2.storeUint(src2.prevTransactionHash, 256);
      builder2.storeUint(src2.prevTransactionLt, 64);
      builder2.storeUint(src2.now, 32);
      builder2.storeUint(src2.outMessagesCount, 15);
      builder2.store((0, AccountStatus_1.storeAccountStatus)(src2.oldStatus));
      builder2.store((0, AccountStatus_1.storeAccountStatus)(src2.endStatus));
      let msgBuilder = (0, Builder_12.beginCell)();
      if (src2.inMessage) {
        msgBuilder.storeBit(true);
        msgBuilder.storeRef((0, Builder_12.beginCell)().store((0, Message_1.storeMessage)(src2.inMessage)));
      } else {
        msgBuilder.storeBit(false);
      }
      msgBuilder.storeDict(src2.outMessages);
      builder2.storeRef(msgBuilder);
      builder2.store((0, CurrencyCollection_1.storeCurrencyCollection)(src2.totalFees));
      builder2.storeRef((0, Builder_12.beginCell)().store((0, HashUpdate_1.storeHashUpdate)(src2.stateUpdate)));
      builder2.storeRef((0, Builder_12.beginCell)().store((0, TransactionDescription_1.storeTransactionDescription)(src2.description)));
    };
  }
  Transaction$1.storeTransaction = storeTransaction;
  return Transaction$1;
}
var hasRequired_export$1;
function require_export$1() {
  if (hasRequired_export$1) return _export$1;
  hasRequired_export$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadSimpleLibrary = exports.loadShardStateUnsplit = exports.storeShardIdent = exports.loadShardIdent = exports.storeShardAccounts = exports.loadShardAccounts = exports.ShardAccountRefValue = exports.storeShardAccount = exports.loadShardAccount = exports.ReserveMode = exports.SendMode = exports.storeMessageRelaxed = exports.loadMessageRelaxed = exports.storeMessage = exports.loadMessage = exports.loadMasterchainStateExtra = exports.storeHashUpdate = exports.loadHashUpdate = exports.storeExtraCurrency = exports.loadMaybeExtraCurrency = exports.loadExtraCurrency = exports.packExtraCurrencyDict = exports.packExtraCurrencyCell = exports.storeDepthBalanceInfo = exports.loadDepthBalanceInfo = exports.storeCurrencyCollection = exports.loadCurrencyCollection = exports.storeComputeSkipReason = exports.loadComputeSkipReason = exports.storeCommonMessageInfoRelaxed = exports.loadCommonMessageInfoRelaxed = exports.storeCommonMessageInfo = exports.loadCommonMessageInfo = exports.storeOutList = exports.loadOutList = exports.storeOutAction = exports.loadOutAction = exports.storeAccountStorage = exports.loadAccountStorage = exports.storeAccountStatusChange = exports.loadAccountStatusChange = exports.storeAccountStatus = exports.loadAccountStatus = exports.storeAccountState = exports.loadAccountState = exports.storeAccount = exports.loadAccount = exports.comment = exports.external = exports.internal = void 0;
    exports.storeTransactionsStoragePhase = exports.loadTransactionStoragePhase = exports.storeTransactionDescription = exports.loadTransactionDescription = exports.storeTransactionCreditPhase = exports.loadTransactionCreditPhase = exports.storeTransactionComputePhase = exports.loadTransactionComputePhase = exports.storeTransactionBouncePhase = exports.loadTransactionBouncePhase = exports.storeTransactionActionPhase = exports.loadTransactionActionPhase = exports.storeTransaction = exports.loadTransaction = exports.storeTickTock = exports.loadTickTock = exports.storeStorageUsed = exports.loadStorageUsed = exports.storeStorageInfo = exports.loadStorageInfo = exports.storeStateInit = exports.loadStateInit = exports.storeSplitMergeInfo = exports.loadSplitMergeInfo = exports.storeLibRef = exports.loadLibRef = exports.storeSimpleLibrary = void 0;
    var _helpers_1 = require_helpers$1();
    Object.defineProperty(exports, "internal", { enumerable: true, get: function() {
      return _helpers_1.internal;
    } });
    Object.defineProperty(exports, "external", { enumerable: true, get: function() {
      return _helpers_1.external;
    } });
    Object.defineProperty(exports, "comment", { enumerable: true, get: function() {
      return _helpers_1.comment;
    } });
    var Account_1 = requireAccount$1();
    Object.defineProperty(exports, "loadAccount", { enumerable: true, get: function() {
      return Account_1.loadAccount;
    } });
    Object.defineProperty(exports, "storeAccount", { enumerable: true, get: function() {
      return Account_1.storeAccount;
    } });
    var AccountState_1 = requireAccountState$1();
    Object.defineProperty(exports, "loadAccountState", { enumerable: true, get: function() {
      return AccountState_1.loadAccountState;
    } });
    Object.defineProperty(exports, "storeAccountState", { enumerable: true, get: function() {
      return AccountState_1.storeAccountState;
    } });
    var AccountStatus_1 = requireAccountStatus$1();
    Object.defineProperty(exports, "loadAccountStatus", { enumerable: true, get: function() {
      return AccountStatus_1.loadAccountStatus;
    } });
    Object.defineProperty(exports, "storeAccountStatus", { enumerable: true, get: function() {
      return AccountStatus_1.storeAccountStatus;
    } });
    var AccountStatusChange_1 = requireAccountStatusChange$1();
    Object.defineProperty(exports, "loadAccountStatusChange", { enumerable: true, get: function() {
      return AccountStatusChange_1.loadAccountStatusChange;
    } });
    Object.defineProperty(exports, "storeAccountStatusChange", { enumerable: true, get: function() {
      return AccountStatusChange_1.storeAccountStatusChange;
    } });
    var AccountStorage_1 = requireAccountStorage$1();
    Object.defineProperty(exports, "loadAccountStorage", { enumerable: true, get: function() {
      return AccountStorage_1.loadAccountStorage;
    } });
    Object.defineProperty(exports, "storeAccountStorage", { enumerable: true, get: function() {
      return AccountStorage_1.storeAccountStorage;
    } });
    var OutList_1 = requireOutList$1();
    Object.defineProperty(exports, "loadOutAction", { enumerable: true, get: function() {
      return OutList_1.loadOutAction;
    } });
    Object.defineProperty(exports, "storeOutAction", { enumerable: true, get: function() {
      return OutList_1.storeOutAction;
    } });
    Object.defineProperty(exports, "loadOutList", { enumerable: true, get: function() {
      return OutList_1.loadOutList;
    } });
    Object.defineProperty(exports, "storeOutList", { enumerable: true, get: function() {
      return OutList_1.storeOutList;
    } });
    var CommonMessageInfo_1 = requireCommonMessageInfo$1();
    Object.defineProperty(exports, "loadCommonMessageInfo", { enumerable: true, get: function() {
      return CommonMessageInfo_1.loadCommonMessageInfo;
    } });
    Object.defineProperty(exports, "storeCommonMessageInfo", { enumerable: true, get: function() {
      return CommonMessageInfo_1.storeCommonMessageInfo;
    } });
    var CommonMessageInfoRelaxed_1 = requireCommonMessageInfoRelaxed$1();
    Object.defineProperty(exports, "loadCommonMessageInfoRelaxed", { enumerable: true, get: function() {
      return CommonMessageInfoRelaxed_1.loadCommonMessageInfoRelaxed;
    } });
    Object.defineProperty(exports, "storeCommonMessageInfoRelaxed", { enumerable: true, get: function() {
      return CommonMessageInfoRelaxed_1.storeCommonMessageInfoRelaxed;
    } });
    var ComputeSkipReason_1 = requireComputeSkipReason$1();
    Object.defineProperty(exports, "loadComputeSkipReason", { enumerable: true, get: function() {
      return ComputeSkipReason_1.loadComputeSkipReason;
    } });
    Object.defineProperty(exports, "storeComputeSkipReason", { enumerable: true, get: function() {
      return ComputeSkipReason_1.storeComputeSkipReason;
    } });
    var CurrencyCollection_1 = requireCurrencyCollection$1();
    Object.defineProperty(exports, "loadCurrencyCollection", { enumerable: true, get: function() {
      return CurrencyCollection_1.loadCurrencyCollection;
    } });
    Object.defineProperty(exports, "storeCurrencyCollection", { enumerable: true, get: function() {
      return CurrencyCollection_1.storeCurrencyCollection;
    } });
    var DepthBalanceInfo_1 = requireDepthBalanceInfo$1();
    Object.defineProperty(exports, "loadDepthBalanceInfo", { enumerable: true, get: function() {
      return DepthBalanceInfo_1.loadDepthBalanceInfo;
    } });
    Object.defineProperty(exports, "storeDepthBalanceInfo", { enumerable: true, get: function() {
      return DepthBalanceInfo_1.storeDepthBalanceInfo;
    } });
    var ExtraCurrency_1 = requireExtraCurrency$1();
    Object.defineProperty(exports, "packExtraCurrencyCell", { enumerable: true, get: function() {
      return ExtraCurrency_1.packExtraCurrencyCell;
    } });
    Object.defineProperty(exports, "packExtraCurrencyDict", { enumerable: true, get: function() {
      return ExtraCurrency_1.packExtraCurrencyDict;
    } });
    Object.defineProperty(exports, "loadExtraCurrency", { enumerable: true, get: function() {
      return ExtraCurrency_1.loadExtraCurrency;
    } });
    Object.defineProperty(exports, "loadMaybeExtraCurrency", { enumerable: true, get: function() {
      return ExtraCurrency_1.loadMaybeExtraCurrency;
    } });
    Object.defineProperty(exports, "storeExtraCurrency", { enumerable: true, get: function() {
      return ExtraCurrency_1.storeExtraCurrency;
    } });
    var HashUpdate_1 = requireHashUpdate$1();
    Object.defineProperty(exports, "loadHashUpdate", { enumerable: true, get: function() {
      return HashUpdate_1.loadHashUpdate;
    } });
    Object.defineProperty(exports, "storeHashUpdate", { enumerable: true, get: function() {
      return HashUpdate_1.storeHashUpdate;
    } });
    var MasterchainStateExtra_1 = requireMasterchainStateExtra$1();
    Object.defineProperty(exports, "loadMasterchainStateExtra", { enumerable: true, get: function() {
      return MasterchainStateExtra_1.loadMasterchainStateExtra;
    } });
    var Message_1 = requireMessage$1();
    Object.defineProperty(exports, "loadMessage", { enumerable: true, get: function() {
      return Message_1.loadMessage;
    } });
    Object.defineProperty(exports, "storeMessage", { enumerable: true, get: function() {
      return Message_1.storeMessage;
    } });
    var MessageRelaxed_1 = requireMessageRelaxed$1();
    Object.defineProperty(exports, "loadMessageRelaxed", { enumerable: true, get: function() {
      return MessageRelaxed_1.loadMessageRelaxed;
    } });
    Object.defineProperty(exports, "storeMessageRelaxed", { enumerable: true, get: function() {
      return MessageRelaxed_1.storeMessageRelaxed;
    } });
    var SendMode_1 = requireSendMode$1();
    Object.defineProperty(exports, "SendMode", { enumerable: true, get: function() {
      return SendMode_1.SendMode;
    } });
    var ReserveMode_1 = requireReserveMode$1();
    Object.defineProperty(exports, "ReserveMode", { enumerable: true, get: function() {
      return ReserveMode_1.ReserveMode;
    } });
    var ShardAccount_1 = requireShardAccount$1();
    Object.defineProperty(exports, "loadShardAccount", { enumerable: true, get: function() {
      return ShardAccount_1.loadShardAccount;
    } });
    Object.defineProperty(exports, "storeShardAccount", { enumerable: true, get: function() {
      return ShardAccount_1.storeShardAccount;
    } });
    var ShardAccounts_1 = requireShardAccounts$1();
    Object.defineProperty(exports, "ShardAccountRefValue", { enumerable: true, get: function() {
      return ShardAccounts_1.ShardAccountRefValue;
    } });
    Object.defineProperty(exports, "loadShardAccounts", { enumerable: true, get: function() {
      return ShardAccounts_1.loadShardAccounts;
    } });
    Object.defineProperty(exports, "storeShardAccounts", { enumerable: true, get: function() {
      return ShardAccounts_1.storeShardAccounts;
    } });
    var ShardIdent_1 = requireShardIdent$1();
    Object.defineProperty(exports, "loadShardIdent", { enumerable: true, get: function() {
      return ShardIdent_1.loadShardIdent;
    } });
    Object.defineProperty(exports, "storeShardIdent", { enumerable: true, get: function() {
      return ShardIdent_1.storeShardIdent;
    } });
    var ShardStateUnsplit_1 = requireShardStateUnsplit$1();
    Object.defineProperty(exports, "loadShardStateUnsplit", { enumerable: true, get: function() {
      return ShardStateUnsplit_1.loadShardStateUnsplit;
    } });
    var SimpleLibrary_1 = requireSimpleLibrary$1();
    Object.defineProperty(exports, "loadSimpleLibrary", { enumerable: true, get: function() {
      return SimpleLibrary_1.loadSimpleLibrary;
    } });
    Object.defineProperty(exports, "storeSimpleLibrary", { enumerable: true, get: function() {
      return SimpleLibrary_1.storeSimpleLibrary;
    } });
    var LibRef_1 = requireLibRef$1();
    Object.defineProperty(exports, "loadLibRef", { enumerable: true, get: function() {
      return LibRef_1.loadLibRef;
    } });
    Object.defineProperty(exports, "storeLibRef", { enumerable: true, get: function() {
      return LibRef_1.storeLibRef;
    } });
    var SplitMergeInfo_1 = requireSplitMergeInfo$1();
    Object.defineProperty(exports, "loadSplitMergeInfo", { enumerable: true, get: function() {
      return SplitMergeInfo_1.loadSplitMergeInfo;
    } });
    Object.defineProperty(exports, "storeSplitMergeInfo", { enumerable: true, get: function() {
      return SplitMergeInfo_1.storeSplitMergeInfo;
    } });
    var StateInit_1 = requireStateInit$1();
    Object.defineProperty(exports, "loadStateInit", { enumerable: true, get: function() {
      return StateInit_1.loadStateInit;
    } });
    Object.defineProperty(exports, "storeStateInit", { enumerable: true, get: function() {
      return StateInit_1.storeStateInit;
    } });
    var StorageInfo_1 = requireStorageInfo$1();
    Object.defineProperty(exports, "loadStorageInfo", { enumerable: true, get: function() {
      return StorageInfo_1.loadStorageInfo;
    } });
    Object.defineProperty(exports, "storeStorageInfo", { enumerable: true, get: function() {
      return StorageInfo_1.storeStorageInfo;
    } });
    var StorageUsed_1 = requireStorageUsed$1();
    Object.defineProperty(exports, "loadStorageUsed", { enumerable: true, get: function() {
      return StorageUsed_1.loadStorageUsed;
    } });
    Object.defineProperty(exports, "storeStorageUsed", { enumerable: true, get: function() {
      return StorageUsed_1.storeStorageUsed;
    } });
    var TickTock_1 = requireTickTock$1();
    Object.defineProperty(exports, "loadTickTock", { enumerable: true, get: function() {
      return TickTock_1.loadTickTock;
    } });
    Object.defineProperty(exports, "storeTickTock", { enumerable: true, get: function() {
      return TickTock_1.storeTickTock;
    } });
    var Transaction_1 = requireTransaction$1();
    Object.defineProperty(exports, "loadTransaction", { enumerable: true, get: function() {
      return Transaction_1.loadTransaction;
    } });
    Object.defineProperty(exports, "storeTransaction", { enumerable: true, get: function() {
      return Transaction_1.storeTransaction;
    } });
    var TransactionActionPhase_1 = requireTransactionActionPhase$1();
    Object.defineProperty(exports, "loadTransactionActionPhase", { enumerable: true, get: function() {
      return TransactionActionPhase_1.loadTransactionActionPhase;
    } });
    Object.defineProperty(exports, "storeTransactionActionPhase", { enumerable: true, get: function() {
      return TransactionActionPhase_1.storeTransactionActionPhase;
    } });
    var TransactionBouncePhase_1 = requireTransactionBouncePhase$1();
    Object.defineProperty(exports, "loadTransactionBouncePhase", { enumerable: true, get: function() {
      return TransactionBouncePhase_1.loadTransactionBouncePhase;
    } });
    Object.defineProperty(exports, "storeTransactionBouncePhase", { enumerable: true, get: function() {
      return TransactionBouncePhase_1.storeTransactionBouncePhase;
    } });
    var TransactionComputePhase_1 = requireTransactionComputePhase$1();
    Object.defineProperty(exports, "loadTransactionComputePhase", { enumerable: true, get: function() {
      return TransactionComputePhase_1.loadTransactionComputePhase;
    } });
    Object.defineProperty(exports, "storeTransactionComputePhase", { enumerable: true, get: function() {
      return TransactionComputePhase_1.storeTransactionComputePhase;
    } });
    var TransactionCreditPhase_1 = requireTransactionCreditPhase$1();
    Object.defineProperty(exports, "loadTransactionCreditPhase", { enumerable: true, get: function() {
      return TransactionCreditPhase_1.loadTransactionCreditPhase;
    } });
    Object.defineProperty(exports, "storeTransactionCreditPhase", { enumerable: true, get: function() {
      return TransactionCreditPhase_1.storeTransactionCreditPhase;
    } });
    var TransactionDescription_1 = requireTransactionDescription$1();
    Object.defineProperty(exports, "loadTransactionDescription", { enumerable: true, get: function() {
      return TransactionDescription_1.loadTransactionDescription;
    } });
    Object.defineProperty(exports, "storeTransactionDescription", { enumerable: true, get: function() {
      return TransactionDescription_1.storeTransactionDescription;
    } });
    var TransactionStoragePhase_1 = requireTransactionStoragePhase$1();
    Object.defineProperty(exports, "loadTransactionStoragePhase", { enumerable: true, get: function() {
      return TransactionStoragePhase_1.loadTransactionStoragePhase;
    } });
    Object.defineProperty(exports, "storeTransactionsStoragePhase", { enumerable: true, get: function() {
      return TransactionStoragePhase_1.storeTransactionsStoragePhase;
    } });
  })(_export$1);
  return _export$1;
}
var openContract$1 = {};
var hasRequiredOpenContract$1;
function requireOpenContract$1() {
  if (hasRequiredOpenContract$1) return openContract$1;
  hasRequiredOpenContract$1 = 1;
  Object.defineProperty(openContract$1, "__esModule", { value: true });
  openContract$1.openContract = void 0;
  const Address_1 = requireAddress$1();
  const Cell_1 = requireCell$1();
  function openContract2(src2, factory) {
    let address;
    let init = null;
    if (!Address_1.Address.isAddress(src2.address)) {
      throw Error("Invalid address");
    }
    address = src2.address;
    if (src2.init) {
      if (!(src2.init.code instanceof Cell_1.Cell)) {
        throw Error("Invalid init.code");
      }
      if (!(src2.init.data instanceof Cell_1.Cell)) {
        throw Error("Invalid init.data");
      }
      init = src2.init;
    }
    let executor = factory({ address, init });
    return new Proxy(src2, {
      get(target, prop) {
        const value = target[prop];
        if (typeof prop === "string" && (prop.startsWith("get") || prop.startsWith("send") || prop.startsWith("is"))) {
          if (typeof value === "function") {
            return (...args) => value.apply(target, [executor, ...args]);
          }
        }
        return value;
      }
    });
  }
  openContract$1.openContract = openContract2;
  return openContract$1;
}
var ComputeError$1 = {};
var hasRequiredComputeError$1;
function requireComputeError$1() {
  if (hasRequiredComputeError$1) return ComputeError$1;
  hasRequiredComputeError$1 = 1;
  Object.defineProperty(ComputeError$1, "__esModule", { value: true });
  ComputeError$1.ComputeError = void 0;
  class ComputeError2 extends Error {
    constructor(message, exitCode, opts) {
      super(message);
      this.exitCode = exitCode;
      this.debugLogs = opts && opts.debugLogs ? opts.debugLogs : null;
      this.logs = opts && opts.logs ? opts.logs : null;
      Object.setPrototypeOf(this, ComputeError2.prototype);
    }
  }
  ComputeError$1.ComputeError = ComputeError2;
  return ComputeError$1;
}
var getMethodId$1 = {};
var hasRequiredGetMethodId$1;
function requireGetMethodId$1() {
  if (hasRequiredGetMethodId$1) return getMethodId$1;
  hasRequiredGetMethodId$1 = 1;
  Object.defineProperty(getMethodId$1, "__esModule", { value: true });
  getMethodId$1.getMethodId = void 0;
  const TABLE = new Int16Array([
    0,
    4129,
    8258,
    12387,
    16516,
    20645,
    24774,
    28903,
    33032,
    37161,
    41290,
    45419,
    49548,
    53677,
    57806,
    61935,
    4657,
    528,
    12915,
    8786,
    21173,
    17044,
    29431,
    25302,
    37689,
    33560,
    45947,
    41818,
    54205,
    50076,
    62463,
    58334,
    9314,
    13379,
    1056,
    5121,
    25830,
    29895,
    17572,
    21637,
    42346,
    46411,
    34088,
    38153,
    58862,
    62927,
    50604,
    54669,
    13907,
    9842,
    5649,
    1584,
    30423,
    26358,
    22165,
    18100,
    46939,
    42874,
    38681,
    34616,
    63455,
    59390,
    55197,
    51132,
    18628,
    22757,
    26758,
    30887,
    2112,
    6241,
    10242,
    14371,
    51660,
    55789,
    59790,
    63919,
    35144,
    39273,
    43274,
    47403,
    23285,
    19156,
    31415,
    27286,
    6769,
    2640,
    14899,
    10770,
    56317,
    52188,
    64447,
    60318,
    39801,
    35672,
    47931,
    43802,
    27814,
    31879,
    19684,
    23749,
    11298,
    15363,
    3168,
    7233,
    60846,
    64911,
    52716,
    56781,
    44330,
    48395,
    36200,
    40265,
    32407,
    28342,
    24277,
    20212,
    15891,
    11826,
    7761,
    3696,
    65439,
    61374,
    57309,
    53244,
    48923,
    44858,
    40793,
    36728,
    37256,
    33193,
    45514,
    41451,
    53516,
    49453,
    61774,
    57711,
    4224,
    161,
    12482,
    8419,
    20484,
    16421,
    28742,
    24679,
    33721,
    37784,
    41979,
    46042,
    49981,
    54044,
    58239,
    62302,
    689,
    4752,
    8947,
    13010,
    16949,
    21012,
    25207,
    29270,
    46570,
    42443,
    38312,
    34185,
    62830,
    58703,
    54572,
    50445,
    13538,
    9411,
    5280,
    1153,
    29798,
    25671,
    21540,
    17413,
    42971,
    47098,
    34713,
    38840,
    59231,
    63358,
    50973,
    55100,
    9939,
    14066,
    1681,
    5808,
    26199,
    30326,
    17941,
    22068,
    55628,
    51565,
    63758,
    59695,
    39368,
    35305,
    47498,
    43435,
    22596,
    18533,
    30726,
    26663,
    6336,
    2273,
    14466,
    10403,
    52093,
    56156,
    60223,
    64286,
    35833,
    39896,
    43963,
    48026,
    19061,
    23124,
    27191,
    31254,
    2801,
    6864,
    10931,
    14994,
    64814,
    60687,
    56684,
    52557,
    48554,
    44427,
    40424,
    36297,
    31782,
    27655,
    23652,
    19525,
    15522,
    11395,
    7392,
    3265,
    61215,
    65342,
    53085,
    57212,
    44955,
    49082,
    36825,
    40952,
    28183,
    32310,
    20053,
    24180,
    11923,
    16050,
    3793,
    7920
  ]);
  function crc162(data) {
    if (!(data instanceof Buffer)) {
      data = Buffer.from(data);
    }
    let crc = 0;
    for (let index = 0; index < data.length; index++) {
      const byte = data[index];
      crc = (TABLE[(crc >> 8 ^ byte) & 255] ^ crc << 8) & 65535;
    }
    return crc;
  }
  function getMethodId2(name) {
    return crc162(name) & 65535 | 65536;
  }
  getMethodId$1.getMethodId = getMethodId2;
  return getMethodId$1;
}
var safeSign$1 = {};
var hasRequiredSafeSign$1;
function requireSafeSign$1() {
  if (hasRequiredSafeSign$1) return safeSign$1;
  hasRequiredSafeSign$1 = 1;
  Object.defineProperty(safeSign$1, "__esModule", { value: true });
  safeSign$1.safeSignVerify = safeSign$1.safeSign = void 0;
  const crypto_1 = requireDist$6();
  const MIN_SEED_LENGTH = 8;
  const MAX_SEED_LENGTH = 64;
  function createSafeSignHash(cell, seed) {
    let seedData = Buffer.from(seed);
    if (seedData.length > MAX_SEED_LENGTH) {
      throw Error("Seed can	 be longer than 64 bytes");
    }
    if (seedData.length < MIN_SEED_LENGTH) {
      throw Error("Seed must be at least 8 bytes");
    }
    return (0, crypto_1.sha256_sync)(Buffer.concat([Buffer.from([255, 255]), seedData, cell.hash()]));
  }
  function safeSign2(cell, secretKey, seed = "ton-safe-sign-magic") {
    return (0, crypto_1.sign)(createSafeSignHash(cell, seed), secretKey);
  }
  safeSign$1.safeSign = safeSign2;
  function safeSignVerify(cell, signature, publicKey, seed = "ton-safe-sign-magic") {
    return (0, crypto_1.signVerify)(createSafeSignHash(cell, seed), signature, publicKey);
  }
  safeSign$1.safeSignVerify = safeSignVerify;
  return safeSign$1;
}
var hasRequiredDist$5;
function requireDist$5() {
  if (hasRequiredDist$5) return dist$6;
  hasRequiredDist$5 = 1;
  (function(exports) {
    var __createBinding = dist$6 && dist$6.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = dist$6 && dist$6.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.safeSignVerify = exports.safeSign = exports.getMethodId = exports.base32Encode = exports.base32Decode = exports.crc32c = exports.crc16 = exports.fromNano = exports.toNano = exports.ComputeError = exports.openContract = exports.TupleBuilder = exports.TupleReader = exports.serializeTupleItem = exports.parseTupleItem = exports.serializeTuple = exports.parseTuple = exports.generateMerkleUpdate = exports.generateMerkleProofDirect = exports.generateMerkleProof = exports.exoticPruned = exports.exoticMerkleUpdate = exports.convertToMerkleProof = exports.exoticMerkleProof = exports.Dictionary = exports.Cell = exports.CellType = exports.Slice = exports.beginCell = exports.Builder = exports.BitBuilder = exports.BitReader = exports.BitString = exports.contractAddress = exports.ADNLAddress = exports.ExternalAddress = exports.address = exports.Address = void 0;
    var Address_1 = requireAddress$1();
    Object.defineProperty(exports, "Address", { enumerable: true, get: function() {
      return Address_1.Address;
    } });
    Object.defineProperty(exports, "address", { enumerable: true, get: function() {
      return Address_1.address;
    } });
    var ExternalAddress_1 = requireExternalAddress$1();
    Object.defineProperty(exports, "ExternalAddress", { enumerable: true, get: function() {
      return ExternalAddress_1.ExternalAddress;
    } });
    var ADNLAddress_1 = requireADNLAddress$1();
    Object.defineProperty(exports, "ADNLAddress", { enumerable: true, get: function() {
      return ADNLAddress_1.ADNLAddress;
    } });
    var contractAddress_1 = requireContractAddress$1();
    Object.defineProperty(exports, "contractAddress", { enumerable: true, get: function() {
      return contractAddress_1.contractAddress;
    } });
    var BitString_1 = requireBitString$1();
    Object.defineProperty(exports, "BitString", { enumerable: true, get: function() {
      return BitString_1.BitString;
    } });
    var BitReader_1 = requireBitReader$1();
    Object.defineProperty(exports, "BitReader", { enumerable: true, get: function() {
      return BitReader_1.BitReader;
    } });
    var BitBuilder_1 = requireBitBuilder$1();
    Object.defineProperty(exports, "BitBuilder", { enumerable: true, get: function() {
      return BitBuilder_1.BitBuilder;
    } });
    var Builder_12 = requireBuilder$3();
    Object.defineProperty(exports, "Builder", { enumerable: true, get: function() {
      return Builder_12.Builder;
    } });
    Object.defineProperty(exports, "beginCell", { enumerable: true, get: function() {
      return Builder_12.beginCell;
    } });
    var Slice_1 = requireSlice$1();
    Object.defineProperty(exports, "Slice", { enumerable: true, get: function() {
      return Slice_1.Slice;
    } });
    var CellType_1 = requireCellType$1();
    Object.defineProperty(exports, "CellType", { enumerable: true, get: function() {
      return CellType_1.CellType;
    } });
    var Cell_1 = requireCell$1();
    Object.defineProperty(exports, "Cell", { enumerable: true, get: function() {
      return Cell_1.Cell;
    } });
    var Dictionary_1 = requireDictionary$1();
    Object.defineProperty(exports, "Dictionary", { enumerable: true, get: function() {
      return Dictionary_1.Dictionary;
    } });
    var exoticMerkleProof_1 = requireExoticMerkleProof$1();
    Object.defineProperty(exports, "exoticMerkleProof", { enumerable: true, get: function() {
      return exoticMerkleProof_1.exoticMerkleProof;
    } });
    Object.defineProperty(exports, "convertToMerkleProof", { enumerable: true, get: function() {
      return exoticMerkleProof_1.convertToMerkleProof;
    } });
    var exoticMerkleUpdate_1 = requireExoticMerkleUpdate$1();
    Object.defineProperty(exports, "exoticMerkleUpdate", { enumerable: true, get: function() {
      return exoticMerkleUpdate_1.exoticMerkleUpdate;
    } });
    var exoticPruned_1 = requireExoticPruned$1();
    Object.defineProperty(exports, "exoticPruned", { enumerable: true, get: function() {
      return exoticPruned_1.exoticPruned;
    } });
    var generateMerkleProof_1 = requireGenerateMerkleProof$1();
    Object.defineProperty(exports, "generateMerkleProof", { enumerable: true, get: function() {
      return generateMerkleProof_1.generateMerkleProof;
    } });
    Object.defineProperty(exports, "generateMerkleProofDirect", { enumerable: true, get: function() {
      return generateMerkleProof_1.generateMerkleProofDirect;
    } });
    var generateMerkleUpdate_1 = requireGenerateMerkleUpdate$1();
    Object.defineProperty(exports, "generateMerkleUpdate", { enumerable: true, get: function() {
      return generateMerkleUpdate_1.generateMerkleUpdate;
    } });
    var tuple_1 = requireTuple$1();
    Object.defineProperty(exports, "parseTuple", { enumerable: true, get: function() {
      return tuple_1.parseTuple;
    } });
    Object.defineProperty(exports, "serializeTuple", { enumerable: true, get: function() {
      return tuple_1.serializeTuple;
    } });
    Object.defineProperty(exports, "parseTupleItem", { enumerable: true, get: function() {
      return tuple_1.parseTupleItem;
    } });
    Object.defineProperty(exports, "serializeTupleItem", { enumerable: true, get: function() {
      return tuple_1.serializeTupleItem;
    } });
    var reader_1 = requireReader$1();
    Object.defineProperty(exports, "TupleReader", { enumerable: true, get: function() {
      return reader_1.TupleReader;
    } });
    var builder_1 = requireBuilder$2();
    Object.defineProperty(exports, "TupleBuilder", { enumerable: true, get: function() {
      return builder_1.TupleBuilder;
    } });
    __exportStar(require_export$1(), exports);
    var openContract_1 = requireOpenContract$1();
    Object.defineProperty(exports, "openContract", { enumerable: true, get: function() {
      return openContract_1.openContract;
    } });
    var ComputeError_1 = requireComputeError$1();
    Object.defineProperty(exports, "ComputeError", { enumerable: true, get: function() {
      return ComputeError_1.ComputeError;
    } });
    var convert_1 = requireConvert$1();
    Object.defineProperty(exports, "toNano", { enumerable: true, get: function() {
      return convert_1.toNano;
    } });
    Object.defineProperty(exports, "fromNano", { enumerable: true, get: function() {
      return convert_1.fromNano;
    } });
    var crc16_1 = requireCrc16$1();
    Object.defineProperty(exports, "crc16", { enumerable: true, get: function() {
      return crc16_1.crc16;
    } });
    var crc32c_1 = requireCrc32c$1();
    Object.defineProperty(exports, "crc32c", { enumerable: true, get: function() {
      return crc32c_1.crc32c;
    } });
    var base32_1 = requireBase32$1();
    Object.defineProperty(exports, "base32Decode", { enumerable: true, get: function() {
      return base32_1.base32Decode;
    } });
    Object.defineProperty(exports, "base32Encode", { enumerable: true, get: function() {
      return base32_1.base32Encode;
    } });
    var getMethodId_1 = requireGetMethodId$1();
    Object.defineProperty(exports, "getMethodId", { enumerable: true, get: function() {
      return getMethodId_1.getMethodId;
    } });
    var safeSign_1 = requireSafeSign$1();
    Object.defineProperty(exports, "safeSign", { enumerable: true, get: function() {
      return safeSign_1.safeSign;
    } });
    Object.defineProperty(exports, "safeSignVerify", { enumerable: true, get: function() {
      return safeSign_1.safeSignVerify;
    } });
  })(dist$6);
  return dist$6;
}
var distExports$1 = requireDist$5();
var JettonErrorCode;
(function(JettonErrorCode2) {
  JettonErrorCode2["INVALID_ADDRESS"] = "INVALID_ADDRESS";
  JettonErrorCode2["JETTON_NOT_FOUND"] = "JETTON_NOT_FOUND";
  JettonErrorCode2["INSUFFICIENT_BALANCE"] = "INSUFFICIENT_BALANCE";
  JettonErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
  JettonErrorCode2["INVALID_AMOUNT"] = "INVALID_AMOUNT";
  JettonErrorCode2["PREPARATION_FAILED"] = "PREPARATION_FAILED";
})(JettonErrorCode || (JettonErrorCode = {}));
var LogLevel;
(function(LogLevel2) {
  LogLevel2[LogLevel2["DEBUG"] = 0] = "DEBUG";
  LogLevel2[LogLevel2["INFO"] = 1] = "INFO";
  LogLevel2[LogLevel2["WARN"] = 2] = "WARN";
  LogLevel2[LogLevel2["ERROR"] = 3] = "ERROR";
  LogLevel2[LogLevel2["NONE"] = 4] = "NONE";
})(LogLevel || (LogLevel = {}));
class Logger {
  config;
  parent;
  static defaultConfig = {
    level: LogLevel.INFO,
    prefix: "TonWalletKit",
    enableTimestamp: true,
    enableStackTrace: false
  };
  constructor(config) {
    this.parent = config?.parent;
    this.config = { ...Logger.defaultConfig, ...config };
    if (this.parent) {
      this.config = {
        ...this.parent.config,
        ...config,
        // Build hierarchical prefix
        prefix: this.buildHierarchicalPrefix(config?.prefix)
      };
    }
  }
  /**
   * Update logger configuration
   */
  configure(config) {
    this.config = { ...this.config, ...config };
  }
  /**
   * Create a child logger with a prefix that inherits from this logger
   */
  createChild(prefix, config) {
    return new Logger({
      ...config,
      parent: this,
      prefix
    });
  }
  /**
   * Build hierarchical prefix by combining parent prefix with current prefix
   */
  buildHierarchicalPrefix(currentPrefix) {
    if (!this.parent || !currentPrefix) {
      return currentPrefix || this.parent?.config.prefix || "";
    }
    const parentPrefix = this.parent.config.prefix;
    if (!parentPrefix) {
      return currentPrefix;
    }
    return `${parentPrefix}:${currentPrefix}`;
  }
  /**
   * Get the full hierarchical prefix for this logger
   */
  getPrefix() {
    return this.config.prefix || "";
  }
  /**
   * Get the parent logger if it exists
   */
  getParent() {
    return this.parent;
  }
  /**
   * Log debug messages
   */
  debug(message, context) {
    if (this.config.level <= LogLevel.DEBUG) {
      this.log("DEBUG", message, context);
    }
  }
  /**
   * Log info messages
   */
  info(message, context) {
    if (this.config.level <= LogLevel.INFO) {
      this.log("INFO", message, context);
    }
  }
  /**
   * Log warning messages
   */
  warn(message, context) {
    if (this.config.level <= LogLevel.WARN) {
      this.log("WARN", message, context);
    }
  }
  /**
   * Log error messages
   */
  error(message, context) {
    if (this.config.level <= LogLevel.ERROR) {
      this.log("ERROR", message, context);
    }
  }
  /**
   * Internal logging method
   */
  log(level, message, context) {
    const timestamp = this.config.enableTimestamp ? (/* @__PURE__ */ new Date()).toISOString() : "";
    const prefix = this.config.prefix ? `[${this.config.prefix}]` : "";
    let logMessage = "";
    if (timestamp) {
      logMessage += `${timestamp} `;
    }
    if (prefix) {
      logMessage += `${prefix} `;
    }
    logMessage += `${level}: ${message}`;
    const logArgs = [logMessage];
    if (context && Object.keys(context).length > 0) {
      logArgs.push(context);
    }
    switch (level) {
      case "DEBUG":
        console.debug(...logArgs);
        break;
      case "INFO":
        console.info(...logArgs);
        break;
      case "WARN":
        console.warn(...logArgs);
        break;
      case "ERROR":
        console.error(...logArgs);
        if (this.config.enableStackTrace) {
          console.trace();
        }
        break;
    }
  }
}
const globalLogger = new Logger({
  level: LogLevel.DEBUG,
  enableStackTrace: true
});
globalLogger.createChild("StorageAdapter");
globalLogger.createChild("Storage");
globalLogger.createChild("WalletManager");
globalLogger.createChild("SessionManager");
var util$9;
var hasRequiredUtil$1;
function requireUtil$1() {
  if (hasRequiredUtil$1) return util$9;
  hasRequiredUtil$1 = 1;
  const ERROR_MSG_INPUT = "Input must be an string, Buffer or Uint8Array";
  function normalizeInput(input) {
    let ret;
    if (input instanceof Uint8Array) {
      ret = input;
    } else if (typeof input === "string") {
      const encoder = new TextEncoder();
      ret = encoder.encode(input);
    } else {
      throw new Error(ERROR_MSG_INPUT);
    }
    return ret;
  }
  function toHex(bytes) {
    return Array.prototype.map.call(bytes, function(n) {
      return (n < 16 ? "0" : "") + n.toString(16);
    }).join("");
  }
  function uint32ToHex(val) {
    return (4294967296 + val).toString(16).substring(1);
  }
  function debugPrint(label, arr, size) {
    let msg = "\n" + label + " = ";
    for (let i = 0; i < arr.length; i += 2) {
      if (size === 32) {
        msg += uint32ToHex(arr[i]).toUpperCase();
        msg += " ";
        msg += uint32ToHex(arr[i + 1]).toUpperCase();
      } else if (size === 64) {
        msg += uint32ToHex(arr[i + 1]).toUpperCase();
        msg += uint32ToHex(arr[i]).toUpperCase();
      } else throw new Error("Invalid size " + size);
      if (i % 6 === 4) {
        msg += "\n" + new Array(label.length + 4).join(" ");
      } else if (i < arr.length - 2) {
        msg += " ";
      }
    }
    console.log(msg);
  }
  function testSpeed(hashFn, N, M) {
    let startMs = (/* @__PURE__ */ new Date()).getTime();
    const input = new Uint8Array(N);
    for (let i = 0; i < N; i++) {
      input[i] = i % 256;
    }
    const genMs = (/* @__PURE__ */ new Date()).getTime();
    console.log("Generated random input in " + (genMs - startMs) + "ms");
    startMs = genMs;
    for (let i = 0; i < M; i++) {
      const hashHex = hashFn(input);
      const hashMs = (/* @__PURE__ */ new Date()).getTime();
      const ms = hashMs - startMs;
      startMs = hashMs;
      console.log("Hashed in " + ms + "ms: " + hashHex.substring(0, 20) + "...");
      console.log(
        Math.round(N / (1 << 20) / (ms / 1e3) * 100) / 100 + " MB PER SECOND"
      );
    }
  }
  util$9 = {
    normalizeInput,
    toHex,
    debugPrint,
    testSpeed
  };
  return util$9;
}
var blake2b_1;
var hasRequiredBlake2b;
function requireBlake2b() {
  if (hasRequiredBlake2b) return blake2b_1;
  hasRequiredBlake2b = 1;
  const util2 = requireUtil$1();
  function ADD64AA(v3, a, b) {
    const o0 = v3[a] + v3[b];
    let o1 = v3[a + 1] + v3[b + 1];
    if (o0 >= 4294967296) {
      o1++;
    }
    v3[a] = o0;
    v3[a + 1] = o1;
  }
  function ADD64AC(v3, a, b0, b1) {
    let o0 = v3[a] + b0;
    if (b0 < 0) {
      o0 += 4294967296;
    }
    let o1 = v3[a + 1] + b1;
    if (o0 >= 4294967296) {
      o1++;
    }
    v3[a] = o0;
    v3[a + 1] = o1;
  }
  function B2B_GET32(arr, i) {
    return arr[i] ^ arr[i + 1] << 8 ^ arr[i + 2] << 16 ^ arr[i + 3] << 24;
  }
  function B2B_G(a, b, c, d, ix, iy) {
    const x0 = m[ix];
    const x1 = m[ix + 1];
    const y0 = m[iy];
    const y1 = m[iy + 1];
    ADD64AA(v2, a, b);
    ADD64AC(v2, a, x0, x1);
    let xor0 = v2[d] ^ v2[a];
    let xor1 = v2[d + 1] ^ v2[a + 1];
    v2[d] = xor1;
    v2[d + 1] = xor0;
    ADD64AA(v2, c, d);
    xor0 = v2[b] ^ v2[c];
    xor1 = v2[b + 1] ^ v2[c + 1];
    v2[b] = xor0 >>> 24 ^ xor1 << 8;
    v2[b + 1] = xor1 >>> 24 ^ xor0 << 8;
    ADD64AA(v2, a, b);
    ADD64AC(v2, a, y0, y1);
    xor0 = v2[d] ^ v2[a];
    xor1 = v2[d + 1] ^ v2[a + 1];
    v2[d] = xor0 >>> 16 ^ xor1 << 16;
    v2[d + 1] = xor1 >>> 16 ^ xor0 << 16;
    ADD64AA(v2, c, d);
    xor0 = v2[b] ^ v2[c];
    xor1 = v2[b + 1] ^ v2[c + 1];
    v2[b] = xor1 >>> 31 ^ xor0 << 1;
    v2[b + 1] = xor0 >>> 31 ^ xor1 << 1;
  }
  const BLAKE2B_IV32 = new Uint32Array([
    4089235720,
    1779033703,
    2227873595,
    3144134277,
    4271175723,
    1013904242,
    1595750129,
    2773480762,
    2917565137,
    1359893119,
    725511199,
    2600822924,
    4215389547,
    528734635,
    327033209,
    1541459225
  ]);
  const SIGMA8 = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3,
    11,
    8,
    12,
    0,
    5,
    2,
    15,
    13,
    10,
    14,
    3,
    6,
    7,
    1,
    9,
    4,
    7,
    9,
    3,
    1,
    13,
    12,
    11,
    14,
    2,
    6,
    5,
    10,
    4,
    0,
    15,
    8,
    9,
    0,
    5,
    7,
    2,
    4,
    10,
    15,
    14,
    1,
    11,
    12,
    6,
    8,
    3,
    13,
    2,
    12,
    6,
    10,
    0,
    11,
    8,
    3,
    4,
    13,
    7,
    5,
    15,
    14,
    1,
    9,
    12,
    5,
    1,
    15,
    14,
    13,
    4,
    10,
    0,
    7,
    6,
    3,
    9,
    2,
    8,
    11,
    13,
    11,
    7,
    14,
    12,
    1,
    3,
    9,
    5,
    0,
    15,
    4,
    8,
    6,
    2,
    10,
    6,
    15,
    14,
    9,
    11,
    3,
    0,
    8,
    12,
    2,
    13,
    7,
    1,
    4,
    10,
    5,
    10,
    2,
    8,
    4,
    7,
    6,
    1,
    5,
    15,
    11,
    9,
    14,
    3,
    12,
    13,
    0,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3
  ];
  const SIGMA82 = new Uint8Array(
    SIGMA8.map(function(x) {
      return x * 2;
    })
  );
  const v2 = new Uint32Array(32);
  const m = new Uint32Array(32);
  function blake2bCompress(ctx, last) {
    let i = 0;
    for (i = 0; i < 16; i++) {
      v2[i] = ctx.h[i];
      v2[i + 16] = BLAKE2B_IV32[i];
    }
    v2[24] = v2[24] ^ ctx.t;
    v2[25] = v2[25] ^ ctx.t / 4294967296;
    if (last) {
      v2[28] = ~v2[28];
      v2[29] = ~v2[29];
    }
    for (i = 0; i < 32; i++) {
      m[i] = B2B_GET32(ctx.b, 4 * i);
    }
    for (i = 0; i < 12; i++) {
      B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1]);
      B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3]);
      B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5]);
      B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7]);
      B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9]);
      B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11]);
      B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13]);
      B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15]);
    }
    for (i = 0; i < 16; i++) {
      ctx.h[i] = ctx.h[i] ^ v2[i] ^ v2[i + 16];
    }
  }
  const parameterBlock = new Uint8Array([
    0,
    0,
    0,
    0,
    //  0: outlen, keylen, fanout, depth
    0,
    0,
    0,
    0,
    //  4: leaf length, sequential mode
    0,
    0,
    0,
    0,
    //  8: node offset
    0,
    0,
    0,
    0,
    // 12: node offset
    0,
    0,
    0,
    0,
    // 16: node depth, inner length, rfu
    0,
    0,
    0,
    0,
    // 20: rfu
    0,
    0,
    0,
    0,
    // 24: rfu
    0,
    0,
    0,
    0,
    // 28: rfu
    0,
    0,
    0,
    0,
    // 32: salt
    0,
    0,
    0,
    0,
    // 36: salt
    0,
    0,
    0,
    0,
    // 40: salt
    0,
    0,
    0,
    0,
    // 44: salt
    0,
    0,
    0,
    0,
    // 48: personal
    0,
    0,
    0,
    0,
    // 52: personal
    0,
    0,
    0,
    0,
    // 56: personal
    0,
    0,
    0,
    0
    // 60: personal
  ]);
  function blake2bInit(outlen, key2, salt, personal) {
    if (outlen === 0 || outlen > 64) {
      throw new Error("Illegal output length, expected 0 < length <= 64");
    }
    if (key2 && key2.length > 64) {
      throw new Error("Illegal key, expected Uint8Array with 0 < length <= 64");
    }
    if (salt && salt.length !== 16) {
      throw new Error("Illegal salt, expected Uint8Array with length is 16");
    }
    if (personal && personal.length !== 16) {
      throw new Error("Illegal personal, expected Uint8Array with length is 16");
    }
    const ctx = {
      b: new Uint8Array(128),
      h: new Uint32Array(16),
      t: 0,
      // input count
      c: 0,
      // pointer within buffer
      outlen
      // output length in bytes
    };
    parameterBlock.fill(0);
    parameterBlock[0] = outlen;
    if (key2) parameterBlock[1] = key2.length;
    parameterBlock[2] = 1;
    parameterBlock[3] = 1;
    if (salt) parameterBlock.set(salt, 32);
    if (personal) parameterBlock.set(personal, 48);
    for (let i = 0; i < 16; i++) {
      ctx.h[i] = BLAKE2B_IV32[i] ^ B2B_GET32(parameterBlock, i * 4);
    }
    if (key2) {
      blake2bUpdate(ctx, key2);
      ctx.c = 128;
    }
    return ctx;
  }
  function blake2bUpdate(ctx, input) {
    for (let i = 0; i < input.length; i++) {
      if (ctx.c === 128) {
        ctx.t += ctx.c;
        blake2bCompress(ctx, false);
        ctx.c = 0;
      }
      ctx.b[ctx.c++] = input[i];
    }
  }
  function blake2bFinal(ctx) {
    ctx.t += ctx.c;
    while (ctx.c < 128) {
      ctx.b[ctx.c++] = 0;
    }
    blake2bCompress(ctx, true);
    const out = new Uint8Array(ctx.outlen);
    for (let i = 0; i < ctx.outlen; i++) {
      out[i] = ctx.h[i >> 2] >> 8 * (i & 3);
    }
    return out;
  }
  function blake2b(input, key2, outlen, salt, personal) {
    outlen = outlen || 64;
    input = util2.normalizeInput(input);
    if (salt) {
      salt = util2.normalizeInput(salt);
    }
    if (personal) {
      personal = util2.normalizeInput(personal);
    }
    const ctx = blake2bInit(outlen, key2, salt, personal);
    blake2bUpdate(ctx, input);
    return blake2bFinal(ctx);
  }
  function blake2bHex(input, key2, outlen, salt, personal) {
    const output = blake2b(input, key2, outlen, salt, personal);
    return util2.toHex(output);
  }
  blake2b_1 = {
    blake2b,
    blake2bHex,
    blake2bInit,
    blake2bUpdate,
    blake2bFinal
  };
  return blake2b_1;
}
var blake2s_1;
var hasRequiredBlake2s;
function requireBlake2s() {
  if (hasRequiredBlake2s) return blake2s_1;
  hasRequiredBlake2s = 1;
  const util2 = requireUtil$1();
  function B2S_GET32(v3, i) {
    return v3[i] ^ v3[i + 1] << 8 ^ v3[i + 2] << 16 ^ v3[i + 3] << 24;
  }
  function B2S_G(a, b, c, d, x, y) {
    v2[a] = v2[a] + v2[b] + x;
    v2[d] = ROTR32(v2[d] ^ v2[a], 16);
    v2[c] = v2[c] + v2[d];
    v2[b] = ROTR32(v2[b] ^ v2[c], 12);
    v2[a] = v2[a] + v2[b] + y;
    v2[d] = ROTR32(v2[d] ^ v2[a], 8);
    v2[c] = v2[c] + v2[d];
    v2[b] = ROTR32(v2[b] ^ v2[c], 7);
  }
  function ROTR32(x, y) {
    return x >>> y ^ x << 32 - y;
  }
  const BLAKE2S_IV = new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  const SIGMA = new Uint8Array([
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3,
    11,
    8,
    12,
    0,
    5,
    2,
    15,
    13,
    10,
    14,
    3,
    6,
    7,
    1,
    9,
    4,
    7,
    9,
    3,
    1,
    13,
    12,
    11,
    14,
    2,
    6,
    5,
    10,
    4,
    0,
    15,
    8,
    9,
    0,
    5,
    7,
    2,
    4,
    10,
    15,
    14,
    1,
    11,
    12,
    6,
    8,
    3,
    13,
    2,
    12,
    6,
    10,
    0,
    11,
    8,
    3,
    4,
    13,
    7,
    5,
    15,
    14,
    1,
    9,
    12,
    5,
    1,
    15,
    14,
    13,
    4,
    10,
    0,
    7,
    6,
    3,
    9,
    2,
    8,
    11,
    13,
    11,
    7,
    14,
    12,
    1,
    3,
    9,
    5,
    0,
    15,
    4,
    8,
    6,
    2,
    10,
    6,
    15,
    14,
    9,
    11,
    3,
    0,
    8,
    12,
    2,
    13,
    7,
    1,
    4,
    10,
    5,
    10,
    2,
    8,
    4,
    7,
    6,
    1,
    5,
    15,
    11,
    9,
    14,
    3,
    12,
    13,
    0
  ]);
  const v2 = new Uint32Array(16);
  const m = new Uint32Array(16);
  function blake2sCompress(ctx, last) {
    let i = 0;
    for (i = 0; i < 8; i++) {
      v2[i] = ctx.h[i];
      v2[i + 8] = BLAKE2S_IV[i];
    }
    v2[12] ^= ctx.t;
    v2[13] ^= ctx.t / 4294967296;
    if (last) {
      v2[14] = ~v2[14];
    }
    for (i = 0; i < 16; i++) {
      m[i] = B2S_GET32(ctx.b, 4 * i);
    }
    for (i = 0; i < 10; i++) {
      B2S_G(0, 4, 8, 12, m[SIGMA[i * 16 + 0]], m[SIGMA[i * 16 + 1]]);
      B2S_G(1, 5, 9, 13, m[SIGMA[i * 16 + 2]], m[SIGMA[i * 16 + 3]]);
      B2S_G(2, 6, 10, 14, m[SIGMA[i * 16 + 4]], m[SIGMA[i * 16 + 5]]);
      B2S_G(3, 7, 11, 15, m[SIGMA[i * 16 + 6]], m[SIGMA[i * 16 + 7]]);
      B2S_G(0, 5, 10, 15, m[SIGMA[i * 16 + 8]], m[SIGMA[i * 16 + 9]]);
      B2S_G(1, 6, 11, 12, m[SIGMA[i * 16 + 10]], m[SIGMA[i * 16 + 11]]);
      B2S_G(2, 7, 8, 13, m[SIGMA[i * 16 + 12]], m[SIGMA[i * 16 + 13]]);
      B2S_G(3, 4, 9, 14, m[SIGMA[i * 16 + 14]], m[SIGMA[i * 16 + 15]]);
    }
    for (i = 0; i < 8; i++) {
      ctx.h[i] ^= v2[i] ^ v2[i + 8];
    }
  }
  function blake2sInit(outlen, key2) {
    if (!(outlen > 0 && outlen <= 32)) {
      throw new Error("Incorrect output length, should be in [1, 32]");
    }
    const keylen = key2 ? key2.length : 0;
    if (key2 && !(keylen > 0 && keylen <= 32)) {
      throw new Error("Incorrect key length, should be in [1, 32]");
    }
    const ctx = {
      h: new Uint32Array(BLAKE2S_IV),
      // hash state
      b: new Uint8Array(64),
      // input block
      c: 0,
      // pointer within block
      t: 0,
      // input count
      outlen
      // output length in bytes
    };
    ctx.h[0] ^= 16842752 ^ keylen << 8 ^ outlen;
    if (keylen > 0) {
      blake2sUpdate(ctx, key2);
      ctx.c = 64;
    }
    return ctx;
  }
  function blake2sUpdate(ctx, input) {
    for (let i = 0; i < input.length; i++) {
      if (ctx.c === 64) {
        ctx.t += ctx.c;
        blake2sCompress(ctx, false);
        ctx.c = 0;
      }
      ctx.b[ctx.c++] = input[i];
    }
  }
  function blake2sFinal(ctx) {
    ctx.t += ctx.c;
    while (ctx.c < 64) {
      ctx.b[ctx.c++] = 0;
    }
    blake2sCompress(ctx, true);
    const out = new Uint8Array(ctx.outlen);
    for (let i = 0; i < ctx.outlen; i++) {
      out[i] = ctx.h[i >> 2] >> 8 * (i & 3) & 255;
    }
    return out;
  }
  function blake2s(input, key2, outlen) {
    outlen = outlen || 32;
    input = util2.normalizeInput(input);
    const ctx = blake2sInit(outlen, key2);
    blake2sUpdate(ctx, input);
    return blake2sFinal(ctx);
  }
  function blake2sHex(input, key2, outlen) {
    const output = blake2s(input, key2, outlen);
    return util2.toHex(output);
  }
  blake2s_1 = {
    blake2s,
    blake2sHex,
    blake2sInit,
    blake2sUpdate,
    blake2sFinal
  };
  return blake2s_1;
}
var blakejs;
var hasRequiredBlakejs;
function requireBlakejs() {
  if (hasRequiredBlakejs) return blakejs;
  hasRequiredBlakejs = 1;
  const b2b = requireBlake2b();
  const b2s = requireBlake2s();
  blakejs = {
    blake2b: b2b.blake2b,
    blake2bHex: b2b.blake2bHex,
    blake2bInit: b2b.blake2bInit,
    blake2bUpdate: b2b.blake2bUpdate,
    blake2bFinal: b2b.blake2bFinal,
    blake2s: b2s.blake2s,
    blake2sHex: b2s.blake2sHex,
    blake2sInit: b2s.blake2sInit,
    blake2sUpdate: b2s.blake2sUpdate,
    blake2sFinal: b2s.blake2sFinal
  };
  return blakejs;
}
requireBlakejs();
function P() {
  return typeof process < "u" && !!process.env;
}
function B(o) {
  return process?.env?.[o];
}
P() && !B("TONBRIDGE_DEBUG");
globalLogger.createChild("BridgeManager");
globalLogger.createChild("ConnectHandler");
function ot(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var T = { exports: {} }, A, v;
function nt() {
  if (v) return A;
  v = 1;
  var t = 1e3, e = t * 60, o = e * 60, n = o * 24, a = n * 7, r = n * 365.25;
  A = function(u, s) {
    s = s || {};
    var p = typeof u;
    if (p === "string" && u.length > 0)
      return d(u);
    if (p === "number" && isFinite(u))
      return s.long ? l(u) : i(u);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(u)
    );
  };
  function d(u) {
    if (u = String(u), !(u.length > 100)) {
      var s = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        u
      );
      if (s) {
        var p = parseFloat(s[1]), _ = (s[2] || "ms").toLowerCase();
        switch (_) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return p * r;
          case "weeks":
          case "week":
          case "w":
            return p * a;
          case "days":
          case "day":
          case "d":
            return p * n;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return p * o;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return p * e;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return p * t;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return p;
          default:
            return;
        }
      }
    }
  }
  function i(u) {
    var s = Math.abs(u);
    return s >= n ? Math.round(u / n) + "d" : s >= o ? Math.round(u / o) + "h" : s >= e ? Math.round(u / e) + "m" : s >= t ? Math.round(u / t) + "s" : u + "ms";
  }
  function l(u) {
    var s = Math.abs(u);
    return s >= n ? f(u, s, n, "day") : s >= o ? f(u, s, o, "hour") : s >= e ? f(u, s, e, "minute") : s >= t ? f(u, s, t, "second") : u + " ms";
  }
  function f(u, s, p, _) {
    var U = s >= p * 1.5;
    return Math.round(u / p) + " " + _ + (U ? "s" : "");
  }
  return A;
}
function at(t) {
  o.debug = o, o.default = o, o.coerce = l, o.disable = d, o.enable = a, o.enabled = i, o.humanize = nt(), o.destroy = f, Object.keys(t).forEach((u) => {
    o[u] = t[u];
  }), o.names = [], o.skips = [], o.formatters = {};
  function e(u) {
    let s = 0;
    for (let p = 0; p < u.length; p++)
      s = (s << 5) - s + u.charCodeAt(p), s |= 0;
    return o.colors[Math.abs(s) % o.colors.length];
  }
  o.selectColor = e;
  function o(u) {
    let s, p = null, _, U;
    function y(...h) {
      if (!y.enabled)
        return;
      const c = y, B2 = Number(/* @__PURE__ */ new Date()), P2 = B2 - (s || B2);
      c.diff = P2, c.prev = s, c.curr = B2, s = B2, h[0] = o.coerce(h[0]), typeof h[0] != "string" && h.unshift("%O");
      let k = 0;
      h[0] = h[0].replace(/%([a-zA-Z%])/g, (E, tt) => {
        if (E === "%%")
          return "%";
        k++;
        const L = o.formatters[tt];
        if (typeof L == "function") {
          const et = h[k];
          E = L.call(c, et), h.splice(k, 1), k--;
        }
        return E;
      }), o.formatArgs.call(c, h), (c.log || o.log).apply(c, h);
    }
    return y.namespace = u, y.useColors = o.useColors(), y.color = o.selectColor(u), y.extend = n, y.destroy = o.destroy, Object.defineProperty(y, "enabled", {
      enumerable: true,
      configurable: false,
      get: () => p !== null ? p : (_ !== o.namespaces && (_ = o.namespaces, U = o.enabled(u)), U),
      set: (h) => {
        p = h;
      }
    }), typeof o.init == "function" && o.init(y), y;
  }
  function n(u, s) {
    const p = o(this.namespace + (typeof s > "u" ? ":" : s) + u);
    return p.log = this.log, p;
  }
  function a(u) {
    o.save(u), o.namespaces = u, o.names = [], o.skips = [];
    const s = (typeof u == "string" ? u : "").trim().replace(" ", ",").split(",").filter(Boolean);
    for (const p of s)
      p[0] === "-" ? o.skips.push(p.slice(1)) : o.names.push(p);
  }
  function r(u, s) {
    let p = 0, _ = 0, U = -1, y = 0;
    for (; p < u.length; )
      if (_ < s.length && (s[_] === u[p] || s[_] === "*"))
        s[_] === "*" ? (U = _, y = p, _++) : (p++, _++);
      else if (U !== -1)
        _ = U + 1, y++, p = y;
      else
        return false;
    for (; _ < s.length && s[_] === "*"; )
      _++;
    return _ === s.length;
  }
  function d() {
    const u = [
      ...o.names,
      ...o.skips.map((s) => "-" + s)
    ].join(",");
    return o.enable(""), u;
  }
  function i(u) {
    for (const s of o.skips)
      if (r(u, s))
        return false;
    for (const s of o.names)
      if (r(u, s))
        return true;
    return false;
  }
  function l(u) {
    return u instanceof Error ? u.stack || u.message : u;
  }
  function f() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return o.enable(o.load()), o;
}
var rt = at;
(function(t, e) {
  e.formatArgs = n, e.save = a, e.load = r, e.useColors = o, e.storage = d(), e.destroy = /* @__PURE__ */ (() => {
    let l = false;
    return () => {
      l || (l = true, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), e.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function o() {
    if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
      return true;
    if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
      return false;
    let l;
    return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && (l = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(l[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function n(l) {
    if (l[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + l[0] + (this.useColors ? "%c " : " ") + "+" + t.exports.humanize(this.diff), !this.useColors)
      return;
    const f = "color: " + this.color;
    l.splice(1, 0, f, "color: inherit");
    let u = 0, s = 0;
    l[0].replace(/%[a-zA-Z%]/g, (p) => {
      p !== "%%" && (u++, p === "%c" && (s = u));
    }), l.splice(s, 0, f);
  }
  e.log = console.debug || console.log || (() => {
  });
  function a(l) {
    try {
      l ? e.storage.setItem("debug", l) : e.storage.removeItem("debug");
    } catch {
    }
  }
  function r() {
    let l;
    try {
      l = e.storage.getItem("debug");
    } catch {
    }
    return !l && typeof process < "u" && "env" in process && (l = process.env.DEBUG), l;
  }
  function d() {
    try {
      return localStorage;
    } catch {
    }
  }
  t.exports = rt(e);
  const { formatters: i } = t.exports;
  i.j = function(l) {
    try {
      return JSON.stringify(l);
    } catch (f) {
      return "[UnexpectedJSONParseError]: " + f.message;
    }
  };
})(T, T.exports);
var dt = T.exports;
const $ = /* @__PURE__ */ ot(dt);
$("tlb-abi:internal");
$("tlb-abi:jetton");
globalLogger.createChild("TransactionHandler");
var dist$4 = {};
var parser = {};
var dist$3 = {};
var Address = {};
var crc16 = {};
var hasRequiredCrc16;
function requireCrc16() {
  if (hasRequiredCrc16) return crc16;
  hasRequiredCrc16 = 1;
  Object.defineProperty(crc16, "__esModule", { value: true });
  crc16.crc16 = void 0;
  function crc16$12(data) {
    const poly = 4129;
    let reg = 0;
    const message = Buffer.alloc(data.length + 2);
    message.set(data);
    for (let byte of message) {
      let mask = 128;
      while (mask > 0) {
        reg <<= 1;
        if (byte & mask) {
          reg += 1;
        }
        mask >>= 1;
        if (reg > 65535) {
          reg &= 65535;
          reg ^= poly;
        }
      }
    }
    return Buffer.from([Math.floor(reg / 256), reg % 256]);
  }
  crc16.crc16 = crc16$12;
  return crc16;
}
var hasRequiredAddress;
function requireAddress() {
  if (hasRequiredAddress) return Address;
  hasRequiredAddress = 1;
  var __importDefault = Address && Address.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  var _a;
  Object.defineProperty(Address, "__esModule", { value: true });
  Address.address = Address.Address = void 0;
  const symbol_inspect_1 = __importDefault(requireSymbol_inspect());
  const crc16_1 = requireCrc16();
  const bounceable_tag = 17;
  const non_bounceable_tag = 81;
  const test_flag = 128;
  function parseFriendlyAddress(src2) {
    if (typeof src2 === "string" && !Address$12.isFriendly(src2)) {
      throw new Error("Unknown address type");
    }
    const data = Buffer.isBuffer(src2) ? src2 : Buffer.from(src2, "base64");
    if (data.length !== 36) {
      throw new Error("Unknown address type: byte length is not equal to 36");
    }
    const addr = data.subarray(0, 34);
    const crc = data.subarray(34, 36);
    const calcedCrc = (0, crc16_1.crc16)(addr);
    if (!(calcedCrc[0] === crc[0] && calcedCrc[1] === crc[1])) {
      throw new Error("Invalid checksum: " + src2);
    }
    let tag = addr[0];
    let isTestOnly = false;
    let isBounceable = false;
    if (tag & test_flag) {
      isTestOnly = true;
      tag = tag ^ test_flag;
    }
    if (tag !== bounceable_tag && tag !== non_bounceable_tag)
      throw "Unknown address tag";
    isBounceable = tag === bounceable_tag;
    let workchain = null;
    if (addr[1] === 255) {
      workchain = -1;
    } else {
      workchain = addr[1];
    }
    const hashPart = addr.subarray(2, 34);
    return { isTestOnly, isBounceable, workchain, hashPart };
  }
  let Address$12 = class Address2 {
    static isAddress(src2) {
      return src2 instanceof Address2;
    }
    static isFriendly(source) {
      if (source.length !== 48) {
        return false;
      }
      if (!/^[A-Za-z0-9+/_-]+$/.test(source)) {
        return false;
      }
      return true;
    }
    static isRaw(source) {
      if (source.indexOf(":") === -1) {
        return false;
      }
      let [wc, hash] = source.split(":");
      if (!Number.isInteger(parseFloat(wc))) {
        return false;
      }
      if (!/[a-f0-9]+/.test(hash.toLowerCase())) {
        return false;
      }
      if (hash.length !== 64) {
        return false;
      }
      return true;
    }
    static normalize(source) {
      if (typeof source === "string") {
        return Address2.parse(source).toString();
      } else {
        return source.toString();
      }
    }
    static parse(source) {
      if (Address2.isFriendly(source)) {
        return this.parseFriendly(source).address;
      } else if (Address2.isRaw(source)) {
        return this.parseRaw(source);
      } else {
        throw new Error("Unknown address type: " + source);
      }
    }
    static parseRaw(source) {
      let workChain = parseInt(source.split(":")[0]);
      let hash = Buffer.from(source.split(":")[1], "hex");
      return new Address2(workChain, hash);
    }
    static parseFriendly(source) {
      if (Buffer.isBuffer(source)) {
        let r = parseFriendlyAddress(source);
        return {
          isBounceable: r.isBounceable,
          isTestOnly: r.isTestOnly,
          address: new Address2(r.workchain, r.hashPart)
        };
      } else {
        let addr = source.replace(/\-/g, "+").replace(/_/g, "/");
        let r = parseFriendlyAddress(addr);
        return {
          isBounceable: r.isBounceable,
          isTestOnly: r.isTestOnly,
          address: new Address2(r.workchain, r.hashPart)
        };
      }
    }
    constructor(workChain, hash) {
      this.toRawString = () => {
        return this.workChain + ":" + this.hash.toString("hex");
      };
      this.toRaw = () => {
        const addressWithChecksum = Buffer.alloc(36);
        addressWithChecksum.set(this.hash);
        addressWithChecksum.set([this.workChain, this.workChain, this.workChain, this.workChain], 32);
        return addressWithChecksum;
      };
      this.toStringBuffer = (args) => {
        let testOnly = args && args.testOnly !== void 0 ? args.testOnly : false;
        let bounceable = args && args.bounceable !== void 0 ? args.bounceable : true;
        let tag = bounceable ? bounceable_tag : non_bounceable_tag;
        if (testOnly) {
          tag |= test_flag;
        }
        const addr = Buffer.alloc(34);
        addr[0] = tag;
        addr[1] = this.workChain;
        addr.set(this.hash, 2);
        const addressWithChecksum = Buffer.alloc(36);
        addressWithChecksum.set(addr);
        addressWithChecksum.set((0, crc16_1.crc16)(addr), 34);
        return addressWithChecksum;
      };
      this.toString = (args) => {
        let urlSafe = args && args.urlSafe !== void 0 ? args.urlSafe : true;
        let buffer = this.toStringBuffer(args);
        if (urlSafe) {
          return buffer.toString("base64").replace(/\+/g, "-").replace(/\//g, "_");
        } else {
          return buffer.toString("base64");
        }
      };
      this[_a] = () => this.toString();
      if (hash.length !== 32) {
        throw new Error("Invalid address hash length: " + hash.length);
      }
      this.workChain = workChain;
      this.hash = hash;
      Object.freeze(this);
    }
    equals(src2) {
      if (src2.workChain !== this.workChain) {
        return false;
      }
      return src2.hash.equals(this.hash);
    }
  };
  Address.Address = Address$12;
  _a = symbol_inspect_1.default;
  function address(src2) {
    return Address$12.parse(src2);
  }
  Address.address = address;
  return Address;
}
var ExternalAddress = {};
var hasRequiredExternalAddress;
function requireExternalAddress() {
  if (hasRequiredExternalAddress) return ExternalAddress;
  hasRequiredExternalAddress = 1;
  var __importDefault = ExternalAddress && ExternalAddress.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  var _a;
  Object.defineProperty(ExternalAddress, "__esModule", { value: true });
  ExternalAddress.ExternalAddress = void 0;
  const symbol_inspect_1 = __importDefault(requireSymbol_inspect());
  let ExternalAddress$12 = class ExternalAddress2 {
    static isAddress(src2) {
      return src2 instanceof ExternalAddress2;
    }
    constructor(value, bits) {
      this[_a] = () => this.toString();
      this.value = value;
      this.bits = bits;
    }
    toString() {
      return `External<${this.bits}:${this.value}>`;
    }
  };
  ExternalAddress.ExternalAddress = ExternalAddress$12;
  _a = symbol_inspect_1.default;
  return ExternalAddress;
}
var ADNLAddress = {};
var base32 = {};
var hasRequiredBase32;
function requireBase32() {
  if (hasRequiredBase32) return base32;
  hasRequiredBase32 = 1;
  Object.defineProperty(base32, "__esModule", { value: true });
  base32.base32Decode = base32.base32Encode = void 0;
  const alphabet = "abcdefghijklmnopqrstuvwxyz234567";
  function base32Encode(buffer) {
    const length = buffer.byteLength;
    let bits = 0;
    let value = 0;
    let output = "";
    for (let i = 0; i < length; i++) {
      value = value << 8 | buffer[i];
      bits += 8;
      while (bits >= 5) {
        output += alphabet[value >>> bits - 5 & 31];
        bits -= 5;
      }
    }
    if (bits > 0) {
      output += alphabet[value << 5 - bits & 31];
    }
    return output;
  }
  base32.base32Encode = base32Encode;
  function readChar(alphabet2, char) {
    const idx = alphabet2.indexOf(char);
    if (idx === -1) {
      throw new Error("Invalid character found: " + char);
    }
    return idx;
  }
  function base32Decode(input) {
    let cleanedInput;
    cleanedInput = input.toLowerCase();
    const { length } = cleanedInput;
    let bits = 0;
    let value = 0;
    let index = 0;
    const output = Buffer.alloc(length * 5 / 8 | 0);
    for (let i = 0; i < length; i++) {
      value = value << 5 | readChar(alphabet, cleanedInput[i]);
      bits += 5;
      if (bits >= 8) {
        output[index++] = value >>> bits - 8 & 255;
        bits -= 8;
      }
    }
    return output;
  }
  base32.base32Decode = base32Decode;
  return base32;
}
var hasRequiredADNLAddress;
function requireADNLAddress() {
  if (hasRequiredADNLAddress) return ADNLAddress;
  hasRequiredADNLAddress = 1;
  var __importDefault = ADNLAddress && ADNLAddress.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  var _a;
  Object.defineProperty(ADNLAddress, "__esModule", { value: true });
  ADNLAddress.ADNLAddress = void 0;
  const symbol_inspect_1 = __importDefault(requireSymbol_inspect());
  const base32_1 = requireBase32();
  const crc16_1 = requireCrc16();
  let ADNLAddress$12 = class ADNLAddress2 {
    static parseFriendly(src2) {
      if (src2.length !== 55) {
        throw Error("Invalid address");
      }
      src2 = "f" + src2;
      let decoded = (0, base32_1.base32Decode)(src2);
      if (decoded[0] !== 45) {
        throw Error("Invalid address");
      }
      let gotHash = decoded.slice(33);
      let hash = (0, crc16_1.crc16)(decoded.slice(0, 33));
      if (!hash.equals(gotHash)) {
        throw Error("Invalid address");
      }
      return new ADNLAddress2(decoded.slice(1, 33));
    }
    static parseRaw(src2) {
      const data = Buffer.from(src2, "base64");
      return new ADNLAddress2(data);
    }
    constructor(address) {
      this.toRaw = () => {
        return this.address.toString("hex").toUpperCase();
      };
      this.toString = () => {
        let data = Buffer.concat([Buffer.from([45]), this.address]);
        let hash = (0, crc16_1.crc16)(data);
        data = Buffer.concat([data, hash]);
        return (0, base32_1.base32Encode)(data).slice(1);
      };
      this[_a] = () => this.toString();
      if (address.length !== 32) {
        throw Error("Invalid address");
      }
      this.address = address;
    }
    equals(b) {
      return this.address.equals(b.address);
    }
  };
  ADNLAddress.ADNLAddress = ADNLAddress$12;
  _a = symbol_inspect_1.default;
  return ADNLAddress;
}
var contractAddress = {};
var Builder$3 = {};
var BitBuilder = {};
var BitString = {};
var paddedBits = {};
var hasRequiredPaddedBits;
function requirePaddedBits() {
  if (hasRequiredPaddedBits) return paddedBits;
  hasRequiredPaddedBits = 1;
  Object.defineProperty(paddedBits, "__esModule", { value: true });
  paddedBits.paddedBufferToBits = paddedBits.bitsToPaddedBuffer = void 0;
  const BitBuilder_1 = requireBitBuilder();
  const BitString_1 = requireBitString();
  function bitsToPaddedBuffer(bits) {
    let builder2 = new BitBuilder_1.BitBuilder(Math.ceil(bits.length / 8) * 8);
    builder2.writeBits(bits);
    let padding = Math.ceil(bits.length / 8) * 8 - bits.length;
    for (let i = 0; i < padding; i++) {
      if (i === 0) {
        builder2.writeBit(1);
      } else {
        builder2.writeBit(0);
      }
    }
    return builder2.buffer();
  }
  paddedBits.bitsToPaddedBuffer = bitsToPaddedBuffer;
  function paddedBufferToBits(buff) {
    let bitLen = 0;
    for (let i = buff.length - 1; i >= 0; i--) {
      if (buff[i] !== 0) {
        const testByte = buff[i];
        let bitPos = testByte & -testByte;
        if ((bitPos & 1) == 0) {
          bitPos = Math.log2(bitPos) + 1;
        }
        if (i > 0) {
          bitLen = i << 3;
        }
        bitLen += 8 - bitPos;
        break;
      }
    }
    return new BitString_1.BitString(buff, 0, bitLen);
  }
  paddedBits.paddedBufferToBits = paddedBufferToBits;
  return paddedBits;
}
var hasRequiredBitString;
function requireBitString() {
  if (hasRequiredBitString) return BitString;
  hasRequiredBitString = 1;
  var __importDefault = BitString && BitString.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  var _a;
  Object.defineProperty(BitString, "__esModule", { value: true });
  BitString.BitString = void 0;
  const paddedBits_1 = requirePaddedBits();
  const symbol_inspect_1 = __importDefault(requireSymbol_inspect());
  let BitString$12 = class BitString2 {
    /**
     * Checks if supplied object is BitString
     * @param src is unknow object
     * @returns true if object is BitString and false otherwise
     **/
    static isBitString(src2) {
      return src2 instanceof BitString2;
    }
    /**
     * Constructing BitString from a buffer
     * @param data data that contains the bitstring data. NOTE: We are expecting this buffer to be NOT modified
     * @param offset offset in bits from the start of the buffer
     * @param length length of the bitstring in bits
     */
    constructor(data, offset, length) {
      this[_a] = () => this.toString();
      if (length < 0) {
        throw new Error(`Length ${length} is out of bounds`);
      }
      this._length = length;
      this._data = data;
      this._offset = offset;
    }
    /**
     * Returns the length of the bitstring
     */
    get length() {
      return this._length;
    }
    /**
     * Returns the bit at the specified index
     * @param index index of the bit
     * @throws Error if index is out of bounds
     * @returns true if the bit is set, false otherwise
     */
    at(index) {
      if (index >= this._length) {
        throw new Error(`Index ${index} > ${this._length} is out of bounds`);
      }
      if (index < 0) {
        throw new Error(`Index ${index} < 0 is out of bounds`);
      }
      let byteIndex = this._offset + index >> 3;
      let bitIndex = 7 - (this._offset + index) % 8;
      return (this._data[byteIndex] & 1 << bitIndex) !== 0;
    }
    /**
     * Get a subscring of the bitstring
     * @param offset
     * @param length
     * @returns
     */
    substring(offset, length) {
      if (offset > this._length) {
        throw new Error(`Offset(${offset}) > ${this._length} is out of bounds`);
      }
      if (offset < 0) {
        throw new Error(`Offset(${offset}) < 0 is out of bounds`);
      }
      if (length === 0) {
        return BitString2.EMPTY;
      }
      if (offset + length > this._length) {
        throw new Error(`Offset ${offset} + Length ${length} > ${this._length} is out of bounds`);
      }
      return new BitString2(this._data, this._offset + offset, length);
    }
    /**
     * Try to get a buffer from the bitstring without allocations
     * @param offset offset in bits
     * @param length length in bits
     * @returns buffer if the bitstring is aligned to bytes, null otherwise
     */
    subbuffer(offset, length) {
      if (offset > this._length) {
        throw new Error(`Offset ${offset} is out of bounds`);
      }
      if (offset < 0) {
        throw new Error(`Offset ${offset} is out of bounds`);
      }
      if (offset + length > this._length) {
        throw new Error(`Offset + Lenght = ${offset + length} is out of bounds`);
      }
      if (length % 8 !== 0) {
        return null;
      }
      if ((this._offset + offset) % 8 !== 0) {
        return null;
      }
      let start = this._offset + offset >> 3;
      let end2 = start + (length >> 3);
      return this._data.subarray(start, end2);
    }
    /**
     * Checks for equality
     * @param b other bitstring
     * @returns true if the bitstrings are equal, false otherwise
     */
    equals(b) {
      if (this._length !== b._length) {
        return false;
      }
      for (let i = 0; i < this._length; i++) {
        if (this.at(i) !== b.at(i)) {
          return false;
        }
      }
      return true;
    }
    /**
     * Format to canonical string
     * @returns formatted bits as a string
     */
    toString() {
      const padded = (0, paddedBits_1.bitsToPaddedBuffer)(this);
      if (this._length % 4 === 0) {
        const s = padded.subarray(0, Math.ceil(this._length / 8)).toString("hex").toUpperCase();
        if (this._length % 8 === 0) {
          return s;
        } else {
          return s.substring(0, s.length - 1);
        }
      } else {
        const hex = padded.toString("hex").toUpperCase();
        if (this._length % 8 <= 4) {
          return hex.substring(0, hex.length - 1) + "_";
        } else {
          return hex + "_";
        }
      }
    }
  };
  BitString.BitString = BitString$12;
  _a = symbol_inspect_1.default;
  BitString$12.EMPTY = new BitString$12(Buffer.alloc(0), 0, 0);
  return BitString;
}
var hasRequiredBitBuilder;
function requireBitBuilder() {
  if (hasRequiredBitBuilder) return BitBuilder;
  hasRequiredBitBuilder = 1;
  Object.defineProperty(BitBuilder, "__esModule", { value: true });
  BitBuilder.BitBuilder = void 0;
  const Address_1 = requireAddress();
  const ExternalAddress_1 = requireExternalAddress();
  const BitString_1 = requireBitString();
  let BitBuilder$12 = class BitBuilder {
    constructor(size = 1023) {
      this._buffer = Buffer.alloc(Math.ceil(size / 8));
      this._length = 0;
    }
    /**
     * Current number of bits written
     */
    get length() {
      return this._length;
    }
    /**
     * Write a single bit
     * @param value bit to write, true or positive number for 1, false or zero or negative for 0
     */
    writeBit(value) {
      let n = this._length;
      if (n > this._buffer.length * 8) {
        throw new Error("BitBuilder overflow");
      }
      if (typeof value === "boolean" && value === true || typeof value === "number" && value > 0) {
        this._buffer[n / 8 | 0] |= 1 << 7 - n % 8;
      }
      this._length++;
    }
    /**
     * Copy bits from BitString
     * @param src source bits
     */
    writeBits(src2) {
      for (let i = 0; i < src2.length; i++) {
        this.writeBit(src2.at(i));
      }
    }
    /**
     * Write bits from buffer
     * @param src source buffer
     */
    writeBuffer(src2) {
      if (this._length % 8 === 0) {
        if (this._length + src2.length * 8 > this._buffer.length * 8) {
          throw new Error("BitBuilder overflow");
        }
        src2.copy(this._buffer, this._length / 8);
        this._length += src2.length * 8;
      } else {
        for (let i = 0; i < src2.length; i++) {
          this.writeUint(src2[i], 8);
        }
      }
    }
    /**
     * Write uint value
     * @param value value as bigint or number
     * @param bits number of bits to write
     */
    writeUint(value, bits) {
      if (bits < 0 || !Number.isSafeInteger(bits)) {
        throw Error(`invalid bit length. Got ${bits}`);
      }
      const v2 = BigInt(value);
      if (bits === 0) {
        if (v2 !== 0n) {
          throw Error(`value is not zero for ${bits} bits. Got ${value}`);
        } else {
          return;
        }
      }
      const vBits = 1n << BigInt(bits);
      if (v2 < 0 || v2 >= vBits) {
        throw Error(`bitLength is too small for a value ${value}. Got ${bits}`);
      }
      if (this._length + bits > this._buffer.length * 8) {
        throw new Error("BitBuilder overflow");
      }
      const tillByte = 8 - this._length % 8;
      if (tillByte > 0) {
        const bidx = Math.floor(this._length / 8);
        if (bits < tillByte) {
          const wb = Number(v2);
          this._buffer[bidx] |= wb << tillByte - bits;
          this._length += bits;
        } else {
          const wb = Number(v2 >> BigInt(bits - tillByte));
          this._buffer[bidx] |= wb;
          this._length += tillByte;
        }
      }
      bits -= tillByte;
      while (bits > 0) {
        if (bits >= 8) {
          this._buffer[this._length / 8] = Number(v2 >> BigInt(bits - 8) & 0xffn);
          this._length += 8;
          bits -= 8;
        } else {
          this._buffer[this._length / 8] = Number(v2 << BigInt(8 - bits) & 0xffn);
          this._length += bits;
          bits = 0;
        }
      }
    }
    /**
     * Write int value
     * @param value value as bigint or number
     * @param bits number of bits to write
     */
    writeInt(value, bits) {
      let v2 = BigInt(value);
      if (bits < 0 || !Number.isSafeInteger(bits)) {
        throw Error(`invalid bit length. Got ${bits}`);
      }
      if (bits === 0) {
        if (v2 !== 0n) {
          throw Error(`value is not zero for ${bits} bits. Got ${value}`);
        } else {
          return;
        }
      }
      if (bits === 1) {
        if (v2 !== -1n && v2 !== 0n) {
          throw Error(`value is not zero or -1 for ${bits} bits. Got ${value}`);
        } else {
          this.writeBit(value === -1n);
          return;
        }
      }
      let vBits = 1n << BigInt(bits) - 1n;
      if (v2 < -vBits || v2 >= vBits) {
        throw Error(`value is out of range for ${bits} bits. Got ${value}`);
      }
      if (v2 < 0) {
        this.writeBit(true);
        v2 = vBits + v2;
      } else {
        this.writeBit(false);
      }
      this.writeUint(v2, bits - 1);
    }
    /**
     * Wrtie var uint value, used for serializing coins
     * @param value value to write as bigint or number
     * @param bits header bits to write size
     */
    writeVarUint(value, bits) {
      let v2 = BigInt(value);
      if (bits < 0 || !Number.isSafeInteger(bits)) {
        throw Error(`invalid bit length. Got ${bits}`);
      }
      if (v2 < 0) {
        throw Error(`value is negative. Got ${value}`);
      }
      if (v2 === 0n) {
        this.writeUint(0, bits);
        return;
      }
      const sizeBytes = Math.ceil(v2.toString(2).length / 8);
      const sizeBits = sizeBytes * 8;
      this.writeUint(sizeBytes, bits);
      this.writeUint(v2, sizeBits);
    }
    /**
     * Wrtie var int value, used for serializing coins
     * @param value value to write as bigint or number
     * @param bits header bits to write size
     */
    writeVarInt(value, bits) {
      let v2 = BigInt(value);
      if (bits < 0 || !Number.isSafeInteger(bits)) {
        throw Error(`invalid bit length. Got ${bits}`);
      }
      if (v2 === 0n) {
        this.writeUint(0, bits);
        return;
      }
      let v22 = v2 > 0 ? v2 : -v2;
      const sizeBytes = Math.ceil((v22.toString(2).length + 1) / 8);
      const sizeBits = sizeBytes * 8;
      this.writeUint(sizeBytes, bits);
      this.writeInt(v2, sizeBits);
    }
    /**
     * Write coins in var uint format
     * @param amount amount to write
     */
    writeCoins(amount) {
      this.writeVarUint(amount, 4);
    }
    /**
     * Write address
     * @param address write address or address external
     */
    writeAddress(address) {
      if (address === null || address === void 0) {
        this.writeUint(0, 2);
        return;
      }
      if (Address_1.Address.isAddress(address)) {
        this.writeUint(2, 2);
        this.writeUint(0, 1);
        this.writeInt(address.workChain, 8);
        this.writeBuffer(address.hash);
        return;
      }
      if (ExternalAddress_1.ExternalAddress.isAddress(address)) {
        this.writeUint(1, 2);
        this.writeUint(address.bits, 9);
        this.writeUint(address.value, address.bits);
        return;
      }
      throw Error(`Invalid address. Got ${address}`);
    }
    /**
     * Build BitString
     * @returns result bit string
     */
    build() {
      return new BitString_1.BitString(this._buffer, 0, this._length);
    }
    /**
     * Build into Buffer
     * @returns result buffer
     */
    buffer() {
      if (this._length % 8 !== 0) {
        throw new Error("BitBuilder buffer is not byte aligned");
      }
      return this._buffer.subarray(0, this._length / 8);
    }
  };
  BitBuilder.BitBuilder = BitBuilder$12;
  return BitBuilder;
}
var Cell = {};
var CellType = {};
var hasRequiredCellType;
function requireCellType() {
  if (hasRequiredCellType) return CellType;
  hasRequiredCellType = 1;
  Object.defineProperty(CellType, "__esModule", { value: true });
  CellType.CellType = void 0;
  var CellType$12;
  (function(CellType2) {
    CellType2[CellType2["Ordinary"] = -1] = "Ordinary";
    CellType2[CellType2["PrunedBranch"] = 1] = "PrunedBranch";
    CellType2[CellType2["Library"] = 2] = "Library";
    CellType2[CellType2["MerkleProof"] = 3] = "MerkleProof";
    CellType2[CellType2["MerkleUpdate"] = 4] = "MerkleUpdate";
  })(CellType$12 || (CellType.CellType = CellType$12 = {}));
  return CellType;
}
var Slice = {};
var Dictionary = {};
var generateMerkleProof = {};
var readUnaryLength = {};
var hasRequiredReadUnaryLength;
function requireReadUnaryLength() {
  if (hasRequiredReadUnaryLength) return readUnaryLength;
  hasRequiredReadUnaryLength = 1;
  Object.defineProperty(readUnaryLength, "__esModule", { value: true });
  readUnaryLength.readUnaryLength = void 0;
  function readUnaryLength$12(slice) {
    let res = 0;
    while (slice.loadBit()) {
      res++;
    }
    return res;
  }
  readUnaryLength.readUnaryLength = readUnaryLength$12;
  return readUnaryLength;
}
var exoticMerkleProof = {};
var BitReader = {};
var hasRequiredBitReader;
function requireBitReader() {
  if (hasRequiredBitReader) return BitReader;
  hasRequiredBitReader = 1;
  Object.defineProperty(BitReader, "__esModule", { value: true });
  BitReader.BitReader = void 0;
  const Address_1 = requireAddress();
  const ExternalAddress_1 = requireExternalAddress();
  let BitReader$12 = class BitReader2 {
    constructor(bits, offset = 0) {
      this._checkpoints = [];
      this._bits = bits;
      this._offset = offset;
    }
    /**
     * Offset in source bit string
     */
    get offset() {
      return this._offset;
    }
    /**
     * Number of bits remaining
     */
    get remaining() {
      return this._bits.length - this._offset;
    }
    /**
     * Skip bits
     * @param bits number of bits to skip
     */
    skip(bits) {
      if (bits < 0 || this._offset + bits > this._bits.length) {
        throw new Error(`Index ${this._offset + bits} is out of bounds`);
      }
      this._offset += bits;
    }
    /**
     * Reset to the beginning or latest checkpoint
     */
    reset() {
      if (this._checkpoints.length > 0) {
        this._offset = this._checkpoints.pop();
      } else {
        this._offset = 0;
      }
    }
    /**
     * Save checkpoint
     */
    save() {
      this._checkpoints.push(this._offset);
    }
    /**
     * Load a single bit
     * @returns true if the bit is set, false otherwise
     */
    loadBit() {
      let r = this._bits.at(this._offset);
      this._offset++;
      return r;
    }
    /**
     * Preload bit
     * @returns true if the bit is set, false otherwise
     */
    preloadBit() {
      return this._bits.at(this._offset);
    }
    /**
     * Load bit string
     * @param bits number of bits to read
     * @returns new bitstring
     */
    loadBits(bits) {
      let r = this._bits.substring(this._offset, bits);
      this._offset += bits;
      return r;
    }
    /**
     * Preload bit string
     * @param bits number of bits to read
     * @returns new bitstring
     */
    preloadBits(bits) {
      return this._bits.substring(this._offset, bits);
    }
    /**
     * Load buffer
     * @param bytes number of bytes
     * @returns new buffer
     */
    loadBuffer(bytes) {
      let buf = this._preloadBuffer(bytes, this._offset);
      this._offset += bytes * 8;
      return buf;
    }
    /**
     * Preload buffer
     * @param bytes number of bytes
     * @returns new buffer
     */
    preloadBuffer(bytes) {
      return this._preloadBuffer(bytes, this._offset);
    }
    /**
     * Load uint value
     * @param bits uint bits
     * @returns read value as number
     */
    loadUint(bits) {
      return this._toSafeInteger(this.loadUintBig(bits), "loadUintBig");
    }
    /**
     * Load uint value as bigint
     * @param bits uint bits
     * @returns read value as bigint
     */
    loadUintBig(bits) {
      let loaded = this.preloadUintBig(bits);
      this._offset += bits;
      return loaded;
    }
    /**
     * Preload uint value
     * @param bits uint bits
     * @returns read value as number
     */
    preloadUint(bits) {
      return this._toSafeInteger(this._preloadUint(bits, this._offset), "preloadUintBig");
    }
    /**
     * Preload uint value as bigint
     * @param bits uint bits
     * @returns read value as bigint
     */
    preloadUintBig(bits) {
      return this._preloadUint(bits, this._offset);
    }
    /**
     * Load int value
     * @param bits int bits
     * @returns read value as bigint
     */
    loadInt(bits) {
      let res = this._preloadInt(bits, this._offset);
      this._offset += bits;
      return this._toSafeInteger(res, "loadUintBig");
    }
    /**
     * Load int value as bigint
     * @param bits int bits
     * @returns read value as bigint
     */
    loadIntBig(bits) {
      let res = this._preloadInt(bits, this._offset);
      this._offset += bits;
      return res;
    }
    /**
     * Preload int value
     * @param bits int bits
     * @returns read value as bigint
     */
    preloadInt(bits) {
      return this._toSafeInteger(this._preloadInt(bits, this._offset), "preloadIntBig");
    }
    /**
     * Preload int value
     * @param bits int bits
     * @returns read value as bigint
     */
    preloadIntBig(bits) {
      return this._preloadInt(bits, this._offset);
    }
    /**
     * Load varuint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    loadVarUint(bits) {
      let size = Number(this.loadUint(bits));
      return this._toSafeInteger(this.loadUintBig(size * 8), "loadVarUintBig");
    }
    /**
     * Load varuint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    loadVarUintBig(bits) {
      let size = Number(this.loadUint(bits));
      return this.loadUintBig(size * 8);
    }
    /**
     * Preload varuint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    preloadVarUint(bits) {
      let size = Number(this._preloadUint(bits, this._offset));
      return this._toSafeInteger(this._preloadUint(size * 8, this._offset + bits), "preloadVarUintBig");
    }
    /**
     * Preload varuint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    preloadVarUintBig(bits) {
      let size = Number(this._preloadUint(bits, this._offset));
      return this._preloadUint(size * 8, this._offset + bits);
    }
    /**
     * Load varint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    loadVarInt(bits) {
      let size = Number(this.loadUint(bits));
      return this._toSafeInteger(this.loadIntBig(size * 8), "loadVarIntBig");
    }
    /**
     * Load varint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    loadVarIntBig(bits) {
      let size = Number(this.loadUint(bits));
      return this.loadIntBig(size * 8);
    }
    /**
     * Preload varint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    preloadVarInt(bits) {
      let size = Number(this._preloadUint(bits, this._offset));
      return this._toSafeInteger(this._preloadInt(size * 8, this._offset + bits), "preloadVarIntBig");
    }
    /**
     * Preload varint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */
    preloadVarIntBig(bits) {
      let size = Number(this._preloadUint(bits, this._offset));
      return this._preloadInt(size * 8, this._offset + bits);
    }
    /**
     * Load coins value
     * @returns read value as bigint
     */
    loadCoins() {
      return this.loadVarUintBig(4);
    }
    /**
     * Preload coins value
     * @returns read value as bigint
     */
    preloadCoins() {
      return this.preloadVarUintBig(4);
    }
    /**
     * Load Address
     * @returns Address
     */
    loadAddress() {
      let type = Number(this._preloadUint(2, this._offset));
      if (type === 2) {
        return this._loadInternalAddress();
      } else {
        throw new Error("Invalid address: " + type);
      }
    }
    /**
     * Load internal address
     * @returns Address or null
     */
    loadMaybeAddress() {
      let type = Number(this._preloadUint(2, this._offset));
      if (type === 0) {
        this._offset += 2;
        return null;
      } else if (type === 2) {
        return this._loadInternalAddress();
      } else {
        throw new Error("Invalid address");
      }
    }
    /**
     * Load external address
     * @returns ExternalAddress
     */
    loadExternalAddress() {
      let type = Number(this._preloadUint(2, this._offset));
      if (type === 1) {
        return this._loadExternalAddress();
      } else {
        throw new Error("Invalid address");
      }
    }
    /**
     * Load external address
     * @returns ExternalAddress or null
     */
    loadMaybeExternalAddress() {
      let type = Number(this._preloadUint(2, this._offset));
      if (type === 0) {
        this._offset += 2;
        return null;
      } else if (type === 1) {
        return this._loadExternalAddress();
      } else {
        throw new Error("Invalid address");
      }
    }
    /**
     * Read address of any type
     * @returns Address or ExternalAddress or null
     */
    loadAddressAny() {
      let type = Number(this._preloadUint(2, this._offset));
      if (type === 0) {
        this._offset += 2;
        return null;
      } else if (type === 2) {
        return this._loadInternalAddress();
      } else if (type === 1) {
        return this._loadExternalAddress();
      } else if (type === 3) {
        throw Error("Unsupported");
      } else {
        throw Error("Unreachable");
      }
    }
    /**
     * Load bit string that was padded to make it byte alligned. Used in BOC serialization
     * @param bytes number of bytes to read
     */
    loadPaddedBits(bits) {
      if (bits % 8 !== 0) {
        throw new Error("Invalid number of bits");
      }
      let length = bits;
      while (true) {
        if (this._bits.at(this._offset + length - 1)) {
          length--;
          break;
        } else {
          length--;
        }
      }
      let r = this._bits.substring(this._offset, length);
      this._offset += bits;
      return r;
    }
    /**
     * Clone BitReader
     */
    clone() {
      return new BitReader2(this._bits, this._offset);
    }
    /**
     * Preload int from specific offset
     * @param bits bits to preload
     * @param offset offset to start from
     * @returns read value as bigint
     */
    _preloadInt(bits, offset) {
      if (bits == 0) {
        return 0n;
      }
      let sign = this._bits.at(offset);
      let res = 0n;
      for (let i = 0; i < bits - 1; i++) {
        if (this._bits.at(offset + 1 + i)) {
          res += 1n << BigInt(bits - i - 1 - 1);
        }
      }
      if (sign) {
        res = res - (1n << BigInt(bits - 1));
      }
      return res;
    }
    /**
     * Preload uint from specific offset
     * @param bits bits to preload
     * @param offset offset to start from
     * @returns read value as bigint
     */
    _preloadUint(bits, offset) {
      if (bits == 0) {
        return 0n;
      }
      let res = 0n;
      for (let i = 0; i < bits; i++) {
        if (this._bits.at(offset + i)) {
          res += 1n << BigInt(bits - i - 1);
        }
      }
      return res;
    }
    _preloadBuffer(bytes, offset) {
      let fastBuffer = this._bits.subbuffer(offset, bytes * 8);
      if (fastBuffer) {
        return fastBuffer;
      }
      let buf = Buffer.alloc(bytes);
      for (let i = 0; i < bytes; i++) {
        buf[i] = Number(this._preloadUint(8, offset + i * 8));
      }
      return buf;
    }
    _loadInternalAddress() {
      let type = Number(this._preloadUint(2, this._offset));
      if (type !== 2) {
        throw Error("Invalid address");
      }
      let rewrite_pfx = void 0;
      let rewrite_depth = void 0;
      if (this._preloadUint(1, this._offset + 2) !== 0n) {
        rewrite_depth = Number(this._preloadUint(5, this._offset + 3));
        rewrite_pfx = this._preloadUint(rewrite_depth, this._offset + 8);
        this._offset += 5 + rewrite_depth;
      }
      let wc = Number(this._preloadInt(8, this._offset + 3));
      let hash = this._preloadBuffer(32, this._offset + 11);
      if (rewrite_depth !== void 0 && rewrite_pfx !== void 0) {
        let pfx = Number(rewrite_pfx);
        let byteIndex = 0;
        let bitIndex = 0;
        let bitsRemaining = rewrite_depth;
        while (bitsRemaining > 0) {
          let bitsInThisByte = Math.min(8 - bitIndex, bitsRemaining);
          let mask = (1 << bitsInThisByte) - 1 << 8 - bitIndex - bitsInThisByte;
          let bits = (pfx >> bitsRemaining - bitsInThisByte & (1 << bitsInThisByte) - 1) << 8 - bitIndex - bitsInThisByte;
          hash[byteIndex] = hash[byteIndex] & ~mask | bits;
          bitsRemaining -= bitsInThisByte;
          bitIndex += bitsInThisByte;
          if (bitIndex === 8) {
            byteIndex++;
            bitIndex = 0;
          }
        }
      }
      this._offset += 267;
      return new Address_1.Address(wc, hash);
    }
    _loadExternalAddress() {
      let type = Number(this._preloadUint(2, this._offset));
      if (type !== 1) {
        throw Error("Invalid address");
      }
      let bits = Number(this._preloadUint(9, this._offset + 2));
      let value = this._preloadUint(bits, this._offset + 11);
      this._offset += 11 + bits;
      return new ExternalAddress_1.ExternalAddress(value, bits);
    }
    _toSafeInteger(src2, alt) {
      if (BigInt(Number.MAX_SAFE_INTEGER) < src2 || src2 < BigInt(Number.MIN_SAFE_INTEGER)) {
        throw new TypeError(`${src2} is out of safe integer range. Use ${alt} instead`);
      }
      return Number(src2);
    }
  };
  BitReader.BitReader = BitReader$12;
  return BitReader;
}
var hasRequiredExoticMerkleProof;
function requireExoticMerkleProof() {
  if (hasRequiredExoticMerkleProof) return exoticMerkleProof;
  hasRequiredExoticMerkleProof = 1;
  Object.defineProperty(exoticMerkleProof, "__esModule", { value: true });
  exoticMerkleProof.convertToMerkleProof = exoticMerkleProof.exoticMerkleProof = void 0;
  const BitReader_1 = requireBitReader();
  const Builder_12 = requireBuilder$1();
  function exoticMerkleProof$12(bits, refs) {
    const reader2 = new BitReader_1.BitReader(bits);
    const size = 8 + 256 + 16;
    if (bits.length !== size) {
      throw new Error(`Merkle Proof cell must have exactly (8 + 256 + 16) bits, got "${bits.length}"`);
    }
    if (refs.length !== 1) {
      throw new Error(`Merkle Proof cell must have exactly 1 ref, got "${refs.length}"`);
    }
    let type = reader2.loadUint(8);
    if (type !== 3) {
      throw new Error(`Merkle Proof cell must have type 3, got "${type}"`);
    }
    const proofHash = reader2.loadBuffer(32);
    const proofDepth = reader2.loadUint(16);
    const refHash = refs[0].hash(0);
    const refDepth = refs[0].depth(0);
    if (proofDepth !== refDepth) {
      throw new Error(`Merkle Proof cell ref depth must be exactly "${proofDepth}", got "${refDepth}"`);
    }
    if (!proofHash.equals(refHash)) {
      throw new Error(`Merkle Proof cell ref hash must be exactly "${proofHash.toString("hex")}", got "${refHash.toString("hex")}"`);
    }
    return {
      proofDepth,
      proofHash
    };
  }
  exoticMerkleProof.exoticMerkleProof = exoticMerkleProof$12;
  function convertToMerkleProof(c) {
    return (0, Builder_12.beginCell)().storeUint(3, 8).storeBuffer(c.hash(0)).storeUint(c.depth(0), 16).storeRef(c).endCell({ exotic: true });
  }
  exoticMerkleProof.convertToMerkleProof = convertToMerkleProof;
  return exoticMerkleProof;
}
var hasRequiredGenerateMerkleProof;
function requireGenerateMerkleProof() {
  if (hasRequiredGenerateMerkleProof) return generateMerkleProof;
  hasRequiredGenerateMerkleProof = 1;
  Object.defineProperty(generateMerkleProof, "__esModule", { value: true });
  generateMerkleProof.generateMerkleProof = generateMerkleProof.generateMerkleProofDirect = void 0;
  const Builder_12 = requireBuilder$1();
  const readUnaryLength_1 = requireReadUnaryLength();
  const exoticMerkleProof_1 = requireExoticMerkleProof();
  function convertToPrunedBranch(c) {
    return (0, Builder_12.beginCell)().storeUint(1, 8).storeUint(1, 8).storeBuffer(c.hash(0)).storeUint(c.depth(0), 16).endCell({ exotic: true });
  }
  function doGenerateMerkleProof(prefix, slice, n, keys) {
    const originalCell = slice.asCell();
    if (keys.length == 0) {
      return convertToPrunedBranch(originalCell);
    }
    let lb0 = slice.loadBit() ? 1 : 0;
    let prefixLength = 0;
    let pp = prefix;
    if (lb0 === 0) {
      prefixLength = (0, readUnaryLength_1.readUnaryLength)(slice);
      for (let i = 0; i < prefixLength; i++) {
        pp += slice.loadBit() ? "1" : "0";
      }
    } else {
      let lb1 = slice.loadBit() ? 1 : 0;
      if (lb1 === 0) {
        prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));
        for (let i = 0; i < prefixLength; i++) {
          pp += slice.loadBit() ? "1" : "0";
        }
      } else {
        let bit = slice.loadBit() ? "1" : "0";
        prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));
        for (let i = 0; i < prefixLength; i++) {
          pp += bit;
        }
      }
    }
    if (n - prefixLength === 0) {
      return originalCell;
    } else {
      let sl = originalCell.beginParse();
      let left = sl.loadRef();
      let right = sl.loadRef();
      if (!left.isExotic) {
        const leftKeys = keys.filter((key2) => {
          return pp + "0" === key2.slice(0, pp.length + 1);
        });
        left = doGenerateMerkleProof(pp + "0", left.beginParse(), n - prefixLength - 1, leftKeys);
      }
      if (!right.isExotic) {
        const rightKeys = keys.filter((key2) => {
          return pp + "1" === key2.slice(0, pp.length + 1);
        });
        right = doGenerateMerkleProof(pp + "1", right.beginParse(), n - prefixLength - 1, rightKeys);
      }
      return (0, Builder_12.beginCell)().storeSlice(sl).storeRef(left).storeRef(right).endCell();
    }
  }
  function generateMerkleProofDirect(dict, keys, keyObject) {
    keys.forEach((key2) => {
      if (!dict.has(key2)) {
        throw new Error(`Trying to generate merkle proof for a missing key "${key2}"`);
      }
    });
    const s = (0, Builder_12.beginCell)().storeDictDirect(dict).asSlice();
    return doGenerateMerkleProof("", s, keyObject.bits, keys.map((key2) => keyObject.serialize(key2).toString(2).padStart(keyObject.bits, "0")));
  }
  generateMerkleProof.generateMerkleProofDirect = generateMerkleProofDirect;
  function generateMerkleProof$12(dict, keys, keyObject) {
    return (0, exoticMerkleProof_1.convertToMerkleProof)(generateMerkleProofDirect(dict, keys, keyObject));
  }
  generateMerkleProof.generateMerkleProof = generateMerkleProof$12;
  return generateMerkleProof;
}
var generateMerkleUpdate = {};
var hasRequiredGenerateMerkleUpdate;
function requireGenerateMerkleUpdate() {
  if (hasRequiredGenerateMerkleUpdate) return generateMerkleUpdate;
  hasRequiredGenerateMerkleUpdate = 1;
  Object.defineProperty(generateMerkleUpdate, "__esModule", { value: true });
  generateMerkleUpdate.generateMerkleUpdate = void 0;
  const Builder_12 = requireBuilder$1();
  const generateMerkleProof_1 = requireGenerateMerkleProof();
  function convertToMerkleUpdate(c1, c2) {
    return (0, Builder_12.beginCell)().storeUint(4, 8).storeBuffer(c1.hash(0)).storeBuffer(c2.hash(0)).storeUint(c1.depth(0), 16).storeUint(c2.depth(0), 16).storeRef(c1).storeRef(c2).endCell({ exotic: true });
  }
  function generateMerkleUpdate$12(dict, key2, keyObject, newValue) {
    const oldProof = (0, generateMerkleProof_1.generateMerkleProof)(dict, [key2], keyObject).refs[0];
    dict.set(key2, newValue);
    const newProof = (0, generateMerkleProof_1.generateMerkleProof)(dict, [key2], keyObject).refs[0];
    return convertToMerkleUpdate(oldProof, newProof);
  }
  generateMerkleUpdate.generateMerkleUpdate = generateMerkleUpdate$12;
  return generateMerkleUpdate;
}
var parseDict = {};
var hasRequiredParseDict;
function requireParseDict() {
  if (hasRequiredParseDict) return parseDict;
  hasRequiredParseDict = 1;
  Object.defineProperty(parseDict, "__esModule", { value: true });
  parseDict.parseDict = void 0;
  function readUnaryLength2(slice) {
    let res = 0;
    while (slice.loadBit()) {
      res++;
    }
    return res;
  }
  function doParse(prefix, slice, n, res, extractor) {
    let lb0 = slice.loadBit() ? 1 : 0;
    let prefixLength = 0;
    let pp = prefix;
    if (lb0 === 0) {
      prefixLength = readUnaryLength2(slice);
      for (let i = 0; i < prefixLength; i++) {
        pp += slice.loadBit() ? "1" : "0";
      }
    } else {
      let lb1 = slice.loadBit() ? 1 : 0;
      if (lb1 === 0) {
        prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));
        for (let i = 0; i < prefixLength; i++) {
          pp += slice.loadBit() ? "1" : "0";
        }
      } else {
        let bit = slice.loadBit() ? "1" : "0";
        prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));
        for (let i = 0; i < prefixLength; i++) {
          pp += bit;
        }
      }
    }
    if (n - prefixLength === 0) {
      res.set(BigInt("0b" + pp), extractor(slice));
    } else {
      let left = slice.loadRef();
      let right = slice.loadRef();
      if (!left.isExotic) {
        doParse(pp + "0", left.beginParse(), n - prefixLength - 1, res, extractor);
      }
      if (!right.isExotic) {
        doParse(pp + "1", right.beginParse(), n - prefixLength - 1, res, extractor);
      }
    }
  }
  function parseDict$12(sc, keySize, extractor) {
    let res = /* @__PURE__ */ new Map();
    if (sc) {
      doParse("", sc, keySize, res, extractor);
    }
    return res;
  }
  parseDict.parseDict = parseDict$12;
  return parseDict;
}
var serializeDict = {};
var findCommonPrefix = {};
var hasRequiredFindCommonPrefix;
function requireFindCommonPrefix() {
  if (hasRequiredFindCommonPrefix) return findCommonPrefix;
  hasRequiredFindCommonPrefix = 1;
  Object.defineProperty(findCommonPrefix, "__esModule", { value: true });
  findCommonPrefix.findCommonPrefix = void 0;
  function findCommonPrefix$12(src2, startPos = 0) {
    if (src2.length === 0) {
      return "";
    }
    let r = src2[0].slice(startPos);
    for (let i = 1; i < src2.length; i++) {
      const s = src2[i];
      while (s.indexOf(r, startPos) !== startPos) {
        r = r.substring(0, r.length - 1);
        if (r === "") {
          return r;
        }
      }
    }
    return r;
  }
  findCommonPrefix.findCommonPrefix = findCommonPrefix$12;
  return findCommonPrefix;
}
var hasRequiredSerializeDict;
function requireSerializeDict() {
  if (hasRequiredSerializeDict) return serializeDict;
  hasRequiredSerializeDict = 1;
  Object.defineProperty(serializeDict, "__esModule", { value: true });
  serializeDict.serializeDict = serializeDict.detectLabelType = serializeDict.writeLabelSame = serializeDict.writeLabelLong = serializeDict.writeLabelShort = serializeDict.buildTree = void 0;
  const Builder_12 = requireBuilder$1();
  const findCommonPrefix_1 = requireFindCommonPrefix();
  function pad(src2, size) {
    while (src2.length < size) {
      src2 = "0" + src2;
    }
    return src2;
  }
  function forkMap(src2, prefixLen) {
    if (src2.size === 0) {
      throw Error("Internal inconsistency");
    }
    let left = /* @__PURE__ */ new Map();
    let right = /* @__PURE__ */ new Map();
    for (let [k, d] of src2.entries()) {
      if (k[prefixLen] === "0") {
        left.set(k, d);
      } else {
        right.set(k, d);
      }
    }
    if (left.size === 0) {
      throw Error("Internal inconsistency. Left emtpy.");
    }
    if (right.size === 0) {
      throw Error("Internal inconsistency. Right emtpy.");
    }
    return { left, right };
  }
  function buildNode(src2, prefixLen) {
    if (src2.size === 0) {
      throw Error("Internal inconsistency");
    }
    if (src2.size === 1) {
      return { type: "leaf", value: Array.from(src2.values())[0] };
    }
    let { left, right } = forkMap(src2, prefixLen);
    return {
      type: "fork",
      left: buildEdge(left, prefixLen + 1),
      right: buildEdge(right, prefixLen + 1)
    };
  }
  function buildEdge(src2, prefixLen = 0) {
    if (src2.size === 0) {
      throw Error("Internal inconsistency");
    }
    const label = (0, findCommonPrefix_1.findCommonPrefix)(Array.from(src2.keys()), prefixLen);
    return { label, node: buildNode(src2, label.length + prefixLen) };
  }
  function buildTree(src2, keyLength) {
    let converted = /* @__PURE__ */ new Map();
    for (let k of Array.from(src2.keys())) {
      const padded = pad(k.toString(2), keyLength);
      converted.set(padded, src2.get(k));
    }
    return buildEdge(converted);
  }
  serializeDict.buildTree = buildTree;
  function writeLabelShort(src2, to) {
    to.storeBit(0);
    for (let i = 0; i < src2.length; i++) {
      to.storeBit(1);
    }
    to.storeBit(0);
    if (src2.length > 0) {
      to.storeUint(BigInt("0b" + src2), src2.length);
    }
    return to;
  }
  serializeDict.writeLabelShort = writeLabelShort;
  function labelShortLength(src2) {
    return 1 + src2.length + 1 + src2.length;
  }
  function writeLabelLong(src2, keyLength, to) {
    to.storeBit(1);
    to.storeBit(0);
    let length = Math.ceil(Math.log2(keyLength + 1));
    to.storeUint(src2.length, length);
    if (src2.length > 0) {
      to.storeUint(BigInt("0b" + src2), src2.length);
    }
    return to;
  }
  serializeDict.writeLabelLong = writeLabelLong;
  function labelLongLength(src2, keyLength) {
    return 1 + 1 + Math.ceil(Math.log2(keyLength + 1)) + src2.length;
  }
  function writeLabelSame(value, length, keyLength, to) {
    to.storeBit(1);
    to.storeBit(1);
    to.storeBit(value);
    let lenLen = Math.ceil(Math.log2(keyLength + 1));
    to.storeUint(length, lenLen);
  }
  serializeDict.writeLabelSame = writeLabelSame;
  function labelSameLength(keyLength) {
    return 1 + 1 + 1 + Math.ceil(Math.log2(keyLength + 1));
  }
  function isSame(src2) {
    if (src2.length === 0 || src2.length === 1) {
      return true;
    }
    for (let i = 1; i < src2.length; i++) {
      if (src2[i] !== src2[0]) {
        return false;
      }
    }
    return true;
  }
  function detectLabelType(src2, keyLength) {
    let kind = "short";
    let kindLength = labelShortLength(src2);
    let longLength = labelLongLength(src2, keyLength);
    if (longLength < kindLength) {
      kindLength = longLength;
      kind = "long";
    }
    if (isSame(src2)) {
      let sameLength = labelSameLength(keyLength);
      if (sameLength < kindLength) {
        kindLength = sameLength;
        kind = "same";
      }
    }
    return kind;
  }
  serializeDict.detectLabelType = detectLabelType;
  function writeLabel(src2, keyLength, to) {
    let type = detectLabelType(src2, keyLength);
    if (type === "short") {
      writeLabelShort(src2, to);
    } else if (type === "long") {
      writeLabelLong(src2, keyLength, to);
    } else if (type === "same") {
      writeLabelSame(src2[0] === "1", src2.length, keyLength, to);
    }
  }
  function writeNode(src2, keyLength, serializer, to) {
    if (src2.type === "leaf") {
      serializer(src2.value, to);
    }
    if (src2.type === "fork") {
      const leftCell = (0, Builder_12.beginCell)();
      const rightCell = (0, Builder_12.beginCell)();
      writeEdge(src2.left, keyLength - 1, serializer, leftCell);
      writeEdge(src2.right, keyLength - 1, serializer, rightCell);
      to.storeRef(leftCell);
      to.storeRef(rightCell);
    }
  }
  function writeEdge(src2, keyLength, serializer, to) {
    writeLabel(src2.label, keyLength, to);
    writeNode(src2.node, keyLength - src2.label.length, serializer, to);
  }
  function serializeDict$12(src2, keyLength, serializer, to) {
    const tree = buildTree(src2, keyLength);
    writeEdge(tree, keyLength, serializer, to);
  }
  serializeDict.serializeDict = serializeDict$12;
  return serializeDict;
}
var internalKeySerializer = {};
var hasRequiredInternalKeySerializer;
function requireInternalKeySerializer() {
  if (hasRequiredInternalKeySerializer) return internalKeySerializer;
  hasRequiredInternalKeySerializer = 1;
  Object.defineProperty(internalKeySerializer, "__esModule", { value: true });
  internalKeySerializer.deserializeInternalKey = internalKeySerializer.serializeInternalKey = void 0;
  const Address_1 = requireAddress();
  const BitString_1 = requireBitString();
  const paddedBits_1 = requirePaddedBits();
  function serializeInternalKey(value) {
    if (typeof value === "number") {
      if (!Number.isSafeInteger(value)) {
        throw Error("Invalid key type: not a safe integer: " + value);
      }
      return "n:" + value.toString(10);
    } else if (typeof value === "bigint") {
      return "b:" + value.toString(10);
    } else if (Address_1.Address.isAddress(value)) {
      return "a:" + value.toString();
    } else if (Buffer.isBuffer(value)) {
      return "f:" + value.toString("hex");
    } else if (BitString_1.BitString.isBitString(value)) {
      return "B:" + value.toString();
    } else {
      throw Error("Invalid key type");
    }
  }
  internalKeySerializer.serializeInternalKey = serializeInternalKey;
  function deserializeInternalKey(value) {
    let k = value.slice(0, 2);
    let v2 = value.slice(2);
    if (k === "n:") {
      return parseInt(v2, 10);
    } else if (k === "b:") {
      return BigInt(v2);
    } else if (k === "a:") {
      return Address_1.Address.parse(v2);
    } else if (k === "f:") {
      return Buffer.from(v2, "hex");
    } else if (k === "B:") {
      const lastDash = v2.slice(-1) == "_";
      const isPadded = lastDash || v2.length % 2 != 0;
      if (isPadded) {
        let charLen = lastDash ? v2.length - 1 : v2.length;
        const padded = v2.substr(0, charLen) + "0";
        if (!lastDash && (charLen & 1) !== 0) {
          return new BitString_1.BitString(Buffer.from(padded, "hex"), 0, charLen << 2);
        } else {
          return (0, paddedBits_1.paddedBufferToBits)(Buffer.from(padded, "hex"));
        }
      } else {
        return new BitString_1.BitString(Buffer.from(v2, "hex"), 0, v2.length << 2);
      }
    }
    throw Error("Invalid key type: " + k);
  }
  internalKeySerializer.deserializeInternalKey = deserializeInternalKey;
  return internalKeySerializer;
}
var hasRequiredDictionary;
function requireDictionary() {
  if (hasRequiredDictionary) return Dictionary;
  hasRequiredDictionary = 1;
  Object.defineProperty(Dictionary, "__esModule", { value: true });
  Dictionary.Dictionary = void 0;
  const Address_1 = requireAddress();
  const Builder_12 = requireBuilder$1();
  const Cell_1 = requireCell();
  const BitString_1 = requireBitString();
  const generateMerkleProof_1 = requireGenerateMerkleProof();
  const generateMerkleUpdate_1 = requireGenerateMerkleUpdate();
  const parseDict_1 = requireParseDict();
  const serializeDict_1 = requireSerializeDict();
  const internalKeySerializer_1 = requireInternalKeySerializer();
  let Dictionary$12 = class Dictionary2 {
    /**
     * Create an empty map
     * @param key key type
     * @param value value type
     * @returns Dictionary<K, V>
     */
    static empty(key2, value) {
      if (key2 && value) {
        return new Dictionary2(/* @__PURE__ */ new Map(), key2, value);
      } else {
        return new Dictionary2(/* @__PURE__ */ new Map(), null, null);
      }
    }
    /**
     * Load dictionary from slice
     * @param key key description
     * @param value value description
     * @param src slice
     * @returns Dictionary<K, V>
     */
    static load(key2, value, sc) {
      let slice;
      if (sc instanceof Cell_1.Cell) {
        if (sc.isExotic) {
          return Dictionary2.empty(key2, value);
        }
        slice = sc.beginParse();
      } else {
        slice = sc;
      }
      let cell = slice.loadMaybeRef();
      if (cell && !cell.isExotic) {
        return Dictionary2.loadDirect(key2, value, cell.beginParse());
      } else {
        return Dictionary2.empty(key2, value);
      }
    }
    /**
     * Low level method for rare dictionaries from system contracts.
     * Loads dictionary from slice directly without going to the ref.
     *
     * @param key key description
     * @param value value description
     * @param sc slice
     * @returns Dictionary<K, V>
     */
    static loadDirect(key2, value, sc) {
      if (!sc) {
        return Dictionary2.empty(key2, value);
      }
      let slice;
      if (sc instanceof Cell_1.Cell) {
        slice = sc.beginParse();
      } else {
        slice = sc;
      }
      let values = (0, parseDict_1.parseDict)(slice, key2.bits, value.parse);
      let prepare = /* @__PURE__ */ new Map();
      for (let [k, v2] of values) {
        prepare.set((0, internalKeySerializer_1.serializeInternalKey)(key2.parse(k)), v2);
      }
      return new Dictionary2(prepare, key2, value);
    }
    constructor(values, key2, value) {
      this._key = key2;
      this._value = value;
      this._map = values;
    }
    get size() {
      return this._map.size;
    }
    get(key2) {
      return this._map.get((0, internalKeySerializer_1.serializeInternalKey)(key2));
    }
    has(key2) {
      return this._map.has((0, internalKeySerializer_1.serializeInternalKey)(key2));
    }
    set(key2, value) {
      this._map.set((0, internalKeySerializer_1.serializeInternalKey)(key2), value);
      return this;
    }
    delete(key2) {
      const k = (0, internalKeySerializer_1.serializeInternalKey)(key2);
      return this._map.delete(k);
    }
    clear() {
      this._map.clear();
    }
    *[Symbol.iterator]() {
      for (const [k, v2] of this._map) {
        const key2 = (0, internalKeySerializer_1.deserializeInternalKey)(k);
        yield [key2, v2];
      }
    }
    keys() {
      return Array.from(this._map.keys()).map((v2) => (0, internalKeySerializer_1.deserializeInternalKey)(v2));
    }
    values() {
      return Array.from(this._map.values());
    }
    store(builder2, key2, value) {
      if (this._map.size === 0) {
        builder2.storeBit(0);
      } else {
        let resolvedKey = this._key;
        if (key2 !== null && key2 !== void 0) {
          resolvedKey = key2;
        }
        let resolvedValue = this._value;
        if (value !== null && value !== void 0) {
          resolvedValue = value;
        }
        if (!resolvedKey) {
          throw Error("Key serializer is not defined");
        }
        if (!resolvedValue) {
          throw Error("Value serializer is not defined");
        }
        let prepared = /* @__PURE__ */ new Map();
        for (const [k, v2] of this._map) {
          prepared.set(resolvedKey.serialize((0, internalKeySerializer_1.deserializeInternalKey)(k)), v2);
        }
        builder2.storeBit(1);
        let dd = (0, Builder_12.beginCell)();
        (0, serializeDict_1.serializeDict)(prepared, resolvedKey.bits, resolvedValue.serialize, dd);
        builder2.storeRef(dd.endCell());
      }
    }
    storeDirect(builder2, key2, value) {
      if (this._map.size === 0) {
        throw Error("Cannot store empty dictionary directly");
      }
      let resolvedKey = this._key;
      if (key2 !== null && key2 !== void 0) {
        resolvedKey = key2;
      }
      let resolvedValue = this._value;
      if (value !== null && value !== void 0) {
        resolvedValue = value;
      }
      if (!resolvedKey) {
        throw Error("Key serializer is not defined");
      }
      if (!resolvedValue) {
        throw Error("Value serializer is not defined");
      }
      let prepared = /* @__PURE__ */ new Map();
      for (const [k, v2] of this._map) {
        prepared.set(resolvedKey.serialize((0, internalKeySerializer_1.deserializeInternalKey)(k)), v2);
      }
      (0, serializeDict_1.serializeDict)(prepared, resolvedKey.bits, resolvedValue.serialize, builder2);
    }
    /**
     * Generate merkle proof for multiple keys in the dictionary
     * @param keys an array of the keys
     * @returns generated merkle proof cell
     */
    generateMerkleProof(keys) {
      return (0, generateMerkleProof_1.generateMerkleProof)(this, keys, this._key);
    }
    /**
     * Low level method for generating pruned dictionary directly.
     * The result can be used as a part of a bigger merkle proof
     * @param keys an array of the keys
     * @returns cell that contains the pruned dictionary
     */
    generateMerkleProofDirect(keys) {
      return (0, generateMerkleProof_1.generateMerkleProofDirect)(this, keys, this._key);
    }
    generateMerkleUpdate(key2, newValue) {
      return (0, generateMerkleUpdate_1.generateMerkleUpdate)(this, key2, this._key, newValue);
    }
  };
  Dictionary.Dictionary = Dictionary$12;
  Dictionary$12.Keys = {
    /**
     * Standard address key
     * @returns DictionaryKey<Address>
     */
    Address: () => {
      return createAddressKey();
    },
    /**
     * Create standard big integer key
     * @param bits number of bits
     * @returns DictionaryKey<bigint>
     */
    BigInt: (bits) => {
      return createBigIntKey(bits);
    },
    /**
     * Create integer key
     * @param bits bits of integer
     * @returns DictionaryKey<number>
     */
    Int: (bits) => {
      return createIntKey(bits);
    },
    /**
     * Create standard unsigned big integer key
     * @param bits number of bits
     * @returns DictionaryKey<bigint>
     */
    BigUint: (bits) => {
      return createBigUintKey(bits);
    },
    /**
     * Create standard unsigned integer key
     * @param bits number of bits
     * @returns DictionaryKey<number>
     */
    Uint: (bits) => {
      return createUintKey(bits);
    },
    /**
     * Create standard buffer key
     * @param bytes number of bytes of a buffer
     * @returns DictionaryKey<Buffer>
     */
    Buffer: (bytes) => {
      return createBufferKey(bytes);
    },
    /**
     * Create BitString key
     * @param bits key length
     * @returns DictionaryKey<BitString>
     * Point is that Buffer has to be 8 bit aligned,
     * while key is TVM dictionary doesn't have to be
     * aligned at all.
     */
    BitString: (bits) => {
      return createBitStringKey(bits);
    }
  };
  Dictionary$12.Values = {
    /**
     * Create standard integer value
     * @returns DictionaryValue<bigint>
     */
    BigInt: (bits) => {
      return createBigIntValue(bits);
    },
    /**
     * Create standard integer value
     * @returns DictionaryValue<number>
     */
    Int: (bits) => {
      return createIntValue(bits);
    },
    /**
     * Create big var int
     * @param bits nubmer of header bits
     * @returns DictionaryValue<bigint>
     */
    BigVarInt: (bits) => {
      return createBigVarIntValue(bits);
    },
    /**
     * Create standard unsigned integer value
     * @param bits number of bits
     * @returns DictionaryValue<bigint>
     */
    BigUint: (bits) => {
      return createBigUintValue(bits);
    },
    /**
     * Create standard unsigned integer value
     * @param bits number of bits
     * @returns DictionaryValue<bigint>
     */
    Uint: (bits) => {
      return createUintValue(bits);
    },
    /**
     * Create big var int
     * @param bits nubmer of header bits
     * @returns DictionaryValue<bigint>
     */
    BigVarUint: (bits) => {
      return createBigVarUintValue(bits);
    },
    /**
     * Create standard boolean value
     * @returns DictionaryValue<boolean>
     */
    Bool: () => {
      return createBooleanValue();
    },
    /**
     * Create standard address value
     * @returns DictionaryValue<Address>
     */
    Address: () => {
      return createAddressValue();
    },
    /**
     * Create standard cell value
     * @returns DictionaryValue<Cell>
     */
    Cell: () => {
      return createCellValue();
    },
    /**
     * Create Builder value
     * @param bytes number of bytes of a buffer
     * @returns DictionaryValue<Builder>
     */
    Buffer: (bytes) => {
      return createBufferValue(bytes);
    },
    /**
     * Create BitString value
     * @param requested bit length
     * @returns DictionaryValue<BitString>
     * Point is that Buffer is not applicable
     * when length is not 8 bit alligned.
     */
    BitString: (bits) => {
      return createBitStringValue(bits);
    },
    /**
     * Create dictionary value
     * @param key
     * @param value
     */
    Dictionary: (key2, value) => {
      return createDictionaryValue(key2, value);
    }
  };
  function createAddressKey() {
    return {
      bits: 267,
      serialize: (src2) => {
        if (!Address_1.Address.isAddress(src2)) {
          throw Error("Key is not an address");
        }
        return (0, Builder_12.beginCell)().storeAddress(src2).endCell().beginParse().preloadUintBig(267);
      },
      parse: (src2) => {
        return (0, Builder_12.beginCell)().storeUint(src2, 267).endCell().beginParse().loadAddress();
      }
    };
  }
  function createBigIntKey(bits) {
    return {
      bits,
      serialize: (src2) => {
        if (typeof src2 !== "bigint") {
          throw Error("Key is not a bigint");
        }
        return (0, Builder_12.beginCell)().storeInt(src2, bits).endCell().beginParse().loadUintBig(bits);
      },
      parse: (src2) => {
        return (0, Builder_12.beginCell)().storeUint(src2, bits).endCell().beginParse().loadIntBig(bits);
      }
    };
  }
  function createIntKey(bits) {
    return {
      bits,
      serialize: (src2) => {
        if (typeof src2 !== "number") {
          throw Error("Key is not a number");
        }
        if (!Number.isSafeInteger(src2)) {
          throw Error("Key is not a safe integer: " + src2);
        }
        return (0, Builder_12.beginCell)().storeInt(src2, bits).endCell().beginParse().loadUintBig(bits);
      },
      parse: (src2) => {
        return (0, Builder_12.beginCell)().storeUint(src2, bits).endCell().beginParse().loadInt(bits);
      }
    };
  }
  function createBigUintKey(bits) {
    return {
      bits,
      serialize: (src2) => {
        if (typeof src2 !== "bigint") {
          throw Error("Key is not a bigint");
        }
        if (src2 < 0) {
          throw Error("Key is negative: " + src2);
        }
        return (0, Builder_12.beginCell)().storeUint(src2, bits).endCell().beginParse().loadUintBig(bits);
      },
      parse: (src2) => {
        return (0, Builder_12.beginCell)().storeUint(src2, bits).endCell().beginParse().loadUintBig(bits);
      }
    };
  }
  function createUintKey(bits) {
    return {
      bits,
      serialize: (src2) => {
        if (typeof src2 !== "number") {
          throw Error("Key is not a number");
        }
        if (!Number.isSafeInteger(src2)) {
          throw Error("Key is not a safe integer: " + src2);
        }
        if (src2 < 0) {
          throw Error("Key is negative: " + src2);
        }
        return (0, Builder_12.beginCell)().storeUint(src2, bits).endCell().beginParse().loadUintBig(bits);
      },
      parse: (src2) => {
        return Number((0, Builder_12.beginCell)().storeUint(src2, bits).endCell().beginParse().loadUint(bits));
      }
    };
  }
  function createBufferKey(bytes) {
    return {
      bits: bytes * 8,
      serialize: (src2) => {
        if (!Buffer.isBuffer(src2)) {
          throw Error("Key is not a buffer");
        }
        return (0, Builder_12.beginCell)().storeBuffer(src2).endCell().beginParse().loadUintBig(bytes * 8);
      },
      parse: (src2) => {
        return (0, Builder_12.beginCell)().storeUint(src2, bytes * 8).endCell().beginParse().loadBuffer(bytes);
      }
    };
  }
  function createBitStringKey(bits) {
    return {
      bits,
      serialize: (src2) => {
        if (!BitString_1.BitString.isBitString(src2))
          throw Error("Key is not a BitString");
        return (0, Builder_12.beginCell)().storeBits(src2).endCell().beginParse().loadUintBig(bits);
      },
      parse: (src2) => {
        return (0, Builder_12.beginCell)().storeUint(src2, bits).endCell().beginParse().loadBits(bits);
      }
    };
  }
  function createIntValue(bits) {
    return {
      serialize: (src2, buidler) => {
        buidler.storeInt(src2, bits);
      },
      parse: (src2) => {
        let value = src2.loadInt(bits);
        src2.endParse();
        return value;
      }
    };
  }
  function createBigIntValue(bits) {
    return {
      serialize: (src2, buidler) => {
        buidler.storeInt(src2, bits);
      },
      parse: (src2) => {
        let value = src2.loadIntBig(bits);
        src2.endParse();
        return value;
      }
    };
  }
  function createBigVarIntValue(bits) {
    return {
      serialize: (src2, buidler) => {
        buidler.storeVarInt(src2, bits);
      },
      parse: (src2) => {
        let value = src2.loadVarIntBig(bits);
        src2.endParse();
        return value;
      }
    };
  }
  function createBigVarUintValue(bits) {
    return {
      serialize: (src2, buidler) => {
        buidler.storeVarUint(src2, bits);
      },
      parse: (src2) => {
        let value = src2.loadVarUintBig(bits);
        src2.endParse();
        return value;
      }
    };
  }
  function createUintValue(bits) {
    return {
      serialize: (src2, buidler) => {
        buidler.storeUint(src2, bits);
      },
      parse: (src2) => {
        let value = src2.loadUint(bits);
        src2.endParse();
        return value;
      }
    };
  }
  function createBigUintValue(bits) {
    return {
      serialize: (src2, buidler) => {
        buidler.storeUint(src2, bits);
      },
      parse: (src2) => {
        let value = src2.loadUintBig(bits);
        src2.endParse();
        return value;
      }
    };
  }
  function createBooleanValue() {
    return {
      serialize: (src2, buidler) => {
        buidler.storeBit(src2);
      },
      parse: (src2) => {
        let value = src2.loadBit();
        src2.endParse();
        return value;
      }
    };
  }
  function createAddressValue() {
    return {
      serialize: (src2, buidler) => {
        buidler.storeAddress(src2);
      },
      parse: (src2) => {
        let addr = src2.loadAddress();
        src2.endParse();
        return addr;
      }
    };
  }
  function createCellValue() {
    return {
      serialize: (src2, buidler) => {
        buidler.storeRef(src2);
      },
      parse: (src2) => {
        let value = src2.loadRef();
        src2.endParse();
        return value;
      }
    };
  }
  function createDictionaryValue(key2, value) {
    return {
      serialize: (src2, buidler) => {
        src2.store(buidler);
      },
      parse: (src2) => {
        let dict = Dictionary$12.load(key2, value, src2);
        src2.endParse();
        return dict;
      }
    };
  }
  function createBufferValue(size) {
    return {
      serialize: (src2, buidler) => {
        if (src2.length !== size) {
          throw Error("Invalid buffer size");
        }
        buidler.storeBuffer(src2);
      },
      parse: (src2) => {
        let value = src2.loadBuffer(size);
        src2.endParse();
        return value;
      }
    };
  }
  function createBitStringValue(bits) {
    return {
      serialize: (src2, builder2) => {
        if (src2.length !== bits) {
          throw Error("Invalid BitString size");
        }
        builder2.storeBits(src2);
      },
      parse: (src2) => {
        let value = src2.loadBits(bits);
        src2.endParse();
        return value;
      }
    };
  }
  return Dictionary;
}
var strings = {};
var hasRequiredStrings;
function requireStrings() {
  if (hasRequiredStrings) return strings;
  hasRequiredStrings = 1;
  Object.defineProperty(strings, "__esModule", { value: true });
  strings.writeString = strings.stringToCell = strings.readString = void 0;
  const Builder_12 = requireBuilder$1();
  function readBuffer(slice) {
    if (slice.remainingBits % 8 !== 0) {
      throw new Error(`Invalid string length: ${slice.remainingBits}`);
    }
    if (slice.remainingRefs !== 0 && slice.remainingRefs !== 1) {
      throw new Error(`invalid number of refs: ${slice.remainingRefs}`);
    }
    let res;
    if (slice.remainingBits === 0) {
      res = Buffer.alloc(0);
    } else {
      res = slice.loadBuffer(slice.remainingBits / 8);
    }
    if (slice.remainingRefs === 1) {
      res = Buffer.concat([res, readBuffer(slice.loadRef().beginParse())]);
    }
    return res;
  }
  function readString(slice) {
    return readBuffer(slice).toString();
  }
  strings.readString = readString;
  function writeBuffer(src2, builder2) {
    if (src2.length > 0) {
      let bytes = Math.floor(builder2.availableBits / 8);
      if (src2.length > bytes) {
        let a = src2.subarray(0, bytes);
        let t = src2.subarray(bytes);
        builder2 = builder2.storeBuffer(a);
        let bb = (0, Builder_12.beginCell)();
        writeBuffer(t, bb);
        builder2 = builder2.storeRef(bb.endCell());
      } else {
        builder2 = builder2.storeBuffer(src2);
      }
    }
  }
  function stringToCell(src2) {
    let builder2 = (0, Builder_12.beginCell)();
    writeBuffer(Buffer.from(src2), builder2);
    return builder2.endCell();
  }
  strings.stringToCell = stringToCell;
  function writeString(src2, builder2) {
    writeBuffer(Buffer.from(src2), builder2);
  }
  strings.writeString = writeString;
  return strings;
}
var hasRequiredSlice;
function requireSlice() {
  if (hasRequiredSlice) return Slice;
  hasRequiredSlice = 1;
  var __importDefault = Slice && Slice.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  var _a;
  Object.defineProperty(Slice, "__esModule", { value: true });
  Slice.Slice = void 0;
  const symbol_inspect_1 = __importDefault(requireSymbol_inspect());
  const Dictionary_1 = requireDictionary();
  const Builder_12 = requireBuilder$1();
  const strings_1 = requireStrings();
  let Slice$12 = class Slice2 {
    constructor(reader2, refs) {
      this[_a] = () => this.toString();
      this._reader = reader2.clone();
      this._refs = [...refs];
      this._refsOffset = 0;
    }
    /**
     * Get remaining bits
     */
    get remainingBits() {
      return this._reader.remaining;
    }
    /**
     * Get offset bits
     */
    get offsetBits() {
      return this._reader.offset;
    }
    /**
     * Get remaining refs
     */
    get remainingRefs() {
      return this._refs.length - this._refsOffset;
    }
    /**
     * Get offset refs
     */
    get offsetRefs() {
      return this._refsOffset;
    }
    /**
     * Skip bits
     * @param bits
     */
    skip(bits) {
      this._reader.skip(bits);
      return this;
    }
    /**
     * Load a single bit
     * @returns true or false depending on the bit value
     */
    loadBit() {
      return this._reader.loadBit();
    }
    /**
     * Preload a signle bit
     * @returns true or false depending on the bit value
     */
    preloadBit() {
      return this._reader.preloadBit();
    }
    /**
     * Load a boolean
     * @returns true or false depending on the bit value
     */
    loadBoolean() {
      return this.loadBit();
    }
    /**
     * Load maybe boolean
     * @returns true or false depending on the bit value or null
     */
    loadMaybeBoolean() {
      if (this.loadBit()) {
        return this.loadBoolean();
      } else {
        return null;
      }
    }
    /**
     * Load bits as a new BitString
     * @param bits number of bits to read
     * @returns new BitString
     */
    loadBits(bits) {
      return this._reader.loadBits(bits);
    }
    /**
     * Preload bits as a new BitString
     * @param bits number of bits to read
     * @returns new BitString
     */
    preloadBits(bits) {
      return this._reader.preloadBits(bits);
    }
    /**
     * Load uint
     * @param bits number of bits to read
     * @returns uint value
     */
    loadUint(bits) {
      return this._reader.loadUint(bits);
    }
    /**
     * Load uint
     * @param bits number of bits to read
     * @returns uint value
     */
    loadUintBig(bits) {
      return this._reader.loadUintBig(bits);
    }
    /**
     * Preload uint
     * @param bits number of bits to read
     * @returns uint value
     */
    preloadUint(bits) {
      return this._reader.preloadUint(bits);
    }
    /**
     * Preload uint
     * @param bits number of bits to read
     * @returns uint value
     */
    preloadUintBig(bits) {
      return this._reader.preloadUintBig(bits);
    }
    /**
     * Load maybe uint
     * @param bits number of bits to read
     * @returns uint value or null
     */
    loadMaybeUint(bits) {
      if (this.loadBit()) {
        return this.loadUint(bits);
      } else {
        return null;
      }
    }
    /**
     * Load maybe uint
     * @param bits number of bits to read
     * @returns uint value or null
     */
    loadMaybeUintBig(bits) {
      if (this.loadBit()) {
        return this.loadUintBig(bits);
      } else {
        return null;
      }
    }
    /**
     * Load int
     * @param bits number of bits to read
     * @returns int value
     */
    loadInt(bits) {
      return this._reader.loadInt(bits);
    }
    /**
     * Load int
     * @param bits number of bits to read
     * @returns int value
     */
    loadIntBig(bits) {
      return this._reader.loadIntBig(bits);
    }
    /**
     * Preload int
     * @param bits number of bits to read
     * @returns int value
     */
    preloadInt(bits) {
      return this._reader.preloadInt(bits);
    }
    /**
     * Preload int
     * @param bits number of bits to read
     * @returns int value
     */
    preloadIntBig(bits) {
      return this._reader.preloadIntBig(bits);
    }
    /**
     * Load maybe uint
     * @param bits number of bits to read
     * @returns uint value or null
     */
    loadMaybeInt(bits) {
      if (this.loadBit()) {
        return this.loadInt(bits);
      } else {
        return null;
      }
    }
    /**
     * Load maybe uint
     * @param bits number of bits to read
     * @returns uint value or null
     */
    loadMaybeIntBig(bits) {
      if (this.loadBit()) {
        return this.loadIntBig(bits);
      } else {
        return null;
      }
    }
    /**
     * Load varuint
     * @param bits number of bits to read in header
     * @returns varuint value
     */
    loadVarUint(bits) {
      return this._reader.loadVarUint(bits);
    }
    /**
     * Load varuint
     * @param bits number of bits to read in header
     * @returns varuint value
     */
    loadVarUintBig(bits) {
      return this._reader.loadVarUintBig(bits);
    }
    /**
     * Preload varuint
     * @param bits number of bits to read in header
     * @returns varuint value
     */
    preloadVarUint(bits) {
      return this._reader.preloadVarUint(bits);
    }
    /**
     * Preload varuint
     * @param bits number of bits to read in header
     * @returns varuint value
     */
    preloadVarUintBig(bits) {
      return this._reader.preloadVarUintBig(bits);
    }
    /**
     * Load varint
     * @param bits number of bits to read in header
     * @returns varint value
     */
    loadVarInt(bits) {
      return this._reader.loadVarInt(bits);
    }
    /**
     * Load varint
     * @param bits number of bits to read in header
     * @returns varint value
     */
    loadVarIntBig(bits) {
      return this._reader.loadVarIntBig(bits);
    }
    /**
     * Preload varint
     * @param bits number of bits to read in header
     * @returns varint value
     */
    preloadVarInt(bits) {
      return this._reader.preloadVarInt(bits);
    }
    /**
     * Preload varint
     * @param bits number of bits to read in header
     * @returns varint value
     */
    preloadVarIntBig(bits) {
      return this._reader.preloadVarIntBig(bits);
    }
    /**
     * Load coins
     * @returns coins value
     */
    loadCoins() {
      return this._reader.loadCoins();
    }
    /**
     * Preload coins
     * @returns coins value
     */
    preloadCoins() {
      return this._reader.preloadCoins();
    }
    /**
     * Load maybe coins
     * @returns coins value or null
     */
    loadMaybeCoins() {
      if (this._reader.loadBit()) {
        return this._reader.loadCoins();
      } else {
        return null;
      }
    }
    /**
     * Load internal Address
     * @returns Address
     */
    loadAddress() {
      return this._reader.loadAddress();
    }
    /**
     * Load optional internal Address
     * @returns Address or null
     */
    loadMaybeAddress() {
      return this._reader.loadMaybeAddress();
    }
    /**
     * Load external address
     * @returns ExternalAddress
     */
    loadExternalAddress() {
      return this._reader.loadExternalAddress();
    }
    /**
     * Load optional external address
     * @returns ExternalAddress or null
     */
    loadMaybeExternalAddress() {
      return this._reader.loadMaybeExternalAddress();
    }
    /**
     * Load address
     * @returns Address, ExternalAddress or null
     */
    loadAddressAny() {
      return this._reader.loadAddressAny();
    }
    /**
     * Load reference
     * @returns Cell
     */
    loadRef() {
      if (this._refsOffset >= this._refs.length) {
        throw new Error("No more references");
      }
      return this._refs[this._refsOffset++];
    }
    /**
     * Preload reference
     * @returns Cell
     */
    preloadRef() {
      if (this._refsOffset >= this._refs.length) {
        throw new Error("No more references");
      }
      return this._refs[this._refsOffset];
    }
    /**
     * Load optional reference
     * @returns Cell or null
     */
    loadMaybeRef() {
      if (this.loadBit()) {
        return this.loadRef();
      } else {
        return null;
      }
    }
    /**
     * Preload optional reference
     * @returns Cell or null
     */
    preloadMaybeRef() {
      if (this.preloadBit()) {
        return this.preloadRef();
      } else {
        return null;
      }
    }
    /**
     * Load byte buffer
     * @param bytes number of bytes to load
     * @returns Buffer
     */
    loadBuffer(bytes) {
      return this._reader.loadBuffer(bytes);
    }
    /**
     * Load byte buffer
     * @param bytes number of bytes to load
     * @returns Buffer
     */
    preloadBuffer(bytes) {
      return this._reader.preloadBuffer(bytes);
    }
    /**
     * Load string tail
     */
    loadStringTail() {
      return (0, strings_1.readString)(this);
    }
    /**
     * Load maybe string tail
     * @returns string or null
     */
    loadMaybeStringTail() {
      if (this.loadBit()) {
        return (0, strings_1.readString)(this);
      } else {
        return null;
      }
    }
    /**
     * Load string tail from ref
     * @returns string
     */
    loadStringRefTail() {
      return (0, strings_1.readString)(this.loadRef().beginParse());
    }
    /**
     * Load maybe string tail from ref
     * @returns string or null
     */
    loadMaybeStringRefTail() {
      const ref = this.loadMaybeRef();
      if (ref) {
        return (0, strings_1.readString)(ref.beginParse());
      } else {
        return null;
      }
    }
    /**
     * Loads dictionary
     * @param key key description
     * @param value value description
     * @returns Dictionary<K, V>
     */
    loadDict(key2, value) {
      return Dictionary_1.Dictionary.load(key2, value, this);
    }
    /**
     * Loads dictionary directly from current slice
     * @param key key description
     * @param value value description
     * @returns Dictionary<K, V>
     */
    loadDictDirect(key2, value) {
      return Dictionary_1.Dictionary.loadDirect(key2, value, this);
    }
    /**
     * Checks if slice is empty
     */
    endParse() {
      if (this.remainingBits > 0 || this.remainingRefs > 0) {
        throw new Error("Slice is not empty");
      }
    }
    /**
     * Convert slice to cell
     */
    asCell() {
      return (0, Builder_12.beginCell)().storeSlice(this).endCell();
    }
    /**
     *
     * @returns
     */
    asBuilder() {
      return (0, Builder_12.beginCell)().storeSlice(this);
    }
    /**
     * Clone slice
     * @returns cloned slice
     */
    clone(fromStart = false) {
      if (fromStart) {
        let reader2 = this._reader.clone();
        reader2.reset();
        return new Slice2(reader2, this._refs);
      } else {
        let res = new Slice2(this._reader, this._refs);
        res._refsOffset = this._refsOffset;
        return res;
      }
    }
    /**
     * Print slice as string by converting it to cell
     * @returns string
     */
    toString() {
      return this.asCell().toString();
    }
  };
  Slice.Slice = Slice$12;
  _a = symbol_inspect_1.default;
  return Slice;
}
var resolveExotic = {};
var exoticLibrary = {};
var hasRequiredExoticLibrary;
function requireExoticLibrary() {
  if (hasRequiredExoticLibrary) return exoticLibrary;
  hasRequiredExoticLibrary = 1;
  Object.defineProperty(exoticLibrary, "__esModule", { value: true });
  exoticLibrary.exoticLibrary = void 0;
  const BitReader_1 = requireBitReader();
  function exoticLibrary$12(bits, refs) {
    const reader2 = new BitReader_1.BitReader(bits);
    const size = 8 + 256;
    if (bits.length !== size) {
      throw new Error(`Library cell must have exactly (8 + 256) bits, got "${bits.length}"`);
    }
    let type = reader2.loadUint(8);
    if (type !== 2) {
      throw new Error(`Library cell must have type 2, got "${type}"`);
    }
    return {};
  }
  exoticLibrary.exoticLibrary = exoticLibrary$12;
  return exoticLibrary;
}
var exoticMerkleUpdate = {};
var hasRequiredExoticMerkleUpdate;
function requireExoticMerkleUpdate() {
  if (hasRequiredExoticMerkleUpdate) return exoticMerkleUpdate;
  hasRequiredExoticMerkleUpdate = 1;
  Object.defineProperty(exoticMerkleUpdate, "__esModule", { value: true });
  exoticMerkleUpdate.exoticMerkleUpdate = void 0;
  const BitReader_1 = requireBitReader();
  function exoticMerkleUpdate$12(bits, refs) {
    const reader2 = new BitReader_1.BitReader(bits);
    const size = 8 + 2 * (256 + 16);
    if (bits.length !== size) {
      throw new Error(`Merkle Update cell must have exactly (8 + (2 * (256 + 16))) bits, got "${bits.length}"`);
    }
    if (refs.length !== 2) {
      throw new Error(`Merkle Update cell must have exactly 2 refs, got "${refs.length}"`);
    }
    let type = reader2.loadUint(8);
    if (type !== 4) {
      throw new Error(`Merkle Update cell type must be exactly 4, got "${type}"`);
    }
    const proofHash1 = reader2.loadBuffer(32);
    const proofHash2 = reader2.loadBuffer(32);
    const proofDepth1 = reader2.loadUint(16);
    const proofDepth2 = reader2.loadUint(16);
    if (proofDepth1 !== refs[0].depth(0)) {
      throw new Error(`Merkle Update cell ref depth must be exactly "${proofDepth1}", got "${refs[0].depth(0)}"`);
    }
    if (!proofHash1.equals(refs[0].hash(0))) {
      throw new Error(`Merkle Update cell ref hash must be exactly "${proofHash1.toString("hex")}", got "${refs[0].hash(0).toString("hex")}"`);
    }
    if (proofDepth2 !== refs[1].depth(0)) {
      throw new Error(`Merkle Update cell ref depth must be exactly "${proofDepth2}", got "${refs[1].depth(0)}"`);
    }
    if (!proofHash2.equals(refs[1].hash(0))) {
      throw new Error(`Merkle Update cell ref hash must be exactly "${proofHash2.toString("hex")}", got "${refs[1].hash(0).toString("hex")}"`);
    }
    return {
      proofDepth1,
      proofDepth2,
      proofHash1,
      proofHash2
    };
  }
  exoticMerkleUpdate.exoticMerkleUpdate = exoticMerkleUpdate$12;
  return exoticMerkleUpdate;
}
var exoticPruned = {};
var LevelMask = {};
var hasRequiredLevelMask;
function requireLevelMask() {
  if (hasRequiredLevelMask) return LevelMask;
  hasRequiredLevelMask = 1;
  Object.defineProperty(LevelMask, "__esModule", { value: true });
  LevelMask.LevelMask = void 0;
  let LevelMask$12 = class LevelMask2 {
    constructor(mask = 0) {
      this._mask = 0;
      this._mask = mask;
      this._hashIndex = countSetBits(this._mask);
      this._hashCount = this._hashIndex + 1;
    }
    get value() {
      return this._mask;
    }
    get level() {
      return 32 - Math.clz32(this._mask);
    }
    get hashIndex() {
      return this._hashIndex;
    }
    get hashCount() {
      return this._hashCount;
    }
    apply(level) {
      return new LevelMask2(this._mask & (1 << level) - 1);
    }
    isSignificant(level) {
      let res = level === 0 || (this._mask >> level - 1) % 2 !== 0;
      return res;
    }
  };
  LevelMask.LevelMask = LevelMask$12;
  function countSetBits(n) {
    n = n - (n >> 1 & 1431655765);
    n = (n & 858993459) + (n >> 2 & 858993459);
    return (n + (n >> 4) & 252645135) * 16843009 >> 24;
  }
  return LevelMask;
}
var hasRequiredExoticPruned;
function requireExoticPruned() {
  if (hasRequiredExoticPruned) return exoticPruned;
  hasRequiredExoticPruned = 1;
  Object.defineProperty(exoticPruned, "__esModule", { value: true });
  exoticPruned.exoticPruned = void 0;
  const BitReader_1 = requireBitReader();
  const LevelMask_1 = requireLevelMask();
  function exoticPruned$12(bits, refs) {
    let reader2 = new BitReader_1.BitReader(bits);
    let type = reader2.loadUint(8);
    if (type !== 1) {
      throw new Error(`Pruned branch cell must have type 1, got "${type}"`);
    }
    if (refs.length !== 0) {
      throw new Error(`Pruned Branch cell can't has refs, got "${refs.length}"`);
    }
    let mask;
    if (bits.length === 280) {
      mask = new LevelMask_1.LevelMask(1);
    } else {
      mask = new LevelMask_1.LevelMask(reader2.loadUint(8));
      if (mask.level < 1 || mask.level > 3) {
        throw new Error(`Pruned Branch cell level must be >= 1 and <= 3, got "${mask.level}/${mask.value}"`);
      }
      const size = 8 + 8 + mask.apply(mask.level - 1).hashCount * (256 + 16);
      if (bits.length !== size) {
        throw new Error(`Pruned branch cell must have exactly ${size} bits, got "${bits.length}"`);
      }
    }
    let pruned = [];
    let hashes = [];
    let depths = [];
    for (let i = 0; i < mask.level; i++) {
      hashes.push(reader2.loadBuffer(32));
    }
    for (let i = 0; i < mask.level; i++) {
      depths.push(reader2.loadUint(16));
    }
    for (let i = 0; i < mask.level; i++) {
      pruned.push({
        depth: depths[i],
        hash: hashes[i]
      });
    }
    return {
      mask: mask.value,
      pruned
    };
  }
  exoticPruned.exoticPruned = exoticPruned$12;
  return exoticPruned;
}
var hasRequiredResolveExotic;
function requireResolveExotic() {
  if (hasRequiredResolveExotic) return resolveExotic;
  hasRequiredResolveExotic = 1;
  Object.defineProperty(resolveExotic, "__esModule", { value: true });
  resolveExotic.resolveExotic = void 0;
  const BitReader_1 = requireBitReader();
  const CellType_1 = requireCellType();
  const exoticLibrary_1 = requireExoticLibrary();
  const exoticMerkleProof_1 = requireExoticMerkleProof();
  const exoticMerkleUpdate_1 = requireExoticMerkleUpdate();
  const exoticPruned_1 = requireExoticPruned();
  const LevelMask_1 = requireLevelMask();
  function resolvePruned(bits, refs) {
    let pruned = (0, exoticPruned_1.exoticPruned)(bits, refs);
    let depths = [];
    let hashes = [];
    let mask = new LevelMask_1.LevelMask(pruned.mask);
    for (let i = 0; i < pruned.pruned.length; i++) {
      depths.push(pruned.pruned[i].depth);
      hashes.push(pruned.pruned[i].hash);
    }
    return {
      type: CellType_1.CellType.PrunedBranch,
      depths,
      hashes,
      mask
    };
  }
  function resolveLibrary(bits, refs) {
    (0, exoticLibrary_1.exoticLibrary)(bits, refs);
    let depths = [];
    let hashes = [];
    let mask = new LevelMask_1.LevelMask();
    return {
      type: CellType_1.CellType.Library,
      depths,
      hashes,
      mask
    };
  }
  function resolveMerkleProof(bits, refs) {
    (0, exoticMerkleProof_1.exoticMerkleProof)(bits, refs);
    let depths = [];
    let hashes = [];
    let mask = new LevelMask_1.LevelMask(refs[0].level() >> 1);
    return {
      type: CellType_1.CellType.MerkleProof,
      depths,
      hashes,
      mask
    };
  }
  function resolveMerkleUpdate(bits, refs) {
    (0, exoticMerkleUpdate_1.exoticMerkleUpdate)(bits, refs);
    let depths = [];
    let hashes = [];
    let mask = new LevelMask_1.LevelMask((refs[0].level() | refs[1].level()) >> 1);
    return {
      type: CellType_1.CellType.MerkleUpdate,
      depths,
      hashes,
      mask
    };
  }
  function resolveExotic$12(bits, refs) {
    let reader2 = new BitReader_1.BitReader(bits);
    let type = reader2.preloadUint(8);
    if (type === 1) {
      return resolvePruned(bits, refs);
    }
    if (type === 2) {
      return resolveLibrary(bits, refs);
    }
    if (type === 3) {
      return resolveMerkleProof(bits, refs);
    }
    if (type === 4) {
      return resolveMerkleUpdate(bits, refs);
    }
    throw Error("Invalid exotic cell type: " + type);
  }
  resolveExotic.resolveExotic = resolveExotic$12;
  return resolveExotic;
}
var wonderCalculator = {};
var descriptor = {};
var hasRequiredDescriptor;
function requireDescriptor() {
  if (hasRequiredDescriptor) return descriptor;
  hasRequiredDescriptor = 1;
  Object.defineProperty(descriptor, "__esModule", { value: true });
  descriptor.getRepr = descriptor.getBitsDescriptor = descriptor.getRefsDescriptor = void 0;
  const CellType_1 = requireCellType();
  const paddedBits_1 = requirePaddedBits();
  function getRefsDescriptor(refs, levelMask, type) {
    return refs.length + (type !== CellType_1.CellType.Ordinary ? 1 : 0) * 8 + levelMask * 32;
  }
  descriptor.getRefsDescriptor = getRefsDescriptor;
  function getBitsDescriptor(bits) {
    let len = bits.length;
    return Math.ceil(len / 8) + Math.floor(len / 8);
  }
  descriptor.getBitsDescriptor = getBitsDescriptor;
  function getRepr(originalBits, bits, refs, level, levelMask, type) {
    const bitsLen = Math.ceil(bits.length / 8);
    const repr = Buffer.alloc(2 + bitsLen + (2 + 32) * refs.length);
    let reprCursor = 0;
    repr[reprCursor++] = getRefsDescriptor(refs, levelMask, type);
    repr[reprCursor++] = getBitsDescriptor(originalBits);
    (0, paddedBits_1.bitsToPaddedBuffer)(bits).copy(repr, reprCursor);
    reprCursor += bitsLen;
    for (const c of refs) {
      let childDepth;
      if (type == CellType_1.CellType.MerkleProof || type == CellType_1.CellType.MerkleUpdate) {
        childDepth = c.depth(level + 1);
      } else {
        childDepth = c.depth(level);
      }
      repr[reprCursor++] = Math.floor(childDepth / 256);
      repr[reprCursor++] = childDepth % 256;
    }
    for (const c of refs) {
      let childHash;
      if (type == CellType_1.CellType.MerkleProof || type == CellType_1.CellType.MerkleUpdate) {
        childHash = c.hash(level + 1);
      } else {
        childHash = c.hash(level);
      }
      childHash.copy(repr, reprCursor);
      reprCursor += 32;
    }
    return repr;
  }
  descriptor.getRepr = getRepr;
  return descriptor;
}
var hasRequiredWonderCalculator;
function requireWonderCalculator() {
  if (hasRequiredWonderCalculator) return wonderCalculator;
  hasRequiredWonderCalculator = 1;
  Object.defineProperty(wonderCalculator, "__esModule", { value: true });
  wonderCalculator.wonderCalculator = void 0;
  const BitString_1 = requireBitString();
  const CellType_1 = requireCellType();
  const LevelMask_1 = requireLevelMask();
  const exoticPruned_1 = requireExoticPruned();
  const exoticMerkleProof_1 = requireExoticMerkleProof();
  const descriptor_1 = requireDescriptor();
  const crypto_1 = requireDist$6();
  const exoticMerkleUpdate_1 = requireExoticMerkleUpdate();
  const exoticLibrary_1 = requireExoticLibrary();
  function wonderCalculator$12(type, bits, refs) {
    let levelMask;
    let pruned = null;
    if (type === CellType_1.CellType.Ordinary) {
      let mask = 0;
      for (let r of refs) {
        mask = mask | r.mask.value;
      }
      levelMask = new LevelMask_1.LevelMask(mask);
    } else if (type === CellType_1.CellType.PrunedBranch) {
      pruned = (0, exoticPruned_1.exoticPruned)(bits, refs);
      levelMask = new LevelMask_1.LevelMask(pruned.mask);
    } else if (type === CellType_1.CellType.MerkleProof) {
      (0, exoticMerkleProof_1.exoticMerkleProof)(bits, refs);
      levelMask = new LevelMask_1.LevelMask(refs[0].mask.value >> 1);
    } else if (type === CellType_1.CellType.MerkleUpdate) {
      (0, exoticMerkleUpdate_1.exoticMerkleUpdate)(bits, refs);
      levelMask = new LevelMask_1.LevelMask((refs[0].mask.value | refs[1].mask.value) >> 1);
    } else if (type === CellType_1.CellType.Library) {
      (0, exoticLibrary_1.exoticLibrary)(bits, refs);
      levelMask = new LevelMask_1.LevelMask();
    } else {
      throw new Error("Unsupported exotic type");
    }
    let depths = [];
    let hashes = [];
    let hashCount = type === CellType_1.CellType.PrunedBranch ? 1 : levelMask.hashCount;
    let totalHashCount = levelMask.hashCount;
    let hashIOffset = totalHashCount - hashCount;
    for (let levelI = 0, hashI = 0; levelI <= levelMask.level; levelI++) {
      if (!levelMask.isSignificant(levelI)) {
        continue;
      }
      if (hashI < hashIOffset) {
        hashI++;
        continue;
      }
      let currentBits;
      if (hashI === hashIOffset) {
        if (!(levelI === 0 || type === CellType_1.CellType.PrunedBranch)) {
          throw Error("Invalid");
        }
        currentBits = bits;
      } else {
        if (!(levelI !== 0 && type !== CellType_1.CellType.PrunedBranch)) {
          throw Error("Invalid: " + levelI + ", " + type);
        }
        currentBits = new BitString_1.BitString(hashes[hashI - hashIOffset - 1], 0, 256);
      }
      let currentDepth = 0;
      for (let c of refs) {
        let childDepth;
        if (type == CellType_1.CellType.MerkleProof || type == CellType_1.CellType.MerkleUpdate) {
          childDepth = c.depth(levelI + 1);
        } else {
          childDepth = c.depth(levelI);
        }
        currentDepth = Math.max(currentDepth, childDepth);
      }
      if (refs.length > 0) {
        currentDepth++;
      }
      let repr = (0, descriptor_1.getRepr)(bits, currentBits, refs, levelI, levelMask.apply(levelI).value, type);
      let hash = (0, crypto_1.sha256_sync)(repr);
      let destI = hashI - hashIOffset;
      depths[destI] = currentDepth;
      hashes[destI] = hash;
      hashI++;
    }
    let resolvedHashes = [];
    let resolvedDepths = [];
    if (pruned) {
      for (let i = 0; i < 4; i++) {
        const { hashIndex } = levelMask.apply(i);
        const { hashIndex: thisHashIndex } = levelMask;
        if (hashIndex !== thisHashIndex) {
          resolvedHashes.push(pruned.pruned[hashIndex].hash);
          resolvedDepths.push(pruned.pruned[hashIndex].depth);
        } else {
          resolvedHashes.push(hashes[0]);
          resolvedDepths.push(depths[0]);
        }
      }
    } else {
      for (let i = 0; i < 4; i++) {
        resolvedHashes.push(hashes[levelMask.apply(i).hashIndex]);
        resolvedDepths.push(depths[levelMask.apply(i).hashIndex]);
      }
    }
    return {
      mask: levelMask,
      hashes: resolvedHashes,
      depths: resolvedDepths
    };
  }
  wonderCalculator.wonderCalculator = wonderCalculator$12;
  return wonderCalculator;
}
var serialization = {};
var topologicalSort = {};
var hasRequiredTopologicalSort;
function requireTopologicalSort() {
  if (hasRequiredTopologicalSort) return topologicalSort;
  hasRequiredTopologicalSort = 1;
  Object.defineProperty(topologicalSort, "__esModule", { value: true });
  topologicalSort.topologicalSort = void 0;
  function topologicalSort$12(src2) {
    let pending = [src2];
    let allCells = /* @__PURE__ */ new Map();
    let notPermCells = /* @__PURE__ */ new Set();
    let sorted = [];
    while (pending.length > 0) {
      const cells = [...pending];
      pending = [];
      for (let cell of cells) {
        const hash = cell.hash().toString("hex");
        if (allCells.has(hash)) {
          continue;
        }
        notPermCells.add(hash);
        allCells.set(hash, { cell, refs: cell.refs.map((v2) => v2.hash().toString("hex")) });
        for (let r of cell.refs) {
          pending.push(r);
        }
      }
    }
    let tempMark = /* @__PURE__ */ new Set();
    function visit2(hash) {
      if (!notPermCells.has(hash)) {
        return;
      }
      if (tempMark.has(hash)) {
        throw Error("Not a DAG");
      }
      tempMark.add(hash);
      let refs = allCells.get(hash).refs;
      for (let ci = refs.length - 1; ci >= 0; ci--) {
        visit2(refs[ci]);
      }
      sorted.push(hash);
      tempMark.delete(hash);
      notPermCells.delete(hash);
    }
    while (notPermCells.size > 0) {
      const id = Array.from(notPermCells)[0];
      visit2(id);
    }
    let indexes = /* @__PURE__ */ new Map();
    for (let i = 0; i < sorted.length; i++) {
      indexes.set(sorted[sorted.length - i - 1], i);
    }
    let result = [];
    for (let i = sorted.length - 1; i >= 0; i--) {
      let ent = sorted[i];
      const rrr = allCells.get(ent);
      result.push({ cell: rrr.cell, refs: rrr.refs.map((v2) => indexes.get(v2)) });
    }
    return result;
  }
  topologicalSort.topologicalSort = topologicalSort$12;
  return topologicalSort;
}
var bitsForNumber = {};
var hasRequiredBitsForNumber;
function requireBitsForNumber() {
  if (hasRequiredBitsForNumber) return bitsForNumber;
  hasRequiredBitsForNumber = 1;
  Object.defineProperty(bitsForNumber, "__esModule", { value: true });
  bitsForNumber.bitsForNumber = void 0;
  function bitsForNumber$12(src2, mode) {
    let v2 = BigInt(src2);
    if (mode === "int") {
      if (v2 === 0n || v2 === -1n) {
        return 1;
      }
      let v22 = v2 > 0 ? v2 : -v2;
      return v22.toString(2).length + 1;
    } else if (mode === "uint") {
      if (v2 < 0) {
        throw Error(`value is negative. Got ${src2}`);
      }
      return v2.toString(2).length;
    } else {
      throw Error(`invalid mode. Got ${mode}`);
    }
  }
  bitsForNumber.bitsForNumber = bitsForNumber$12;
  return bitsForNumber;
}
var crc32c = {};
var hasRequiredCrc32c;
function requireCrc32c() {
  if (hasRequiredCrc32c) return crc32c;
  hasRequiredCrc32c = 1;
  Object.defineProperty(crc32c, "__esModule", { value: true });
  crc32c.crc32c = void 0;
  const POLY = 2197175160;
  function crc32c$12(source) {
    let crc = 0 ^ 4294967295;
    for (let n = 0; n < source.length; n++) {
      crc ^= source[n];
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
      crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
    }
    crc = crc ^ 4294967295;
    let res = Buffer.alloc(4);
    res.writeInt32LE(crc);
    return res;
  }
  crc32c.crc32c = crc32c$12;
  return crc32c;
}
var hasRequiredSerialization;
function requireSerialization() {
  if (hasRequiredSerialization) return serialization;
  hasRequiredSerialization = 1;
  Object.defineProperty(serialization, "__esModule", { value: true });
  serialization.serializeBoc = serialization.deserializeBoc = serialization.parseBoc = void 0;
  const BitReader_1 = requireBitReader();
  const BitString_1 = requireBitString();
  const Cell_1 = requireCell();
  const topologicalSort_1 = requireTopologicalSort();
  const bitsForNumber_1 = requireBitsForNumber();
  const BitBuilder_1 = requireBitBuilder();
  const descriptor_1 = requireDescriptor();
  const paddedBits_1 = requirePaddedBits();
  const crc32c_1 = requireCrc32c();
  function getHashesCount(levelMask) {
    return getHashesCountFromMask(levelMask & 7);
  }
  function getHashesCountFromMask(mask) {
    let n = 0;
    for (let i = 0; i < 3; i++) {
      n += mask & 1;
      mask = mask >> 1;
    }
    return n + 1;
  }
  function readCell(reader2, sizeBytes) {
    const d1 = reader2.loadUint(8);
    const refsCount = d1 % 8;
    const exotic = !!(d1 & 8);
    const d2 = reader2.loadUint(8);
    const dataBytesize = Math.ceil(d2 / 2);
    const paddingAdded = !!(d2 % 2);
    const levelMask = d1 >> 5;
    const hasHashes = (d1 & 16) != 0;
    const hash_bytes = 32;
    const hashesSize = hasHashes ? getHashesCount(levelMask) * hash_bytes : 0;
    const depthSize = hasHashes ? getHashesCount(levelMask) * 2 : 0;
    reader2.skip(hashesSize * 8);
    reader2.skip(depthSize * 8);
    let bits = BitString_1.BitString.EMPTY;
    if (dataBytesize > 0) {
      if (paddingAdded) {
        bits = reader2.loadPaddedBits(dataBytesize * 8);
      } else {
        bits = reader2.loadBits(dataBytesize * 8);
      }
    }
    let refs = [];
    for (let i = 0; i < refsCount; i++) {
      refs.push(reader2.loadUint(sizeBytes * 8));
    }
    return {
      bits,
      refs,
      exotic
    };
  }
  function calcCellSize(cell, sizeBytes) {
    return 2 + Math.ceil(cell.bits.length / 8) + cell.refs.length * sizeBytes;
  }
  function parseBoc(src2) {
    let reader2 = new BitReader_1.BitReader(new BitString_1.BitString(src2, 0, src2.length * 8));
    let magic = reader2.loadUint(32);
    if (magic === 1761568243) {
      let size = reader2.loadUint(8);
      let offBytes = reader2.loadUint(8);
      let cells = reader2.loadUint(size * 8);
      let roots = reader2.loadUint(size * 8);
      let absent = reader2.loadUint(size * 8);
      let totalCellSize = reader2.loadUint(offBytes * 8);
      let index = reader2.loadBuffer(cells * offBytes);
      let cellData = reader2.loadBuffer(totalCellSize);
      return {
        size,
        offBytes,
        cells,
        roots,
        absent,
        totalCellSize,
        index,
        cellData,
        root: [0]
      };
    } else if (magic === 2898503464) {
      let size = reader2.loadUint(8);
      let offBytes = reader2.loadUint(8);
      let cells = reader2.loadUint(size * 8);
      let roots = reader2.loadUint(size * 8);
      let absent = reader2.loadUint(size * 8);
      let totalCellSize = reader2.loadUint(offBytes * 8);
      let index = reader2.loadBuffer(cells * offBytes);
      let cellData = reader2.loadBuffer(totalCellSize);
      let crc32 = reader2.loadBuffer(4);
      if (!(0, crc32c_1.crc32c)(src2.subarray(0, src2.length - 4)).equals(crc32)) {
        throw Error("Invalid CRC32C");
      }
      return {
        size,
        offBytes,
        cells,
        roots,
        absent,
        totalCellSize,
        index,
        cellData,
        root: [0]
      };
    } else if (magic === 3052313714) {
      let hasIdx = reader2.loadUint(1);
      let hasCrc32c = reader2.loadUint(1);
      reader2.loadUint(1);
      reader2.loadUint(2);
      let size = reader2.loadUint(3);
      let offBytes = reader2.loadUint(8);
      let cells = reader2.loadUint(size * 8);
      let roots = reader2.loadUint(size * 8);
      let absent = reader2.loadUint(size * 8);
      let totalCellSize = reader2.loadUint(offBytes * 8);
      let root = [];
      for (let i = 0; i < roots; i++) {
        root.push(reader2.loadUint(size * 8));
      }
      let index = null;
      if (hasIdx) {
        index = reader2.loadBuffer(cells * offBytes);
      }
      let cellData = reader2.loadBuffer(totalCellSize);
      if (hasCrc32c) {
        let crc32 = reader2.loadBuffer(4);
        if (!(0, crc32c_1.crc32c)(src2.subarray(0, src2.length - 4)).equals(crc32)) {
          throw Error("Invalid CRC32C");
        }
      }
      return {
        size,
        offBytes,
        cells,
        roots,
        absent,
        totalCellSize,
        index,
        cellData,
        root
      };
    } else {
      throw Error("Invalid magic");
    }
  }
  serialization.parseBoc = parseBoc;
  function deserializeBoc(src2) {
    let boc = parseBoc(src2);
    let reader2 = new BitReader_1.BitReader(new BitString_1.BitString(boc.cellData, 0, boc.cellData.length * 8));
    let cells = [];
    for (let i = 0; i < boc.cells; i++) {
      let cll = readCell(reader2, boc.size);
      cells.push({ ...cll, result: null });
    }
    for (let i = cells.length - 1; i >= 0; i--) {
      if (cells[i].result) {
        throw Error("Impossible");
      }
      let refs = [];
      for (let r of cells[i].refs) {
        if (!cells[r].result) {
          throw Error("Invalid BOC file");
        }
        refs.push(cells[r].result);
      }
      cells[i].result = new Cell_1.Cell({ bits: cells[i].bits, refs, exotic: cells[i].exotic });
    }
    let roots = [];
    for (let i = 0; i < boc.root.length; i++) {
      roots.push(cells[boc.root[i]].result);
    }
    return roots;
  }
  serialization.deserializeBoc = deserializeBoc;
  function writeCellToBuilder(cell, refs, sizeBytes, to) {
    let d1 = (0, descriptor_1.getRefsDescriptor)(cell.refs, cell.mask.value, cell.type);
    let d2 = (0, descriptor_1.getBitsDescriptor)(cell.bits);
    to.writeUint(d1, 8);
    to.writeUint(d2, 8);
    to.writeBuffer((0, paddedBits_1.bitsToPaddedBuffer)(cell.bits));
    for (let r of refs) {
      to.writeUint(r, sizeBytes * 8);
    }
  }
  function serializeBoc(root, opts) {
    let allCells = (0, topologicalSort_1.topologicalSort)(root);
    let cellsNum = allCells.length;
    let has_idx = opts.idx;
    let has_crc32c = opts.crc32;
    let has_cache_bits = false;
    let flags = 0;
    let sizeBytes = Math.max(Math.ceil((0, bitsForNumber_1.bitsForNumber)(cellsNum, "uint") / 8), 1);
    let totalCellSize = 0;
    let index = [];
    for (let c of allCells) {
      let sz = calcCellSize(c.cell, sizeBytes);
      totalCellSize += sz;
      index.push(totalCellSize);
    }
    let offsetBytes = Math.max(Math.ceil((0, bitsForNumber_1.bitsForNumber)(totalCellSize, "uint") / 8), 1);
    let totalSize = (4 + // magic
    1 + // flags and s_bytes
    1 + // offset_bytes
    3 * sizeBytes + // cells_num, roots, complete
    offsetBytes + // full_size
    1 * sizeBytes + // root_idx
    (has_idx ? cellsNum * offsetBytes : 0) + totalCellSize + (has_crc32c ? 4 : 0)) * 8;
    let builder2 = new BitBuilder_1.BitBuilder(totalSize);
    builder2.writeUint(3052313714, 32);
    builder2.writeBit(has_idx);
    builder2.writeBit(has_crc32c);
    builder2.writeBit(has_cache_bits);
    builder2.writeUint(flags, 2);
    builder2.writeUint(sizeBytes, 3);
    builder2.writeUint(offsetBytes, 8);
    builder2.writeUint(cellsNum, sizeBytes * 8);
    builder2.writeUint(1, sizeBytes * 8);
    builder2.writeUint(0, sizeBytes * 8);
    builder2.writeUint(totalCellSize, offsetBytes * 8);
    builder2.writeUint(0, sizeBytes * 8);
    if (has_idx) {
      for (let i = 0; i < cellsNum; i++) {
        builder2.writeUint(index[i], offsetBytes * 8);
      }
    }
    for (let i = 0; i < cellsNum; i++) {
      writeCellToBuilder(allCells[i].cell, allCells[i].refs, sizeBytes, builder2);
    }
    if (has_crc32c) {
      let crc32 = (0, crc32c_1.crc32c)(builder2.buffer());
      builder2.writeBuffer(crc32);
    }
    let res = builder2.buffer();
    if (res.length !== totalSize / 8) {
      throw Error("Internal error");
    }
    return res;
  }
  serialization.serializeBoc = serializeBoc;
  return serialization;
}
var hasRequiredCell;
function requireCell() {
  if (hasRequiredCell) return Cell;
  hasRequiredCell = 1;
  var __importDefault = Cell && Cell.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  var _a;
  Object.defineProperty(Cell, "__esModule", { value: true });
  Cell.Cell = void 0;
  const symbol_inspect_1 = __importDefault(requireSymbol_inspect());
  const BitString_1 = requireBitString();
  const CellType_1 = requireCellType();
  const Slice_1 = requireSlice();
  const resolveExotic_1 = requireResolveExotic();
  const wonderCalculator_1 = requireWonderCalculator();
  const serialization_1 = requireSerialization();
  const BitReader_1 = requireBitReader();
  const Builder_12 = requireBuilder$1();
  let Cell$12 = class Cell2 {
    /**
     * Deserialize cells from BOC
     * @param src source buffer
     * @returns array of cells
     */
    static fromBoc(src2) {
      return (0, serialization_1.deserializeBoc)(src2);
    }
    /**
     * Helper function that deserializes a single cell from BOC in base64
     * @param src source string
     */
    static fromBase64(src2) {
      let parsed = Cell2.fromBoc(Buffer.from(src2, "base64"));
      if (parsed.length !== 1) {
        throw new Error("Deserialized more than one cell");
      }
      return parsed[0];
    }
    /**
     * Helper function that deserializes a single cell from BOC in hex
     * @param src source string
     */
    static fromHex(src2) {
      let parsed = Cell2.fromBoc(Buffer.from(src2, "hex"));
      if (parsed.length !== 1) {
        throw new Error("Deserialized more than one cell");
      }
      return parsed[0];
    }
    constructor(opts) {
      this._hashes = [];
      this._depths = [];
      this.beginParse = (allowExotic = false) => {
        if (this.isExotic && !allowExotic) {
          throw new Error("Exotic cells cannot be parsed");
        }
        return new Slice_1.Slice(new BitReader_1.BitReader(this.bits), this.refs);
      };
      this.hash = (level = 3) => {
        return this._hashes[Math.min(this._hashes.length - 1, level)];
      };
      this.depth = (level = 3) => {
        return this._depths[Math.min(this._depths.length - 1, level)];
      };
      this.level = () => {
        return this.mask.level;
      };
      this.equals = (other) => {
        return this.hash().equals(other.hash());
      };
      this[_a] = () => this.toString();
      let bits = BitString_1.BitString.EMPTY;
      if (opts && opts.bits) {
        bits = opts.bits;
      }
      let refs = [];
      if (opts && opts.refs) {
        refs = [...opts.refs];
      }
      let hashes;
      let depths;
      let mask;
      let type = CellType_1.CellType.Ordinary;
      if (opts && opts.exotic) {
        let resolved = (0, resolveExotic_1.resolveExotic)(bits, refs);
        let wonders = (0, wonderCalculator_1.wonderCalculator)(resolved.type, bits, refs);
        mask = wonders.mask;
        depths = wonders.depths;
        hashes = wonders.hashes;
        type = resolved.type;
      } else {
        if (refs.length > 4) {
          throw new Error("Invalid number of references");
        }
        if (bits.length > 1023) {
          throw new Error(`Bits overflow: ${bits.length} > 1023`);
        }
        let wonders = (0, wonderCalculator_1.wonderCalculator)(CellType_1.CellType.Ordinary, bits, refs);
        mask = wonders.mask;
        depths = wonders.depths;
        hashes = wonders.hashes;
        type = CellType_1.CellType.Ordinary;
      }
      this.type = type;
      this.bits = bits;
      this.refs = refs;
      this.mask = mask;
      this._depths = depths;
      this._hashes = hashes;
      Object.freeze(this);
      Object.freeze(this.refs);
      Object.freeze(this.bits);
      Object.freeze(this.mask);
      Object.freeze(this._depths);
      Object.freeze(this._hashes);
    }
    /**
     * Check if cell is exotic
     */
    get isExotic() {
      return this.type !== CellType_1.CellType.Ordinary;
    }
    /**
     * Serializes cell to BOC
     * @param opts options
     */
    toBoc(opts) {
      let idx = opts && opts.idx !== null && opts.idx !== void 0 ? opts.idx : false;
      let crc32 = opts && opts.crc32 !== null && opts.crc32 !== void 0 ? opts.crc32 : true;
      return (0, serialization_1.serializeBoc)(this, { idx, crc32 });
    }
    /**
     * Format cell to string
     * @param indent indentation
     * @returns string representation
     */
    toString(indent) {
      let id = indent || "";
      let t = "x";
      if (this.isExotic) {
        if (this.type === CellType_1.CellType.MerkleProof) {
          t = "p";
        } else if (this.type === CellType_1.CellType.MerkleUpdate) {
          t = "u";
        } else if (this.type === CellType_1.CellType.PrunedBranch) {
          t = "p";
        }
      }
      let s = id + (this.isExotic ? t : "x") + "{" + this.bits.toString() + "}";
      for (let k in this.refs) {
        const i = this.refs[k];
        s += "\n" + i.toString(id + " ");
      }
      return s;
    }
    /**
     * Covnert cell to slice
     * @returns slice
     */
    asSlice() {
      return this.beginParse();
    }
    /**
     * Convert cell to a builder that has this cell stored
     * @returns builder
     */
    asBuilder() {
      return (0, Builder_12.beginCell)().storeSlice(this.asSlice());
    }
  };
  Cell.Cell = Cell$12;
  _a = symbol_inspect_1.default;
  Cell$12.EMPTY = new Cell$12();
  return Cell;
}
var hasRequiredBuilder$1;
function requireBuilder$1() {
  if (hasRequiredBuilder$1) return Builder$3;
  hasRequiredBuilder$1 = 1;
  Object.defineProperty(Builder$3, "__esModule", { value: true });
  Builder$3.Builder = Builder$3.beginCell = void 0;
  const BitBuilder_1 = requireBitBuilder();
  const Cell_1 = requireCell();
  const strings_1 = requireStrings();
  function beginCell() {
    return new Builder2();
  }
  Builder$3.beginCell = beginCell;
  class Builder2 {
    constructor() {
      this._bits = new BitBuilder_1.BitBuilder();
      this._refs = [];
    }
    /**
     * Bits written so far
     */
    get bits() {
      return this._bits.length;
    }
    /**
     * References written so far
     */
    get refs() {
      return this._refs.length;
    }
    /**
     * Available bits
     */
    get availableBits() {
      return 1023 - this.bits;
    }
    /**
     * Available references
     */
    get availableRefs() {
      return 4 - this.refs;
    }
    /**
     * Write a single bit
     * @param value bit to write, true or positive number for 1, false or zero or negative for 0
     * @returns this builder
     */
    storeBit(value) {
      this._bits.writeBit(value);
      return this;
    }
    /**
     * Write bits from BitString
     * @param src source bits
     * @returns this builder
     */
    storeBits(src2) {
      this._bits.writeBits(src2);
      return this;
    }
    /**
     * Store Buffer
     * @param src source buffer
     * @param bytes optional number of bytes to write
     * @returns this builder
     */
    storeBuffer(src2, bytes) {
      if (bytes !== void 0 && bytes !== null) {
        if (src2.length !== bytes) {
          throw Error(`Buffer length ${src2.length} is not equal to ${bytes}`);
        }
      }
      this._bits.writeBuffer(src2);
      return this;
    }
    /**
     * Store Maybe Buffer
     * @param src source buffer or null
     * @param bytes optional number of bytes to write
     * @returns this builder
     */
    storeMaybeBuffer(src2, bytes) {
      if (src2 !== null) {
        this.storeBit(1);
        this.storeBuffer(src2, bytes);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store uint value
     * @param value value as bigint or number
     * @param bits number of bits to write
     * @returns this builder
     */
    storeUint(value, bits) {
      this._bits.writeUint(value, bits);
      return this;
    }
    /**
     * Store maybe uint value
     * @param value value as bigint or number, null or undefined
     * @param bits number of bits to write
     * @returns this builder
     */
    storeMaybeUint(value, bits) {
      if (value !== null && value !== void 0) {
        this.storeBit(1);
        this.storeUint(value, bits);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store int value
     * @param value value as bigint or number
     * @param bits number of bits to write
     * @returns this builder
     */
    storeInt(value, bits) {
      this._bits.writeInt(value, bits);
      return this;
    }
    /**
     * Store maybe int value
     * @param value value as bigint or number, null or undefined
     * @param bits number of bits to write
     * @returns this builder
     */
    storeMaybeInt(value, bits) {
      if (value !== null && value !== void 0) {
        this.storeBit(1);
        this.storeInt(value, bits);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store varuint value
     * @param value value as bigint or number
     * @param bits number of bits to write to header
     * @returns this builder
     */
    storeVarUint(value, bits) {
      this._bits.writeVarUint(value, bits);
      return this;
    }
    /**
     * Store maybe varuint value
     * @param value value as bigint or number, null or undefined
     * @param bits number of bits to write to header
     * @returns this builder
     */
    storeMaybeVarUint(value, bits) {
      if (value !== null && value !== void 0) {
        this.storeBit(1);
        this.storeVarUint(value, bits);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store varint value
     * @param value value as bigint or number
     * @param bits number of bits to write to header
     * @returns this builder
     */
    storeVarInt(value, bits) {
      this._bits.writeVarInt(value, bits);
      return this;
    }
    /**
     * Store maybe varint value
     * @param value value as bigint or number, null or undefined
     * @param bits number of bits to write to header
     * @returns this builder
     */
    storeMaybeVarInt(value, bits) {
      if (value !== null && value !== void 0) {
        this.storeBit(1);
        this.storeVarInt(value, bits);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store coins value
     * @param amount amount of coins
     * @returns this builder
     */
    storeCoins(amount) {
      this._bits.writeCoins(amount);
      return this;
    }
    /**
     * Store maybe coins value
     * @param amount amount of coins, null or undefined
     * @returns this builder
     */
    storeMaybeCoins(amount) {
      if (amount !== null && amount !== void 0) {
        this.storeBit(1);
        this.storeCoins(amount);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store address
     * @param addres address to store
     * @returns this builder
     */
    storeAddress(address) {
      this._bits.writeAddress(address);
      return this;
    }
    /**
     * Store reference
     * @param cell cell or builder to store
     * @returns this builder
     */
    storeRef(cell) {
      if (this._refs.length >= 4) {
        throw new Error("Too many references");
      }
      if (cell instanceof Cell_1.Cell) {
        this._refs.push(cell);
      } else if (cell instanceof Builder2) {
        this._refs.push(cell.endCell());
      } else {
        throw new Error("Invalid argument");
      }
      return this;
    }
    /**
     * Store reference if not null
     * @param cell cell or builder to store
     * @returns this builder
     */
    storeMaybeRef(cell) {
      if (cell) {
        this.storeBit(1);
        this.storeRef(cell);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store slice it in this builder
     * @param src source slice
     */
    storeSlice(src2) {
      let c = src2.clone();
      if (c.remainingBits > 0) {
        this.storeBits(c.loadBits(c.remainingBits));
      }
      while (c.remainingRefs > 0) {
        this.storeRef(c.loadRef());
      }
      return this;
    }
    /**
     * Store slice in this builder if not null
     * @param src source slice
     */
    storeMaybeSlice(src2) {
      if (src2) {
        this.storeBit(1);
        this.storeSlice(src2);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store builder
     * @param src builder to store
     * @returns this builder
     */
    storeBuilder(src2) {
      return this.storeSlice(src2.endCell().beginParse());
    }
    /**
     * Store builder if not null
     * @param src builder to store
     * @returns this builder
     */
    storeMaybeBuilder(src2) {
      if (src2) {
        this.storeBit(1);
        this.storeBuilder(src2);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store writer or builder
     * @param writer writer or builder to store
     * @returns this builder
     */
    storeWritable(writer) {
      if (typeof writer === "object") {
        writer.writeTo(this);
      } else {
        writer(this);
      }
      return this;
    }
    /**
     * Store writer or builder if not null
     * @param writer writer or builder to store
     * @returns this builder
     */
    storeMaybeWritable(writer) {
      if (writer) {
        this.storeBit(1);
        this.storeWritable(writer);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store object in this builder
     * @param writer Writable or writer functuin
     */
    store(writer) {
      this.storeWritable(writer);
      return this;
    }
    /**
     * Store string tail
     * @param src source string
     * @returns this builder
     */
    storeStringTail(src2) {
      (0, strings_1.writeString)(src2, this);
      return this;
    }
    /**
     * Store string tail
     * @param src source string
     * @returns this builder
     */
    storeMaybeStringTail(src2) {
      if (src2 !== null && src2 !== void 0) {
        this.storeBit(1);
        (0, strings_1.writeString)(src2, this);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store string tail in ref
     * @param src source string
     * @returns this builder
     */
    storeStringRefTail(src2) {
      this.storeRef(beginCell().storeStringTail(src2));
      return this;
    }
    /**
     * Store maybe string tail in ref
     * @param src source string
     * @returns this builder
     */
    storeMaybeStringRefTail(src2) {
      if (src2 !== null && src2 !== void 0) {
        this.storeBit(1);
        this.storeStringRefTail(src2);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store dictionary in this builder
     * @param dict dictionary to store
     * @returns this builder
     */
    storeDict(dict, key2, value) {
      if (dict) {
        dict.store(this, key2, value);
      } else {
        this.storeBit(0);
      }
      return this;
    }
    /**
     * Store dictionary in this builder directly
     * @param dict dictionary to store
     * @returns this builder
     */
    storeDictDirect(dict, key2, value) {
      dict.storeDirect(this, key2, value);
      return this;
    }
    /**
     * Complete cell
     * @param opts options
     * @returns cell
     */
    endCell(opts) {
      return new Cell_1.Cell({
        bits: this._bits.build(),
        refs: this._refs,
        exotic: opts?.exotic
      });
    }
    /**
     * Convert to cell
     * @returns cell
     */
    asCell() {
      return this.endCell();
    }
    /**
     * Convert to slice
     * @returns slice
     */
    asSlice() {
      return this.endCell().beginParse();
    }
  }
  Builder$3.Builder = Builder2;
  return Builder$3;
}
var StateInit = {};
var SimpleLibrary = {};
var hasRequiredSimpleLibrary;
function requireSimpleLibrary() {
  if (hasRequiredSimpleLibrary) return SimpleLibrary;
  hasRequiredSimpleLibrary = 1;
  Object.defineProperty(SimpleLibrary, "__esModule", { value: true });
  SimpleLibrary.SimpleLibraryValue = SimpleLibrary.storeSimpleLibrary = SimpleLibrary.loadSimpleLibrary = void 0;
  function loadSimpleLibrary(slice) {
    return {
      public: slice.loadBit(),
      root: slice.loadRef()
    };
  }
  SimpleLibrary.loadSimpleLibrary = loadSimpleLibrary;
  function storeSimpleLibrary(src2) {
    return (builder2) => {
      builder2.storeBit(src2.public);
      builder2.storeRef(src2.root);
    };
  }
  SimpleLibrary.storeSimpleLibrary = storeSimpleLibrary;
  SimpleLibrary.SimpleLibraryValue = {
    serialize(src2, builder2) {
      storeSimpleLibrary(src2)(builder2);
    },
    parse(src2) {
      return loadSimpleLibrary(src2);
    }
  };
  return SimpleLibrary;
}
var TickTock = {};
var hasRequiredTickTock;
function requireTickTock() {
  if (hasRequiredTickTock) return TickTock;
  hasRequiredTickTock = 1;
  Object.defineProperty(TickTock, "__esModule", { value: true });
  TickTock.storeTickTock = TickTock.loadTickTock = void 0;
  function loadTickTock(slice) {
    return {
      tick: slice.loadBit(),
      tock: slice.loadBit()
    };
  }
  TickTock.loadTickTock = loadTickTock;
  function storeTickTock(src2) {
    return (builder2) => {
      builder2.storeBit(src2.tick);
      builder2.storeBit(src2.tock);
    };
  }
  TickTock.storeTickTock = storeTickTock;
  return TickTock;
}
var hasRequiredStateInit;
function requireStateInit() {
  if (hasRequiredStateInit) return StateInit;
  hasRequiredStateInit = 1;
  Object.defineProperty(StateInit, "__esModule", { value: true });
  StateInit.storeStateInit = StateInit.loadStateInit = void 0;
  const Dictionary_1 = requireDictionary();
  const SimpleLibrary_1 = requireSimpleLibrary();
  const TickTock_1 = requireTickTock();
  function loadStateInit(slice) {
    let splitDepth;
    if (slice.loadBit()) {
      splitDepth = slice.loadUint(5);
    }
    let special;
    if (slice.loadBit()) {
      special = (0, TickTock_1.loadTickTock)(slice);
    }
    let code = slice.loadMaybeRef();
    let data = slice.loadMaybeRef();
    let libraries = slice.loadDict(Dictionary_1.Dictionary.Keys.BigUint(256), SimpleLibrary_1.SimpleLibraryValue);
    if (libraries.size === 0) {
      libraries = void 0;
    }
    return {
      splitDepth,
      special,
      code,
      data,
      libraries
    };
  }
  StateInit.loadStateInit = loadStateInit;
  function storeStateInit(src2) {
    return (builder2) => {
      if (src2.splitDepth !== null && src2.splitDepth !== void 0) {
        builder2.storeBit(true);
        builder2.storeUint(src2.splitDepth, 5);
      } else {
        builder2.storeBit(false);
      }
      if (src2.special !== null && src2.special !== void 0) {
        builder2.storeBit(true);
        builder2.store((0, TickTock_1.storeTickTock)(src2.special));
      } else {
        builder2.storeBit(false);
      }
      builder2.storeMaybeRef(src2.code);
      builder2.storeMaybeRef(src2.data);
      builder2.storeDict(src2.libraries);
    };
  }
  StateInit.storeStateInit = storeStateInit;
  return StateInit;
}
var hasRequiredContractAddress;
function requireContractAddress() {
  if (hasRequiredContractAddress) return contractAddress;
  hasRequiredContractAddress = 1;
  Object.defineProperty(contractAddress, "__esModule", { value: true });
  contractAddress.contractAddress = void 0;
  const Builder_12 = requireBuilder$1();
  const StateInit_1 = requireStateInit();
  const Address_1 = requireAddress();
  function contractAddress$12(workchain, init) {
    let hash = (0, Builder_12.beginCell)().store((0, StateInit_1.storeStateInit)(init)).endCell().hash();
    return new Address_1.Address(workchain, hash);
  }
  contractAddress.contractAddress = contractAddress$12;
  return contractAddress;
}
var tuple = {};
var hasRequiredTuple;
function requireTuple() {
  if (hasRequiredTuple) return tuple;
  hasRequiredTuple = 1;
  Object.defineProperty(tuple, "__esModule", { value: true });
  tuple.parseTuple = tuple.serializeTuple = void 0;
  const Builder_12 = requireBuilder$1();
  const INT64_MIN = BigInt("-9223372036854775808");
  const INT64_MAX = BigInt("9223372036854775807");
  function serializeTupleItem(src2, builder2) {
    if (src2.type === "null") {
      builder2.storeUint(0, 8);
    } else if (src2.type === "int") {
      if (src2.value <= INT64_MAX && src2.value >= INT64_MIN) {
        builder2.storeUint(1, 8);
        builder2.storeInt(src2.value, 64);
      } else {
        builder2.storeUint(256, 15);
        builder2.storeInt(src2.value, 257);
      }
    } else if (src2.type === "nan") {
      builder2.storeInt(767, 16);
    } else if (src2.type === "cell") {
      builder2.storeUint(3, 8);
      builder2.storeRef(src2.cell);
    } else if (src2.type === "slice") {
      builder2.storeUint(4, 8);
      builder2.storeUint(0, 10);
      builder2.storeUint(src2.cell.bits.length, 10);
      builder2.storeUint(0, 3);
      builder2.storeUint(src2.cell.refs.length, 3);
      builder2.storeRef(src2.cell);
    } else if (src2.type === "builder") {
      builder2.storeUint(5, 8);
      builder2.storeRef(src2.cell);
    } else if (src2.type === "tuple") {
      let head = null;
      let tail = null;
      for (let i = 0; i < src2.items.length; i++) {
        let s = head;
        head = tail;
        tail = s;
        if (i > 1) {
          head = (0, Builder_12.beginCell)().storeRef(tail).storeRef(head).endCell();
        }
        let bc = (0, Builder_12.beginCell)();
        serializeTupleItem(src2.items[i], bc);
        tail = bc.endCell();
      }
      builder2.storeUint(7, 8);
      builder2.storeUint(src2.items.length, 16);
      if (head) {
        builder2.storeRef(head);
      }
      if (tail) {
        builder2.storeRef(tail);
      }
    } else {
      throw Error("Invalid value");
    }
  }
  function parseStackItem(cs) {
    let kind = cs.loadUint(8);
    if (kind === 0) {
      return { type: "null" };
    } else if (kind === 1) {
      return { type: "int", value: cs.loadIntBig(64) };
    } else if (kind === 2) {
      if (cs.loadUint(7) === 0) {
        return { type: "int", value: cs.loadIntBig(257) };
      } else {
        cs.loadBit();
        return { type: "nan" };
      }
    } else if (kind === 3) {
      return { type: "cell", cell: cs.loadRef() };
    } else if (kind === 4) {
      let startBits = cs.loadUint(10);
      let endBits = cs.loadUint(10);
      let startRefs = cs.loadUint(3);
      let endRefs = cs.loadUint(3);
      let rs = cs.loadRef().beginParse();
      rs.skip(startBits);
      let dt2 = rs.loadBits(endBits - startBits);
      let builder2 = (0, Builder_12.beginCell)().storeBits(dt2);
      if (startRefs < endRefs) {
        for (let i = 0; i < startRefs; i++) {
          rs.loadRef();
        }
        for (let i = 0; i < endRefs - startRefs; i++) {
          builder2.storeRef(rs.loadRef());
        }
      }
      return { type: "slice", cell: builder2.endCell() };
    } else if (kind === 5) {
      return { type: "builder", cell: cs.loadRef() };
    } else if (kind === 7) {
      let length = cs.loadUint(16);
      let items = [];
      if (length > 1) {
        let head = cs.loadRef().beginParse();
        let tail = cs.loadRef().beginParse();
        items.unshift(parseStackItem(tail));
        for (let i = 0; i < length - 2; i++) {
          let ohead = head;
          head = ohead.loadRef().beginParse();
          tail = ohead.loadRef().beginParse();
          items.unshift(parseStackItem(tail));
        }
        items.unshift(parseStackItem(head));
      } else if (length === 1) {
        items.push(parseStackItem(cs.loadRef().beginParse()));
      }
      return { type: "tuple", items };
    } else {
      throw Error("Unsupported stack item");
    }
  }
  function serializeTupleTail(src2, builder2) {
    if (src2.length > 0) {
      let tail = (0, Builder_12.beginCell)();
      serializeTupleTail(src2.slice(0, src2.length - 1), tail);
      builder2.storeRef(tail.endCell());
      serializeTupleItem(src2[src2.length - 1], builder2);
    }
  }
  function serializeTuple(src2) {
    let builder2 = (0, Builder_12.beginCell)();
    builder2.storeUint(src2.length, 24);
    let r = [...src2];
    serializeTupleTail(r, builder2);
    return builder2.endCell();
  }
  tuple.serializeTuple = serializeTuple;
  function parseTuple(src2) {
    let res = [];
    let cs = src2.beginParse();
    let size = cs.loadUint(24);
    for (let i = 0; i < size; i++) {
      let next = cs.loadRef();
      res.unshift(parseStackItem(cs));
      cs = next.beginParse();
    }
    return res;
  }
  tuple.parseTuple = parseTuple;
  return tuple;
}
var reader = {};
var hasRequiredReader;
function requireReader() {
  if (hasRequiredReader) return reader;
  hasRequiredReader = 1;
  Object.defineProperty(reader, "__esModule", { value: true });
  reader.TupleReader = void 0;
  class TupleReader {
    constructor(items) {
      this.items = [...items];
    }
    get remaining() {
      return this.items.length;
    }
    peek() {
      if (this.items.length === 0) {
        throw Error("EOF");
      }
      return this.items[0];
    }
    pop() {
      if (this.items.length === 0) {
        throw Error("EOF");
      }
      let res = this.items[0];
      this.items.splice(0, 1);
      return res;
    }
    skip(num = 1) {
      for (let i = 0; i < num; i++) {
        this.pop();
      }
      return this;
    }
    readBigNumber() {
      let popped = this.pop();
      if (popped.type !== "int") {
        throw Error("Not a number");
      }
      return popped.value;
    }
    readBigNumberOpt() {
      let popped = this.pop();
      if (popped.type === "null") {
        return null;
      }
      if (popped.type !== "int") {
        throw Error("Not a number");
      }
      return popped.value;
    }
    readNumber() {
      return Number(this.readBigNumber());
    }
    readNumberOpt() {
      let r = this.readBigNumberOpt();
      if (r !== null) {
        return Number(r);
      } else {
        return null;
      }
    }
    readBoolean() {
      let res = this.readNumber();
      return res === 0 ? false : true;
    }
    readBooleanOpt() {
      let res = this.readNumberOpt();
      if (res !== null) {
        return res === 0 ? false : true;
      } else {
        return null;
      }
    }
    readAddress() {
      let r = this.readCell().beginParse().loadAddress();
      if (r !== null) {
        return r;
      } else {
        throw Error("Not an address");
      }
    }
    readAddressOpt() {
      let r = this.readCellOpt();
      if (r !== null) {
        return r.beginParse().loadMaybeAddress();
      } else {
        return null;
      }
    }
    readCell() {
      let popped = this.pop();
      if (popped.type !== "cell" && popped.type !== "slice" && popped.type !== "builder") {
        throw Error("Not a cell: " + popped.type);
      }
      return popped.cell;
    }
    readCellOpt() {
      let popped = this.pop();
      if (popped.type === "null") {
        return null;
      }
      if (popped.type !== "cell" && popped.type !== "slice" && popped.type !== "builder") {
        throw Error("Not a cell");
      }
      return popped.cell;
    }
    readTuple() {
      let popped = this.pop();
      if (popped.type !== "tuple") {
        throw Error("Not a tuple");
      }
      return new TupleReader(popped.items);
    }
    readTupleOpt() {
      let popped = this.pop();
      if (popped.type === "null") {
        return null;
      }
      if (popped.type !== "tuple") {
        throw Error("Not a tuple");
      }
      return new TupleReader(popped.items);
    }
    static readLispList(reader2) {
      const result = [];
      let tail = reader2;
      while (tail !== null) {
        var head = tail.pop();
        if (tail.items.length === 0 || tail.items[0].type !== "tuple" && tail.items[0].type !== "null") {
          throw Error("Lisp list consists only from (any, tuple) elements and ends with null");
        }
        tail = tail.readTupleOpt();
        result.push(head);
      }
      return result;
    }
    readLispListDirect() {
      if (this.items.length === 1 && this.items[0].type === "null") {
        return [];
      }
      return TupleReader.readLispList(this);
    }
    readLispList() {
      return TupleReader.readLispList(this.readTupleOpt());
    }
    readBuffer() {
      let s = this.readCell().beginParse();
      if (s.remainingRefs !== 0) {
        throw Error("Not a buffer");
      }
      if (s.remainingBits % 8 !== 0) {
        throw Error("Not a buffer");
      }
      return s.loadBuffer(s.remainingBits / 8);
    }
    readBufferOpt() {
      let r = this.readCellOpt();
      if (r !== null) {
        let s = r.beginParse();
        if (s.remainingRefs !== 0 || s.remainingBits % 8 !== 0) {
          throw Error("Not a buffer");
        }
        return s.loadBuffer(s.remainingBits / 8);
      } else {
        return null;
      }
    }
    readString() {
      let s = this.readCell().beginParse();
      return s.loadStringTail();
    }
    readStringOpt() {
      let r = this.readCellOpt();
      if (r !== null) {
        let s = r.beginParse();
        return s.loadStringTail();
      } else {
        return null;
      }
    }
  }
  reader.TupleReader = TupleReader;
  return reader;
}
var builder = {};
var hasRequiredBuilder;
function requireBuilder() {
  if (hasRequiredBuilder) return builder;
  hasRequiredBuilder = 1;
  Object.defineProperty(builder, "__esModule", { value: true });
  builder.TupleBuilder = void 0;
  const Builder_12 = requireBuilder$1();
  const Cell_1 = requireCell();
  const Slice_1 = requireSlice();
  class TupleBuilder {
    constructor() {
      this._tuple = [];
    }
    writeNumber(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        this._tuple.push({ type: "int", value: BigInt(v2) });
      }
    }
    writeBoolean(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        this._tuple.push({ type: "int", value: v2 ? -1n : 0n });
      }
    }
    writeBuffer(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        this._tuple.push({ type: "slice", cell: (0, Builder_12.beginCell)().storeBuffer(v2).endCell() });
      }
    }
    writeString(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        this._tuple.push({ type: "slice", cell: (0, Builder_12.beginCell)().storeStringTail(v2).endCell() });
      }
    }
    writeCell(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        if (v2 instanceof Cell_1.Cell) {
          this._tuple.push({ type: "cell", cell: v2 });
        } else if (v2 instanceof Slice_1.Slice) {
          this._tuple.push({ type: "cell", cell: v2.asCell() });
        }
      }
    }
    writeSlice(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        if (v2 instanceof Cell_1.Cell) {
          this._tuple.push({ type: "slice", cell: v2 });
        } else if (v2 instanceof Slice_1.Slice) {
          this._tuple.push({ type: "slice", cell: v2.asCell() });
        }
      }
    }
    writeBuilder(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        if (v2 instanceof Cell_1.Cell) {
          this._tuple.push({ type: "builder", cell: v2 });
        } else if (v2 instanceof Slice_1.Slice) {
          this._tuple.push({ type: "builder", cell: v2.asCell() });
        }
      }
    }
    writeTuple(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        this._tuple.push({ type: "tuple", items: v2 });
      }
    }
    writeAddress(v2) {
      if (v2 === null || v2 === void 0) {
        this._tuple.push({ type: "null" });
      } else {
        this._tuple.push({ type: "slice", cell: (0, Builder_12.beginCell)().storeAddress(v2).endCell() });
      }
    }
    build() {
      return [...this._tuple];
    }
  }
  builder.TupleBuilder = TupleBuilder;
  return builder;
}
var _export = {};
var _helpers = {};
var convert = {};
var hasRequiredConvert;
function requireConvert() {
  if (hasRequiredConvert) return convert;
  hasRequiredConvert = 1;
  Object.defineProperty(convert, "__esModule", { value: true });
  convert.fromNano = convert.toNano = void 0;
  function toNano(src2) {
    if (typeof src2 === "bigint") {
      return src2 * 1000000000n;
    } else {
      if (typeof src2 === "number") {
        if (!Number.isFinite(src2)) {
          throw Error("Invalid number");
        }
        if (Math.log10(src2) <= 6) {
          src2 = src2.toLocaleString("en", { minimumFractionDigits: 9, useGrouping: false });
        } else if (src2 - Math.trunc(src2) === 0) {
          src2 = src2.toLocaleString("en", { maximumFractionDigits: 0, useGrouping: false });
        } else {
          throw Error("Not enough precision for a number value. Use string value instead");
        }
      }
      let neg = false;
      while (src2.startsWith("-")) {
        neg = !neg;
        src2 = src2.slice(1);
      }
      if (src2 === ".") {
        throw Error("Invalid number");
      }
      let parts = src2.split(".");
      if (parts.length > 2) {
        throw Error("Invalid number");
      }
      let whole = parts[0];
      let frac = parts[1];
      if (!whole) {
        whole = "0";
      }
      if (!frac) {
        frac = "0";
      }
      if (frac.length > 9) {
        throw Error("Invalid number");
      }
      while (frac.length < 9) {
        frac += "0";
      }
      let r = BigInt(whole) * 1000000000n + BigInt(frac);
      if (neg) {
        r = -r;
      }
      return r;
    }
  }
  convert.toNano = toNano;
  function fromNano(src2) {
    let v2 = BigInt(src2);
    let neg = false;
    if (v2 < 0) {
      neg = true;
      v2 = -v2;
    }
    let frac = v2 % 1000000000n;
    let facStr = frac.toString();
    while (facStr.length < 9) {
      facStr = "0" + facStr;
    }
    facStr = facStr.match(/^([0-9]*[1-9]|0)(0*)/)[1];
    let whole = v2 / 1000000000n;
    let wholeStr = whole.toString();
    let value = `${wholeStr}${facStr === "0" ? "" : `.${facStr}`}`;
    if (neg) {
      value = "-" + value;
    }
    return value;
  }
  convert.fromNano = fromNano;
  return convert;
}
var ExtraCurrency = {};
var hasRequiredExtraCurrency;
function requireExtraCurrency() {
  if (hasRequiredExtraCurrency) return ExtraCurrency;
  hasRequiredExtraCurrency = 1;
  Object.defineProperty(ExtraCurrency, "__esModule", { value: true });
  ExtraCurrency.packExtraCurrencyCell = ExtraCurrency.packExtraCurrencyDict = ExtraCurrency.storeExtraCurrency = ExtraCurrency.loadMaybeExtraCurrency = ExtraCurrency.loadExtraCurrency = void 0;
  const Builder_12 = requireBuilder$1();
  const Dictionary_1 = requireDictionary();
  function loadExtraCurrency(data) {
    let ecDict = data instanceof Dictionary_1.Dictionary ? data : Dictionary_1.Dictionary.loadDirect(Dictionary_1.Dictionary.Keys.Uint(32), Dictionary_1.Dictionary.Values.BigVarUint(5), data);
    let ecMap = {};
    for (let [k, v2] of ecDict) {
      ecMap[k] = v2;
    }
    return ecMap;
  }
  ExtraCurrency.loadExtraCurrency = loadExtraCurrency;
  function loadMaybeExtraCurrency(data) {
    const ecData = data.loadMaybeRef();
    return ecData === null ? ecData : loadExtraCurrency(ecData);
  }
  ExtraCurrency.loadMaybeExtraCurrency = loadMaybeExtraCurrency;
  function storeExtraCurrency(extracurrency) {
    return (builder2) => {
      builder2.storeDict(packExtraCurrencyDict(extracurrency));
    };
  }
  ExtraCurrency.storeExtraCurrency = storeExtraCurrency;
  function packExtraCurrencyDict(extracurrency) {
    const resEc = Dictionary_1.Dictionary.empty(Dictionary_1.Dictionary.Keys.Uint(32), Dictionary_1.Dictionary.Values.BigVarUint(5));
    Object.entries(extracurrency).map(([k, v2]) => resEc.set(Number(k), v2));
    return resEc;
  }
  ExtraCurrency.packExtraCurrencyDict = packExtraCurrencyDict;
  function packExtraCurrencyCell(extracurrency) {
    return (0, Builder_12.beginCell)().storeDictDirect(packExtraCurrencyDict(extracurrency)).endCell();
  }
  ExtraCurrency.packExtraCurrencyCell = packExtraCurrencyCell;
  return ExtraCurrency;
}
var hasRequired_helpers;
function require_helpers() {
  if (hasRequired_helpers) return _helpers;
  hasRequired_helpers = 1;
  Object.defineProperty(_helpers, "__esModule", { value: true });
  _helpers.comment = _helpers.external = _helpers.internal = void 0;
  const Address_1 = requireAddress();
  const Cell_1 = requireCell();
  const Builder_12 = requireBuilder$1();
  const convert_1 = requireConvert();
  const ExtraCurrency_1 = requireExtraCurrency();
  function internal(src2) {
    let bounce = true;
    if (src2.bounce !== null && src2.bounce !== void 0) {
      bounce = src2.bounce;
    }
    let to;
    if (typeof src2.to === "string") {
      to = Address_1.Address.parse(src2.to);
    } else if (Address_1.Address.isAddress(src2.to)) {
      to = src2.to;
    } else {
      throw new Error(`Invalid address ${src2.to}`);
    }
    let value;
    if (typeof src2.value === "string") {
      value = (0, convert_1.toNano)(src2.value);
    } else {
      value = src2.value;
    }
    let other;
    if (src2.extracurrency) {
      other = (0, ExtraCurrency_1.packExtraCurrencyDict)(src2.extracurrency);
    }
    let body = Cell_1.Cell.EMPTY;
    if (typeof src2.body === "string") {
      body = (0, Builder_12.beginCell)().storeUint(0, 32).storeStringTail(src2.body).endCell();
    } else if (src2.body) {
      body = src2.body;
    }
    return {
      info: {
        type: "internal",
        dest: to,
        value: { coins: value, other },
        bounce,
        ihrDisabled: true,
        bounced: false,
        ihrFee: 0n,
        forwardFee: 0n,
        createdAt: 0,
        createdLt: 0n
      },
      init: src2.init ?? void 0,
      body
    };
  }
  _helpers.internal = internal;
  function external2(src2) {
    let to;
    if (typeof src2.to === "string") {
      to = Address_1.Address.parse(src2.to);
    } else if (Address_1.Address.isAddress(src2.to)) {
      to = src2.to;
    } else {
      throw new Error(`Invalid address ${src2.to}`);
    }
    return {
      info: {
        type: "external-in",
        dest: to,
        importFee: 0n
      },
      init: src2.init ?? void 0,
      body: src2.body || Cell_1.Cell.EMPTY
    };
  }
  _helpers.external = external2;
  function comment(src2) {
    return (0, Builder_12.beginCell)().storeUint(0, 32).storeStringTail(src2).endCell();
  }
  _helpers.comment = comment;
  return _helpers;
}
var Account = {};
var AccountStorage = {};
var AccountState = {};
var hasRequiredAccountState;
function requireAccountState() {
  if (hasRequiredAccountState) return AccountState;
  hasRequiredAccountState = 1;
  Object.defineProperty(AccountState, "__esModule", { value: true });
  AccountState.storeAccountState = AccountState.loadAccountState = void 0;
  const StateInit_1 = requireStateInit();
  function loadAccountState(cs) {
    if (cs.loadBit()) {
      return { type: "active", state: (0, StateInit_1.loadStateInit)(cs) };
    } else if (cs.loadBit()) {
      return { type: "frozen", stateHash: cs.loadUintBig(256) };
    } else {
      return { type: "uninit" };
    }
  }
  AccountState.loadAccountState = loadAccountState;
  function storeAccountState(src2) {
    return (builder2) => {
      if (src2.type === "active") {
        builder2.storeBit(true);
        builder2.store((0, StateInit_1.storeStateInit)(src2.state));
      } else if (src2.type === "frozen") {
        builder2.storeBit(false);
        builder2.storeBit(true);
        builder2.storeUint(src2.stateHash, 256);
      } else if (src2.type === "uninit") {
        builder2.storeBit(false);
        builder2.storeBit(false);
      }
    };
  }
  AccountState.storeAccountState = storeAccountState;
  return AccountState;
}
var CurrencyCollection = {};
var hasRequiredCurrencyCollection;
function requireCurrencyCollection() {
  if (hasRequiredCurrencyCollection) return CurrencyCollection;
  hasRequiredCurrencyCollection = 1;
  Object.defineProperty(CurrencyCollection, "__esModule", { value: true });
  CurrencyCollection.storeCurrencyCollection = CurrencyCollection.loadCurrencyCollection = void 0;
  const Dictionary_1 = requireDictionary();
  function loadCurrencyCollection(slice) {
    const coins = slice.loadCoins();
    const other = slice.loadDict(Dictionary_1.Dictionary.Keys.Uint(32), Dictionary_1.Dictionary.Values.BigVarUint(
      5
      /* log2(32) */
    ));
    if (other.size === 0) {
      return { coins };
    } else {
      return { other, coins };
    }
  }
  CurrencyCollection.loadCurrencyCollection = loadCurrencyCollection;
  function storeCurrencyCollection(collection) {
    return (builder2) => {
      builder2.storeCoins(collection.coins);
      if (collection.other) {
        builder2.storeDict(collection.other);
      } else {
        builder2.storeBit(0);
      }
    };
  }
  CurrencyCollection.storeCurrencyCollection = storeCurrencyCollection;
  return CurrencyCollection;
}
var hasRequiredAccountStorage;
function requireAccountStorage() {
  if (hasRequiredAccountStorage) return AccountStorage;
  hasRequiredAccountStorage = 1;
  Object.defineProperty(AccountStorage, "__esModule", { value: true });
  AccountStorage.storeAccountStorage = AccountStorage.loadAccountStorage = void 0;
  const AccountState_1 = requireAccountState();
  const CurrencyCollection_1 = requireCurrencyCollection();
  function loadAccountStorage(slice) {
    return {
      lastTransLt: slice.loadUintBig(64),
      balance: (0, CurrencyCollection_1.loadCurrencyCollection)(slice),
      state: (0, AccountState_1.loadAccountState)(slice)
    };
  }
  AccountStorage.loadAccountStorage = loadAccountStorage;
  function storeAccountStorage(src2) {
    return (builder2) => {
      builder2.storeUint(src2.lastTransLt, 64);
      builder2.store((0, CurrencyCollection_1.storeCurrencyCollection)(src2.balance));
      builder2.store((0, AccountState_1.storeAccountState)(src2.state));
    };
  }
  AccountStorage.storeAccountStorage = storeAccountStorage;
  return AccountStorage;
}
var StorageInfo = {};
var StorageExtraInfo = {};
var hasRequiredStorageExtraInfo;
function requireStorageExtraInfo() {
  if (hasRequiredStorageExtraInfo) return StorageExtraInfo;
  hasRequiredStorageExtraInfo = 1;
  Object.defineProperty(StorageExtraInfo, "__esModule", { value: true });
  StorageExtraInfo.storeStorageExtraInfo = StorageExtraInfo.loadStorageExtraInfo = void 0;
  function loadStorageExtraInfo(slice) {
    let header = slice.loadUint(3);
    if (header === 0) {
      return null;
    }
    if (header === 1) {
      return {
        dictHash: slice.loadUintBig(256)
      };
    }
    throw new Error(`Invalid storage extra info header: ${header}`);
  }
  StorageExtraInfo.loadStorageExtraInfo = loadStorageExtraInfo;
  function storeStorageExtraInfo(src2) {
    return (builder2) => {
      if (src2 === null) {
        builder2.storeUint(0, 3);
      } else {
        builder2.storeUint(1, 3);
        builder2.storeUint(src2.dictHash, 256);
      }
    };
  }
  StorageExtraInfo.storeStorageExtraInfo = storeStorageExtraInfo;
  return StorageExtraInfo;
}
var StorageUsed = {};
var hasRequiredStorageUsed;
function requireStorageUsed() {
  if (hasRequiredStorageUsed) return StorageUsed;
  hasRequiredStorageUsed = 1;
  Object.defineProperty(StorageUsed, "__esModule", { value: true });
  StorageUsed.storeStorageUsed = StorageUsed.loadStorageUsed = void 0;
  function loadStorageUsed(cs) {
    return {
      cells: cs.loadVarUintBig(3),
      bits: cs.loadVarUintBig(3)
    };
  }
  StorageUsed.loadStorageUsed = loadStorageUsed;
  function storeStorageUsed(src2) {
    return (builder2) => {
      builder2.storeVarUint(src2.cells, 3);
      builder2.storeVarUint(src2.bits, 3);
    };
  }
  StorageUsed.storeStorageUsed = storeStorageUsed;
  return StorageUsed;
}
var hasRequiredStorageInfo;
function requireStorageInfo() {
  if (hasRequiredStorageInfo) return StorageInfo;
  hasRequiredStorageInfo = 1;
  Object.defineProperty(StorageInfo, "__esModule", { value: true });
  StorageInfo.storeStorageInfo = StorageInfo.loadStorageInfo = void 0;
  const StorageExtraInfo_1 = requireStorageExtraInfo();
  const StorageUsed_1 = requireStorageUsed();
  function loadStorageInfo(slice) {
    return {
      used: (0, StorageUsed_1.loadStorageUsed)(slice),
      storageExtra: (0, StorageExtraInfo_1.loadStorageExtraInfo)(slice),
      lastPaid: slice.loadUint(32),
      duePayment: slice.loadMaybeCoins()
    };
  }
  StorageInfo.loadStorageInfo = loadStorageInfo;
  function storeStorageInfo(src2) {
    return (builder2) => {
      builder2.store((0, StorageUsed_1.storeStorageUsed)(src2.used));
      builder2.store((0, StorageExtraInfo_1.storeStorageExtraInfo)(src2.storageExtra));
      builder2.storeUint(src2.lastPaid, 32);
      builder2.storeMaybeCoins(src2.duePayment);
    };
  }
  StorageInfo.storeStorageInfo = storeStorageInfo;
  return StorageInfo;
}
var hasRequiredAccount;
function requireAccount() {
  if (hasRequiredAccount) return Account;
  hasRequiredAccount = 1;
  Object.defineProperty(Account, "__esModule", { value: true });
  Account.storeAccount = Account.loadAccount = void 0;
  const AccountStorage_1 = requireAccountStorage();
  const StorageInfo_1 = requireStorageInfo();
  function loadAccount(slice) {
    return {
      addr: slice.loadAddress(),
      storageStats: (0, StorageInfo_1.loadStorageInfo)(slice),
      storage: (0, AccountStorage_1.loadAccountStorage)(slice)
    };
  }
  Account.loadAccount = loadAccount;
  function storeAccount(src2) {
    return (builder2) => {
      builder2.storeAddress(src2.addr);
      builder2.store((0, StorageInfo_1.storeStorageInfo)(src2.storageStats));
      builder2.store((0, AccountStorage_1.storeAccountStorage)(src2.storage));
    };
  }
  Account.storeAccount = storeAccount;
  return Account;
}
var AccountStatus = {};
var hasRequiredAccountStatus;
function requireAccountStatus() {
  if (hasRequiredAccountStatus) return AccountStatus;
  hasRequiredAccountStatus = 1;
  Object.defineProperty(AccountStatus, "__esModule", { value: true });
  AccountStatus.storeAccountStatus = AccountStatus.loadAccountStatus = void 0;
  function loadAccountStatus(slice) {
    const status = slice.loadUint(2);
    if (status === 0) {
      return "uninitialized";
    }
    if (status === 1) {
      return "frozen";
    }
    if (status === 2) {
      return "active";
    }
    if (status === 3) {
      return "non-existing";
    }
    throw Error("Invalid data");
  }
  AccountStatus.loadAccountStatus = loadAccountStatus;
  function storeAccountStatus(src2) {
    return (builder2) => {
      if (src2 === "uninitialized") {
        builder2.storeUint(0, 2);
      } else if (src2 === "frozen") {
        builder2.storeUint(1, 2);
      } else if (src2 === "active") {
        builder2.storeUint(2, 2);
      } else if (src2 === "non-existing") {
        builder2.storeUint(3, 2);
      } else {
        throw Error("Invalid data");
      }
      return builder2;
    };
  }
  AccountStatus.storeAccountStatus = storeAccountStatus;
  return AccountStatus;
}
var AccountStatusChange = {};
var hasRequiredAccountStatusChange;
function requireAccountStatusChange() {
  if (hasRequiredAccountStatusChange) return AccountStatusChange;
  hasRequiredAccountStatusChange = 1;
  Object.defineProperty(AccountStatusChange, "__esModule", { value: true });
  AccountStatusChange.storeAccountStatusChange = AccountStatusChange.loadAccountStatusChange = void 0;
  function loadAccountStatusChange(slice) {
    if (!slice.loadBit()) {
      return "unchanged";
    }
    if (slice.loadBit()) {
      return "deleted";
    } else {
      return "frozen";
    }
  }
  AccountStatusChange.loadAccountStatusChange = loadAccountStatusChange;
  function storeAccountStatusChange(src2) {
    return (builder2) => {
      if (src2 == "unchanged") {
        builder2.storeBit(0);
      } else if (src2 === "frozen") {
        builder2.storeBit(1);
        builder2.storeBit(0);
      } else if (src2 === "deleted") {
        builder2.storeBit(1);
        builder2.storeBit(1);
      } else {
        throw Error("Invalid account status change");
      }
    };
  }
  AccountStatusChange.storeAccountStatusChange = storeAccountStatusChange;
  return AccountStatusChange;
}
var OutList = {};
var MessageRelaxed = {};
var CommonMessageInfoRelaxed = {};
var hasRequiredCommonMessageInfoRelaxed;
function requireCommonMessageInfoRelaxed() {
  if (hasRequiredCommonMessageInfoRelaxed) return CommonMessageInfoRelaxed;
  hasRequiredCommonMessageInfoRelaxed = 1;
  Object.defineProperty(CommonMessageInfoRelaxed, "__esModule", { value: true });
  CommonMessageInfoRelaxed.storeCommonMessageInfoRelaxed = CommonMessageInfoRelaxed.loadCommonMessageInfoRelaxed = void 0;
  const CurrencyCollection_1 = requireCurrencyCollection();
  function loadCommonMessageInfoRelaxed(slice) {
    if (!slice.loadBit()) {
      const ihrDisabled = slice.loadBit();
      const bounce = slice.loadBit();
      const bounced = slice.loadBit();
      const src3 = slice.loadMaybeAddress();
      const dest2 = slice.loadAddress();
      const value = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
      const ihrFee = slice.loadCoins();
      const forwardFee = slice.loadCoins();
      const createdLt2 = slice.loadUintBig(64);
      const createdAt2 = slice.loadUint(32);
      return {
        type: "internal",
        ihrDisabled,
        bounce,
        bounced,
        src: src3,
        dest: dest2,
        value,
        ihrFee,
        forwardFee,
        createdLt: createdLt2,
        createdAt: createdAt2
      };
    }
    if (!slice.loadBit()) {
      throw Error("External In message is not possible for CommonMessageInfoRelaxed");
    }
    const src2 = slice.loadMaybeAddress();
    const dest = slice.loadMaybeExternalAddress();
    const createdLt = slice.loadUintBig(64);
    const createdAt = slice.loadUint(32);
    return {
      type: "external-out",
      src: src2,
      dest,
      createdLt,
      createdAt
    };
  }
  CommonMessageInfoRelaxed.loadCommonMessageInfoRelaxed = loadCommonMessageInfoRelaxed;
  function storeCommonMessageInfoRelaxed(source) {
    return (builder2) => {
      if (source.type === "internal") {
        builder2.storeBit(0);
        builder2.storeBit(source.ihrDisabled);
        builder2.storeBit(source.bounce);
        builder2.storeBit(source.bounced);
        builder2.storeAddress(source.src);
        builder2.storeAddress(source.dest);
        builder2.store((0, CurrencyCollection_1.storeCurrencyCollection)(source.value));
        builder2.storeCoins(source.ihrFee);
        builder2.storeCoins(source.forwardFee);
        builder2.storeUint(source.createdLt, 64);
        builder2.storeUint(source.createdAt, 32);
      } else if (source.type === "external-out") {
        builder2.storeBit(1);
        builder2.storeBit(1);
        builder2.storeAddress(source.src);
        builder2.storeAddress(source.dest);
        builder2.storeUint(source.createdLt, 64);
        builder2.storeUint(source.createdAt, 32);
      } else {
        throw new Error("Unknown CommonMessageInfo type");
      }
    };
  }
  CommonMessageInfoRelaxed.storeCommonMessageInfoRelaxed = storeCommonMessageInfoRelaxed;
  return CommonMessageInfoRelaxed;
}
var hasRequiredMessageRelaxed;
function requireMessageRelaxed() {
  if (hasRequiredMessageRelaxed) return MessageRelaxed;
  hasRequiredMessageRelaxed = 1;
  Object.defineProperty(MessageRelaxed, "__esModule", { value: true });
  MessageRelaxed.storeMessageRelaxed = MessageRelaxed.loadMessageRelaxed = void 0;
  const Builder_12 = requireBuilder$1();
  const CommonMessageInfoRelaxed_1 = requireCommonMessageInfoRelaxed();
  const StateInit_1 = requireStateInit();
  function loadMessageRelaxed(slice) {
    const info = (0, CommonMessageInfoRelaxed_1.loadCommonMessageInfoRelaxed)(slice);
    let init = null;
    if (slice.loadBit()) {
      if (!slice.loadBit()) {
        init = (0, StateInit_1.loadStateInit)(slice);
      } else {
        init = (0, StateInit_1.loadStateInit)(slice.loadRef().beginParse());
      }
    }
    const body = slice.loadBit() ? slice.loadRef() : slice.asCell();
    return {
      info,
      init,
      body
    };
  }
  MessageRelaxed.loadMessageRelaxed = loadMessageRelaxed;
  function storeMessageRelaxed(message, opts) {
    return (builder2) => {
      builder2.store((0, CommonMessageInfoRelaxed_1.storeCommonMessageInfoRelaxed)(message.info));
      if (message.init) {
        builder2.storeBit(true);
        let initCell = (0, Builder_12.beginCell)().store((0, StateInit_1.storeStateInit)(message.init));
        let needRef2 = false;
        if (opts && opts.forceRef) {
          needRef2 = true;
        } else {
          if (builder2.availableBits - 2 >= initCell.bits) {
            needRef2 = false;
          } else {
            needRef2 = true;
          }
        }
        if (needRef2) {
          builder2.storeBit(true);
          builder2.storeRef(initCell);
        } else {
          builder2.storeBit(false);
          builder2.storeBuilder(initCell);
        }
      } else {
        builder2.storeBit(false);
      }
      let needRef = false;
      if (opts && opts.forceRef) {
        needRef = true;
      } else {
        if (builder2.availableBits - 1 >= message.body.bits.length && builder2.refs + message.body.refs.length <= 4 && !message.body.isExotic) {
          needRef = false;
        } else {
          needRef = true;
        }
      }
      if (needRef) {
        builder2.storeBit(true);
        builder2.storeRef(message.body);
      } else {
        builder2.storeBit(false);
        builder2.storeBuilder(message.body.asBuilder());
      }
    };
  }
  MessageRelaxed.storeMessageRelaxed = storeMessageRelaxed;
  return MessageRelaxed;
}
var LibRef = {};
var hasRequiredLibRef;
function requireLibRef() {
  if (hasRequiredLibRef) return LibRef;
  hasRequiredLibRef = 1;
  Object.defineProperty(LibRef, "__esModule", { value: true });
  LibRef.storeLibRef = LibRef.loadLibRef = void 0;
  function loadLibRef(slice) {
    const type = slice.loadUint(1);
    if (type === 0) {
      return {
        type: "hash",
        libHash: slice.loadBuffer(32)
      };
    } else {
      return {
        type: "ref",
        library: slice.loadRef()
      };
    }
  }
  LibRef.loadLibRef = loadLibRef;
  function storeLibRef(src2) {
    return (builder2) => {
      if (src2.type === "hash") {
        builder2.storeUint(0, 1);
        builder2.storeBuffer(src2.libHash);
      } else {
        builder2.storeUint(1, 1);
        builder2.storeRef(src2.library);
      }
    };
  }
  LibRef.storeLibRef = storeLibRef;
  return LibRef;
}
var hasRequiredOutList;
function requireOutList() {
  if (hasRequiredOutList) return OutList;
  hasRequiredOutList = 1;
  Object.defineProperty(OutList, "__esModule", { value: true });
  OutList.loadOutList = OutList.storeOutList = OutList.loadOutAction = OutList.storeOutAction = void 0;
  const MessageRelaxed_1 = requireMessageRelaxed();
  const Builder_12 = requireBuilder$1();
  const CurrencyCollection_1 = requireCurrencyCollection();
  const LibRef_1 = requireLibRef();
  function storeOutAction(action) {
    switch (action.type) {
      case "sendMsg":
        return storeOutActionSendMsg(action);
      case "setCode":
        return storeOutActionSetCode(action);
      case "reserve":
        return storeOutActionReserve(action);
      case "changeLibrary":
        return storeOutActionChangeLibrary(action);
      default:
        throw new Error(`Unknown action type ${action.type}`);
    }
  }
  OutList.storeOutAction = storeOutAction;
  const outActionSendMsgTag = 247711853;
  function storeOutActionSendMsg(action) {
    return (builder2) => {
      builder2.storeUint(outActionSendMsgTag, 32).storeUint(action.mode, 8).storeRef((0, Builder_12.beginCell)().store((0, MessageRelaxed_1.storeMessageRelaxed)(action.outMsg)).endCell());
    };
  }
  const outActionSetCodeTag = 2907562126;
  function storeOutActionSetCode(action) {
    return (builder2) => {
      builder2.storeUint(outActionSetCodeTag, 32).storeRef(action.newCode);
    };
  }
  const outActionReserveTag = 921090057;
  function storeOutActionReserve(action) {
    return (builder2) => {
      builder2.storeUint(outActionReserveTag, 32).storeUint(action.mode, 8).store((0, CurrencyCollection_1.storeCurrencyCollection)(action.currency));
    };
  }
  const outActionChangeLibraryTag = 653925844;
  function storeOutActionChangeLibrary(action) {
    return (builder2) => {
      builder2.storeUint(outActionChangeLibraryTag, 32).storeUint(action.mode, 7).store((0, LibRef_1.storeLibRef)(action.libRef));
    };
  }
  function loadOutAction(slice) {
    const tag = slice.loadUint(32);
    if (tag === outActionSendMsgTag) {
      const mode = slice.loadUint(8);
      const outMsg = (0, MessageRelaxed_1.loadMessageRelaxed)(slice.loadRef().beginParse());
      return {
        type: "sendMsg",
        mode,
        outMsg
      };
    }
    if (tag === outActionSetCodeTag) {
      const newCode = slice.loadRef();
      return {
        type: "setCode",
        newCode
      };
    }
    if (tag === outActionReserveTag) {
      const mode = slice.loadUint(8);
      const currency = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
      return {
        type: "reserve",
        mode,
        currency
      };
    }
    if (tag === outActionChangeLibraryTag) {
      const mode = slice.loadUint(7);
      const libRef = (0, LibRef_1.loadLibRef)(slice);
      return {
        type: "changeLibrary",
        mode,
        libRef
      };
    }
    throw new Error(`Unknown out action tag 0x${tag.toString(16)}`);
  }
  OutList.loadOutAction = loadOutAction;
  function storeOutList(actions) {
    const cell = actions.reduce((cell2, action) => (0, Builder_12.beginCell)().storeRef(cell2).store(storeOutAction(action)).endCell(), (0, Builder_12.beginCell)().endCell());
    return (builder2) => {
      builder2.storeSlice(cell.beginParse());
    };
  }
  OutList.storeOutList = storeOutList;
  function loadOutList(slice) {
    const actions = [];
    while (slice.remainingRefs) {
      const nextCell = slice.loadRef();
      actions.push(loadOutAction(slice));
      slice = nextCell.beginParse();
    }
    return actions.reverse();
  }
  OutList.loadOutList = loadOutList;
  return OutList;
}
var CommonMessageInfo = {};
var hasRequiredCommonMessageInfo;
function requireCommonMessageInfo() {
  if (hasRequiredCommonMessageInfo) return CommonMessageInfo;
  hasRequiredCommonMessageInfo = 1;
  Object.defineProperty(CommonMessageInfo, "__esModule", { value: true });
  CommonMessageInfo.storeCommonMessageInfo = CommonMessageInfo.loadCommonMessageInfo = void 0;
  const CurrencyCollection_1 = requireCurrencyCollection();
  function loadCommonMessageInfo(slice) {
    if (!slice.loadBit()) {
      const ihrDisabled = slice.loadBit();
      const bounce = slice.loadBit();
      const bounced = slice.loadBit();
      const src3 = slice.loadAddress();
      const dest2 = slice.loadAddress();
      const value = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
      const ihrFee = slice.loadCoins();
      const forwardFee = slice.loadCoins();
      const createdLt2 = slice.loadUintBig(64);
      const createdAt2 = slice.loadUint(32);
      return {
        type: "internal",
        ihrDisabled,
        bounce,
        bounced,
        src: src3,
        dest: dest2,
        value,
        ihrFee,
        forwardFee,
        createdLt: createdLt2,
        createdAt: createdAt2
      };
    }
    if (!slice.loadBit()) {
      const src3 = slice.loadMaybeExternalAddress();
      const dest2 = slice.loadAddress();
      const importFee = slice.loadCoins();
      return {
        type: "external-in",
        src: src3,
        dest: dest2,
        importFee
      };
    }
    const src2 = slice.loadAddress();
    const dest = slice.loadMaybeExternalAddress();
    const createdLt = slice.loadUintBig(64);
    const createdAt = slice.loadUint(32);
    return {
      type: "external-out",
      src: src2,
      dest,
      createdLt,
      createdAt
    };
  }
  CommonMessageInfo.loadCommonMessageInfo = loadCommonMessageInfo;
  function storeCommonMessageInfo(source) {
    return (builder2) => {
      if (source.type === "internal") {
        builder2.storeBit(0);
        builder2.storeBit(source.ihrDisabled);
        builder2.storeBit(source.bounce);
        builder2.storeBit(source.bounced);
        builder2.storeAddress(source.src);
        builder2.storeAddress(source.dest);
        builder2.store((0, CurrencyCollection_1.storeCurrencyCollection)(source.value));
        builder2.storeCoins(source.ihrFee);
        builder2.storeCoins(source.forwardFee);
        builder2.storeUint(source.createdLt, 64);
        builder2.storeUint(source.createdAt, 32);
      } else if (source.type === "external-in") {
        builder2.storeBit(1);
        builder2.storeBit(0);
        builder2.storeAddress(source.src);
        builder2.storeAddress(source.dest);
        builder2.storeCoins(source.importFee);
      } else if (source.type === "external-out") {
        builder2.storeBit(1);
        builder2.storeBit(1);
        builder2.storeAddress(source.src);
        builder2.storeAddress(source.dest);
        builder2.storeUint(source.createdLt, 64);
        builder2.storeUint(source.createdAt, 32);
      } else {
        throw new Error("Unknown CommonMessageInfo type");
      }
    };
  }
  CommonMessageInfo.storeCommonMessageInfo = storeCommonMessageInfo;
  return CommonMessageInfo;
}
var ComputeSkipReason = {};
var hasRequiredComputeSkipReason;
function requireComputeSkipReason() {
  if (hasRequiredComputeSkipReason) return ComputeSkipReason;
  hasRequiredComputeSkipReason = 1;
  Object.defineProperty(ComputeSkipReason, "__esModule", { value: true });
  ComputeSkipReason.storeComputeSkipReason = ComputeSkipReason.loadComputeSkipReason = void 0;
  function loadComputeSkipReason(slice) {
    let reason = slice.loadUint(2);
    if (reason === 0) {
      return "no-state";
    } else if (reason === 1) {
      return "bad-state";
    } else if (reason === 2) {
      return "no-gas";
    }
    throw new Error(`Unknown ComputeSkipReason: ${reason}`);
  }
  ComputeSkipReason.loadComputeSkipReason = loadComputeSkipReason;
  function storeComputeSkipReason(src2) {
    return (builder2) => {
      if (src2 === "no-state") {
        builder2.storeUint(0, 2);
      } else if (src2 === "bad-state") {
        builder2.storeUint(1, 2);
      } else if (src2 === "no-gas") {
        builder2.storeUint(2, 2);
      } else {
        throw new Error(`Unknown ComputeSkipReason: ${src2}`);
      }
    };
  }
  ComputeSkipReason.storeComputeSkipReason = storeComputeSkipReason;
  return ComputeSkipReason;
}
var DepthBalanceInfo = {};
var hasRequiredDepthBalanceInfo;
function requireDepthBalanceInfo() {
  if (hasRequiredDepthBalanceInfo) return DepthBalanceInfo;
  hasRequiredDepthBalanceInfo = 1;
  Object.defineProperty(DepthBalanceInfo, "__esModule", { value: true });
  DepthBalanceInfo.storeDepthBalanceInfo = DepthBalanceInfo.loadDepthBalanceInfo = void 0;
  const CurrencyCollection_1 = requireCurrencyCollection();
  function loadDepthBalanceInfo(slice) {
    let splitDepth = slice.loadUint(5);
    return {
      splitDepth,
      balance: (0, CurrencyCollection_1.loadCurrencyCollection)(slice)
    };
  }
  DepthBalanceInfo.loadDepthBalanceInfo = loadDepthBalanceInfo;
  function storeDepthBalanceInfo(src2) {
    return (builder2) => {
      builder2.storeUint(src2.splitDepth, 5);
      builder2.store((0, CurrencyCollection_1.storeCurrencyCollection)(src2.balance));
    };
  }
  DepthBalanceInfo.storeDepthBalanceInfo = storeDepthBalanceInfo;
  return DepthBalanceInfo;
}
var HashUpdate = {};
var hasRequiredHashUpdate;
function requireHashUpdate() {
  if (hasRequiredHashUpdate) return HashUpdate;
  hasRequiredHashUpdate = 1;
  Object.defineProperty(HashUpdate, "__esModule", { value: true });
  HashUpdate.storeHashUpdate = HashUpdate.loadHashUpdate = void 0;
  function loadHashUpdate(slice) {
    if (slice.loadUint(8) !== 114) {
      throw Error("Invalid data");
    }
    const oldHash = slice.loadBuffer(32);
    const newHash = slice.loadBuffer(32);
    return { oldHash, newHash };
  }
  HashUpdate.loadHashUpdate = loadHashUpdate;
  function storeHashUpdate(src2) {
    return (builder2) => {
      builder2.storeUint(114, 8);
      builder2.storeBuffer(src2.oldHash);
      builder2.storeBuffer(src2.newHash);
    };
  }
  HashUpdate.storeHashUpdate = storeHashUpdate;
  return HashUpdate;
}
var MasterchainStateExtra = {};
var hasRequiredMasterchainStateExtra;
function requireMasterchainStateExtra() {
  if (hasRequiredMasterchainStateExtra) return MasterchainStateExtra;
  hasRequiredMasterchainStateExtra = 1;
  Object.defineProperty(MasterchainStateExtra, "__esModule", { value: true });
  MasterchainStateExtra.loadMasterchainStateExtra = void 0;
  const Dictionary_1 = requireDictionary();
  const CurrencyCollection_1 = requireCurrencyCollection();
  function loadMasterchainStateExtra(cs) {
    if (cs.loadUint(16) !== 52262) {
      throw Error("Invalid data");
    }
    if (cs.loadBit()) {
      cs.loadRef();
    }
    let configAddress = cs.loadUintBig(256);
    let config = Dictionary_1.Dictionary.load(Dictionary_1.Dictionary.Keys.Int(32), Dictionary_1.Dictionary.Values.Cell(), cs);
    const globalBalance = (0, CurrencyCollection_1.loadCurrencyCollection)(cs);
    return {
      config,
      configAddress,
      globalBalance
    };
  }
  MasterchainStateExtra.loadMasterchainStateExtra = loadMasterchainStateExtra;
  return MasterchainStateExtra;
}
var Message = {};
var hasRequiredMessage;
function requireMessage() {
  if (hasRequiredMessage) return Message;
  hasRequiredMessage = 1;
  Object.defineProperty(Message, "__esModule", { value: true });
  Message.MessageValue = Message.storeMessage = Message.loadMessage = void 0;
  const Builder_12 = requireBuilder$1();
  const CommonMessageInfo_1 = requireCommonMessageInfo();
  const StateInit_1 = requireStateInit();
  function loadMessage(slice) {
    const info = (0, CommonMessageInfo_1.loadCommonMessageInfo)(slice);
    let init = null;
    if (slice.loadBit()) {
      if (!slice.loadBit()) {
        init = (0, StateInit_1.loadStateInit)(slice);
      } else {
        init = (0, StateInit_1.loadStateInit)(slice.loadRef().beginParse());
      }
    }
    const body = slice.loadBit() ? slice.loadRef() : slice.asCell();
    return {
      info,
      init,
      body
    };
  }
  Message.loadMessage = loadMessage;
  function storeMessage(message, opts) {
    return (builder2) => {
      builder2.store((0, CommonMessageInfo_1.storeCommonMessageInfo)(message.info));
      if (message.init) {
        builder2.storeBit(true);
        let initCell = (0, Builder_12.beginCell)().store((0, StateInit_1.storeStateInit)(message.init));
        let needRef2 = false;
        if (opts && opts.forceRef) {
          needRef2 = true;
        } else {
          needRef2 = builder2.availableBits - 2 < initCell.bits + message.body.bits.length;
        }
        if (needRef2) {
          builder2.storeBit(true);
          builder2.storeRef(initCell);
        } else {
          builder2.storeBit(false);
          builder2.storeBuilder(initCell);
        }
      } else {
        builder2.storeBit(false);
      }
      let needRef = false;
      if (opts && opts.forceRef) {
        needRef = true;
      } else {
        needRef = builder2.availableBits - 1 < message.body.bits.length || builder2.refs + message.body.refs.length > 4;
      }
      if (needRef) {
        builder2.storeBit(true);
        builder2.storeRef(message.body);
      } else {
        builder2.storeBit(false);
        builder2.storeBuilder(message.body.asBuilder());
      }
    };
  }
  Message.storeMessage = storeMessage;
  Message.MessageValue = {
    serialize(src2, builder2) {
      builder2.storeRef((0, Builder_12.beginCell)().store(storeMessage(src2)));
    },
    parse(slice) {
      return loadMessage(slice.loadRef().beginParse());
    }
  };
  return Message;
}
var SendMode = {};
var hasRequiredSendMode;
function requireSendMode() {
  if (hasRequiredSendMode) return SendMode;
  hasRequiredSendMode = 1;
  Object.defineProperty(SendMode, "__esModule", { value: true });
  SendMode.SendMode = void 0;
  var SendMode$12;
  (function(SendMode2) {
    SendMode2[SendMode2["CARRY_ALL_REMAINING_BALANCE"] = 128] = "CARRY_ALL_REMAINING_BALANCE";
    SendMode2[SendMode2["CARRY_ALL_REMAINING_INCOMING_VALUE"] = 64] = "CARRY_ALL_REMAINING_INCOMING_VALUE";
    SendMode2[SendMode2["DESTROY_ACCOUNT_IF_ZERO"] = 32] = "DESTROY_ACCOUNT_IF_ZERO";
    SendMode2[SendMode2["PAY_GAS_SEPARATELY"] = 1] = "PAY_GAS_SEPARATELY";
    SendMode2[SendMode2["IGNORE_ERRORS"] = 2] = "IGNORE_ERRORS";
    SendMode2[SendMode2["NONE"] = 0] = "NONE";
  })(SendMode$12 || (SendMode.SendMode = SendMode$12 = {}));
  return SendMode;
}
var ReserveMode = {};
var hasRequiredReserveMode;
function requireReserveMode() {
  if (hasRequiredReserveMode) return ReserveMode;
  hasRequiredReserveMode = 1;
  Object.defineProperty(ReserveMode, "__esModule", { value: true });
  ReserveMode.ReserveMode = void 0;
  var ReserveMode$12;
  (function(ReserveMode2) {
    ReserveMode2[ReserveMode2["THIS_AMOUNT"] = 0] = "THIS_AMOUNT";
    ReserveMode2[ReserveMode2["LEAVE_THIS_AMOUNT"] = 1] = "LEAVE_THIS_AMOUNT";
    ReserveMode2[ReserveMode2["AT_MOST_THIS_AMOUNT"] = 2] = "AT_MOST_THIS_AMOUNT";
    ReserveMode2[ReserveMode2["LEAVE_MAX_THIS_AMOUNT"] = 3] = "LEAVE_MAX_THIS_AMOUNT";
    ReserveMode2[ReserveMode2["BEFORE_BALANCE_PLUS_THIS_AMOUNT"] = 4] = "BEFORE_BALANCE_PLUS_THIS_AMOUNT";
    ReserveMode2[ReserveMode2["LEAVE_BBALANCE_PLUS_THIS_AMOUNT"] = 5] = "LEAVE_BBALANCE_PLUS_THIS_AMOUNT";
    ReserveMode2[ReserveMode2["BEFORE_BALANCE_MINUS_THIS_AMOUNT"] = 12] = "BEFORE_BALANCE_MINUS_THIS_AMOUNT";
    ReserveMode2[ReserveMode2["LEAVE_BEFORE_BALANCE_MINUS_THIS_AMOUNT"] = 13] = "LEAVE_BEFORE_BALANCE_MINUS_THIS_AMOUNT";
  })(ReserveMode$12 || (ReserveMode.ReserveMode = ReserveMode$12 = {}));
  return ReserveMode;
}
var ShardAccount = {};
var hasRequiredShardAccount;
function requireShardAccount() {
  if (hasRequiredShardAccount) return ShardAccount;
  hasRequiredShardAccount = 1;
  Object.defineProperty(ShardAccount, "__esModule", { value: true });
  ShardAccount.storeShardAccount = ShardAccount.loadShardAccount = void 0;
  const Builder_12 = requireBuilder$1();
  const Account_1 = requireAccount();
  function loadShardAccount(slice) {
    let accountRef = slice.loadRef();
    let account = void 0;
    if (!accountRef.isExotic) {
      let accountSlice = accountRef.beginParse();
      if (accountSlice.loadBit()) {
        account = (0, Account_1.loadAccount)(accountSlice);
      }
    }
    return {
      account,
      lastTransactionHash: slice.loadUintBig(256),
      lastTransactionLt: slice.loadUintBig(64)
    };
  }
  ShardAccount.loadShardAccount = loadShardAccount;
  function storeShardAccount(src2) {
    return (builder2) => {
      if (src2.account) {
        builder2.storeRef((0, Builder_12.beginCell)().storeBit(true).store((0, Account_1.storeAccount)(src2.account)));
      } else {
        builder2.storeRef((0, Builder_12.beginCell)().storeBit(false));
      }
      builder2.storeUint(src2.lastTransactionHash, 256);
      builder2.storeUint(src2.lastTransactionLt, 64);
    };
  }
  ShardAccount.storeShardAccount = storeShardAccount;
  return ShardAccount;
}
var ShardAccounts = {};
var hasRequiredShardAccounts;
function requireShardAccounts() {
  if (hasRequiredShardAccounts) return ShardAccounts;
  hasRequiredShardAccounts = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeShardAccounts = exports.loadShardAccounts = exports.ShardAccountRefValue = void 0;
    const Dictionary_1 = requireDictionary();
    const DepthBalanceInfo_1 = requireDepthBalanceInfo();
    const ShardAccount_1 = requireShardAccount();
    exports.ShardAccountRefValue = {
      parse: (cs) => {
        let depthBalanceInfo = (0, DepthBalanceInfo_1.loadDepthBalanceInfo)(cs);
        let shardAccount = (0, ShardAccount_1.loadShardAccount)(cs);
        return {
          depthBalanceInfo,
          shardAccount
        };
      },
      serialize(src2, builder2) {
        builder2.store((0, DepthBalanceInfo_1.storeDepthBalanceInfo)(src2.depthBalanceInfo));
        builder2.store((0, ShardAccount_1.storeShardAccount)(src2.shardAccount));
      }
    };
    function loadShardAccounts(cs) {
      return Dictionary_1.Dictionary.load(Dictionary_1.Dictionary.Keys.BigUint(256), exports.ShardAccountRefValue, cs);
    }
    exports.loadShardAccounts = loadShardAccounts;
    function storeShardAccounts(src2) {
      return (Builder2) => {
        Builder2.storeDict(src2);
      };
    }
    exports.storeShardAccounts = storeShardAccounts;
  })(ShardAccounts);
  return ShardAccounts;
}
var ShardIdent = {};
var hasRequiredShardIdent;
function requireShardIdent() {
  if (hasRequiredShardIdent) return ShardIdent;
  hasRequiredShardIdent = 1;
  Object.defineProperty(ShardIdent, "__esModule", { value: true });
  ShardIdent.storeShardIdent = ShardIdent.loadShardIdent = void 0;
  function loadShardIdent(slice) {
    if (slice.loadUint(2) !== 0) {
      throw Error("Invalid data");
    }
    return {
      shardPrefixBits: slice.loadUint(6),
      workchainId: slice.loadInt(32),
      shardPrefix: slice.loadUintBig(64)
    };
  }
  ShardIdent.loadShardIdent = loadShardIdent;
  function storeShardIdent(src2) {
    return (builder2) => {
      builder2.storeUint(0, 2);
      builder2.storeUint(src2.shardPrefixBits, 6);
      builder2.storeInt(src2.workchainId, 32);
      builder2.storeUint(src2.shardPrefix, 64);
    };
  }
  ShardIdent.storeShardIdent = storeShardIdent;
  return ShardIdent;
}
var ShardStateUnsplit = {};
var hasRequiredShardStateUnsplit;
function requireShardStateUnsplit() {
  if (hasRequiredShardStateUnsplit) return ShardStateUnsplit;
  hasRequiredShardStateUnsplit = 1;
  Object.defineProperty(ShardStateUnsplit, "__esModule", { value: true });
  ShardStateUnsplit.loadShardStateUnsplit = void 0;
  const MasterchainStateExtra_1 = requireMasterchainStateExtra();
  const ShardAccounts_1 = requireShardAccounts();
  const ShardIdent_1 = requireShardIdent();
  function loadShardStateUnsplit(cs) {
    if (cs.loadUint(32) !== 2418257890) {
      throw Error("Invalid data");
    }
    let globalId = cs.loadInt(32);
    let shardId = (0, ShardIdent_1.loadShardIdent)(cs);
    let seqno = cs.loadUint(32);
    let vertSeqNo = cs.loadUint(32);
    let genUtime = cs.loadUint(32);
    let genLt = cs.loadUintBig(64);
    let minRefMcSeqno = cs.loadUint(32);
    cs.loadRef();
    let beforeSplit = cs.loadBit();
    let shardAccountsRef = cs.loadRef();
    let accounts = void 0;
    if (!shardAccountsRef.isExotic) {
      accounts = (0, ShardAccounts_1.loadShardAccounts)(shardAccountsRef.beginParse());
    }
    cs.loadRef();
    let mcStateExtra = cs.loadBit();
    let extras2 = null;
    if (mcStateExtra) {
      let cell = cs.loadRef();
      if (!cell.isExotic) {
        extras2 = (0, MasterchainStateExtra_1.loadMasterchainStateExtra)(cell.beginParse());
      }
    }
    return {
      globalId,
      shardId,
      seqno,
      vertSeqNo,
      genUtime,
      genLt,
      minRefMcSeqno,
      beforeSplit,
      accounts,
      extras: extras2
    };
  }
  ShardStateUnsplit.loadShardStateUnsplit = loadShardStateUnsplit;
  return ShardStateUnsplit;
}
var SplitMergeInfo = {};
var hasRequiredSplitMergeInfo;
function requireSplitMergeInfo() {
  if (hasRequiredSplitMergeInfo) return SplitMergeInfo;
  hasRequiredSplitMergeInfo = 1;
  Object.defineProperty(SplitMergeInfo, "__esModule", { value: true });
  SplitMergeInfo.storeSplitMergeInfo = SplitMergeInfo.loadSplitMergeInfo = void 0;
  function loadSplitMergeInfo(slice) {
    let currentShardPrefixLength = slice.loadUint(6);
    let accountSplitDepth = slice.loadUint(6);
    let thisAddress = slice.loadUintBig(256);
    let siblingAddress = slice.loadUintBig(256);
    return {
      currentShardPrefixLength,
      accountSplitDepth,
      thisAddress,
      siblingAddress
    };
  }
  SplitMergeInfo.loadSplitMergeInfo = loadSplitMergeInfo;
  function storeSplitMergeInfo(src2) {
    return (builder2) => {
      builder2.storeUint(src2.currentShardPrefixLength, 6);
      builder2.storeUint(src2.accountSplitDepth, 6);
      builder2.storeUint(src2.thisAddress, 256);
      builder2.storeUint(src2.siblingAddress, 256);
    };
  }
  SplitMergeInfo.storeSplitMergeInfo = storeSplitMergeInfo;
  return SplitMergeInfo;
}
var Transaction = {};
var TransactionDescription = {};
var TransactionActionPhase = {};
var hasRequiredTransactionActionPhase;
function requireTransactionActionPhase() {
  if (hasRequiredTransactionActionPhase) return TransactionActionPhase;
  hasRequiredTransactionActionPhase = 1;
  Object.defineProperty(TransactionActionPhase, "__esModule", { value: true });
  TransactionActionPhase.storeTransactionActionPhase = TransactionActionPhase.loadTransactionActionPhase = void 0;
  const AccountStatusChange_1 = requireAccountStatusChange();
  const StorageUsed_1 = requireStorageUsed();
  function loadTransactionActionPhase(slice) {
    let success = slice.loadBit();
    let valid = slice.loadBit();
    let noFunds = slice.loadBit();
    let statusChange = (0, AccountStatusChange_1.loadAccountStatusChange)(slice);
    let totalFwdFees = slice.loadBit() ? slice.loadCoins() : void 0;
    let totalActionFees = slice.loadBit() ? slice.loadCoins() : void 0;
    let resultCode = slice.loadInt(32);
    let resultArg = slice.loadBit() ? slice.loadInt(32) : void 0;
    let totalActions = slice.loadUint(16);
    let specActions = slice.loadUint(16);
    let skippedActions = slice.loadUint(16);
    let messagesCreated = slice.loadUint(16);
    let actionListHash = slice.loadUintBig(256);
    let totalMessageSize = (0, StorageUsed_1.loadStorageUsed)(slice);
    return {
      success,
      valid,
      noFunds,
      statusChange,
      totalFwdFees,
      totalActionFees,
      resultCode,
      resultArg,
      totalActions,
      specActions,
      skippedActions,
      messagesCreated,
      actionListHash,
      totalMessageSize
    };
  }
  TransactionActionPhase.loadTransactionActionPhase = loadTransactionActionPhase;
  function storeTransactionActionPhase(src2) {
    return (builder2) => {
      builder2.storeBit(src2.success);
      builder2.storeBit(src2.valid);
      builder2.storeBit(src2.noFunds);
      builder2.store((0, AccountStatusChange_1.storeAccountStatusChange)(src2.statusChange));
      builder2.storeMaybeCoins(src2.totalFwdFees);
      builder2.storeMaybeCoins(src2.totalActionFees);
      builder2.storeInt(src2.resultCode, 32);
      builder2.storeMaybeInt(src2.resultArg, 32);
      builder2.storeUint(src2.totalActions, 16);
      builder2.storeUint(src2.specActions, 16);
      builder2.storeUint(src2.skippedActions, 16);
      builder2.storeUint(src2.messagesCreated, 16);
      builder2.storeUint(src2.actionListHash, 256);
      builder2.store((0, StorageUsed_1.storeStorageUsed)(src2.totalMessageSize));
    };
  }
  TransactionActionPhase.storeTransactionActionPhase = storeTransactionActionPhase;
  return TransactionActionPhase;
}
var TransactionBouncePhase = {};
var hasRequiredTransactionBouncePhase;
function requireTransactionBouncePhase() {
  if (hasRequiredTransactionBouncePhase) return TransactionBouncePhase;
  hasRequiredTransactionBouncePhase = 1;
  Object.defineProperty(TransactionBouncePhase, "__esModule", { value: true });
  TransactionBouncePhase.storeTransactionBouncePhase = TransactionBouncePhase.loadTransactionBouncePhase = void 0;
  const StorageUsed_1 = requireStorageUsed();
  function loadTransactionBouncePhase(slice) {
    if (slice.loadBit()) {
      let messageSize = (0, StorageUsed_1.loadStorageUsed)(slice);
      let messageFees = slice.loadCoins();
      let forwardFees = slice.loadCoins();
      return {
        type: "ok",
        messageSize,
        messageFees,
        forwardFees
      };
    }
    if (slice.loadBit()) {
      let messageSize = (0, StorageUsed_1.loadStorageUsed)(slice);
      let requiredForwardFees = slice.loadCoins();
      return {
        type: "no-funds",
        messageSize,
        requiredForwardFees
      };
    }
    return {
      type: "negative-funds"
    };
  }
  TransactionBouncePhase.loadTransactionBouncePhase = loadTransactionBouncePhase;
  function storeTransactionBouncePhase(src2) {
    return (builder2) => {
      if (src2.type === "ok") {
        builder2.storeBit(true);
        builder2.store((0, StorageUsed_1.storeStorageUsed)(src2.messageSize));
        builder2.storeCoins(src2.messageFees);
        builder2.storeCoins(src2.forwardFees);
      } else if (src2.type === "negative-funds") {
        builder2.storeBit(false);
        builder2.storeBit(false);
      } else if (src2.type === "no-funds") {
        builder2.storeBit(false);
        builder2.storeBit(true);
        builder2.store((0, StorageUsed_1.storeStorageUsed)(src2.messageSize));
        builder2.storeCoins(src2.requiredForwardFees);
      } else {
        throw new Error("Invalid TransactionBouncePhase type");
      }
    };
  }
  TransactionBouncePhase.storeTransactionBouncePhase = storeTransactionBouncePhase;
  return TransactionBouncePhase;
}
var TransactionComputePhase = {};
var hasRequiredTransactionComputePhase;
function requireTransactionComputePhase() {
  if (hasRequiredTransactionComputePhase) return TransactionComputePhase;
  hasRequiredTransactionComputePhase = 1;
  Object.defineProperty(TransactionComputePhase, "__esModule", { value: true });
  TransactionComputePhase.storeTransactionComputePhase = TransactionComputePhase.loadTransactionComputePhase = void 0;
  const Builder_12 = requireBuilder$1();
  const ComputeSkipReason_1 = requireComputeSkipReason();
  function loadTransactionComputePhase(slice) {
    if (!slice.loadBit()) {
      let reason = (0, ComputeSkipReason_1.loadComputeSkipReason)(slice);
      return {
        type: "skipped",
        reason
      };
    }
    let success = slice.loadBit();
    let messageStateUsed = slice.loadBit();
    let accountActivated = slice.loadBit();
    let gasFees = slice.loadCoins();
    const vmState = slice.loadRef().beginParse();
    let gasUsed = vmState.loadVarUintBig(3);
    let gasLimit = vmState.loadVarUintBig(3);
    let gasCredit = vmState.loadBit() ? vmState.loadVarUintBig(2) : void 0;
    let mode = vmState.loadUint(8);
    let exitCode = vmState.loadInt(32);
    let exitArg = vmState.loadBit() ? vmState.loadInt(32) : void 0;
    let vmSteps = vmState.loadUint(32);
    let vmInitStateHash = vmState.loadUintBig(256);
    let vmFinalStateHash = vmState.loadUintBig(256);
    return {
      type: "vm",
      success,
      messageStateUsed,
      accountActivated,
      gasFees,
      gasUsed,
      gasLimit,
      gasCredit,
      mode,
      exitCode,
      exitArg,
      vmSteps,
      vmInitStateHash,
      vmFinalStateHash
    };
  }
  TransactionComputePhase.loadTransactionComputePhase = loadTransactionComputePhase;
  function storeTransactionComputePhase(src2) {
    return (builder2) => {
      if (src2.type === "skipped") {
        builder2.storeBit(0);
        builder2.store((0, ComputeSkipReason_1.storeComputeSkipReason)(src2.reason));
        return;
      }
      builder2.storeBit(1);
      builder2.storeBit(src2.success);
      builder2.storeBit(src2.messageStateUsed);
      builder2.storeBit(src2.accountActivated);
      builder2.storeCoins(src2.gasFees);
      builder2.storeRef((0, Builder_12.beginCell)().storeVarUint(src2.gasUsed, 3).storeVarUint(src2.gasLimit, 3).store((b) => src2.gasCredit !== void 0 && src2.gasCredit !== null ? b.storeBit(1).storeVarUint(src2.gasCredit, 2) : b.storeBit(0)).storeUint(src2.mode, 8).storeInt(src2.exitCode, 32).store((b) => src2.exitArg !== void 0 && src2.exitArg !== null ? b.storeBit(1).storeInt(src2.exitArg, 32) : b.storeBit(0)).storeUint(src2.vmSteps, 32).storeUint(src2.vmInitStateHash, 256).storeUint(src2.vmFinalStateHash, 256).endCell());
    };
  }
  TransactionComputePhase.storeTransactionComputePhase = storeTransactionComputePhase;
  return TransactionComputePhase;
}
var TransactionCreditPhase = {};
var hasRequiredTransactionCreditPhase;
function requireTransactionCreditPhase() {
  if (hasRequiredTransactionCreditPhase) return TransactionCreditPhase;
  hasRequiredTransactionCreditPhase = 1;
  Object.defineProperty(TransactionCreditPhase, "__esModule", { value: true });
  TransactionCreditPhase.storeTransactionCreditPhase = TransactionCreditPhase.loadTransactionCreditPhase = void 0;
  const CurrencyCollection_1 = requireCurrencyCollection();
  function loadTransactionCreditPhase(slice) {
    const dueFeesColelcted = slice.loadBit() ? slice.loadCoins() : void 0;
    const credit = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
    return {
      dueFeesColelcted,
      credit
    };
  }
  TransactionCreditPhase.loadTransactionCreditPhase = loadTransactionCreditPhase;
  function storeTransactionCreditPhase(src2) {
    return (builder2) => {
      if (src2.dueFeesColelcted === null || src2.dueFeesColelcted === void 0) {
        builder2.storeBit(false);
      } else {
        builder2.storeBit(true);
        builder2.storeCoins(src2.dueFeesColelcted);
      }
      builder2.store((0, CurrencyCollection_1.storeCurrencyCollection)(src2.credit));
    };
  }
  TransactionCreditPhase.storeTransactionCreditPhase = storeTransactionCreditPhase;
  return TransactionCreditPhase;
}
var TransactionStoragePhase = {};
var hasRequiredTransactionStoragePhase;
function requireTransactionStoragePhase() {
  if (hasRequiredTransactionStoragePhase) return TransactionStoragePhase;
  hasRequiredTransactionStoragePhase = 1;
  Object.defineProperty(TransactionStoragePhase, "__esModule", { value: true });
  TransactionStoragePhase.storeTransactionsStoragePhase = TransactionStoragePhase.loadTransactionStoragePhase = void 0;
  const AccountStatusChange_1 = requireAccountStatusChange();
  function loadTransactionStoragePhase(slice) {
    const storageFeesCollected = slice.loadCoins();
    let storageFeesDue = void 0;
    if (slice.loadBit()) {
      storageFeesDue = slice.loadCoins();
    }
    const statusChange = (0, AccountStatusChange_1.loadAccountStatusChange)(slice);
    return {
      storageFeesCollected,
      storageFeesDue,
      statusChange
    };
  }
  TransactionStoragePhase.loadTransactionStoragePhase = loadTransactionStoragePhase;
  function storeTransactionsStoragePhase(src2) {
    return (builder2) => {
      builder2.storeCoins(src2.storageFeesCollected);
      if (src2.storageFeesDue === null || src2.storageFeesDue === void 0) {
        builder2.storeBit(false);
      } else {
        builder2.storeBit(true);
        builder2.storeCoins(src2.storageFeesDue);
      }
      builder2.store((0, AccountStatusChange_1.storeAccountStatusChange)(src2.statusChange));
    };
  }
  TransactionStoragePhase.storeTransactionsStoragePhase = storeTransactionsStoragePhase;
  return TransactionStoragePhase;
}
var hasRequiredTransactionDescription;
function requireTransactionDescription() {
  if (hasRequiredTransactionDescription) return TransactionDescription;
  hasRequiredTransactionDescription = 1;
  Object.defineProperty(TransactionDescription, "__esModule", { value: true });
  TransactionDescription.storeTransactionDescription = TransactionDescription.loadTransactionDescription = void 0;
  const Builder_12 = requireBuilder$1();
  const SplitMergeInfo_1 = requireSplitMergeInfo();
  const Transaction_1 = requireTransaction();
  const TransactionActionPhase_1 = requireTransactionActionPhase();
  const TransactionBouncePhase_1 = requireTransactionBouncePhase();
  const TransactionComputePhase_1 = requireTransactionComputePhase();
  const TransactionCreditPhase_1 = requireTransactionCreditPhase();
  const TransactionStoragePhase_1 = requireTransactionStoragePhase();
  function loadTransactionDescription(slice) {
    let type = slice.loadUint(4);
    if (type === 0) {
      const creditFirst = slice.loadBit();
      let storagePhase = void 0;
      if (slice.loadBit()) {
        storagePhase = (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice);
      }
      let creditPhase = void 0;
      if (slice.loadBit()) {
        creditPhase = (0, TransactionCreditPhase_1.loadTransactionCreditPhase)(slice);
      }
      let computePhase = (0, TransactionComputePhase_1.loadTransactionComputePhase)(slice);
      let actionPhase = void 0;
      if (slice.loadBit()) {
        actionPhase = (0, TransactionActionPhase_1.loadTransactionActionPhase)(slice.loadRef().beginParse());
      }
      let aborted = slice.loadBit();
      let bouncePhase = void 0;
      if (slice.loadBit()) {
        bouncePhase = (0, TransactionBouncePhase_1.loadTransactionBouncePhase)(slice);
      }
      const destroyed = slice.loadBit();
      return {
        type: "generic",
        creditFirst,
        storagePhase,
        creditPhase,
        computePhase,
        actionPhase,
        bouncePhase,
        aborted,
        destroyed
      };
    }
    if (type === 1) {
      return {
        type: "storage",
        storagePhase: (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice)
      };
    }
    if (type === 2 || type === 3) {
      const isTock = type === 3;
      let storagePhase = (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice);
      let computePhase = (0, TransactionComputePhase_1.loadTransactionComputePhase)(slice);
      let actionPhase = void 0;
      if (slice.loadBit()) {
        actionPhase = (0, TransactionActionPhase_1.loadTransactionActionPhase)(slice.loadRef().beginParse());
      }
      const aborted = slice.loadBit();
      const destroyed = slice.loadBit();
      return {
        type: "tick-tock",
        isTock,
        storagePhase,
        computePhase,
        actionPhase,
        aborted,
        destroyed
      };
    }
    if (type === 4) {
      let splitInfo = (0, SplitMergeInfo_1.loadSplitMergeInfo)(slice);
      let storagePhase = void 0;
      if (slice.loadBit()) {
        storagePhase = (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice);
      }
      let computePhase = (0, TransactionComputePhase_1.loadTransactionComputePhase)(slice);
      let actionPhase = void 0;
      if (slice.loadBit()) {
        actionPhase = (0, TransactionActionPhase_1.loadTransactionActionPhase)(slice.loadRef().beginParse());
      }
      const aborted = slice.loadBit();
      const destroyed = slice.loadBit();
      return {
        type: "split-prepare",
        splitInfo,
        storagePhase,
        computePhase,
        actionPhase,
        aborted,
        destroyed
      };
    }
    if (type === 5) {
      let splitInfo = (0, SplitMergeInfo_1.loadSplitMergeInfo)(slice);
      let prepareTransaction = (0, Transaction_1.loadTransaction)(slice.loadRef().beginParse());
      const installed = slice.loadBit();
      return {
        type: "split-install",
        splitInfo,
        prepareTransaction,
        installed
      };
    }
    throw Error(`Unsupported transaction description type ${type}`);
  }
  TransactionDescription.loadTransactionDescription = loadTransactionDescription;
  function storeTransactionDescription(src2) {
    return (builder2) => {
      if (src2.type === "generic") {
        builder2.storeUint(0, 4);
        builder2.storeBit(src2.creditFirst);
        if (src2.storagePhase) {
          builder2.storeBit(true);
          builder2.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src2.storagePhase));
        } else {
          builder2.storeBit(false);
        }
        if (src2.creditPhase) {
          builder2.storeBit(true);
          builder2.store((0, TransactionCreditPhase_1.storeTransactionCreditPhase)(src2.creditPhase));
        } else {
          builder2.storeBit(false);
        }
        builder2.store((0, TransactionComputePhase_1.storeTransactionComputePhase)(src2.computePhase));
        if (src2.actionPhase) {
          builder2.storeBit(true);
          builder2.storeRef((0, Builder_12.beginCell)().store((0, TransactionActionPhase_1.storeTransactionActionPhase)(src2.actionPhase)));
        } else {
          builder2.storeBit(false);
        }
        builder2.storeBit(src2.aborted);
        if (src2.bouncePhase) {
          builder2.storeBit(true);
          builder2.store((0, TransactionBouncePhase_1.storeTransactionBouncePhase)(src2.bouncePhase));
        } else {
          builder2.storeBit(false);
        }
        builder2.storeBit(src2.destroyed);
      } else if (src2.type === "storage") {
        builder2.storeUint(1, 4);
        builder2.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src2.storagePhase));
      } else if (src2.type === "tick-tock") {
        builder2.storeUint(src2.isTock ? 3 : 2, 4);
        builder2.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src2.storagePhase));
        builder2.store((0, TransactionComputePhase_1.storeTransactionComputePhase)(src2.computePhase));
        if (src2.actionPhase) {
          builder2.storeBit(true);
          builder2.storeRef((0, Builder_12.beginCell)().store((0, TransactionActionPhase_1.storeTransactionActionPhase)(src2.actionPhase)));
        } else {
          builder2.storeBit(false);
        }
        builder2.storeBit(src2.aborted);
        builder2.storeBit(src2.destroyed);
      } else if (src2.type === "split-prepare") {
        builder2.storeUint(4, 4);
        builder2.store((0, SplitMergeInfo_1.storeSplitMergeInfo)(src2.splitInfo));
        if (src2.storagePhase) {
          builder2.storeBit(true);
          builder2.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src2.storagePhase));
        } else {
          builder2.storeBit(false);
        }
        builder2.store((0, TransactionComputePhase_1.storeTransactionComputePhase)(src2.computePhase));
        if (src2.actionPhase) {
          builder2.storeBit(true);
          builder2.store((0, TransactionActionPhase_1.storeTransactionActionPhase)(src2.actionPhase));
        } else {
          builder2.storeBit(false);
        }
        builder2.storeBit(src2.aborted);
        builder2.storeBit(src2.destroyed);
      } else if (src2.type === "split-install") {
        builder2.storeUint(5, 4);
        builder2.store((0, SplitMergeInfo_1.storeSplitMergeInfo)(src2.splitInfo));
        builder2.storeRef((0, Builder_12.beginCell)().store((0, Transaction_1.storeTransaction)(src2.prepareTransaction)));
        builder2.storeBit(src2.installed);
      } else {
        throw Error(`Unsupported transaction description type ${src2.type}`);
      }
    };
  }
  TransactionDescription.storeTransactionDescription = storeTransactionDescription;
  return TransactionDescription;
}
var hasRequiredTransaction;
function requireTransaction() {
  if (hasRequiredTransaction) return Transaction;
  hasRequiredTransaction = 1;
  Object.defineProperty(Transaction, "__esModule", { value: true });
  Transaction.storeTransaction = Transaction.loadTransaction = void 0;
  const Builder_12 = requireBuilder$1();
  const Dictionary_1 = requireDictionary();
  const AccountStatus_1 = requireAccountStatus();
  const CurrencyCollection_1 = requireCurrencyCollection();
  const HashUpdate_1 = requireHashUpdate();
  const Message_1 = requireMessage();
  const TransactionDescription_1 = requireTransactionDescription();
  function loadTransaction(slice) {
    let raw = slice.asCell();
    if (slice.loadUint(4) !== 7) {
      throw Error("Invalid data");
    }
    let address = slice.loadUintBig(256);
    let lt = slice.loadUintBig(64);
    let prevTransactionHash = slice.loadUintBig(256);
    let prevTransactionLt = slice.loadUintBig(64);
    let now = slice.loadUint(32);
    let outMessagesCount = slice.loadUint(15);
    let oldStatus = (0, AccountStatus_1.loadAccountStatus)(slice);
    let endStatus = (0, AccountStatus_1.loadAccountStatus)(slice);
    let msgRef = slice.loadRef();
    let msgSlice = msgRef.beginParse();
    let inMessage = msgSlice.loadBit() ? (0, Message_1.loadMessage)(msgSlice.loadRef().beginParse()) : void 0;
    let outMessages = msgSlice.loadDict(Dictionary_1.Dictionary.Keys.Uint(15), Message_1.MessageValue);
    msgSlice.endParse();
    let totalFees = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
    let stateUpdate = (0, HashUpdate_1.loadHashUpdate)(slice.loadRef().beginParse());
    let description = (0, TransactionDescription_1.loadTransactionDescription)(slice.loadRef().beginParse());
    return {
      address,
      lt,
      prevTransactionHash,
      prevTransactionLt,
      now,
      outMessagesCount,
      oldStatus,
      endStatus,
      inMessage,
      outMessages,
      totalFees,
      stateUpdate,
      description,
      raw,
      hash: () => raw.hash()
    };
  }
  Transaction.loadTransaction = loadTransaction;
  function storeTransaction(src2) {
    return (builder2) => {
      builder2.storeUint(7, 4);
      builder2.storeUint(src2.address, 256);
      builder2.storeUint(src2.lt, 64);
      builder2.storeUint(src2.prevTransactionHash, 256);
      builder2.storeUint(src2.prevTransactionLt, 64);
      builder2.storeUint(src2.now, 32);
      builder2.storeUint(src2.outMessagesCount, 15);
      builder2.store((0, AccountStatus_1.storeAccountStatus)(src2.oldStatus));
      builder2.store((0, AccountStatus_1.storeAccountStatus)(src2.endStatus));
      let msgBuilder = (0, Builder_12.beginCell)();
      if (src2.inMessage) {
        msgBuilder.storeBit(true);
        msgBuilder.storeRef((0, Builder_12.beginCell)().store((0, Message_1.storeMessage)(src2.inMessage)));
      } else {
        msgBuilder.storeBit(false);
      }
      msgBuilder.storeDict(src2.outMessages);
      builder2.storeRef(msgBuilder);
      builder2.store((0, CurrencyCollection_1.storeCurrencyCollection)(src2.totalFees));
      builder2.storeRef((0, Builder_12.beginCell)().store((0, HashUpdate_1.storeHashUpdate)(src2.stateUpdate)));
      builder2.storeRef((0, Builder_12.beginCell)().store((0, TransactionDescription_1.storeTransactionDescription)(src2.description)));
    };
  }
  Transaction.storeTransaction = storeTransaction;
  return Transaction;
}
var hasRequired_export;
function require_export() {
  if (hasRequired_export) return _export;
  hasRequired_export = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadSimpleLibrary = exports.loadShardStateUnsplit = exports.storeShardIdent = exports.loadShardIdent = exports.storeShardAccounts = exports.loadShardAccounts = exports.ShardAccountRefValue = exports.storeShardAccount = exports.loadShardAccount = exports.ReserveMode = exports.SendMode = exports.storeMessageRelaxed = exports.loadMessageRelaxed = exports.storeMessage = exports.loadMessage = exports.loadMasterchainStateExtra = exports.storeHashUpdate = exports.loadHashUpdate = exports.storeExtraCurrency = exports.loadMaybeExtraCurrency = exports.loadExtraCurrency = exports.packExtraCurrencyDict = exports.packExtraCurrencyCell = exports.storeDepthBalanceInfo = exports.loadDepthBalanceInfo = exports.storeCurrencyCollection = exports.loadCurrencyCollection = exports.storeComputeSkipReason = exports.loadComputeSkipReason = exports.storeCommonMessageInfoRelaxed = exports.loadCommonMessageInfoRelaxed = exports.storeCommonMessageInfo = exports.loadCommonMessageInfo = exports.storeOutList = exports.loadOutList = exports.storeOutAction = exports.loadOutAction = exports.storeAccountStorage = exports.loadAccountStorage = exports.storeAccountStatusChange = exports.loadAccountStatusChange = exports.storeAccountStatus = exports.loadAccountStatus = exports.storeAccountState = exports.loadAccountState = exports.storeAccount = exports.loadAccount = exports.comment = exports.external = exports.internal = void 0;
    exports.storeTransactionsStoragePhase = exports.loadTransactionStoragePhase = exports.storeTransactionDescription = exports.loadTransactionDescription = exports.storeTransactionCreditPhase = exports.loadTransactionCreditPhase = exports.storeTransactionComputePhase = exports.loadTransactionComputePhase = exports.storeTransactionBouncePhase = exports.loadTransactionBouncePhase = exports.storeTransactionActionPhase = exports.loadTransactionActionPhase = exports.storeTransaction = exports.loadTransaction = exports.storeTickTock = exports.loadTickTock = exports.storeStorageUsed = exports.loadStorageUsed = exports.storeStorageInfo = exports.loadStorageInfo = exports.storeStateInit = exports.loadStateInit = exports.storeSplitMergeInfo = exports.loadSplitMergeInfo = exports.storeLibRef = exports.loadLibRef = exports.storeSimpleLibrary = void 0;
    var _helpers_1 = require_helpers();
    Object.defineProperty(exports, "internal", { enumerable: true, get: function() {
      return _helpers_1.internal;
    } });
    Object.defineProperty(exports, "external", { enumerable: true, get: function() {
      return _helpers_1.external;
    } });
    Object.defineProperty(exports, "comment", { enumerable: true, get: function() {
      return _helpers_1.comment;
    } });
    var Account_1 = requireAccount();
    Object.defineProperty(exports, "loadAccount", { enumerable: true, get: function() {
      return Account_1.loadAccount;
    } });
    Object.defineProperty(exports, "storeAccount", { enumerable: true, get: function() {
      return Account_1.storeAccount;
    } });
    var AccountState_1 = requireAccountState();
    Object.defineProperty(exports, "loadAccountState", { enumerable: true, get: function() {
      return AccountState_1.loadAccountState;
    } });
    Object.defineProperty(exports, "storeAccountState", { enumerable: true, get: function() {
      return AccountState_1.storeAccountState;
    } });
    var AccountStatus_1 = requireAccountStatus();
    Object.defineProperty(exports, "loadAccountStatus", { enumerable: true, get: function() {
      return AccountStatus_1.loadAccountStatus;
    } });
    Object.defineProperty(exports, "storeAccountStatus", { enumerable: true, get: function() {
      return AccountStatus_1.storeAccountStatus;
    } });
    var AccountStatusChange_1 = requireAccountStatusChange();
    Object.defineProperty(exports, "loadAccountStatusChange", { enumerable: true, get: function() {
      return AccountStatusChange_1.loadAccountStatusChange;
    } });
    Object.defineProperty(exports, "storeAccountStatusChange", { enumerable: true, get: function() {
      return AccountStatusChange_1.storeAccountStatusChange;
    } });
    var AccountStorage_1 = requireAccountStorage();
    Object.defineProperty(exports, "loadAccountStorage", { enumerable: true, get: function() {
      return AccountStorage_1.loadAccountStorage;
    } });
    Object.defineProperty(exports, "storeAccountStorage", { enumerable: true, get: function() {
      return AccountStorage_1.storeAccountStorage;
    } });
    var OutList_1 = requireOutList();
    Object.defineProperty(exports, "loadOutAction", { enumerable: true, get: function() {
      return OutList_1.loadOutAction;
    } });
    Object.defineProperty(exports, "storeOutAction", { enumerable: true, get: function() {
      return OutList_1.storeOutAction;
    } });
    Object.defineProperty(exports, "loadOutList", { enumerable: true, get: function() {
      return OutList_1.loadOutList;
    } });
    Object.defineProperty(exports, "storeOutList", { enumerable: true, get: function() {
      return OutList_1.storeOutList;
    } });
    var CommonMessageInfo_1 = requireCommonMessageInfo();
    Object.defineProperty(exports, "loadCommonMessageInfo", { enumerable: true, get: function() {
      return CommonMessageInfo_1.loadCommonMessageInfo;
    } });
    Object.defineProperty(exports, "storeCommonMessageInfo", { enumerable: true, get: function() {
      return CommonMessageInfo_1.storeCommonMessageInfo;
    } });
    var CommonMessageInfoRelaxed_1 = requireCommonMessageInfoRelaxed();
    Object.defineProperty(exports, "loadCommonMessageInfoRelaxed", { enumerable: true, get: function() {
      return CommonMessageInfoRelaxed_1.loadCommonMessageInfoRelaxed;
    } });
    Object.defineProperty(exports, "storeCommonMessageInfoRelaxed", { enumerable: true, get: function() {
      return CommonMessageInfoRelaxed_1.storeCommonMessageInfoRelaxed;
    } });
    var ComputeSkipReason_1 = requireComputeSkipReason();
    Object.defineProperty(exports, "loadComputeSkipReason", { enumerable: true, get: function() {
      return ComputeSkipReason_1.loadComputeSkipReason;
    } });
    Object.defineProperty(exports, "storeComputeSkipReason", { enumerable: true, get: function() {
      return ComputeSkipReason_1.storeComputeSkipReason;
    } });
    var CurrencyCollection_1 = requireCurrencyCollection();
    Object.defineProperty(exports, "loadCurrencyCollection", { enumerable: true, get: function() {
      return CurrencyCollection_1.loadCurrencyCollection;
    } });
    Object.defineProperty(exports, "storeCurrencyCollection", { enumerable: true, get: function() {
      return CurrencyCollection_1.storeCurrencyCollection;
    } });
    var DepthBalanceInfo_1 = requireDepthBalanceInfo();
    Object.defineProperty(exports, "loadDepthBalanceInfo", { enumerable: true, get: function() {
      return DepthBalanceInfo_1.loadDepthBalanceInfo;
    } });
    Object.defineProperty(exports, "storeDepthBalanceInfo", { enumerable: true, get: function() {
      return DepthBalanceInfo_1.storeDepthBalanceInfo;
    } });
    var ExtraCurrency_1 = requireExtraCurrency();
    Object.defineProperty(exports, "packExtraCurrencyCell", { enumerable: true, get: function() {
      return ExtraCurrency_1.packExtraCurrencyCell;
    } });
    Object.defineProperty(exports, "packExtraCurrencyDict", { enumerable: true, get: function() {
      return ExtraCurrency_1.packExtraCurrencyDict;
    } });
    Object.defineProperty(exports, "loadExtraCurrency", { enumerable: true, get: function() {
      return ExtraCurrency_1.loadExtraCurrency;
    } });
    Object.defineProperty(exports, "loadMaybeExtraCurrency", { enumerable: true, get: function() {
      return ExtraCurrency_1.loadMaybeExtraCurrency;
    } });
    Object.defineProperty(exports, "storeExtraCurrency", { enumerable: true, get: function() {
      return ExtraCurrency_1.storeExtraCurrency;
    } });
    var HashUpdate_1 = requireHashUpdate();
    Object.defineProperty(exports, "loadHashUpdate", { enumerable: true, get: function() {
      return HashUpdate_1.loadHashUpdate;
    } });
    Object.defineProperty(exports, "storeHashUpdate", { enumerable: true, get: function() {
      return HashUpdate_1.storeHashUpdate;
    } });
    var MasterchainStateExtra_1 = requireMasterchainStateExtra();
    Object.defineProperty(exports, "loadMasterchainStateExtra", { enumerable: true, get: function() {
      return MasterchainStateExtra_1.loadMasterchainStateExtra;
    } });
    var Message_1 = requireMessage();
    Object.defineProperty(exports, "loadMessage", { enumerable: true, get: function() {
      return Message_1.loadMessage;
    } });
    Object.defineProperty(exports, "storeMessage", { enumerable: true, get: function() {
      return Message_1.storeMessage;
    } });
    var MessageRelaxed_1 = requireMessageRelaxed();
    Object.defineProperty(exports, "loadMessageRelaxed", { enumerable: true, get: function() {
      return MessageRelaxed_1.loadMessageRelaxed;
    } });
    Object.defineProperty(exports, "storeMessageRelaxed", { enumerable: true, get: function() {
      return MessageRelaxed_1.storeMessageRelaxed;
    } });
    var SendMode_1 = requireSendMode();
    Object.defineProperty(exports, "SendMode", { enumerable: true, get: function() {
      return SendMode_1.SendMode;
    } });
    var ReserveMode_1 = requireReserveMode();
    Object.defineProperty(exports, "ReserveMode", { enumerable: true, get: function() {
      return ReserveMode_1.ReserveMode;
    } });
    var ShardAccount_1 = requireShardAccount();
    Object.defineProperty(exports, "loadShardAccount", { enumerable: true, get: function() {
      return ShardAccount_1.loadShardAccount;
    } });
    Object.defineProperty(exports, "storeShardAccount", { enumerable: true, get: function() {
      return ShardAccount_1.storeShardAccount;
    } });
    var ShardAccounts_1 = requireShardAccounts();
    Object.defineProperty(exports, "ShardAccountRefValue", { enumerable: true, get: function() {
      return ShardAccounts_1.ShardAccountRefValue;
    } });
    Object.defineProperty(exports, "loadShardAccounts", { enumerable: true, get: function() {
      return ShardAccounts_1.loadShardAccounts;
    } });
    Object.defineProperty(exports, "storeShardAccounts", { enumerable: true, get: function() {
      return ShardAccounts_1.storeShardAccounts;
    } });
    var ShardIdent_1 = requireShardIdent();
    Object.defineProperty(exports, "loadShardIdent", { enumerable: true, get: function() {
      return ShardIdent_1.loadShardIdent;
    } });
    Object.defineProperty(exports, "storeShardIdent", { enumerable: true, get: function() {
      return ShardIdent_1.storeShardIdent;
    } });
    var ShardStateUnsplit_1 = requireShardStateUnsplit();
    Object.defineProperty(exports, "loadShardStateUnsplit", { enumerable: true, get: function() {
      return ShardStateUnsplit_1.loadShardStateUnsplit;
    } });
    var SimpleLibrary_1 = requireSimpleLibrary();
    Object.defineProperty(exports, "loadSimpleLibrary", { enumerable: true, get: function() {
      return SimpleLibrary_1.loadSimpleLibrary;
    } });
    Object.defineProperty(exports, "storeSimpleLibrary", { enumerable: true, get: function() {
      return SimpleLibrary_1.storeSimpleLibrary;
    } });
    var LibRef_1 = requireLibRef();
    Object.defineProperty(exports, "loadLibRef", { enumerable: true, get: function() {
      return LibRef_1.loadLibRef;
    } });
    Object.defineProperty(exports, "storeLibRef", { enumerable: true, get: function() {
      return LibRef_1.storeLibRef;
    } });
    var SplitMergeInfo_1 = requireSplitMergeInfo();
    Object.defineProperty(exports, "loadSplitMergeInfo", { enumerable: true, get: function() {
      return SplitMergeInfo_1.loadSplitMergeInfo;
    } });
    Object.defineProperty(exports, "storeSplitMergeInfo", { enumerable: true, get: function() {
      return SplitMergeInfo_1.storeSplitMergeInfo;
    } });
    var StateInit_1 = requireStateInit();
    Object.defineProperty(exports, "loadStateInit", { enumerable: true, get: function() {
      return StateInit_1.loadStateInit;
    } });
    Object.defineProperty(exports, "storeStateInit", { enumerable: true, get: function() {
      return StateInit_1.storeStateInit;
    } });
    var StorageInfo_1 = requireStorageInfo();
    Object.defineProperty(exports, "loadStorageInfo", { enumerable: true, get: function() {
      return StorageInfo_1.loadStorageInfo;
    } });
    Object.defineProperty(exports, "storeStorageInfo", { enumerable: true, get: function() {
      return StorageInfo_1.storeStorageInfo;
    } });
    var StorageUsed_1 = requireStorageUsed();
    Object.defineProperty(exports, "loadStorageUsed", { enumerable: true, get: function() {
      return StorageUsed_1.loadStorageUsed;
    } });
    Object.defineProperty(exports, "storeStorageUsed", { enumerable: true, get: function() {
      return StorageUsed_1.storeStorageUsed;
    } });
    var TickTock_1 = requireTickTock();
    Object.defineProperty(exports, "loadTickTock", { enumerable: true, get: function() {
      return TickTock_1.loadTickTock;
    } });
    Object.defineProperty(exports, "storeTickTock", { enumerable: true, get: function() {
      return TickTock_1.storeTickTock;
    } });
    var Transaction_1 = requireTransaction();
    Object.defineProperty(exports, "loadTransaction", { enumerable: true, get: function() {
      return Transaction_1.loadTransaction;
    } });
    Object.defineProperty(exports, "storeTransaction", { enumerable: true, get: function() {
      return Transaction_1.storeTransaction;
    } });
    var TransactionActionPhase_1 = requireTransactionActionPhase();
    Object.defineProperty(exports, "loadTransactionActionPhase", { enumerable: true, get: function() {
      return TransactionActionPhase_1.loadTransactionActionPhase;
    } });
    Object.defineProperty(exports, "storeTransactionActionPhase", { enumerable: true, get: function() {
      return TransactionActionPhase_1.storeTransactionActionPhase;
    } });
    var TransactionBouncePhase_1 = requireTransactionBouncePhase();
    Object.defineProperty(exports, "loadTransactionBouncePhase", { enumerable: true, get: function() {
      return TransactionBouncePhase_1.loadTransactionBouncePhase;
    } });
    Object.defineProperty(exports, "storeTransactionBouncePhase", { enumerable: true, get: function() {
      return TransactionBouncePhase_1.storeTransactionBouncePhase;
    } });
    var TransactionComputePhase_1 = requireTransactionComputePhase();
    Object.defineProperty(exports, "loadTransactionComputePhase", { enumerable: true, get: function() {
      return TransactionComputePhase_1.loadTransactionComputePhase;
    } });
    Object.defineProperty(exports, "storeTransactionComputePhase", { enumerable: true, get: function() {
      return TransactionComputePhase_1.storeTransactionComputePhase;
    } });
    var TransactionCreditPhase_1 = requireTransactionCreditPhase();
    Object.defineProperty(exports, "loadTransactionCreditPhase", { enumerable: true, get: function() {
      return TransactionCreditPhase_1.loadTransactionCreditPhase;
    } });
    Object.defineProperty(exports, "storeTransactionCreditPhase", { enumerable: true, get: function() {
      return TransactionCreditPhase_1.storeTransactionCreditPhase;
    } });
    var TransactionDescription_1 = requireTransactionDescription();
    Object.defineProperty(exports, "loadTransactionDescription", { enumerable: true, get: function() {
      return TransactionDescription_1.loadTransactionDescription;
    } });
    Object.defineProperty(exports, "storeTransactionDescription", { enumerable: true, get: function() {
      return TransactionDescription_1.storeTransactionDescription;
    } });
    var TransactionStoragePhase_1 = requireTransactionStoragePhase();
    Object.defineProperty(exports, "loadTransactionStoragePhase", { enumerable: true, get: function() {
      return TransactionStoragePhase_1.loadTransactionStoragePhase;
    } });
    Object.defineProperty(exports, "storeTransactionsStoragePhase", { enumerable: true, get: function() {
      return TransactionStoragePhase_1.storeTransactionsStoragePhase;
    } });
  })(_export);
  return _export;
}
var openContract = {};
var hasRequiredOpenContract;
function requireOpenContract() {
  if (hasRequiredOpenContract) return openContract;
  hasRequiredOpenContract = 1;
  Object.defineProperty(openContract, "__esModule", { value: true });
  openContract.openContract = void 0;
  const Address_1 = requireAddress();
  const Cell_1 = requireCell();
  function openContract$12(src2, factory) {
    let address;
    let init = null;
    if (!Address_1.Address.isAddress(src2.address)) {
      throw Error("Invalid address");
    }
    address = src2.address;
    if (src2.init) {
      if (!(src2.init.code instanceof Cell_1.Cell)) {
        throw Error("Invalid init.code");
      }
      if (!(src2.init.data instanceof Cell_1.Cell)) {
        throw Error("Invalid init.data");
      }
      init = src2.init;
    }
    let executor = factory({ address, init });
    return new Proxy(src2, {
      get(target, prop) {
        const value = target[prop];
        if (typeof prop === "string" && (prop.startsWith("get") || prop.startsWith("send") || prop.startsWith("is"))) {
          if (typeof value === "function") {
            return (...args) => value.apply(target, [executor, ...args]);
          }
        }
        return value;
      }
    });
  }
  openContract.openContract = openContract$12;
  return openContract;
}
var ComputeError = {};
var hasRequiredComputeError;
function requireComputeError() {
  if (hasRequiredComputeError) return ComputeError;
  hasRequiredComputeError = 1;
  Object.defineProperty(ComputeError, "__esModule", { value: true });
  ComputeError.ComputeError = void 0;
  let ComputeError$12 = class ComputeError2 extends Error {
    constructor(message, exitCode, opts) {
      super(message);
      this.exitCode = exitCode;
      this.debugLogs = opts && opts.debugLogs ? opts.debugLogs : null;
      this.logs = opts && opts.logs ? opts.logs : null;
      Object.setPrototypeOf(this, ComputeError2.prototype);
    }
  };
  ComputeError.ComputeError = ComputeError$12;
  return ComputeError;
}
var getMethodId = {};
var hasRequiredGetMethodId;
function requireGetMethodId() {
  if (hasRequiredGetMethodId) return getMethodId;
  hasRequiredGetMethodId = 1;
  Object.defineProperty(getMethodId, "__esModule", { value: true });
  getMethodId.getMethodId = void 0;
  const TABLE = new Int16Array([
    0,
    4129,
    8258,
    12387,
    16516,
    20645,
    24774,
    28903,
    33032,
    37161,
    41290,
    45419,
    49548,
    53677,
    57806,
    61935,
    4657,
    528,
    12915,
    8786,
    21173,
    17044,
    29431,
    25302,
    37689,
    33560,
    45947,
    41818,
    54205,
    50076,
    62463,
    58334,
    9314,
    13379,
    1056,
    5121,
    25830,
    29895,
    17572,
    21637,
    42346,
    46411,
    34088,
    38153,
    58862,
    62927,
    50604,
    54669,
    13907,
    9842,
    5649,
    1584,
    30423,
    26358,
    22165,
    18100,
    46939,
    42874,
    38681,
    34616,
    63455,
    59390,
    55197,
    51132,
    18628,
    22757,
    26758,
    30887,
    2112,
    6241,
    10242,
    14371,
    51660,
    55789,
    59790,
    63919,
    35144,
    39273,
    43274,
    47403,
    23285,
    19156,
    31415,
    27286,
    6769,
    2640,
    14899,
    10770,
    56317,
    52188,
    64447,
    60318,
    39801,
    35672,
    47931,
    43802,
    27814,
    31879,
    19684,
    23749,
    11298,
    15363,
    3168,
    7233,
    60846,
    64911,
    52716,
    56781,
    44330,
    48395,
    36200,
    40265,
    32407,
    28342,
    24277,
    20212,
    15891,
    11826,
    7761,
    3696,
    65439,
    61374,
    57309,
    53244,
    48923,
    44858,
    40793,
    36728,
    37256,
    33193,
    45514,
    41451,
    53516,
    49453,
    61774,
    57711,
    4224,
    161,
    12482,
    8419,
    20484,
    16421,
    28742,
    24679,
    33721,
    37784,
    41979,
    46042,
    49981,
    54044,
    58239,
    62302,
    689,
    4752,
    8947,
    13010,
    16949,
    21012,
    25207,
    29270,
    46570,
    42443,
    38312,
    34185,
    62830,
    58703,
    54572,
    50445,
    13538,
    9411,
    5280,
    1153,
    29798,
    25671,
    21540,
    17413,
    42971,
    47098,
    34713,
    38840,
    59231,
    63358,
    50973,
    55100,
    9939,
    14066,
    1681,
    5808,
    26199,
    30326,
    17941,
    22068,
    55628,
    51565,
    63758,
    59695,
    39368,
    35305,
    47498,
    43435,
    22596,
    18533,
    30726,
    26663,
    6336,
    2273,
    14466,
    10403,
    52093,
    56156,
    60223,
    64286,
    35833,
    39896,
    43963,
    48026,
    19061,
    23124,
    27191,
    31254,
    2801,
    6864,
    10931,
    14994,
    64814,
    60687,
    56684,
    52557,
    48554,
    44427,
    40424,
    36297,
    31782,
    27655,
    23652,
    19525,
    15522,
    11395,
    7392,
    3265,
    61215,
    65342,
    53085,
    57212,
    44955,
    49082,
    36825,
    40952,
    28183,
    32310,
    20053,
    24180,
    11923,
    16050,
    3793,
    7920
  ]);
  function crc162(data) {
    if (!(data instanceof Buffer)) {
      data = Buffer.from(data);
    }
    let crc = 0;
    for (let index = 0; index < data.length; index++) {
      const byte = data[index];
      crc = (TABLE[(crc >> 8 ^ byte) & 255] ^ crc << 8) & 65535;
    }
    return crc;
  }
  function getMethodId$12(name) {
    return crc162(name) & 65535 | 65536;
  }
  getMethodId.getMethodId = getMethodId$12;
  return getMethodId;
}
var safeSign = {};
var hasRequiredSafeSign;
function requireSafeSign() {
  if (hasRequiredSafeSign) return safeSign;
  hasRequiredSafeSign = 1;
  Object.defineProperty(safeSign, "__esModule", { value: true });
  safeSign.safeSignVerify = safeSign.safeSign = void 0;
  const crypto_1 = requireDist$6();
  const MIN_SEED_LENGTH = 8;
  const MAX_SEED_LENGTH = 64;
  function createSafeSignHash(cell, seed) {
    let seedData = Buffer.from(seed);
    if (seedData.length > MAX_SEED_LENGTH) {
      throw Error("Seed can	 be longer than 64 bytes");
    }
    if (seedData.length < MIN_SEED_LENGTH) {
      throw Error("Seed must be at least 8 bytes");
    }
    return (0, crypto_1.sha256_sync)(Buffer.concat([Buffer.from([255, 255]), seedData, cell.hash()]));
  }
  function safeSign$12(cell, secretKey, seed = "ton-safe-sign-magic") {
    return (0, crypto_1.sign)(createSafeSignHash(cell, seed), secretKey);
  }
  safeSign.safeSign = safeSign$12;
  function safeSignVerify(cell, signature, publicKey, seed = "ton-safe-sign-magic") {
    return (0, crypto_1.signVerify)(createSafeSignHash(cell, seed), signature, publicKey);
  }
  safeSign.safeSignVerify = safeSignVerify;
  return safeSign;
}
var hasRequiredDist$4;
function requireDist$4() {
  if (hasRequiredDist$4) return dist$3;
  hasRequiredDist$4 = 1;
  (function(exports) {
    var __createBinding = dist$3 && dist$3.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = dist$3 && dist$3.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.safeSignVerify = exports.safeSign = exports.getMethodId = exports.base32Encode = exports.base32Decode = exports.crc32c = exports.crc16 = exports.fromNano = exports.toNano = exports.ComputeError = exports.openContract = exports.TupleBuilder = exports.TupleReader = exports.serializeTuple = exports.parseTuple = exports.generateMerkleUpdate = exports.generateMerkleProofDirect = exports.generateMerkleProof = exports.exoticPruned = exports.exoticMerkleUpdate = exports.convertToMerkleProof = exports.exoticMerkleProof = exports.Dictionary = exports.Cell = exports.CellType = exports.Slice = exports.beginCell = exports.Builder = exports.BitBuilder = exports.BitReader = exports.BitString = exports.contractAddress = exports.ADNLAddress = exports.ExternalAddress = exports.address = exports.Address = void 0;
    var Address_1 = requireAddress();
    Object.defineProperty(exports, "Address", { enumerable: true, get: function() {
      return Address_1.Address;
    } });
    Object.defineProperty(exports, "address", { enumerable: true, get: function() {
      return Address_1.address;
    } });
    var ExternalAddress_1 = requireExternalAddress();
    Object.defineProperty(exports, "ExternalAddress", { enumerable: true, get: function() {
      return ExternalAddress_1.ExternalAddress;
    } });
    var ADNLAddress_1 = requireADNLAddress();
    Object.defineProperty(exports, "ADNLAddress", { enumerable: true, get: function() {
      return ADNLAddress_1.ADNLAddress;
    } });
    var contractAddress_1 = requireContractAddress();
    Object.defineProperty(exports, "contractAddress", { enumerable: true, get: function() {
      return contractAddress_1.contractAddress;
    } });
    var BitString_1 = requireBitString();
    Object.defineProperty(exports, "BitString", { enumerable: true, get: function() {
      return BitString_1.BitString;
    } });
    var BitReader_1 = requireBitReader();
    Object.defineProperty(exports, "BitReader", { enumerable: true, get: function() {
      return BitReader_1.BitReader;
    } });
    var BitBuilder_1 = requireBitBuilder();
    Object.defineProperty(exports, "BitBuilder", { enumerable: true, get: function() {
      return BitBuilder_1.BitBuilder;
    } });
    var Builder_12 = requireBuilder$1();
    Object.defineProperty(exports, "Builder", { enumerable: true, get: function() {
      return Builder_12.Builder;
    } });
    Object.defineProperty(exports, "beginCell", { enumerable: true, get: function() {
      return Builder_12.beginCell;
    } });
    var Slice_1 = requireSlice();
    Object.defineProperty(exports, "Slice", { enumerable: true, get: function() {
      return Slice_1.Slice;
    } });
    var CellType_1 = requireCellType();
    Object.defineProperty(exports, "CellType", { enumerable: true, get: function() {
      return CellType_1.CellType;
    } });
    var Cell_1 = requireCell();
    Object.defineProperty(exports, "Cell", { enumerable: true, get: function() {
      return Cell_1.Cell;
    } });
    var Dictionary_1 = requireDictionary();
    Object.defineProperty(exports, "Dictionary", { enumerable: true, get: function() {
      return Dictionary_1.Dictionary;
    } });
    var exoticMerkleProof_1 = requireExoticMerkleProof();
    Object.defineProperty(exports, "exoticMerkleProof", { enumerable: true, get: function() {
      return exoticMerkleProof_1.exoticMerkleProof;
    } });
    Object.defineProperty(exports, "convertToMerkleProof", { enumerable: true, get: function() {
      return exoticMerkleProof_1.convertToMerkleProof;
    } });
    var exoticMerkleUpdate_1 = requireExoticMerkleUpdate();
    Object.defineProperty(exports, "exoticMerkleUpdate", { enumerable: true, get: function() {
      return exoticMerkleUpdate_1.exoticMerkleUpdate;
    } });
    var exoticPruned_1 = requireExoticPruned();
    Object.defineProperty(exports, "exoticPruned", { enumerable: true, get: function() {
      return exoticPruned_1.exoticPruned;
    } });
    var generateMerkleProof_1 = requireGenerateMerkleProof();
    Object.defineProperty(exports, "generateMerkleProof", { enumerable: true, get: function() {
      return generateMerkleProof_1.generateMerkleProof;
    } });
    Object.defineProperty(exports, "generateMerkleProofDirect", { enumerable: true, get: function() {
      return generateMerkleProof_1.generateMerkleProofDirect;
    } });
    var generateMerkleUpdate_1 = requireGenerateMerkleUpdate();
    Object.defineProperty(exports, "generateMerkleUpdate", { enumerable: true, get: function() {
      return generateMerkleUpdate_1.generateMerkleUpdate;
    } });
    var tuple_1 = requireTuple();
    Object.defineProperty(exports, "parseTuple", { enumerable: true, get: function() {
      return tuple_1.parseTuple;
    } });
    Object.defineProperty(exports, "serializeTuple", { enumerable: true, get: function() {
      return tuple_1.serializeTuple;
    } });
    var reader_1 = requireReader();
    Object.defineProperty(exports, "TupleReader", { enumerable: true, get: function() {
      return reader_1.TupleReader;
    } });
    var builder_1 = requireBuilder();
    Object.defineProperty(exports, "TupleBuilder", { enumerable: true, get: function() {
      return builder_1.TupleBuilder;
    } });
    __exportStar(require_export(), exports);
    var openContract_1 = requireOpenContract();
    Object.defineProperty(exports, "openContract", { enumerable: true, get: function() {
      return openContract_1.openContract;
    } });
    var ComputeError_1 = requireComputeError();
    Object.defineProperty(exports, "ComputeError", { enumerable: true, get: function() {
      return ComputeError_1.ComputeError;
    } });
    var convert_1 = requireConvert();
    Object.defineProperty(exports, "toNano", { enumerable: true, get: function() {
      return convert_1.toNano;
    } });
    Object.defineProperty(exports, "fromNano", { enumerable: true, get: function() {
      return convert_1.fromNano;
    } });
    var crc16_1 = requireCrc16();
    Object.defineProperty(exports, "crc16", { enumerable: true, get: function() {
      return crc16_1.crc16;
    } });
    var crc32c_1 = requireCrc32c();
    Object.defineProperty(exports, "crc32c", { enumerable: true, get: function() {
      return crc32c_1.crc32c;
    } });
    var base32_1 = requireBase32();
    Object.defineProperty(exports, "base32Decode", { enumerable: true, get: function() {
      return base32_1.base32Decode;
    } });
    Object.defineProperty(exports, "base32Encode", { enumerable: true, get: function() {
      return base32_1.base32Encode;
    } });
    var getMethodId_1 = requireGetMethodId();
    Object.defineProperty(exports, "getMethodId", { enumerable: true, get: function() {
      return getMethodId_1.getMethodId;
    } });
    var safeSign_1 = requireSafeSign();
    Object.defineProperty(exports, "safeSign", { enumerable: true, get: function() {
      return safeSign_1.safeSign;
    } });
    Object.defineProperty(exports, "safeSignVerify", { enumerable: true, get: function() {
      return safeSign_1.safeSignVerify;
    } });
  })(dist$3);
  return dist$3;
}
var TLBRuntime = {};
var build = {};
var ast = {};
var hasRequiredAst;
function requireAst() {
  if (hasRequiredAst) return ast;
  hasRequiredAst = 1;
  Object.defineProperty(ast, "__esModule", { value: true });
  ast.TLBCode = ast.TLBType = ast.TLBConstructor = ast.TLBParameter = ast.TLBVariable = ast.TLBVarExpr = ast.TLBUnaryOp = ast.TLBNumberExpr = ast.TLBBinaryOp = void 0;
  class TLBBinaryOp {
    constructor(left, right, operation, variables = /* @__PURE__ */ new Set([...left.variables, ...right.variables]), hasNeg = left.hasNeg || right.hasNeg) {
      this.left = left;
      this.right = right;
      this.operation = operation;
      this.variables = variables;
      this.hasNeg = hasNeg;
    }
  }
  ast.TLBBinaryOp = TLBBinaryOp;
  class TLBNumberExpr {
    constructor(n, variables = /* @__PURE__ */ new Set(), hasNeg = false) {
      this.n = n;
      this.variables = variables;
      this.hasNeg = hasNeg;
    }
  }
  ast.TLBNumberExpr = TLBNumberExpr;
  class TLBUnaryOp {
    constructor(value, operation, variables = value.variables, hasNeg = value.hasNeg) {
      this.value = value;
      this.operation = operation;
      this.variables = variables;
      this.hasNeg = hasNeg;
    }
  }
  ast.TLBUnaryOp = TLBUnaryOp;
  class TLBVarExpr {
    constructor(x, variables = /* @__PURE__ */ new Set(), hasNeg = false) {
      this.x = x;
      this.variables = variables;
      this.hasNeg = hasNeg;
      if (variables.size == 0) {
        variables.add(x);
      }
    }
  }
  ast.TLBVarExpr = TLBVarExpr;
  class TLBVariable {
    constructor(isConst, negated, type, name, isField, deriveExpr, initialExpr) {
      this.isConst = isConst;
      this.negated = negated;
      this.type = type;
      this.name = name;
      this.isField = isField;
      this.deriveExpr = deriveExpr;
      this.initialExpr = initialExpr;
    }
  }
  ast.TLBVariable = TLBVariable;
  class TLBParameter {
    constructor(variable, paramExpr, argName) {
      this.variable = variable;
      this.paramExpr = paramExpr;
      this.argName = argName;
    }
  }
  ast.TLBParameter = TLBParameter;
  class TLBConstructor {
    constructor(parameters, variables, variablesMap, parametersMap, name, fields, tag, constraints, declaration, tlbType) {
      this.parameters = parameters;
      this.variables = variables;
      this.variablesMap = variablesMap;
      this.parametersMap = parametersMap;
      this.name = name;
      this.fields = fields;
      this.tag = tag;
      this.constraints = constraints;
      this.declaration = declaration;
      this.tlbType = tlbType;
    }
  }
  ast.TLBConstructor = TLBConstructor;
  class TLBType {
    constructor(name, constructors) {
      this.name = name;
      this.constructors = constructors;
    }
  }
  ast.TLBType = TLBType;
  class TLBCode {
    constructor(types2) {
      this.types = types2;
    }
  }
  ast.TLBCode = TLBCode;
  return ast;
}
var main = {};
var dist$2 = {};
var intermediate = {};
var main$1 = { exports: {} };
function isValidType(type) {
  return type === "description" || type === "string" || type === "code";
}
function Failure$2(pexpr, text, type) {
  if (!isValidType(type)) {
    throw new Error("invalid Failure type: " + type);
  }
  this.pexpr = pexpr;
  this.text = text;
  this.type = type;
  this.fluffy = false;
}
Failure$2.prototype.getPExpr = function() {
  return this.pexpr;
};
Failure$2.prototype.getText = function() {
  return this.text;
};
Failure$2.prototype.getType = function() {
  return this.type;
};
Failure$2.prototype.isDescription = function() {
  return this.type === "description";
};
Failure$2.prototype.isStringTerminal = function() {
  return this.type === "string";
};
Failure$2.prototype.isCode = function() {
  return this.type === "code";
};
Failure$2.prototype.isFluffy = function() {
  return this.fluffy;
};
Failure$2.prototype.makeFluffy = function() {
  this.fluffy = true;
};
Failure$2.prototype.clearFluffy = function() {
  this.fluffy = false;
};
Failure$2.prototype.subsumes = function(that) {
  return this.getText() === that.getText() && this.type === that.type && (!this.isFluffy() || this.isFluffy() && that.isFluffy());
};
Failure$2.prototype.toString = function() {
  return this.type === "string" ? JSON.stringify(this.getText()) : this.getText();
};
Failure$2.prototype.clone = function() {
  const failure = new Failure$2(this.pexpr, this.text, this.type);
  if (this.isFluffy()) {
    failure.makeFluffy();
  }
  return failure;
};
Failure$2.prototype.toKey = function() {
  return this.toString() + "#" + this.type;
};
var Failure_1 = Failure$2;
var common$l = {};
(function(exports) {
  exports.abstract = function(optMethodName) {
    const methodName = optMethodName || "";
    return function() {
      throw new Error(
        "this method " + methodName + " is abstract! (it has no implementation in class " + this.constructor.name + ")"
      );
    };
  };
  exports.assert = function(cond, message) {
    if (!cond) {
      throw new Error(message || "Assertion failed");
    }
  };
  exports.defineLazyProperty = function(obj, propName, getterFn) {
    let memo;
    Object.defineProperty(obj, propName, {
      get() {
        if (!memo) {
          memo = getterFn.call(this);
        }
        return memo;
      }
    });
  };
  exports.clone = function(obj) {
    if (obj) {
      return Object.assign({}, obj);
    }
    return obj;
  };
  exports.repeatFn = function(fn, n) {
    const arr = [];
    while (n-- > 0) {
      arr.push(fn());
    }
    return arr;
  };
  exports.repeatStr = function(str, n) {
    return new Array(n + 1).join(str);
  };
  exports.repeat = function(x, n) {
    return exports.repeatFn(() => x, n);
  };
  exports.getDuplicates = function(array) {
    const duplicates = [];
    for (let idx = 0; idx < array.length; idx++) {
      const x = array[idx];
      if (array.lastIndexOf(x) !== idx && duplicates.indexOf(x) < 0) {
        duplicates.push(x);
      }
    }
    return duplicates;
  };
  exports.copyWithoutDuplicates = function(array) {
    const noDuplicates = [];
    array.forEach((entry) => {
      if (noDuplicates.indexOf(entry) < 0) {
        noDuplicates.push(entry);
      }
    });
    return noDuplicates;
  };
  exports.isSyntactic = function(ruleName) {
    const firstChar = ruleName[0];
    return firstChar === firstChar.toUpperCase();
  };
  exports.isLexical = function(ruleName) {
    return !exports.isSyntactic(ruleName);
  };
  exports.padLeft = function(str, len, optChar) {
    const ch = optChar || " ";
    if (str.length < len) {
      return exports.repeatStr(ch, len - str.length) + str;
    }
    return str;
  };
  exports.StringBuffer = function() {
    this.strings = [];
  };
  exports.StringBuffer.prototype.append = function(str) {
    this.strings.push(str);
  };
  exports.StringBuffer.prototype.contents = function() {
    return this.strings.join("");
  };
  const escapeUnicode = (str) => String.fromCodePoint(parseInt(str, 16));
  exports.unescapeCodePoint = function(s) {
    if (s.charAt(0) === "\\") {
      switch (s.charAt(1)) {
        case "b":
          return "\b";
        case "f":
          return "\f";
        case "n":
          return "\n";
        case "r":
          return "\r";
        case "t":
          return "	";
        case "v":
          return "\v";
        case "x":
          return escapeUnicode(s.slice(2, 4));
        case "u":
          return s.charAt(2) === "{" ? escapeUnicode(s.slice(3, -1)) : escapeUnicode(s.slice(2, 6));
        default:
          return s.charAt(1);
      }
    } else {
      return s;
    }
  };
  exports.unexpectedObjToString = function(obj) {
    if (obj == null) {
      return String(obj);
    }
    const baseToString = Object.prototype.toString.call(obj);
    try {
      let typeName;
      if (obj.constructor && obj.constructor.name) {
        typeName = obj.constructor.name;
      } else if (baseToString.indexOf("[object ") === 0) {
        typeName = baseToString.slice(8, -1);
      } else {
        typeName = typeof obj;
      }
      return typeName + ": " + JSON.stringify(String(obj));
    } catch (e) {
      return baseToString;
    }
  };
})(common$l);
const common$k = common$l;
let Node$1 = class Node2 {
  constructor(matchLength) {
    this.matchLength = matchLength;
  }
  get ctorName() {
    throw new Error("subclass responsibility");
  }
  numChildren() {
    return this.children ? this.children.length : 0;
  }
  childAt(idx) {
    if (this.children) {
      return this.children[idx];
    }
  }
  indexOfChild(arg) {
    return this.children.indexOf(arg);
  }
  hasChildren() {
    return this.numChildren() > 0;
  }
  hasNoChildren() {
    return !this.hasChildren();
  }
  onlyChild() {
    if (this.numChildren() !== 1) {
      throw new Error(
        "cannot get only child of a node of type " + this.ctorName + " (it has " + this.numChildren() + " children)"
      );
    } else {
      return this.firstChild();
    }
  }
  firstChild() {
    if (this.hasNoChildren()) {
      throw new Error(
        "cannot get first child of a " + this.ctorName + " node, which has no children"
      );
    } else {
      return this.childAt(0);
    }
  }
  lastChild() {
    if (this.hasNoChildren()) {
      throw new Error(
        "cannot get last child of a " + this.ctorName + " node, which has no children"
      );
    } else {
      return this.childAt(this.numChildren() - 1);
    }
  }
  childBefore(child) {
    const childIdx = this.indexOfChild(child);
    if (childIdx < 0) {
      throw new Error("Node.childBefore() called w/ an argument that is not a child");
    } else if (childIdx === 0) {
      throw new Error("cannot get child before first child");
    } else {
      return this.childAt(childIdx - 1);
    }
  }
  childAfter(child) {
    const childIdx = this.indexOfChild(child);
    if (childIdx < 0) {
      throw new Error("Node.childAfter() called w/ an argument that is not a child");
    } else if (childIdx === this.numChildren() - 1) {
      throw new Error("cannot get child after last child");
    } else {
      return this.childAt(childIdx + 1);
    }
  }
  isTerminal() {
    return false;
  }
  isNonterminal() {
    return false;
  }
  isIteration() {
    return false;
  }
  isOptional() {
    return false;
  }
};
class TerminalNode$2 extends Node$1 {
  get ctorName() {
    return "_terminal";
  }
  isTerminal() {
    return true;
  }
  get primitiveValue() {
    throw new Error("The `primitiveValue` property was removed in Ohm v17.");
  }
}
class NonterminalNode$1 extends Node$1 {
  constructor(ruleName, children, childOffsets, matchLength) {
    super(matchLength);
    this.ruleName = ruleName;
    this.children = children;
    this.childOffsets = childOffsets;
  }
  get ctorName() {
    return this.ruleName;
  }
  isNonterminal() {
    return true;
  }
  isLexical() {
    return common$k.isLexical(this.ctorName);
  }
  isSyntactic() {
    return common$k.isSyntactic(this.ctorName);
  }
}
class IterationNode$2 extends Node$1 {
  constructor(children, childOffsets, matchLength, isOptional) {
    super(matchLength);
    this.children = children;
    this.childOffsets = childOffsets;
    this.optional = isOptional;
  }
  get ctorName() {
    return "_iter";
  }
  isIteration() {
    return true;
  }
  isOptional() {
    return this.optional;
  }
}
var nodes$1$1 = {
  TerminalNode: TerminalNode$2,
  NonterminalNode: NonterminalNode$1,
  IterationNode: IterationNode$2
};
var pexprsMain = {};
var UnicodeCategories$1 = {
  // Letters
  Lu: /[A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AE\uA7B0-\uA7B4\uA7B6\uFF21-\uFF3A]|\uD801[\uDC00-\uDC27\uDCB0-\uDCD3]|\uD803[\uDC80-\uDCB2]|\uD806[\uDCA0-\uDCBF]|\uD835[\uDC00-\uDC19\uDC34-\uDC4D\uDC68-\uDC81\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB5\uDCD0-\uDCE9\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD38\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD6C-\uDD85\uDDA0-\uDDB9\uDDD4-\uDDED\uDE08-\uDE21\uDE3C-\uDE55\uDE70-\uDE89\uDEA8-\uDEC0\uDEE2-\uDEFA\uDF1C-\uDF34\uDF56-\uDF6E\uDF90-\uDFA8\uDFCA]|\uD83A[\uDD00-\uDD21]/,
  Ll: /[a-z\xB5\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0561-\u0587\u13F8-\u13FD\u1C80-\u1C88\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7B5\uA7B7\uA7FA\uAB30-\uAB5A\uAB60-\uAB65\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A]|\uD801[\uDC28-\uDC4F\uDCD8-\uDCFB]|\uD803[\uDCC0-\uDCF2]|\uD806[\uDCC0-\uDCDF]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]|\uD83A[\uDD22-\uDD43]/,
  Lt: /[\u01C5\u01C8\u01CB\u01F2\u1F88-\u1F8F\u1F98-\u1F9F\u1FA8-\u1FAF\u1FBC\u1FCC\u1FFC]/,
  Lm: /[\u02B0-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0374\u037A\u0559\u0640\u06E5\u06E6\u07F4\u07F5\u07FA\u081A\u0824\u0828\u0971\u0E46\u0EC6\u10FC\u17D7\u1843\u1AA7\u1C78-\u1C7D\u1D2C-\u1D6A\u1D78\u1D9B-\u1DBF\u2071\u207F\u2090-\u209C\u2C7C\u2C7D\u2D6F\u2E2F\u3005\u3031-\u3035\u303B\u309D\u309E\u30FC-\u30FE\uA015\uA4F8-\uA4FD\uA60C\uA67F\uA69C\uA69D\uA717-\uA71F\uA770\uA788\uA7F8\uA7F9\uA9CF\uA9E6\uAA70\uAADD\uAAF3\uAAF4\uAB5C-\uAB5F\uFF70\uFF9E\uFF9F]|\uD81A[\uDF40-\uDF43]|\uD81B[\uDF93-\uDF9F\uDFE0]/,
  Lo: /[\xAA\xBA\u01BB\u01C0-\u01C3\u0294\u05D0-\u05EA\u05F0-\u05F2\u0620-\u063F\u0641-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u0800-\u0815\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0972-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E45\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10D0-\u10FA\u10FD-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17DC\u1820-\u1842\u1844-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C77\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u2135-\u2138\u2D30-\u2D67\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3006\u303C\u3041-\u3096\u309F\u30A1-\u30FA\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA014\uA016-\uA48C\uA4D0-\uA4F7\uA500-\uA60B\uA610-\uA61F\uA62A\uA62B\uA66E\uA6A0-\uA6E5\uA78F\uA7F7\uA7FB-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9E0-\uA9E4\uA9E7-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA6F\uAA71-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB\uAADC\uAAE0-\uAAEA\uAAF2\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF66-\uFF6F\uFF71-\uFF9D\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC50-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
  // Numbers
  Nl: /[\u16EE-\u16F0\u2160-\u2182\u2185-\u2188\u3007\u3021-\u3029\u3038-\u303A\uA6E6-\uA6EF]|\uD800[\uDD40-\uDD74\uDF41\uDF4A\uDFD1-\uDFD5]|\uD809[\uDC00-\uDC6E]/,
  Nd: /[0-9\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19]|\uD801[\uDCA0-\uDCA9]|\uD804[\uDC66-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDEF0-\uDEF9]|[\uD805\uD807][\uDC50-\uDC59\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDF30-\uDF39]|\uD806[\uDCE0-\uDCE9]|\uD81A[\uDE60-\uDE69\uDF50-\uDF59]|\uD835[\uDFCE-\uDFFF]|\uD83A[\uDD50-\uDD59]/,
  // Marks
  Mn: /[\u0300-\u036F\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D4-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D01\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ABD\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFB-\u1DFF\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA8C4\uA8C5\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC01\uDC38-\uDC46\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDCA-\uDDCC\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3C\uDF40\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDCB3-\uDCB8\uDCBA\uDCBF\uDCC0\uDCC2\uDCC3\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD67-\uDD69\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uDB40[\uDD00-\uDDEF]/,
  Mc: /[\u0903-\u0903]|[\u093E-\u0940]|[\u0949-\u094C]|[\u0982-\u0983]|[\u09BE-\u09C0]|[\u09C7-\u09C8]|[\u09CB-\u09CC]|[\u09D7-\u09D7]|[\u0A3E-\u0A40]|[\u0A83-\u0A83]|[\u0ABE-\u0AC0]|[\u0AC9-\u0AC9]|[\u0ACB-\u0ACC]|[\u0B02-\u0B03]|[\u0B3E-\u0B3E]|[\u0B40-\u0B40]|[\u0B47-\u0B48]|[\u0B4B-\u0B4C]|[\u0B57-\u0B57]|[\u0B83-\u0B83]|[\u0BBE-\u0BBF]|[\u0BC1-\u0BC2]|[\u0BC6-\u0BC8]|[\u0BCA-\u0BCC]|[\u0BD7-\u0BD7]|[\u0C01-\u0C03]|[\u0C41-\u0C44]|[\u0C82-\u0C83]|[\u0CBE-\u0CBE]|[\u0CC0-\u0CC4]|[\u0CC7-\u0CC8]|[\u0CCA-\u0CCB]|[\u0CD5-\u0CD6]|[\u0D02-\u0D03]|[\u0D3E-\u0D40]|[\u0D46-\u0D48]|[\u0D4A-\u0D4C]|[\u0D57-\u0D57]|[\u0F3E-\u0F3F]|[\u0F7F-\u0F7F]/,
  // Punctuation, Connector
  Pc: /[_\u203F\u2040\u2054\uFE33\uFE34\uFE4D-\uFE4F\uFF3F]/,
  // Separator, Space
  Zs: /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/,
  // These two are not real Unicode categories, but our useful for Ohm.
  // L is a combination of all the letter categories.
  // Ltmo is a combination of Lt, Lm, and Lo.
  L: /[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
  Ltmo: /[\u01C5\u01C8\u01CB\u01F2\u1F88-\u1F8F\u1F98-\u1F9F\u1FA8-\u1FAF\u1FBC\u1FCC\u1FFC]|[\u02B0-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0374\u037A\u0559\u0640\u06E5\u06E6\u07F4\u07F5\u07FA\u081A\u0824\u0828\u0971\u0E46\u0EC6\u10FC\u17D7\u1843\u1AA7\u1C78-\u1C7D\u1D2C-\u1D6A\u1D78\u1D9B-\u1DBF\u2071\u207F\u2090-\u209C\u2C7C\u2C7D\u2D6F\u2E2F\u3005\u3031-\u3035\u303B\u309D\u309E\u30FC-\u30FE\uA015\uA4F8-\uA4FD\uA60C\uA67F\uA69C\uA69D\uA717-\uA71F\uA770\uA788\uA7F8\uA7F9\uA9CF\uA9E6\uAA70\uAADD\uAAF3\uAAF4\uAB5C-\uAB5F\uFF70\uFF9E\uFF9F]|\uD81A[\uDF40-\uDF43]|\uD81B[\uDF93-\uDF9F\uDFE0]|[\xAA\xBA\u01BB\u01C0-\u01C3\u0294\u05D0-\u05EA\u05F0-\u05F2\u0620-\u063F\u0641-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u0800-\u0815\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0972-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E45\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10D0-\u10FA\u10FD-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17DC\u1820-\u1842\u1844-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C77\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u2135-\u2138\u2D30-\u2D67\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3006\u303C\u3041-\u3096\u309F\u30A1-\u30FA\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA014\uA016-\uA48C\uA4D0-\uA4F7\uA500-\uA60B\uA610-\uA61F\uA62A\uA62B\uA66E\uA6A0-\uA6E5\uA78F\uA7F7\uA7FB-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9E0-\uA9E4\uA9E7-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA6F\uAA71-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB\uAADC\uAAE0-\uAAEA\uAAF2\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF66-\uFF6F\uFF71-\uFF9D\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC50-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/
};
const UnicodeCategories = UnicodeCategories$1;
const common$j = common$l;
class PExpr$1 {
  constructor() {
    if (this.constructor === PExpr$1) {
      throw new Error("PExpr cannot be instantiated -- it's abstract");
    }
  }
  // Set the `source` property to the interval containing the source for this expression.
  withSource(interval) {
    if (interval) {
      this.source = interval.trimmed();
    }
    return this;
  }
}
const any = Object.create(PExpr$1.prototype);
const end = Object.create(PExpr$1.prototype);
class Terminal$1 extends PExpr$1 {
  constructor(obj) {
    super();
    this.obj = obj;
  }
}
class Range extends PExpr$1 {
  constructor(from, to) {
    super();
    this.from = from;
    this.to = to;
    this.matchCodePoint = from.length > 1 || to.length > 1;
  }
}
class Param extends PExpr$1 {
  constructor(index) {
    super();
    this.index = index;
  }
}
class Alt extends PExpr$1 {
  constructor(terms) {
    super();
    this.terms = terms;
  }
}
class Extend extends Alt {
  constructor(superGrammar, name, body) {
    const origBody = superGrammar.rules[name].body;
    super([body, origBody]);
    this.superGrammar = superGrammar;
    this.name = name;
    this.body = body;
  }
}
class Splice extends Alt {
  constructor(superGrammar, ruleName, beforeTerms, afterTerms) {
    const origBody = superGrammar.rules[ruleName].body;
    super([...beforeTerms, origBody, ...afterTerms]);
    this.superGrammar = superGrammar;
    this.ruleName = ruleName;
    this.expansionPos = beforeTerms.length;
  }
}
class Seq extends PExpr$1 {
  constructor(factors) {
    super();
    this.factors = factors;
  }
}
class Iter extends PExpr$1 {
  constructor(expr) {
    super();
    this.expr = expr;
  }
}
class Star extends Iter {
}
class Plus extends Iter {
}
class Opt extends Iter {
}
Star.prototype.operator = "*";
Plus.prototype.operator = "+";
Opt.prototype.operator = "?";
Star.prototype.minNumMatches = 0;
Plus.prototype.minNumMatches = 1;
Opt.prototype.minNumMatches = 0;
Star.prototype.maxNumMatches = Number.POSITIVE_INFINITY;
Plus.prototype.maxNumMatches = Number.POSITIVE_INFINITY;
Opt.prototype.maxNumMatches = 1;
class Not extends PExpr$1 {
  constructor(expr) {
    super();
    this.expr = expr;
  }
}
class Lookahead extends PExpr$1 {
  constructor(expr) {
    super();
    this.expr = expr;
  }
}
class Lex extends PExpr$1 {
  constructor(expr) {
    super();
    this.expr = expr;
  }
}
class Apply extends PExpr$1 {
  constructor(ruleName, args = []) {
    super();
    this.ruleName = ruleName;
    this.args = args;
  }
  isSyntactic() {
    return common$j.isSyntactic(this.ruleName);
  }
  // This method just caches the result of `this.toString()` in a non-enumerable property.
  toMemoKey() {
    if (!this._memoKey) {
      Object.defineProperty(this, "_memoKey", { value: this.toString() });
    }
    return this._memoKey;
  }
}
class UnicodeChar extends PExpr$1 {
  constructor(category) {
    super();
    this.category = category;
    this.pattern = UnicodeCategories[category];
  }
}
pexprsMain.PExpr = PExpr$1;
pexprsMain.any = any;
pexprsMain.end = end;
pexprsMain.Terminal = Terminal$1;
pexprsMain.Range = Range;
pexprsMain.Param = Param;
pexprsMain.Alt = Alt;
pexprsMain.Extend = Extend;
pexprsMain.Splice = Splice;
pexprsMain.Seq = Seq;
pexprsMain.Iter = Iter;
pexprsMain.Star = Star;
pexprsMain.Plus = Plus;
pexprsMain.Opt = Opt;
pexprsMain.Not = Not;
pexprsMain.Lookahead = Lookahead;
pexprsMain.Lex = Lex;
pexprsMain.Apply = Apply;
pexprsMain.UnicodeChar = UnicodeChar;
const common$i = common$l;
const pexprs$l = pexprsMain;
pexprs$l.PExpr.prototype.allowsSkippingPrecedingSpace = common$i.abstract(
  "allowsSkippingPrecedingSpace"
);
pexprs$l.any.allowsSkippingPrecedingSpace = pexprs$l.end.allowsSkippingPrecedingSpace = pexprs$l.Apply.prototype.allowsSkippingPrecedingSpace = pexprs$l.Terminal.prototype.allowsSkippingPrecedingSpace = pexprs$l.Range.prototype.allowsSkippingPrecedingSpace = pexprs$l.UnicodeChar.prototype.allowsSkippingPrecedingSpace = function() {
  return true;
};
pexprs$l.Alt.prototype.allowsSkippingPrecedingSpace = pexprs$l.Iter.prototype.allowsSkippingPrecedingSpace = pexprs$l.Lex.prototype.allowsSkippingPrecedingSpace = pexprs$l.Lookahead.prototype.allowsSkippingPrecedingSpace = pexprs$l.Not.prototype.allowsSkippingPrecedingSpace = pexprs$l.Param.prototype.allowsSkippingPrecedingSpace = pexprs$l.Seq.prototype.allowsSkippingPrecedingSpace = function() {
  return false;
};
function Namespace$2() {
}
Namespace$2.prototype = /* @__PURE__ */ Object.create(null);
Namespace$2.asNamespace = function(objOrNamespace) {
  if (objOrNamespace instanceof Namespace$2) {
    return objOrNamespace;
  }
  return Namespace$2.createNamespace(objOrNamespace);
};
Namespace$2.createNamespace = function(optProps) {
  return Namespace$2.extend(Namespace$2.prototype, optProps);
};
Namespace$2.extend = function(namespace, optProps) {
  if (namespace !== Namespace$2.prototype && !(namespace instanceof Namespace$2)) {
    throw new TypeError("not a Namespace object: " + namespace);
  }
  const ns = Object.create(namespace, {
    constructor: {
      value: Namespace$2,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  return Object.assign(ns, optProps);
};
Namespace$2.toString = function(ns) {
  return Object.prototype.toString.call(ns);
};
var Namespace_1 = Namespace$2;
const { assert: assert$3 } = common$l;
const Namespace$1 = Namespace_1;
const pexprs$k = pexprsMain;
function createError(message, optInterval) {
  let e;
  if (optInterval) {
    e = new Error(optInterval.getLineAndColumnMessage() + message);
    e.shortMessage = message;
    e.interval = optInterval;
  } else {
    e = new Error(message);
  }
  return e;
}
function intervalSourcesDontMatch() {
  return createError("Interval sources don't match");
}
function grammarSyntaxError(matchFailure) {
  const e = new Error();
  Object.defineProperty(e, "message", {
    enumerable: true,
    get() {
      return matchFailure.message;
    }
  });
  Object.defineProperty(e, "shortMessage", {
    enumerable: true,
    get() {
      return "Expected " + matchFailure.getExpectedText();
    }
  });
  e.interval = matchFailure.getInterval();
  return e;
}
function undeclaredGrammar(grammarName, namespace, interval) {
  const message = namespace ? "Grammar " + grammarName + " is not declared in namespace " + Namespace$1.toString(namespace) : "Undeclared grammar " + grammarName;
  return createError(message, interval);
}
function duplicateGrammarDeclaration(grammar2, namespace) {
  return createError("Grammar " + grammar2.name + " is already declared in this namespace");
}
function undeclaredRule(ruleName, grammarName, optInterval) {
  return createError(
    "Rule " + ruleName + " is not declared in grammar " + grammarName,
    optInterval
  );
}
function cannotOverrideUndeclaredRule(ruleName, grammarName, optSource) {
  return createError(
    "Cannot override rule " + ruleName + " because it is not declared in " + grammarName,
    optSource
  );
}
function cannotExtendUndeclaredRule(ruleName, grammarName, optSource) {
  return createError(
    "Cannot extend rule " + ruleName + " because it is not declared in " + grammarName,
    optSource
  );
}
function duplicateRuleDeclaration(ruleName, grammarName, declGrammarName, optSource) {
  let message = "Duplicate declaration for rule '" + ruleName + "' in grammar '" + grammarName + "'";
  if (grammarName !== declGrammarName) {
    message += " (originally declared in '" + declGrammarName + "')";
  }
  return createError(message, optSource);
}
function wrongNumberOfParameters(ruleName, expected, actual, source) {
  return createError(
    "Wrong number of parameters for rule " + ruleName + " (expected " + expected + ", got " + actual + ")",
    source
  );
}
function wrongNumberOfArguments(ruleName, expected, actual, expr) {
  return createError(
    "Wrong number of arguments for rule " + ruleName + " (expected " + expected + ", got " + actual + ")",
    expr
  );
}
function duplicateParameterNames(ruleName, duplicates, source) {
  return createError(
    "Duplicate parameter names in rule " + ruleName + ": " + duplicates.join(", "),
    source
  );
}
function invalidParameter(ruleName, expr) {
  return createError(
    "Invalid parameter to rule " + ruleName + ": " + expr + " has arity " + expr.getArity() + ", but parameter expressions must have arity 1",
    expr.source
  );
}
const syntacticVsLexicalNote = "NOTE: A _syntactic rule_ is a rule whose name begins with a capital letter. See https://ohmjs.org/d/svl for more details.";
function applicationOfSyntacticRuleFromLexicalContext(ruleName, applyExpr) {
  return createError(
    "Cannot apply syntactic rule " + ruleName + " from here (inside a lexical context)",
    applyExpr.source
  );
}
function applySyntacticWithLexicalRuleApplication(applyExpr) {
  const { ruleName } = applyExpr;
  return createError(
    `applySyntactic is for syntactic rules, but '${ruleName}' is a lexical rule. ` + syntacticVsLexicalNote,
    applyExpr.source
  );
}
function unnecessaryExperimentalApplySyntactic(applyExpr) {
  return createError(
    "applySyntactic is not required here (in a syntactic context)",
    applyExpr.source
  );
}
function incorrectArgumentType(expectedType, expr) {
  return createError("Incorrect argument type: expected " + expectedType, expr.source);
}
function multipleSuperSplices(expr) {
  return createError("'...' can appear at most once in a rule body", expr.source);
}
function invalidCodePoint(applyWrapper) {
  const node = applyWrapper._node;
  assert$3(node && node.isNonterminal() && node.ctorName === "escapeChar_unicodeCodePoint");
  const digitIntervals = applyWrapper.children.slice(1, -1).map((d) => d.source);
  const fullInterval = digitIntervals[0].coverageWith(...digitIntervals.slice(1));
  return createError(
    `U+${fullInterval.contents} is not a valid Unicode code point`,
    fullInterval
  );
}
function kleeneExprHasNullableOperand(kleeneExpr, applicationStack) {
  const actuals = applicationStack.length > 0 ? applicationStack[applicationStack.length - 1].args : [];
  const expr = kleeneExpr.expr.substituteParams(actuals);
  let message = "Nullable expression " + expr + " is not allowed inside '" + kleeneExpr.operator + "' (possible infinite loop)";
  if (applicationStack.length > 0) {
    const stackTrace = applicationStack.map((app) => new pexprs$k.Apply(app.ruleName, app.args)).join("\n");
    message += "\nApplication stack (most recent application last):\n" + stackTrace;
  }
  return createError(message, kleeneExpr.expr.source);
}
function inconsistentArity(ruleName, expected, actual, expr) {
  return createError(
    "Rule " + ruleName + " involves an alternation which has inconsistent arity (expected " + expected + ", got " + actual + ")",
    expr.source
  );
}
function duplicatePropertyNames(duplicates) {
  return createError("Object pattern has duplicate property names: " + duplicates.join(", "));
}
function invalidConstructorCall(grammar2, ctorName, children) {
  return createError(
    "Attempt to invoke constructor " + ctorName + " with invalid or unexpected arguments"
  );
}
function multipleErrors(errors2) {
  const messages = errors2.map((e) => e.message);
  return createError(["Errors:"].concat(messages).join("\n- "), errors2[0].interval);
}
function missingSemanticAction(ctorName, name, type, stack) {
  let stackTrace = stack.slice(0, -1).map((info) => {
    const ans = "  " + info[0].name + " > " + info[1];
    return info.length === 3 ? ans + " for '" + info[2] + "'" : ans;
  }).join("\n");
  stackTrace += "\n  " + name + " > " + ctorName;
  let moreInfo = "";
  if (ctorName === "_iter") {
    moreInfo = [
      "\nNOTE: as of Ohm v16, there is no default action for iteration nodes  see ",
      "  https://ohmjs.org/d/dsa for details."
    ].join("\n");
  }
  const message = [
    `Missing semantic action for '${ctorName}' in ${type} '${name}'.${moreInfo}`,
    "Action stack (most recent call last):",
    stackTrace
  ].join("\n");
  const e = createError(message);
  e.name = "missingSemanticAction";
  return e;
}
var errors$9 = {
  applicationOfSyntacticRuleFromLexicalContext,
  applySyntacticWithLexicalRuleApplication,
  cannotExtendUndeclaredRule,
  cannotOverrideUndeclaredRule,
  duplicateGrammarDeclaration,
  duplicateParameterNames,
  duplicatePropertyNames,
  duplicateRuleDeclaration,
  inconsistentArity,
  incorrectArgumentType,
  intervalSourcesDontMatch,
  invalidCodePoint,
  invalidConstructorCall,
  invalidParameter,
  grammarSyntaxError,
  kleeneExprHasNullableOperand,
  missingSemanticAction,
  multipleSuperSplices,
  undeclaredGrammar,
  undeclaredRule,
  unnecessaryExperimentalApplySyntactic,
  wrongNumberOfArguments,
  wrongNumberOfParameters,
  throwErrors(errors2) {
    if (errors2.length === 1) {
      throw errors2[0];
    }
    if (errors2.length > 1) {
      throw multipleErrors(errors2);
    }
  }
};
var util$7 = {};
(function(exports) {
  const common2 = common$l;
  function padNumbersToEqualLength(arr) {
    let maxLen = 0;
    const strings2 = arr.map((n) => {
      const str = n.toString();
      maxLen = Math.max(maxLen, str.length);
      return str;
    });
    return strings2.map((s) => common2.padLeft(s, maxLen));
  }
  function strcpy(dest, src2, offset) {
    const origDestLen = dest.length;
    const start = dest.slice(0, offset);
    const end2 = dest.slice(offset + src2.length);
    return (start + src2 + end2).substr(0, origDestLen);
  }
  function lineAndColumnToMessage(...ranges) {
    const lineAndCol = this;
    const { offset } = lineAndCol;
    const { repeatStr } = common2;
    const sb = new common2.StringBuffer();
    sb.append("Line " + lineAndCol.lineNum + ", col " + lineAndCol.colNum + ":\n");
    const lineNumbers = padNumbersToEqualLength([
      lineAndCol.prevLine == null ? 0 : lineAndCol.lineNum - 1,
      lineAndCol.lineNum,
      lineAndCol.nextLine == null ? 0 : lineAndCol.lineNum + 1
    ]);
    const appendLine = (num, content2, prefix) => {
      sb.append(prefix + lineNumbers[num] + " | " + content2 + "\n");
    };
    if (lineAndCol.prevLine != null) {
      appendLine(0, lineAndCol.prevLine, "  ");
    }
    appendLine(1, lineAndCol.line, "> ");
    const lineLen = lineAndCol.line.length;
    let indicationLine = repeatStr(" ", lineLen + 1);
    for (let i = 0; i < ranges.length; ++i) {
      let startIdx = ranges[i][0];
      let endIdx = ranges[i][1];
      common2.assert(startIdx >= 0 && startIdx <= endIdx, "range start must be >= 0 and <= end");
      const lineStartOffset = offset - lineAndCol.colNum + 1;
      startIdx = Math.max(0, startIdx - lineStartOffset);
      endIdx = Math.min(endIdx - lineStartOffset, lineLen);
      indicationLine = strcpy(indicationLine, repeatStr("~", endIdx - startIdx), startIdx);
    }
    const gutterWidth = 2 + lineNumbers[1].length + 3;
    sb.append(repeatStr(" ", gutterWidth));
    indicationLine = strcpy(indicationLine, "^", lineAndCol.colNum - 1);
    sb.append(indicationLine.replace(/ +$/, "") + "\n");
    if (lineAndCol.nextLine != null) {
      appendLine(2, lineAndCol.nextLine, "  ");
    }
    return sb.contents();
  }
  let builtInRulesCallbacks = [];
  exports.awaitBuiltInRules = (cb) => {
    builtInRulesCallbacks.push(cb);
  };
  exports.announceBuiltInRules = (grammar2) => {
    builtInRulesCallbacks.forEach((cb) => {
      cb(grammar2);
    });
    builtInRulesCallbacks = null;
  };
  exports.getLineAndColumn = (str, offset) => {
    let lineNum = 1;
    let colNum = 1;
    let currOffset = 0;
    let lineStartOffset = 0;
    let nextLine = null;
    let prevLine = null;
    let prevLineStartOffset = -1;
    while (currOffset < offset) {
      const c = str.charAt(currOffset++);
      if (c === "\n") {
        lineNum++;
        colNum = 1;
        prevLineStartOffset = lineStartOffset;
        lineStartOffset = currOffset;
      } else if (c !== "\r") {
        colNum++;
      }
    }
    let lineEndOffset = str.indexOf("\n", lineStartOffset);
    if (lineEndOffset === -1) {
      lineEndOffset = str.length;
    } else {
      const nextLineEndOffset = str.indexOf("\n", lineEndOffset + 1);
      nextLine = nextLineEndOffset === -1 ? str.slice(lineEndOffset) : str.slice(lineEndOffset, nextLineEndOffset);
      nextLine = nextLine.replace(/^\r?\n/, "").replace(/\r$/, "");
    }
    if (prevLineStartOffset >= 0) {
      prevLine = str.slice(prevLineStartOffset, lineStartOffset).replace(/\r?\n$/, "");
    }
    const line = str.slice(lineStartOffset, lineEndOffset).replace(/\r$/, "");
    return {
      offset,
      lineNum,
      colNum,
      line,
      prevLine,
      nextLine,
      toString: lineAndColumnToMessage
    };
  };
  exports.getLineAndColumnMessage = function(str, offset, ...ranges) {
    return exports.getLineAndColumn(str, offset).toString(...ranges);
  };
  exports.uniqueId = /* @__PURE__ */ (() => {
    let idCounter = 0;
    return (prefix) => "" + prefix + idCounter++;
  })();
})(util$7);
const { abstract, isSyntactic } = common$l;
const errors$8 = errors$9;
const pexprs$j = pexprsMain;
const util$6 = util$7;
let BuiltInRules;
util$6.awaitBuiltInRules((g2) => {
  BuiltInRules = g2;
});
let lexifyCount;
pexprs$j.PExpr.prototype.assertAllApplicationsAreValid = function(ruleName, grammar2) {
  lexifyCount = 0;
  this._assertAllApplicationsAreValid(ruleName, grammar2);
};
pexprs$j.PExpr.prototype._assertAllApplicationsAreValid = abstract(
  "_assertAllApplicationsAreValid"
);
pexprs$j.any._assertAllApplicationsAreValid = pexprs$j.end._assertAllApplicationsAreValid = pexprs$j.Terminal.prototype._assertAllApplicationsAreValid = pexprs$j.Range.prototype._assertAllApplicationsAreValid = pexprs$j.Param.prototype._assertAllApplicationsAreValid = pexprs$j.UnicodeChar.prototype._assertAllApplicationsAreValid = function(ruleName, grammar2) {
};
pexprs$j.Lex.prototype._assertAllApplicationsAreValid = function(ruleName, grammar2) {
  lexifyCount++;
  this.expr._assertAllApplicationsAreValid(ruleName, grammar2);
  lexifyCount--;
};
pexprs$j.Alt.prototype._assertAllApplicationsAreValid = function(ruleName, grammar2) {
  for (let idx = 0; idx < this.terms.length; idx++) {
    this.terms[idx]._assertAllApplicationsAreValid(ruleName, grammar2);
  }
};
pexprs$j.Seq.prototype._assertAllApplicationsAreValid = function(ruleName, grammar2) {
  for (let idx = 0; idx < this.factors.length; idx++) {
    this.factors[idx]._assertAllApplicationsAreValid(ruleName, grammar2);
  }
};
pexprs$j.Iter.prototype._assertAllApplicationsAreValid = pexprs$j.Not.prototype._assertAllApplicationsAreValid = pexprs$j.Lookahead.prototype._assertAllApplicationsAreValid = function(ruleName, grammar2) {
  this.expr._assertAllApplicationsAreValid(ruleName, grammar2);
};
pexprs$j.Apply.prototype._assertAllApplicationsAreValid = function(ruleName, grammar2, skipSyntacticCheck = false) {
  const ruleInfo = grammar2.rules[this.ruleName];
  const isContextSyntactic = isSyntactic(ruleName) && lexifyCount === 0;
  if (!ruleInfo) {
    throw errors$8.undeclaredRule(this.ruleName, grammar2.name, this.source);
  }
  if (!skipSyntacticCheck && isSyntactic(this.ruleName) && !isContextSyntactic) {
    throw errors$8.applicationOfSyntacticRuleFromLexicalContext(this.ruleName, this);
  }
  const actual = this.args.length;
  const expected = ruleInfo.formals.length;
  if (actual !== expected) {
    throw errors$8.wrongNumberOfArguments(this.ruleName, expected, actual, this.source);
  }
  const isBuiltInApplySyntactic = BuiltInRules && ruleInfo === BuiltInRules.rules.applySyntactic;
  const isBuiltInCaseInsensitive = BuiltInRules && ruleInfo === BuiltInRules.rules.caseInsensitive;
  if (isBuiltInCaseInsensitive) {
    if (!(this.args[0] instanceof pexprs$j.Terminal)) {
      throw errors$8.incorrectArgumentType('a Terminal (e.g. "abc")', this.args[0]);
    }
  }
  if (isBuiltInApplySyntactic) {
    const arg = this.args[0];
    if (!(arg instanceof pexprs$j.Apply)) {
      throw errors$8.incorrectArgumentType("a syntactic rule application", arg);
    }
    if (!isSyntactic(arg.ruleName)) {
      throw errors$8.applySyntacticWithLexicalRuleApplication(arg);
    }
    if (isContextSyntactic) {
      throw errors$8.unnecessaryExperimentalApplySyntactic(this);
    }
  }
  this.args.forEach((arg) => {
    arg._assertAllApplicationsAreValid(ruleName, grammar2, isBuiltInApplySyntactic);
    if (arg.getArity() !== 1) {
      throw errors$8.invalidParameter(this.ruleName, arg);
    }
  });
};
const common$h = common$l;
const errors$7 = errors$9;
const pexprs$i = pexprsMain;
pexprs$i.PExpr.prototype.assertChoicesHaveUniformArity = common$h.abstract(
  "assertChoicesHaveUniformArity"
);
pexprs$i.any.assertChoicesHaveUniformArity = pexprs$i.end.assertChoicesHaveUniformArity = pexprs$i.Terminal.prototype.assertChoicesHaveUniformArity = pexprs$i.Range.prototype.assertChoicesHaveUniformArity = pexprs$i.Param.prototype.assertChoicesHaveUniformArity = pexprs$i.Lex.prototype.assertChoicesHaveUniformArity = pexprs$i.UnicodeChar.prototype.assertChoicesHaveUniformArity = function(ruleName) {
};
pexprs$i.Alt.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  if (this.terms.length === 0) {
    return;
  }
  const arity = this.terms[0].getArity();
  for (let idx = 0; idx < this.terms.length; idx++) {
    const term = this.terms[idx];
    term.assertChoicesHaveUniformArity();
    const otherArity = term.getArity();
    if (arity !== otherArity) {
      throw errors$7.inconsistentArity(ruleName, arity, otherArity, term);
    }
  }
};
pexprs$i.Extend.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  const actualArity = this.terms[0].getArity();
  const expectedArity = this.terms[1].getArity();
  if (actualArity !== expectedArity) {
    throw errors$7.inconsistentArity(ruleName, expectedArity, actualArity, this.terms[0]);
  }
};
pexprs$i.Seq.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  for (let idx = 0; idx < this.factors.length; idx++) {
    this.factors[idx].assertChoicesHaveUniformArity(ruleName);
  }
};
pexprs$i.Iter.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  this.expr.assertChoicesHaveUniformArity(ruleName);
};
pexprs$i.Not.prototype.assertChoicesHaveUniformArity = function(ruleName) {
};
pexprs$i.Lookahead.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  this.expr.assertChoicesHaveUniformArity(ruleName);
};
pexprs$i.Apply.prototype.assertChoicesHaveUniformArity = function(ruleName) {
};
const common$g = common$l;
const errors$6 = errors$9;
const pexprs$h = pexprsMain;
pexprs$h.PExpr.prototype.assertIteratedExprsAreNotNullable = common$g.abstract(
  "assertIteratedExprsAreNotNullable"
);
pexprs$h.any.assertIteratedExprsAreNotNullable = pexprs$h.end.assertIteratedExprsAreNotNullable = pexprs$h.Terminal.prototype.assertIteratedExprsAreNotNullable = pexprs$h.Range.prototype.assertIteratedExprsAreNotNullable = pexprs$h.Param.prototype.assertIteratedExprsAreNotNullable = pexprs$h.UnicodeChar.prototype.assertIteratedExprsAreNotNullable = function(grammar2) {
};
pexprs$h.Alt.prototype.assertIteratedExprsAreNotNullable = function(grammar2) {
  for (let idx = 0; idx < this.terms.length; idx++) {
    this.terms[idx].assertIteratedExprsAreNotNullable(grammar2);
  }
};
pexprs$h.Seq.prototype.assertIteratedExprsAreNotNullable = function(grammar2) {
  for (let idx = 0; idx < this.factors.length; idx++) {
    this.factors[idx].assertIteratedExprsAreNotNullable(grammar2);
  }
};
pexprs$h.Iter.prototype.assertIteratedExprsAreNotNullable = function(grammar2) {
  this.expr.assertIteratedExprsAreNotNullable(grammar2);
  if (this.expr.isNullable(grammar2)) {
    throw errors$6.kleeneExprHasNullableOperand(this, []);
  }
};
pexprs$h.Opt.prototype.assertIteratedExprsAreNotNullable = pexprs$h.Not.prototype.assertIteratedExprsAreNotNullable = pexprs$h.Lookahead.prototype.assertIteratedExprsAreNotNullable = pexprs$h.Lex.prototype.assertIteratedExprsAreNotNullable = function(grammar2) {
  this.expr.assertIteratedExprsAreNotNullable(grammar2);
};
pexprs$h.Apply.prototype.assertIteratedExprsAreNotNullable = function(grammar2) {
  this.args.forEach((arg) => {
    arg.assertIteratedExprsAreNotNullable(grammar2);
  });
};
const { assert: assert$2 } = common$l;
const errors$5 = errors$9;
const util$5 = util$7;
function Interval$3(sourceString, startIdx, endIdx) {
  this.sourceString = sourceString;
  this.startIdx = startIdx;
  this.endIdx = endIdx;
}
Interval$3.coverage = function(firstInterval, ...intervals) {
  let { startIdx, endIdx } = firstInterval;
  for (const interval of intervals) {
    if (interval.sourceString !== firstInterval.sourceString) {
      throw errors$5.intervalSourcesDontMatch();
    } else {
      startIdx = Math.min(startIdx, interval.startIdx);
      endIdx = Math.max(endIdx, interval.endIdx);
    }
  }
  return new Interval$3(firstInterval.sourceString, startIdx, endIdx);
};
Interval$3.prototype = {
  coverageWith(...intervals) {
    return Interval$3.coverage(...intervals, this);
  },
  collapsedLeft() {
    return new Interval$3(this.sourceString, this.startIdx, this.startIdx);
  },
  collapsedRight() {
    return new Interval$3(this.sourceString, this.endIdx, this.endIdx);
  },
  getLineAndColumn() {
    return util$5.getLineAndColumn(this.sourceString, this.startIdx);
  },
  getLineAndColumnMessage() {
    const range = [this.startIdx, this.endIdx];
    return util$5.getLineAndColumnMessage(this.sourceString, this.startIdx, range);
  },
  // Returns an array of 0, 1, or 2 intervals that represents the result of the
  // interval difference operation.
  minus(that) {
    if (this.sourceString !== that.sourceString) {
      throw errors$5.intervalSourcesDontMatch();
    } else if (this.startIdx === that.startIdx && this.endIdx === that.endIdx) {
      return [];
    } else if (this.startIdx < that.startIdx && that.endIdx < this.endIdx) {
      return [
        new Interval$3(this.sourceString, this.startIdx, that.startIdx),
        new Interval$3(this.sourceString, that.endIdx, this.endIdx)
      ];
    } else if (this.startIdx < that.endIdx && that.endIdx < this.endIdx) {
      return [new Interval$3(this.sourceString, that.endIdx, this.endIdx)];
    } else if (this.startIdx < that.startIdx && that.startIdx < this.endIdx) {
      return [new Interval$3(this.sourceString, this.startIdx, that.startIdx)];
    } else {
      return [this];
    }
  },
  // Returns a new Interval that has the same extent as this one, but which is relative
  // to `that`, an Interval that fully covers this one.
  relativeTo(that) {
    if (this.sourceString !== that.sourceString) {
      throw errors$5.intervalSourcesDontMatch();
    }
    assert$2(
      this.startIdx >= that.startIdx && this.endIdx <= that.endIdx,
      "other interval does not cover this one"
    );
    return new Interval$3(
      this.sourceString,
      this.startIdx - that.startIdx,
      this.endIdx - that.startIdx
    );
  },
  // Returns a new Interval which contains the same contents as this one,
  // but with whitespace trimmed from both ends.
  trimmed() {
    const { contents } = this;
    const startIdx = this.startIdx + contents.match(/^\s*/)[0].length;
    const endIdx = this.endIdx - contents.match(/\s*$/)[0].length;
    return new Interval$3(this.sourceString, startIdx, endIdx);
  },
  subInterval(offset, len) {
    const newStartIdx = this.startIdx + offset;
    return new Interval$3(this.sourceString, newStartIdx, newStartIdx + len);
  }
};
Object.defineProperties(Interval$3.prototype, {
  contents: {
    get() {
      if (this._contents === void 0) {
        this._contents = this.sourceString.slice(this.startIdx, this.endIdx);
      }
      return this._contents;
    },
    enumerable: true
  },
  length: {
    get() {
      return this.endIdx - this.startIdx;
    },
    enumerable: true
  }
});
var Interval_1 = Interval$3;
const Interval$2 = Interval_1;
const common$f = common$l;
const BALLOT_X = "";
const CHECK_MARK = "";
const DOT_OPERATOR = "";
const RIGHTWARDS_DOUBLE_ARROW = "";
const SYMBOL_FOR_HORIZONTAL_TABULATION = "";
const SYMBOL_FOR_LINE_FEED = "";
const SYMBOL_FOR_CARRIAGE_RETURN = "";
const Flags = {
  succeeded: 1 << 0,
  isRootNode: 1 << 1,
  isImplicitSpaces: 1 << 2,
  isMemoized: 1 << 3,
  isHeadOfLeftRecursion: 1 << 4,
  terminatesLR: 1 << 5
};
function spaces(n) {
  return common$f.repeat(" ", n).join("");
}
function getInputExcerpt(input, pos, len) {
  const excerpt = asEscapedString(input.slice(pos, pos + len));
  if (excerpt.length < len) {
    return excerpt + common$f.repeat(" ", len - excerpt.length).join("");
  }
  return excerpt;
}
function asEscapedString(obj) {
  if (typeof obj === "string") {
    return obj.replace(/ /g, DOT_OPERATOR).replace(/\t/g, SYMBOL_FOR_HORIZONTAL_TABULATION).replace(/\n/g, SYMBOL_FOR_LINE_FEED).replace(/\r/g, SYMBOL_FOR_CARRIAGE_RETURN);
  }
  return String(obj);
}
function Trace$2(input, pos1, pos2, expr, succeeded, bindings, optChildren) {
  this.input = input;
  this.pos = this.pos1 = pos1;
  this.pos2 = pos2;
  this.source = new Interval$2(input, pos1, pos2);
  this.expr = expr;
  this.bindings = bindings;
  this.children = optChildren || [];
  this.terminatingLREntry = null;
  this._flags = succeeded ? Flags.succeeded : 0;
}
Trace$2.prototype.SKIP = {};
Object.defineProperty(Trace$2.prototype, "displayString", {
  get() {
    return this.expr.toDisplayString();
  }
});
Object.keys(Flags).forEach((name) => {
  const mask = Flags[name];
  Object.defineProperty(Trace$2.prototype, name, {
    get() {
      return (this._flags & mask) !== 0;
    },
    set(val) {
      if (val) {
        this._flags |= mask;
      } else {
        this._flags &= ~mask;
      }
    }
  });
});
Trace$2.prototype.clone = function() {
  return this.cloneWithExpr(this.expr);
};
Trace$2.prototype.cloneWithExpr = function(expr) {
  const ans = new Trace$2(
    this.input,
    this.pos,
    this.pos2,
    expr,
    this.succeeded,
    this.bindings,
    this.children
  );
  ans.isHeadOfLeftRecursion = this.isHeadOfLeftRecursion;
  ans.isImplicitSpaces = this.isImplicitSpaces;
  ans.isMemoized = this.isMemoized;
  ans.isRootNode = this.isRootNode;
  ans.terminatesLR = this.terminatesLR;
  ans.terminatingLREntry = this.terminatingLREntry;
  return ans;
};
Trace$2.prototype.recordLRTermination = function(ruleBodyTrace, value) {
  this.terminatingLREntry = new Trace$2(
    this.input,
    this.pos,
    this.pos2,
    this.expr,
    false,
    [value],
    [ruleBodyTrace]
  );
  this.terminatingLREntry.terminatesLR = true;
};
Trace$2.prototype.walk = function(visitorObjOrFn, optThisArg) {
  let visitor = visitorObjOrFn;
  if (typeof visitor === "function") {
    visitor = { enter: visitor };
  }
  function _walk(node, parent, depth) {
    let recurse = true;
    if (visitor.enter) {
      if (visitor.enter.call(optThisArg, node, parent, depth) === Trace$2.prototype.SKIP) {
        recurse = false;
      }
    }
    if (recurse) {
      node.children.forEach((child) => {
        _walk(child, node, depth + 1);
      });
      if (visitor.exit) {
        visitor.exit.call(optThisArg, node, parent, depth);
      }
    }
  }
  if (this.isRootNode) {
    this.children.forEach((c) => {
      _walk(c, null, 0);
    });
  } else {
    _walk(this, null, 0);
  }
};
Trace$2.prototype.toString = function() {
  const sb = new common$f.StringBuffer();
  this.walk((node, parent, depth) => {
    if (!node) {
      return this.SKIP;
    }
    const ctorName = node.expr.constructor.name;
    if (ctorName === "Alt") {
      return;
    }
    sb.append(getInputExcerpt(node.input, node.pos, 10) + spaces(depth * 2 + 1));
    sb.append((node.succeeded ? CHECK_MARK : BALLOT_X) + " " + node.displayString);
    if (node.isHeadOfLeftRecursion) {
      sb.append(" (LR)");
    }
    if (node.succeeded) {
      const contents = asEscapedString(node.source.contents);
      sb.append(" " + RIGHTWARDS_DOUBLE_ARROW + "  ");
      sb.append(typeof contents === "string" ? '"' + contents + '"' : contents);
    }
    sb.append("\n");
  });
  return sb.contents();
};
var Trace_1 = Trace$2;
const Trace$1 = Trace_1;
const common$e = common$l;
const errors$4 = errors$9;
const nodes$2 = nodes$1$1;
const pexprs$g = pexprsMain;
const { TerminalNode: TerminalNode$1 } = nodes$2;
const { NonterminalNode } = nodes$2;
const { IterationNode: IterationNode$1 } = nodes$2;
pexprs$g.PExpr.prototype.eval = common$e.abstract("eval");
pexprs$g.any.eval = function(state) {
  const { inputStream } = state;
  const origPos = inputStream.pos;
  const ch = inputStream.next();
  if (ch) {
    state.pushBinding(new TerminalNode$1(ch.length), origPos);
    return true;
  } else {
    state.processFailure(origPos, this);
    return false;
  }
};
pexprs$g.end.eval = function(state) {
  const { inputStream } = state;
  const origPos = inputStream.pos;
  if (inputStream.atEnd()) {
    state.pushBinding(new TerminalNode$1(0), origPos);
    return true;
  } else {
    state.processFailure(origPos, this);
    return false;
  }
};
pexprs$g.Terminal.prototype.eval = function(state) {
  const { inputStream } = state;
  const origPos = inputStream.pos;
  if (!inputStream.matchString(this.obj)) {
    state.processFailure(origPos, this);
    return false;
  } else {
    state.pushBinding(new TerminalNode$1(this.obj.length), origPos);
    return true;
  }
};
pexprs$g.Range.prototype.eval = function(state) {
  const { inputStream } = state;
  const origPos = inputStream.pos;
  const cp = this.matchCodePoint ? inputStream.nextCodePoint() : inputStream.nextCharCode();
  if (cp !== void 0 && this.from.codePointAt(0) <= cp && cp <= this.to.codePointAt(0)) {
    state.pushBinding(new TerminalNode$1(String.fromCodePoint(cp).length), origPos);
    return true;
  } else {
    state.processFailure(origPos, this);
    return false;
  }
};
pexprs$g.Param.prototype.eval = function(state) {
  return state.eval(state.currentApplication().args[this.index]);
};
pexprs$g.Lex.prototype.eval = function(state) {
  state.enterLexifiedContext();
  const ans = state.eval(this.expr);
  state.exitLexifiedContext();
  return ans;
};
pexprs$g.Alt.prototype.eval = function(state) {
  for (let idx = 0; idx < this.terms.length; idx++) {
    if (state.eval(this.terms[idx])) {
      return true;
    }
  }
  return false;
};
pexprs$g.Seq.prototype.eval = function(state) {
  for (let idx = 0; idx < this.factors.length; idx++) {
    const factor = this.factors[idx];
    if (!state.eval(factor)) {
      return false;
    }
  }
  return true;
};
pexprs$g.Iter.prototype.eval = function(state) {
  const { inputStream } = state;
  const origPos = inputStream.pos;
  const arity = this.getArity();
  const cols = [];
  const colOffsets = [];
  while (cols.length < arity) {
    cols.push([]);
    colOffsets.push([]);
  }
  let numMatches = 0;
  let prevPos = origPos;
  let idx;
  while (numMatches < this.maxNumMatches && state.eval(this.expr)) {
    if (inputStream.pos === prevPos) {
      throw errors$4.kleeneExprHasNullableOperand(this, state._applicationStack);
    }
    prevPos = inputStream.pos;
    numMatches++;
    const row = state._bindings.splice(state._bindings.length - arity, arity);
    const rowOffsets = state._bindingOffsets.splice(
      state._bindingOffsets.length - arity,
      arity
    );
    for (idx = 0; idx < row.length; idx++) {
      cols[idx].push(row[idx]);
      colOffsets[idx].push(rowOffsets[idx]);
    }
  }
  if (numMatches < this.minNumMatches) {
    return false;
  }
  let offset = state.posToOffset(origPos);
  let matchLength = 0;
  if (numMatches > 0) {
    const lastCol = cols[arity - 1];
    const lastColOffsets = colOffsets[arity - 1];
    const endOffset = lastColOffsets[lastColOffsets.length - 1] + lastCol[lastCol.length - 1].matchLength;
    offset = colOffsets[0][0];
    matchLength = endOffset - offset;
  }
  const isOptional = this instanceof pexprs$g.Opt;
  for (idx = 0; idx < cols.length; idx++) {
    state._bindings.push(
      new IterationNode$1(cols[idx], colOffsets[idx], matchLength, isOptional)
    );
    state._bindingOffsets.push(offset);
  }
  return true;
};
pexprs$g.Not.prototype.eval = function(state) {
  const { inputStream } = state;
  const origPos = inputStream.pos;
  state.pushFailuresInfo();
  const ans = state.eval(this.expr);
  state.popFailuresInfo();
  if (ans) {
    state.processFailure(origPos, this);
    return false;
  }
  inputStream.pos = origPos;
  return true;
};
pexprs$g.Lookahead.prototype.eval = function(state) {
  const { inputStream } = state;
  const origPos = inputStream.pos;
  if (state.eval(this.expr)) {
    inputStream.pos = origPos;
    return true;
  } else {
    return false;
  }
};
pexprs$g.Apply.prototype.eval = function(state) {
  const caller = state.currentApplication();
  const actuals = caller ? caller.args : [];
  const app = this.substituteParams(actuals);
  const posInfo = state.getCurrentPosInfo();
  if (posInfo.isActive(app)) {
    return app.handleCycle(state);
  }
  const memoKey = app.toMemoKey();
  const memoRec = posInfo.memo[memoKey];
  if (memoRec && posInfo.shouldUseMemoizedResult(memoRec)) {
    if (state.hasNecessaryInfo(memoRec)) {
      return state.useMemoizedResult(state.inputStream.pos, memoRec);
    }
    delete posInfo.memo[memoKey];
  }
  return app.reallyEval(state);
};
pexprs$g.Apply.prototype.handleCycle = function(state) {
  const posInfo = state.getCurrentPosInfo();
  const { currentLeftRecursion } = posInfo;
  const memoKey = this.toMemoKey();
  let memoRec = posInfo.memo[memoKey];
  if (currentLeftRecursion && currentLeftRecursion.headApplication.toMemoKey() === memoKey) {
    memoRec.updateInvolvedApplicationMemoKeys();
  } else if (!memoRec) {
    memoRec = posInfo.memoize(memoKey, {
      matchLength: 0,
      examinedLength: 0,
      value: false,
      rightmostFailureOffset: -1
    });
    posInfo.startLeftRecursion(this, memoRec);
  }
  return state.useMemoizedResult(state.inputStream.pos, memoRec);
};
pexprs$g.Apply.prototype.reallyEval = function(state) {
  const { inputStream } = state;
  const origPos = inputStream.pos;
  const origPosInfo = state.getCurrentPosInfo();
  const ruleInfo = state.grammar.rules[this.ruleName];
  const { body } = ruleInfo;
  const { description } = ruleInfo;
  state.enterApplication(origPosInfo, this);
  if (description) {
    state.pushFailuresInfo();
  }
  const origInputStreamExaminedLength = inputStream.examinedLength;
  inputStream.examinedLength = 0;
  let value = this.evalOnce(body, state);
  const currentLR = origPosInfo.currentLeftRecursion;
  const memoKey = this.toMemoKey();
  const isHeadOfLeftRecursion = currentLR && currentLR.headApplication.toMemoKey() === memoKey;
  let memoRec;
  if (isHeadOfLeftRecursion) {
    value = this.growSeedResult(body, state, origPos, currentLR, value);
    origPosInfo.endLeftRecursion();
    memoRec = currentLR;
    memoRec.examinedLength = inputStream.examinedLength - origPos;
    memoRec.rightmostFailureOffset = state._getRightmostFailureOffset();
    origPosInfo.memoize(memoKey, memoRec);
  } else if (!currentLR || !currentLR.isInvolved(memoKey)) {
    memoRec = origPosInfo.memoize(memoKey, {
      matchLength: inputStream.pos - origPos,
      examinedLength: inputStream.examinedLength - origPos,
      value,
      failuresAtRightmostPosition: state.cloneRecordedFailures(),
      rightmostFailureOffset: state._getRightmostFailureOffset()
    });
  }
  const succeeded = !!value;
  if (description) {
    state.popFailuresInfo();
    if (!succeeded) {
      state.processFailure(origPos, this);
    }
    if (memoRec) {
      memoRec.failuresAtRightmostPosition = state.cloneRecordedFailures();
    }
  }
  if (state.isTracing() && memoRec) {
    const entry = state.getTraceEntry(origPos, this, succeeded, succeeded ? [value] : []);
    if (isHeadOfLeftRecursion) {
      common$e.assert(entry.terminatingLREntry != null || !succeeded);
      entry.isHeadOfLeftRecursion = true;
    }
    memoRec.traceEntry = entry;
  }
  inputStream.examinedLength = Math.max(
    inputStream.examinedLength,
    origInputStreamExaminedLength
  );
  state.exitApplication(origPosInfo, value);
  return succeeded;
};
pexprs$g.Apply.prototype.evalOnce = function(expr, state) {
  const { inputStream } = state;
  const origPos = inputStream.pos;
  if (state.eval(expr)) {
    const arity = expr.getArity();
    const bindings = state._bindings.splice(state._bindings.length - arity, arity);
    const offsets = state._bindingOffsets.splice(state._bindingOffsets.length - arity, arity);
    const matchLength = inputStream.pos - origPos;
    return new NonterminalNode(this.ruleName, bindings, offsets, matchLength);
  } else {
    return false;
  }
};
pexprs$g.Apply.prototype.growSeedResult = function(body, state, origPos, lrMemoRec, newValue) {
  if (!newValue) {
    return false;
  }
  const { inputStream } = state;
  while (true) {
    lrMemoRec.matchLength = inputStream.pos - origPos;
    lrMemoRec.value = newValue;
    lrMemoRec.failuresAtRightmostPosition = state.cloneRecordedFailures();
    if (state.isTracing()) {
      const seedTrace = state.trace[state.trace.length - 1];
      lrMemoRec.traceEntry = new Trace$1(
        state.input,
        origPos,
        inputStream.pos,
        this,
        true,
        [newValue],
        [seedTrace.clone()]
      );
    }
    inputStream.pos = origPos;
    newValue = this.evalOnce(body, state);
    if (inputStream.pos - origPos <= lrMemoRec.matchLength) {
      break;
    }
    if (state.isTracing()) {
      state.trace.splice(-2, 1);
    }
  }
  if (state.isTracing()) {
    lrMemoRec.traceEntry.recordLRTermination(state.trace.pop(), newValue);
  }
  inputStream.pos = origPos + lrMemoRec.matchLength;
  return lrMemoRec.value;
};
pexprs$g.UnicodeChar.prototype.eval = function(state) {
  const { inputStream } = state;
  const origPos = inputStream.pos;
  const ch = inputStream.next();
  if (ch && this.pattern.test(ch)) {
    state.pushBinding(new TerminalNode$1(ch.length), origPos);
    return true;
  } else {
    state.processFailure(origPos, this);
    return false;
  }
};
const common$d = common$l;
const pexprs$f = pexprsMain;
pexprs$f.PExpr.prototype.getArity = common$d.abstract("getArity");
pexprs$f.any.getArity = pexprs$f.end.getArity = pexprs$f.Terminal.prototype.getArity = pexprs$f.Range.prototype.getArity = pexprs$f.Param.prototype.getArity = pexprs$f.Apply.prototype.getArity = pexprs$f.UnicodeChar.prototype.getArity = function() {
  return 1;
};
pexprs$f.Alt.prototype.getArity = function() {
  return this.terms.length === 0 ? 0 : this.terms[0].getArity();
};
pexprs$f.Seq.prototype.getArity = function() {
  let arity = 0;
  for (let idx = 0; idx < this.factors.length; idx++) {
    arity += this.factors[idx].getArity();
  }
  return arity;
};
pexprs$f.Iter.prototype.getArity = function() {
  return this.expr.getArity();
};
pexprs$f.Not.prototype.getArity = function() {
  return 0;
};
pexprs$f.Lookahead.prototype.getArity = pexprs$f.Lex.prototype.getArity = function() {
  return this.expr.getArity();
};
const common$c = common$l;
const pexprs$e = pexprsMain;
function getMetaInfo(expr, grammarInterval) {
  const metaInfo = {};
  if (expr.source && grammarInterval) {
    const adjusted = expr.source.relativeTo(grammarInterval);
    metaInfo.sourceInterval = [adjusted.startIdx, adjusted.endIdx];
  }
  return metaInfo;
}
pexprs$e.PExpr.prototype.outputRecipe = common$c.abstract("outputRecipe");
pexprs$e.any.outputRecipe = function(formals, grammarInterval) {
  return ["any", getMetaInfo(this, grammarInterval)];
};
pexprs$e.end.outputRecipe = function(formals, grammarInterval) {
  return ["end", getMetaInfo(this, grammarInterval)];
};
pexprs$e.Terminal.prototype.outputRecipe = function(formals, grammarInterval) {
  return ["terminal", getMetaInfo(this, grammarInterval), this.obj];
};
pexprs$e.Range.prototype.outputRecipe = function(formals, grammarInterval) {
  return ["range", getMetaInfo(this, grammarInterval), this.from, this.to];
};
pexprs$e.Param.prototype.outputRecipe = function(formals, grammarInterval) {
  return ["param", getMetaInfo(this, grammarInterval), this.index];
};
pexprs$e.Alt.prototype.outputRecipe = function(formals, grammarInterval) {
  return ["alt", getMetaInfo(this, grammarInterval)].concat(
    this.terms.map((term) => term.outputRecipe(formals, grammarInterval))
  );
};
pexprs$e.Extend.prototype.outputRecipe = function(formals, grammarInterval) {
  const extension = this.terms[0];
  return extension.outputRecipe(formals, grammarInterval);
};
pexprs$e.Splice.prototype.outputRecipe = function(formals, grammarInterval) {
  const beforeTerms = this.terms.slice(0, this.expansionPos);
  const afterTerms = this.terms.slice(this.expansionPos + 1);
  return [
    "splice",
    getMetaInfo(this, grammarInterval),
    beforeTerms.map((term) => term.outputRecipe(formals, grammarInterval)),
    afterTerms.map((term) => term.outputRecipe(formals, grammarInterval))
  ];
};
pexprs$e.Seq.prototype.outputRecipe = function(formals, grammarInterval) {
  return ["seq", getMetaInfo(this, grammarInterval)].concat(
    this.factors.map((factor) => factor.outputRecipe(formals, grammarInterval))
  );
};
pexprs$e.Star.prototype.outputRecipe = pexprs$e.Plus.prototype.outputRecipe = pexprs$e.Opt.prototype.outputRecipe = pexprs$e.Not.prototype.outputRecipe = pexprs$e.Lookahead.prototype.outputRecipe = pexprs$e.Lex.prototype.outputRecipe = function(formals, grammarInterval) {
  return [
    this.constructor.name.toLowerCase(),
    getMetaInfo(this, grammarInterval),
    this.expr.outputRecipe(formals, grammarInterval)
  ];
};
pexprs$e.Apply.prototype.outputRecipe = function(formals, grammarInterval) {
  return [
    "app",
    getMetaInfo(this, grammarInterval),
    this.ruleName,
    this.args.map((arg) => arg.outputRecipe(formals, grammarInterval))
  ];
};
pexprs$e.UnicodeChar.prototype.outputRecipe = function(formals, grammarInterval) {
  return ["unicodeChar", getMetaInfo(this, grammarInterval), this.category];
};
const common$b = common$l;
const pexprs$d = pexprsMain;
pexprs$d.PExpr.prototype.introduceParams = common$b.abstract("introduceParams");
pexprs$d.any.introduceParams = pexprs$d.end.introduceParams = pexprs$d.Terminal.prototype.introduceParams = pexprs$d.Range.prototype.introduceParams = pexprs$d.Param.prototype.introduceParams = pexprs$d.UnicodeChar.prototype.introduceParams = function(formals) {
  return this;
};
pexprs$d.Alt.prototype.introduceParams = function(formals) {
  this.terms.forEach((term, idx, terms) => {
    terms[idx] = term.introduceParams(formals);
  });
  return this;
};
pexprs$d.Seq.prototype.introduceParams = function(formals) {
  this.factors.forEach((factor, idx, factors) => {
    factors[idx] = factor.introduceParams(formals);
  });
  return this;
};
pexprs$d.Iter.prototype.introduceParams = pexprs$d.Not.prototype.introduceParams = pexprs$d.Lookahead.prototype.introduceParams = pexprs$d.Lex.prototype.introduceParams = function(formals) {
  this.expr = this.expr.introduceParams(formals);
  return this;
};
pexprs$d.Apply.prototype.introduceParams = function(formals) {
  const index = formals.indexOf(this.ruleName);
  if (index >= 0) {
    if (this.args.length > 0) {
      throw new Error("Parameterized rules cannot be passed as arguments to another rule.");
    }
    return new pexprs$d.Param(index).withSource(this.source);
  } else {
    this.args.forEach((arg, idx, args) => {
      args[idx] = arg.introduceParams(formals);
    });
    return this;
  }
};
const common$a = common$l;
const pexprs$c = pexprsMain;
pexprs$c.PExpr.prototype.isNullable = function(grammar2) {
  return this._isNullable(grammar2, /* @__PURE__ */ Object.create(null));
};
pexprs$c.PExpr.prototype._isNullable = common$a.abstract("_isNullable");
pexprs$c.any._isNullable = pexprs$c.Range.prototype._isNullable = pexprs$c.Param.prototype._isNullable = pexprs$c.Plus.prototype._isNullable = pexprs$c.UnicodeChar.prototype._isNullable = function(grammar2, memo) {
  return false;
};
pexprs$c.end._isNullable = function(grammar2, memo) {
  return true;
};
pexprs$c.Terminal.prototype._isNullable = function(grammar2, memo) {
  if (typeof this.obj === "string") {
    return this.obj === "";
  } else {
    return false;
  }
};
pexprs$c.Alt.prototype._isNullable = function(grammar2, memo) {
  return this.terms.length === 0 || this.terms.some((term) => term._isNullable(grammar2, memo));
};
pexprs$c.Seq.prototype._isNullable = function(grammar2, memo) {
  return this.factors.every((factor) => factor._isNullable(grammar2, memo));
};
pexprs$c.Star.prototype._isNullable = pexprs$c.Opt.prototype._isNullable = pexprs$c.Not.prototype._isNullable = pexprs$c.Lookahead.prototype._isNullable = function(grammar2, memo) {
  return true;
};
pexprs$c.Lex.prototype._isNullable = function(grammar2, memo) {
  return this.expr._isNullable(grammar2, memo);
};
pexprs$c.Apply.prototype._isNullable = function(grammar2, memo) {
  const key2 = this.toMemoKey();
  if (!Object.prototype.hasOwnProperty.call(memo, key2)) {
    const { body } = grammar2.rules[this.ruleName];
    const inlined = body.substituteParams(this.args);
    memo[key2] = false;
    memo[key2] = inlined._isNullable(grammar2, memo);
  }
  return memo[key2];
};
const common$9 = common$l;
const pexprs$b = pexprsMain;
pexprs$b.PExpr.prototype.substituteParams = common$9.abstract("substituteParams");
pexprs$b.any.substituteParams = pexprs$b.end.substituteParams = pexprs$b.Terminal.prototype.substituteParams = pexprs$b.Range.prototype.substituteParams = pexprs$b.UnicodeChar.prototype.substituteParams = function(actuals) {
  return this;
};
pexprs$b.Param.prototype.substituteParams = function(actuals) {
  return actuals[this.index];
};
pexprs$b.Alt.prototype.substituteParams = function(actuals) {
  return new pexprs$b.Alt(this.terms.map((term) => term.substituteParams(actuals)));
};
pexprs$b.Seq.prototype.substituteParams = function(actuals) {
  return new pexprs$b.Seq(this.factors.map((factor) => factor.substituteParams(actuals)));
};
pexprs$b.Iter.prototype.substituteParams = pexprs$b.Not.prototype.substituteParams = pexprs$b.Lookahead.prototype.substituteParams = pexprs$b.Lex.prototype.substituteParams = function(actuals) {
  return new this.constructor(this.expr.substituteParams(actuals));
};
pexprs$b.Apply.prototype.substituteParams = function(actuals) {
  if (this.args.length === 0) {
    return this;
  } else {
    const args = this.args.map((arg) => arg.substituteParams(actuals));
    return new pexprs$b.Apply(this.ruleName, args);
  }
};
const common$8 = common$l;
const pexprs$a = pexprsMain;
const { copyWithoutDuplicates } = common$8;
function isRestrictedJSIdentifier(str) {
  return /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(str);
}
function resolveDuplicatedNames(argumentNameList) {
  const count = /* @__PURE__ */ Object.create(null);
  argumentNameList.forEach((argName) => {
    count[argName] = (count[argName] || 0) + 1;
  });
  Object.keys(count).forEach((dupArgName) => {
    if (count[dupArgName] <= 1) {
      return;
    }
    let subscript = 1;
    argumentNameList.forEach((argName, idx) => {
      if (argName === dupArgName) {
        argumentNameList[idx] = argName + "_" + subscript++;
      }
    });
  });
}
pexprs$a.PExpr.prototype.toArgumentNameList = common$8.abstract("toArgumentNameList");
pexprs$a.any.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return ["any"];
};
pexprs$a.end.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return ["end"];
};
pexprs$a.Terminal.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  if (typeof this.obj === "string" && /^[_a-zA-Z0-9]+$/.test(this.obj)) {
    return ["_" + this.obj];
  } else {
    return ["$" + firstArgIndex];
  }
};
pexprs$a.Range.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  let argName = this.from + "_to_" + this.to;
  if (!isRestrictedJSIdentifier(argName)) {
    argName = "_" + argName;
  }
  if (!isRestrictedJSIdentifier(argName)) {
    argName = "$" + firstArgIndex;
  }
  return [argName];
};
pexprs$a.Alt.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  const termArgNameLists = this.terms.map(
    (term) => term.toArgumentNameList(firstArgIndex, true)
  );
  const argumentNameList = [];
  const numArgs = termArgNameLists[0].length;
  for (let colIdx = 0; colIdx < numArgs; colIdx++) {
    const col = [];
    for (let rowIdx = 0; rowIdx < this.terms.length; rowIdx++) {
      col.push(termArgNameLists[rowIdx][colIdx]);
    }
    const uniqueNames = copyWithoutDuplicates(col);
    argumentNameList.push(uniqueNames.join("_or_"));
  }
  if (!noDupCheck) {
    resolveDuplicatedNames(argumentNameList);
  }
  return argumentNameList;
};
pexprs$a.Seq.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  let argumentNameList = [];
  this.factors.forEach((factor) => {
    const factorArgumentNameList = factor.toArgumentNameList(firstArgIndex, true);
    argumentNameList = argumentNameList.concat(factorArgumentNameList);
    firstArgIndex += factorArgumentNameList.length;
  });
  if (!noDupCheck) {
    resolveDuplicatedNames(argumentNameList);
  }
  return argumentNameList;
};
pexprs$a.Iter.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  const argumentNameList = this.expr.toArgumentNameList(firstArgIndex, noDupCheck).map(
    (exprArgumentString) => exprArgumentString[exprArgumentString.length - 1] === "s" ? exprArgumentString + "es" : exprArgumentString + "s"
  );
  if (!noDupCheck) {
    resolveDuplicatedNames(argumentNameList);
  }
  return argumentNameList;
};
pexprs$a.Opt.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return this.expr.toArgumentNameList(firstArgIndex, noDupCheck).map((argName) => {
    return "opt" + argName[0].toUpperCase() + argName.slice(1);
  });
};
pexprs$a.Not.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return [];
};
pexprs$a.Lookahead.prototype.toArgumentNameList = pexprs$a.Lex.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return this.expr.toArgumentNameList(firstArgIndex, noDupCheck);
};
pexprs$a.Apply.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return [this.ruleName];
};
pexprs$a.UnicodeChar.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return ["$" + firstArgIndex];
};
pexprs$a.Param.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return ["param" + this.index];
};
const common$7 = common$l;
const pexprs$9 = pexprsMain;
pexprs$9.PExpr.prototype.toDisplayString = common$7.abstract("toDisplayString");
pexprs$9.Alt.prototype.toDisplayString = pexprs$9.Seq.prototype.toDisplayString = function() {
  if (this.source) {
    return this.source.trimmed().contents;
  }
  return "[" + this.constructor.name + "]";
};
pexprs$9.any.toDisplayString = pexprs$9.end.toDisplayString = pexprs$9.Iter.prototype.toDisplayString = pexprs$9.Not.prototype.toDisplayString = pexprs$9.Lookahead.prototype.toDisplayString = pexprs$9.Lex.prototype.toDisplayString = pexprs$9.Terminal.prototype.toDisplayString = pexprs$9.Range.prototype.toDisplayString = pexprs$9.Param.prototype.toDisplayString = function() {
  return this.toString();
};
pexprs$9.Apply.prototype.toDisplayString = function() {
  if (this.args.length > 0) {
    const ps = this.args.map((arg) => arg.toDisplayString());
    return this.ruleName + "<" + ps.join(",") + ">";
  } else {
    return this.ruleName;
  }
};
pexprs$9.UnicodeChar.prototype.toDisplayString = function() {
  return "Unicode [" + this.category + "] character";
};
const Failure$1 = Failure_1;
const common$6 = common$l;
const pexprs$8 = pexprsMain;
pexprs$8.PExpr.prototype.toFailure = common$6.abstract("toFailure");
pexprs$8.any.toFailure = function(grammar2) {
  return new Failure$1(this, "any object", "description");
};
pexprs$8.end.toFailure = function(grammar2) {
  return new Failure$1(this, "end of input", "description");
};
pexprs$8.Terminal.prototype.toFailure = function(grammar2) {
  return new Failure$1(this, this.obj, "string");
};
pexprs$8.Range.prototype.toFailure = function(grammar2) {
  return new Failure$1(this, JSON.stringify(this.from) + ".." + JSON.stringify(this.to), "code");
};
pexprs$8.Not.prototype.toFailure = function(grammar2) {
  const description = this.expr === pexprs$8.any ? "nothing" : "not " + this.expr.toFailure(grammar2);
  return new Failure$1(this, description, "description");
};
pexprs$8.Lookahead.prototype.toFailure = function(grammar2) {
  return this.expr.toFailure(grammar2);
};
pexprs$8.Apply.prototype.toFailure = function(grammar2) {
  let { description } = grammar2.rules[this.ruleName];
  if (!description) {
    const article = /^[aeiouAEIOU]/.test(this.ruleName) ? "an" : "a";
    description = article + " " + this.ruleName;
  }
  return new Failure$1(this, description, "description");
};
pexprs$8.UnicodeChar.prototype.toFailure = function(grammar2) {
  return new Failure$1(this, "a Unicode [" + this.category + "] character", "description");
};
pexprs$8.Alt.prototype.toFailure = function(grammar2) {
  const fs = this.terms.map((t) => t.toFailure(grammar2));
  const description = "(" + fs.join(" or ") + ")";
  return new Failure$1(this, description, "description");
};
pexprs$8.Seq.prototype.toFailure = function(grammar2) {
  const fs = this.factors.map((f) => f.toFailure(grammar2));
  const description = "(" + fs.join(" ") + ")";
  return new Failure$1(this, description, "description");
};
pexprs$8.Iter.prototype.toFailure = function(grammar2) {
  const description = "(" + this.expr.toFailure(grammar2) + this.operator + ")";
  return new Failure$1(this, description, "description");
};
const common$5 = common$l;
const pexprs$7 = pexprsMain;
pexprs$7.PExpr.prototype.toString = common$5.abstract("toString");
pexprs$7.any.toString = function() {
  return "any";
};
pexprs$7.end.toString = function() {
  return "end";
};
pexprs$7.Terminal.prototype.toString = function() {
  return JSON.stringify(this.obj);
};
pexprs$7.Range.prototype.toString = function() {
  return JSON.stringify(this.from) + ".." + JSON.stringify(this.to);
};
pexprs$7.Param.prototype.toString = function() {
  return "$" + this.index;
};
pexprs$7.Lex.prototype.toString = function() {
  return "#(" + this.expr.toString() + ")";
};
pexprs$7.Alt.prototype.toString = function() {
  return this.terms.length === 1 ? this.terms[0].toString() : "(" + this.terms.map((term) => term.toString()).join(" | ") + ")";
};
pexprs$7.Seq.prototype.toString = function() {
  return this.factors.length === 1 ? this.factors[0].toString() : "(" + this.factors.map((factor) => factor.toString()).join(" ") + ")";
};
pexprs$7.Iter.prototype.toString = function() {
  return this.expr + this.operator;
};
pexprs$7.Not.prototype.toString = function() {
  return "~" + this.expr;
};
pexprs$7.Lookahead.prototype.toString = function() {
  return "&" + this.expr;
};
pexprs$7.Apply.prototype.toString = function() {
  if (this.args.length > 0) {
    const ps = this.args.map((arg) => arg.toString());
    return this.ruleName + "<" + ps.join(",") + ">";
  } else {
    return this.ruleName;
  }
};
pexprs$7.UnicodeChar.prototype.toString = function() {
  return "\\p{" + this.category + "}";
};
var pexprs$6 = pexprsMain;
const Failure = Failure_1;
const { TerminalNode } = nodes$1$1;
const { assert: assert$1 } = common$l;
const { PExpr, Terminal } = pexprs$6;
class CaseInsensitiveTerminal$1 extends PExpr {
  constructor(param) {
    super();
    this.obj = param;
  }
  _getString(state) {
    const terminal = state.currentApplication().args[this.obj.index];
    assert$1(terminal instanceof Terminal, "expected a Terminal expression");
    return terminal.obj;
  }
  // Implementation of the PExpr API
  allowsSkippingPrecedingSpace() {
    return true;
  }
  eval(state) {
    const { inputStream } = state;
    const origPos = inputStream.pos;
    const matchStr = this._getString(state);
    if (!inputStream.matchString(matchStr, true)) {
      state.processFailure(origPos, this);
      return false;
    } else {
      state.pushBinding(new TerminalNode(matchStr.length), origPos);
      return true;
    }
  }
  getArity() {
    return 1;
  }
  substituteParams(actuals) {
    return new CaseInsensitiveTerminal$1(this.obj.substituteParams(actuals));
  }
  toDisplayString() {
    return this.obj.toDisplayString() + " (case-insensitive)";
  }
  toFailure(grammar2) {
    return new Failure(
      this,
      this.obj.toFailure(grammar2) + " (case-insensitive)",
      "description"
    );
  }
  _isNullable(grammar2, memo) {
    return this.obj._isNullable(grammar2, memo);
  }
}
var CaseInsensitiveTerminal_1 = CaseInsensitiveTerminal$1;
const Interval$1 = Interval_1;
function InputStream$3(source) {
  this.source = source;
  this.pos = 0;
  this.examinedLength = 0;
}
InputStream$3.prototype = {
  atEnd() {
    const ans = this.pos === this.source.length;
    this.examinedLength = Math.max(this.examinedLength, this.pos + 1);
    return ans;
  },
  next() {
    const ans = this.source[this.pos++];
    this.examinedLength = Math.max(this.examinedLength, this.pos);
    return ans;
  },
  nextCharCode() {
    const nextChar = this.next();
    return nextChar && nextChar.charCodeAt(0);
  },
  nextCodePoint() {
    const cp = this.source.slice(this.pos++).codePointAt(0);
    if (cp > 65535) {
      this.pos += 1;
    }
    this.examinedLength = Math.max(this.examinedLength, this.pos);
    return cp;
  },
  matchString(s, optIgnoreCase) {
    let idx;
    if (optIgnoreCase) {
      for (idx = 0; idx < s.length; idx++) {
        const actual = this.next();
        const expected = s[idx];
        if (actual == null || actual.toUpperCase() !== expected.toUpperCase()) {
          return false;
        }
      }
      return true;
    }
    for (idx = 0; idx < s.length; idx++) {
      if (this.next() !== s[idx]) {
        return false;
      }
    }
    return true;
  },
  sourceSlice(startIdx, endIdx) {
    return this.source.slice(startIdx, endIdx);
  },
  interval(startIdx, optEndIdx) {
    return new Interval$1(this.source, startIdx, optEndIdx ? optEndIdx : this.pos);
  }
};
var InputStream_1 = InputStream$3;
const common$4 = common$l;
const util$4 = util$7;
const Interval = Interval_1;
function MatchResult$2(matcher, input, startExpr, cst, cstOffset, rightmostFailurePosition, optRecordedFailures) {
  this.matcher = matcher;
  this.input = input;
  this.startExpr = startExpr;
  this._cst = cst;
  this._cstOffset = cstOffset;
  this._rightmostFailurePosition = rightmostFailurePosition;
  this._rightmostFailures = optRecordedFailures;
  if (this.failed()) {
    common$4.defineLazyProperty(this, "message", function() {
      const detail = "Expected " + this.getExpectedText();
      return util$4.getLineAndColumnMessage(this.input, this.getRightmostFailurePosition()) + detail;
    });
    common$4.defineLazyProperty(this, "shortMessage", function() {
      const detail = "expected " + this.getExpectedText();
      const errorInfo = util$4.getLineAndColumn(this.input, this.getRightmostFailurePosition());
      return "Line " + errorInfo.lineNum + ", col " + errorInfo.colNum + ": " + detail;
    });
  }
}
MatchResult$2.prototype.succeeded = function() {
  return !!this._cst;
};
MatchResult$2.prototype.failed = function() {
  return !this.succeeded();
};
MatchResult$2.prototype.getRightmostFailurePosition = function() {
  return this._rightmostFailurePosition;
};
MatchResult$2.prototype.getRightmostFailures = function() {
  if (!this._rightmostFailures) {
    this.matcher.setInput(this.input);
    const matchResultWithFailures = this.matcher._match(
      this.startExpr,
      false,
      this.getRightmostFailurePosition()
    );
    this._rightmostFailures = matchResultWithFailures.getRightmostFailures();
  }
  return this._rightmostFailures;
};
MatchResult$2.prototype.toString = function() {
  return this.succeeded() ? "[match succeeded]" : "[match failed at position " + this.getRightmostFailurePosition() + "]";
};
MatchResult$2.prototype.getExpectedText = function() {
  if (this.succeeded()) {
    throw new Error("cannot get expected text of a successful MatchResult");
  }
  const sb = new common$4.StringBuffer();
  let failures = this.getRightmostFailures();
  failures = failures.filter((failure) => !failure.isFluffy());
  for (let idx = 0; idx < failures.length; idx++) {
    if (idx > 0) {
      if (idx === failures.length - 1) {
        sb.append(failures.length > 2 ? ", or " : " or ");
      } else {
        sb.append(", ");
      }
    }
    sb.append(failures[idx].toString());
  }
  return sb.contents();
};
MatchResult$2.prototype.getInterval = function() {
  const pos = this.getRightmostFailurePosition();
  return new Interval(this.input, pos, pos);
};
var MatchResult_1 = MatchResult$2;
function PosInfo$1() {
  this.applicationMemoKeyStack = [];
  this.memo = {};
  this.maxExaminedLength = 0;
  this.maxRightmostFailureOffset = -1;
  this.currentLeftRecursion = void 0;
}
PosInfo$1.prototype = {
  isActive(application) {
    return this.applicationMemoKeyStack.indexOf(application.toMemoKey()) >= 0;
  },
  enter(application) {
    this.applicationMemoKeyStack.push(application.toMemoKey());
  },
  exit() {
    this.applicationMemoKeyStack.pop();
  },
  startLeftRecursion(headApplication, memoRec) {
    memoRec.isLeftRecursion = true;
    memoRec.headApplication = headApplication;
    memoRec.nextLeftRecursion = this.currentLeftRecursion;
    this.currentLeftRecursion = memoRec;
    const { applicationMemoKeyStack } = this;
    const indexOfFirstInvolvedRule = applicationMemoKeyStack.indexOf(headApplication.toMemoKey()) + 1;
    const involvedApplicationMemoKeys = applicationMemoKeyStack.slice(
      indexOfFirstInvolvedRule
    );
    memoRec.isInvolved = function(applicationMemoKey) {
      return involvedApplicationMemoKeys.indexOf(applicationMemoKey) >= 0;
    };
    memoRec.updateInvolvedApplicationMemoKeys = function() {
      for (let idx = indexOfFirstInvolvedRule; idx < applicationMemoKeyStack.length; idx++) {
        const applicationMemoKey = applicationMemoKeyStack[idx];
        if (!this.isInvolved(applicationMemoKey)) {
          involvedApplicationMemoKeys.push(applicationMemoKey);
        }
      }
    };
  },
  endLeftRecursion() {
    this.currentLeftRecursion = this.currentLeftRecursion.nextLeftRecursion;
  },
  // Note: this method doesn't get called for the "head" of a left recursion -- for LR heads,
  // the memoized result (which starts out being a failure) is always used.
  shouldUseMemoizedResult(memoRec) {
    if (!memoRec.isLeftRecursion) {
      return true;
    }
    const { applicationMemoKeyStack } = this;
    for (let idx = 0; idx < applicationMemoKeyStack.length; idx++) {
      const applicationMemoKey = applicationMemoKeyStack[idx];
      if (memoRec.isInvolved(applicationMemoKey)) {
        return false;
      }
    }
    return true;
  },
  memoize(memoKey, memoRec) {
    this.memo[memoKey] = memoRec;
    this.maxExaminedLength = Math.max(this.maxExaminedLength, memoRec.examinedLength);
    this.maxRightmostFailureOffset = Math.max(
      this.maxRightmostFailureOffset,
      memoRec.rightmostFailureOffset
    );
    return memoRec;
  },
  clearObsoleteEntries(pos, invalidatedIdx) {
    if (pos + this.maxExaminedLength <= invalidatedIdx) {
      return;
    }
    const { memo } = this;
    this.maxExaminedLength = 0;
    this.maxRightmostFailureOffset = -1;
    Object.keys(memo).forEach((k) => {
      const memoRec = memo[k];
      if (pos + memoRec.examinedLength > invalidatedIdx) {
        delete memo[k];
      } else {
        this.maxExaminedLength = Math.max(this.maxExaminedLength, memoRec.examinedLength);
        this.maxRightmostFailureOffset = Math.max(
          this.maxRightmostFailureOffset,
          memoRec.rightmostFailureOffset
        );
      }
    });
  }
};
var PosInfo_1 = PosInfo$1;
const InputStream$2 = InputStream_1;
const MatchResult$1 = MatchResult_1;
const PosInfo = PosInfo_1;
const Trace = Trace_1;
const pexprs$5 = pexprs$6;
const util$3 = util$7;
let builtInApplySyntacticBody;
util$3.awaitBuiltInRules((builtInRules2) => {
  builtInApplySyntacticBody = builtInRules2.rules.applySyntactic.body;
});
const applySpaces = new pexprs$5.Apply("spaces");
function MatchState$1(matcher, startExpr, optPositionToRecordFailures) {
  this.matcher = matcher;
  this.startExpr = startExpr;
  this.grammar = matcher.grammar;
  this.input = matcher.input;
  this.inputStream = new InputStream$2(matcher.input);
  this.memoTable = matcher.memoTable;
  this._bindings = [];
  this._bindingOffsets = [];
  this._applicationStack = [];
  this._posStack = [0];
  this.inLexifiedContextStack = [false];
  this.rightmostFailurePosition = -1;
  this._rightmostFailurePositionStack = [];
  this._recordedFailuresStack = [];
  if (optPositionToRecordFailures !== void 0) {
    this.positionToRecordFailures = optPositionToRecordFailures;
    this.recordedFailures = /* @__PURE__ */ Object.create(null);
  }
}
MatchState$1.prototype = {
  posToOffset(pos) {
    return pos - this._posStack[this._posStack.length - 1];
  },
  enterApplication(posInfo, app) {
    this._posStack.push(this.inputStream.pos);
    this._applicationStack.push(app);
    this.inLexifiedContextStack.push(false);
    posInfo.enter(app);
    this._rightmostFailurePositionStack.push(this.rightmostFailurePosition);
    this.rightmostFailurePosition = -1;
  },
  exitApplication(posInfo, optNode) {
    const origPos = this._posStack.pop();
    this._applicationStack.pop();
    this.inLexifiedContextStack.pop();
    posInfo.exit();
    this.rightmostFailurePosition = Math.max(
      this.rightmostFailurePosition,
      this._rightmostFailurePositionStack.pop()
    );
    if (optNode) {
      this.pushBinding(optNode, origPos);
    }
  },
  enterLexifiedContext() {
    this.inLexifiedContextStack.push(true);
  },
  exitLexifiedContext() {
    this.inLexifiedContextStack.pop();
  },
  currentApplication() {
    return this._applicationStack[this._applicationStack.length - 1];
  },
  inSyntacticContext() {
    const currentApplication = this.currentApplication();
    if (currentApplication) {
      return currentApplication.isSyntactic() && !this.inLexifiedContext();
    } else {
      return this.startExpr.factors[0].isSyntactic();
    }
  },
  inLexifiedContext() {
    return this.inLexifiedContextStack[this.inLexifiedContextStack.length - 1];
  },
  skipSpaces() {
    this.pushFailuresInfo();
    this.eval(applySpaces);
    this.popBinding();
    this.popFailuresInfo();
    return this.inputStream.pos;
  },
  skipSpacesIfInSyntacticContext() {
    return this.inSyntacticContext() ? this.skipSpaces() : this.inputStream.pos;
  },
  maybeSkipSpacesBefore(expr) {
    if (expr.allowsSkippingPrecedingSpace() && expr !== applySpaces) {
      return this.skipSpacesIfInSyntacticContext();
    } else {
      return this.inputStream.pos;
    }
  },
  pushBinding(node, origPos) {
    this._bindings.push(node);
    this._bindingOffsets.push(this.posToOffset(origPos));
  },
  popBinding() {
    this._bindings.pop();
    this._bindingOffsets.pop();
  },
  numBindings() {
    return this._bindings.length;
  },
  truncateBindings(newLength) {
    while (this._bindings.length > newLength) {
      this.popBinding();
    }
  },
  getCurrentPosInfo() {
    return this.getPosInfo(this.inputStream.pos);
  },
  getPosInfo(pos) {
    let posInfo = this.memoTable[pos];
    if (!posInfo) {
      posInfo = this.memoTable[pos] = new PosInfo();
    }
    return posInfo;
  },
  processFailure(pos, expr) {
    this.rightmostFailurePosition = Math.max(this.rightmostFailurePosition, pos);
    if (this.recordedFailures && pos === this.positionToRecordFailures) {
      const app = this.currentApplication();
      if (app) {
        expr = expr.substituteParams(app.args);
      }
      this.recordFailure(expr.toFailure(this.grammar), false);
    }
  },
  recordFailure(failure, shouldCloneIfNew) {
    const key2 = failure.toKey();
    if (!this.recordedFailures[key2]) {
      this.recordedFailures[key2] = shouldCloneIfNew ? failure.clone() : failure;
    } else if (this.recordedFailures[key2].isFluffy() && !failure.isFluffy()) {
      this.recordedFailures[key2].clearFluffy();
    }
  },
  recordFailures(failures, shouldCloneIfNew) {
    Object.keys(failures).forEach((key2) => {
      this.recordFailure(failures[key2], shouldCloneIfNew);
    });
  },
  cloneRecordedFailures() {
    if (!this.recordedFailures) {
      return void 0;
    }
    const ans = /* @__PURE__ */ Object.create(null);
    Object.keys(this.recordedFailures).forEach((key2) => {
      ans[key2] = this.recordedFailures[key2].clone();
    });
    return ans;
  },
  getRightmostFailurePosition() {
    return this.rightmostFailurePosition;
  },
  _getRightmostFailureOffset() {
    return this.rightmostFailurePosition >= 0 ? this.posToOffset(this.rightmostFailurePosition) : -1;
  },
  // Returns the memoized trace entry for `expr` at `pos`, if one exists, `null` otherwise.
  getMemoizedTraceEntry(pos, expr) {
    const posInfo = this.memoTable[pos];
    if (posInfo && expr instanceof pexprs$5.Apply) {
      const memoRec = posInfo.memo[expr.toMemoKey()];
      if (memoRec && memoRec.traceEntry) {
        const entry = memoRec.traceEntry.cloneWithExpr(expr);
        entry.isMemoized = true;
        return entry;
      }
    }
    return null;
  },
  // Returns a new trace entry, with the currently active trace array as its children.
  getTraceEntry(pos, expr, succeeded, bindings) {
    if (expr instanceof pexprs$5.Apply) {
      const app = this.currentApplication();
      const actuals = app ? app.args : [];
      expr = expr.substituteParams(actuals);
    }
    return this.getMemoizedTraceEntry(pos, expr) || new Trace(this.input, pos, this.inputStream.pos, expr, succeeded, bindings, this.trace);
  },
  isTracing() {
    return !!this.trace;
  },
  hasNecessaryInfo(memoRec) {
    if (this.trace && !memoRec.traceEntry) {
      return false;
    }
    if (this.recordedFailures && this.inputStream.pos + memoRec.rightmostFailureOffset === this.positionToRecordFailures) {
      return !!memoRec.failuresAtRightmostPosition;
    }
    return true;
  },
  useMemoizedResult(origPos, memoRec) {
    if (this.trace) {
      this.trace.push(memoRec.traceEntry);
    }
    const memoRecRightmostFailurePosition = this.inputStream.pos + memoRec.rightmostFailureOffset;
    this.rightmostFailurePosition = Math.max(
      this.rightmostFailurePosition,
      memoRecRightmostFailurePosition
    );
    if (this.recordedFailures && this.positionToRecordFailures === memoRecRightmostFailurePosition && memoRec.failuresAtRightmostPosition) {
      this.recordFailures(memoRec.failuresAtRightmostPosition, true);
    }
    this.inputStream.examinedLength = Math.max(
      this.inputStream.examinedLength,
      memoRec.examinedLength + origPos
    );
    if (memoRec.value) {
      this.inputStream.pos += memoRec.matchLength;
      this.pushBinding(memoRec.value, origPos);
      return true;
    }
    return false;
  },
  // Evaluate `expr` and return `true` if it succeeded, `false` otherwise. On success, `bindings`
  // will have `expr.getArity()` more elements than before, and the input stream's position may
  // have increased. On failure, `bindings` and position will be unchanged.
  eval(expr) {
    const { inputStream } = this;
    const origNumBindings = this._bindings.length;
    let origRecordedFailures;
    if (this.recordedFailures) {
      origRecordedFailures = this.recordedFailures;
      this.recordedFailures = /* @__PURE__ */ Object.create(null);
    }
    const origPos = inputStream.pos;
    const memoPos = this.maybeSkipSpacesBefore(expr);
    let origTrace;
    if (this.trace) {
      origTrace = this.trace;
      this.trace = [];
    }
    const ans = expr.eval(this);
    if (this.trace) {
      const bindings = this._bindings.slice(origNumBindings);
      const traceEntry = this.getTraceEntry(memoPos, expr, ans, bindings);
      traceEntry.isImplicitSpaces = expr === applySpaces;
      traceEntry.isRootNode = expr === this.startExpr;
      origTrace.push(traceEntry);
      this.trace = origTrace;
    }
    if (ans) {
      if (this.recordedFailures && inputStream.pos === this.positionToRecordFailures) {
        Object.keys(this.recordedFailures).forEach((key2) => {
          this.recordedFailures[key2].makeFluffy();
        });
      }
    } else {
      inputStream.pos = origPos;
      this.truncateBindings(origNumBindings);
    }
    if (this.recordedFailures) {
      this.recordFailures(origRecordedFailures, false);
    }
    if (expr === builtInApplySyntacticBody) {
      this.skipSpaces();
    }
    return ans;
  },
  getMatchResult() {
    this.eval(this.startExpr);
    let rightmostFailures;
    if (this.recordedFailures) {
      rightmostFailures = Object.keys(this.recordedFailures).map(
        (key2) => this.recordedFailures[key2]
      );
    }
    const cst = this._bindings[0];
    if (cst) {
      cst.grammar = this.grammar;
    }
    return new MatchResult$1(
      this.matcher,
      this.input,
      this.startExpr,
      cst,
      this._bindingOffsets[0],
      this.rightmostFailurePosition,
      rightmostFailures
    );
  },
  getTrace() {
    this.trace = [];
    const matchResult = this.getMatchResult();
    const rootTrace = this.trace[this.trace.length - 1];
    rootTrace.result = matchResult;
    return rootTrace;
  },
  pushFailuresInfo() {
    this._rightmostFailurePositionStack.push(this.rightmostFailurePosition);
    this._recordedFailuresStack.push(this.recordedFailures);
  },
  popFailuresInfo() {
    this.rightmostFailurePosition = this._rightmostFailurePositionStack.pop();
    this.recordedFailures = this._recordedFailuresStack.pop();
  }
};
var MatchState_1 = MatchState$1;
const MatchState = MatchState_1;
const pexprs$4 = pexprs$6;
function Matcher$1(grammar2) {
  this.grammar = grammar2;
  this.memoTable = [];
  this.input = "";
}
Matcher$1.prototype.getInput = function() {
  return this.input;
};
Matcher$1.prototype.setInput = function(str) {
  if (this.input !== str) {
    this.replaceInputRange(0, this.input.length, str);
  }
  return this;
};
Matcher$1.prototype.replaceInputRange = function(startIdx, endIdx, str) {
  const currentInput = this.input;
  if (startIdx < 0 || startIdx > currentInput.length || endIdx < 0 || endIdx > currentInput.length || startIdx > endIdx) {
    throw new Error("Invalid indices: " + startIdx + " and " + endIdx);
  }
  this.input = currentInput.slice(0, startIdx) + str + currentInput.slice(endIdx);
  const restOfMemoTable = this.memoTable.slice(endIdx);
  this.memoTable.length = startIdx;
  for (let idx = 0; idx < str.length; idx++) {
    this.memoTable.push(void 0);
  }
  restOfMemoTable.forEach(function(posInfo) {
    this.memoTable.push(posInfo);
  }, this);
  for (let pos = 0; pos < startIdx; pos++) {
    const posInfo = this.memoTable[pos];
    if (posInfo) {
      posInfo.clearObsoleteEntries(pos, startIdx);
    }
  }
  return this;
};
Matcher$1.prototype.match = function(optStartApplicationStr) {
  return this._match(this._getStartExpr(optStartApplicationStr), false);
};
Matcher$1.prototype.trace = function(optStartApplicationStr) {
  return this._match(this._getStartExpr(optStartApplicationStr), true);
};
Matcher$1.prototype._match = function(startExpr, tracing, optPositionToRecordFailures) {
  const state = new MatchState(this, startExpr, optPositionToRecordFailures);
  return tracing ? state.getTrace() : state.getMatchResult();
};
Matcher$1.prototype._getStartExpr = function(optStartApplicationStr) {
  const applicationStr = optStartApplicationStr || this.grammar.defaultStartRule;
  if (!applicationStr) {
    throw new Error("Missing start rule argument -- the grammar has no default start rule.");
  }
  const startApp = this.grammar.parseApplication(applicationStr);
  return new pexprs$4.Seq([startApp, pexprs$4.end]);
};
var Matcher_1 = Matcher$1;
const InputStream$1 = InputStream_1;
const { IterationNode } = nodes$1$1;
const MatchResult = MatchResult_1;
const common$3 = common$l;
const errors$3 = errors$9;
const util$2 = util$7;
const globalActionStack = [];
const hasOwnProperty = (x, prop) => Object.prototype.hasOwnProperty.call(x, prop);
class Wrapper {
  constructor(node, sourceInterval, baseInterval) {
    this._node = node;
    this.source = sourceInterval;
    this._baseInterval = baseInterval;
    if (node.isNonterminal()) {
      common$3.assert(sourceInterval === baseInterval);
    }
    this._childWrappers = [];
  }
  toString() {
    return "[semantics wrapper for " + this._node.grammar.name + "]";
  }
  _forgetMemoizedResultFor(attributeName) {
    delete this._node[this._semantics.attributeKeys[attributeName]];
    this.children.forEach((child) => {
      child._forgetMemoizedResultFor(attributeName);
    });
  }
  // Returns the wrapper of the specified child node. Child wrappers are created lazily and
  // cached in the parent wrapper's `_childWrappers` instance variable.
  child(idx) {
    if (!(0 <= idx && idx < this._node.numChildren())) {
      return void 0;
    }
    let childWrapper = this._childWrappers[idx];
    if (!childWrapper) {
      const childNode = this._node.childAt(idx);
      const offset = this._node.childOffsets[idx];
      const source = this._baseInterval.subInterval(offset, childNode.matchLength);
      const base = childNode.isNonterminal() ? source : this._baseInterval;
      childWrapper = this._childWrappers[idx] = this._semantics.wrap(childNode, source, base);
    }
    return childWrapper;
  }
  // Returns an array containing the wrappers of all of the children of the node associated
  // with this wrapper.
  _children() {
    for (let idx = 0; idx < this._node.numChildren(); idx++) {
      this.child(idx);
    }
    return this._childWrappers;
  }
  // Returns `true` if the CST node associated with this wrapper corresponds to an iteration
  // expression, i.e., a Kleene-*, Kleene-+, or an optional. Returns `false` otherwise.
  isIteration() {
    return this._node.isIteration();
  }
  // Returns `true` if the CST node associated with this wrapper is a terminal node, `false`
  // otherwise.
  isTerminal() {
    return this._node.isTerminal();
  }
  // Returns `true` if the CST node associated with this wrapper is a nonterminal node, `false`
  // otherwise.
  isNonterminal() {
    return this._node.isNonterminal();
  }
  // Returns `true` if the CST node associated with this wrapper is a nonterminal node
  // corresponding to a syntactic rule, `false` otherwise.
  isSyntactic() {
    return this.isNonterminal() && this._node.isSyntactic();
  }
  // Returns `true` if the CST node associated with this wrapper is a nonterminal node
  // corresponding to a lexical rule, `false` otherwise.
  isLexical() {
    return this.isNonterminal() && this._node.isLexical();
  }
  // Returns `true` if the CST node associated with this wrapper is an iterator node
  // having either one or no child (? operator), `false` otherwise.
  // Otherwise, throws an exception.
  isOptional() {
    return this._node.isOptional();
  }
  // Create a new _iter wrapper in the same semantics as this wrapper.
  iteration(optChildWrappers) {
    const childWrappers = optChildWrappers || [];
    const childNodes = childWrappers.map((c) => c._node);
    const iter = new IterationNode(childNodes, [], -1, false);
    const wrapper = this._semantics.wrap(iter, null, null);
    wrapper._childWrappers = childWrappers;
    return wrapper;
  }
  // Returns an array containing the children of this CST node.
  get children() {
    return this._children();
  }
  // Returns the name of grammar rule that created this CST node.
  get ctorName() {
    return this._node.ctorName;
  }
  // TODO: Remove this eventually (deprecated in v0.12).
  get interval() {
    throw new Error("The `interval` property is deprecated -- use `source` instead");
  }
  // Returns the number of children of this CST node.
  get numChildren() {
    return this._node.numChildren();
  }
  // Returns the contents of the input stream consumed by this CST node.
  get sourceString() {
    return this.source.contents;
  }
}
function Semantics$2(grammar2, superSemantics) {
  const self2 = this;
  this.grammar = grammar2;
  this.checkedActionDicts = false;
  this.Wrapper = class extends (superSemantics ? superSemantics.Wrapper : Wrapper) {
    constructor(node, sourceInterval, baseInterval) {
      super(node, sourceInterval, baseInterval);
      self2.checkActionDictsIfHaventAlready();
      this._semantics = self2;
    }
  };
  this.super = superSemantics;
  if (superSemantics) {
    if (!(grammar2.equals(this.super.grammar) || grammar2._inheritsFrom(this.super.grammar))) {
      throw new Error(
        "Cannot extend a semantics for grammar '" + this.super.grammar.name + "' for use with grammar '" + grammar2.name + "' (not a sub-grammar)"
      );
    }
    this.operations = Object.create(this.super.operations);
    this.attributes = Object.create(this.super.attributes);
    this.attributeKeys = /* @__PURE__ */ Object.create(null);
    for (const attributeName in this.attributes) {
      Object.defineProperty(this.attributeKeys, attributeName, {
        value: util$2.uniqueId(attributeName)
      });
    }
  } else {
    this.operations = /* @__PURE__ */ Object.create(null);
    this.attributes = /* @__PURE__ */ Object.create(null);
    this.attributeKeys = /* @__PURE__ */ Object.create(null);
  }
}
Semantics$2.prototype.toString = function() {
  return "[semantics for " + this.grammar.name + "]";
};
Semantics$2.prototype.checkActionDictsIfHaventAlready = function() {
  if (!this.checkedActionDicts) {
    this.checkActionDicts();
    this.checkedActionDicts = true;
  }
};
Semantics$2.prototype.checkActionDicts = function() {
  let name;
  for (name in this.operations) {
    this.operations[name].checkActionDict(this.grammar);
  }
  for (name in this.attributes) {
    this.attributes[name].checkActionDict(this.grammar);
  }
};
Semantics$2.prototype.toRecipe = function(semanticsOnly) {
  function hasSuperSemantics(s) {
    return s.super !== Semantics$2.BuiltInSemantics._getSemantics();
  }
  let str = "(function(g) {\n";
  if (hasSuperSemantics(this)) {
    str += "  var semantics = " + this.super.toRecipe(true) + "(g";
    const superSemanticsGrammar = this.super.grammar;
    let relatedGrammar = this.grammar;
    while (relatedGrammar !== superSemanticsGrammar) {
      str += ".superGrammar";
      relatedGrammar = relatedGrammar.superGrammar;
    }
    str += ");\n";
    str += "  return g.extendSemantics(semantics)";
  } else {
    str += "  return g.createSemantics()";
  }
  ["Operation", "Attribute"].forEach((type) => {
    const semanticOperations = this[type.toLowerCase() + "s"];
    Object.keys(semanticOperations).forEach((name) => {
      const { actionDict, formals, builtInDefault } = semanticOperations[name];
      let signature = name;
      if (formals.length > 0) {
        signature += "(" + formals.join(", ") + ")";
      }
      let method;
      if (hasSuperSemantics(this) && this.super[type.toLowerCase() + "s"][name]) {
        method = "extend" + type;
      } else {
        method = "add" + type;
      }
      str += "\n    ." + method + "(" + JSON.stringify(signature) + ", {";
      const srcArray = [];
      Object.keys(actionDict).forEach((actionName) => {
        if (actionDict[actionName] !== builtInDefault) {
          let source = actionDict[actionName].toString().trim();
          source = source.replace(/^.*\(/, "function(");
          srcArray.push("\n      " + JSON.stringify(actionName) + ": " + source);
        }
      });
      str += srcArray.join(",") + "\n    })";
    });
  });
  str += ";\n  })";
  if (!semanticsOnly) {
    str = "(function() {\n  var grammar = this.fromRecipe(" + this.grammar.toRecipe() + ");\n  var semantics = " + str + "(grammar);\n  return semantics;\n});\n";
  }
  return str;
};
function parseSignature$1(signature, type) {
  if (!Semantics$2.prototypeGrammar) {
    common$3.assert(signature.indexOf("(") === -1);
    return {
      name: signature,
      formals: []
    };
  }
  const r = Semantics$2.prototypeGrammar.match(
    signature,
    type === "operation" ? "OperationSignature" : "AttributeSignature"
  );
  if (r.failed()) {
    throw new Error(r.message);
  }
  return Semantics$2.prototypeGrammarSemantics(r).parse();
}
function newDefaultAction(type, name, doIt) {
  return function(...children) {
    const thisThing = this._semantics.operations[name] || this._semantics.attributes[name];
    const args = thisThing.formals.map((formal) => this.args[formal]);
    if (!this.isIteration() && children.length === 1) {
      return doIt.apply(children[0], args);
    } else {
      throw errors$3.missingSemanticAction(this.ctorName, name, type, globalActionStack);
    }
  };
}
Semantics$2.prototype.addOperationOrAttribute = function(type, signature, actionDict) {
  const typePlural = type + "s";
  const parsedNameAndFormalArgs = parseSignature$1(signature, type);
  const { name } = parsedNameAndFormalArgs;
  const { formals } = parsedNameAndFormalArgs;
  this.assertNewName(name, type);
  const builtInDefault = newDefaultAction(type, name, doIt);
  const realActionDict = { _default: builtInDefault };
  Object.keys(actionDict).forEach((name2) => {
    realActionDict[name2] = actionDict[name2];
  });
  const entry = type === "operation" ? new Operation(name, formals, realActionDict, builtInDefault) : new Attribute(name, realActionDict, builtInDefault);
  entry.checkActionDict(this.grammar);
  this[typePlural][name] = entry;
  function doIt(...args) {
    const thisThing = this._semantics[typePlural][name];
    if (arguments.length !== thisThing.formals.length) {
      throw new Error(
        "Invalid number of arguments passed to " + name + " " + type + " (expected " + thisThing.formals.length + ", got " + arguments.length + ")"
      );
    }
    const argsObj = /* @__PURE__ */ Object.create(null);
    for (const [idx, val] of Object.entries(args)) {
      const formal = thisThing.formals[idx];
      argsObj[formal] = val;
    }
    const oldArgs = this.args;
    this.args = argsObj;
    const ans = thisThing.execute(this._semantics, this);
    this.args = oldArgs;
    return ans;
  }
  if (type === "operation") {
    this.Wrapper.prototype[name] = doIt;
    this.Wrapper.prototype[name].toString = function() {
      return "[" + name + " operation]";
    };
  } else {
    Object.defineProperty(this.Wrapper.prototype, name, {
      get: doIt,
      configurable: true
      // So the property can be deleted.
    });
    Object.defineProperty(this.attributeKeys, name, {
      value: util$2.uniqueId(name)
    });
  }
};
Semantics$2.prototype.extendOperationOrAttribute = function(type, name, actionDict) {
  const typePlural = type + "s";
  parseSignature$1(name, "attribute");
  if (!(this.super && name in this.super[typePlural])) {
    throw new Error(
      "Cannot extend " + type + " '" + name + "': did not inherit an " + type + " with that name"
    );
  }
  if (hasOwnProperty(this[typePlural], name)) {
    throw new Error("Cannot extend " + type + " '" + name + "' again");
  }
  const inheritedFormals = this[typePlural][name].formals;
  const inheritedActionDict = this[typePlural][name].actionDict;
  const newActionDict = Object.create(inheritedActionDict);
  Object.keys(actionDict).forEach((name2) => {
    newActionDict[name2] = actionDict[name2];
  });
  this[typePlural][name] = type === "operation" ? new Operation(name, inheritedFormals, newActionDict) : new Attribute(name, newActionDict);
  this[typePlural][name].checkActionDict(this.grammar);
};
Semantics$2.prototype.assertNewName = function(name, type) {
  if (hasOwnProperty(Wrapper.prototype, name)) {
    throw new Error("Cannot add " + type + " '" + name + "': that's a reserved name");
  }
  if (name in this.operations) {
    throw new Error(
      "Cannot add " + type + " '" + name + "': an operation with that name already exists"
    );
  }
  if (name in this.attributes) {
    throw new Error(
      "Cannot add " + type + " '" + name + "': an attribute with that name already exists"
    );
  }
};
Semantics$2.prototype.wrap = function(node, source, optBaseInterval) {
  const baseInterval = optBaseInterval || source;
  return node instanceof this.Wrapper ? node : new this.Wrapper(node, source, baseInterval);
};
Semantics$2.createSemantics = function(grammar2, optSuperSemantics) {
  const s = new Semantics$2(
    grammar2,
    optSuperSemantics !== void 0 ? optSuperSemantics : Semantics$2.BuiltInSemantics._getSemantics()
  );
  const proxy = function ASemantics(matchResult) {
    if (!(matchResult instanceof MatchResult)) {
      throw new TypeError(
        "Semantics expected a MatchResult, but got " + common$3.unexpectedObjToString(matchResult)
      );
    }
    if (matchResult.failed()) {
      throw new TypeError("cannot apply Semantics to " + matchResult.toString());
    }
    const cst = matchResult._cst;
    if (cst.grammar !== grammar2) {
      throw new Error(
        "Cannot use a MatchResult from grammar '" + cst.grammar.name + "' with a semantics for '" + grammar2.name + "'"
      );
    }
    const inputStream = new InputStream$1(matchResult.input);
    return s.wrap(cst, inputStream.interval(matchResult._cstOffset, matchResult.input.length));
  };
  proxy.addOperation = function(signature, actionDict) {
    s.addOperationOrAttribute("operation", signature, actionDict);
    return proxy;
  };
  proxy.extendOperation = function(name, actionDict) {
    s.extendOperationOrAttribute("operation", name, actionDict);
    return proxy;
  };
  proxy.addAttribute = function(name, actionDict) {
    s.addOperationOrAttribute("attribute", name, actionDict);
    return proxy;
  };
  proxy.extendAttribute = function(name, actionDict) {
    s.extendOperationOrAttribute("attribute", name, actionDict);
    return proxy;
  };
  proxy._getActionDict = function(operationOrAttributeName) {
    const action = s.operations[operationOrAttributeName] || s.attributes[operationOrAttributeName];
    if (!action) {
      throw new Error(
        '"' + operationOrAttributeName + '" is not a valid operation or attribute name in this semantics for "' + grammar2.name + '"'
      );
    }
    return action.actionDict;
  };
  proxy._remove = function(operationOrAttributeName) {
    let semantic;
    if (operationOrAttributeName in s.operations) {
      semantic = s.operations[operationOrAttributeName];
      delete s.operations[operationOrAttributeName];
    } else if (operationOrAttributeName in s.attributes) {
      semantic = s.attributes[operationOrAttributeName];
      delete s.attributes[operationOrAttributeName];
    }
    delete s.Wrapper.prototype[operationOrAttributeName];
    return semantic;
  };
  proxy.getOperationNames = function() {
    return Object.keys(s.operations);
  };
  proxy.getAttributeNames = function() {
    return Object.keys(s.attributes);
  };
  proxy.getGrammar = function() {
    return s.grammar;
  };
  proxy.toRecipe = function(semanticsOnly) {
    return s.toRecipe(semanticsOnly);
  };
  proxy.toString = s.toString.bind(s);
  proxy._getSemantics = function() {
    return s;
  };
  return proxy;
};
class Operation {
  constructor(name, formals, actionDict, builtInDefault) {
    this.name = name;
    this.formals = formals;
    this.actionDict = actionDict;
    this.builtInDefault = builtInDefault;
  }
  checkActionDict(grammar2) {
    grammar2._checkTopDownActionDict(this.typeName, this.name, this.actionDict);
  }
  // Execute this operation on the CST node associated with `nodeWrapper` in the context of the
  // given Semantics instance.
  execute(semantics, nodeWrapper) {
    try {
      const { ctorName } = nodeWrapper._node;
      let actionFn = this.actionDict[ctorName];
      if (actionFn) {
        globalActionStack.push([this, ctorName]);
        return actionFn.apply(nodeWrapper, nodeWrapper._children());
      }
      if (nodeWrapper.isNonterminal()) {
        actionFn = this.actionDict._nonterminal;
        if (actionFn) {
          globalActionStack.push([this, "_nonterminal", ctorName]);
          return actionFn.apply(nodeWrapper, nodeWrapper._children());
        }
      }
      globalActionStack.push([this, "default action", ctorName]);
      return this.actionDict._default.apply(nodeWrapper, nodeWrapper._children());
    } finally {
      globalActionStack.pop();
    }
  }
}
Operation.prototype.typeName = "operation";
class Attribute extends Operation {
  constructor(name, actionDict, builtInDefault) {
    super(name, [], actionDict, builtInDefault);
  }
  execute(semantics, nodeWrapper) {
    const node = nodeWrapper._node;
    const key2 = semantics.attributeKeys[this.name];
    if (!hasOwnProperty(node, key2)) {
      node[key2] = Operation.prototype.execute.call(this, semantics, nodeWrapper);
    }
    return node[key2];
  }
}
Attribute.prototype.typeName = "attribute";
var Semantics_1 = Semantics$2;
const CaseInsensitiveTerminal = CaseInsensitiveTerminal_1;
const Matcher = Matcher_1;
const Semantics$1 = Semantics_1;
const common$2 = common$l;
const errors$2 = errors$9;
const pexprs$3 = pexprs$6;
const SPECIAL_ACTION_NAMES = ["_iter", "_terminal", "_nonterminal", "_default"];
function getSortedRuleValues(grammar2) {
  return Object.keys(grammar2.rules).sort().map((name) => grammar2.rules[name]);
}
const jsonToJS = (str) => str.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
function Grammar$4(name, superGrammar, rules, optDefaultStartRule) {
  this.name = name;
  this.superGrammar = superGrammar;
  this.rules = rules;
  if (optDefaultStartRule) {
    if (!(optDefaultStartRule in rules)) {
      throw new Error(
        "Invalid start rule: '" + optDefaultStartRule + "' is not a rule in grammar '" + name + "'"
      );
    }
    this.defaultStartRule = optDefaultStartRule;
  }
}
let ohmGrammar$2;
let buildGrammar$1;
Grammar$4.initApplicationParser = function(grammar2, builderFn) {
  ohmGrammar$2 = grammar2;
  buildGrammar$1 = builderFn;
};
Grammar$4.prototype = {
  matcher() {
    return new Matcher(this);
  },
  // Return true if the grammar is a built-in grammar, otherwise false.
  // NOTE: This might give an unexpected result if called before BuiltInRules is defined!
  isBuiltIn() {
    return this === Grammar$4.ProtoBuiltInRules || this === Grammar$4.BuiltInRules;
  },
  equals(g2) {
    if (this === g2) {
      return true;
    }
    if (g2 == null || this.name !== g2.name || this.defaultStartRule !== g2.defaultStartRule || !(this.superGrammar === g2.superGrammar || this.superGrammar.equals(g2.superGrammar))) {
      return false;
    }
    const myRules = getSortedRuleValues(this);
    const otherRules = getSortedRuleValues(g2);
    return myRules.length === otherRules.length && myRules.every((rule, i) => {
      return rule.description === otherRules[i].description && rule.formals.join(",") === otherRules[i].formals.join(",") && rule.body.toString() === otherRules[i].body.toString();
    });
  },
  match(input, optStartApplication) {
    const m = this.matcher();
    m.replaceInputRange(0, 0, input);
    return m.match(optStartApplication);
  },
  trace(input, optStartApplication) {
    const m = this.matcher();
    m.replaceInputRange(0, 0, input);
    return m.trace(optStartApplication);
  },
  createSemantics() {
    return Semantics$1.createSemantics(this);
  },
  extendSemantics(superSemantics) {
    return Semantics$1.createSemantics(this, superSemantics._getSemantics());
  },
  // Check that every key in `actionDict` corresponds to a semantic action, and that it maps to
  // a function of the correct arity. If not, throw an exception.
  _checkTopDownActionDict(what, name, actionDict) {
    const problems = [];
    for (const k in actionDict) {
      const v2 = actionDict[k];
      const isSpecialAction = SPECIAL_ACTION_NAMES.includes(k);
      if (!isSpecialAction && !(k in this.rules)) {
        problems.push(`'${k}' is not a valid semantic action for '${this.name}'`);
        continue;
      }
      if (typeof v2 !== "function") {
        problems.push(`'${k}' must be a function in an action dictionary for '${this.name}'`);
        continue;
      }
      const actual = v2.length;
      const expected = this._topDownActionArity(k);
      if (actual !== expected) {
        let details;
        if (k === "_iter" || k === "_nonterminal") {
          details = `it should use a rest parameter, e.g. \`${k}(...children) {}\`. NOTE: this is new in Ohm v16  see https://ohmjs.org/d/ati for details.`;
        } else {
          details = `expected ${expected}, got ${actual}`;
        }
        problems.push(`Semantic action '${k}' has the wrong arity: ${details}`);
      }
    }
    if (problems.length > 0) {
      const prettyProblems = problems.map((problem) => "- " + problem);
      const error2 = new Error(
        [
          `Found errors in the action dictionary of the '${name}' ${what}:`,
          ...prettyProblems
        ].join("\n")
      );
      error2.problems = problems;
      throw error2;
    }
  },
  // Return the expected arity for a semantic action named `actionName`, which
  // is either a rule name or a special action name like '_nonterminal'.
  _topDownActionArity(actionName) {
    return SPECIAL_ACTION_NAMES.includes(actionName) ? 0 : this.rules[actionName].body.getArity();
  },
  _inheritsFrom(grammar2) {
    let g2 = this.superGrammar;
    while (g2) {
      if (g2.equals(grammar2, true)) {
        return true;
      }
      g2 = g2.superGrammar;
    }
    return false;
  },
  toRecipe(superGrammarExpr = void 0) {
    const metaInfo = {};
    if (this.source) {
      metaInfo.source = this.source.contents;
    }
    let startRule = null;
    if (this.defaultStartRule) {
      startRule = this.defaultStartRule;
    }
    const rules = {};
    Object.keys(this.rules).forEach((ruleName) => {
      const ruleInfo = this.rules[ruleName];
      const { body } = ruleInfo;
      const isDefinition = !this.superGrammar || !this.superGrammar.rules[ruleName];
      let operation;
      if (isDefinition) {
        operation = "define";
      } else {
        operation = body instanceof pexprs$3.Extend ? "extend" : "override";
      }
      const metaInfo2 = {};
      if (ruleInfo.source && this.source) {
        const adjusted = ruleInfo.source.relativeTo(this.source);
        metaInfo2.sourceInterval = [adjusted.startIdx, adjusted.endIdx];
      }
      const description = isDefinition ? ruleInfo.description : null;
      const bodyRecipe = body.outputRecipe(ruleInfo.formals, this.source);
      rules[ruleName] = [
        operation,
        // "define"/"extend"/"override"
        metaInfo2,
        description,
        ruleInfo.formals,
        bodyRecipe
      ];
    });
    let superGrammarOutput = "null";
    if (superGrammarExpr) {
      superGrammarOutput = superGrammarExpr;
    } else if (this.superGrammar && !this.superGrammar.isBuiltIn()) {
      superGrammarOutput = this.superGrammar.toRecipe();
    }
    const recipeElements = [
      ...["grammar", metaInfo, this.name].map(JSON.stringify),
      superGrammarOutput,
      ...[startRule, rules].map(JSON.stringify)
    ];
    return jsonToJS(`[${recipeElements.join(",")}]`);
  },
  // TODO: Come up with better names for these methods.
  // TODO: Write the analog of these methods for inherited attributes.
  toOperationActionDictionaryTemplate() {
    return this._toOperationOrAttributeActionDictionaryTemplate();
  },
  toAttributeActionDictionaryTemplate() {
    return this._toOperationOrAttributeActionDictionaryTemplate();
  },
  _toOperationOrAttributeActionDictionaryTemplate() {
    const sb = new common$2.StringBuffer();
    sb.append("{");
    let first = true;
    for (const ruleName in this.rules) {
      const { body } = this.rules[ruleName];
      if (first) {
        first = false;
      } else {
        sb.append(",");
      }
      sb.append("\n");
      sb.append("  ");
      this.addSemanticActionTemplate(ruleName, body, sb);
    }
    sb.append("\n}");
    return sb.contents();
  },
  addSemanticActionTemplate(ruleName, body, sb) {
    sb.append(ruleName);
    sb.append(": function(");
    const arity = this._topDownActionArity(ruleName);
    sb.append(common$2.repeat("_", arity).join(", "));
    sb.append(") {\n");
    sb.append("  }");
  },
  // Parse a string which expresses a rule application in this grammar, and return the
  // resulting Apply node.
  parseApplication(str) {
    let app;
    if (str.indexOf("<") === -1) {
      app = new pexprs$3.Apply(str);
    } else {
      const cst = ohmGrammar$2.match(str, "Base_application");
      app = buildGrammar$1(cst, {});
    }
    if (!(app.ruleName in this.rules)) {
      throw errors$2.undeclaredRule(app.ruleName, this.name);
    }
    const { formals } = this.rules[app.ruleName];
    if (formals.length !== app.args.length) {
      const { source } = this.rules[app.ruleName];
      throw errors$2.wrongNumberOfParameters(
        app.ruleName,
        formals.length,
        app.args.length,
        source
      );
    }
    return app;
  }
};
Grammar$4.ProtoBuiltInRules = new Grammar$4(
  "ProtoBuiltInRules",
  // name
  void 0,
  // supergrammar
  {
    any: {
      body: pexprs$3.any,
      formals: [],
      description: "any character",
      primitive: true
    },
    end: {
      body: pexprs$3.end,
      formals: [],
      description: "end of input",
      primitive: true
    },
    caseInsensitive: {
      body: new CaseInsensitiveTerminal(new pexprs$3.Param(0)),
      formals: ["str"],
      primitive: true
    },
    lower: {
      body: new pexprs$3.UnicodeChar("Ll"),
      formals: [],
      description: "a lowercase letter",
      primitive: true
    },
    upper: {
      body: new pexprs$3.UnicodeChar("Lu"),
      formals: [],
      description: "an uppercase letter",
      primitive: true
    },
    // Union of Lt (titlecase), Lm (modifier), and Lo (other), i.e. any letter not in Ll or Lu.
    unicodeLtmo: {
      body: new pexprs$3.UnicodeChar("Ltmo"),
      formals: [],
      description: "a Unicode character in Lt, Lm, or Lo",
      primitive: true
    },
    // These rules are not truly primitive (they could be written in userland) but are defined
    // here for bootstrapping purposes.
    spaces: {
      body: new pexprs$3.Star(new pexprs$3.Apply("space")),
      formals: []
    },
    space: {
      body: new pexprs$3.Range("\0", " "),
      formals: [],
      description: "a space"
    }
  }
);
var Grammar_1 = Grammar$4;
const Grammar$3 = Grammar_1;
const InputStream = InputStream_1;
const common$1$1 = common$l;
const errors$1 = errors$9;
const pexprs$2 = pexprs$6;
function GrammarDecl$1(name) {
  this.name = name;
}
GrammarDecl$1.prototype.sourceInterval = function(startIdx, endIdx) {
  return this.source.subInterval(startIdx, endIdx - startIdx);
};
GrammarDecl$1.prototype.ensureSuperGrammar = function() {
  if (!this.superGrammar) {
    this.withSuperGrammar(
      // TODO: The conditional expression below is an ugly hack. It's kind of ok because
      // I doubt anyone will ever try to declare a grammar called `BuiltInRules`. Still,
      // we should try to find a better way to do this.
      this.name === "BuiltInRules" ? Grammar$3.ProtoBuiltInRules : Grammar$3.BuiltInRules
    );
  }
  return this.superGrammar;
};
GrammarDecl$1.prototype.ensureSuperGrammarRuleForOverriding = function(name, source) {
  const ruleInfo = this.ensureSuperGrammar().rules[name];
  if (!ruleInfo) {
    throw errors$1.cannotOverrideUndeclaredRule(name, this.superGrammar.name, source);
  }
  return ruleInfo;
};
GrammarDecl$1.prototype.installOverriddenOrExtendedRule = function(name, formals, body, source) {
  const duplicateParameterNames2 = common$1$1.getDuplicates(formals);
  if (duplicateParameterNames2.length > 0) {
    throw errors$1.duplicateParameterNames(name, duplicateParameterNames2, source);
  }
  const ruleInfo = this.ensureSuperGrammar().rules[name];
  const expectedFormals = ruleInfo.formals;
  const expectedNumFormals = expectedFormals ? expectedFormals.length : 0;
  if (formals.length !== expectedNumFormals) {
    throw errors$1.wrongNumberOfParameters(name, expectedNumFormals, formals.length, source);
  }
  return this.install(name, formals, body, ruleInfo.description, source);
};
GrammarDecl$1.prototype.install = function(name, formals, body, description, source) {
  this.rules[name] = {
    body: body.introduceParams(formals),
    formals,
    description,
    source
  };
  return this;
};
GrammarDecl$1.prototype.withSuperGrammar = function(superGrammar) {
  if (this.superGrammar) {
    throw new Error("the super grammar of a GrammarDecl cannot be set more than once");
  }
  this.superGrammar = superGrammar;
  this.rules = Object.create(superGrammar.rules);
  if (!superGrammar.isBuiltIn()) {
    this.defaultStartRule = superGrammar.defaultStartRule;
  }
  return this;
};
GrammarDecl$1.prototype.withDefaultStartRule = function(ruleName) {
  this.defaultStartRule = ruleName;
  return this;
};
GrammarDecl$1.prototype.withSource = function(source) {
  this.source = new InputStream(source).interval(0, source.length);
  return this;
};
GrammarDecl$1.prototype.build = function() {
  const grammar2 = new Grammar$3(
    this.name,
    this.ensureSuperGrammar(),
    this.rules,
    this.defaultStartRule
  );
  const grammarErrors = [];
  let grammarHasInvalidApplications = false;
  Object.keys(grammar2.rules).forEach((ruleName) => {
    const { body } = grammar2.rules[ruleName];
    try {
      body.assertChoicesHaveUniformArity(ruleName);
    } catch (e) {
      grammarErrors.push(e);
    }
    try {
      body.assertAllApplicationsAreValid(ruleName, grammar2);
    } catch (e) {
      grammarErrors.push(e);
      grammarHasInvalidApplications = true;
    }
  });
  if (!grammarHasInvalidApplications) {
    Object.keys(grammar2.rules).forEach((ruleName) => {
      const { body } = grammar2.rules[ruleName];
      try {
        body.assertIteratedExprsAreNotNullable(grammar2, []);
      } catch (e) {
        grammarErrors.push(e);
      }
    });
  }
  if (grammarErrors.length > 0) {
    errors$1.throwErrors(grammarErrors);
  }
  if (this.source) {
    grammar2.source = this.source;
  }
  return grammar2;
};
GrammarDecl$1.prototype.define = function(name, formals, body, description, source) {
  this.ensureSuperGrammar();
  if (this.superGrammar.rules[name]) {
    throw errors$1.duplicateRuleDeclaration(name, this.name, this.superGrammar.name, source);
  } else if (this.rules[name]) {
    throw errors$1.duplicateRuleDeclaration(name, this.name, this.name, source);
  }
  const duplicateParameterNames2 = common$1$1.getDuplicates(formals);
  if (duplicateParameterNames2.length > 0) {
    throw errors$1.duplicateParameterNames(name, duplicateParameterNames2, source);
  }
  return this.install(name, formals, body, description, source);
};
GrammarDecl$1.prototype.override = function(name, formals, body, descIgnored, source) {
  this.ensureSuperGrammarRuleForOverriding(name, source);
  this.installOverriddenOrExtendedRule(name, formals, body, source);
  return this;
};
GrammarDecl$1.prototype.extend = function(name, formals, fragment, descIgnored, source) {
  const ruleInfo = this.ensureSuperGrammar().rules[name];
  if (!ruleInfo) {
    throw errors$1.cannotExtendUndeclaredRule(name, this.superGrammar.name, source);
  }
  const body = new pexprs$2.Extend(this.superGrammar, name, fragment);
  body.source = fragment.source;
  this.installOverriddenOrExtendedRule(name, formals, body, source);
  return this;
};
var GrammarDecl_1 = GrammarDecl$1;
const Grammar$2 = Grammar_1;
const GrammarDecl = GrammarDecl_1;
const pexprs$1 = pexprs$6;
function Builder$2() {
}
Builder$2.prototype = {
  currentDecl: null,
  currentRuleName: null,
  newGrammar(name) {
    return new GrammarDecl(name);
  },
  grammar(metaInfo, name, superGrammar, defaultStartRule, rules) {
    const gDecl = new GrammarDecl(name);
    if (superGrammar) {
      gDecl.withSuperGrammar(
        superGrammar instanceof Grammar$2 ? superGrammar : this.fromRecipe(superGrammar)
      );
    }
    if (defaultStartRule) {
      gDecl.withDefaultStartRule(defaultStartRule);
    }
    if (metaInfo && metaInfo.source) {
      gDecl.withSource(metaInfo.source);
    }
    this.currentDecl = gDecl;
    Object.keys(rules).forEach((ruleName) => {
      this.currentRuleName = ruleName;
      const ruleRecipe = rules[ruleName];
      const action = ruleRecipe[0];
      const metaInfo2 = ruleRecipe[1];
      const description = ruleRecipe[2];
      const formals = ruleRecipe[3];
      const body = this.fromRecipe(ruleRecipe[4]);
      let source;
      if (gDecl.source && metaInfo2 && metaInfo2.sourceInterval) {
        source = gDecl.source.subInterval(
          metaInfo2.sourceInterval[0],
          metaInfo2.sourceInterval[1] - metaInfo2.sourceInterval[0]
        );
      }
      gDecl[action](ruleName, formals, body, description, source);
    });
    this.currentRuleName = this.currentDecl = null;
    return gDecl.build();
  },
  terminal(x) {
    return new pexprs$1.Terminal(x);
  },
  range(from, to) {
    return new pexprs$1.Range(from, to);
  },
  param(index) {
    return new pexprs$1.Param(index);
  },
  alt(...termArgs) {
    let terms = [];
    for (let arg of termArgs) {
      if (!(arg instanceof pexprs$1.PExpr)) {
        arg = this.fromRecipe(arg);
      }
      if (arg instanceof pexprs$1.Alt) {
        terms = terms.concat(arg.terms);
      } else {
        terms.push(arg);
      }
    }
    return terms.length === 1 ? terms[0] : new pexprs$1.Alt(terms);
  },
  seq(...factorArgs) {
    let factors = [];
    for (let arg of factorArgs) {
      if (!(arg instanceof pexprs$1.PExpr)) {
        arg = this.fromRecipe(arg);
      }
      if (arg instanceof pexprs$1.Seq) {
        factors = factors.concat(arg.factors);
      } else {
        factors.push(arg);
      }
    }
    return factors.length === 1 ? factors[0] : new pexprs$1.Seq(factors);
  },
  star(expr) {
    if (!(expr instanceof pexprs$1.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs$1.Star(expr);
  },
  plus(expr) {
    if (!(expr instanceof pexprs$1.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs$1.Plus(expr);
  },
  opt(expr) {
    if (!(expr instanceof pexprs$1.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs$1.Opt(expr);
  },
  not(expr) {
    if (!(expr instanceof pexprs$1.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs$1.Not(expr);
  },
  la(expr) {
    return this.lookahead(expr);
  },
  lookahead(expr) {
    if (!(expr instanceof pexprs$1.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs$1.Lookahead(expr);
  },
  lex(expr) {
    if (!(expr instanceof pexprs$1.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs$1.Lex(expr);
  },
  app(ruleName, optParams) {
    if (optParams && optParams.length > 0) {
      optParams = optParams.map(function(param) {
        return param instanceof pexprs$1.PExpr ? param : this.fromRecipe(param);
      }, this);
    }
    return new pexprs$1.Apply(ruleName, optParams);
  },
  // Note that unlike other methods in this class, this method cannot be used as a
  // convenience constructor. It only works with recipes, because it relies on
  // `this.currentDecl` and `this.currentRuleName` being set.
  splice(beforeTerms, afterTerms) {
    return new pexprs$1.Splice(
      this.currentDecl.superGrammar,
      this.currentRuleName,
      beforeTerms.map((term) => this.fromRecipe(term)),
      afterTerms.map((term) => this.fromRecipe(term))
    );
  },
  fromRecipe(recipe) {
    const args = recipe[0] === "grammar" ? recipe.slice(1) : recipe.slice(2);
    const result = this[recipe[0]](...args);
    const metaInfo = recipe[1];
    if (metaInfo) {
      if (metaInfo.sourceInterval && this.currentDecl) {
        result.withSource(this.currentDecl.sourceInterval(...metaInfo.sourceInterval));
      }
    }
    return result;
  }
};
var Builder_1 = Builder$2;
var version$2 = "16.6.0";
var require$$0$2 = {
  version: version$2
};
var version$1$1 = typeof __GLOBAL_OHM_VERSION__ === "string" ? __GLOBAL_OHM_VERSION__ : require$$0$2.version;
var makeRecipe$5 = {};
const Builder$1 = Builder_1;
function makeRecipe$4(recipe) {
  if (typeof recipe === "function") {
    return recipe.call(new Builder$1());
  } else {
    if (typeof recipe === "string") {
      recipe = JSON.parse(recipe);
    }
    return new Builder$1().fromRecipe(recipe);
  }
}
makeRecipe$5.makeRecipe = makeRecipe$4;
var { makeRecipe: makeRecipe$3 } = makeRecipe$5;
var builtInRules = makeRecipe$3(["grammar", { "source": 'BuiltInRules {\n\n  alnum  (an alpha-numeric character)\n    = letter\n    | digit\n\n  letter  (a letter)\n    = lower\n    | upper\n    | unicodeLtmo\n\n  digit  (a digit)\n    = "0".."9"\n\n  hexDigit  (a hexadecimal digit)\n    = digit\n    | "a".."f"\n    | "A".."F"\n\n  ListOf<elem, sep>\n    = NonemptyListOf<elem, sep>\n    | EmptyListOf<elem, sep>\n\n  NonemptyListOf<elem, sep>\n    = elem (sep elem)*\n\n  EmptyListOf<elem, sep>\n    = /* nothing */\n\n  listOf<elem, sep>\n    = nonemptyListOf<elem, sep>\n    | emptyListOf<elem, sep>\n\n  nonemptyListOf<elem, sep>\n    = elem (sep elem)*\n\n  emptyListOf<elem, sep>\n    = /* nothing */\n\n  // Allows a syntactic rule application within a lexical context.\n  applySyntactic<app> = app\n}' }, "BuiltInRules", null, null, { "alnum": ["define", { "sourceInterval": [18, 78] }, "an alpha-numeric character", [], ["alt", { "sourceInterval": [60, 78] }, ["app", { "sourceInterval": [60, 66] }, "letter", []], ["app", { "sourceInterval": [73, 78] }, "digit", []]]], "letter": ["define", { "sourceInterval": [82, 142] }, "a letter", [], ["alt", { "sourceInterval": [107, 142] }, ["app", { "sourceInterval": [107, 112] }, "lower", []], ["app", { "sourceInterval": [119, 124] }, "upper", []], ["app", { "sourceInterval": [131, 142] }, "unicodeLtmo", []]]], "digit": ["define", { "sourceInterval": [146, 177] }, "a digit", [], ["range", { "sourceInterval": [169, 177] }, "0", "9"]], "hexDigit": ["define", { "sourceInterval": [181, 254] }, "a hexadecimal digit", [], ["alt", { "sourceInterval": [219, 254] }, ["app", { "sourceInterval": [219, 224] }, "digit", []], ["range", { "sourceInterval": [231, 239] }, "a", "f"], ["range", { "sourceInterval": [246, 254] }, "A", "F"]]], "ListOf": ["define", { "sourceInterval": [258, 336] }, null, ["elem", "sep"], ["alt", { "sourceInterval": [282, 336] }, ["app", { "sourceInterval": [282, 307] }, "NonemptyListOf", [["param", { "sourceInterval": [297, 301] }, 0], ["param", { "sourceInterval": [303, 306] }, 1]]], ["app", { "sourceInterval": [314, 336] }, "EmptyListOf", [["param", { "sourceInterval": [326, 330] }, 0], ["param", { "sourceInterval": [332, 335] }, 1]]]]], "NonemptyListOf": ["define", { "sourceInterval": [340, 388] }, null, ["elem", "sep"], ["seq", { "sourceInterval": [372, 388] }, ["param", { "sourceInterval": [372, 376] }, 0], ["star", { "sourceInterval": [377, 388] }, ["seq", { "sourceInterval": [378, 386] }, ["param", { "sourceInterval": [378, 381] }, 1], ["param", { "sourceInterval": [382, 386] }, 0]]]]], "EmptyListOf": ["define", { "sourceInterval": [392, 434] }, null, ["elem", "sep"], ["seq", { "sourceInterval": [438, 438] }]], "listOf": ["define", { "sourceInterval": [438, 516] }, null, ["elem", "sep"], ["alt", { "sourceInterval": [462, 516] }, ["app", { "sourceInterval": [462, 487] }, "nonemptyListOf", [["param", { "sourceInterval": [477, 481] }, 0], ["param", { "sourceInterval": [483, 486] }, 1]]], ["app", { "sourceInterval": [494, 516] }, "emptyListOf", [["param", { "sourceInterval": [506, 510] }, 0], ["param", { "sourceInterval": [512, 515] }, 1]]]]], "nonemptyListOf": ["define", { "sourceInterval": [520, 568] }, null, ["elem", "sep"], ["seq", { "sourceInterval": [552, 568] }, ["param", { "sourceInterval": [552, 556] }, 0], ["star", { "sourceInterval": [557, 568] }, ["seq", { "sourceInterval": [558, 566] }, ["param", { "sourceInterval": [558, 561] }, 1], ["param", { "sourceInterval": [562, 566] }, 0]]]]], "emptyListOf": ["define", { "sourceInterval": [572, 682] }, null, ["elem", "sep"], ["seq", { "sourceInterval": [685, 685] }]], "applySyntactic": ["define", { "sourceInterval": [685, 710] }, null, ["app"], ["param", { "sourceInterval": [707, 710] }, 0]] }]);
const Grammar$1 = Grammar_1;
Grammar$1.BuiltInRules = builtInRules;
var { makeRecipe: makeRecipe$2 } = makeRecipe$5;
var operationsAndAttributes = makeRecipe$2(["grammar", { "source": 'OperationsAndAttributes {\n\n  AttributeSignature =\n    name\n\n  OperationSignature =\n    name Formals?\n\n  Formals\n    = "(" ListOf<name, ","> ")"\n\n  name  (a name)\n    = nameFirst nameRest*\n\n  nameFirst\n    = "_"\n    | letter\n\n  nameRest\n    = "_"\n    | alnum\n\n}' }, "OperationsAndAttributes", null, "AttributeSignature", { "AttributeSignature": ["define", { "sourceInterval": [29, 58] }, null, [], ["app", { "sourceInterval": [54, 58] }, "name", []]], "OperationSignature": ["define", { "sourceInterval": [62, 100] }, null, [], ["seq", { "sourceInterval": [87, 100] }, ["app", { "sourceInterval": [87, 91] }, "name", []], ["opt", { "sourceInterval": [92, 100] }, ["app", { "sourceInterval": [92, 99] }, "Formals", []]]]], "Formals": ["define", { "sourceInterval": [104, 143] }, null, [], ["seq", { "sourceInterval": [118, 143] }, ["terminal", { "sourceInterval": [118, 121] }, "("], ["app", { "sourceInterval": [122, 139] }, "ListOf", [["app", { "sourceInterval": [129, 133] }, "name", []], ["terminal", { "sourceInterval": [135, 138] }, ","]]], ["terminal", { "sourceInterval": [140, 143] }, ")"]]], "name": ["define", { "sourceInterval": [147, 187] }, "a name", [], ["seq", { "sourceInterval": [168, 187] }, ["app", { "sourceInterval": [168, 177] }, "nameFirst", []], ["star", { "sourceInterval": [178, 187] }, ["app", { "sourceInterval": [178, 186] }, "nameRest", []]]]], "nameFirst": ["define", { "sourceInterval": [191, 223] }, null, [], ["alt", { "sourceInterval": [207, 223] }, ["terminal", { "sourceInterval": [207, 210] }, "_"], ["app", { "sourceInterval": [217, 223] }, "letter", []]]], "nameRest": ["define", { "sourceInterval": [227, 257] }, null, [], ["alt", { "sourceInterval": [242, 257] }, ["terminal", { "sourceInterval": [242, 245] }, "_"], ["app", { "sourceInterval": [252, 257] }, "alnum", []]]] }]);
const Semantics = Semantics_1;
const util$1 = util$7;
util$1.awaitBuiltInRules((builtInRules2) => {
  const operationsAndAttributesGrammar = operationsAndAttributes;
  initBuiltInSemantics(builtInRules2);
  initPrototypeParser(operationsAndAttributesGrammar);
});
function initBuiltInSemantics(builtInRules2) {
  const actions = {
    empty() {
      return this.iteration();
    },
    nonEmpty(first, _, rest) {
      return this.iteration([first].concat(rest.children));
    }
  };
  Semantics.BuiltInSemantics = Semantics.createSemantics(builtInRules2, null).addOperation(
    "asIteration",
    {
      emptyListOf: actions.empty,
      nonemptyListOf: actions.nonEmpty,
      EmptyListOf: actions.empty,
      NonemptyListOf: actions.nonEmpty
    }
  );
}
function initPrototypeParser(grammar2) {
  Semantics.prototypeGrammarSemantics = grammar2.createSemantics().addOperation("parse", {
    AttributeSignature(name) {
      return {
        name: name.parse(),
        formals: []
      };
    },
    OperationSignature(name, optFormals) {
      return {
        name: name.parse(),
        formals: optFormals.children.map((c) => c.parse())[0] || []
      };
    },
    Formals(oparen, fs, cparen) {
      return fs.asIteration().children.map((c) => c.parse());
    },
    name(first, rest) {
      return this.sourceString;
    }
  });
  Semantics.prototypeGrammar = grammar2;
}
var { makeRecipe: makeRecipe$1 } = makeRecipe$5;
var ohmGrammar$1 = makeRecipe$1(["grammar", { "source": `Ohm {

  Grammars
    = Grammar*

  Grammar
    = ident SuperGrammar? "{" Rule* "}"

  SuperGrammar
    = "<:" ident

  Rule
    = ident Formals? ruleDescr? "="  RuleBody  -- define
    | ident Formals?            ":=" OverrideRuleBody  -- override
    | ident Formals?            "+=" RuleBody  -- extend

  RuleBody
    = "|"? NonemptyListOf<TopLevelTerm, "|">

  TopLevelTerm
    = Seq caseName  -- inline
    | Seq

  OverrideRuleBody
    = "|"? NonemptyListOf<OverrideTopLevelTerm, "|">

  OverrideTopLevelTerm
    = "..."  -- superSplice
    | TopLevelTerm

  Formals
    = "<" ListOf<ident, ","> ">"

  Params
    = "<" ListOf<Seq, ","> ">"

  Alt
    = NonemptyListOf<Seq, "|">

  Seq
    = Iter*

  Iter
    = Pred "*"  -- star
    | Pred "+"  -- plus
    | Pred "?"  -- opt
    | Pred

  Pred
    = "~" Lex  -- not
    | "&" Lex  -- lookahead
    | Lex

  Lex
    = "#" Base  -- lex
    | Base

  Base
    = ident Params? ~(ruleDescr? "=" | ":=" | "+=")  -- application
    | oneCharTerminal ".." oneCharTerminal           -- range
    | terminal                                       -- terminal
    | "(" Alt ")"                                    -- paren

  ruleDescr  (a rule description)
    = "(" ruleDescrText ")"

  ruleDescrText
    = (~")" any)*

  caseName
    = "--" (~"\\n" space)* name (~"\\n" space)* ("\\n" | &"}")

  name  (a name)
    = nameFirst nameRest*

  nameFirst
    = "_"
    | letter

  nameRest
    = "_"
    | alnum

  ident  (an identifier)
    = name

  terminal
    = "\\"" terminalChar* "\\""

  oneCharTerminal
    = "\\"" terminalChar "\\""

  terminalChar
    = escapeChar
      | ~"\\\\" ~"\\"" ~"\\n" "\\u{0}".."\\u{10FFFF}"

  escapeChar  (an escape sequence)
    = "\\\\\\\\"                                     -- backslash
    | "\\\\\\""                                     -- doubleQuote
    | "\\\\\\'"                                     -- singleQuote
    | "\\\\b"                                      -- backspace
    | "\\\\n"                                      -- lineFeed
    | "\\\\r"                                      -- carriageReturn
    | "\\\\t"                                      -- tab
    | "\\\\u{" hexDigit hexDigit? hexDigit?
             hexDigit? hexDigit? hexDigit? "}"   -- unicodeCodePoint
    | "\\\\u" hexDigit hexDigit hexDigit hexDigit  -- unicodeEscape
    | "\\\\x" hexDigit hexDigit                    -- hexEscape

  space
   += comment

  comment
    = "//" (~"\\n" any)* &("\\n" | end)  -- singleLine
    | "/*" (~"*/" any)* "*/"  -- multiLine

  tokens = token*

  token = caseName | comment | ident | operator | punctuation | terminal | any

  operator = "<:" | "=" | ":=" | "+=" | "*" | "+" | "?" | "~" | "&"

  punctuation = "<" | ">" | "," | "--"
}` }, "Ohm", null, "Grammars", { "Grammars": ["define", { "sourceInterval": [9, 32] }, null, [], ["star", { "sourceInterval": [24, 32] }, ["app", { "sourceInterval": [24, 31] }, "Grammar", []]]], "Grammar": ["define", { "sourceInterval": [36, 83] }, null, [], ["seq", { "sourceInterval": [50, 83] }, ["app", { "sourceInterval": [50, 55] }, "ident", []], ["opt", { "sourceInterval": [56, 69] }, ["app", { "sourceInterval": [56, 68] }, "SuperGrammar", []]], ["terminal", { "sourceInterval": [70, 73] }, "{"], ["star", { "sourceInterval": [74, 79] }, ["app", { "sourceInterval": [74, 78] }, "Rule", []]], ["terminal", { "sourceInterval": [80, 83] }, "}"]]], "SuperGrammar": ["define", { "sourceInterval": [87, 116] }, null, [], ["seq", { "sourceInterval": [106, 116] }, ["terminal", { "sourceInterval": [106, 110] }, "<:"], ["app", { "sourceInterval": [111, 116] }, "ident", []]]], "Rule_define": ["define", { "sourceInterval": [131, 181] }, null, [], ["seq", { "sourceInterval": [131, 170] }, ["app", { "sourceInterval": [131, 136] }, "ident", []], ["opt", { "sourceInterval": [137, 145] }, ["app", { "sourceInterval": [137, 144] }, "Formals", []]], ["opt", { "sourceInterval": [146, 156] }, ["app", { "sourceInterval": [146, 155] }, "ruleDescr", []]], ["terminal", { "sourceInterval": [157, 160] }, "="], ["app", { "sourceInterval": [162, 170] }, "RuleBody", []]]], "Rule_override": ["define", { "sourceInterval": [188, 248] }, null, [], ["seq", { "sourceInterval": [188, 235] }, ["app", { "sourceInterval": [188, 193] }, "ident", []], ["opt", { "sourceInterval": [194, 202] }, ["app", { "sourceInterval": [194, 201] }, "Formals", []]], ["terminal", { "sourceInterval": [214, 218] }, ":="], ["app", { "sourceInterval": [219, 235] }, "OverrideRuleBody", []]]], "Rule_extend": ["define", { "sourceInterval": [255, 305] }, null, [], ["seq", { "sourceInterval": [255, 294] }, ["app", { "sourceInterval": [255, 260] }, "ident", []], ["opt", { "sourceInterval": [261, 269] }, ["app", { "sourceInterval": [261, 268] }, "Formals", []]], ["terminal", { "sourceInterval": [281, 285] }, "+="], ["app", { "sourceInterval": [286, 294] }, "RuleBody", []]]], "Rule": ["define", { "sourceInterval": [120, 305] }, null, [], ["alt", { "sourceInterval": [131, 305] }, ["app", { "sourceInterval": [131, 170] }, "Rule_define", []], ["app", { "sourceInterval": [188, 235] }, "Rule_override", []], ["app", { "sourceInterval": [255, 294] }, "Rule_extend", []]]], "RuleBody": ["define", { "sourceInterval": [309, 362] }, null, [], ["seq", { "sourceInterval": [324, 362] }, ["opt", { "sourceInterval": [324, 328] }, ["terminal", { "sourceInterval": [324, 327] }, "|"]], ["app", { "sourceInterval": [329, 362] }, "NonemptyListOf", [["app", { "sourceInterval": [344, 356] }, "TopLevelTerm", []], ["terminal", { "sourceInterval": [358, 361] }, "|"]]]]], "TopLevelTerm_inline": ["define", { "sourceInterval": [385, 408] }, null, [], ["seq", { "sourceInterval": [385, 397] }, ["app", { "sourceInterval": [385, 388] }, "Seq", []], ["app", { "sourceInterval": [389, 397] }, "caseName", []]]], "TopLevelTerm": ["define", { "sourceInterval": [366, 418] }, null, [], ["alt", { "sourceInterval": [385, 418] }, ["app", { "sourceInterval": [385, 397] }, "TopLevelTerm_inline", []], ["app", { "sourceInterval": [415, 418] }, "Seq", []]]], "OverrideRuleBody": ["define", { "sourceInterval": [422, 491] }, null, [], ["seq", { "sourceInterval": [445, 491] }, ["opt", { "sourceInterval": [445, 449] }, ["terminal", { "sourceInterval": [445, 448] }, "|"]], ["app", { "sourceInterval": [450, 491] }, "NonemptyListOf", [["app", { "sourceInterval": [465, 485] }, "OverrideTopLevelTerm", []], ["terminal", { "sourceInterval": [487, 490] }, "|"]]]]], "OverrideTopLevelTerm_superSplice": ["define", { "sourceInterval": [522, 543] }, null, [], ["terminal", { "sourceInterval": [522, 527] }, "..."]], "OverrideTopLevelTerm": ["define", { "sourceInterval": [495, 562] }, null, [], ["alt", { "sourceInterval": [522, 562] }, ["app", { "sourceInterval": [522, 527] }, "OverrideTopLevelTerm_superSplice", []], ["app", { "sourceInterval": [550, 562] }, "TopLevelTerm", []]]], "Formals": ["define", { "sourceInterval": [566, 606] }, null, [], ["seq", { "sourceInterval": [580, 606] }, ["terminal", { "sourceInterval": [580, 583] }, "<"], ["app", { "sourceInterval": [584, 602] }, "ListOf", [["app", { "sourceInterval": [591, 596] }, "ident", []], ["terminal", { "sourceInterval": [598, 601] }, ","]]], ["terminal", { "sourceInterval": [603, 606] }, ">"]]], "Params": ["define", { "sourceInterval": [610, 647] }, null, [], ["seq", { "sourceInterval": [623, 647] }, ["terminal", { "sourceInterval": [623, 626] }, "<"], ["app", { "sourceInterval": [627, 643] }, "ListOf", [["app", { "sourceInterval": [634, 637] }, "Seq", []], ["terminal", { "sourceInterval": [639, 642] }, ","]]], ["terminal", { "sourceInterval": [644, 647] }, ">"]]], "Alt": ["define", { "sourceInterval": [651, 685] }, null, [], ["app", { "sourceInterval": [661, 685] }, "NonemptyListOf", [["app", { "sourceInterval": [676, 679] }, "Seq", []], ["terminal", { "sourceInterval": [681, 684] }, "|"]]]], "Seq": ["define", { "sourceInterval": [689, 704] }, null, [], ["star", { "sourceInterval": [699, 704] }, ["app", { "sourceInterval": [699, 703] }, "Iter", []]]], "Iter_star": ["define", { "sourceInterval": [719, 736] }, null, [], ["seq", { "sourceInterval": [719, 727] }, ["app", { "sourceInterval": [719, 723] }, "Pred", []], ["terminal", { "sourceInterval": [724, 727] }, "*"]]], "Iter_plus": ["define", { "sourceInterval": [743, 760] }, null, [], ["seq", { "sourceInterval": [743, 751] }, ["app", { "sourceInterval": [743, 747] }, "Pred", []], ["terminal", { "sourceInterval": [748, 751] }, "+"]]], "Iter_opt": ["define", { "sourceInterval": [767, 783] }, null, [], ["seq", { "sourceInterval": [767, 775] }, ["app", { "sourceInterval": [767, 771] }, "Pred", []], ["terminal", { "sourceInterval": [772, 775] }, "?"]]], "Iter": ["define", { "sourceInterval": [708, 794] }, null, [], ["alt", { "sourceInterval": [719, 794] }, ["app", { "sourceInterval": [719, 727] }, "Iter_star", []], ["app", { "sourceInterval": [743, 751] }, "Iter_plus", []], ["app", { "sourceInterval": [767, 775] }, "Iter_opt", []], ["app", { "sourceInterval": [790, 794] }, "Pred", []]]], "Pred_not": ["define", { "sourceInterval": [809, 824] }, null, [], ["seq", { "sourceInterval": [809, 816] }, ["terminal", { "sourceInterval": [809, 812] }, "~"], ["app", { "sourceInterval": [813, 816] }, "Lex", []]]], "Pred_lookahead": ["define", { "sourceInterval": [831, 852] }, null, [], ["seq", { "sourceInterval": [831, 838] }, ["terminal", { "sourceInterval": [831, 834] }, "&"], ["app", { "sourceInterval": [835, 838] }, "Lex", []]]], "Pred": ["define", { "sourceInterval": [798, 862] }, null, [], ["alt", { "sourceInterval": [809, 862] }, ["app", { "sourceInterval": [809, 816] }, "Pred_not", []], ["app", { "sourceInterval": [831, 838] }, "Pred_lookahead", []], ["app", { "sourceInterval": [859, 862] }, "Lex", []]]], "Lex_lex": ["define", { "sourceInterval": [876, 892] }, null, [], ["seq", { "sourceInterval": [876, 884] }, ["terminal", { "sourceInterval": [876, 879] }, "#"], ["app", { "sourceInterval": [880, 884] }, "Base", []]]], "Lex": ["define", { "sourceInterval": [866, 903] }, null, [], ["alt", { "sourceInterval": [876, 903] }, ["app", { "sourceInterval": [876, 884] }, "Lex_lex", []], ["app", { "sourceInterval": [899, 903] }, "Base", []]]], "Base_application": ["define", { "sourceInterval": [918, 979] }, null, [], ["seq", { "sourceInterval": [918, 963] }, ["app", { "sourceInterval": [918, 923] }, "ident", []], ["opt", { "sourceInterval": [924, 931] }, ["app", { "sourceInterval": [924, 930] }, "Params", []]], ["not", { "sourceInterval": [932, 963] }, ["alt", { "sourceInterval": [934, 962] }, ["seq", { "sourceInterval": [934, 948] }, ["opt", { "sourceInterval": [934, 944] }, ["app", { "sourceInterval": [934, 943] }, "ruleDescr", []]], ["terminal", { "sourceInterval": [945, 948] }, "="]], ["terminal", { "sourceInterval": [951, 955] }, ":="], ["terminal", { "sourceInterval": [958, 962] }, "+="]]]]], "Base_range": ["define", { "sourceInterval": [986, 1041] }, null, [], ["seq", { "sourceInterval": [986, 1022] }, ["app", { "sourceInterval": [986, 1001] }, "oneCharTerminal", []], ["terminal", { "sourceInterval": [1002, 1006] }, ".."], ["app", { "sourceInterval": [1007, 1022] }, "oneCharTerminal", []]]], "Base_terminal": ["define", { "sourceInterval": [1048, 1106] }, null, [], ["app", { "sourceInterval": [1048, 1056] }, "terminal", []]], "Base_paren": ["define", { "sourceInterval": [1113, 1168] }, null, [], ["seq", { "sourceInterval": [1113, 1124] }, ["terminal", { "sourceInterval": [1113, 1116] }, "("], ["app", { "sourceInterval": [1117, 1120] }, "Alt", []], ["terminal", { "sourceInterval": [1121, 1124] }, ")"]]], "Base": ["define", { "sourceInterval": [907, 1168] }, null, [], ["alt", { "sourceInterval": [918, 1168] }, ["app", { "sourceInterval": [918, 963] }, "Base_application", []], ["app", { "sourceInterval": [986, 1022] }, "Base_range", []], ["app", { "sourceInterval": [1048, 1056] }, "Base_terminal", []], ["app", { "sourceInterval": [1113, 1124] }, "Base_paren", []]]], "ruleDescr": ["define", { "sourceInterval": [1172, 1231] }, "a rule description", [], ["seq", { "sourceInterval": [1210, 1231] }, ["terminal", { "sourceInterval": [1210, 1213] }, "("], ["app", { "sourceInterval": [1214, 1227] }, "ruleDescrText", []], ["terminal", { "sourceInterval": [1228, 1231] }, ")"]]], "ruleDescrText": ["define", { "sourceInterval": [1235, 1266] }, null, [], ["star", { "sourceInterval": [1255, 1266] }, ["seq", { "sourceInterval": [1256, 1264] }, ["not", { "sourceInterval": [1256, 1260] }, ["terminal", { "sourceInterval": [1257, 1260] }, ")"]], ["app", { "sourceInterval": [1261, 1264] }, "any", []]]]], "caseName": ["define", { "sourceInterval": [1270, 1338] }, null, [], ["seq", { "sourceInterval": [1285, 1338] }, ["terminal", { "sourceInterval": [1285, 1289] }, "--"], ["star", { "sourceInterval": [1290, 1304] }, ["seq", { "sourceInterval": [1291, 1302] }, ["not", { "sourceInterval": [1291, 1296] }, ["terminal", { "sourceInterval": [1292, 1296] }, "\n"]], ["app", { "sourceInterval": [1297, 1302] }, "space", []]]], ["app", { "sourceInterval": [1305, 1309] }, "name", []], ["star", { "sourceInterval": [1310, 1324] }, ["seq", { "sourceInterval": [1311, 1322] }, ["not", { "sourceInterval": [1311, 1316] }, ["terminal", { "sourceInterval": [1312, 1316] }, "\n"]], ["app", { "sourceInterval": [1317, 1322] }, "space", []]]], ["alt", { "sourceInterval": [1326, 1337] }, ["terminal", { "sourceInterval": [1326, 1330] }, "\n"], ["lookahead", { "sourceInterval": [1333, 1337] }, ["terminal", { "sourceInterval": [1334, 1337] }, "}"]]]]], "name": ["define", { "sourceInterval": [1342, 1382] }, "a name", [], ["seq", { "sourceInterval": [1363, 1382] }, ["app", { "sourceInterval": [1363, 1372] }, "nameFirst", []], ["star", { "sourceInterval": [1373, 1382] }, ["app", { "sourceInterval": [1373, 1381] }, "nameRest", []]]]], "nameFirst": ["define", { "sourceInterval": [1386, 1418] }, null, [], ["alt", { "sourceInterval": [1402, 1418] }, ["terminal", { "sourceInterval": [1402, 1405] }, "_"], ["app", { "sourceInterval": [1412, 1418] }, "letter", []]]], "nameRest": ["define", { "sourceInterval": [1422, 1452] }, null, [], ["alt", { "sourceInterval": [1437, 1452] }, ["terminal", { "sourceInterval": [1437, 1440] }, "_"], ["app", { "sourceInterval": [1447, 1452] }, "alnum", []]]], "ident": ["define", { "sourceInterval": [1456, 1489] }, "an identifier", [], ["app", { "sourceInterval": [1485, 1489] }, "name", []]], "terminal": ["define", { "sourceInterval": [1493, 1531] }, null, [], ["seq", { "sourceInterval": [1508, 1531] }, ["terminal", { "sourceInterval": [1508, 1512] }, '"'], ["star", { "sourceInterval": [1513, 1526] }, ["app", { "sourceInterval": [1513, 1525] }, "terminalChar", []]], ["terminal", { "sourceInterval": [1527, 1531] }, '"']]], "oneCharTerminal": ["define", { "sourceInterval": [1535, 1579] }, null, [], ["seq", { "sourceInterval": [1557, 1579] }, ["terminal", { "sourceInterval": [1557, 1561] }, '"'], ["app", { "sourceInterval": [1562, 1574] }, "terminalChar", []], ["terminal", { "sourceInterval": [1575, 1579] }, '"']]], "terminalChar": ["define", { "sourceInterval": [1583, 1660] }, null, [], ["alt", { "sourceInterval": [1602, 1660] }, ["app", { "sourceInterval": [1602, 1612] }, "escapeChar", []], ["seq", { "sourceInterval": [1621, 1660] }, ["not", { "sourceInterval": [1621, 1626] }, ["terminal", { "sourceInterval": [1622, 1626] }, "\\"]], ["not", { "sourceInterval": [1627, 1632] }, ["terminal", { "sourceInterval": [1628, 1632] }, '"']], ["not", { "sourceInterval": [1633, 1638] }, ["terminal", { "sourceInterval": [1634, 1638] }, "\n"]], ["range", { "sourceInterval": [1639, 1660] }, "\0", ""]]]], "escapeChar_backslash": ["define", { "sourceInterval": [1703, 1758] }, null, [], ["terminal", { "sourceInterval": [1703, 1709] }, "\\\\"]], "escapeChar_doubleQuote": ["define", { "sourceInterval": [1765, 1822] }, null, [], ["terminal", { "sourceInterval": [1765, 1771] }, '\\"']], "escapeChar_singleQuote": ["define", { "sourceInterval": [1829, 1886] }, null, [], ["terminal", { "sourceInterval": [1829, 1835] }, "\\'"]], "escapeChar_backspace": ["define", { "sourceInterval": [1893, 1948] }, null, [], ["terminal", { "sourceInterval": [1893, 1898] }, "\\b"]], "escapeChar_lineFeed": ["define", { "sourceInterval": [1955, 2009] }, null, [], ["terminal", { "sourceInterval": [1955, 1960] }, "\\n"]], "escapeChar_carriageReturn": ["define", { "sourceInterval": [2016, 2076] }, null, [], ["terminal", { "sourceInterval": [2016, 2021] }, "\\r"]], "escapeChar_tab": ["define", { "sourceInterval": [2083, 2132] }, null, [], ["terminal", { "sourceInterval": [2083, 2088] }, "\\t"]], "escapeChar_unicodeCodePoint": ["define", { "sourceInterval": [2139, 2243] }, null, [], ["seq", { "sourceInterval": [2139, 2221] }, ["terminal", { "sourceInterval": [2139, 2145] }, "\\u{"], ["app", { "sourceInterval": [2146, 2154] }, "hexDigit", []], ["opt", { "sourceInterval": [2155, 2164] }, ["app", { "sourceInterval": [2155, 2163] }, "hexDigit", []]], ["opt", { "sourceInterval": [2165, 2174] }, ["app", { "sourceInterval": [2165, 2173] }, "hexDigit", []]], ["opt", { "sourceInterval": [2188, 2197] }, ["app", { "sourceInterval": [2188, 2196] }, "hexDigit", []]], ["opt", { "sourceInterval": [2198, 2207] }, ["app", { "sourceInterval": [2198, 2206] }, "hexDigit", []]], ["opt", { "sourceInterval": [2208, 2217] }, ["app", { "sourceInterval": [2208, 2216] }, "hexDigit", []]], ["terminal", { "sourceInterval": [2218, 2221] }, "}"]]], "escapeChar_unicodeEscape": ["define", { "sourceInterval": [2250, 2309] }, null, [], ["seq", { "sourceInterval": [2250, 2291] }, ["terminal", { "sourceInterval": [2250, 2255] }, "\\u"], ["app", { "sourceInterval": [2256, 2264] }, "hexDigit", []], ["app", { "sourceInterval": [2265, 2273] }, "hexDigit", []], ["app", { "sourceInterval": [2274, 2282] }, "hexDigit", []], ["app", { "sourceInterval": [2283, 2291] }, "hexDigit", []]]], "escapeChar_hexEscape": ["define", { "sourceInterval": [2316, 2371] }, null, [], ["seq", { "sourceInterval": [2316, 2339] }, ["terminal", { "sourceInterval": [2316, 2321] }, "\\x"], ["app", { "sourceInterval": [2322, 2330] }, "hexDigit", []], ["app", { "sourceInterval": [2331, 2339] }, "hexDigit", []]]], "escapeChar": ["define", { "sourceInterval": [1664, 2371] }, "an escape sequence", [], ["alt", { "sourceInterval": [1703, 2371] }, ["app", { "sourceInterval": [1703, 1709] }, "escapeChar_backslash", []], ["app", { "sourceInterval": [1765, 1771] }, "escapeChar_doubleQuote", []], ["app", { "sourceInterval": [1829, 1835] }, "escapeChar_singleQuote", []], ["app", { "sourceInterval": [1893, 1898] }, "escapeChar_backspace", []], ["app", { "sourceInterval": [1955, 1960] }, "escapeChar_lineFeed", []], ["app", { "sourceInterval": [2016, 2021] }, "escapeChar_carriageReturn", []], ["app", { "sourceInterval": [2083, 2088] }, "escapeChar_tab", []], ["app", { "sourceInterval": [2139, 2221] }, "escapeChar_unicodeCodePoint", []], ["app", { "sourceInterval": [2250, 2291] }, "escapeChar_unicodeEscape", []], ["app", { "sourceInterval": [2316, 2339] }, "escapeChar_hexEscape", []]]], "space": ["extend", { "sourceInterval": [2375, 2394] }, null, [], ["app", { "sourceInterval": [2387, 2394] }, "comment", []]], "comment_singleLine": ["define", { "sourceInterval": [2412, 2458] }, null, [], ["seq", { "sourceInterval": [2412, 2443] }, ["terminal", { "sourceInterval": [2412, 2416] }, "//"], ["star", { "sourceInterval": [2417, 2429] }, ["seq", { "sourceInterval": [2418, 2427] }, ["not", { "sourceInterval": [2418, 2423] }, ["terminal", { "sourceInterval": [2419, 2423] }, "\n"]], ["app", { "sourceInterval": [2424, 2427] }, "any", []]]], ["lookahead", { "sourceInterval": [2430, 2443] }, ["alt", { "sourceInterval": [2432, 2442] }, ["terminal", { "sourceInterval": [2432, 2436] }, "\n"], ["app", { "sourceInterval": [2439, 2442] }, "end", []]]]]], "comment_multiLine": ["define", { "sourceInterval": [2465, 2501] }, null, [], ["seq", { "sourceInterval": [2465, 2487] }, ["terminal", { "sourceInterval": [2465, 2469] }, "/*"], ["star", { "sourceInterval": [2470, 2482] }, ["seq", { "sourceInterval": [2471, 2480] }, ["not", { "sourceInterval": [2471, 2476] }, ["terminal", { "sourceInterval": [2472, 2476] }, "*/"]], ["app", { "sourceInterval": [2477, 2480] }, "any", []]]], ["terminal", { "sourceInterval": [2483, 2487] }, "*/"]]], "comment": ["define", { "sourceInterval": [2398, 2501] }, null, [], ["alt", { "sourceInterval": [2412, 2501] }, ["app", { "sourceInterval": [2412, 2443] }, "comment_singleLine", []], ["app", { "sourceInterval": [2465, 2487] }, "comment_multiLine", []]]], "tokens": ["define", { "sourceInterval": [2505, 2520] }, null, [], ["star", { "sourceInterval": [2514, 2520] }, ["app", { "sourceInterval": [2514, 2519] }, "token", []]]], "token": ["define", { "sourceInterval": [2524, 2600] }, null, [], ["alt", { "sourceInterval": [2532, 2600] }, ["app", { "sourceInterval": [2532, 2540] }, "caseName", []], ["app", { "sourceInterval": [2543, 2550] }, "comment", []], ["app", { "sourceInterval": [2553, 2558] }, "ident", []], ["app", { "sourceInterval": [2561, 2569] }, "operator", []], ["app", { "sourceInterval": [2572, 2583] }, "punctuation", []], ["app", { "sourceInterval": [2586, 2594] }, "terminal", []], ["app", { "sourceInterval": [2597, 2600] }, "any", []]]], "operator": ["define", { "sourceInterval": [2604, 2669] }, null, [], ["alt", { "sourceInterval": [2615, 2669] }, ["terminal", { "sourceInterval": [2615, 2619] }, "<:"], ["terminal", { "sourceInterval": [2622, 2625] }, "="], ["terminal", { "sourceInterval": [2628, 2632] }, ":="], ["terminal", { "sourceInterval": [2635, 2639] }, "+="], ["terminal", { "sourceInterval": [2642, 2645] }, "*"], ["terminal", { "sourceInterval": [2648, 2651] }, "+"], ["terminal", { "sourceInterval": [2654, 2657] }, "?"], ["terminal", { "sourceInterval": [2660, 2663] }, "~"], ["terminal", { "sourceInterval": [2666, 2669] }, "&"]]], "punctuation": ["define", { "sourceInterval": [2673, 2709] }, null, [], ["alt", { "sourceInterval": [2687, 2709] }, ["terminal", { "sourceInterval": [2687, 2690] }, "<"], ["terminal", { "sourceInterval": [2693, 2696] }, ">"], ["terminal", { "sourceInterval": [2699, 2702] }, ","], ["terminal", { "sourceInterval": [2705, 2709] }, "--"]]] }]);
const Builder = Builder_1;
const Grammar = Grammar_1;
const Namespace = Namespace_1;
const common$m = common$l;
const errors$a = errors$9;
const pexprs = pexprs$6;
const util$8 = util$7;
const version$3 = version$1$1;
const { makeRecipe } = makeRecipe$5;
let ohmGrammar;
const superSplicePlaceholder = Object.create(pexprs.PExpr.prototype);
const isBuffer = (obj) => !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
function buildGrammar(match, namespace, optOhmGrammarForTesting) {
  const builder2 = new Builder();
  let decl;
  let currentRuleName;
  let currentRuleFormals;
  let overriding = false;
  const metaGrammar = optOhmGrammarForTesting || ohmGrammar;
  const helpers = metaGrammar.createSemantics().addOperation("visit", {
    Grammars(grammarIter) {
      return grammarIter.children.map((c) => c.visit());
    },
    Grammar(id, s, _open, rules, _close) {
      const grammarName = id.visit();
      decl = builder2.newGrammar(grammarName, namespace);
      s.child(0) && s.child(0).visit();
      rules.children.map((c) => c.visit());
      const g2 = decl.build();
      g2.source = this.source.trimmed();
      if (grammarName in namespace) {
        throw errors$a.duplicateGrammarDeclaration(g2, namespace);
      }
      namespace[grammarName] = g2;
      return g2;
    },
    SuperGrammar(_, n) {
      const superGrammarName = n.visit();
      if (superGrammarName === "null") {
        decl.withSuperGrammar(null);
      } else {
        if (!namespace || !(superGrammarName in namespace)) {
          throw errors$a.undeclaredGrammar(superGrammarName, namespace, n.source);
        }
        decl.withSuperGrammar(namespace[superGrammarName]);
      }
    },
    Rule_define(n, fs, d, _, b) {
      currentRuleName = n.visit();
      currentRuleFormals = fs.children.map((c) => c.visit())[0] || [];
      if (!decl.defaultStartRule && decl.ensureSuperGrammar() !== Grammar.ProtoBuiltInRules) {
        decl.withDefaultStartRule(currentRuleName);
      }
      const body = b.visit();
      const description = d.children.map((c) => c.visit())[0];
      const source = this.source.trimmed();
      return decl.define(currentRuleName, currentRuleFormals, body, description, source);
    },
    Rule_override(n, fs, _, b) {
      currentRuleName = n.visit();
      currentRuleFormals = fs.children.map((c) => c.visit())[0] || [];
      const source = this.source.trimmed();
      decl.ensureSuperGrammarRuleForOverriding(currentRuleName, source);
      overriding = true;
      const body = b.visit();
      overriding = false;
      return decl.override(currentRuleName, currentRuleFormals, body, null, source);
    },
    Rule_extend(n, fs, _, b) {
      currentRuleName = n.visit();
      currentRuleFormals = fs.children.map((c) => c.visit())[0] || [];
      const body = b.visit();
      const source = this.source.trimmed();
      return decl.extend(currentRuleName, currentRuleFormals, body, null, source);
    },
    RuleBody(_, terms) {
      return builder2.alt(...terms.visit()).withSource(this.source);
    },
    OverrideRuleBody(_, terms) {
      const args = terms.visit();
      const expansionPos = args.indexOf(superSplicePlaceholder);
      if (expansionPos >= 0) {
        const beforeTerms = args.slice(0, expansionPos);
        const afterTerms = args.slice(expansionPos + 1);
        afterTerms.forEach((t) => {
          if (t === superSplicePlaceholder) throw errors$a.multipleSuperSplices(t);
        });
        return new pexprs.Splice(
          decl.superGrammar,
          currentRuleName,
          beforeTerms,
          afterTerms
        ).withSource(this.source);
      } else {
        return builder2.alt(...args).withSource(this.source);
      }
    },
    Formals(opointy, fs, cpointy) {
      return fs.visit();
    },
    Params(opointy, ps, cpointy) {
      return ps.visit();
    },
    Alt(seqs) {
      return builder2.alt(...seqs.visit()).withSource(this.source);
    },
    TopLevelTerm_inline(b, n) {
      const inlineRuleName = currentRuleName + "_" + n.visit();
      const body = b.visit();
      const source = this.source.trimmed();
      const isNewRuleDeclaration = !(decl.superGrammar && decl.superGrammar.rules[inlineRuleName]);
      if (overriding && !isNewRuleDeclaration) {
        decl.override(inlineRuleName, currentRuleFormals, body, null, source);
      } else {
        decl.define(inlineRuleName, currentRuleFormals, body, null, source);
      }
      const params = currentRuleFormals.map((formal) => builder2.app(formal));
      return builder2.app(inlineRuleName, params).withSource(body.source);
    },
    OverrideTopLevelTerm_superSplice(_) {
      return superSplicePlaceholder;
    },
    Seq(expr) {
      return builder2.seq(...expr.children.map((c) => c.visit())).withSource(this.source);
    },
    Iter_star(x, _) {
      return builder2.star(x.visit()).withSource(this.source);
    },
    Iter_plus(x, _) {
      return builder2.plus(x.visit()).withSource(this.source);
    },
    Iter_opt(x, _) {
      return builder2.opt(x.visit()).withSource(this.source);
    },
    Pred_not(_, x) {
      return builder2.not(x.visit()).withSource(this.source);
    },
    Pred_lookahead(_, x) {
      return builder2.lookahead(x.visit()).withSource(this.source);
    },
    Lex_lex(_, x) {
      return builder2.lex(x.visit()).withSource(this.source);
    },
    Base_application(rule, ps) {
      const params = ps.children.map((c) => c.visit())[0] || [];
      return builder2.app(rule.visit(), params).withSource(this.source);
    },
    Base_range(from, _, to) {
      return builder2.range(from.visit(), to.visit()).withSource(this.source);
    },
    Base_terminal(expr) {
      return builder2.terminal(expr.visit()).withSource(this.source);
    },
    Base_paren(open, x, close) {
      return x.visit();
    },
    ruleDescr(open, t, close) {
      return t.visit();
    },
    ruleDescrText(_) {
      return this.sourceString.trim();
    },
    caseName(_, space1, n, space2, end2) {
      return n.visit();
    },
    name(first, rest) {
      return this.sourceString;
    },
    nameFirst(expr) {
    },
    nameRest(expr) {
    },
    terminal(open, cs, close) {
      return cs.children.map((c) => c.visit()).join("");
    },
    oneCharTerminal(open, c, close) {
      return c.visit();
    },
    escapeChar(c) {
      try {
        return common$m.unescapeCodePoint(this.sourceString);
      } catch (err) {
        if (err instanceof RangeError && err.message.startsWith("Invalid code point ")) {
          throw errors$a.invalidCodePoint(c);
        }
        throw err;
      }
    },
    NonemptyListOf(x, _, xs) {
      return [x.visit()].concat(xs.children.map((c) => c.visit()));
    },
    EmptyListOf() {
      return [];
    },
    _terminal() {
      return this.sourceString;
    }
  });
  return helpers(match).visit();
}
function compileAndLoad(source, namespace) {
  const m = ohmGrammar.match(source, "Grammars");
  if (m.failed()) {
    throw errors$a.grammarSyntaxError(m);
  }
  return buildGrammar(m, namespace);
}
function grammar(source, optNamespace) {
  const ns = grammars(source, optNamespace);
  const grammarNames = Object.keys(ns);
  if (grammarNames.length === 0) {
    throw new Error("Missing grammar definition");
  } else if (grammarNames.length > 1) {
    const secondGrammar = ns[grammarNames[1]];
    const interval = secondGrammar.source;
    throw new Error(
      util$8.getLineAndColumnMessage(interval.sourceString, interval.startIdx) + "Found more than one grammar definition -- use ohm.grammars() instead."
    );
  }
  return ns[grammarNames[0]];
}
function grammars(source, optNamespace) {
  const ns = Namespace.extend(Namespace.asNamespace(optNamespace));
  if (typeof source !== "string") {
    if (isBuffer(source)) {
      source = source.toString();
    } else {
      throw new TypeError(
        "Expected string as first argument, got " + common$m.unexpectedObjToString(source)
      );
    }
  }
  compileAndLoad(source, ns);
  return ns;
}
function grammarFromScriptElement(optNode) {
  throw new Error(
    "grammarFromScriptElement was removed in Ohm v16.0. See https://ohmjs.org/d/gfs for more info."
  );
}
function grammarsFromScriptElements(optNodeOrNodeList) {
  throw new Error(
    "grammarsFromScriptElements was removed in Ohm v16.0. See https://ohmjs.org/d/gfs for more info."
  );
}
main$1.exports = {
  createNamespace: Namespace.createNamespace,
  grammar,
  grammars,
  grammarFromScriptElement,
  grammarsFromScriptElements,
  makeRecipe,
  ohmGrammar: null,
  // Initialized below, after Grammar.BuiltInRules.
  pexprs,
  util: util$8,
  version: version$3
};
main$1.exports._buildGrammar = buildGrammar;
util$8.announceBuiltInRules(Grammar.BuiltInRules);
main$1.exports.ohmGrammar = ohmGrammar = ohmGrammar$1;
Grammar.initApplicationParser(ohmGrammar, buildGrammar);
var ohm = main$1.exports;
const { assert } = common$l;
function getProp(name, thing, fn) {
  return fn(thing[name]);
}
function mapProp(name, thing, fn) {
  return thing[name].map(fn);
}
function getPropWalkFn(descriptor2) {
  const parts = descriptor2.split(/ ?\[\]/);
  if (parts.length === 2) {
    return mapProp.bind(null, parts[0]);
  }
  return getProp.bind(null, descriptor2);
}
function getProps(walkFns, thing, fn) {
  return walkFns.map((walkFn) => walkFn(thing, fn));
}
function getWalkFn(shape) {
  if (typeof shape === "string") {
    return getProps.bind(null, [getPropWalkFn(shape)]);
  } else if (Array.isArray(shape)) {
    return getProps.bind(null, shape.map(getPropWalkFn));
  } else {
    assert(typeof shape === "function", "Expected a string, Array, or function");
    assert(shape.length === 2, "Expected a function of arity 2, got " + shape.length);
    return shape;
  }
}
function isRestrictedIdentifier(str) {
  return /^[a-zA-Z_][0-9a-zA-Z_]*$/.test(str);
}
function trim(s) {
  return s.trim();
}
function parseSignature(sig) {
  const parts = sig.split(/[()]/).map(trim);
  if (parts.length === 3 && parts[2] === "") {
    const name = parts[0];
    let params = [];
    if (parts[1].length > 0) {
      params = parts[1].split(",").map(trim);
    }
    if (isRestrictedIdentifier(name) && params.every(isRestrictedIdentifier)) {
      return { name, formals: params };
    }
  }
  throw new Error("Invalid operation signature: " + sig);
}
function VisitorFamily(config) {
  this._shapes = config.shapes;
  this._getTag = config.getTag;
  this.Adapter = function(thing, family) {
    this._adaptee = thing;
    this._family = family;
  };
  this.Adapter.prototype.valueOf = function() {
    throw new Error("heeey!");
  };
  this.operations = {};
  this._arities = /* @__PURE__ */ Object.create(null);
  this._getChildren = /* @__PURE__ */ Object.create(null);
  Object.keys(this._shapes).forEach((k) => {
    const shape = this._shapes[k];
    this._getChildren[k] = getWalkFn(shape);
    if (typeof shape !== "function") {
      this._arities[k] = Array.isArray(shape) ? shape.length : 1;
    }
  });
  this._wrap = (thing) => new this.Adapter(thing, this);
}
VisitorFamily.prototype.wrap = function(thing) {
  return this._wrap(thing);
};
VisitorFamily.prototype._checkActionDict = function(dict) {
  Object.keys(dict).forEach((k) => {
    assert(k in this._getChildren, "Unrecognized action name '" + k + "'");
    const action = dict[k];
    assert(typeof action === "function", "Key '" + k + "': expected function, got " + action);
    if (k in this._arities) {
      const expected = this._arities[k];
      const actual = dict[k].length;
      assert(
        actual === expected,
        "Action '" + k + "' has the wrong arity: expected " + expected + ", got " + actual
      );
    }
  });
};
VisitorFamily.prototype.addOperation = function(signature, actions) {
  const sig = parseSignature(signature);
  const { name } = sig;
  this._checkActionDict(actions);
  this.operations[name] = {
    name,
    formals: sig.formals,
    actions
  };
  const family = this;
  this.Adapter.prototype[name] = function(...args) {
    const tag = family._getTag(this._adaptee);
    assert(tag in family._getChildren, "getTag returned unrecognized tag '" + tag + "'");
    assert(tag in actions, "No action for '" + tag + "' in operation '" + name + "'");
    const argsObj = /* @__PURE__ */ Object.create(null);
    for (const [i, val] of Object.entries(args)) {
      argsObj[sig.formals[i]] = val;
    }
    const oldArgs = this.args;
    this.args = argsObj;
    const ans = actions[tag].apply(
      this,
      family._getChildren[tag](this._adaptee, family._wrap)
    );
    this.args = oldArgs;
    return ans;
  };
  return this;
};
var VisitorFamily_1 = VisitorFamily;
const defaultOperation = {
  _terminal() {
    return this.sourceString;
  },
  _nonterminal(...children) {
    const { ctorName } = this._node;
    const { mapping } = this.args;
    if (!Object.prototype.hasOwnProperty.call(mapping, ctorName)) {
      if (this.isLexical()) {
        return this.sourceString;
      }
      const realChildren = children.filter((child) => !child.isTerminal());
      if (realChildren.length === 1) {
        return realChildren[0].toAST(mapping);
      }
    }
    if (typeof mapping[ctorName] === "number") {
      return children[mapping[ctorName]].toAST(mapping);
    }
    const propMap = mapping[ctorName] || children;
    const node = {
      type: ctorName
    };
    for (const prop in propMap) {
      const mappedProp = mapping[ctorName] && mapping[ctorName][prop];
      if (typeof mappedProp === "number") {
        node[prop] = children[mappedProp].toAST(mapping);
      } else if (typeof mappedProp === "string" || typeof mappedProp === "boolean" || mappedProp === null) {
        node[prop] = mappedProp;
      } else if (typeof mappedProp === "object" && mappedProp instanceof Number) {
        node[prop] = Number(mappedProp);
      } else if (typeof mappedProp === "function") {
        node[prop] = mappedProp.call(this, children);
      } else if (mappedProp === void 0) {
        if (children[prop] && !children[prop].isTerminal()) {
          node[prop] = children[prop].toAST(mapping);
        } else {
          delete node[prop];
        }
      }
    }
    return node;
  },
  _iter(...children) {
    if (this._node.isOptional()) {
      if (this.numChildren === 0) {
        return null;
      } else {
        return children[0].toAST(this.args.mapping);
      }
    }
    return children.map(function(child) {
      return child.toAST(this.args.mapping);
    }, this);
  },
  NonemptyListOf(first, sep, rest) {
    return [first.toAST(this.args.mapping)].concat(rest.toAST(this.args.mapping));
  },
  EmptyListOf() {
    return [];
  }
};
function toAST(res, mapping) {
  if (typeof res.failed !== "function" || res.failed()) {
    throw new Error("toAST() expects a succesful MatchResult as first parameter");
  }
  mapping = Object.assign({}, mapping);
  const operation = Object.assign({}, defaultOperation);
  for (const termName in mapping) {
    if (typeof mapping[termName] === "function") {
      operation[termName] = mapping[termName];
      delete mapping[termName];
    }
  }
  const g2 = res._cst.grammar;
  const s = g2.createSemantics().addOperation("toAST(mapping)", operation);
  return s(res).toAST(mapping);
}
function semanticsForToAST(g2) {
  if (typeof g2.createSemantics !== "function") {
    throw new Error("semanticsToAST() expects a Grammar as parameter");
  }
  return g2.createSemantics().addOperation("toAST(mapping)", defaultOperation);
}
var semanticsToAST = {
  helper: toAST,
  semantics: semanticsForToAST
};
var extras = {
  VisitorFamily: VisitorFamily_1,
  semanticsForToAST: semanticsToAST.semantics,
  toAST: semanticsToAST.helper
};
const ohm_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: ohm,
  extras
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(ohm_esm);
var parents = {};
var visit = {};
var nodes$1 = {};
var hasRequiredNodes$1;
function requireNodes$1() {
  if (hasRequiredNodes$1) return nodes$1;
  hasRequiredNodes$1 = 1;
  Object.defineProperty(nodes$1, "__esModule", { value: true });
  nodes$1.NumberExpr = nodes$1.NameExpr = nodes$1.RefExpr = nodes$1.NegateExpr = nodes$1.MathExpr = nodes$1.MathOperator = nodes$1.CombinatorExpr = nodes$1.BuiltinZeroArgs = nodes$1.BuiltinZeroArgsOperators = nodes$1.BuiltinOneArgExpr = nodes$1.BuiltinOneArgOperators = nodes$1.BuiltinExpr = nodes$1.CellRefExpr = nodes$1.CompareExpr = nodes$1.CompareOperator = nodes$1.CondExpr = nodes$1.Expression = nodes$1.Combinator = nodes$1.FieldExprDef = nodes$1.FieldNamedDef = nodes$1.FieldAnonymousDef = nodes$1.FieldCurlyExprDef = nodes$1.FieldBuiltinDef = nodes$1.FieldBuiltinType = nodes$1.Field = nodes$1.Constructor = nodes$1.Declaration = nodes$1.Program = nodes$1.ASTBase = nodes$1.ASTRootBase = void 0;
  class ASTRootBase {
  }
  nodes$1.ASTRootBase = ASTRootBase;
  ASTRootBase._attributes = [];
  class ASTBase extends ASTRootBase {
  }
  nodes$1.ASTBase = ASTBase;
  class Program extends ASTRootBase {
    constructor(declarations) {
      super();
      this.declarations = declarations;
      this.parent = null;
    }
  }
  nodes$1.Program = Program;
  Program._attributes = ["declarations"];
  class Declaration extends ASTBase {
    constructor(constructorDef, fields, combinator) {
      super();
      this.constructorDef = constructorDef;
      this.fields = fields;
      this.combinator = combinator;
    }
  }
  nodes$1.Declaration = Declaration;
  Declaration._attributes = ["constructorDef", "fields", "combinator"];
  class Constructor extends ASTBase {
    constructor(name, tag) {
      super();
      this.name = name;
      this.tag = tag;
    }
    getTagType() {
      if (this.tag === null) {
        return null;
      }
      return this.tag.startsWith("$") ? "binary" : "hex";
    }
  }
  nodes$1.Constructor = Constructor;
  class Field extends ASTBase {
  }
  nodes$1.Field = Field;
  nodes$1.FieldBuiltinType = ["#", "Type"];
  class FieldBuiltinDef extends Field {
    constructor(name, type) {
      super();
      this.name = name;
      this.type = type;
    }
  }
  nodes$1.FieldBuiltinDef = FieldBuiltinDef;
  class FieldCurlyExprDef extends Field {
    constructor(expr) {
      super();
      this.expr = expr;
    }
  }
  nodes$1.FieldCurlyExprDef = FieldCurlyExprDef;
  FieldCurlyExprDef._attributes = ["expr"];
  class FieldAnonymousDef extends Field {
    constructor(name, isRef, fields) {
      super();
      this.name = name;
      this.isRef = isRef;
      this.fields = fields;
    }
  }
  nodes$1.FieldAnonymousDef = FieldAnonymousDef;
  FieldAnonymousDef._attributes = ["fields"];
  class FieldNamedDef extends Field {
    constructor(name, expr) {
      super();
      this.name = name;
      this.expr = expr;
    }
  }
  nodes$1.FieldNamedDef = FieldNamedDef;
  FieldNamedDef._attributes = ["expr"];
  class FieldExprDef extends Field {
    constructor(expr) {
      super();
      this.expr = expr;
    }
  }
  nodes$1.FieldExprDef = FieldExprDef;
  FieldExprDef._attributes = ["expr"];
  class Combinator extends ASTBase {
    constructor(name, args) {
      super();
      this.name = name;
      this.args = args;
    }
  }
  nodes$1.Combinator = Combinator;
  Combinator._attributes = ["args"];
  class Expression extends ASTBase {
  }
  nodes$1.Expression = Expression;
  class CondExpr extends Expression {
    constructor(left, dotExpr, condExpr) {
      super();
      this.left = left;
      this.dotExpr = dotExpr;
      this.condExpr = condExpr;
    }
  }
  nodes$1.CondExpr = CondExpr;
  CondExpr._attributes = ["left", "condExpr"];
  nodes$1.CompareOperator = ["<=", ">=", "!=", "=", "<", ">"];
  class CompareExpr extends Expression {
    constructor(left, op, right) {
      super();
      this.left = left;
      this.op = op;
      this.right = right;
    }
  }
  nodes$1.CompareExpr = CompareExpr;
  CompareExpr._attributes = ["left", "right"];
  class CellRefExpr extends Expression {
    constructor(expr) {
      super();
      this.expr = expr;
    }
  }
  nodes$1.CellRefExpr = CellRefExpr;
  CellRefExpr._attributes = ["expr"];
  class BuiltinExpr extends Expression {
  }
  nodes$1.BuiltinExpr = BuiltinExpr;
  nodes$1.BuiltinOneArgOperators = ["#<=", "#<", "##"];
  class BuiltinOneArgExpr extends BuiltinExpr {
    constructor(name, arg) {
      super();
      this.name = name;
      this.arg = arg;
    }
  }
  nodes$1.BuiltinOneArgExpr = BuiltinOneArgExpr;
  BuiltinOneArgExpr._attributes = ["arg"];
  nodes$1.BuiltinZeroArgsOperators = ["#"];
  class BuiltinZeroArgs extends BuiltinExpr {
    constructor(name) {
      super();
      this.name = name;
    }
  }
  nodes$1.BuiltinZeroArgs = BuiltinZeroArgs;
  class CombinatorExpr extends Expression {
    constructor(name, args) {
      super();
      this.name = name;
      this.args = args;
    }
  }
  nodes$1.CombinatorExpr = CombinatorExpr;
  CombinatorExpr._attributes = ["args"];
  nodes$1.MathOperator = ["*", "+"];
  class MathExpr extends Expression {
    // TODO: narrower type for `left` and `right`?
    // TODO: use `SimpleExpr` and `number`?
    constructor(left, op, right) {
      super();
      this.left = left;
      this.op = op;
      this.right = right;
    }
  }
  nodes$1.MathExpr = MathExpr;
  MathExpr._attributes = ["left", "right"];
  class NegateExpr extends Expression {
    constructor(expr) {
      super();
      this.expr = expr;
    }
  }
  nodes$1.NegateExpr = NegateExpr;
  NegateExpr._attributes = ["expr"];
  class RefExpr extends Expression {
  }
  nodes$1.RefExpr = RefExpr;
  class NameExpr extends RefExpr {
    constructor(name) {
      super();
      this.name = name;
    }
  }
  nodes$1.NameExpr = NameExpr;
  class NumberExpr extends RefExpr {
    constructor(num) {
      super();
      this.num = num;
    }
  }
  nodes$1.NumberExpr = NumberExpr;
  return nodes$1;
}
var hasRequiredVisit;
function requireVisit() {
  if (hasRequiredVisit) return visit;
  hasRequiredVisit = 1;
  Object.defineProperty(visit, "__esModule", { value: true });
  visit.NodeVisitor = void 0;
  visit.iterChildNodes = iterChildNodes;
  visit.walk = walk;
  const nodes_1 = requireNodes$1();
  function* iterChildNodes(node) {
    const item = Object.getPrototypeOf(node).constructor;
    for (const attributeName of item._attributes) {
      const raw = node[attributeName];
      if (Array.isArray(raw)) {
        for (const child of raw) {
          yield child;
        }
      } else if (raw instanceof nodes_1.ASTRootBase) {
        yield raw;
      }
    }
  }
  function* walk(node) {
    const todo = [node];
    while (todo.length > 0) {
      const current = todo.shift();
      todo.push(...iterChildNodes(current));
      yield current;
    }
  }
  class NodeVisitor {
    visit(node) {
      const constructorName = node.constructor.name;
      const handlerName = `visit${constructorName}`;
      const handler = this[handlerName];
      if (typeof handler === "function") {
        return handler.call(this, node);
      } else {
        return this.genericVisit(node);
      }
    }
    genericVisit(node) {
      for (let attribute of iterChildNodes(node)) {
        this.visit(attribute);
      }
    }
  }
  visit.NodeVisitor = NodeVisitor;
  return visit;
}
var hasRequiredParents;
function requireParents() {
  if (hasRequiredParents) return parents;
  hasRequiredParents = 1;
  Object.defineProperty(parents, "__esModule", { value: true });
  parents.withParents = withParents;
  const visit_1 = requireVisit();
  function withParents(tree) {
    for (let parent of (0, visit_1.walk)(tree)) {
      for (let child of (0, visit_1.iterChildNodes)(parent)) {
        if (parent) {
          child.parent = parent;
        } else {
          child.parent = parent;
        }
      }
    }
    return tree;
  }
  return parents;
}
var tlb = {};
var hasRequiredTlb;
function requireTlb() {
  if (hasRequiredTlb) return tlb;
  hasRequiredTlb = 1;
  Object.defineProperty(tlb, "__esModule", { value: true });
  const grammar2 = String.raw`
TLB {
  // See:
  // https://github.com/andreypfau/TL-B-docs

  // Root definition
  Program = SourceElement*

  // Utilities
  // Override Ohm's built-in definition of space.
  space := whitespace | lineTerminator | comment

  whitespace =
    | "\t"
    | "\x0B"    -- verticalTab
    | "\x0C"    -- formFeed
    | " "
    | "\u00A0"  -- noBreakSpace
    | "\uFEFF"  -- byteOrderMark
    | "\u2000".."\u200B"
    | "\u3000"

  sourceCharacter = any
  lineTerminator = "\n" | "\r" | "\u2028" | "\u2029"

  // Comments
  comment = multiLineComment | singleLineComment
  multiLineComment = "/*" (~"*/" sourceCharacter)* "*/"
  singleLineComment = "//" (~lineTerminator sourceCharacter)*

  // Data types
  binaryDigit = "0" | "1"
  decimalDigit = "0".."9"
  hex = hexChar* "_"?
  hexChar = decimalDigit | letter

  // Identifiers
  identifier = identifierStart identifierPart*
  identifierStart = "_" | letter
  identifierPart = identifierStart | digit

  // Primitives
  number = digit+

  // Builtins
  builtins_one_arg = "#<=" | "#<" | "##"
  builtins_zero_args = "#"
  builtins_field = "#" | "Type"


  // ----------
  // Base rules
  // ----------
  SourceElement = Declaration | comment
  Declaration = Constructor Fields "=" Combinator ";"


  // Constructors
  // ~~~~~~~~~~~~
  Constructor = ConstructorStart ConstructorTag?
  ConstructorStart = "!"? ("_" | identifier)
  ConstructorTag =
  	| "$" ("_" | binaryDigit+)  -- binary
    | "#" ("_" | hex)           -- hex


  // Fields
  // ~~~~~~
  Fields = FieldDefinition*
  FieldDefinition =
    | FieldBuiltinDef
    | FieldCurlyExprDef
    | FieldAnonymousDef
    | FieldNamedDef
    | FieldExprDef

  FieldBuiltinDef = "{" identifier ":" builtins_field "}"
  FieldCurlyExprDef = "{" CurlyExpression "}"
  FieldAnonymousDef = FieldAnonRef | FieldNamedAnonRef
  FieldNamedDef = identifier ":" CondExpr
  FieldExprDef = CondExpr

  FieldAnonRef = "^"? "[" FieldDefinition* "]"
  FieldNamedAnonRef = identifier ":" FieldAnonRef


  // Combinators
  // ~~~~~~~~~~~

  Combinator = identifier SimpleExpr*


  // Expressions
  // ~~~~~~~~~~~

  // First come the complex rules we only use to define fields.
  // The line between fields definition and expressions is blury at this point.
  CurlyExpression = CompareExpr
  CondExpr =
    | CondDotAndQuestionExpr
    | CondQuestionExpr
    | CondTypeExpr

  CondDotted = TypeExpr "." number
  CondDotAndQuestionExpr = ( CondDotted | Parens<CondDotted> ) "?" TypeExpr
  CondQuestionExpr = TypeExpr "?" TypeExpr
  CondTypeExpr = TypeExpr

  // Compares:
  CompareExpr =
    | CompareOperatorExpr
    | Parens<CompareExpr>
    | MathExpr

  CompareOperatorExpr =
    | MathExpr "<=" MathExpr
    | MathExpr ">=" MathExpr
    | MathExpr "!=" MathExpr
    | MathExpr "=" MathExpr
    | MathExpr "<" MathExpr
    | MathExpr ">" MathExpr

  // Base rule for field defining expressions:
  TypeExpr =
    | CellRefExpr
    | BuiltinExpr
    | CombinatorExpr
    | SimpleExpr
    | Parens<TypeExpr>

  // Math:
  MathExpr = MulExpr ("+" MulExpr)*
  // You can multiply by constant values only: 'Bit' and numbers, basically
  MulExpr = SimpleExpr ("*" RefExpr)*

  // TypeExpr's items:
  CellRefExpr = "^" ( CellRefInner | Parens<CellRefInner> )
  CellRefInner = TypeExpr

  BuiltinExpr = BuiltinOneArg | BuiltinZeroArgs
  // This needs extra 'Parens' because of '(##)' expr:
  BuiltinOneArg = "(" ( builtins_one_arg | Parens<builtins_one_arg> ) RefExpr ")"
  BuiltinZeroArgs = builtins_zero_args

  // It is different from 'Combinator' only in the quantity part:
  // we always need at least one argument here and it can be complex.
  CombinatorExpr = "(" identifier TypeExpr+ ")"

  SimpleExpr =
    | NegateExpr
    | MathExpr
    | RefExpr
    | Parens<SimpleExpr>

  NegateExpr = "~" SimpleExpr
  RefExpr = RefInner | Parens<RefInner>
  RefInner = identifier | number


  // Helpers
  // ~~~~~~~

  // Generic rule to allow parens around some expressions:
  Parens<expr> = "(" expr ")"
}
`;
  tlb.default = grammar2;
  return tlb;
}
var parsing = {};
var locations = {};
var hasRequiredLocations;
function requireLocations() {
  if (hasRequiredLocations) return locations;
  hasRequiredLocations = 1;
  Object.defineProperty(locations, "__esModule", { value: true });
  locations.withLocations = withLocations;
  function withLocations(astNode, intermediateNode) {
    const lineAndColumn = intermediateNode.source.getLineAndColumn();
    astNode.locations = {
      line: lineAndColumn.lineNum,
      column: lineAndColumn.colNum
    };
    return astNode;
  }
  return locations;
}
var hasRequiredParsing;
function requireParsing() {
  if (hasRequiredParsing) return parsing;
  hasRequiredParsing = 1;
  var __createBinding = parsing && parsing.__createBinding || (Object.create ? (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  }) : (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  }));
  var __setModuleDefault = parsing && parsing.__setModuleDefault || (Object.create ? (function(o, v2) {
    Object.defineProperty(o, "default", { enumerable: true, value: v2 });
  }) : function(o, v2) {
    o["default"] = v2;
  });
  var __importStar = parsing && parsing.__importStar || /* @__PURE__ */ (function() {
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      }
      __setModuleDefault(result, mod);
      return result;
    };
  })();
  Object.defineProperty(parsing, "__esModule", { value: true });
  parsing.exprNodes = parsing.combinatorNodes = parsing.fieldNodes = parsing.constructorNodes = parsing.rootNodes = void 0;
  const ast2 = __importStar(requireNodes$1());
  const locations_1 = requireLocations();
  parsing.rootNodes = {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Program(node) {
      return (0, locations_1.withLocations)(new ast2.Program(node.children.map((child) => child["root"]())), node);
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    SourceElement(node) {
      return (0, locations_1.withLocations)(new ast2.Declaration(node.child(0)["Constructor"](), node.child(1)["Field"](), node.child(3)["Combinator"]()), node);
    }
  };
  parsing.constructorNodes = {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Constructor(name, tag) {
      const nameValue = name.sourceString;
      let tagValue = null;
      if (tag.numChildren !== 0) {
        tagValue = tag.child(0)["Constructor"]();
      }
      return (0, locations_1.withLocations)(new ast2.Constructor(nameValue, tagValue), name);
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ConstructorTag(node) {
      return node.sourceString;
    }
  };
  parsing.fieldNodes = {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Fields(node) {
      return node.children.map((child) => child["Field"]());
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    FieldDefinition(node) {
      return node["Field"]();
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    FieldBuiltinDef(lpar, name, _sep, type, _rpar) {
      return (0, locations_1.withLocations)(new ast2.FieldBuiltinDef(name.sourceString, type.sourceString), lpar);
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    FieldCurlyExprDef(lpar, expr, _rpar) {
      return (0, locations_1.withLocations)(new ast2.FieldCurlyExprDef(expr["expr"]()), lpar);
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    FieldAnonymousDef(node) {
      const { name, isRef, fields } = node["Field"]();
      return (0, locations_1.withLocations)(new ast2.FieldAnonymousDef(name, isRef, fields), node);
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    FieldNamedDef(name, _sep, expr) {
      return (0, locations_1.withLocations)(new ast2.FieldNamedDef(name.sourceString, expr["expr"]()), name);
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    FieldExprDef(node) {
      return (0, locations_1.withLocations)(new ast2.FieldExprDef(node["expr"]()), node);
    },
    // Helpers to parse complex anonymous fields:
    // TODO: move out of this semantics
    FieldAnonRef(ref, _lpar, fields, _rpar) {
      return {
        name: null,
        isRef: ref.numChildren !== 0,
        fields: fields.children.map((field) => field["Field"]())
      };
    },
    FieldNamedAnonRef(name, _sep, fields) {
      return Object.assign(Object.assign({}, fields["Field"]()), { name: name.sourceString });
    }
  };
  parsing.combinatorNodes = {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Combinator(name, exprs) {
      return (0, locations_1.withLocations)(new ast2.Combinator(name.sourceString, exprs.children.map((typeExpr) => typeExpr["expr"]())), name);
    }
  };
  parsing.exprNodes = {
    // Math
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    MathExpr(left, ops, rights) {
      return parseMath(left, ops, rights);
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    MulExpr(left, ops, rights) {
      return parseMath(left, ops, rights);
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    CompareExpr(node) {
      return node["expr"]();
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    CompareOperatorExpr(left, op, right) {
      return (0, locations_1.withLocations)(new ast2.CompareExpr(left["expr"](), op.sourceString, right["expr"]()), op);
    },
    // Conditional types
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    CondExpr(expr) {
      const { leftExpr, dotExpr, condExpr } = expr["expr"]();
      if (dotExpr === void 0 && condExpr === void 0) {
        return leftExpr;
      }
      return (0, locations_1.withLocations)(new ast2.CondExpr(leftExpr, dotExpr, condExpr), expr);
    },
    // TODO: move out of this semantics
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    CondDotAndQuestionExpr(dotNode, _sep, condNode) {
      return Object.assign(Object.assign({}, dotNode["expr"]()), { condExpr: condNode["expr"]() });
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    CondQuestionExpr(left, _sep, condNode) {
      return {
        leftExpr: left["expr"](),
        dotExpr: null,
        condExpr: condNode["expr"]()
      };
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    CondTypeExpr(node) {
      return {
        leftExpr: node["expr"]()
      };
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    CondDotted(left, _sep, number) {
      return {
        leftExpr: left["expr"](),
        dotExpr: new Number(number.sourceString)
      };
    },
    // TypeExpr
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    CombinatorExpr(lpar, name, args, _rpar) {
      return (0, locations_1.withLocations)(new ast2.CombinatorExpr(name.sourceString, args.children.map((arg) => arg["expr"]())), lpar);
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    CellRefExpr(ref, node) {
      return (0, locations_1.withLocations)(new ast2.CellRefExpr(node["expr"]()), ref);
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    BuiltinExpr(node) {
      return (0, locations_1.withLocations)(node["expr"](), node);
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    NegateExpr(op, node) {
      return (0, locations_1.withLocations)(new ast2.NegateExpr(node["expr"]()), op);
    },
    // Builtins
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    BuiltinOneArg(lpar, expr, arg, _rpar) {
      return (0, locations_1.withLocations)(new ast2.BuiltinOneArgExpr(expr.sourceString, arg["expr"]()), lpar);
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    BuiltinZeroArgs(expr) {
      return (0, locations_1.withLocations)(new ast2.BuiltinZeroArgs(expr.sourceString), expr);
    },
    // Base rules
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    identifier(start, rest) {
      return (0, locations_1.withLocations)(new ast2.NameExpr(start.sourceString + rest.sourceString), start);
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    number(node) {
      return (0, locations_1.withLocations)(new ast2.NumberExpr(parseInt(node.sourceString)), node);
    },
    // Helpers
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Parens(lpar, node, _rpar) {
      return (0, locations_1.withLocations)(node["expr"](), lpar);
    }
  };
  function parseMath(left, ops, rights) {
    const leftExpr = left["expr"]();
    const opsSigns = [];
    for (let child of ops.children) {
      opsSigns.push(child.sourceString);
    }
    const rightExprs = [];
    for (let child of rights.children) {
      const rightExpr = child["expr"]();
      if (rightExpr !== void 0) {
        rightExprs.push(rightExpr);
      }
    }
    if (opsSigns.length !== rightExprs.length) {
      throw new Error("Invalid math operation");
    }
    if (opsSigns.length === 0) {
      return (0, locations_1.withLocations)(leftExpr, left);
    }
    let expr = (0, locations_1.withLocations)(new ast2.MathExpr(leftExpr, opsSigns[0], rightExprs[0]), left);
    for (let index = 1; index < opsSigns.length; index++) {
      expr = (0, locations_1.withLocations)(new ast2.MathExpr(
        expr,
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        opsSigns[index],
        // validated earlier
        rightExprs[index]
      ), left);
    }
    return expr;
  }
  return parsing;
}
var hasRequiredIntermediate;
function requireIntermediate() {
  if (hasRequiredIntermediate) return intermediate;
  hasRequiredIntermediate = 1;
  var __importDefault = intermediate && intermediate.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(intermediate, "__esModule", { value: true });
  intermediate.buildGrammar = buildGrammar2;
  intermediate.buildAST = buildAST;
  const ohm_js_1 = __importDefault(require$$0$1);
  const parents_1 = requireParents();
  const tlb_1 = __importDefault(requireTlb());
  const parsing_1 = requireParsing();
  function buildGrammar2() {
    return ohm_js_1.default.grammar(tlb_1.default);
  }
  function buildAST(input, grammar2) {
    const semantics = grammar2.createSemantics();
    semantics.addOperation("root", parsing_1.rootNodes);
    semantics.addOperation("Constructor", parsing_1.constructorNodes);
    semantics.addOperation("Field", parsing_1.fieldNodes);
    semantics.addOperation("Combinator", parsing_1.combinatorNodes);
    semantics.addOperation("expr", parsing_1.exprNodes);
    const matchResult = grammar2.match(input);
    const ast2 = semantics(matchResult)["root"]();
    return (0, parents_1.withParents)(ast2);
  }
  return intermediate;
}
var hasRequiredDist$3;
function requireDist$3() {
  if (hasRequiredDist$3) return dist$2;
  hasRequiredDist$3 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MathOperator = exports.BuiltinZeroArgsOperators = exports.BuiltinOneArgOperators = exports.CompareOperator = exports.FieldBuiltinType = exports.NumberExpr = exports.NameExpr = exports.RefExpr = exports.NegateExpr = exports.MathExpr = exports.CombinatorExpr = exports.BuiltinZeroArgs = exports.BuiltinOneArgExpr = exports.BuiltinExpr = exports.CellRefExpr = exports.CompareExpr = exports.CondExpr = exports.Expression = exports.Combinator = exports.FieldExprDef = exports.FieldNamedDef = exports.FieldAnonymousDef = exports.FieldCurlyExprDef = exports.FieldBuiltinDef = exports.Field = exports.Constructor = exports.Declaration = exports.Program = exports.ASTBase = exports.ASTRootBase = exports.NodeVisitor = void 0;
    exports.parse = parse;
    exports.ast = ast2;
    const intermediate_1 = requireIntermediate();
    function parse(input, grammar2 = void 0) {
      if (grammar2 === void 0) {
        grammar2 = (0, intermediate_1.buildGrammar)();
      }
      return grammar2.match(input);
    }
    function ast2(input) {
      return (0, intermediate_1.buildAST)(input, (0, intermediate_1.buildGrammar)());
    }
    var visit_1 = requireVisit();
    Object.defineProperty(exports, "NodeVisitor", { enumerable: true, get: function() {
      return visit_1.NodeVisitor;
    } });
    var nodes_1 = requireNodes$1();
    Object.defineProperty(exports, "ASTRootBase", { enumerable: true, get: function() {
      return nodes_1.ASTRootBase;
    } });
    Object.defineProperty(exports, "ASTBase", { enumerable: true, get: function() {
      return nodes_1.ASTBase;
    } });
    Object.defineProperty(exports, "Program", { enumerable: true, get: function() {
      return nodes_1.Program;
    } });
    Object.defineProperty(exports, "Declaration", { enumerable: true, get: function() {
      return nodes_1.Declaration;
    } });
    Object.defineProperty(exports, "Constructor", { enumerable: true, get: function() {
      return nodes_1.Constructor;
    } });
    Object.defineProperty(exports, "Field", { enumerable: true, get: function() {
      return nodes_1.Field;
    } });
    Object.defineProperty(exports, "FieldBuiltinDef", { enumerable: true, get: function() {
      return nodes_1.FieldBuiltinDef;
    } });
    Object.defineProperty(exports, "FieldCurlyExprDef", { enumerable: true, get: function() {
      return nodes_1.FieldCurlyExprDef;
    } });
    Object.defineProperty(exports, "FieldAnonymousDef", { enumerable: true, get: function() {
      return nodes_1.FieldAnonymousDef;
    } });
    Object.defineProperty(exports, "FieldNamedDef", { enumerable: true, get: function() {
      return nodes_1.FieldNamedDef;
    } });
    Object.defineProperty(exports, "FieldExprDef", { enumerable: true, get: function() {
      return nodes_1.FieldExprDef;
    } });
    Object.defineProperty(exports, "Combinator", { enumerable: true, get: function() {
      return nodes_1.Combinator;
    } });
    Object.defineProperty(exports, "Expression", { enumerable: true, get: function() {
      return nodes_1.Expression;
    } });
    Object.defineProperty(exports, "CondExpr", { enumerable: true, get: function() {
      return nodes_1.CondExpr;
    } });
    Object.defineProperty(exports, "CompareExpr", { enumerable: true, get: function() {
      return nodes_1.CompareExpr;
    } });
    Object.defineProperty(exports, "CellRefExpr", { enumerable: true, get: function() {
      return nodes_1.CellRefExpr;
    } });
    Object.defineProperty(exports, "BuiltinExpr", { enumerable: true, get: function() {
      return nodes_1.BuiltinExpr;
    } });
    Object.defineProperty(exports, "BuiltinOneArgExpr", { enumerable: true, get: function() {
      return nodes_1.BuiltinOneArgExpr;
    } });
    Object.defineProperty(exports, "BuiltinZeroArgs", { enumerable: true, get: function() {
      return nodes_1.BuiltinZeroArgs;
    } });
    Object.defineProperty(exports, "CombinatorExpr", { enumerable: true, get: function() {
      return nodes_1.CombinatorExpr;
    } });
    Object.defineProperty(exports, "MathExpr", { enumerable: true, get: function() {
      return nodes_1.MathExpr;
    } });
    Object.defineProperty(exports, "NegateExpr", { enumerable: true, get: function() {
      return nodes_1.NegateExpr;
    } });
    Object.defineProperty(exports, "RefExpr", { enumerable: true, get: function() {
      return nodes_1.RefExpr;
    } });
    Object.defineProperty(exports, "NameExpr", { enumerable: true, get: function() {
      return nodes_1.NameExpr;
    } });
    Object.defineProperty(exports, "NumberExpr", { enumerable: true, get: function() {
      return nodes_1.NumberExpr;
    } });
    Object.defineProperty(exports, "FieldBuiltinType", { enumerable: true, get: function() {
      return nodes_1.FieldBuiltinType;
    } });
    Object.defineProperty(exports, "CompareOperator", { enumerable: true, get: function() {
      return nodes_1.CompareOperator;
    } });
    Object.defineProperty(exports, "BuiltinOneArgOperators", { enumerable: true, get: function() {
      return nodes_1.BuiltinOneArgOperators;
    } });
    Object.defineProperty(exports, "BuiltinZeroArgsOperators", { enumerable: true, get: function() {
      return nodes_1.BuiltinZeroArgsOperators;
    } });
    Object.defineProperty(exports, "MathOperator", { enumerable: true, get: function() {
      return nodes_1.MathOperator;
    } });
  })(dist$2);
  return dist$2;
}
var fill_constructors = {};
var utils$4 = {};
var hasRequiredUtils$4;
function requireUtils$4() {
  if (hasRequiredUtils$4) return utils$4;
  hasRequiredUtils$4 = 1;
  Object.defineProperty(utils$4, "__esModule", { value: true });
  utils$4.crc32 = utils$4.getSubStructName = utils$4.findNotReservedName = utils$4.isNameReserved = utils$4.bitLen = utils$4.getCurrentSlice = utils$4.firstLower = void 0;
  function firstLower(structName) {
    return structName.charAt(0).toLowerCase() + structName.slice(1);
  }
  utils$4.firstLower = firstLower;
  function getCurrentSlice(slicePrefix, name) {
    let result = name;
    slicePrefix = slicePrefix.slice(0, slicePrefix.length - 1);
    slicePrefix.forEach((element) => {
      result += element.toString();
    });
    if (result == "cell") {
      return "builder";
    }
    return result;
  }
  utils$4.getCurrentSlice = getCurrentSlice;
  function bitLen(n) {
    return n.toString(2).length;
  }
  utils$4.bitLen = bitLen;
  function isNameReserved(name) {
    let tsReserved = [
      "abstract",
      "arguments",
      "await",
      "boolean",
      "break",
      "byte",
      "case",
      "catch",
      "char",
      "class",
      "const",
      "continue",
      "debugger",
      "default",
      "delete",
      "do",
      "double",
      "else",
      "enum",
      "eval",
      "export",
      "extends",
      "false",
      "final",
      "finally",
      "float",
      "for",
      "function",
      "goto",
      "if",
      "implements",
      "import",
      "in",
      "instanceof",
      "int",
      "interface",
      "let",
      "long",
      "native",
      "new",
      "null",
      "package",
      "private",
      "protected",
      "public",
      "return",
      "short",
      "static",
      "super",
      "switch",
      "synchronized",
      "this",
      "throw",
      "throws",
      "transient",
      "true",
      "try",
      "typeof",
      "var",
      "void",
      "volatile",
      "while",
      "with",
      "yield"
    ];
    if (tsReserved.includes(name)) {
      return true;
    }
    if (name.startsWith("slice")) {
      return true;
    }
    if (name.startsWith("cell")) {
      return true;
    }
    if (name == "builder") {
      return true;
    }
    return false;
  }
  utils$4.isNameReserved = isNameReserved;
  function findNotReservedName(name, possibleSuffix = "0") {
    if (name.startsWith("slice") || name.startsWith("cell")) {
      name = "_" + name;
    }
    while (isNameReserved(name)) {
      name += possibleSuffix;
    }
    return name;
  }
  utils$4.findNotReservedName = findNotReservedName;
  function getSubStructName(tlbType, constructor) {
    if (tlbType.constructors.length > 1) {
      return tlbType.name + "_" + constructor.name;
    } else {
      return tlbType.name;
    }
  }
  utils$4.getSubStructName = getSubStructName;
  const POLYNOMIAL = -306674912;
  function crc32(bytes, crc = 4294967295) {
    let result = crc;
    for (let n = 0; n < bytes.length; n++) {
      result ^= bytes[n];
      result = result & 1 ? result >>> 1 ^ POLYNOMIAL : result >>> 1;
      result = result & 1 ? result >>> 1 ^ POLYNOMIAL : result >>> 1;
      result = result & 1 ? result >>> 1 ^ POLYNOMIAL : result >>> 1;
      result = result & 1 ? result >>> 1 ^ POLYNOMIAL : result >>> 1;
      result = result & 1 ? result >>> 1 ^ POLYNOMIAL : result >>> 1;
      result = result & 1 ? result >>> 1 ^ POLYNOMIAL : result >>> 1;
      result = result & 1 ? result >>> 1 ^ POLYNOMIAL : result >>> 1;
      result = result & 1 ? result >>> 1 ^ POLYNOMIAL : result >>> 1;
    }
    return (result ^ -1) >>> 0;
  }
  utils$4.crc32 = crc32;
  return utils$4;
}
var handle_field = {};
var handle_type = {};
var utils$3 = {};
var hasRequiredUtils$3;
function requireUtils$3() {
  if (hasRequiredUtils$3) return utils$3;
  hasRequiredUtils$3 = 1;
  Object.defineProperty(utils$3, "__esModule", { value: true });
  utils$3.convertToMathExpr = utils$3.getNegatedVariable = utils$3.reorganizeExpression = utils$3.getVariableName = utils$3.deriveMathExpression = utils$3.splitForTypeValue = utils$3.getCalculatedExpression = utils$3.calculateVariable = utils$3.opCodeSetsEqual = void 0;
  const tlb_parser_1 = requireDist$3();
  const ast_1 = requireAst();
  function opCodeSetsEqual(a, b) {
    if (a === b)
      return true;
    if (a == null || b == null)
      return false;
    if (a.length !== b.length)
      return false;
    a = a.sort();
    b = b.sort();
    for (var i = 0; i < a.length; ++i) {
      if (a[i] !== b[i])
        return false;
    }
    return true;
  }
  utils$3.opCodeSetsEqual = opCodeSetsEqual;
  function calculateVariable(variable, constructor) {
    if (variable.calculated) {
      return;
    }
    if (!variable.deriveExpr) {
      return;
    }
    variable.calculated = true;
    variable.deriveExpr = getCalculatedExpression(variable.deriveExpr, constructor);
  }
  utils$3.calculateVariable = calculateVariable;
  function getCalculatedExpression(expr, constructor) {
    if (expr instanceof ast_1.TLBVarExpr) {
      let variable = constructor.variablesMap.get(expr.x);
      if (variable) {
        calculateVariable(variable, constructor);
        if (variable.deriveExpr) {
          return variable.deriveExpr;
        }
      }
    }
    if (expr instanceof ast_1.TLBBinaryOp) {
      let left = getCalculatedExpression(expr.left, constructor);
      let right = getCalculatedExpression(expr.right, constructor);
      return new ast_1.TLBBinaryOp(left, right, expr.operation, expr.variables, expr.hasNeg);
    }
    return expr;
  }
  utils$3.getCalculatedExpression = getCalculatedExpression;
  function splitForTypeValue(name, typeName) {
    if (!name.startsWith(typeName)) {
      return void 0;
    }
    let num = parseInt(name.slice(typeName.length));
    if (num == void 0) {
      return void 0;
    }
    if (name != typeName + num.toString()) {
      return void 0;
    }
    return num;
  }
  utils$3.splitForTypeValue = splitForTypeValue;
  function deriveMathExpression(mathExpr) {
    let myMathExpr = convertToMathExpr(mathExpr);
    return {
      name: getVariableName(myMathExpr),
      derived: myMathExpr
    };
  }
  utils$3.deriveMathExpression = deriveMathExpression;
  function getVariableName(myMathExpr) {
    if (myMathExpr instanceof ast_1.TLBVarExpr) {
      return myMathExpr.x;
    }
    if (myMathExpr instanceof ast_1.TLBBinaryOp) {
      if (myMathExpr.left.variables.size) {
        return getVariableName(myMathExpr.left);
      } else {
        return getVariableName(myMathExpr.right);
      }
    }
    return void 0;
  }
  utils$3.getVariableName = getVariableName;
  function reorganizeExpression(mathExpr, variable) {
    if (mathExpr instanceof ast_1.TLBBinaryOp && mathExpr.operation == "=") {
      if (mathExpr.left.variables.has(variable)) {
        mathExpr = new ast_1.TLBBinaryOp(mathExpr.right, mathExpr.left, "=", mathExpr.variables, mathExpr.hasNeg);
      }
      if (mathExpr.right instanceof ast_1.TLBVarExpr) {
        return new ast_1.TLBBinaryOp(mathExpr.right, mathExpr.left, "=", mathExpr.variables, mathExpr.hasNeg);
      }
      let rightSide = mathExpr.right;
      if (rightSide instanceof ast_1.TLBBinaryOp) {
        let op = "";
        if (rightSide.operation == "*") {
          op = "/";
        } else if (rightSide.operation == "+") {
          op = "-";
        } else {
          throw new Error("invalid operation");
        }
        let withVariable = void 0;
        let other = void 0;
        if (rightSide.left.variables.has(variable)) {
          withVariable = rightSide.left;
          other = rightSide.right;
        } else {
          other = rightSide.left;
          withVariable = rightSide.right;
        }
        let leftSide = new ast_1.TLBBinaryOp(mathExpr.left, other, op);
        mathExpr = new ast_1.TLBBinaryOp(leftSide, withVariable, "=", /* @__PURE__ */ new Set([...leftSide.variables, ...withVariable.variables]), leftSide.hasNeg || rightSide.hasNeg);
        return reorganizeExpression(mathExpr, variable);
      }
    }
    throw new Error(`Couldn't reogranize expression: ${mathExpr}`);
  }
  utils$3.reorganizeExpression = reorganizeExpression;
  function getNegatedVariable(mathExpr) {
    if (mathExpr.hasNeg) {
      if (mathExpr instanceof ast_1.TLBBinaryOp) {
        if (mathExpr.left.hasNeg) {
          return getNegatedVariable(mathExpr.left);
        }
        if (mathExpr.right.hasNeg) {
          return getNegatedVariable(mathExpr.right);
        }
      }
      if (mathExpr instanceof ast_1.TLBVarExpr) {
        return mathExpr.x;
      }
    }
    return void 0;
  }
  utils$3.getNegatedVariable = getNegatedVariable;
  function convertToMathExpr(mathExpr, negated = false) {
    if (mathExpr instanceof tlb_parser_1.NameExpr) {
      let variables = /* @__PURE__ */ new Set();
      variables.add(mathExpr.name);
      return new ast_1.TLBVarExpr(mathExpr.name, variables, negated);
    }
    if (mathExpr instanceof tlb_parser_1.NumberExpr) {
      return new ast_1.TLBNumberExpr(mathExpr.num, /* @__PURE__ */ new Set(), false);
    }
    if (mathExpr instanceof tlb_parser_1.MathExpr) {
      let left = convertToMathExpr(mathExpr.left, negated);
      let right = convertToMathExpr(mathExpr.right, negated);
      return new ast_1.TLBBinaryOp(left, right, mathExpr.op);
    }
    if (mathExpr instanceof tlb_parser_1.CompareExpr) {
      let left = convertToMathExpr(mathExpr.left, negated);
      let right = convertToMathExpr(mathExpr.right, negated);
      let operation = mathExpr.op;
      return new ast_1.TLBBinaryOp(left, right, operation);
    }
    if (mathExpr instanceof tlb_parser_1.NegateExpr) {
      if (mathExpr.expr instanceof tlb_parser_1.MathExpr || mathExpr.expr instanceof tlb_parser_1.NameExpr || mathExpr.expr instanceof tlb_parser_1.NumberExpr) {
        let expression = convertToMathExpr(mathExpr.expr, true);
        if (expression instanceof ast_1.TLBBinaryOp) {
          return new ast_1.TLBBinaryOp(expression.left, expression.right, expression.operation, expression.variables, true);
        }
        if (expression instanceof ast_1.TLBVarExpr) {
          return new ast_1.TLBVarExpr(expression.x, expression.variables, true);
        }
        if (expression instanceof ast_1.TLBNumberExpr) {
          return new ast_1.TLBNumberExpr(expression.n, expression.variables, true);
        }
      }
    }
    throw new Error(`Could not convert expression: ${mathExpr}`);
  }
  utils$3.convertToMathExpr = convertToMathExpr;
  return utils$3;
}
var hasRequiredHandle_type;
function requireHandle_type() {
  if (hasRequiredHandle_type) return handle_type;
  hasRequiredHandle_type = 1;
  Object.defineProperty(handle_type, "__esModule", { value: true });
  handle_type.getType = void 0;
  const tlb_parser_1 = requireDist$3();
  const ast_1 = requireAst();
  const utils_1 = requireUtils$3();
  function getType(expr, constructor, fieldTypeName) {
    var _a;
    if (expr instanceof tlb_parser_1.BuiltinZeroArgs) {
      if (expr.name == "#") {
        return {
          kind: "TLBNumberType",
          bits: new ast_1.TLBNumberExpr(32),
          storeBits: new ast_1.TLBNumberExpr(32),
          signed: false,
          maxBits: 32
        };
      } else {
        throw new Error("Expression not supported" + expr);
      }
    } else if (expr instanceof tlb_parser_1.BuiltinOneArgExpr) {
      if (expr.name.toString() == "##" || expr.name.toString() == "(##)") {
        if (expr.arg instanceof tlb_parser_1.NumberExpr) {
          return {
            kind: "TLBNumberType",
            bits: new ast_1.TLBNumberExpr(expr.arg.num),
            storeBits: new ast_1.TLBNumberExpr(expr.arg.num),
            signed: false,
            maxBits: expr.arg.num
          };
        }
        if (expr.arg instanceof tlb_parser_1.NameExpr) {
          let parameter = constructor.parametersMap.get(expr.arg.name);
          if (!parameter || !parameter.variable.deriveExpr || !parameter.variable.initialExpr) {
            throw new Error(`Couldn't handle expression ${expr}`);
          }
          return {
            kind: "TLBNumberType",
            bits: (0, utils_1.getCalculatedExpression)(parameter.variable.deriveExpr, constructor),
            storeBits: parameter.variable.initialExpr,
            signed: false,
            maxBits: void 0
          };
        } else {
          throw new Error(`Couldn't handle expression ${expr}`);
        }
      } else if (expr.name == "#<") {
        if (expr.arg instanceof tlb_parser_1.NumberExpr || expr.arg instanceof tlb_parser_1.NameExpr) {
          let bits = new ast_1.TLBUnaryOp(new ast_1.TLBBinaryOp((0, utils_1.getCalculatedExpression)((0, utils_1.convertToMathExpr)(expr.arg), constructor), new ast_1.TLBNumberExpr(1), "-"), ".");
          return {
            kind: "TLBNumberType",
            bits,
            storeBits: bits,
            signed: false,
            maxBits: 32
          };
        } else {
          throw new Error(`Couldn't handle expression ${expr}`);
        }
      } else if (expr.name == "#<=") {
        if (expr.arg instanceof tlb_parser_1.NumberExpr || expr.arg instanceof tlb_parser_1.NameExpr) {
          let bits = new ast_1.TLBUnaryOp((0, utils_1.getCalculatedExpression)((0, utils_1.convertToMathExpr)(expr.arg), constructor), ".");
          return {
            kind: "TLBNumberType",
            bits,
            storeBits: bits,
            signed: false,
            maxBits: 32
          };
        } else {
          throw new Error(`Couldn't handle expression ${expr}`);
        }
      }
    } else if (expr instanceof tlb_parser_1.CombinatorExpr) {
      if (expr.name == "int" && expr.args.length == 1 && (expr.args[0] instanceof tlb_parser_1.MathExpr || expr.args[0] instanceof tlb_parser_1.NumberExpr || expr.args[0] instanceof tlb_parser_1.NameExpr)) {
        return {
          kind: "TLBNumberType",
          bits: (0, utils_1.getCalculatedExpression)((0, utils_1.convertToMathExpr)(expr.args[0]), constructor),
          storeBits: (0, utils_1.convertToMathExpr)(expr.args[0]),
          signed: true,
          maxBits: void 0
        };
      } else if (expr.name == "uint" && expr.args.length == 1 && (expr.args[0] instanceof tlb_parser_1.MathExpr || expr.args[0] instanceof tlb_parser_1.NumberExpr || expr.args[0] instanceof tlb_parser_1.NameExpr)) {
        return {
          kind: "TLBNumberType",
          bits: (0, utils_1.getCalculatedExpression)((0, utils_1.convertToMathExpr)(expr.args[0]), constructor),
          storeBits: (0, utils_1.convertToMathExpr)(expr.args[0]),
          signed: false,
          maxBits: void 0
        };
      } else if (expr.name == "bits" && expr.args.length == 1 && (expr.args[0] instanceof tlb_parser_1.MathExpr || expr.args[0] instanceof tlb_parser_1.NumberExpr || expr.args[0] instanceof tlb_parser_1.NameExpr)) {
        return {
          kind: "TLBBitsType",
          bits: (0, utils_1.getCalculatedExpression)((0, utils_1.convertToMathExpr)(expr.args[0]), constructor)
        };
      } else if (expr.name == "HashmapE") {
        if (expr.args.length != 2) {
          throw new Error("");
        }
        let key2 = getType(expr.args[0], constructor, fieldTypeName);
        let value = getType(expr.args[1], constructor, fieldTypeName);
        if (key2.kind != "TLBExprMathType") {
          throw new Error("Hashmap key should be number");
        }
        return { kind: "TLBHashmapType", key: key2, value, directStore: false };
      } else if (expr.name == "HashmapAugE") {
        if (expr.args.length != 3) {
          throw new Error("Not enough arguments for HashmapAugE");
        }
        let key2 = getType(expr.args[0], constructor, fieldTypeName);
        let value = getType(expr.args[1], constructor, fieldTypeName);
        let extra = getType(expr.args[2], constructor, fieldTypeName);
        if (key2.kind != "TLBExprMathType") {
          throw new Error("Hashmap key should be number");
        }
        return { kind: "TLBHashmapType", key: key2, value, extra, directStore: false };
      } else if (expr.name == "Hashmap" && constructor.tlbType != "HashmapNode") {
        let key2 = getType(expr.args[0], constructor, fieldTypeName);
        let value = getType(expr.args[1], constructor, fieldTypeName);
        if (key2.kind != "TLBExprMathType") {
          throw new Error("Hashmap key should be number");
        }
        return { kind: "TLBHashmapType", key: key2, value, directStore: true };
      } else if (expr.name == "VarUInteger" && (expr.args[0] instanceof tlb_parser_1.MathExpr || expr.args[0] instanceof tlb_parser_1.NumberExpr || expr.args[0] instanceof tlb_parser_1.NameExpr)) {
        return {
          kind: "TLBVarIntegerType",
          n: new ast_1.TLBUnaryOp(new ast_1.TLBBinaryOp((0, utils_1.convertToMathExpr)(expr.args[0]), new ast_1.TLBNumberExpr(1), "-"), "."),
          signed: false
        };
      } else if (expr.name == "VarInteger" && (expr.args[0] instanceof tlb_parser_1.MathExpr || expr.args[0] instanceof tlb_parser_1.NumberExpr || expr.args[0] instanceof tlb_parser_1.NameExpr)) {
        return {
          kind: "TLBVarIntegerType",
          n: (0, utils_1.convertToMathExpr)(expr.args[0]),
          signed: true
        };
      } else {
        let argumentTypes = [];
        expr.args.forEach((arg) => {
          let thefield = getType(arg, constructor, fieldTypeName);
          argumentTypes.push(thefield);
        });
        return {
          kind: "TLBNamedType",
          name: expr.name,
          arguments: argumentTypes
        };
      }
    } else if (expr instanceof tlb_parser_1.NameExpr) {
      let theNum;
      if (expr.name == "Int") {
        return {
          kind: "TLBNumberType",
          bits: new ast_1.TLBNumberExpr(257),
          storeBits: new ast_1.TLBNumberExpr(257),
          signed: true,
          maxBits: 257
        };
      } else if (expr.name == "VmStack") {
        return {
          kind: "TLBTupleType"
        };
      } else if (expr.name == "Bits") {
        return { kind: "TLBBitsType", bits: new ast_1.TLBNumberExpr(1023) };
      } else if (expr.name == "Bit") {
        return { kind: "TLBBitsType", bits: new ast_1.TLBNumberExpr(1) };
      } else if (expr.name == "Uint") {
        return {
          kind: "TLBNumberType",
          bits: new ast_1.TLBNumberExpr(257),
          storeBits: new ast_1.TLBNumberExpr(257),
          signed: false,
          maxBits: 257
        };
      } else if (expr.name == "Any" || expr.name == "Cell") {
        return { kind: "TLBCellType" };
      } else if ((theNum = (0, utils_1.splitForTypeValue)(expr.name, "int")) != void 0) {
        return {
          kind: "TLBNumberType",
          bits: new ast_1.TLBNumberExpr(theNum),
          storeBits: new ast_1.TLBNumberExpr(theNum),
          signed: true,
          maxBits: theNum
        };
      } else if ((theNum = (0, utils_1.splitForTypeValue)(expr.name, "uint")) != void 0) {
        return {
          kind: "TLBNumberType",
          bits: new ast_1.TLBNumberExpr(theNum),
          storeBits: new ast_1.TLBNumberExpr(theNum),
          signed: false,
          maxBits: theNum
        };
      } else if ((theNum = (0, utils_1.splitForTypeValue)(expr.name, "bits")) != void 0) {
        return { kind: "TLBBitsType", bits: new ast_1.TLBNumberExpr(theNum) };
      } else if (expr.name == "MsgAddressInt") {
        return { kind: "TLBAddressType", addrType: "Internal" };
      } else if (expr.name == "MsgAddressExt") {
        return { kind: "TLBAddressType", addrType: "External" };
      } else if (expr.name == "MsgAddress") {
        return { kind: "TLBAddressType", addrType: "Any" };
      } else if (expr.name == "Grams" || expr.name == "Coins") {
        return { kind: "TLBCoinsType" };
      } else if (expr.name == "Bool") {
        return { kind: "TLBBoolType", value: void 0 };
      } else if (expr.name == "BoolFalse") {
        return { kind: "TLBBoolType", value: false };
      } else if (expr.name == "BoolTrue") {
        return { kind: "TLBBoolType", value: true };
      } else {
        if (((_a = constructor.variablesMap.get(expr.name)) === null || _a === void 0 ? void 0 : _a.type) == "#") {
          return {
            kind: "TLBExprMathType",
            expr: (0, utils_1.getCalculatedExpression)(new ast_1.TLBVarExpr(expr.name), constructor),
            initialExpr: new ast_1.TLBVarExpr(expr.name)
          };
        } else {
          return { kind: "TLBNamedType", name: expr.name, arguments: [] };
        }
      }
    } else if (expr instanceof tlb_parser_1.NumberExpr) {
      return { kind: "TLBExprMathType", expr: new ast_1.TLBNumberExpr(expr.num), initialExpr: new ast_1.TLBNumberExpr(expr.num) };
    } else if (expr instanceof tlb_parser_1.NegateExpr && expr.expr instanceof tlb_parser_1.NameExpr) {
      return { kind: "TLBNegatedType", variableName: expr.expr.name };
    } else if (expr instanceof tlb_parser_1.CellRefExpr) {
      let subExprInfo = getType(expr.expr, constructor, fieldTypeName);
      return { kind: "TLBCellInsideType", value: subExprInfo };
    } else if (expr instanceof tlb_parser_1.MathExpr) {
      if (fieldTypeName == "") {
        if (expr.op == "*") {
          let subExprInfo = getType(expr.right, constructor, fieldTypeName);
          return {
            kind: "TLBMultipleType",
            times: (0, utils_1.getCalculatedExpression)((0, utils_1.convertToMathExpr)(expr.left), constructor),
            value: subExprInfo
          };
        } else {
          throw new Error(`Couldn't handle expression ${expr}`);
        }
      } else {
        return {
          kind: "TLBExprMathType",
          expr: (0, utils_1.getCalculatedExpression)((0, utils_1.convertToMathExpr)(expr), constructor),
          initialExpr: (0, utils_1.convertToMathExpr)(expr)
        };
      }
    } else if (expr instanceof tlb_parser_1.CondExpr) {
      let subExprInfo = getType(expr.condExpr, constructor, fieldTypeName);
      if (expr.left instanceof tlb_parser_1.NameExpr) {
        let condition = (0, utils_1.getCalculatedExpression)((0, utils_1.convertToMathExpr)(expr.left), constructor);
        if (expr.dotExpr != null) {
          condition = new ast_1.TLBBinaryOp(condition, new ast_1.TLBBinaryOp(new ast_1.TLBNumberExpr(1), new ast_1.TLBNumberExpr(expr.dotExpr), "<<"), "&");
        }
        return { kind: "TLBCondType", value: subExprInfo, condition };
      }
    } else {
      throw new Error(`Couldn't handle expression ${expr}`);
    }
    throw new Error(`Couldn't handle expression ${expr}`);
  }
  handle_type.getType = getType;
  return handle_type;
}
var hasRequiredHandle_field;
function requireHandle_field() {
  if (hasRequiredHandle_field) return handle_field;
  hasRequiredHandle_field = 1;
  Object.defineProperty(handle_field, "__esModule", { value: true });
  handle_field.fillFields = void 0;
  const tlb_parser_1 = requireDist$3();
  const handle_type_1 = requireHandle_type();
  function getField(field, constructor, fieldIndex) {
    if (field instanceof tlb_parser_1.FieldAnonymousDef) {
      let result = {
        name: "",
        anonymous: true,
        fieldType: { kind: "TLBNamedType", name: "Bool", arguments: [] },
        subFields: []
      };
      let currentFieldIndex = 0;
      field.fields.forEach((field2) => {
        let subField = getField(field2, constructor, fieldIndex + "_" + currentFieldIndex.toString());
        if (subField) {
          result.subFields.push(subField);
        }
        currentFieldIndex++;
      });
      return result;
    }
    if (field instanceof tlb_parser_1.FieldNamedDef || field instanceof tlb_parser_1.FieldExprDef) {
      let fieldName;
      if (field instanceof tlb_parser_1.FieldNamedDef) {
        fieldName = field.name;
      } else {
        fieldName = "anon" + fieldIndex;
      }
      if (field instanceof tlb_parser_1.FieldExprDef && field.expr instanceof tlb_parser_1.NameExpr && field.expr.name == "_") {
        return void 0;
      }
      if (field.expr instanceof tlb_parser_1.CellRefExpr) {
        if (field.expr.expr instanceof tlb_parser_1.CombinatorExpr && (field.expr.expr.name == "MERKLE_UPDATE" || field.expr.expr.name == "MERKLE_ROOT")) {
          return {
            name: fieldName,
            anonymous: true,
            fieldType: { kind: "TLBExoticType" },
            subFields: []
          };
        } else {
          let subField = getField(new tlb_parser_1.FieldNamedDef(fieldName, field.expr.expr), constructor, fieldIndex + "_0");
          if (subField) {
            let result = {
              name: fieldName,
              anonymous: true,
              fieldType: { kind: "TLBNamedType", name: "Bool", arguments: [] },
              subFields: [subField]
            };
            return result;
          }
          return subField;
        }
      }
      if (field.expr instanceof tlb_parser_1.CombinatorExpr || field.expr instanceof tlb_parser_1.NameExpr || field.expr instanceof tlb_parser_1.BuiltinZeroArgs || field.expr instanceof tlb_parser_1.BuiltinOneArgExpr || field.expr instanceof tlb_parser_1.MathExpr || field.expr instanceof tlb_parser_1.CondExpr) {
        let fieldTypeName;
        if (field.expr instanceof tlb_parser_1.MathExpr || field.expr instanceof tlb_parser_1.CondExpr) {
          fieldTypeName = "";
        } else {
          fieldTypeName = field.expr.name;
        }
        let fieldInfo = (0, handle_type_1.getType)(field.expr, constructor, fieldTypeName);
        return {
          name: fieldName,
          anonymous: !(field instanceof tlb_parser_1.FieldNamedDef),
          fieldType: fieldInfo,
          subFields: []
        };
      }
    }
    return void 0;
  }
  function fillFields(typeItem, _tlbType) {
    let constructor = typeItem.constructor;
    let declaration = typeItem.declaration;
    let fieldIndex = -1;
    declaration.fields.forEach((fieldDecl) => {
      fieldIndex++;
      let field = getField(fieldDecl, constructor, fieldIndex.toString());
      if (field != void 0) {
        constructor.fields.push(field);
      }
    });
  }
  handle_field.fillFields = fillFields;
  return handle_field;
}
var hasRequiredFill_constructors;
function requireFill_constructors() {
  if (hasRequiredFill_constructors) return fill_constructors;
  hasRequiredFill_constructors = 1;
  Object.defineProperty(fill_constructors, "__esModule", { value: true });
  fill_constructors.convertCodeToReadonly = fill_constructors.fillConstructors = void 0;
  const tlb_parser_1 = requireDist$3();
  const ast_1 = requireAst();
  const utils_1 = requireUtils$4();
  const handle_field_1 = requireHandle_field();
  const utils_2 = requireUtils$3();
  function fillConstructors(declarations, tlbCode, input) {
    let typeDeclarations = /* @__PURE__ */ new Map();
    declarations.forEach((declaration) => {
      let tlbType = tlbCode.types.get(declaration.combinator.name);
      if (tlbType == void 0) {
        tlbType = { name: declaration.combinator.name, constructors: [] };
      }
      let constructor = {
        parameters: [],
        parametersMap: /* @__PURE__ */ new Map(),
        name: declaration.constructorDef.name,
        variables: new Array(),
        variablesMap: /* @__PURE__ */ new Map(),
        tag: getConstructorTag(declaration),
        constraints: [],
        fields: [],
        declaration: "",
        tlbType: tlbType.name
      };
      tlbType.constructors.push(constructor);
      tlbCode.types.set(tlbType.name, tlbType);
      let currentDecls = typeDeclarations.get(tlbType.name);
      if (!currentDecls) {
        currentDecls = [];
      }
      currentDecls.push({ declaration, constructor });
      typeDeclarations.set(tlbType.name, currentDecls);
    });
    tlbCode.types.forEach((tlbType) => {
      var _a;
      (_a = typeDeclarations.get(tlbType.name)) === null || _a === void 0 ? void 0 : _a.forEach((typeItem) => {
        let declaration = typeItem.declaration;
        let constructor = typeItem.constructor;
        declaration.fields.forEach((field) => {
          if (field instanceof tlb_parser_1.FieldBuiltinDef) {
            constructor.variables.push({
              name: field.name,
              isConst: false,
              negated: false,
              type: field.type,
              calculated: false,
              isField: false
            });
          }
          if (field instanceof tlb_parser_1.FieldNamedDef) {
            constructor.variables.push({
              name: field.name,
              isConst: false,
              negated: false,
              type: "#",
              calculated: false,
              isField: true
            });
          }
        });
        constructor.variables.forEach((variable) => {
          if (variable.name) {
            constructor.variablesMap.set(variable.name, variable);
          }
        });
        let argumentIndex = -1;
        declaration.combinator.args.forEach((element) => {
          argumentIndex++;
          let parameter = void 0;
          if (element instanceof tlb_parser_1.NameExpr) {
            let variable = constructor.variablesMap.get(element.name);
            if (variable) {
              if (variable.type == "#") {
                variable.deriveExpr = new ast_1.TLBVarExpr(element.name);
                variable.initialExpr = variable.deriveExpr;
              }
              parameter = {
                variable,
                paramExpr: new ast_1.TLBVarExpr(element.name)
              };
            } else {
              throw new Error("Field not known before using (should be tagged as implicit): " + element);
            }
          } else if (element instanceof tlb_parser_1.MathExpr) {
            let derivedExpr = (0, utils_2.deriveMathExpression)(element);
            if (!derivedExpr.name) {
              throw new Error(`Expression should contain variable ${element}`);
            }
            let variable = constructor.variablesMap.get(derivedExpr.name);
            if (variable && variable.name) {
              parameter = { variable, paramExpr: derivedExpr.derived };
              parameter.argName = "arg" + argumentIndex;
              parameter.variable.deriveExpr = reorganizeWithArg((0, utils_2.convertToMathExpr)(element), parameter.argName, variable.name);
              parameter.variable.initialExpr = new ast_1.TLBVarExpr(variable.name);
            } else {
              throw new Error(`Variable should have name ${variable}`);
            }
          } else if (element instanceof tlb_parser_1.NegateExpr && (element.expr instanceof tlb_parser_1.MathExpr || element.expr instanceof tlb_parser_1.NumberExpr || element.expr instanceof tlb_parser_1.NameExpr)) {
            let derivedExpr = (0, utils_2.deriveMathExpression)(element.expr);
            let toBeConst = false;
            if (element.expr instanceof tlb_parser_1.NumberExpr) {
              toBeConst = true;
            }
            if (derivedExpr.name == void 0) {
              if (toBeConst) {
                parameter = {
                  variable: {
                    negated: true,
                    isConst: toBeConst,
                    type: "#",
                    name: void 0,
                    deriveExpr: derivedExpr.derived,
                    initialExpr: derivedExpr.derived,
                    calculated: false,
                    isField: false
                  },
                  paramExpr: derivedExpr.derived
                };
              } else {
                throw new Error("Cannot identify combinator arg " + element);
              }
            } else {
              let variable = constructor.variablesMap.get(derivedExpr.name);
              if (variable) {
                variable.negated = true;
                variable.isConst = toBeConst;
                variable.initialExpr = derivedExpr.derived;
                parameter = {
                  variable,
                  paramExpr: derivedExpr.derived
                };
              } else {
                throw new Error("Cannot identify combinator arg " + element);
              }
            }
          } else if (element instanceof tlb_parser_1.NumberExpr) {
            parameter = {
              variable: {
                negated: false,
                isConst: true,
                type: "#",
                name: void 0,
                deriveExpr: new ast_1.TLBNumberExpr(element.num),
                initialExpr: new ast_1.TLBNumberExpr(element.num),
                calculated: false,
                isField: false
              },
              paramExpr: new ast_1.TLBNumberExpr(element.num)
            };
          } else {
            throw new Error("Cannot identify combinator arg: " + element);
          }
          constructor.parameters.push(parameter);
          if (parameter.variable.name != void 0) {
            constructor.parametersMap.set(parameter.variable.name, parameter);
          }
        });
        constructor.declaration = getStringDeclaration(declaration, input);
        fillConstraintsAndNegationVars(constructor, declaration);
        (0, handle_field_1.fillFields)(typeItem, tlbType);
        calculateVariables(constructor);
      });
      fillParameterNames(tlbType);
      fillArgNames(tlbType);
      findConstructorsNaming(tlbType);
      tlbType.constructors.sort(compareConstructors);
    });
    checkAndRemovePrimitives(tlbCode, input, typeDeclarations);
    findAvailableVarNamesForCode(tlbCode);
  }
  fill_constructors.fillConstructors = fillConstructors;
  function fillConstraintsAndNegationVars(constructor, declaration) {
    declaration.fields.forEach((field) => {
      if (field instanceof tlb_parser_1.FieldCurlyExprDef && field.expr instanceof tlb_parser_1.CompareExpr) {
        if (field.expr.op == "=") {
          let myMathExpr = (0, utils_2.convertToMathExpr)(field.expr);
          let negatedVariable = (0, utils_2.getNegatedVariable)(myMathExpr);
          if (negatedVariable) {
            myMathExpr = (0, utils_2.reorganizeExpression)(myMathExpr, negatedVariable);
            if (myMathExpr instanceof ast_1.TLBBinaryOp) {
              myMathExpr = myMathExpr.right;
            }
            let variable = constructor.variablesMap.get(negatedVariable);
            if (variable) {
              variable.negated = true;
              variable.deriveExpr = myMathExpr;
            } else {
              throw new Error(`Variable ${negatedVariable} not defined`);
            }
          } else {
            constructor.constraints.push(myMathExpr);
          }
        } else {
          constructor.constraints.push((0, utils_2.convertToMathExpr)(field.expr));
        }
      }
    });
  }
  function fillParameterNames(tlbType) {
    var _a;
    let parameterNames = [];
    (_a = tlbType.constructors[0]) === null || _a === void 0 ? void 0 : _a.parameters.forEach((element) => {
      parameterNames.push(element.variable.name);
    });
    tlbType.constructors.forEach((constructor) => {
      var _a2;
      for (let i = 0; i < constructor.parameters.length; i++) {
        if (parameterNames[i] == void 0) {
          let parameterName = (_a2 = constructor.parameters[i]) === null || _a2 === void 0 ? void 0 : _a2.variable.name;
          if (parameterName != void 0) {
            parameterNames[i] = parameterName;
          }
        }
      }
    });
    for (let i = 0; i < parameterNames.length; i++) {
      if (parameterNames[i] == void 0) {
        parameterNames[i] = "arg" + i;
      }
    }
    tlbType.constructors.forEach((constructor) => {
      var _a2;
      for (let i = 0; i < constructor.parameters.length; i++) {
        let parameterName = parameterNames[i];
        if (parameterName != void 0 && ((_a2 = constructor.parameters[i]) === null || _a2 === void 0 ? void 0 : _a2.variable.name) == void 0) {
          constructor.parameters[i].variable.name = parameterName;
        }
      }
    });
  }
  function fillArgNames(tlbType) {
    var _a;
    let argNames = [];
    (_a = tlbType.constructors[0]) === null || _a === void 0 ? void 0 : _a.parameters.forEach((_element) => {
      argNames.push(void 0);
    });
    tlbType.constructors.forEach((constructor) => {
      var _a2;
      for (let i = 0; i < constructor.parameters.length; i++) {
        let argName = (_a2 = constructor.parameters[i]) === null || _a2 === void 0 ? void 0 : _a2.argName;
        if (argName) {
          argNames[i] = argName;
        }
      }
    });
    tlbType.constructors.forEach((constructor) => {
      for (let i = 0; i < constructor.parameters.length; i++) {
        let argName = argNames[i];
        let parameter = constructor.parameters[i];
        if (argName != void 0 && parameter != void 0) {
          parameter.argName = argName;
          if (parameter.paramExpr instanceof ast_1.TLBVarExpr) {
            parameter.variable.deriveExpr = new ast_1.TLBVarExpr(parameter.argName);
            parameter.paramExpr = parameter.variable.deriveExpr;
          }
        }
      }
    });
  }
  function compareConstructors(a, b) {
    let aPriority = constructorPriority(a);
    let bPriority = constructorPriority(b);
    if (aPriority < bPriority) {
      return 1;
    }
    if (aPriority > bPriority) {
      return -1;
    }
    return 0;
  }
  function constructorPriority(c) {
    let result = 0;
    if (c.tag.bitLen > 0) {
      result++;
    }
    c.parameters.forEach((parameter) => {
      if (parameter.variable.isConst) {
        result++;
      }
    });
    return result;
  }
  function reorganizeWithArg(mathExpr, argName, varName) {
    let reorganized = (0, utils_2.reorganizeExpression)(new ast_1.TLBBinaryOp(new ast_1.TLBVarExpr(argName), mathExpr, "=", /* @__PURE__ */ new Set(), false), varName);
    if (reorganized instanceof ast_1.TLBBinaryOp) {
      return reorganized.right;
    }
    throw new Error(`Couldn't reorganize expression ${mathExpr}`);
  }
  function getConstructorTag(declaration, _input) {
    let tag = declaration.constructorDef.tag;
    if (tag == null && declaration.constructorDef.name == "_" || tag && tag.length > 1 && tag[1] == "_") {
      return {
        bitLen: 0,
        binary: ""
      };
    }
    if (tag == null) {
      let calculatedTag = calculateTag(declaration);
      return {
        bitLen: 32,
        binary: "0x" + calculatedTag
      };
    }
    if (tag[0] == "$") {
      return {
        bitLen: (tag === null || tag === void 0 ? void 0 : tag.length) - 1,
        binary: "0b" + tag.slice(1)
      };
    }
    if (tag[0] == "#") {
      const hasTrailingUnderscore = tag.endsWith("_");
      const hexPart = tag.slice(1, hasTrailingUnderscore ? -1 : void 0);
      if (hasTrailingUnderscore) {
        const binary2 = parseInt(hexPart, 16).toString(2).padStart(hexPart.length * 4, "0");
        const truncatedBinary = binary2.slice(0, -1);
        const truncatedHex = parseInt(truncatedBinary, 2).toString(16).padStart(Math.ceil(truncatedBinary.length / 4), "0");
        return {
          bitLen: truncatedBinary.length,
          binary: "0x" + truncatedHex
        };
      }
      return {
        bitLen: hexPart.length * 4,
        binary: "0x" + hexPart
      };
    }
    throw new Error("Unknown tag " + tag);
  }
  function findConstructorsNaming(tlbType) {
    let constructorNames = /* @__PURE__ */ new Set();
    let constructorIndex = 0;
    tlbType.constructors.forEach((current) => {
      while (constructorNames.has(current.name)) {
        current.name += constructorIndex.toString();
      }
      constructorNames.add(current.name);
      constructorIndex++;
    });
  }
  function checkAndRemovePrimitives(tlbCode, _input, typeDeclarations) {
    let toDelete = [];
    let typesToDelete = /* @__PURE__ */ new Map();
    typesToDelete.set("Bool", ["b814e002", "e95dd78d"]);
    typesToDelete.set("MsgAddressInt", ["9bb90082", "ca70d9f6"]);
    typesToDelete.set("Bit", ["12acf7f6"]);
    typesToDelete.set("Grams", ["31468450"]);
    typesToDelete.set("MsgAddressExt", ["9ccb7139", "ee7b72a3"]);
    typesToDelete.set("MsgAddress", ["21d0382b", "e06aa05e"]);
    typesToDelete.set("VarUInteger", ["988e36b3"]);
    typesToDelete.set("VarInteger", ["225aaee0"]);
    typesToDelete.set("HashmapE", ["1cc05be9", "40b92161"]);
    typesToDelete.set("HashmapAugE", ["af55dae6", "e135d248"]);
    typesToDelete.set("BoolTrue", ["b5311773"]);
    typesToDelete.set("BoolFalse", ["f3214771"]);
    typesToDelete.forEach((opCodesExpected, typeName) => {
      let typeItems = typeDeclarations.get(typeName);
      if (typeItems) {
        let opCodesActual = [];
        typeItems.forEach((typeItem) => {
          opCodesActual.push(calculateTag(typeItem.declaration));
        });
        if (!(0, utils_2.opCodeSetsEqual)(opCodesExpected, opCodesActual)) {
          throw new Error("Bool primitive type is not correct in scheme");
        }
        toDelete.push(typeName);
      }
    });
    toDelete.forEach((name) => {
      tlbCode.types.delete(name);
    });
  }
  function findAvailableVarNamesForCode(tlbCode) {
    tlbCode.types.forEach((tlbType) => {
      tlbType.constructors.forEach((constructor) => {
        let variablesSet = /* @__PURE__ */ new Set();
        findAvailableFieldsNames(constructor.fields, variablesSet);
      });
    });
  }
  function findAvailableFieldsNames(fields, variablesSet) {
    fields.forEach((field) => {
      if (field.subFields.length == 0) {
        findAvailableFieldName(field, variablesSet);
      }
      findAvailableFieldsNames(field.subFields, variablesSet);
    });
  }
  function findAvailableFieldName(field, variablesSet) {
    let index = 0;
    field.name = (0, utils_1.findNotReservedName)(field.name);
    while (variablesSet.has(field.name)) {
      field.name = (0, utils_1.findNotReservedName)(field.name + "_" + index);
      index++;
    }
    variablesSet.add(field.name);
  }
  function convertCodeToReadonly(tlbCode) {
    let newTypes = /* @__PURE__ */ new Map();
    tlbCode.types.forEach((value, key2) => {
      let newConstructors = new Array();
      value.constructors.forEach((value2) => {
        let newVariablesMap = /* @__PURE__ */ new Map();
        value2.variablesMap.forEach((value3, key3) => {
          newVariablesMap.set(key3, convertVariableToReadonly(value3));
        });
        let newParametersMap = /* @__PURE__ */ new Map();
        value2.parametersMap.forEach((value3, key3) => {
          newParametersMap.set(key3, convertParameterToReadonly(value3));
        });
        let newConstructor = new ast_1.TLBConstructor(value2.parameters.map(convertParameterToReadonly), value2.variables.map(convertVariableToReadonly), newVariablesMap, newParametersMap, value2.name, value2.fields, value2.tag, value2.constraints, value2.declaration, value2.tlbType);
        newConstructors.push(newConstructor);
      });
      let newType = new ast_1.TLBType(value.name, newConstructors);
      newTypes.set(key2, newType);
    });
    return new ast_1.TLBCode(newTypes);
  }
  fill_constructors.convertCodeToReadonly = convertCodeToReadonly;
  function convertParameterToReadonly(tlbParameter) {
    return new ast_1.TLBParameter(convertVariableToReadonly(tlbParameter.variable), tlbParameter.paramExpr, tlbParameter.argName);
  }
  function convertVariableToReadonly(tlbVariable) {
    if (tlbVariable.name == void 0) {
      throw new Error("Variable is undefined");
    }
    return new ast_1.TLBVariable(tlbVariable.isConst, tlbVariable.negated, tlbVariable.type, tlbVariable.name, tlbVariable.isField, tlbVariable.deriveExpr, tlbVariable.initialExpr);
  }
  function getStringDeclaration(declaration, input) {
    var _a, _b;
    let result = "";
    let splittedInput = input;
    let currentLine = declaration.locations.line - 1;
    let currentColumn = 0;
    while (!((_a = splittedInput[currentLine]) === null || _a === void 0 ? void 0 : _a.includes(";"))) {
      result += ((_b = splittedInput[currentLine]) === null || _b === void 0 ? void 0 : _b.substring(currentColumn)) + "\n";
      currentLine++;
      currentColumn = 0;
    }
    let currentInput = splittedInput[currentLine];
    if (currentInput) {
      result += currentInput.substring(currentColumn, currentInput.indexOf(";") + 1);
    }
    return result;
  }
  function calculateVariables(constructor) {
    constructor.variables.forEach((variable) => {
      (0, utils_2.calculateVariable)(variable, constructor);
    });
    constructor.parameters.forEach((parameter) => {
      (0, utils_2.calculateVariable)(parameter.variable, constructor);
    });
  }
  const TypeGuards = {
    isFieldBuiltinDef: (field) => field instanceof tlb_parser_1.FieldBuiltinDef,
    isFieldCurlyExprDef: (field) => field instanceof tlb_parser_1.FieldCurlyExprDef,
    isFieldAnonymousDef: (field) => field instanceof tlb_parser_1.FieldAnonymousDef,
    isFieldNamedDef: (field) => field instanceof tlb_parser_1.FieldNamedDef,
    isFieldExprDef: (field) => field instanceof tlb_parser_1.FieldExprDef,
    isCompareExpr: (expr) => expr instanceof tlb_parser_1.CompareExpr,
    isMathExpr: (expr) => expr instanceof tlb_parser_1.MathExpr,
    isNegateExpr: (expr) => expr instanceof tlb_parser_1.NegateExpr,
    isNameExpr: (expr) => expr instanceof tlb_parser_1.NameExpr,
    isNumberExpr: (expr) => expr instanceof tlb_parser_1.NumberExpr,
    isCellRefExpr: (expr) => expr instanceof tlb_parser_1.CellRefExpr,
    isBuiltinZeroArgs: (expr) => expr instanceof tlb_parser_1.BuiltinZeroArgs,
    isBuiltinOneArgExpr: (expr) => expr instanceof tlb_parser_1.BuiltinOneArgExpr,
    isCombinatorExpr: (expr) => expr instanceof tlb_parser_1.CombinatorExpr,
    isCondExpr: (expr) => expr instanceof tlb_parser_1.CondExpr
  };
  function calculateTag(declaration) {
    const formattedDeclaration = formatDeclaration(declaration);
    const encoder = new TextEncoder();
    return (0, utils_1.crc32)(encoder.encode(formattedDeclaration)).toString(16);
  }
  function isImplicitOrConstraint(field) {
    const { isFieldBuiltinDef, isFieldCurlyExprDef, isFieldNamedDef, isFieldExprDef, isCompareExpr } = TypeGuards;
    if (isFieldBuiltinDef(field) || isFieldCurlyExprDef(field)) {
      return true;
    }
    if ((isFieldNamedDef(field) || isFieldExprDef(field)) && isCompareExpr(field.expr) && field.expr.op === "=") {
      return true;
    }
    return false;
  }
  function formatDeclaration(declaration) {
    const parts = [declaration.constructorDef.name];
    declaration.fields.forEach((field) => {
      parts.push(formatField(field));
    });
    parts.push("=", declaration.combinator.name);
    declaration.combinator.args.forEach((arg) => {
      parts.push(formatExpression(arg));
    });
    return parts.join(" ");
  }
  function formatField(field) {
    const { isFieldBuiltinDef, isFieldCurlyExprDef, isFieldNamedDef, isFieldExprDef, isFieldAnonymousDef } = TypeGuards;
    const parts = [];
    if (isImplicitOrConstraint(field)) {
      if (isFieldBuiltinDef(field) || isFieldNamedDef(field) || isFieldAnonymousDef(field) && field.name) {
        parts.push(`${field.name}:`);
      }
      if (isFieldBuiltinDef(field)) {
        parts.push(field.type);
      } else if (isFieldCurlyExprDef(field)) {
        parts.push(formatExpression(field.expr));
      } else if (isFieldNamedDef(field)) {
        parts.push(formatExpression(field.expr));
      } else if (isFieldExprDef(field)) {
        parts.push(formatExpression(field.expr));
      } else if (isFieldAnonymousDef(field)) {
        parts.push(formatAnonymousField(field));
      }
      return parts.join("");
    }
    if (isFieldNamedDef(field)) {
      parts.push(`${field.name}:`);
    } else if (isFieldAnonymousDef(field) && field.name) {
      parts.push(`${field.name}:`);
    }
    if (isFieldNamedDef(field)) {
      parts.push(formatExpression(field.expr));
    } else if (isFieldExprDef(field)) {
      parts.push(formatExpression(field.expr));
    } else if (isFieldAnonymousDef(field)) {
      parts.push(formatAnonymousField(field));
    }
    return parts.join("");
  }
  function formatAnonymousField(field) {
    const innerFields = field.fields.map((innerField, index) => index > 0 ? " " + formatField(innerField) : formatField(innerField)).join("");
    return `${field.isRef ? "^[ " : "[ "}${innerFields} ]`;
  }
  function formatExpression(expr) {
    const { isCompareExpr, isMathExpr, isNegateExpr, isNameExpr, isNumberExpr, isCellRefExpr, isBuiltinZeroArgs, isBuiltinOneArgExpr, isCombinatorExpr, isCondExpr } = TypeGuards;
    if (isCompareExpr(expr)) {
      return `${expr.op} ${formatExpression(expr.left)} ${formatExpression(expr.right)}`;
    }
    if (isMathExpr(expr)) {
      return formatMathExpr(expr);
    }
    if (isNegateExpr(expr)) {
      return "~" + formatExpression(expr.expr);
    }
    if (isNumberExpr(expr)) {
      return String(expr.num);
    }
    if (isNameExpr(expr)) {
      return expr.name;
    }
    if (isCellRefExpr(expr)) {
      return "^" + formatExpression(expr.expr);
    }
    if (isBuiltinZeroArgs(expr)) {
      return expr.name;
    }
    if (isBuiltinOneArgExpr(expr)) {
      return `${expr.name} ${formatExpression(expr.arg)}`;
    }
    if (isCombinatorExpr(expr)) {
      const args = expr.args.map((arg) => formatExpression(arg)).join(" ");
      return `${expr.name} ${args}`;
    }
    if (isCondExpr(expr)) {
      let result = formatExpression(expr.left);
      if (expr.dotExpr !== null) {
        result += "." + expr.dotExpr;
      }
      result += "?" + formatExpression(expr.condExpr);
      return result;
    }
    return String(expr);
  }
  function formatMathExpr(expr) {
    const { isNumberExpr } = TypeGuards;
    if (expr.op === "+") {
      return `${formatExpression(expr.left)} + ${formatExpression(expr.right)}`;
    }
    if (expr.op === "*") {
      if (isNumberExpr(expr.right) && !isNumberExpr(expr.left)) {
        return `${formatExpression(expr.right)} * ${formatExpression(expr.left)}`;
      }
      if (isNumberExpr(expr.left) && isNumberExpr(expr.right)) {
        return String(expr.left.num * expr.right.num);
      }
      return `${formatExpression(expr.left)} * ${formatExpression(expr.right)}`;
    }
    return `${formatExpression(expr.left)} ${expr.op} ${formatExpression(expr.right)}`;
  }
  return fill_constructors;
}
var CodeBuilder = {};
var hasRequiredCodeBuilder;
function requireCodeBuilder() {
  if (hasRequiredCodeBuilder) return CodeBuilder;
  hasRequiredCodeBuilder = 1;
  Object.defineProperty(CodeBuilder, "__esModule", { value: true });
  CodeBuilder.CodeBuilder = void 0;
  let CodeBuilder$1 = class CodeBuilder {
    constructor() {
      this.tabLevel = 0;
      this.code = "";
    }
    tab() {
      this.tabLevel++;
    }
    unTab() {
      this.tabLevel--;
    }
    inTab(callback) {
      this.tab();
      callback();
      this.unTab();
    }
    add(text, moveLine = true) {
      if (!text) {
        this.code += "\n";
        return;
      }
      let tab = " ".repeat(this.tabLevel * 4);
      this.code += tab + text + (moveLine ? "\n" : "");
    }
    addMultiline(text, inline = false) {
      let lines = text.split("\n");
      let i = 0;
      for (let line of lines) {
        if (line === "\n" && lines.indexOf(line) === lines.length - 1) {
          continue;
        }
        if (inline && i === 0) {
          this.code += line + "\n";
        } else {
          this.add(line);
        }
        i++;
      }
    }
    append(code) {
      this.addMultiline(code.render());
    }
    appendInline(code) {
      this.addMultiline(code.render(), true);
    }
    render() {
      return this.code;
    }
  };
  CodeBuilder.CodeBuilder = CodeBuilder$1;
  return CodeBuilder;
}
var generator = {};
var complex_expr = {};
var tsgen = {};
var hasRequiredTsgen;
function requireTsgen() {
  if (hasRequiredTsgen) return tsgen;
  hasRequiredTsgen = 1;
  Object.defineProperty(tsgen, "__esModule", { value: true });
  tsgen.id = tsgen.toCode = tsgen.tCodeAsIs = tsgen.tTernaryExpression = tsgen.tComment = tsgen.tMultiStatement = tsgen.tDeclareVariable = tsgen.tArrowFunctionType = tsgen.tBinaryExpression = tsgen.tUnaryOpExpression = tsgen.tIfStatement = tsgen.tExpressionStatement = tsgen.tUnionTypeDeclaration = tsgen.tArrowFunctionExpression = tsgen.tUnionTypeExpression = tsgen.tTypeParametersExpression = tsgen.tBinaryNumericLiteral = tsgen.tNumericLiteral = tsgen.tMemberExpression = tsgen.tFunctionCall = tsgen.tReturnStatement = tsgen.tStructExpression = tsgen.tObjectExpression = tsgen.tForCycle = tsgen.tObjectProperty = tsgen.tStructDeclaration = tsgen.tTypeWithParameters = tsgen.tTypedIdentifier = tsgen.tFunctionDeclaration = tsgen.tImportDeclaration = tsgen.tStringLiteral = tsgen.tIdentifier = void 0;
  const CodeBuilder_1 = requireCodeBuilder();
  function tIdentifier(name) {
    return { type: "Identifier", name };
  }
  tsgen.tIdentifier = tIdentifier;
  function tStringLiteral(value) {
    return { type: "StringLiteral", value };
  }
  tsgen.tStringLiteral = tStringLiteral;
  function tImportDeclaration(importValue, from) {
    return { type: "ImportDeclaration", importValue, from };
  }
  tsgen.tImportDeclaration = tImportDeclaration;
  function tFunctionDeclaration(name, typeParameters, returnType, parameters, body) {
    return {
      type: "FunctionDeclaration",
      name,
      typeParameters,
      returnType,
      parameters,
      body
    };
  }
  tsgen.tFunctionDeclaration = tFunctionDeclaration;
  function tTypedIdentifier(name, typeId, optional = false) {
    return { type: "TypedIdentifier", name, typeId, optional };
  }
  tsgen.tTypedIdentifier = tTypedIdentifier;
  function tTypeWithParameters(name, typeParameters) {
    return {
      type: "TypeWithParameters",
      name,
      typeParameters
    };
  }
  tsgen.tTypeWithParameters = tTypeWithParameters;
  function tStructDeclaration(name, fields, typeParameters) {
    return {
      type: "StructDeclaration",
      name,
      fields,
      typeParametersExpression: typeParameters
    };
  }
  tsgen.tStructDeclaration = tStructDeclaration;
  function tObjectProperty(key2, value) {
    return { type: "ObjectProperty", key: key2, value };
  }
  tsgen.tObjectProperty = tObjectProperty;
  function tForCycle(init, cond, inc, body) {
    return { type: "ForCycle", init, cond, inc, body };
  }
  tsgen.tForCycle = tForCycle;
  function tObjectExpression(objectValues) {
    return { type: "ObjectExpression", objectValues };
  }
  tsgen.tObjectExpression = tObjectExpression;
  function tStructExpression(fields) {
    return { type: "StructExpression", fields };
  }
  tsgen.tStructExpression = tStructExpression;
  function tReturnStatement(returnValue) {
    return { type: "ReturnStatement", returnValue };
  }
  tsgen.tReturnStatement = tReturnStatement;
  function tFunctionCall(functionId, parameters, typeParameters) {
    return {
      type: "FunctionCall",
      functionId,
      parameters,
      typeParameters
    };
  }
  tsgen.tFunctionCall = tFunctionCall;
  function tMemberExpression(thisObject, memberName) {
    return {
      type: "MemberExpression",
      thisObject,
      memberName
    };
  }
  tsgen.tMemberExpression = tMemberExpression;
  function tNumericLiteral(value) {
    return { type: "NumericLiteral", value };
  }
  tsgen.tNumericLiteral = tNumericLiteral;
  function tBinaryNumericLiteral(value) {
    return { type: "BinaryNumericLiteral", value };
  }
  tsgen.tBinaryNumericLiteral = tBinaryNumericLiteral;
  function tTypeParametersExpression(typeParameters) {
    return { type: "TypeParametersExpression", typeParameters };
  }
  tsgen.tTypeParametersExpression = tTypeParametersExpression;
  function tUnionTypeExpression(unionMembers) {
    return { type: "UnionTypeExpression", unionMembers };
  }
  tsgen.tUnionTypeExpression = tUnionTypeExpression;
  function tArrowFunctionExpression(parameters, body) {
    return {
      type: "ArrowFunctionExpression",
      parameters,
      body
    };
  }
  tsgen.tArrowFunctionExpression = tArrowFunctionExpression;
  function tUnionTypeDeclaration(name, union) {
    return { type: "UnionTypeDeclaration", name, union };
  }
  tsgen.tUnionTypeDeclaration = tUnionTypeDeclaration;
  function tExpressionStatement(expression) {
    return { type: "ExpressionStatement", expression };
  }
  tsgen.tExpressionStatement = tExpressionStatement;
  function tIfStatement(condition, body, elseBody) {
    return {
      type: "IfStatement",
      condition,
      body,
      elseBody
    };
  }
  tsgen.tIfStatement = tIfStatement;
  function tUnaryOpExpression(unaryOperator, expr) {
    return {
      type: "UnaryOpExpression",
      unaryOperator,
      expr
    };
  }
  tsgen.tUnaryOpExpression = tUnaryOpExpression;
  function tBinaryExpression(left, binarySign, right) {
    return {
      type: "BinaryExpression",
      binarySign,
      left,
      right
    };
  }
  tsgen.tBinaryExpression = tBinaryExpression;
  function tArrowFunctionType(parameters, returnType) {
    return {
      type: "ArrowFunctionType",
      parameters,
      returnType
    };
  }
  tsgen.tArrowFunctionType = tArrowFunctionType;
  function tDeclareVariable(name, init, typeName) {
    return {
      type: "DeclareVariable",
      name,
      init,
      typeName
    };
  }
  tsgen.tDeclareVariable = tDeclareVariable;
  function tMultiStatement(statements) {
    return { type: "MultiStatement", statements };
  }
  tsgen.tMultiStatement = tMultiStatement;
  function tComment(value) {
    return { type: "Comment", value };
  }
  tsgen.tComment = tComment;
  function tTernaryExpression(condition, body, elseBody) {
    return {
      type: "TernaryExpression",
      condition,
      body,
      elseBody
    };
  }
  tsgen.tTernaryExpression = tTernaryExpression;
  function tCodeAsIs(code) {
    return { type: "CodeAsIs", code };
  }
  tsgen.tCodeAsIs = tCodeAsIs;
  function toCodeArray(nodeArray, code, delimeter) {
    for (let i = 0; i < nodeArray.length; i++) {
      let currentParam = nodeArray[i];
      if (currentParam != void 0) {
        toCode(currentParam, code);
      }
      if (i + 1 < nodeArray.length) {
        code.add(delimeter, false);
      }
    }
    return code;
  }
  function toCode(node, code = new CodeBuilder_1.CodeBuilder()) {
    if (node.type == "Identifier") {
      code.add(node.name, false);
    }
    if (node.type == "NumericLiteral") {
      code.add(node.value.toString(), false);
    }
    if (node.type == "ImportDeclaration") {
      code.add(`import { ${toCode(node.importValue).render()} } from ${toCode(node.from).render()}`, false);
    }
    if (node.type == "FunctionDeclaration") {
      code.add(`export function ${toCode(node.name).render()}${toCode(node.typeParameters).render()}(`, false);
      toCodeArray(node.parameters, code, ", ");
      code.add(`)${node.returnType ? ": " + toCode(node.returnType).render() : ""} {`);
      code.inTab(() => {
        node.body.forEach((statement) => {
          code.append(toCode(statement));
        });
      });
      code.add("}");
    }
    if (node.type == "ArrowFunctionExpression") {
      code.add(`((`, false);
      toCodeArray(node.parameters, code, ", ");
      code.add(`) => {`);
      code.inTab(() => {
        node.body.forEach((statement) => {
          code.append(toCode(statement));
        });
      });
      code.add(`})`, false);
    }
    if (node.type == "ArrowFunctionType") {
      code.add(`(${toCodeArray(node.parameters, new CodeBuilder_1.CodeBuilder(), ", ").render()}) => ${node.returnType ? toCode(node.returnType).render() : ""}`, false);
    }
    if (node.type == "TypeWithParameters") {
      code.add(`${toCode(node.name).render()}${toCode(node.typeParameters).render()}`, false);
    }
    if (node.type == "TypedIdentifier") {
      code.add(toCode(node.name).render() + (node.optional ? "?" : "") + ": " + toCode(node.typeId).render(), false);
    }
    if (node.type == "ObjectProperty") {
      code.add(toCode(node.key).render() + ": " + toCode(node.value).render(), false);
    }
    if (node.type == "DeclareVariable") {
      code.add(`let ${toCode(node.name).render()}${node.typeName ? ": " + toCode(node.typeName).render() : ""}`, false);
      if (node.init) {
        code.add(" = ", false);
        toCode(node.init, code);
      }
    }
    if (node.type == "ObjectExpression") {
      code.add("{");
      code.inTab(() => {
        node.objectValues.forEach((objectValue) => {
          code.add(toCode(objectValue).render() + ",");
        });
      });
      code.add("}", false);
    }
    if (node.type == "StructExpression") {
      code.add("{", false);
      toCodeArray(node.fields, code, ", ");
      code.add("}", false);
    }
    if (node.type == "MultiStatement") {
      node.statements.forEach((statement) => {
        code.append(toCode(statement));
      });
    }
    if (node.type == "ReturnStatement") {
      code.add(`return `, false);
      code.appendInline(toCode(node.returnValue));
    }
    if (node.type == "ExpressionStatement") {
      code.add(toCode(node.expression).render() + ";", false);
    }
    if (node.type == "TypeParametersExpression") {
      if (node.typeParameters.length > 0) {
        code.add("<", false);
        toCodeArray(node.typeParameters, code, ", ");
        code.add(">", false);
      }
    }
    if (node.type == "StructDeclaration") {
      code.add(`export interface ${toCode(node.name).render()}${toCode(node.typeParametersExpression).render()} {`);
      code.inTab(() => {
        node.fields.forEach((field) => {
          code.add(`readonly ${toCode(field).render()};`);
        });
      });
      code.add("}");
    }
    if (node.type == "UnionTypeDeclaration") {
      code.add(`export type ${toCode(node.name).render()} = ${toCode(node.union).render()};`);
    }
    if (node.type == "UnionTypeExpression") {
      toCodeArray(node.unionMembers, code, " | ");
    }
    if (node.type == "FunctionCall") {
      code.add(`${toCode(node.functionId).render()}${node.typeParameters ? toCode(node.typeParameters).render() : ""}(`, false);
      toCodeArray(node.parameters, code, ", ");
      code.add(`)`, false);
    }
    if (node.type == "StringLiteral") {
      code.add(`'${node.value}'`, false);
    }
    if (node.type == "MemberExpression") {
      code.add(toCode(node.thisObject).render() + "." + toCode(node.memberName).render(), false);
    }
    if (node.type == "IfStatement") {
      code.add(`if (${toCode(node.condition).render()}) {`);
      code.inTab(() => {
        node.body.forEach((statement) => {
          code.append(toCode(statement));
        });
      });
      code.add("}", false);
    }
    if (node.type == "ForCycle") {
      code.add(`for (${toCode(node.init).render()};${toCode(node.cond).render()};${toCode(node.inc).render()}) {`);
      code.inTab(() => {
        node.body.forEach((statement) => {
          code.append(toCode(statement));
        });
      });
      code.add(`}`, false);
    }
    if (node.type == "UnaryOpExpression") {
      code.add(`(${node.unaryOperator}${toCode(node.expr).render()})`, false);
    }
    if (node.type == "BinaryExpression") {
      code.add(`(${toCode(node.left).render()} ${node.binarySign} ${toCode(node.right).render()})`, false);
    }
    if (node.type == "TernaryExpression") {
      code.add(`(${toCode(node.condition).render()} ? ${toCode(node.body).render()} : ${toCode(node.elseBody).render()})`, false);
    }
    if (node.type == "Comment") {
      let splittedComment = node.value.split("\n");
      if (splittedComment.length == 1) {
        code.add(`// ${splittedComment[0]}`);
      } else {
        code.add(`/*`);
        splittedComment.forEach((line) => {
          code.add(line);
        });
        code.add(`*/`);
      }
    }
    if (node.type == "CodeAsIs") {
      code.add(node.code, false);
    }
    return code;
  }
  tsgen.toCode = toCode;
  tsgen.id = tIdentifier;
  return tsgen;
}
var utils$2 = {};
var hasRequiredUtils$2;
function requireUtils$2() {
  if (hasRequiredUtils$2) return utils$2;
  hasRequiredUtils$2 = 1;
  Object.defineProperty(utils$2, "__esModule", { value: true });
  utils$2.useBuffer = utils$2.isBigInt = utils$2.isBigIntExpr = utils$2.getCondition = utils$2.getTypeParametersExpression = utils$2.convertToAST = utils$2.addLoadProperty = utils$2.getNegationDerivationFunctionBody = utils$2.getVarExprByName = utils$2.getParamVarExpr = void 0;
  const ast_1 = requireAst();
  const utils_1 = requireUtils$4();
  const complex_expr_1 = requireComplex_expr();
  const tsgen_1 = requireTsgen();
  function getParamVarExpr(param, constructor) {
    if (param.variable.deriveExpr) {
      return convertToAST(param.variable.deriveExpr, constructor);
    } else {
      throw new Error(`Could not get expression for param ${param.variable.name} for constructor ${constructor.name} of type ${constructor.tlbType}`);
    }
  }
  utils$2.getParamVarExpr = getParamVarExpr;
  function getVarExprByName(name, constructor) {
    let variable = constructor.variablesMap.get(name);
    if (variable === null || variable === void 0 ? void 0 : variable.deriveExpr) {
      return convertToAST(variable.deriveExpr, constructor);
    }
    return (0, tsgen_1.id)(name);
  }
  utils$2.getVarExprByName = getVarExprByName;
  function getNegationDerivationFunctionBody(tlbCode, typeName, parameterIndex, parameterName) {
    let result = [];
    let tlbType = tlbCode.types.get(typeName);
    if (!tlbType) {
      throw new Error(`Can not find type ${typeName}`);
    }
    tlbType.constructors.forEach((constructor) => {
      let parameter = constructor.parameters[parameterIndex];
      if (parameter) {
        let getExpression;
        getExpression = convertToAST(parameter.paramExpr, constructor);
        let statements = [];
        if (!parameter.variable.isConst) {
          statements.push((0, tsgen_1.tExpressionStatement)((0, tsgen_1.tDeclareVariable)((0, tsgen_1.id)(parameter.variable.name), (0, tsgen_1.tMemberExpression)((0, tsgen_1.id)(parameterName), (0, tsgen_1.id)(parameter.variable.name)))));
        }
        statements.push((0, tsgen_1.tReturnStatement)(getExpression));
        if (tlbType) {
          result.push((0, tsgen_1.tIfStatement)((0, complex_expr_1.tEqualExpression)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)(parameterName), (0, tsgen_1.id)("kind")), (0, tsgen_1.tStringLiteral)((0, utils_1.getSubStructName)(tlbType, constructor))), statements));
        }
      }
    });
    let exceptionTypesComment = tlbType.constructors.map((constructor) => {
      return `"${tlbType ? (0, utils_1.getSubStructName)(tlbType, constructor) : ""}"`;
    }).join(", ");
    let exceptionComment = (0, tsgen_1.tExpressionStatement)((0, tsgen_1.id)(`throw new Error('Expected one of ${exceptionTypesComment} for type "${tlbType.name}" while getting "${parameterName}", but data does not satisfy any constructor')`));
    result.push(exceptionComment);
    return result;
  }
  utils$2.getNegationDerivationFunctionBody = getNegationDerivationFunctionBody;
  function addLoadProperty(name, loadExpr, typeExpr, ctx) {
    let nameId = (0, tsgen_1.id)(name);
    ctx.loadStatements.push((0, tsgen_1.tExpressionStatement)((0, tsgen_1.tDeclareVariable)(nameId, loadExpr, typeExpr)));
    ctx.loadProperties.push((0, tsgen_1.tObjectProperty)(nameId, nameId));
  }
  utils$2.addLoadProperty = addLoadProperty;
  function convertToAST(mathExpr, constructor, objectId) {
    if (mathExpr instanceof ast_1.TLBVarExpr) {
      let varName = mathExpr.x;
      if (objectId != void 0) {
        return (0, tsgen_1.tMemberExpression)(objectId, (0, tsgen_1.id)(varName));
      }
      return (0, tsgen_1.id)(varName);
    }
    if (mathExpr instanceof ast_1.TLBNumberExpr) {
      return (0, tsgen_1.tNumericLiteral)(mathExpr.n);
    }
    if (mathExpr instanceof ast_1.TLBBinaryOp) {
      let operation = mathExpr.operation;
      if (operation == "=") {
        operation = "==";
      }
      return (0, tsgen_1.tBinaryExpression)(convertToAST(mathExpr.left, constructor, objectId), operation, convertToAST(mathExpr.right, constructor, objectId));
    }
    if (mathExpr instanceof ast_1.TLBUnaryOp) {
      if (mathExpr.operation == ".") {
        return (0, tsgen_1.tFunctionCall)((0, tsgen_1.id)("bitLen"), [convertToAST(mathExpr.value, constructor, objectId)]);
      }
      return (0, tsgen_1.tUnaryOpExpression)(mathExpr.operation, convertToAST(mathExpr.value, constructor, objectId));
    }
    throw new Error(`Type ${constructor.tlbType}, constructor ${constructor.name}: couldn't convert to math expression: ${mathExpr}`);
  }
  utils$2.convertToAST = convertToAST;
  function getTypeParametersExpression(parameters) {
    let structTypeParameters = [];
    parameters.forEach((element) => {
      if (element.variable.type == "Type") {
        structTypeParameters.push((0, tsgen_1.id)(element.variable.name));
      }
    });
    let structTypeParametersExpr = (0, tsgen_1.tTypeParametersExpression)(structTypeParameters);
    return structTypeParametersExpr;
  }
  utils$2.getTypeParametersExpression = getTypeParametersExpression;
  function getCondition(conditions) {
    let cnd = conditions[0];
    if (cnd) {
      if (conditions.length > 1) {
        return (0, tsgen_1.tBinaryExpression)(cnd, "&&", getCondition(conditions.slice(1)));
      } else {
        return cnd;
      }
    } else {
      return (0, tsgen_1.id)("true");
    }
  }
  utils$2.getCondition = getCondition;
  function isBigIntExpr(fieldType) {
    if (fieldType.expr instanceof ast_1.TLBNumberExpr && fieldType.expr.n <= 32) {
      return false;
    }
    return true;
  }
  utils$2.isBigIntExpr = isBigIntExpr;
  function isBigInt(fieldType) {
    if (fieldType.bits instanceof ast_1.TLBNumberExpr) {
      if (fieldType.bits.n <= 32) {
        return false;
      }
    }
    if (fieldType.maxBits && fieldType.maxBits <= 32) {
      return false;
    }
    return true;
  }
  utils$2.isBigInt = isBigInt;
  function useBuffer(bitsType) {
    if (bitsType.bits instanceof ast_1.TLBNumberExpr && bitsType.bits.n % 8 == 0) {
      return true;
    }
    return false;
  }
  utils$2.useBuffer = useBuffer;
  return utils$2;
}
var hasRequiredComplex_expr;
function requireComplex_expr() {
  if (hasRequiredComplex_expr) return complex_expr;
  hasRequiredComplex_expr = 1;
  Object.defineProperty(complex_expr, "__esModule", { value: true });
  complex_expr.dictAugTypeExpr = complex_expr.dictAugParse = complex_expr.dictKeyExpr = complex_expr.dictLoadExpr = complex_expr.dictValueStore = complex_expr.dictTypeParamExpr = complex_expr.dictStoreStmt = complex_expr.negationDerivationFuncDecl = complex_expr.inSeparateRef = complex_expr.checkConstraintStmt = complex_expr.newCellStmt = complex_expr.storeRefStmt = complex_expr.loadRefStmt = complex_expr.storeRefObjectStmt = complex_expr.storeExpressionNamedType = complex_expr.storeExprCond = complex_expr.loadTupleExpr = complex_expr.storeTupleStmt = complex_expr.arrayedType = complex_expr.loadFromNewSlice = complex_expr.storeInNewCell = complex_expr.storeCombinator = complex_expr.loadExprForParam = complex_expr.returnSliceFunc = complex_expr.storeExprForParam = complex_expr.coverFuncCall = complex_expr.storeFunctionExpr = complex_expr.checkHasBitsForTag = complex_expr.checkTagExpr = complex_expr.skipTagStmt = complex_expr.loadFunctionParam = complex_expr.storeFunctionParam = complex_expr.simpleCycle = complex_expr.sliceLoad = complex_expr.typedSlice = complex_expr.bitlenFunctionDecl = complex_expr.checkKindStmt = complex_expr.storeFunctionStmt = complex_expr.storeTagExpression = complex_expr.tEqualExpression = void 0;
  const utils_1 = requireUtils$4();
  const tsgen_1 = requireTsgen();
  const utils_2 = requireUtils$2();
  function tEqualExpression(left, right) {
    return (0, tsgen_1.tBinaryExpression)(left, "==", right);
  }
  complex_expr.tEqualExpression = tEqualExpression;
  function storeTagExpression(tag) {
    return (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)("builder"), (0, tsgen_1.id)("storeUint")), [(0, tsgen_1.id)(tag.binary), (0, tsgen_1.tNumericLiteral)(tag.bitLen)]));
  }
  complex_expr.storeTagExpression = storeTagExpression;
  function storeFunctionStmt(statements) {
    return (0, tsgen_1.tReturnStatement)((0, tsgen_1.tArrowFunctionExpression)([(0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("builder"), (0, tsgen_1.id)("Builder"))], statements));
  }
  complex_expr.storeFunctionStmt = storeFunctionStmt;
  function checkKindStmt(variableCombinatorName, constructorTypeName, storeStatement) {
    return (0, tsgen_1.tIfStatement)(tEqualExpression((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)(variableCombinatorName), (0, tsgen_1.id)("kind")), (0, tsgen_1.tStringLiteral)(constructorTypeName)), [storeStatement]);
  }
  complex_expr.checkKindStmt = checkKindStmt;
  function bitlenFunctionDecl() {
    return (0, tsgen_1.tFunctionDeclaration)((0, tsgen_1.id)("bitLen"), (0, tsgen_1.tTypeParametersExpression)([]), null, [(0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("n"), (0, tsgen_1.id)("number"))], [(0, tsgen_1.tExpressionStatement)((0, tsgen_1.id)("return n.toString(2).length"))]);
  }
  complex_expr.bitlenFunctionDecl = bitlenFunctionDecl;
  function typedSlice() {
    return [(0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("slice"), (0, tsgen_1.id)("Slice"))];
  }
  complex_expr.typedSlice = typedSlice;
  function sliceLoad(slicePrefix, currentSlice) {
    return (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tDeclareVariable)((0, tsgen_1.id)((0, utils_1.getCurrentSlice)(slicePrefix, "slice")), (0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)(currentSlice), (0, tsgen_1.id)("loadRef")), []), (0, tsgen_1.id)("beginParse")), [(0, tsgen_1.id)("true")])));
  }
  complex_expr.sliceLoad = sliceLoad;
  function simpleCycle(varName, finish) {
    return (0, tsgen_1.tForCycle)((0, tsgen_1.tDeclareVariable)((0, tsgen_1.id)(varName), (0, tsgen_1.tNumericLiteral)(0)), (0, tsgen_1.tBinaryExpression)((0, tsgen_1.id)(varName), "<", finish), (0, tsgen_1.tNumericLiteral)(5), []);
  }
  complex_expr.simpleCycle = simpleCycle;
  function storeFunctionParam(varName) {
    return (0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("store" + varName), (0, tsgen_1.tArrowFunctionType)([(0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)((0, utils_1.firstLower)(varName)), (0, tsgen_1.id)(varName))], (0, tsgen_1.tArrowFunctionType)([(0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("builder"), (0, tsgen_1.id)("Builder"))], (0, tsgen_1.id)("void"))));
  }
  complex_expr.storeFunctionParam = storeFunctionParam;
  function loadFunctionParam(varName) {
    return (0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("load" + varName), (0, tsgen_1.tArrowFunctionType)(typedSlice(), (0, tsgen_1.id)(varName)));
  }
  complex_expr.loadFunctionParam = loadFunctionParam;
  function skipTagStmt(bitLen) {
    return (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)("slice"), (0, tsgen_1.id)("loadUint")), [(0, tsgen_1.tNumericLiteral)(bitLen)]));
  }
  complex_expr.skipTagStmt = skipTagStmt;
  function checkTagExpr(tag) {
    return tEqualExpression((0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)("slice"), (0, tsgen_1.id)("preloadUint")), [(0, tsgen_1.tNumericLiteral)(tag.bitLen)]), (0, tsgen_1.id)(tag.binary));
  }
  complex_expr.checkTagExpr = checkTagExpr;
  function checkHasBitsForTag(bitLen) {
    return (0, tsgen_1.tBinaryExpression)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)("slice"), (0, tsgen_1.id)("remainingBits")), ">=", (0, tsgen_1.tNumericLiteral)(bitLen));
  }
  complex_expr.checkHasBitsForTag = checkHasBitsForTag;
  function storeFunctionExpr(typeParamExpr, storeExpr2) {
    return (0, tsgen_1.tArrowFunctionExpression)([(0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("arg"), typeParamExpr)], [(0, tsgen_1.tReturnStatement)((0, tsgen_1.tArrowFunctionExpression)([(0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("builder"), (0, tsgen_1.id)("Builder"))], [storeExpr2]))]);
  }
  complex_expr.storeFunctionExpr = storeFunctionExpr;
  function coverFuncCall(loadExpr) {
    return loadExpr.type == "FunctionCall" ? (0, tsgen_1.tArrowFunctionExpression)(typedSlice(), [(0, tsgen_1.tReturnStatement)(loadExpr)]) : loadExpr;
  }
  complex_expr.coverFuncCall = coverFuncCall;
  function storeExprForParam(theCell, exprForParam, insideStoreParameters) {
    return (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)(theCell), (0, tsgen_1.id)("store" + exprForParam.fieldStoreSuffix)), insideStoreParameters));
  }
  complex_expr.storeExprForParam = storeExprForParam;
  function returnSliceFunc() {
    return (0, tsgen_1.tArrowFunctionExpression)(typedSlice(), [
      (0, tsgen_1.tReturnStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)("slice"), (0, tsgen_1.id)("asCell")), []))
    ]);
  }
  complex_expr.returnSliceFunc = returnSliceFunc;
  function loadExprForParam(currentSlice, exprForParam) {
    return (0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)(currentSlice), (0, tsgen_1.id)("load" + exprForParam.fieldLoadSuffix)), exprForParam.argLoadExpr ? [exprForParam.argLoadExpr] : []);
  }
  complex_expr.loadExprForParam = loadExprForParam;
  function storeCombinator(typeName, insideStoreParameters, storeFunctionsArray, currentTypeParameters, theCell) {
    return (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tFunctionCall)((0, tsgen_1.id)("store" + typeName), insideStoreParameters.concat(storeFunctionsArray), currentTypeParameters), [(0, tsgen_1.id)(theCell)]));
  }
  complex_expr.storeCombinator = storeCombinator;
  function storeInNewCell(currentCell, storeExpr) {
    return (0, tsgen_1.tMultiStatement)([
      (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tDeclareVariable)((0, tsgen_1.id)(currentCell), (0, tsgen_1.tFunctionCall)((0, tsgen_1.id)("beginCell"), []))),
      storeExpr,
      (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)("builder"), (0, tsgen_1.id)("storeRef")), [(0, tsgen_1.id)(currentCell)]))
    ]);
  }
  complex_expr.storeInNewCell = storeInNewCell;
  function loadFromNewSlice(loadExpr) {
    return (0, tsgen_1.tArrowFunctionExpression)(typedSlice(), [sliceLoad([1, 0], "slice"), (0, tsgen_1.tReturnStatement)(loadExpr)]);
  }
  complex_expr.loadFromNewSlice = loadFromNewSlice;
  function arrayedType(typeParamExpr) {
    return (0, tsgen_1.tTypeWithParameters)((0, tsgen_1.id)("Array"), (0, tsgen_1.tTypeParametersExpression)([typeParamExpr]));
  }
  complex_expr.arrayedType = arrayedType;
  function storeTupleStmt(currentParam, storeExpr, typeParamExpr) {
    return (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)(currentParam, (0, tsgen_1.id)("forEach")), [
      (0, tsgen_1.tArrowFunctionExpression)([(0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("arg"), typeParamExpr)], [storeExpr])
    ]));
  }
  complex_expr.storeTupleStmt = storeTupleStmt;
  function loadTupleExpr(arrayLength, loadExpr) {
    return (0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)("Array"), (0, tsgen_1.id)("from")), [
      (0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.tFunctionCall)((0, tsgen_1.id)("Array"), [arrayLength]), (0, tsgen_1.id)("keys")), [])
    ]), (0, tsgen_1.id)("map")), [(0, tsgen_1.tArrowFunctionExpression)([(0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("arg"), (0, tsgen_1.id)("number"))], [(0, tsgen_1.tReturnStatement)(loadExpr)])]);
  }
  complex_expr.loadTupleExpr = loadTupleExpr;
  function storeExprCond(currentParam, storeExpr) {
    return (0, tsgen_1.tIfStatement)((0, tsgen_1.tBinaryExpression)(currentParam, "!=", (0, tsgen_1.id)("undefined")), [storeExpr]);
  }
  complex_expr.storeExprCond = storeExprCond;
  function storeExpressionNamedType(typeName, insideStoreParameters, currentCell) {
    return (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tFunctionCall)((0, tsgen_1.id)("store" + typeName), insideStoreParameters), [(0, tsgen_1.id)(currentCell)]));
  }
  complex_expr.storeExpressionNamedType = storeExpressionNamedType;
  function storeRefObjectStmt(currentCell, ctx, field) {
    return (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)(currentCell), (0, tsgen_1.id)("storeRef")), [
      (0, tsgen_1.tMemberExpression)((0, tsgen_1.id)(ctx.typeName), (0, tsgen_1.id)(field.name))
    ]));
  }
  complex_expr.storeRefObjectStmt = storeRefObjectStmt;
  function loadRefStmt(slicePrefix, currentSlice) {
    return (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tDeclareVariable)((0, tsgen_1.id)((0, utils_1.getCurrentSlice)(slicePrefix, "cell")), (0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)(currentSlice), (0, tsgen_1.id)("loadRef")), [])));
  }
  complex_expr.loadRefStmt = loadRefStmt;
  function storeRefStmt(slicePrefix, currentCell) {
    return (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)(currentCell), (0, tsgen_1.id)("storeRef")), [(0, tsgen_1.id)((0, utils_1.getCurrentSlice)(slicePrefix, "cell"))]));
  }
  complex_expr.storeRefStmt = storeRefStmt;
  function newCellStmt(slicePrefix) {
    return (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tDeclareVariable)((0, tsgen_1.id)((0, utils_1.getCurrentSlice)(slicePrefix, "cell")), (0, tsgen_1.tFunctionCall)((0, tsgen_1.id)("beginCell"), [])));
  }
  complex_expr.newCellStmt = newCellStmt;
  function checkConstraintStmt(constraintAST, exceptionCommentLastPart) {
    return (0, tsgen_1.tIfStatement)((0, tsgen_1.tUnaryOpExpression)("!", constraintAST), [
      (0, tsgen_1.tExpressionStatement)((0, tsgen_1.id)("throw new Error('Condition " + (0, tsgen_1.toCode)(constraintAST).code + exceptionCommentLastPart + "')"))
    ]);
  }
  complex_expr.checkConstraintStmt = checkConstraintStmt;
  function inSeparateRef(slicePrefix, callback) {
    slicePrefix[slicePrefix.length - 1]++;
    slicePrefix.push(0);
    callback();
    slicePrefix.pop();
  }
  complex_expr.inSeparateRef = inSeparateRef;
  function negationDerivationFuncDecl(tlbCode, getParameterFunctionId, fieldName, fieldTypeName, argIndex) {
    return (0, tsgen_1.tFunctionDeclaration)(getParameterFunctionId, (0, tsgen_1.tTypeParametersExpression)([]), (0, tsgen_1.id)("number"), [(0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)((0, utils_1.findNotReservedName)(fieldName)), (0, tsgen_1.id)(fieldTypeName))], (0, utils_2.getNegationDerivationFunctionBody)(tlbCode, fieldTypeName, argIndex, fieldName));
  }
  complex_expr.negationDerivationFuncDecl = negationDerivationFuncDecl;
  function dictStoreStmt(currentCell, storeParametersInside, keyForStore, valueStore, direct) {
    return (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)(currentCell), (0, tsgen_1.id)("storeDict" + (direct ? "Direct" : ""))), storeParametersInside.concat([keyForStore, valueStore])));
  }
  complex_expr.dictStoreStmt = dictStoreStmt;
  function dictTypeParamExpr(fieldType, typeParamExpr) {
    return (0, tsgen_1.tTypeWithParameters)((0, tsgen_1.id)("Dictionary"), (0, tsgen_1.tTypeParametersExpression)([(0, utils_2.isBigIntExpr)(fieldType.key) ? (0, tsgen_1.id)("bigint") : (0, tsgen_1.id)("number"), typeParamExpr]));
  }
  complex_expr.dictTypeParamExpr = dictTypeParamExpr;
  function dictValueStore(typeParamExpr, storeFunctionExpr2, extraStoreFunctionExpr) {
    let subStatements = [
      (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tFunctionCall)(storeFunctionExpr2, [(0, tsgen_1.id)(extraStoreFunctionExpr ? "arg.value" : "arg")]), [
        (0, tsgen_1.id)("builder")
      ]))
    ];
    if (extraStoreFunctionExpr) {
      subStatements = [
        (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tFunctionCall)(extraStoreFunctionExpr, [(0, tsgen_1.id)("arg.extra")]), [(0, tsgen_1.id)("builder")]))
      ].concat(subStatements);
    }
    return (0, tsgen_1.tObjectExpression)([
      (0, tsgen_1.tObjectProperty)((0, tsgen_1.id)("serialize"), (0, tsgen_1.tArrowFunctionExpression)([(0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("arg"), typeParamExpr), (0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("builder"), (0, tsgen_1.id)("Builder"))], subStatements)),
      (0, tsgen_1.tObjectProperty)((0, tsgen_1.id)("parse"), (0, tsgen_1.id)("() => { throw new Error('Not implemented') }"))
    ]);
  }
  complex_expr.dictValueStore = dictValueStore;
  function dictLoadExpr(keyForLoad, loadFunctionExpr, currentSlice, direct) {
    return (0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)("Dictionary"), (0, tsgen_1.id)("load" + (direct ? "Direct" : ""))), [
      keyForLoad,
      dictValueLoad(loadFunctionExpr),
      (0, tsgen_1.id)(currentSlice)
    ]);
  }
  complex_expr.dictLoadExpr = dictLoadExpr;
  function dictValueLoad(loadFunctionExpr) {
    return (0, tsgen_1.tObjectExpression)([
      (0, tsgen_1.tObjectProperty)((0, tsgen_1.id)("serialize"), (0, tsgen_1.id)("() => { throw new Error('Not implemented') }")),
      (0, tsgen_1.tObjectProperty)((0, tsgen_1.id)("parse"), loadFunctionExpr)
    ]);
  }
  function dictKeyExpr(keyType, ctx, objectId) {
    let param;
    if (objectId) {
      param = (0, utils_2.convertToAST)(keyType.expr, ctx.constructor, (0, tsgen_1.id)(objectId));
    } else {
      param = (0, utils_2.convertToAST)(keyType.expr, ctx.constructor);
    }
    return (0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)("Dictionary.Keys"), (0, utils_2.isBigIntExpr)(keyType) ? (0, tsgen_1.id)("BigUint") : (0, tsgen_1.id)("Uint")), [
      param
    ]);
  }
  complex_expr.dictKeyExpr = dictKeyExpr;
  function dictAugParse(extraLoadExpr, loadExpr) {
    return (0, tsgen_1.tArrowFunctionExpression)([(0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("slice"), (0, tsgen_1.id)("Slice"))], [
      (0, tsgen_1.tReturnStatement)((0, tsgen_1.tObjectExpression)([
        (0, tsgen_1.tObjectProperty)((0, tsgen_1.id)("extra"), extraLoadExpr),
        (0, tsgen_1.tObjectProperty)((0, tsgen_1.id)("value"), loadExpr)
      ]))
    ]);
  }
  complex_expr.dictAugParse = dictAugParse;
  function dictAugTypeExpr(typeExpr, extraTypeExpr) {
    return (0, tsgen_1.tStructExpression)([(0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("value"), typeExpr), (0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("extra"), extraTypeExpr)]);
  }
  complex_expr.dictAugTypeExpr = dictAugTypeExpr;
  return complex_expr;
}
var hasRequiredGenerator;
function requireGenerator() {
  if (hasRequiredGenerator) return generator;
  hasRequiredGenerator = 1;
  Object.defineProperty(generator, "__esModule", { value: true });
  generator.TypescriptGenerator = void 0;
  const ast_1 = requireAst();
  const utils_1 = requireUtils$4();
  const CodeBuilder_1 = requireCodeBuilder();
  const complex_expr_1 = requireComplex_expr();
  const tsgen_1 = requireTsgen();
  const utils_2 = requireUtils$2();
  class TypescriptGenerator {
    constructor(tlbCode) {
      this.jsCodeDeclarations = [];
      this.jsCodeConstructorDeclarations = [];
      this.jsCodeFunctionsDeclarations = [];
      this.tlbCode = tlbCode;
    }
    addTonCoreClassUsage(name) {
      this.jsCodeDeclarations.push((0, tsgen_1.tImportDeclaration)((0, tsgen_1.id)(name), (0, tsgen_1.tStringLiteral)("@ton/core")));
    }
    addBuiltinCode() {
      this.addBitLenFunction();
      this.addEmbeddedTypes();
      this.addCopyCellToBuilder();
    }
    addBitLenFunction() {
      this.jsCodeDeclarations.push((0, complex_expr_1.bitlenFunctionDecl)());
    }
    addCopyCellToBuilder() {
      this.jsCodeDeclarations.push((0, tsgen_1.tCodeAsIs)(`export function copyCellToBuilder(from: Cell, to: Builder): void {
    let slice = from.beginParse();
    to.storeBits(slice.loadBits(slice.remainingBits));
    while (slice.remainingRefs) {
        to.storeRef(slice.loadRef());
    }
}`));
    }
    addEmbeddedTypes() {
      this.jsCodeDeclarations.push((0, tsgen_1.tCodeAsIs)(`export interface Bool {
    readonly kind: 'Bool';
    readonly value: boolean;
}

export function loadBool(slice: Slice): Bool {
    if (slice.remainingBits >= 1) {
        let value = slice.loadUint(1);
        return {
            kind: 'Bool',
            value: value == 1
        }

    }
    throw new Error('Expected one of "BoolFalse" in loading "BoolFalse", but data does not satisfy any constructor');
}

export function storeBool(bool: Bool): (builder: Builder) => void {
    return ((builder: Builder) => {
        builder.storeUint(bool.value ? 1: 0, 1);
    })

}



export function loadBoolFalse(slice: Slice): Bool {
  if (((slice.remainingBits >= 1) && (slice.preloadUint(1) == 0b0))) {
      slice.loadUint(1);
      return {
          kind: 'Bool',
          value: false
      }

  }
  throw new Error('Expected one of "BoolFalse" in loading "BoolFalse", but data does not satisfy any constructor');
}

export function loadBoolTrue(slice: Slice): Bool {
  if (((slice.remainingBits >= 1) && (slice.preloadUint(1) == 0b1))) {
      slice.loadUint(1);
      return {
          kind: 'Bool',
          value: true
      }

  }
  throw new Error('Expected one of "BoolTrue" in loading "BoolTrue", but data does not satisfy any constructor');
}
`));
    }
    addTlbType(tlbType) {
      let typeName = (0, utils_1.findNotReservedName)((0, utils_1.firstLower)(tlbType.name), "0");
      let typeUnion = [];
      let constructorsDeclarations = [];
      let loadStatements = [];
      let storeStatements = [];
      let structTypeParametersExpr = (0, tsgen_1.tTypeParametersExpression)([]);
      tlbType.constructors.forEach((constructor) => {
        let constructorTypeName = (0, utils_1.getSubStructName)(tlbType, constructor);
        let ctx = {
          constructor,
          name: (0, utils_1.findNotReservedName)((0, utils_1.firstLower)(constructorTypeName), "_" + constructor.name),
          typeName,
          loadStatements: [],
          loadProperties: [(0, tsgen_1.tObjectProperty)((0, tsgen_1.id)("kind"), (0, tsgen_1.tStringLiteral)(constructorTypeName))],
          properties: [(0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)("kind"), (0, tsgen_1.tStringLiteral)(constructorTypeName))],
          storeStatements: []
        };
        structTypeParametersExpr = (0, utils_2.getTypeParametersExpression)(constructor.parameters);
        let slicePrefix = [0];
        constructor.variables.forEach((variable) => {
          this.addVarToConstructorLoadProperty(variable, ctx, constructor);
        });
        constructor.fields.forEach((field) => {
          this.handleField(field, slicePrefix, ctx);
        });
        typeUnion.push((0, tsgen_1.tTypeWithParameters)((0, tsgen_1.id)(constructorTypeName), structTypeParametersExpr));
        let structX = (0, tsgen_1.tStructDeclaration)((0, tsgen_1.id)(constructorTypeName), ctx.properties, structTypeParametersExpr);
        constructor.constraints.forEach((constraint) => {
          this.genCodeForConstraint(constraint, typeName, tlbType, ctx);
        });
        ctx.loadStatements.push((0, tsgen_1.tReturnStatement)((0, tsgen_1.tObjectExpression)(ctx.loadProperties)));
        loadStatements = this.constructorStmtsToTypeStmts(constructor, tlbType, ctx, loadStatements);
        if (constructor.tag.bitLen != 0) {
          ctx.storeStatements.splice(0, 0, (0, complex_expr_1.storeTagExpression)(constructor.tag));
        }
        let storeStatement = (0, complex_expr_1.storeFunctionStmt)(ctx.storeStatements);
        if (tlbType.constructors.length > 1) {
          storeStatement = (0, complex_expr_1.checkKindStmt)(typeName, constructorTypeName, storeStatement);
        }
        storeStatements.push(storeStatement);
        constructorsDeclarations.push(structX);
        this.jsCodeFunctionsDeclarations.push((0, tsgen_1.tComment)(constructor.declaration));
        this.jsCodeConstructorDeclarations.push((0, tsgen_1.tComment)(constructor.declaration));
      });
      this.addExceptionStmts(tlbType, loadStatements, storeStatements);
      let loadFunctionParameters = (0, complex_expr_1.typedSlice)();
      const currentType = (0, tsgen_1.tTypeWithParameters)((0, tsgen_1.id)(tlbType.name), structTypeParametersExpr);
      let storeFunctionParameters = [(0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)(typeName), currentType)];
      this.addFunctionParameters(tlbType, loadFunctionParameters, storeFunctionParameters);
      let loadFunction = (0, tsgen_1.tFunctionDeclaration)((0, tsgen_1.id)("load" + tlbType.name), structTypeParametersExpr, currentType, loadFunctionParameters, loadStatements);
      let storeFunction = (0, tsgen_1.tFunctionDeclaration)((0, tsgen_1.id)("store" + tlbType.name), structTypeParametersExpr, (0, tsgen_1.id)("(builder: Builder) => void"), storeFunctionParameters, storeStatements);
      if (tlbType.constructors.length > 1) {
        this.jsCodeConstructorDeclarations.push((0, tsgen_1.tUnionTypeDeclaration)(currentType, (0, tsgen_1.tUnionTypeExpression)(typeUnion)));
      }
      constructorsDeclarations.forEach((element) => {
        this.jsCodeConstructorDeclarations.push(element);
      });
      this.jsCodeFunctionsDeclarations.push(loadFunction);
      this.jsCodeFunctionsDeclarations.push(storeFunction);
    }
    addFunctionParameters(tlbType, loadFunctionParameters, storeFunctionParameters) {
      let anyConstructor = tlbType.constructors[0];
      if (anyConstructor) {
        anyConstructor.parameters.forEach((element) => {
          if (element.variable.type == "Type") {
            loadFunctionParameters.push((0, complex_expr_1.loadFunctionParam)(element.variable.name));
            storeFunctionParameters.push((0, complex_expr_1.storeFunctionParam)(element.variable.name));
          }
          if (element.variable.type == "#" && !element.variable.negated) {
            if (element.argName) {
              loadFunctionParameters.push((0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)(element.argName), (0, tsgen_1.id)("number")));
            } else {
              loadFunctionParameters.push((0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)(element.variable.name), (0, tsgen_1.id)("number")));
            }
          }
        });
      } else {
        throw new Error(`Type ${tlbType.name} should have at least one constructor`);
      }
    }
    addExceptionStmts(tlbType, loadStatements, storeStatements) {
      var _a;
      let exceptionTypesComment = tlbType.constructors.map((constructor) => {
        return `"${(0, utils_1.getSubStructName)(tlbType, constructor)}"`;
      }).join(", ");
      let exceptionComment = (0, tsgen_1.tExpressionStatement)((0, tsgen_1.id)(`throw new Error('Expected one of ${exceptionTypesComment} in loading "${tlbType.name}", but data does not satisfy any constructor')`));
      if (tlbType.constructors.length > 1 || ((_a = tlbType.constructors.at(0)) === null || _a === void 0 ? void 0 : _a.tag.bitLen) != 0) {
        loadStatements.push(exceptionComment);
      }
      if (tlbType.constructors.length > 1) {
        storeStatements.push(exceptionComment);
      }
    }
    constructorStmtsToTypeStmts(constructor, tlbType, ctx, loadStatements) {
      if (constructor.tag.bitLen != 0 || tlbType.constructors.length > 1) {
        let conditions = [];
        if (constructor.tag.bitLen != 0) {
          conditions.push((0, complex_expr_1.checkHasBitsForTag)(constructor.tag.bitLen));
          conditions.push((0, complex_expr_1.checkTagExpr)(constructor.tag));
          let loadBitsStatement = [(0, complex_expr_1.skipTagStmt)(constructor.tag.bitLen)];
          ctx.loadStatements = loadBitsStatement.concat(ctx.loadStatements);
        }
        constructor.parameters.forEach((param) => {
          if (param.variable.isConst && !param.variable.negated) {
            let argName = param.variable.name;
            if (param.argName) {
              argName = param.argName;
            }
            conditions.push((0, complex_expr_1.tEqualExpression)((0, tsgen_1.id)(argName), (0, utils_2.getParamVarExpr)(param, constructor)));
          }
        });
        loadStatements.push((0, tsgen_1.tIfStatement)((0, utils_2.getCondition)(conditions), ctx.loadStatements));
      } else {
        loadStatements = loadStatements.concat(ctx.loadStatements);
      }
      return loadStatements;
    }
    genCodeForConstraint(constraint, variableCombinatorName, tlbType, ctx) {
      let loadConstraintAST = (0, utils_2.convertToAST)(constraint, ctx.constructor);
      let storeConstraintAST = (0, utils_2.convertToAST)(constraint, ctx.constructor, (0, tsgen_1.id)(variableCombinatorName));
      let exceptionCommentLastPart = ` is not satisfied while loading "${(0, utils_1.getSubStructName)(tlbType, ctx.constructor)}" for type "${tlbType.name}"`;
      ctx.loadStatements.push((0, complex_expr_1.checkConstraintStmt)(loadConstraintAST, exceptionCommentLastPart));
      ctx.storeStatements.push((0, complex_expr_1.checkConstraintStmt)(storeConstraintAST, exceptionCommentLastPart));
    }
    addVarToConstructorLoadProperty(variable, ctx, constructor) {
      let varExpr = void 0;
      if (variable.negated) {
        if (variable.deriveExpr) {
          varExpr = (0, utils_2.convertToAST)(variable.deriveExpr, constructor);
        }
      }
      if (variable.type == "#" && !variable.isField) {
        const isOptional = this.isOptionalVariable(variable, ctx);
        ctx.properties.push((0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)(variable.name), (0, tsgen_1.id)("number"), isOptional));
        let parameter = constructor.parametersMap.get(variable.name);
        if (parameter && !parameter.variable.isConst && !parameter.variable.negated) {
          varExpr = (0, utils_2.getParamVarExpr)(parameter, constructor);
        }
      }
      if (varExpr) {
        ctx.loadProperties.push((0, tsgen_1.tObjectProperty)((0, tsgen_1.id)(variable.name), varExpr));
      }
    }
    toCode(node, code = new CodeBuilder_1.CodeBuilder()) {
      return (0, tsgen_1.toCode)(node, code);
    }
    handleField(field, slicePrefix, ctx) {
      let currentSlice = (0, utils_1.getCurrentSlice)(slicePrefix, "slice");
      let currentCell = (0, utils_1.getCurrentSlice)(slicePrefix, "cell");
      if (field.subFields.length > 0) {
        (0, complex_expr_1.inSeparateRef)(slicePrefix, () => {
          ctx.loadStatements.push((0, complex_expr_1.sliceLoad)(slicePrefix, currentSlice));
          ctx.storeStatements.push((0, complex_expr_1.newCellStmt)(slicePrefix));
          field.subFields.forEach((fieldDef) => {
            this.handleField(fieldDef, slicePrefix, ctx);
          });
          ctx.storeStatements.push((0, complex_expr_1.storeRefStmt)(slicePrefix, currentCell));
        });
      }
      if (field.fieldType.kind == "TLBExoticType") {
        (0, complex_expr_1.inSeparateRef)(slicePrefix, () => {
          ctx.loadStatements.push((0, complex_expr_1.loadRefStmt)(slicePrefix, currentSlice));
          (0, utils_2.addLoadProperty)(field.name, (0, tsgen_1.id)((0, utils_1.getCurrentSlice)(slicePrefix, "cell")), void 0, ctx);
          ctx.properties.push((0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)(field.name), (0, tsgen_1.id)("Cell")));
          ctx.storeStatements.push((0, complex_expr_1.storeRefObjectStmt)(currentCell, ctx, field));
        });
      } else if (field.subFields.length == 0) {
        let fieldInfo = this.handleType(field, field.fieldType, true, ctx, slicePrefix, 0);
        if (fieldInfo.loadExpr) {
          (0, utils_2.addLoadProperty)(field.name, fieldInfo.loadExpr, fieldInfo.typeParamExpr, ctx);
        }
        if (fieldInfo.typeParamExpr) {
          ctx.properties.push((0, tsgen_1.tTypedIdentifier)((0, tsgen_1.id)(field.name), fieldInfo.typeParamExpr));
        }
        if (fieldInfo.storeStmtOutside) {
          ctx.storeStatements.push(fieldInfo.storeStmtOutside);
        }
        fieldInfo.negatedVariablesLoads.forEach((element) => {
          (0, utils_2.addLoadProperty)(element.name, element.expression, void 0, ctx);
        });
      }
    }
    handleType(field, fieldType, isField, ctx, slicePrefix, argIndex) {
      let currentSlice = (0, utils_1.getCurrentSlice)(slicePrefix, "slice");
      let currentCell = (0, utils_1.getCurrentSlice)(slicePrefix, "cell");
      let fieldName = field.name;
      let theSlice = "slice";
      let theCell = "builder";
      if (isField) {
        theSlice = currentSlice;
        theCell = currentCell;
      }
      let result = {
        typeParamExpr: void 0,
        loadExpr: void 0,
        loadFunctionExpr: void 0,
        storeStmtOutside: void 0,
        storeStmtInside: void 0,
        storeFunctionExpr: void 0,
        negatedVariablesLoads: []
      };
      let exprForParam;
      let storeParametersOutside;
      storeParametersOutside = [(0, tsgen_1.tMemberExpression)((0, tsgen_1.id)(ctx.typeName), (0, tsgen_1.id)(fieldName))];
      let storeParametersInside = [(0, tsgen_1.id)("arg")];
      if (fieldType.kind == "TLBNumberType") {
        exprForParam = {
          argLoadExpr: (0, utils_2.convertToAST)(fieldType.bits, ctx.constructor),
          argStoreExpr: (0, utils_2.convertToAST)(fieldType.storeBits, ctx.constructor, (0, tsgen_1.id)(ctx.typeName)),
          paramType: "number",
          fieldLoadSuffix: fieldType.signed ? "Int" : "Uint",
          fieldStoreSuffix: fieldType.signed ? "Int" : "Uint"
        };
        if ((0, utils_2.isBigInt)(fieldType)) {
          exprForParam.fieldLoadSuffix += "Big";
          exprForParam.paramType = "bigint";
        }
      } else if (fieldType.kind == "TLBBitsType") {
        if (fieldType.bits instanceof ast_1.TLBNumberExpr && fieldType.bits.n == 1) {
          exprForParam = {
            argLoadExpr: void 0,
            argStoreExpr: void 0,
            paramType: "boolean",
            fieldLoadSuffix: "Bit",
            fieldStoreSuffix: "Bit"
          };
        } else {
          let isBuffer2 = (0, utils_2.useBuffer)(fieldType);
          let suffix = isBuffer2 ? "Buffer" : "Bits";
          let argLoadExpr = (0, utils_2.convertToAST)(fieldType.bits, ctx.constructor);
          let argStoreExpr = (0, utils_2.convertToAST)(fieldType.bits, ctx.constructor, (0, tsgen_1.id)(ctx.name));
          if (isBuffer2) {
            argLoadExpr = (0, tsgen_1.tBinaryExpression)(argLoadExpr, "/", (0, tsgen_1.tNumericLiteral)(8));
            argStoreExpr = (0, tsgen_1.tBinaryExpression)(argStoreExpr, "/", (0, tsgen_1.tNumericLiteral)(8));
          }
          exprForParam = {
            argLoadExpr,
            argStoreExpr,
            paramType: isBuffer2 ? "Buffer" : "BitString",
            fieldLoadSuffix: suffix,
            fieldStoreSuffix: suffix
          };
        }
      } else if (fieldType.kind == "TLBCellType") {
        exprForParam = {
          argLoadExpr: (0, tsgen_1.id)(theSlice),
          argStoreExpr: (0, tsgen_1.id)(theSlice),
          paramType: "Cell",
          fieldLoadSuffix: "Ref",
          fieldStoreSuffix: "Slice"
        };
        storeParametersOutside[0] = (0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)(storeParametersOutside[0], (0, tsgen_1.id)("beginParse")), [
          (0, tsgen_1.id)("true")
        ]);
        storeParametersInside[0] = (0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)(storeParametersInside[0], (0, tsgen_1.id)("beginParse")), [
          (0, tsgen_1.id)("true")
        ]);
      } else if (fieldType.kind == "TLBCoinsType") {
        exprForParam = {
          argLoadExpr: void 0,
          argStoreExpr: void 0,
          paramType: "bigint",
          fieldLoadSuffix: "Coins",
          fieldStoreSuffix: "Coins"
        };
      } else if (fieldType.kind == "TLBVarIntegerType") {
        exprForParam = {
          argLoadExpr: (0, utils_2.convertToAST)(fieldType.n, ctx.constructor),
          argStoreExpr: (0, utils_2.convertToAST)(fieldType.n, ctx.constructor, (0, tsgen_1.id)(ctx.name)),
          paramType: "bigint",
          fieldLoadSuffix: fieldType.signed ? "VarIntBig" : "VarUintBig",
          fieldStoreSuffix: fieldType.signed ? "VarInt" : "VarUint"
        };
      } else if (fieldType.kind == "TLBTupleType") {
        result.loadExpr = (0, tsgen_1.tFunctionCall)((0, tsgen_1.id)("parseTuple"), [
          (0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)("slice"), (0, tsgen_1.id)("asCell")), [])
        ]);
        result.typeParamExpr = (0, tsgen_1.id)("TupleItem[]");
        result.storeStmtInside = (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.id)("copyCellToBuilder"), [
          (0, tsgen_1.tFunctionCall)((0, tsgen_1.id)("serializeTuple"), storeParametersInside),
          (0, tsgen_1.id)("builder")
        ]));
        result.storeStmtOutside = (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.id)("copyCellToBuilder"), [
          (0, tsgen_1.tFunctionCall)((0, tsgen_1.id)("serializeTuple"), storeParametersOutside),
          (0, tsgen_1.id)("builder")
        ]));
      } else if (fieldType.kind == "TLBAddressType") {
        if (fieldType.addrType == "Internal") {
          exprForParam = {
            argLoadExpr: void 0,
            argStoreExpr: void 0,
            paramType: "Address",
            fieldLoadSuffix: "Address",
            fieldStoreSuffix: "Address"
          };
        } else if (fieldType.addrType == "External") {
          exprForParam = {
            argLoadExpr: void 0,
            argStoreExpr: void 0,
            paramType: "ExternalAddress | null",
            fieldLoadSuffix: "MaybeExternalAddress",
            fieldStoreSuffix: "Address"
          };
        } else if (fieldType.addrType == "Any") {
          exprForParam = {
            argLoadExpr: void 0,
            argStoreExpr: void 0,
            paramType: "Address | ExternalAddress | null",
            fieldLoadSuffix: "AddressAny",
            fieldStoreSuffix: "Address"
          };
        } else {
          throw new Error("Address has type other than ['Internal', 'External', 'Any']");
        }
      } else if (fieldType.kind == "TLBExprMathType") {
        result.loadExpr = (0, utils_2.convertToAST)(fieldType.expr, ctx.constructor);
        result.storeStmtOutside = (0, tsgen_1.tExpressionStatement)(result.loadExpr);
      } else if (fieldType.kind == "TLBNegatedType") {
        let getParameterFunctionId = (0, tsgen_1.id)(ctx.name + "_get_" + fieldType.variableName);
        if (field.fieldType.kind == "TLBNamedType") {
          let fieldTypeName = field.fieldType.name;
          this.jsCodeFunctionsDeclarations.push((0, complex_expr_1.negationDerivationFuncDecl)(this.tlbCode, getParameterFunctionId, fieldName, fieldTypeName, argIndex));
        }
        result.negatedVariablesLoads.push({
          name: fieldType.variableName,
          expression: (0, tsgen_1.tFunctionCall)(getParameterFunctionId, [(0, tsgen_1.id)(fieldName)])
        });
      } else if (fieldType.kind == "TLBNamedType" && fieldType.arguments.length == 0) {
        let typeName = fieldType.name;
        result.typeParamExpr = (0, tsgen_1.id)(typeName);
        if (isField) {
          result.loadExpr = (0, tsgen_1.tFunctionCall)((0, tsgen_1.id)("load" + typeName), [(0, tsgen_1.id)(theSlice)]);
          result.storeStmtOutside = (0, complex_expr_1.storeExpressionNamedType)(typeName, storeParametersOutside, currentCell);
          result.storeStmtInside = (0, complex_expr_1.storeExpressionNamedType)(typeName, storeParametersInside, currentCell);
        } else {
          result.loadExpr = (0, tsgen_1.id)("load" + typeName);
          result.storeStmtOutside = (0, tsgen_1.tExpressionStatement)((0, tsgen_1.id)("store" + typeName));
        }
      } else if (fieldType.kind == "TLBCondType") {
        let subExprInfo;
        let conditionExpr;
        subExprInfo = this.handleType(field, fieldType.value, true, ctx, slicePrefix, argIndex);
        conditionExpr = (0, utils_2.convertToAST)(fieldType.condition, ctx.constructor);
        if (subExprInfo.typeParamExpr) {
          result.typeParamExpr = (0, tsgen_1.tUnionTypeExpression)([subExprInfo.typeParamExpr, (0, tsgen_1.id)("undefined")]);
        }
        if (subExprInfo.loadExpr) {
          result.loadExpr = (0, tsgen_1.tTernaryExpression)(conditionExpr, subExprInfo.loadExpr, (0, tsgen_1.id)("undefined"));
        }
        let currentParamOutside = storeParametersOutside[0];
        let currentParamInside = storeParametersInside[0];
        if (currentParamOutside && currentParamInside && subExprInfo.storeStmtOutside) {
          result.storeStmtOutside = (0, complex_expr_1.storeExprCond)(currentParamOutside, subExprInfo.storeStmtOutside);
          result.storeStmtInside = (0, complex_expr_1.storeExprCond)(currentParamInside, subExprInfo.storeStmtOutside);
        }
      } else if (fieldType.kind == "TLBMultipleType") {
        let arrayLength;
        let subExprInfo;
        arrayLength = (0, utils_2.convertToAST)(fieldType.times, ctx.constructor);
        subExprInfo = this.handleType(field, fieldType.value, false, ctx, slicePrefix, argIndex);
        let currentParamOutside = storeParametersOutside[0];
        let currentParamInside = storeParametersInside[0];
        if (subExprInfo.loadExpr) {
          result.loadExpr = (0, complex_expr_1.loadTupleExpr)(arrayLength, subExprInfo.loadExpr);
        }
        if (currentParamOutside && currentParamInside && subExprInfo.typeParamExpr && subExprInfo.storeStmtOutside) {
          if (subExprInfo.storeFunctionExpr && subExprInfo.storeStmtInside) {
            result.storeStmtOutside = (0, complex_expr_1.storeTupleStmt)(currentParamOutside, subExprInfo.storeStmtInside, subExprInfo.typeParamExpr);
            result.storeStmtInside = (0, complex_expr_1.storeTupleStmt)(currentParamInside, subExprInfo.storeStmtInside, subExprInfo.typeParamExpr);
          }
        }
        if (subExprInfo.typeParamExpr) {
          result.typeParamExpr = (0, complex_expr_1.arrayedType)(subExprInfo.typeParamExpr);
        }
      } else if (fieldType.kind == "TLBCellInsideType") {
        let currentCell2 = (0, utils_1.getCurrentSlice)([1, 0], "cell");
        let subExprInfo = this.handleType(field, fieldType.value, true, ctx, [1, 0], argIndex);
        if (subExprInfo.loadExpr) {
          result.typeParamExpr = subExprInfo.typeParamExpr;
          result.storeStmtOutside = subExprInfo.storeStmtOutside;
          result.negatedVariablesLoads = subExprInfo.negatedVariablesLoads;
          result.loadFunctionExpr = (0, complex_expr_1.loadFromNewSlice)(subExprInfo.loadExpr);
          result.loadExpr = (0, tsgen_1.tFunctionCall)(result.loadFunctionExpr, [(0, tsgen_1.id)(theSlice)]);
        }
        if (subExprInfo.storeStmtOutside) {
          result.storeStmtOutside = (0, complex_expr_1.storeInNewCell)(currentCell2, subExprInfo.storeStmtOutside);
        }
        if (subExprInfo.storeStmtInside) {
          result.storeStmtInside = (0, complex_expr_1.storeInNewCell)(currentCell2, subExprInfo.storeStmtInside);
        }
      } else if (fieldType.kind == "TLBBoolType") {
        let loadFunction = "load" + (fieldType.value === void 0 ? "Bool" : fieldType.value ? "BoolTrue" : "BoolFalse");
        result.loadExpr = (0, tsgen_1.tFunctionCall)((0, tsgen_1.id)(loadFunction), [(0, tsgen_1.id)("slice")]);
        result.typeParamExpr = (0, tsgen_1.id)("Bool");
        result.storeStmtInside = (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tFunctionCall)((0, tsgen_1.id)("storeBool"), storeParametersInside), [(0, tsgen_1.id)("builder")]));
        result.storeStmtOutside = (0, tsgen_1.tExpressionStatement)((0, tsgen_1.tFunctionCall)((0, tsgen_1.tFunctionCall)((0, tsgen_1.id)("storeBool"), storeParametersOutside), [(0, tsgen_1.id)("builder")]));
      } else if (fieldType.kind == "TLBHashmapType") {
        let keyForLoad = (0, complex_expr_1.dictKeyExpr)(fieldType.key, ctx);
        let keyForStore = (0, complex_expr_1.dictKeyExpr)(fieldType.key, ctx, ctx.typeName);
        let subExprInfo = this.handleType(field, fieldType.value, fieldType.extra != void 0, ctx, slicePrefix, argIndex);
        if (subExprInfo.typeParamExpr && subExprInfo.loadFunctionExpr && subExprInfo.storeFunctionExpr) {
          let valueStore;
          if (fieldType.extra && subExprInfo.loadExpr) {
            let extraInfo = this.handleType(field, fieldType.extra, true, ctx, slicePrefix, argIndex);
            if (extraInfo.typeParamExpr) {
              subExprInfo.typeParamExpr = (0, complex_expr_1.dictAugTypeExpr)(subExprInfo.typeParamExpr, extraInfo.typeParamExpr);
            }
            valueStore = (0, complex_expr_1.dictValueStore)(subExprInfo.typeParamExpr, subExprInfo.storeFunctionExpr, extraInfo.storeFunctionExpr);
            if (extraInfo.loadExpr) {
              result.loadExpr = (0, complex_expr_1.dictLoadExpr)(keyForLoad, (0, complex_expr_1.dictAugParse)(extraInfo.loadExpr, subExprInfo.loadExpr), currentSlice, fieldType.directStore);
            }
          } else {
            valueStore = (0, complex_expr_1.dictValueStore)(subExprInfo.typeParamExpr, subExprInfo.storeFunctionExpr);
            result.loadExpr = (0, complex_expr_1.dictLoadExpr)(keyForLoad, subExprInfo.loadFunctionExpr, currentSlice, fieldType.directStore);
          }
          result.typeParamExpr = (0, complex_expr_1.dictTypeParamExpr)(fieldType, subExprInfo.typeParamExpr);
          result.storeStmtInside = (0, complex_expr_1.dictStoreStmt)(currentCell, storeParametersInside, keyForStore, valueStore, fieldType.directStore);
          result.storeStmtOutside = (0, complex_expr_1.dictStoreStmt)(currentCell, storeParametersOutside, keyForStore, valueStore, fieldType.directStore);
        }
      } else if (fieldType.kind == "TLBNamedType" && fieldType.arguments.length) {
        let typeName = fieldType.name;
        let typeExpression = (0, tsgen_1.tTypeParametersExpression)([]);
        let loadFunctionsArray = [];
        let storeFunctionsArray = [];
        let argIndex2 = -1;
        fieldType.arguments.forEach((arg) => {
          argIndex2++;
          let subExprInfo = this.handleType(field, arg, false, ctx, slicePrefix, argIndex2);
          if (subExprInfo.typeParamExpr) {
            typeExpression.typeParameters.push(subExprInfo.typeParamExpr);
          }
          if (subExprInfo.loadFunctionExpr) {
            loadFunctionsArray.push(subExprInfo.loadFunctionExpr);
          }
          if (subExprInfo.storeFunctionExpr) {
            storeFunctionsArray.push(subExprInfo.storeFunctionExpr);
          }
          result.negatedVariablesLoads = result.negatedVariablesLoads.concat(subExprInfo.negatedVariablesLoads);
        });
        result.typeParamExpr = (0, tsgen_1.tTypeWithParameters)((0, tsgen_1.id)(typeName), typeExpression);
        let currentTypeParameters = typeExpression;
        let insideLoadParameters = [(0, tsgen_1.id)(theSlice)];
        result.loadExpr = (0, tsgen_1.tFunctionCall)((0, tsgen_1.id)("load" + typeName), insideLoadParameters.concat(loadFunctionsArray), currentTypeParameters);
        result.storeStmtOutside = (0, complex_expr_1.storeCombinator)(typeName, storeParametersOutside, storeFunctionsArray, currentTypeParameters, theCell);
        result.storeStmtInside = (0, complex_expr_1.storeCombinator)(typeName, storeParametersInside, storeFunctionsArray, currentTypeParameters, theCell);
        if (exprForParam) {
          result.typeParamExpr = (0, tsgen_1.id)(exprForParam.paramType);
        }
      }
      if (exprForParam) {
        if (exprForParam.paramType != "BitString" && exprForParam.paramType != "Cell") {
          if (exprForParam.argStoreExpr) {
            storeParametersOutside.push(exprForParam.argStoreExpr);
            storeParametersInside.push(exprForParam.argStoreExpr);
          }
        }
        result.loadExpr = (0, complex_expr_1.loadExprForParam)(currentSlice, exprForParam);
        if (exprForParam.paramType == "Cell") {
          result.loadExpr = (0, tsgen_1.tFunctionCall)((0, tsgen_1.tMemberExpression)((0, tsgen_1.id)(currentSlice), (0, tsgen_1.id)("asCell")), []);
          result.loadFunctionExpr = (0, complex_expr_1.returnSliceFunc)();
        }
        result.typeParamExpr = (0, tsgen_1.id)(exprForParam.paramType);
        result.storeStmtOutside = (0, complex_expr_1.storeExprForParam)(theCell, exprForParam, storeParametersOutside);
        result.storeStmtInside = (0, complex_expr_1.storeExprForParam)(theCell, exprForParam, storeParametersInside);
      }
      if (result.loadExpr && !result.loadFunctionExpr) {
        result.loadFunctionExpr = (0, complex_expr_1.coverFuncCall)(result.loadExpr);
      }
      if (result.storeStmtOutside && !result.storeFunctionExpr) {
        if (!result.storeStmtInside) {
          result.storeStmtInside = result.storeStmtOutside;
        }
        if (result.typeParamExpr) {
          if (result.storeStmtOutside.type == "ExpressionStatement" && result.storeStmtOutside.expression.type == "FunctionCall" || result.storeStmtOutside.type == "MultiStatement") {
            result.storeFunctionExpr = (0, complex_expr_1.storeFunctionExpr)(result.typeParamExpr, result.storeStmtInside);
          } else {
            if (result.storeStmtOutside.type == "ExpressionStatement") {
              result.storeFunctionExpr = result.storeStmtOutside.expression;
            }
          }
        }
      }
      if (result.storeStmtInside) {
        result.storeStmtInside = Object.assign({}, result.storeStmtInside);
      }
      return result;
    }
    isOptionalVariable(variable, ctx) {
      const usedInStore = this.collectFieldsUsedInStore(ctx);
      const isParameter = ctx.constructor.parameters.some((param) => param.variable.name === variable.name || param.argName === variable.name);
      return !usedInStore.has(variable.name) && !isParameter;
    }
    collectFieldsUsedInStore(ctx) {
      const fieldsUsed = /* @__PURE__ */ new Set();
      for (const stmt of ctx.storeStatements) {
        this.extractFieldReferences(stmt, ctx.typeName, fieldsUsed);
      }
      return fieldsUsed;
    }
    extractFieldReferences(node, typeName, fieldsUsed) {
      if (!node)
        return;
      switch (node.type) {
        case "ExpressionStatement":
          this.extractFieldReferences(node.expression, typeName, fieldsUsed);
          break;
        case "IfStatement":
          this.extractFieldReferences(node.condition, typeName, fieldsUsed);
          if (node.body) {
            node.body.forEach((stmt) => this.extractFieldReferences(stmt, typeName, fieldsUsed));
          }
          if (node.elseBody) {
            node.elseBody.forEach((stmt) => this.extractFieldReferences(stmt, typeName, fieldsUsed));
          }
          break;
        case "MultiStatement":
          node.statements.forEach((stmt) => this.extractFieldReferences(stmt, typeName, fieldsUsed));
          break;
        case "ReturnStatement":
          this.extractFieldReferences(node.returnValue, typeName, fieldsUsed);
          break;
        case "MemberExpression":
          if (node.thisObject.type === "Identifier" && node.thisObject.name === typeName && node.memberName.type === "Identifier") {
            fieldsUsed.add(node.memberName.name);
          }
          this.extractFieldReferences(node.thisObject, typeName, fieldsUsed);
          break;
        case "FunctionCall":
          this.extractFieldReferences(node.functionId, typeName, fieldsUsed);
          node.parameters.forEach((param) => this.extractFieldReferences(param, typeName, fieldsUsed));
          break;
        case "BinaryExpression":
          this.extractFieldReferences(node.left, typeName, fieldsUsed);
          this.extractFieldReferences(node.right, typeName, fieldsUsed);
          break;
        case "UnaryOpExpression":
          this.extractFieldReferences(node.expr, typeName, fieldsUsed);
          break;
        case "TernaryExpression":
          this.extractFieldReferences(node.condition, typeName, fieldsUsed);
          this.extractFieldReferences(node.body, typeName, fieldsUsed);
          this.extractFieldReferences(node.elseBody, typeName, fieldsUsed);
          break;
        case "ArrowFunctionExpression":
          node.body.forEach((stmt) => this.extractFieldReferences(stmt, typeName, fieldsUsed));
          break;
        case "ObjectExpression":
          node.objectValues.forEach((prop) => {
            this.extractFieldReferences(prop.key, typeName, fieldsUsed);
            this.extractFieldReferences(prop.value, typeName, fieldsUsed);
          });
          break;
      }
    }
  }
  generator.TypescriptGenerator = TypescriptGenerator;
  return generator;
}
var hasRequiredMain;
function requireMain() {
  if (hasRequiredMain) return main;
  hasRequiredMain = 1;
  Object.defineProperty(main, "__esModule", { value: true });
  main.generateCode = main.generateCodeWithGenerator = main.getTLBCode = main.getGenerator = main.generateCodeByAST = main.getTLBCodeByAST = void 0;
  const tlb_parser_1 = requireDist$3();
  const fill_constructors_1 = requireFill_constructors();
  const fill_constructors_2 = requireFill_constructors();
  const CodeBuilder_1 = requireCodeBuilder();
  const generator_1 = requireGenerator();
  function getTLBCodeByAST(tree, input) {
    let oldTlbCode = { types: /* @__PURE__ */ new Map() };
    let splittedInput = input.split("\n");
    (0, fill_constructors_2.fillConstructors)(tree.declarations, oldTlbCode, splittedInput);
    return (0, fill_constructors_1.convertCodeToReadonly)(oldTlbCode);
  }
  main.getTLBCodeByAST = getTLBCodeByAST;
  function generateCodeByAST(tree, input, getGenerator2) {
    let tlbCode = getTLBCodeByAST(tree, input);
    let codeGenerator = getGenerator2(tlbCode);
    codeGenerator.addTonCoreClassUsage("Builder");
    codeGenerator.addTonCoreClassUsage("Slice");
    codeGenerator.addTonCoreClassUsage("beginCell");
    codeGenerator.addTonCoreClassUsage("BitString");
    codeGenerator.addTonCoreClassUsage("Cell");
    codeGenerator.addTonCoreClassUsage("Address");
    codeGenerator.addTonCoreClassUsage("ExternalAddress");
    codeGenerator.addTonCoreClassUsage("Dictionary");
    codeGenerator.addTonCoreClassUsage("DictionaryValue");
    codeGenerator.addTonCoreClassUsage("TupleItem");
    codeGenerator.addTonCoreClassUsage("parseTuple");
    codeGenerator.addTonCoreClassUsage("serializeTuple");
    codeGenerator.addBuiltinCode();
    let jsCodeDeclarations = [];
    codeGenerator.jsCodeDeclarations.forEach((declaration) => {
      jsCodeDeclarations.push(declaration);
    });
    tlbCode.types.forEach((tlbType) => {
      codeGenerator.addTlbType(tlbType);
    });
    let generatedCode = "";
    codeGenerator.jsCodeConstructorDeclarations.forEach((element) => {
      jsCodeDeclarations.push(element);
    });
    codeGenerator.jsCodeFunctionsDeclarations.forEach((element) => {
      jsCodeDeclarations.push(element);
    });
    jsCodeDeclarations.forEach((element) => {
      generatedCode += codeGenerator.toCode(element, new CodeBuilder_1.CodeBuilder()).render() + "\n";
    });
    return generatedCode;
  }
  main.generateCodeByAST = generateCodeByAST;
  function getGenerator(resultLanguage) {
    return (tlbCode) => {
      if (resultLanguage == "typescript") {
        return new generator_1.TypescriptGenerator(tlbCode);
      } else {
        throw new Error(`Result language ${resultLanguage} is not supported`);
      }
    };
  }
  main.getGenerator = getGenerator;
  function getTLBCode(input) {
    return getTLBCodeByAST((0, tlb_parser_1.ast)(input), input);
  }
  main.getTLBCode = getTLBCode;
  function generateCodeWithGenerator(input, getGenerator2) {
    return generateCodeByAST((0, tlb_parser_1.ast)(input), input, getGenerator2);
  }
  main.generateCodeWithGenerator = generateCodeWithGenerator;
  function generateCode(input, resultLanguage) {
    return generateCodeWithGenerator(input, getGenerator(resultLanguage));
  }
  main.generateCode = generateCode;
  return main;
}
var hasRequiredBuild;
function requireBuild() {
  if (hasRequiredBuild) return build;
  hasRequiredBuild = 1;
  (function(exports) {
    var __createBinding = build && build.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = build && build.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypescriptGenerator = exports.isBigIntExpr = exports.isBigInt = exports.generateCode = exports.generateCodeWithGenerator = exports.getTLBCode = exports.generateCodeByAST = exports.getTLBCodeByAST = void 0;
    __exportStar(requireAst(), exports);
    var main_1 = requireMain();
    Object.defineProperty(exports, "getTLBCodeByAST", { enumerable: true, get: function() {
      return main_1.getTLBCodeByAST;
    } });
    Object.defineProperty(exports, "generateCodeByAST", { enumerable: true, get: function() {
      return main_1.generateCodeByAST;
    } });
    Object.defineProperty(exports, "getTLBCode", { enumerable: true, get: function() {
      return main_1.getTLBCode;
    } });
    Object.defineProperty(exports, "generateCodeWithGenerator", { enumerable: true, get: function() {
      return main_1.generateCodeWithGenerator;
    } });
    Object.defineProperty(exports, "generateCode", { enumerable: true, get: function() {
      return main_1.generateCode;
    } });
    var utils_1 = requireUtils$2();
    Object.defineProperty(exports, "isBigInt", { enumerable: true, get: function() {
      return utils_1.isBigInt;
    } });
    Object.defineProperty(exports, "isBigIntExpr", { enumerable: true, get: function() {
      return utils_1.isBigIntExpr;
    } });
    var generator_1 = requireGenerator();
    Object.defineProperty(exports, "TypescriptGenerator", { enumerable: true, get: function() {
      return generator_1.TypescriptGenerator;
    } });
  })(build);
  return build;
}
var common$1 = {};
var hasRequiredCommon$1;
function requireCommon$1() {
  if (hasRequiredCommon$1) return common$1;
  hasRequiredCommon$1 = 1;
  Object.defineProperty(common$1, "__esModule", { value: true });
  common$1.stringToBits = stringToBits;
  common$1.bitsToString = bitsToString;
  common$1.normalizeBitString = normalizeBitString;
  common$1.toCell = toCell;
  const core_1 = requireDist$4();
  const TLBRuntime_1 = requireTLBRuntime();
  function stringToBits(text) {
    const bytes = Buffer.from(text, "utf-8");
    return new core_1.BitString(bytes, 0, bytes.length * 8);
  }
  function bitsToString(bits) {
    if (bits.length % 8 !== 0) {
      throw new Error("Bits must be at least 8 bits");
    }
    let text = "";
    for (let offset = 0; offset < bits.length; offset += 8) {
      text += String.fromCharCode(parseInt(`0x${bits.substring(offset, 8).toString()}`));
    }
    return text;
  }
  function normalizeBitString(bits) {
    const length = bits.length;
    const newBuffer = Buffer.alloc(Math.ceil(length / 8));
    for (let i = 0; i < length; i++) {
      const byteIndex = Math.floor(i / 8);
      const bitIndex = 7 - i % 8;
      if (bits.at(i)) {
        newBuffer[byteIndex] |= 1 << bitIndex;
      }
    }
    return new core_1.BitString(newBuffer, 0, length);
  }
  function toCell(data) {
    try {
      return { success: true, value: core_1.Cell.fromBase64(data) };
    } catch (_) {
      try {
        return { success: true, value: core_1.Cell.fromHex(data) };
      } catch (_2) {
        return { success: false, error: new TLBRuntime_1.TLBDataError("Bad BoC string") };
      }
    }
  }
  return common$1;
}
var MathExprEvaluator = {};
var hasRequiredMathExprEvaluator;
function requireMathExprEvaluator() {
  if (hasRequiredMathExprEvaluator) return MathExprEvaluator;
  hasRequiredMathExprEvaluator = 1;
  Object.defineProperty(MathExprEvaluator, "__esModule", { value: true });
  MathExprEvaluator.MathExprEvaluator = void 0;
  const tlb_codegen_1 = requireBuild();
  let MathExprEvaluator$1 = class MathExprEvaluator2 {
    variables;
    constructor(variables = /* @__PURE__ */ new Map()) {
      this.variables = variables;
    }
    static calculateBitsForLessThan(n) {
      if (n <= 0)
        return 0;
      if (n === 1)
        return 0;
      const maxValue = n - 1;
      if (maxValue === 0)
        return 0;
      return Math.ceil(Math.log2(maxValue + 1));
    }
    static calculateBitsForLessThanOrEqual(n) {
      if (n < 0)
        return 0;
      if (n === 0)
        return 0;
      return Math.ceil(Math.log2(n + 1));
    }
    evaluate(expr) {
      if (expr instanceof tlb_codegen_1.TLBNumberExpr) {
        return expr.n;
      }
      if (expr instanceof tlb_codegen_1.TLBVarExpr) {
        const value = this.variables.get(expr.x);
        if (value === void 0) {
          throw new Error(`Variable ${expr.x} is not defined`);
        }
        return value;
      }
      if (expr instanceof tlb_codegen_1.TLBBinaryOp) {
        const left = this.evaluate(expr.left);
        const right = this.evaluate(expr.right);
        switch (expr.operation) {
          case "+":
            return left + right;
          case "-":
            return left - right;
          case "*":
            return left * right;
          case "/":
            return Math.floor(left / right);
          case "%":
            return left % right;
          case "<<":
            return left << right;
          case ">>":
            return left >> right;
          case "&":
            return left & right;
          case "|":
            return left | right;
          case "^":
            return left ^ right;
          case "==":
            return left === right ? 1 : 0;
          case "!=":
            return left !== right ? 1 : 0;
          case "<":
            return left < right ? 1 : 0;
          case "<=":
            return left <= right ? 1 : 0;
          case ">":
            return left > right ? 1 : 0;
          case ">=":
            return left >= right ? 1 : 0;
          case "=":
            return left === right ? 1 : 0;
          default:
            throw new Error(`Unknown operation: ${expr.operation}`);
        }
      }
      if (expr instanceof tlb_codegen_1.TLBUnaryOp) {
        const operation = expr.operation;
        switch (operation) {
          case ".": {
            const innerExpr = expr.value;
            if (innerExpr instanceof tlb_codegen_1.TLBBinaryOp && innerExpr.operation === "-") {
              const left = this.evaluate(innerExpr.left);
              const right = this.evaluate(innerExpr.right);
              if (right === 1) {
                return MathExprEvaluator2.calculateBitsForLessThan(left);
              }
              return left - right;
            }
            if (innerExpr instanceof tlb_codegen_1.TLBNumberExpr) {
              return MathExprEvaluator2.calculateBitsForLessThanOrEqual(innerExpr.n);
            }
            return this.evaluate(innerExpr);
          }
          case "-":
            return -this.evaluate(expr.value);
          case "~":
            return ~this.evaluate(expr.value);
          case "!":
            return this.evaluate(expr.value) ? 0 : 1;
          default:
            throw new Error(`Unknown unary operation: ${operation}`);
        }
      }
      throw new Error(`Unsupported expression type: ${typeof expr}`);
    }
  };
  MathExprEvaluator.MathExprEvaluator = MathExprEvaluator$1;
  return MathExprEvaluator;
}
var Result = {};
var hasRequiredResult;
function requireResult() {
  if (hasRequiredResult) return Result;
  hasRequiredResult = 1;
  Object.defineProperty(Result, "__esModule", { value: true });
  Result.error = error2;
  Result.unwrap = unwrap;
  function error2(result) {
    return result instanceof Error ? result : new Error(String(result));
  }
  function unwrap(result) {
    if (result.success) {
      return result.value;
    }
    throw error2(result.error);
  }
  return Result;
}
var hasRequiredTLBRuntime;
function requireTLBRuntime() {
  if (hasRequiredTLBRuntime) return TLBRuntime;
  hasRequiredTLBRuntime = 1;
  Object.defineProperty(TLBRuntime, "__esModule", { value: true });
  TLBRuntime.TLBRuntime = TLBRuntime.TLBDataError = TLBRuntime.TLBSchemaError = TLBRuntime.TLBRuntimeError = void 0;
  TLBRuntime.parseTLB = parseTLB;
  const core_1 = requireDist$4();
  const tlb_codegen_1 = requireBuild();
  const tlb_parser_1 = requireDist$3();
  const common_1 = requireCommon$1();
  const MathExprEvaluator_1 = requireMathExprEvaluator();
  const Result_1 = requireResult();
  class TLBRuntimeError extends Error {
  }
  TLBRuntime.TLBRuntimeError = TLBRuntimeError;
  class TLBSchemaError extends TLBRuntimeError {
  }
  TLBRuntime.TLBSchemaError = TLBSchemaError;
  class TLBDataError extends TLBRuntimeError {
  }
  TLBRuntime.TLBDataError = TLBDataError;
  function tagKey(tag) {
    return `0b${BigInt(tag.binary).toString(2).padStart(tag.bitLen, "0")}`;
  }
  let TLBRuntime$1 = class TLBRuntime2 {
    schema;
    types;
    lastTypeName;
    config;
    tagMap = /* @__PURE__ */ new Map();
    maxSizeTag = 0;
    constructor(schema2, types2, lastTypeName, config = {}) {
      this.schema = schema2;
      this.types = types2;
      this.lastTypeName = lastTypeName;
      this.config = config;
      config.autoText = config.autoText || true;
      for (const type of this.types.values()) {
        for (const item of type.constructors) {
          if (item.tag.bitLen > 0) {
            if (item.tag.bitLen > this.maxSizeTag) {
              this.maxSizeTag = item.tag.bitLen;
            }
            const key2 = tagKey(item.tag);
            this.tagMap.set(key2, { type, item });
          }
        }
      }
    }
    static from(schema2, config = {}) {
      try {
        const tree = (0, tlb_parser_1.ast)(schema2);
        const code = (0, tlb_codegen_1.getTLBCodeByAST)(tree, schema2);
        const pared = schema2.split("=");
        const lastTypeName = pared[pared.length - 1].split(";")[0].trim().split(" ")[0].trim();
        return {
          success: true,
          value: new TLBRuntime2(schema2, code.types, lastTypeName, config)
        };
      } catch (error2) {
      }
      return { success: false, error: new TLBSchemaError("Bad Schema") };
    }
    changeSchema(schema2) {
      if (this.schema === schema2) {
        return {
          success: true,
          value: this
        };
      }
      return TLBRuntime2.from(schema2, this.config);
    }
    parseCell(data) {
      return (0, Result_1.unwrap)(this.deserialize(data));
    }
    encodeCell(data) {
      if (typeof data === "string") {
        data = JSON.parse(data);
      }
      return (0, Result_1.unwrap)(this.serialize(data)).endCell();
    }
    findByTag(slice) {
      const savedBits = slice.remainingBits;
      const maxLen = Math.min(this.maxSizeTag, savedBits);
      for (let len = maxLen; len >= 1; len--) {
        if (savedBits < len)
          continue;
        const tagValue = slice.preloadUint(len);
        const key2 = tagKey({
          bitLen: len,
          binary: `0x${tagValue.toString(16)}`
        });
        const type = this.tagMap.get(key2);
        if (type) {
          return type;
        }
      }
      return null;
    }
    deserialize(data, findByTag = false) {
      if (typeof data === "string") {
        const result = (0, common_1.toCell)(data);
        if (!result.success) {
          return result;
        }
        data = result.value;
      }
      const slice = data.asSlice();
      if (findByTag) {
        const find = this.findByTag(slice);
        if (find) {
          return this.deserializeConstructor(find.type, find.item, slice);
        }
      }
      const types2 = Array.from(this.types.keys());
      try {
        const result = this.deserializeByTypeName(this.lastTypeName, slice.clone());
        if (result.success) {
          return result;
        }
      } catch (error2) {
        if (error2 instanceof Error) {
          throw error2;
        } else {
          throw new TLBDataError("Failed to deserialize");
        }
      }
      for (const typeName of types2.slice().reverse()) {
        if (typeName === this.lastTypeName)
          continue;
        const result = this.deserializeByTypeName(typeName, slice.clone());
        if (result.success) {
          return result;
        }
      }
      return { success: false, error: new TLBDataError("No matching constructor") };
    }
    // Deserialize data from a Slice based on a TL-B type name
    deserializeByTypeName(typeName, slice) {
      const type = this.types.get(typeName);
      if (!type) {
        return {
          success: false,
          error: new TLBDataError(`Type ${typeName} not found in TL-B schema`)
        };
      }
      return this.deserializeType(type, slice);
    }
    serialize(data) {
      const typeKind = data.kind;
      if (!typeKind) {
        return {
          success: false,
          error: new TLBDataError("Data must by typed")
        };
      }
      return this.serializeByTypeName(typeKind, data);
    }
    // Serialize data to a Builder based on a TL-B type name
    serializeByTypeName(typeKind, data) {
      const sep = typeKind.indexOf("_");
      const typeName = sep === -1 ? typeKind : typeKind.slice(0, sep);
      const type = this.types.get(typeName);
      if (!type) {
        return {
          success: false,
          error: new TLBDataError(`Type ${typeName} not found in TL-B schema`)
        };
      }
      const value = (0, core_1.beginCell)();
      this.serializeType(type, data, value);
      return {
        success: true,
        value
      };
    }
    deserializeType(type, data, args = [], initialVariables) {
      for (const constructor of type.constructors) {
        const prev = data.clone();
        const result = this.deserializeConstructor(type, constructor, prev, args, initialVariables);
        if (result.success) {
          const bitsUsed = data.remainingBits - prev.remainingBits;
          const refsUsed = data.remainingRefs - prev.remainingRefs;
          if (bitsUsed > 0) {
            data.skip(bitsUsed);
          }
          for (let i = 0; i < refsUsed; i++) {
            data.loadRef();
          }
          return result;
        }
      }
      return {
        success: false,
        error: new TLBDataError(`Failed to deserialize type ${type.name} no matching constructor found`)
      };
    }
    deserializeConstructor(type, constructor, slice, args = [], initialVariables) {
      const kind = type.constructors.length > 1 ? `${type.name}_${constructor.name}` : type.name;
      if (constructor.tag.bitLen > 0) {
        const len = constructor.tag.bitLen;
        if (slice.remainingBits < len) {
          return {
            success: false,
            error: new TLBDataError(`Not enough bits to read tag for ${kind}`)
          };
        }
        const preloadedTag = `0b${slice.loadUint(len).toString(2).padStart(len, "0")}`;
        const expectedTag = tagKey(constructor.tag);
        if (preloadedTag !== expectedTag) {
          return {
            success: false,
            error: new TLBDataError(`Failed to deserialize type ${kind}`)
          };
        }
      }
      const variables = new Map(initialVariables);
      if (args.length > 0 && constructor.parameters.length > 0) {
        const evaluator2 = new MathExprEvaluator_1.MathExprEvaluator(variables);
        for (let i = 0; i < Math.min(args.length, constructor.parameters.length); i++) {
          const param = constructor.parameters[i];
          const arg = args[i];
          let argValue = void 0;
          try {
            if (arg.kind === "TLBExprMathType") {
              argValue = evaluator2.evaluate(arg.initialExpr);
            } else if (arg.kind === "TLBNumberType") {
              argValue = evaluator2.evaluate(arg.bits);
            }
          } catch (error2) {
          }
          if (param.argName && typeof argValue === "number") {
            variables.set(param.argName, argValue);
          }
          try {
            if (param.variable?.name && typeof argValue === "number") {
              const varName = param.variable.name;
              let solved = false;
              if (param.paramExpr) {
                const expr = param.paramExpr;
                let found;
                for (let cand = 0; cand <= 1024; cand++) {
                  const trial = new Map(variables);
                  trial.set(varName, cand);
                  const v2 = new MathExprEvaluator_1.MathExprEvaluator(trial).evaluate(expr);
                  if (v2 === argValue) {
                    found = cand;
                    break;
                  }
                }
                if (typeof found === "number") {
                  variables.set(varName, found);
                  solved = true;
                }
              }
              if (!solved && param.variable.deriveExpr) {
                if (variables.get(varName) === void 0) {
                  let found;
                  for (let cand = 0; cand <= 1024; cand++) {
                    const trial = new Map(variables);
                    trial.set(varName, cand);
                    const v2 = new MathExprEvaluator_1.MathExprEvaluator(trial).evaluate(param.variable.deriveExpr);
                    if (v2 === argValue) {
                      found = cand;
                      break;
                    }
                  }
                  if (typeof found === "number") {
                    variables.set(varName, found);
                    solved = true;
                  }
                }
              }
              if (!solved && !param.variable.negated) {
                variables.set(varName, argValue);
              }
            }
          } catch (error2) {
          }
        }
      }
      if (args.length === 0 && constructor.parameters.length > 0) {
        for (const param of constructor.parameters) {
          try {
            if (param.variable?.type === "#" && !param.variable.negated && !param.variable.isConst) {
              if (slice.remainingBits >= 32) {
                const val = Number(slice.loadUint(32));
                variables.set(param.variable.name, val);
              }
            }
          } catch (error2) {
          }
        }
      }
      if (constructor.fields.length === 0 && constructor.parameters.length === 1 && constructor.parameters[0].variable.type === "#" && variables.get(constructor.parameters[0].variable.name) === void 0 && slice.remainingBits >= 32) {
        try {
          const val = Number(slice.loadUint(32));
          variables.set(constructor.parameters[0].variable.name, val);
        } catch (error2) {
        }
      }
      if (args.length > 0 && constructor.parameters.length === 0 && constructor.variables.length > 0) {
        const evaluator2 = new MathExprEvaluator_1.MathExprEvaluator(variables);
        const numericVars = constructor.variables.filter((v2) => v2.type === "#");
        for (let i = 0; i < Math.min(args.length, numericVars.length); i++) {
          const v2 = numericVars[i];
          const arg = args[i];
          try {
            let argValue;
            if (arg.kind === "TLBExprMathType") {
              argValue = evaluator2.evaluate(arg.initialExpr);
            } else if (arg.kind === "TLBNumberType") {
              argValue = evaluator2.evaluate(arg.bits);
            }
            if (typeof argValue === "number") {
              variables.set(v2.name, argValue);
            }
          } catch (error2) {
          }
        }
      }
      let value = {
        kind
      };
      for (const field of constructor.fields) {
        if (field.subFields.length > 0) {
          if (slice.remainingRefs === 0) {
            return {
              success: false,
              error: new TLBDataError(`No more references available for field ${field.name}`)
            };
          }
          const ref = slice.loadRef();
          if (field.subFields.length === 1) {
            const subfield = field.subFields[0];
            if (subfield.fieldType.kind === "TLBCellType") {
              value[field.name] = ref;
            } else if (subfield.fieldType.kind === "TLBNamedType") {
              const refSlice = ref.beginParse(true);
              const type2 = this.types.get(subfield.fieldType.name);
              if (type2) {
                let initialSeed;
                if (type2.constructors.length > 0) {
                  const nestedCtor = type2.constructors[0];
                  const evaluator2 = new MathExprEvaluator_1.MathExprEvaluator(variables);
                  const forwardedArgs = subfield.fieldType.arguments ?? [];
                  const merged = new Map(variables);
                  if (nestedCtor.parameters.length > 0) {
                    for (let i = 0; i < Math.min(forwardedArgs.length, nestedCtor.parameters.length); i++) {
                      const param = nestedCtor.parameters[i];
                      const arg = forwardedArgs[i];
                      try {
                        let argValue;
                        if (arg.kind === "TLBExprMathType") {
                          argValue = evaluator2.evaluate(arg.initialExpr);
                        } else if (arg.kind === "TLBNumberType") {
                          argValue = evaluator2.evaluate(arg.bits);
                        }
                        if (typeof argValue === "number" && param.variable.type === "#" && !param.variable.negated) {
                          merged.set(param.variable.name, argValue);
                        }
                      } catch (error2) {
                      }
                    }
                    initialSeed = merged;
                  }
                }
                const result = this.deserializeType(type2, refSlice, subfield.fieldType.arguments, initialSeed);
                if (result.success) {
                  value[field.name] = result.value;
                } else {
                  return result;
                }
              } else {
                return {
                  success: false,
                  error: new TLBDataError(`Type ${subfield.fieldType.name} not found`)
                };
              }
            } else {
              const refSlice = ref.beginParse(true);
              value[field.name] = this.deserializeField(subfield, refSlice, variables, constructor, args);
            }
          } else {
            const refSlice = ref.beginParse(true);
            const subfields = {};
            for (const subfield of field.subFields) {
              subfields[subfield.name] = this.deserializeField(subfield, refSlice, variables, constructor, args);
            }
            value[field.name] = subfields;
          }
        } else {
          value[field.name] = this.deserializeField(field, slice, variables, constructor, args);
        }
      }
      if (constructor.parameters.length > 0) {
        for (const param of constructor.parameters) {
          try {
            if (param.variable?.name && param.variable.deriveExpr && variables.get(param.variable.name) === void 0) {
              const derived = new MathExprEvaluator_1.MathExprEvaluator(variables).evaluate(param.variable.deriveExpr);
              variables.set(param.variable.name, derived);
            }
          } catch (error2) {
          }
        }
      }
      const evaluator = new MathExprEvaluator_1.MathExprEvaluator(variables);
      for (const constraint of constructor.constraints) {
        if (evaluator.evaluate(constraint) !== 1) {
          return {
            success: false,
            error: new TLBDataError(`Failed to deserialize type ${kind} due to constraint`)
          };
        }
      }
      if (kind === "ExprType" && typeof value["x"] === "number") {
        value["x"] = BigInt(value["x"]);
      }
      const orderedValue = { kind };
      if (constructor.parameters.length > 0) {
        for (const param of constructor.parameters) {
          try {
            if (param.variable.type === "#" && !param.variable.negated && !param.variable.isConst) {
              const val = variables.get(param.variable.name);
              if (typeof val === "number") {
                orderedValue[param.variable.name] = val;
              }
            }
          } catch (error2) {
          }
        }
      } else if (constructor.variables.length > 0) {
        const fieldNamesSet = new Set(constructor.fields.map((f) => f.name));
        for (const v2 of constructor.variables) {
          try {
            if (v2.type === "#" && !v2.negated && !v2.isConst && !fieldNamesSet.has(v2.name)) {
              const val = variables.get(v2.name);
              if (typeof val === "number") {
                orderedValue[v2.name] = val;
              }
            }
          } catch (error2) {
          }
        }
      }
      if (Object.keys(orderedValue).length === 1 && constructor.parameters.length === 0 && constructor.variables.filter((v2) => v2.type === "#").length === 1) {
        const v2 = constructor.variables.find((vv) => vv.type === "#");
        const val = variables.get(v2.name);
        if (typeof val === "number") {
          orderedValue[v2.name] = val;
        }
      }
      const fieldNames = constructor.fields.map((f) => f.name).sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      for (const name of fieldNames) {
        orderedValue[name] = value[name];
      }
      return {
        success: true,
        value: orderedValue
      };
    }
    deserializeField(field, slice, variables, ctxConstructor, ctxArgs) {
      const value = this.deserializeFieldType(field.fieldType, slice, variables, ctxConstructor, ctxArgs);
      if (field.name && (field.fieldType.kind === "TLBNumberType" || field.fieldType.kind === "TLBVarIntegerType" || field.fieldType.kind === "TLBBoolType")) {
        variables.set(field.name, Number(value));
      }
      if (value && typeof value === "object") {
        for (const param of ctxConstructor.parameters) {
          if (param.variable?.type === "#" && !param.variable.negated && variables.get(param.variable.name) === void 0) {
            const extracted = this.extractNumericProperty(value, param.variable.name);
            if (typeof extracted === "number") {
              variables.set(param.variable.name, extracted);
            }
          }
        }
      }
      return value;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    extractNumericProperty(obj, name) {
      if (!obj || typeof obj !== "object")
        return void 0;
      if (typeof obj[name] === "number")
        return obj[name];
      for (const key2 of Object.keys(obj)) {
        const v2 = obj[key2];
        if (v2 && typeof v2 === "object") {
          const r = this.extractNumericProperty(v2, name);
          if (typeof r === "number")
            return r;
        }
      }
      return void 0;
    }
    deserializeFieldType(fieldType, slice, variables, ctxConstructor, ctxArgs) {
      const evaluator = new MathExprEvaluator_1.MathExprEvaluator(variables);
      switch (fieldType.kind) {
        case "TLBNumberType": {
          let bits;
          try {
            bits = evaluator.evaluate(fieldType.bits);
          } catch (e) {
            let rebound = false;
            if (ctxConstructor?.parameters?.length && ctxArgs?.length) {
              for (let i = 0; i < Math.min(ctxConstructor.parameters.length, ctxArgs.length); i++) {
                const p = ctxConstructor.parameters[i];
                const a = ctxArgs[i];
                if (p.variable?.type === "#") {
                  try {
                    let val2;
                    if (a.kind === "TLBExprMathType") {
                      val2 = new MathExprEvaluator_1.MathExprEvaluator(variables).evaluate(a.initialExpr);
                    } else if (a.kind === "TLBNumberType") {
                      val2 = new MathExprEvaluator_1.MathExprEvaluator(variables).evaluate(a.bits);
                    }
                    if (typeof val2 === "number") {
                      variables.set(p.variable.name, val2);
                      rebound = true;
                    }
                  } catch {
                  }
                }
              }
              if (rebound) {
                bits = new MathExprEvaluator_1.MathExprEvaluator(variables).evaluate(fieldType.bits);
              } else {
                throw e;
              }
            } else {
              throw e;
            }
          }
          const val = this.loadBigInt(slice, bits, fieldType.signed);
          const maxBits = fieldType.maxBits;
          const preferNumber = maxBits !== void 0 ? maxBits <= 32 : false;
          if (!preferNumber && bits > 32) {
            return val;
          }
          if (preferNumber || bits <= 32) {
            return Number(val);
          }
          return val;
        }
        case "TLBBoolType": {
          if (fieldType.value !== void 0) {
            return fieldType.value;
          }
          return slice.loadBit();
        }
        case "TLBBitsType": {
          const bits = evaluator.evaluate(fieldType.bits);
          const raw = slice.loadBits(bits);
          if (this.config.autoText && bits % 8 === 0) {
            return (0, common_1.bitsToString)(raw);
          }
          if (bits === 1) {
            return raw.at(0);
          }
          return (0, common_1.normalizeBitString)(raw);
        }
        case "TLBNamedType": {
          const p = ctxConstructor.parametersMap.get(fieldType.name);
          if (p && p.variable.type === "Type") {
            const paramIndex = ctxConstructor.parameters.findIndex((pp) => pp.variable.name === p.variable.name);
            if (paramIndex >= 0 && ctxArgs[paramIndex]) {
              return this.deserializeFieldType(ctxArgs[paramIndex], slice, variables, ctxConstructor, ctxArgs);
            }
          }
          if (fieldType.name === "Bool") {
            return slice.loadBit();
          }
          if (fieldType.name === "Any") {
            const b = (0, core_1.beginCell)();
            const bitsLeft = slice.remainingBits;
            if (bitsLeft > 0) {
              b.storeBits(slice.loadBits(bitsLeft));
            }
            while (slice.remainingRefs > 0) {
              b.storeRef(slice.loadRef());
            }
            return b.endCell();
          }
          const type = this.types.get(fieldType.name);
          if (!type) {
            throw new TLBDataError(`Type ${fieldType.name} not found in TL-B schema`);
          }
          const forwardedArgs = fieldType.arguments ?? [];
          let childVars = new Map(variables);
          if (type.constructors.length > 0 && forwardedArgs.length > 0) {
            const nestedCtor = type.constructors[0];
            const evaluator2 = new MathExprEvaluator_1.MathExprEvaluator(childVars);
            const max = Math.min(forwardedArgs.length, nestedCtor.parameters.length);
            for (let i = 0; i < max; i++) {
              const param = nestedCtor.parameters[i];
              const arg = forwardedArgs[i];
              if (param.variable?.type === "#") {
                try {
                  let val;
                  if (arg.kind === "TLBExprMathType") {
                    val = evaluator2.evaluate(arg.initialExpr);
                  } else if (arg.kind === "TLBNumberType") {
                    val = evaluator2.evaluate(arg.bits);
                  }
                  if (typeof val === "number") {
                    childVars.set(param.variable.name, val);
                  }
                } catch (error2) {
                }
              }
            }
          }
          return (0, Result_1.unwrap)(this.deserializeType(type, slice, forwardedArgs, childVars));
        }
        case "TLBCoinsType": {
          return slice.loadCoins();
        }
        case "TLBAddressType": {
          if (slice.preloadUint(2) !== 2) {
            if (slice.remainingBits === 2) {
              return null;
            }
            const type = slice.loadUint(2);
            if (type === 1) {
              const bits = slice.loadUint(9);
              return new core_1.ExternalAddress(slice.loadUintBig(bits), bits);
            }
          }
          return slice.loadAddress();
        }
        case "TLBCellType": {
          return slice.asCell();
        }
        case "TLBCellInsideType": {
          if (slice.remainingRefs === 0) {
            throw new TLBDataError("No more references available for TLBCellInsideType");
          }
          const ref = slice.loadRef();
          if (fieldType.value.kind === "TLBCellType") {
            return ref;
          }
          const refSlice = ref.beginParse();
          return this.deserializeFieldType(fieldType.value, refSlice, variables, ctxConstructor, ctxArgs);
        }
        case "TLBHashmapType": {
          const keySize = evaluator.evaluate(fieldType.key.expr);
          const parseValue = (sl) => this.deserializeFieldType(fieldType.value, sl, new Map(variables), ctxConstructor, ctxArgs);
          const emptyBig = () => core_1.Dictionary.empty(core_1.Dictionary.Keys.BigUint(keySize));
          const emptyNum = () => core_1.Dictionary.empty(core_1.Dictionary.Keys.Uint(keySize));
          if (keySize > 32) {
            const dict = fieldType.directStore ? slice.loadDictDirect(core_1.Dictionary.Keys.BigUint(keySize), {
              serialize: () => {
              },
              parse: parseValue
            }) : slice.loadDict(core_1.Dictionary.Keys.BigUint(keySize), { serialize: () => {
            }, parse: parseValue });
            return dict.size === 0 ? emptyBig() : dict;
          } else {
            const dict = fieldType.directStore ? slice.loadDictDirect(core_1.Dictionary.Keys.Uint(keySize), {
              serialize: () => {
              },
              parse: parseValue
            }) : slice.loadDict(core_1.Dictionary.Keys.Uint(keySize), { serialize: () => {
            }, parse: parseValue });
            return dict.size === 0 ? emptyNum() : dict;
          }
        }
        case "TLBVarIntegerType": {
          const size = evaluator.evaluate(fieldType.n);
          if (fieldType.signed) {
            return slice.loadVarIntBig(size);
          } else {
            return slice.loadVarUintBig(size);
          }
        }
        case "TLBMultipleType": {
          const times = evaluator.evaluate(fieldType.times);
          const result = [];
          for (let i = 0; i < times; i++) {
            result.push(this.deserializeFieldType(fieldType.value, slice, variables, ctxConstructor, ctxArgs));
          }
          return result;
        }
        case "TLBCondType": {
          const condition = evaluator.evaluate(fieldType.condition);
          if (condition) {
            return this.deserializeFieldType(fieldType.value, slice, variables, ctxConstructor, ctxArgs);
          }
          return void 0;
        }
        case "TLBTupleType": {
          const cell = slice.loadRef();
          return (0, core_1.parseTuple)(cell);
        }
        default:
          throw new TLBDataError(`Unsupported field type: ${fieldType.kind}`);
      }
    }
    // FIXME
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    serializeType(type, data, builder2) {
      const typeKind = data.kind;
      if (!typeKind) {
        throw new TLBDataError("Data must by typed");
      }
      const constructorName = typeKind.substring(type.name.length + 1);
      let constructor;
      if (constructorName) {
        constructor = type.constructors.find((c) => c.name === constructorName);
      } else if (type.constructors.length > 0) {
        constructor = type.constructors[0];
      }
      if (!constructor) {
        throw new TLBDataError(`Constructor not found for type ${typeKind}`);
      }
      if (constructor.tag.bitLen > 0) {
        const tag = BigInt(constructor.tag.binary);
        builder2.storeUint(tag, constructor.tag.bitLen);
      }
      const variables = /* @__PURE__ */ new Map();
      for (const field of constructor.fields) {
        if (!field.anonymous) {
          this.serializeField(field, data[field.name], builder2, variables);
        } else {
          this.serializeField(field, null, builder2, variables);
        }
      }
      const evaluator = new MathExprEvaluator_1.MathExprEvaluator(variables);
      for (const constraint of constructor.constraints) {
        if (evaluator.evaluate(constraint) !== 1) {
          throw new TLBDataError(`Constraint failed for type ${type.name}, constructor ${constructor.name}`);
        }
      }
    }
    // FIXME
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    serializeField(field, value, builder2, variables) {
      if (field.name && (field.fieldType.kind === "TLBNumberType" || field.fieldType.kind === "TLBVarIntegerType" || field.fieldType.kind === "TLBBoolType")) {
        variables.set(field.name, Number(value));
      }
      this.serializeFieldType(field.fieldType, value, builder2, variables);
    }
    serializeFieldType(fieldType, value, builder2, variables) {
      const evaluator = new MathExprEvaluator_1.MathExprEvaluator(variables);
      switch (fieldType.kind) {
        case "TLBNumberType": {
          const bits = evaluator.evaluate(fieldType.bits);
          builder2.storeUint(value, bits);
          break;
        }
        case "TLBBoolType": {
          if (fieldType.value !== void 0) {
            break;
          }
          builder2.storeBit(value ? 1 : 0);
          break;
        }
        case "TLBBitsType": {
          if (typeof value === "string") {
            value = (0, common_1.stringToBits)(value);
          }
          if (value instanceof core_1.BitString) {
            builder2.storeBits(value);
          }
          break;
        }
        case "TLBNamedType": {
          const type = this.types.get(fieldType.name);
          if (!type) {
            throw new TLBDataError(`Type ${fieldType.name} not found in TL-B schema`);
          }
          this.serializeType(type, value, builder2);
          break;
        }
        case "TLBCoinsType": {
          builder2.storeCoins(value);
          break;
        }
        case "TLBAddressType": {
          if (typeof value === "string") {
            value = core_1.Address.parse(value);
          }
          builder2.storeAddress(value);
          break;
        }
        case "TLBCellType": {
          builder2.storeRef(value);
          break;
        }
        case "TLBCellInsideType": {
          const nestedBuilder = (0, core_1.beginCell)();
          this.serializeFieldType(fieldType.value, value, nestedBuilder, variables);
          builder2.storeRef(nestedBuilder.endCell());
          break;
        }
        case "TLBHashmapType": {
          const keySize = evaluator.evaluate(fieldType.key.expr);
          const dict = core_1.Dictionary.empty(core_1.Dictionary.Keys.BigInt(keySize), core_1.Dictionary.Values.Cell());
          if (value) {
            for (const [key2, dictValue] of Object.entries(value)) {
              const valueBuilder = (0, core_1.beginCell)();
              this.serializeFieldType(fieldType.value, dictValue, valueBuilder, new Map(variables));
              dict.set(BigInt(key2), valueBuilder.endCell());
            }
          }
          builder2.storeDict(dict);
          break;
        }
        case "TLBVarIntegerType": {
          const size = evaluator.evaluate(fieldType.n);
          if (fieldType.signed) {
            builder2.storeVarInt(value, size);
          } else {
            builder2.storeVarUint(value, size);
          }
          break;
        }
        case "TLBMultipleType": {
          const times = evaluator.evaluate(fieldType.times);
          for (let i = 0; i < times; i++) {
            this.serializeFieldType(fieldType.value, value[i], builder2, variables);
          }
          break;
        }
        case "TLBCondType": {
          const condition = evaluator.evaluate(fieldType.condition);
          if (condition) {
            this.serializeFieldType(fieldType.value, value, builder2, variables);
          }
          break;
        }
        case "TLBTupleType": {
          const cell = (0, core_1.serializeTuple)(value);
          builder2.storeRef(cell);
          break;
        }
        default:
          throw new TLBDataError(`Unsupported field type: ${fieldType.kind}`);
      }
    }
    loadBigInt(slice, bits, signed = false) {
      if (signed) {
        return slice.loadIntBig(bits);
      }
      return slice.loadUintBig(bits);
    }
  };
  TLBRuntime.TLBRuntime = TLBRuntime$1;
  function parseTLB(schema2) {
    return (0, Result_1.unwrap)(TLBRuntime$1.from(schema2));
  }
  return TLBRuntime;
}
var hasRequiredParser;
function requireParser() {
  if (hasRequiredParser) return parser;
  hasRequiredParser = 1;
  Object.defineProperty(parser, "__esModule", { value: true });
  parser.parseCell = parseCell;
  parser.encodeCell = encodeCell;
  parser.replacer = replacer;
  const core_1 = requireDist$4();
  const TLBRuntime_1 = requireTLBRuntime();
  function parseCell(schema2, data) {
    return (0, TLBRuntime_1.parseTLB)(schema2).parseCell(data);
  }
  function encodeCell(schema2, data) {
    return (0, TLBRuntime_1.parseTLB)(schema2).encodeCell(data);
  }
  function replacer(_key, value) {
    if (typeof value === "bigint") {
      return value.toString();
    } else if (value instanceof core_1.Address) {
      return value.toString();
    } else if (value instanceof core_1.BitString) {
      return value.toString();
    } else if (value instanceof core_1.Cell) {
      return value.toBoc().toString("base64");
    }
    return value;
  }
  return parser;
}
var schema = {};
var hasRequiredSchema;
function requireSchema() {
  if (hasRequiredSchema) return schema;
  hasRequiredSchema = 1;
  Object.defineProperty(schema, "__esModule", { value: true });
  schema.blockSchema = void 0;
  schema.blockSchema = `// https://github.com/ton-blockchain/ton/raw/774371bdc9f6107fd05106c1fd559e8903e0513d/crypto/block/block.tlb
unit$_ = Unit;
true$_ = True;
// EMPTY False;
bool_false$0 = Bool;
bool_true$1 = Bool;
bool_false$0 = BoolFalse;
bool_true$1 = BoolTrue;
nothing$0 {X:Type} = Maybe X;
just$1 {X:Type} value:X = Maybe X;
left$0 {X:Type} {Y:Type} value:X = Either X Y;
right$1 {X:Type} {Y:Type} value:Y = Either X Y;
pair$_ {X:Type} {Y:Type} first:X second:Y = Both X Y;

bit$_ (## 1) = Bit;
/*
 *
 *   FROM hashmap.tlb
 *
 */
// ordinary Hashmap / HashmapE, with fixed length keys
//
hm_edge#_ {n:#} {X:Type} {l:#} {m:#} label:(HmLabel ~l n) 
          {n = (~m) + l} node:(HashmapNode m X) = Hashmap n X;

hmn_leaf#_ {X:Type} value:X = HashmapNode 0 X;
hmn_fork#_ {n:#} {X:Type} left:^(Hashmap n X) 
           right:^(Hashmap n X) = HashmapNode (n + 1) X;

hml_short$0 {m:#} {n:#} len:(Unary ~n) {n <= m} s:(n * Bit) = HmLabel ~n m;
hml_long$10 {m:#} n:(#<= m) s:(n * Bit) = HmLabel ~n m;
hml_same$11 {m:#} v:Bit n:(#<= m) = HmLabel ~n m;

unary_zero$0 = Unary ~0;
unary_succ$1 {n:#} x:(Unary ~n) = Unary ~(n + 1);

hme_empty$0 {n:#} {X:Type} = HashmapE n X;
hme_root$1 {n:#} {X:Type} root:^(Hashmap n X) = HashmapE n X;

// true#_ = True;
_ {n:#} _:(Hashmap n True) = BitstringSet n;

//  HashmapAug, hashmap with an extra value 
//   (augmentation) of type Y at every node
//
ahm_edge#_ {n:#} {X:Type} {Y:Type} {l:#} {m:#} 
  label:(HmLabel ~l n) {n = (~m) + l} 
  node:(HashmapAugNode m X Y) = HashmapAug n X Y;
ahmn_leaf#_ {X:Type} {Y:Type} extra:Y value:X = HashmapAugNode 0 X Y;
ahmn_fork#_ {n:#} {X:Type} {Y:Type} left:^(HashmapAug n X Y)
  right:^(HashmapAug n X Y) extra:Y = HashmapAugNode (n + 1) X Y;

ahme_empty$0 {n:#} {X:Type} {Y:Type} extra:Y 
          = HashmapAugE n X Y;
ahme_root$1 {n:#} {X:Type} {Y:Type} root:^(HashmapAug n X Y) 
  extra:Y = HashmapAugE n X Y;

// VarHashmap / VarHashmapE, with variable-length keys
//
vhm_edge#_ {n:#} {X:Type} {l:#} {m:#} label:(HmLabel ~l n) 
           {n = (~m) + l} node:(VarHashmapNode m X) 
           = VarHashmap n X;
vhmn_leaf$00 {n:#} {X:Type} value:X = VarHashmapNode n X;
vhmn_fork$01 {n:#} {X:Type} left:^(VarHashmap n X) 
             right:^(VarHashmap n X) value:(Maybe X) 
             = VarHashmapNode (n + 1) X;
vhmn_cont$1 {n:#} {X:Type} branch:Bit child:^(VarHashmap n X) 
            value:X = VarHashmapNode (n + 1) X;

// nothing$0 {X:Type} = Maybe X;
// just$1 {X:Type} value:X = Maybe X;

vhme_empty$0 {n:#} {X:Type} = VarHashmapE n X;
vhme_root$1 {n:#} {X:Type} root:^(VarHashmap n X) 
            = VarHashmapE n X;

//
// PfxHashmap / PfxHashmapE, with variable-length keys
//                           constituting a prefix code
//

phm_edge#_ {n:#} {X:Type} {l:#} {m:#} label:(HmLabel ~l n) 
           {n = (~m) + l} node:(PfxHashmapNode m X) 
           = PfxHashmap n X;

phmn_leaf$0 {n:#} {X:Type} value:X = PfxHashmapNode n X;
phmn_fork$1 {n:#} {X:Type} left:^(PfxHashmap n X) 
            right:^(PfxHashmap n X) = PfxHashmapNode (n + 1) X;

phme_empty$0 {n:#} {X:Type} = PfxHashmapE n X;
phme_root$1 {n:#} {X:Type} root:^(PfxHashmap n X) 
            = PfxHashmapE n X;
/*
 *
 *  END hashmap.tlb
 *
 */
//
// TON BLOCK LAYOUT
//
addr_none$00 = MsgAddressExt;
addr_extern$01 len:(## 9) external_address:(bits len) 
             = MsgAddressExt;
anycast_info$_ depth:(#<= 30) { depth >= 1 }
   rewrite_pfx:(bits depth) = Anycast;
addr_std$10 anycast:(Maybe Anycast) 
   workchain_id:int8 address:bits256  = MsgAddressInt;
addr_var$11 anycast:(Maybe Anycast) addr_len:(## 9) 
   workchain_id:int32 address:(bits addr_len) = MsgAddressInt;
_ _:MsgAddressInt = MsgAddress;
_ _:MsgAddressExt = MsgAddress;
//
var_uint$_ {n:#} len:(#< n) value:(uint (len * 8))
         = VarUInteger n;
var_int$_ {n:#} len:(#< n) value:(int (len * 8)) 
        = VarInteger n;
nanograms$_ amount:(VarUInteger 16) = Grams;

_ grams:Grams = Coins;

//
extra_currencies$_ dict:(HashmapE 32 (VarUInteger 32)) 
                 = ExtraCurrencyCollection;
currencies$_ grams:Grams other:ExtraCurrencyCollection 
           = CurrencyCollection;
//
int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool
  src:MsgAddressInt dest:MsgAddressInt 
  value:CurrencyCollection ihr_fee:Grams fwd_fee:Grams
  created_lt:uint64 created_at:uint32 = CommonMsgInfo;
ext_in_msg_info$10 src:MsgAddressExt dest:MsgAddressInt 
  import_fee:Grams = CommonMsgInfo;
ext_out_msg_info$11 src:MsgAddressInt dest:MsgAddressExt
  created_lt:uint64 created_at:uint32 = CommonMsgInfo;

int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool
  src:MsgAddress dest:MsgAddressInt 
  value:CurrencyCollection ihr_fee:Grams fwd_fee:Grams
  created_lt:uint64 created_at:uint32 = CommonMsgInfoRelaxed;
ext_out_msg_info$11 src:MsgAddress dest:MsgAddressExt
  created_lt:uint64 created_at:uint32 = CommonMsgInfoRelaxed;

tick_tock$_ tick:Bool tock:Bool = TickTock;

_ fixed_prefix_length:(Maybe (## 5)) special:(Maybe TickTock)
  code:(Maybe ^Cell) data:(Maybe ^Cell)
  library:(Maybe ^Cell) = StateInit;

// StateInitWithLibs is used to validate sent and received messages
_ fixed_prefix_length:(Maybe (## 5)) special:(Maybe TickTock)
  code:(Maybe ^Cell) data:(Maybe ^Cell)
  library:(HashmapE 256 SimpleLib) = StateInitWithLibs;

simple_lib$_ public:Bool root:^Cell = SimpleLib;

message$_ {X:Type} info:CommonMsgInfo
  init:(Maybe (Either StateInit ^StateInit))
  body:(Either X ^X) = Message X;

message$_ {X:Type} info:CommonMsgInfoRelaxed
  init:(Maybe (Either StateInit ^StateInit))
  body:(Either X ^X) = MessageRelaxed X;
  
_ (Message Any) = MessageAny;

//
interm_addr_regular$0 use_dest_bits:(#<= 96) 
  = IntermediateAddress;
interm_addr_simple$10 workchain_id:int8 addr_pfx:uint64 
  = IntermediateAddress;
interm_addr_ext$11 workchain_id:int32 addr_pfx:uint64
  = IntermediateAddress;
msg_envelope#4 cur_addr:IntermediateAddress 
  next_addr:IntermediateAddress fwd_fee_remaining:Grams 
  msg:^(Message Any) = MsgEnvelope;
msg_metadata#0 depth:uint32 initiator_addr:MsgAddressInt initiator_lt:uint64 = MsgMetadata;
msg_envelope_v2#5 cur_addr:IntermediateAddress
  next_addr:IntermediateAddress fwd_fee_remaining:Grams
  msg:^(Message Any)
  emitted_lt:(Maybe uint64)
  metadata:(Maybe MsgMetadata) = MsgEnvelope;
//
msg_import_ext$000 msg:^(Message Any) transaction:^Transaction 
              = InMsg;
msg_import_ihr$010 msg:^(Message Any) transaction:^Transaction 
    ihr_fee:Grams proof_created:^Cell = InMsg;
msg_import_imm$011 in_msg:^MsgEnvelope
    transaction:^Transaction fwd_fee:Grams = InMsg;
msg_import_fin$100 in_msg:^MsgEnvelope 
    transaction:^Transaction fwd_fee:Grams = InMsg;
msg_import_tr$101  in_msg:^MsgEnvelope out_msg:^MsgEnvelope 
    transit_fee:Grams = InMsg;
msg_discard_fin$110 in_msg:^MsgEnvelope transaction_id:uint64 
    fwd_fee:Grams = InMsg;
msg_discard_tr$111 in_msg:^MsgEnvelope transaction_id:uint64 
    fwd_fee:Grams proof_delivered:^Cell = InMsg;
msg_import_deferred_fin$00100 in_msg:^MsgEnvelope
    transaction:^Transaction fwd_fee:Grams = InMsg;
msg_import_deferred_tr$00101 in_msg:^MsgEnvelope out_msg:^MsgEnvelope = InMsg;
//
import_fees$_ fees_collected:Grams 
  value_imported:CurrencyCollection = ImportFees;

_ (HashmapAugE 256 InMsg ImportFees) = InMsgDescr;

msg_export_ext$000 msg:^(Message Any)
    transaction:^Transaction = OutMsg;
msg_export_imm$010 out_msg:^MsgEnvelope 
    transaction:^Transaction reimport:^InMsg = OutMsg;
msg_export_new$001 out_msg:^MsgEnvelope 
    transaction:^Transaction = OutMsg;
msg_export_tr$011  out_msg:^MsgEnvelope 
    imported:^InMsg = OutMsg;
msg_export_deq$1100 out_msg:^MsgEnvelope
    import_block_lt:uint63 = OutMsg;
msg_export_deq_short$1101 msg_env_hash:bits256
    next_workchain:int32 next_addr_pfx:uint64
    import_block_lt:uint64 = OutMsg;
msg_export_tr_req$111 out_msg:^MsgEnvelope 
    imported:^InMsg = OutMsg;
msg_export_deq_imm$100 out_msg:^MsgEnvelope 
    reimport:^InMsg = OutMsg;
msg_export_new_defer$10100 out_msg:^MsgEnvelope
    transaction:^Transaction = OutMsg;
msg_export_deferred_tr$10101  out_msg:^MsgEnvelope
    imported:^InMsg = OutMsg;

_ enqueued_lt:uint64 out_msg:^MsgEnvelope = EnqueuedMsg;

_ (HashmapAugE 256 OutMsg CurrencyCollection) = OutMsgDescr;

_ (HashmapAugE 352 EnqueuedMsg uint64) = OutMsgQueue;

processed_upto$_ last_msg_lt:uint64 last_msg_hash:bits256 = ProcessedUpto;
// key is [ shard:uint64 mc_seqno:uint32 ]  
_ (HashmapE 96 ProcessedUpto) = ProcessedInfo;

ihr_pending$_ import_lt:uint64 = IhrPendingSince;
_ (HashmapE 320 IhrPendingSince) = IhrPendingInfo;

// key - created_lt
_ messages:(HashmapE 64 EnqueuedMsg) count:uint48 = AccountDispatchQueue;
// key - sender address, aug - min created_lt
_ (HashmapAugE 256 AccountDispatchQueue uint64) = DispatchQueue;

out_msg_queue_extra#0 dispatch_queue:DispatchQueue out_queue_size:(Maybe uint48) = OutMsgQueueExtra;

_ out_queue:OutMsgQueue proc_info:ProcessedInfo
  extra:(Maybe OutMsgQueueExtra) = OutMsgQueueInfo;

storage_extra_none$000 = StorageExtraInfo;
storage_extra_info$001 dict_hash:uint256 = StorageExtraInfo;

storage_used$_ cells:(VarUInteger 7) bits:(VarUInteger 7) = StorageUsed;

storage_info$_ used:StorageUsed storage_extra:StorageExtraInfo last_paid:uint32
              due_payment:(Maybe Grams) = StorageInfo;

account_none$0 = Account;
account$1 addr:MsgAddressInt storage_stat:StorageInfo
          storage:AccountStorage = Account;

account_storage$_ last_trans_lt:uint64
    balance:CurrencyCollection state:AccountState 
  = AccountStorage;

account_uninit$00 = AccountState;
account_active$1 _:StateInit = AccountState;
account_frozen$01 state_hash:bits256 = AccountState;

acc_state_uninit$00 = AccountStatus;
acc_state_frozen$01 = AccountStatus;
acc_state_active$10 = AccountStatus;
acc_state_nonexist$11 = AccountStatus;

account_descr$_ account:^Account last_trans_hash:bits256 
  last_trans_lt:uint64 = ShardAccount;

depth_balance$_ split_depth:(#<= 30) balance:CurrencyCollection = DepthBalanceInfo;

_ (HashmapAugE 256 ShardAccount DepthBalanceInfo) = ShardAccounts;

transaction$0111 account_addr:bits256 lt:uint64 
  prev_trans_hash:bits256 prev_trans_lt:uint64 now:uint32
  outmsg_cnt:uint15
  orig_status:AccountStatus end_status:AccountStatus
  ^[ in_msg:(Maybe ^(Message Any)) out_msgs:(HashmapE 15 ^(Message Any)) ]
  total_fees:CurrencyCollection state_update:^(HASH_UPDATE Account)
  description:^TransactionDescr = Transaction;

!merkle_update#04 {X:Type} old_hash:bits256 new_hash:bits256 old_depth:uint16 new_depth:uint16
  old:^X new:^X = MERKLE_UPDATE X;
update_hashes#72 {X:Type} old_hash:bits256 new_hash:bits256
  = HASH_UPDATE X;
!merkle_proof#03 {X:Type} virtual_hash:bits256 depth:uint16 virtual_root:^X = MERKLE_PROOF X;

acc_trans#5 account_addr:bits256
            transactions:(HashmapAug 64 ^Transaction CurrencyCollection)
            state_update:^(HASH_UPDATE Account)
          = AccountBlock;

_ (HashmapAugE 256 AccountBlock CurrencyCollection) = ShardAccountBlocks;
//
tr_phase_storage$_ storage_fees_collected:Grams 
  storage_fees_due:(Maybe Grams)
  status_change:AccStatusChange
  = TrStoragePhase;

acst_unchanged$0 = AccStatusChange;  // x -> x
acst_frozen$10 = AccStatusChange;    // init -> frozen
acst_deleted$11 = AccStatusChange;   // frozen -> deleted

tr_phase_credit$_ due_fees_collected:(Maybe Grams)
  credit:CurrencyCollection = TrCreditPhase;

tr_phase_compute_skipped$0 reason:ComputeSkipReason
  = TrComputePhase;
tr_phase_compute_vm$1 success:Bool msg_state_used:Bool 
  account_activated:Bool gas_fees:Grams
  ^[ gas_used:(VarUInteger 7)
  gas_limit:(VarUInteger 7) gas_credit:(Maybe (VarUInteger 3))
  mode:int8 exit_code:int32 exit_arg:(Maybe int32)
  vm_steps:uint32
  vm_init_state_hash:bits256 vm_final_state_hash:bits256 ]
  = TrComputePhase;
cskip_no_state$00 = ComputeSkipReason;
cskip_bad_state$01 = ComputeSkipReason;
cskip_no_gas$10 = ComputeSkipReason;
cskip_suspended$110 = ComputeSkipReason;

tr_phase_action$_ success:Bool valid:Bool no_funds:Bool
  status_change:AccStatusChange
  total_fwd_fees:(Maybe Grams) total_action_fees:(Maybe Grams)
  result_code:int32 result_arg:(Maybe int32) tot_actions:uint16
  spec_actions:uint16 skipped_actions:uint16 msgs_created:uint16 
  action_list_hash:bits256 tot_msg_size:StorageUsed
  = TrActionPhase;

tr_phase_bounce_negfunds$00 = TrBouncePhase;
tr_phase_bounce_nofunds$01 msg_size:StorageUsed
  req_fwd_fees:Grams = TrBouncePhase;
tr_phase_bounce_ok$1 msg_size:StorageUsed
  msg_fees:Grams fwd_fees:Grams = TrBouncePhase;
//
trans_ord$0000 credit_first:Bool
  storage_ph:(Maybe TrStoragePhase)
  credit_ph:(Maybe TrCreditPhase)
  compute_ph:TrComputePhase action:(Maybe ^TrActionPhase)
  aborted:Bool bounce:(Maybe TrBouncePhase)
  destroyed:Bool
  = TransactionDescr;

trans_storage$0001 storage_ph:TrStoragePhase
  = TransactionDescr;

trans_tick_tock$001 is_tock:Bool storage_ph:TrStoragePhase
  compute_ph:TrComputePhase action:(Maybe ^TrActionPhase)
  aborted:Bool destroyed:Bool = TransactionDescr;
//
split_merge_info$_ cur_shard_pfx_len:(## 6)
  acc_split_depth:(## 6) this_addr:bits256 sibling_addr:bits256
  = SplitMergeInfo;
trans_split_prepare$0100 split_info:SplitMergeInfo
  storage_ph:(Maybe TrStoragePhase)
  compute_ph:TrComputePhase action:(Maybe ^TrActionPhase)
  aborted:Bool destroyed:Bool
  = TransactionDescr;
trans_split_install$0101 split_info:SplitMergeInfo
  prepare_transaction:^Transaction
  installed:Bool = TransactionDescr;

trans_merge_prepare$0110 split_info:SplitMergeInfo
  storage_ph:TrStoragePhase aborted:Bool
  = TransactionDescr;
trans_merge_install$0111 split_info:SplitMergeInfo
  prepare_transaction:^Transaction
  storage_ph:(Maybe TrStoragePhase)
  credit_ph:(Maybe TrCreditPhase)
  compute_ph:TrComputePhase action:(Maybe ^TrActionPhase)
  aborted:Bool destroyed:Bool
  = TransactionDescr;

smc_info#076ef1ea actions:uint16 msgs_sent:uint16
  unixtime:uint32 block_lt:uint64 trans_lt:uint64 
  rand_seed:bits256 balance_remaining:CurrencyCollection
  myself:MsgAddressInt global_config:(Maybe Cell) = SmartContractInfo;
//
//
out_list_empty$_ = OutList 0;
out_list$_ {n:#} prev:^(OutList n) action:OutAction
  = OutList (n + 1);
action_send_msg#0ec3c86d mode:(## 8) 
  out_msg:^(MessageRelaxed Any) = OutAction;
action_set_code#ad4de08e new_code:^Cell = OutAction;
action_reserve_currency#36e6b809 mode:(## 8)
  currency:CurrencyCollection = OutAction;
libref_hash$0 lib_hash:bits256 = LibRef;
libref_ref$1 library:^Cell = LibRef;
action_change_library#26fa1dd4 mode:(## 7)
  libref:LibRef = OutAction;

out_list_node$_ prev:^Cell action:OutAction = OutListNode;
//
//
shard_ident$00 shard_pfx_bits:(#<= 60) 
  workchain_id:int32 shard_prefix:uint64 = ShardIdent;

ext_blk_ref$_ end_lt:uint64
  seq_no:uint32 root_hash:bits256 file_hash:bits256 
  = ExtBlkRef;

block_id_ext$_ shard_id:ShardIdent seq_no:uint32
  root_hash:bits256 file_hash:bits256 = BlockIdExt;

master_info$_ master:ExtBlkRef = BlkMasterInfo;

shard_state#9023afe2 global_id:int32
  shard_id:ShardIdent 
  seq_no:uint32 vert_seq_no:#
  gen_utime:uint32 gen_lt:uint64
  min_ref_mc_seqno:uint32
  out_msg_queue_info:^OutMsgQueueInfo
  before_split:(## 1)
  accounts:^ShardAccounts
  ^[ overload_history:uint64 underload_history:uint64
  total_balance:CurrencyCollection
  total_validator_fees:CurrencyCollection
  libraries:(HashmapE 256 LibDescr)
  master_ref:(Maybe BlkMasterInfo) ]
  custom:(Maybe ^McStateExtra)
  = ShardStateUnsplit;
  
_ ShardStateUnsplit = ShardState;
split_state#5f327da5 left:^ShardStateUnsplit right:^ShardStateUnsplit = ShardState;

shared_lib_descr$00 lib:^Cell publishers:(Hashmap 256 True)
  = LibDescr;

block_info#9bc7a987 version:uint32 
  not_master:(## 1) 
  after_merge:(## 1) before_split:(## 1) 
  after_split:(## 1) 
  want_split:Bool want_merge:Bool
  key_block:Bool vert_seqno_incr:(## 1)
  flags:(## 8) { flags <= 1 }
  seq_no:# vert_seq_no:# { vert_seq_no >= vert_seqno_incr } 
  { prev_seq_no:# } { ~prev_seq_no + 1 = seq_no } 
  shard:ShardIdent gen_utime:uint32
  start_lt:uint64 end_lt:uint64
  gen_validator_list_hash_short:uint32
  gen_catchain_seqno:uint32
  min_ref_mc_seqno:uint32
  prev_key_block_seqno:uint32
  gen_software:flags . 0?GlobalVersion
  master_ref:not_master?^BlkMasterInfo 
  prev_ref:^(BlkPrevInfo after_merge)
  prev_vert_ref:vert_seqno_incr?^(BlkPrevInfo 0)
  = BlockInfo;

prev_blk_info$_ prev:ExtBlkRef = BlkPrevInfo 0;
prev_blks_info$_ prev1:^ExtBlkRef prev2:^ExtBlkRef = BlkPrevInfo 1;

block#11ef55aa global_id:int32
  info:^BlockInfo value_flow:^ValueFlow
  state_update:^(MERKLE_UPDATE ShardState) 
  extra:^BlockExtra = Block;

block_extra in_msg_descr:^InMsgDescr
  out_msg_descr:^OutMsgDescr
  account_blocks:^ShardAccountBlocks
  rand_seed:bits256
  created_by:bits256
  custom:(Maybe ^McBlockExtra) = BlockExtra;
//
value_flow#b8e48dfb ^[ from_prev_blk:CurrencyCollection 
  to_next_blk:CurrencyCollection
  imported:CurrencyCollection
  exported:CurrencyCollection ]
  fees_collected:CurrencyCollection
  ^[
  fees_imported:CurrencyCollection
  recovered:CurrencyCollection
  created:CurrencyCollection
  minted:CurrencyCollection
  ] = ValueFlow;

value_flow_v2#3ebf98b7 ^[ from_prev_blk:CurrencyCollection
  to_next_blk:CurrencyCollection
  imported:CurrencyCollection
  exported:CurrencyCollection ]
  fees_collected:CurrencyCollection
  burned:CurrencyCollection
  ^[
  fees_imported:CurrencyCollection
  recovered:CurrencyCollection
  created:CurrencyCollection
  minted:CurrencyCollection
  ] = ValueFlow;

//
//
bt_leaf$0 {X:Type} leaf:X = BinTree X;
bt_fork$1 {X:Type} left:^(BinTree X) right:^(BinTree X) 
          = BinTree X;

fsm_none$0 = FutureSplitMerge;
fsm_split$10 split_utime:uint32 interval:uint32 = FutureSplitMerge;
fsm_merge$11 merge_utime:uint32 interval:uint32 = FutureSplitMerge;

shard_descr#b seq_no:uint32 reg_mc_seqno:uint32
  start_lt:uint64 end_lt:uint64
  root_hash:bits256 file_hash:bits256 
  before_split:Bool before_merge:Bool
  want_split:Bool want_merge:Bool
  nx_cc_updated:Bool flags:(## 3) { flags = 0 }
  next_catchain_seqno:uint32 next_validator_shard:uint64
  min_ref_mc_seqno:uint32 gen_utime:uint32
  split_merge_at:FutureSplitMerge
  fees_collected:CurrencyCollection
  funds_created:CurrencyCollection = ShardDescr;

shard_descr_new#a seq_no:uint32 reg_mc_seqno:uint32
  start_lt:uint64 end_lt:uint64
  root_hash:bits256 file_hash:bits256 
  before_split:Bool before_merge:Bool
  want_split:Bool want_merge:Bool
  nx_cc_updated:Bool flags:(## 3) { flags = 0 }
  next_catchain_seqno:uint32 next_validator_shard:uint64
  min_ref_mc_seqno:uint32 gen_utime:uint32
  split_merge_at:FutureSplitMerge
  ^[ fees_collected:CurrencyCollection
     funds_created:CurrencyCollection ] = ShardDescr;

_ (HashmapE 32 ^(BinTree ShardDescr)) = ShardHashes;

bta_leaf$0 {X:Type} {Y:Type} extra:Y leaf:X = BinTreeAug X Y;
bta_fork$1 {X:Type} {Y:Type} left:^(BinTreeAug X Y) 
           right:^(BinTreeAug X Y) extra:Y = BinTreeAug X Y;

_ fees:CurrencyCollection create:CurrencyCollection = ShardFeeCreated;
_ (HashmapAugE 96 ShardFeeCreated ShardFeeCreated) = ShardFees;

_ config_addr:bits256 config:^(Hashmap 32 ^Cell) 
  = ConfigParams;

validator_info$_
  validator_list_hash_short:uint32 
  catchain_seqno:uint32
  nx_cc_updated:Bool
= ValidatorInfo;

validator_base_info$_
  validator_list_hash_short:uint32 
  catchain_seqno:uint32
= ValidatorBaseInfo;

_ key:Bool max_end_lt:uint64 = KeyMaxLt;
_ key:Bool blk_ref:ExtBlkRef = KeyExtBlkRef;

_ (HashmapAugE 32 KeyExtBlkRef KeyMaxLt) = OldMcBlocksInfo;


counters#_ last_updated:uint32 total:uint64 cnt2048:uint64 cnt65536:uint64 = Counters; 
creator_info#4 mc_blocks:Counters shard_blocks:Counters = CreatorStats; 
block_create_stats#17 counters:(HashmapE 256 CreatorStats) = BlockCreateStats;
block_create_stats_ext#34 counters:(HashmapAugE 256 CreatorStats uint32) = BlockCreateStats;

masterchain_state_extra#cc26
  shard_hashes:ShardHashes
  config:ConfigParams
  ^[ flags:(## 16) { flags <= 1 }
     validator_info:ValidatorInfo
     prev_blocks:OldMcBlocksInfo
     after_key_block:Bool
     last_key_block:(Maybe ExtBlkRef)
     block_create_stats:(flags . 0)?BlockCreateStats ]
  global_balance:CurrencyCollection
= McStateExtra;

ed25519_pubkey#8e81278a pubkey:bits256 = SigPubKey;  // 288 bits
ed25519_signature#5 R:bits256 s:bits256 = CryptoSignatureSimple;  // 516 bits
_ CryptoSignatureSimple = CryptoSignature;
sig_pair$_ node_id_short:bits256 sign:CryptoSignature = CryptoSignaturePair;  // 256+x ~ 772 bits

certificate#4 temp_key:SigPubKey valid_since:uint32 valid_until:uint32 = Certificate;  // 356 bits
certificate_env#a419b7d certificate:Certificate = CertificateEnv;  // 384 bits
signed_certificate$_ certificate:Certificate certificate_signature:CryptoSignature
  = SignedCertificate;  // 356+516 = 872 bits
// certificate_signature is the signature of CertificateEnv (with embedded certificate) with persistent key
chained_signature#f signed_cert:^SignedCertificate temp_key_signature:CryptoSignatureSimple
  = CryptoSignature;   // 4+(356+516)+516 = 520 bits+ref (1392 bits total)
// temp_key_signature is the signature of whatever was originally intended to be signed with temp_key from certificate

masterchain_block_extra#cca5
  key_block:(## 1)
  shard_hashes:ShardHashes
  shard_fees:ShardFees
  ^[ prev_blk_signatures:(HashmapE 16 CryptoSignaturePair)
     recover_create_msg:(Maybe ^InMsg)
     mint_msg:(Maybe ^InMsg) ]
  config:key_block?ConfigParams
= McBlockExtra;

//
//  CONFIGURATION PARAMETERS
//

validator#53 public_key:SigPubKey weight:uint64 = ValidatorDescr;
validator_addr#73 public_key:SigPubKey weight:uint64 adnl_addr:bits256 = ValidatorDescr;
validators#11 utime_since:uint32 utime_until:uint32 
  total:(## 16) main:(## 16) { main <= total } { main >= 1 } 
  list:(Hashmap 16 ValidatorDescr) = ValidatorSet;
validators_ext#12 utime_since:uint32 utime_until:uint32 
  total:(## 16) main:(## 16) { main <= total } { main >= 1 } 
  total_weight:uint64 list:(HashmapE 16 ValidatorDescr) = ValidatorSet;

_ config_addr:bits256 = ConfigParam 0;
_ elector_addr:bits256 = ConfigParam 1;
_ minter_addr:bits256 = ConfigParam 2;  // ConfigParam 0 is used if absent
_ fee_collector_addr:bits256 = ConfigParam 3;  // ConfigParam 1 is used if absent
_ dns_root_addr:bits256 = ConfigParam 4;  // root TON DNS resolver

burning_config#01
  blackhole_addr:(Maybe bits256)
  fee_burn_num:# fee_burn_denom:# { fee_burn_num <= fee_burn_denom } { fee_burn_denom >= 1 } = BurningConfig;
_ BurningConfig = ConfigParam 5;

_ mint_new_price:Grams mint_add_price:Grams = ConfigParam 6;
_ to_mint:ExtraCurrencyCollection = ConfigParam 7;

capabilities#c4 version:uint32 capabilities:uint64 = GlobalVersion;
_ GlobalVersion = ConfigParam 8;  // all zero if absent
_ mandatory_params:(Hashmap 32 True) = ConfigParam 9;
_ critical_params:(Hashmap 32 True) = ConfigParam 10;

cfg_vote_cfg#36 min_tot_rounds:uint8 max_tot_rounds:uint8 min_wins:uint8 max_losses:uint8 min_store_sec:uint32 max_store_sec:uint32 bit_price:uint32 cell_price:uint32 = ConfigProposalSetup;
cfg_vote_setup#91 normal_params:^ConfigProposalSetup critical_params:^ConfigProposalSetup = ConfigVotingSetup;
_ ConfigVotingSetup = ConfigParam 11;

cfg_proposal#f3 param_id:int32 param_value:(Maybe ^Cell) if_hash_equal:(Maybe uint256) 
  = ConfigProposal;
cfg_proposal_status#ce expires:uint32 proposal:^ConfigProposal is_critical:Bool
  voters:(HashmapE 16 True) remaining_weight:int64 validator_set_id:uint256 
  rounds_remaining:uint8 wins:uint8 losses:uint8 = ConfigProposalStatus;

wfmt_basic#1 vm_version:int32 vm_mode:uint64 = WorkchainFormat 1;
wfmt_ext#0 min_addr_len:(## 12) max_addr_len:(## 12) addr_len_step:(## 12)
  { min_addr_len >= 64 } { min_addr_len <= max_addr_len } 
  { max_addr_len <= 1023 } { addr_len_step <= 1023 }
  workchain_type_id:(## 32) { workchain_type_id >= 1 }
  = WorkchainFormat 0;

wc_split_merge_timings#0
  split_merge_delay:uint32 split_merge_interval:uint32
  min_split_merge_interval:uint32 max_split_merge_delay:uint32
  = WcSplitMergeTimings;

//workchain#a5 enabled_since:uint32 min_split:(## 8) max_split:(## 8)
//  { min_split <= max_split } { max_split <= 60 }

workchain#a6 enabled_since:uint32 monitor_min_split:(## 8)
  min_split:(## 8) max_split:(## 8) { monitor_min_split <= min_split }
  basic:(## 1) active:Bool accept_msgs:Bool flags:(## 13) { flags = 0 }
  zerostate_root_hash:bits256 zerostate_file_hash:bits256
  version:uint32 format:(WorkchainFormat basic)
  = WorkchainDescr;

workchain_v2#a7 enabled_since:uint32 monitor_min_split:(## 8)
  min_split:(## 8) max_split:(## 8) { monitor_min_split <= min_split }
  basic:(## 1) active:Bool accept_msgs:Bool flags:(## 13) { flags = 0 }
  zerostate_root_hash:bits256 zerostate_file_hash:bits256
  version:uint32 format:(WorkchainFormat basic)
  split_merge_timings:WcSplitMergeTimings
  persistent_state_split_depth:(## 8) { persistent_state_split_depth <= 63 }
  = WorkchainDescr;

_ workchains:(HashmapE 32 WorkchainDescr) = ConfigParam 12;

complaint_prices#1a deposit:Grams bit_price:Grams cell_price:Grams = ComplaintPricing; 
_ ComplaintPricing = ConfigParam 13;

block_grams_created#6b masterchain_block_fee:Grams basechain_block_fee:Grams
  = BlockCreateFees;
_ BlockCreateFees = ConfigParam 14;

_ validators_elected_for:uint32 elections_start_before:uint32 
  elections_end_before:uint32 stake_held_for:uint32
  = ConfigParam 15;
  
_ max_validators:(## 16) max_main_validators:(## 16) min_validators:(## 16) 
  { max_validators >= max_main_validators } 
  { max_main_validators >= min_validators } 
  { min_validators >= 1 }
  = ConfigParam 16;

_ min_stake:Grams max_stake:Grams min_total_stake:Grams max_stake_factor:uint32 = ConfigParam 17;

_#cc utime_since:uint32 bit_price_ps:uint64 cell_price_ps:uint64 
  mc_bit_price_ps:uint64 mc_cell_price_ps:uint64 = StoragePrices;
_ (Hashmap 32 StoragePrices) = ConfigParam 18;

_ global_id:int32 = ConfigParam 19;

gas_prices#dd gas_price:uint64 gas_limit:uint64 gas_credit:uint64 
  block_gas_limit:uint64 freeze_due_limit:uint64 delete_due_limit:uint64 
  = GasLimitsPrices;

gas_prices_ext#de gas_price:uint64 gas_limit:uint64 special_gas_limit:uint64 gas_credit:uint64 
  block_gas_limit:uint64 freeze_due_limit:uint64 delete_due_limit:uint64 
  = GasLimitsPrices;

gas_flat_pfx#d1 flat_gas_limit:uint64 flat_gas_price:uint64 other:GasLimitsPrices
  = GasLimitsPrices;

config_mc_gas_prices#_ GasLimitsPrices = ConfigParam 20;
config_gas_prices#_ GasLimitsPrices = ConfigParam 21;

param_limits#c3 underload:# soft_limit:# { underload <= soft_limit }
  hard_limit:# { soft_limit <= hard_limit } = ParamLimits;
block_limits#5d bytes:ParamLimits gas:ParamLimits lt_delta:ParamLimits
  = BlockLimits;
  
config_mc_block_limits#_ BlockLimits = ConfigParam 22;
config_block_limits#_ BlockLimits = ConfigParam 23;

// msg_fwd_fees = (lump_price + ceil((bit_price * msg.bits + cell_price * msg.cells)/2^16)) nanograms
// ihr_fwd_fees = ceil((msg_fwd_fees * ihr_price_factor)/2^16) nanograms
// bits in the root cell of a message are not included in msg.bits (lump_price pays for them)
msg_forward_prices#ea lump_price:uint64 bit_price:uint64 cell_price:uint64
  ihr_price_factor:uint32 first_frac:uint16 next_frac:uint16 = MsgForwardPrices;

// used for messages to/from masterchain
config_mc_fwd_prices#_ MsgForwardPrices = ConfigParam 24;
// used for all other messages
config_fwd_prices#_ MsgForwardPrices = ConfigParam 25;

catchain_config#c1 mc_catchain_lifetime:uint32 shard_catchain_lifetime:uint32 
  shard_validators_lifetime:uint32 shard_validators_num:uint32 = CatchainConfig;

catchain_config_new#c2 flags:(## 7) { flags = 0 } shuffle_mc_validators:Bool
  mc_catchain_lifetime:uint32 shard_catchain_lifetime:uint32
  shard_validators_lifetime:uint32 shard_validators_num:uint32 = CatchainConfig;

consensus_config#d6 round_candidates:# { round_candidates >= 1 }
  next_candidate_delay_ms:uint32 consensus_timeout_ms:uint32
  fast_attempts:uint32 attempt_duration:uint32 catchain_max_deps:uint32
  max_block_bytes:uint32 max_collated_bytes:uint32 = ConsensusConfig;

consensus_config_new#d7 flags:(## 7) { flags = 0 } new_catchain_ids:Bool
  round_candidates:(## 8) { round_candidates >= 1 }
  next_candidate_delay_ms:uint32 consensus_timeout_ms:uint32
  fast_attempts:uint32 attempt_duration:uint32 catchain_max_deps:uint32
  max_block_bytes:uint32 max_collated_bytes:uint32 = ConsensusConfig;

consensus_config_v3#d8 flags:(## 7) { flags = 0 } new_catchain_ids:Bool
  round_candidates:(## 8) { round_candidates >= 1 }
  next_candidate_delay_ms:uint32 consensus_timeout_ms:uint32
  fast_attempts:uint32 attempt_duration:uint32 catchain_max_deps:uint32
  max_block_bytes:uint32 max_collated_bytes:uint32 
  proto_version:uint16 = ConsensusConfig;

consensus_config_v4#d9 flags:(## 7) { flags = 0 } new_catchain_ids:Bool
  round_candidates:(## 8) { round_candidates >= 1 }
  next_candidate_delay_ms:uint32 consensus_timeout_ms:uint32
  fast_attempts:uint32 attempt_duration:uint32 catchain_max_deps:uint32
  max_block_bytes:uint32 max_collated_bytes:uint32
  proto_version:uint16 catchain_max_blocks_coeff:uint32 = ConsensusConfig;

_ CatchainConfig = ConfigParam 28;
_ ConsensusConfig = ConfigParam 29;

_ fundamental_smc_addr:(HashmapE 256 True) = ConfigParam 31;
_ prev_validators:ValidatorSet = ConfigParam 32;
_ prev_temp_validators:ValidatorSet = ConfigParam 33;
_ cur_validators:ValidatorSet = ConfigParam 34;
_ cur_temp_validators:ValidatorSet = ConfigParam 35;
_ next_validators:ValidatorSet = ConfigParam 36;
_ next_temp_validators:ValidatorSet = ConfigParam 37;

validator_temp_key#3 adnl_addr:bits256 temp_public_key:SigPubKey seqno:# valid_until:uint32 = ValidatorTempKey;
signed_temp_key#4 key:^ValidatorTempKey signature:CryptoSignature = ValidatorSignedTempKey;
_ (HashmapE 256 ValidatorSignedTempKey) = ConfigParam 39;

misbehaviour_punishment_config_v1#01 
  default_flat_fine:Grams default_proportional_fine:uint32
  severity_flat_mult:uint16 severity_proportional_mult:uint16
  unpunishable_interval:uint16
  long_interval:uint16 long_flat_mult:uint16 long_proportional_mult:uint16
  medium_interval:uint16 medium_flat_mult:uint16 medium_proportional_mult:uint16
   = MisbehaviourPunishmentConfig;
_ MisbehaviourPunishmentConfig = ConfigParam 40;

size_limits_config#01 max_msg_bits:uint32 max_msg_cells:uint32 max_library_cells:uint32 max_vm_data_depth:uint16
  max_ext_msg_size:uint32 max_ext_msg_depth:uint16 = SizeLimitsConfig;
size_limits_config_v2#02 max_msg_bits:uint32 max_msg_cells:uint32 max_library_cells:uint32 max_vm_data_depth:uint16
  max_ext_msg_size:uint32 max_ext_msg_depth:uint16 max_acc_state_cells:uint32 max_acc_state_bits:uint32
  max_acc_public_libraries:uint32 defer_out_queue_size_limit:uint32 max_msg_extra_currencies:uint32
  max_acc_fixed_prefix_length:uint8 = SizeLimitsConfig;
_ SizeLimitsConfig = ConfigParam 43;

// key is [ wc:int32 addr:uint256 ]
suspended_address_list#00 addresses:(HashmapE 288 Unit) suspended_until:uint32 = SuspendedAddressList;
_ SuspendedAddressList = ConfigParam 44;

precompiled_smc#b0 gas_usage:uint64 = PrecompiledSmc;
precompiled_contracts_config#c0 list:(HashmapE 256 PrecompiledSmc) = PrecompiledContractsConfig;
_ PrecompiledContractsConfig = ConfigParam 45;

oracle_bridge_params#_ bridge_address:bits256 oracle_mutlisig_address:bits256 oracles:(HashmapE 256 uint256) external_chain_address:bits256 = OracleBridgeParams;
_ OracleBridgeParams = ConfigParam 71; // Ethereum bridge
_ OracleBridgeParams = ConfigParam 72; // Binance Smart Chain bridge
_ OracleBridgeParams = ConfigParam 73; // Polygon bridge

// Note that chains in which bridge, minter and jetton-wallet operate are fixated
jetton_bridge_prices#_ bridge_burn_fee:Coins bridge_mint_fee:Coins
                       wallet_min_tons_for_storage:Coins
                       wallet_gas_consumption:Coins
                       minter_min_tons_for_storage:Coins
                       discover_gas_consumption:Coins = JettonBridgePrices;

jetton_bridge_params_v0#00 bridge_address:bits256 oracles_address:bits256 oracles:(HashmapE 256 uint256) state_flags:uint8 burn_bridge_fee:Coins = JettonBridgeParams;
jetton_bridge_params_v1#01 bridge_address:bits256 oracles_address:bits256 oracles:(HashmapE 256 uint256) state_flags:uint8 prices:^JettonBridgePrices external_chain_address:bits256 = JettonBridgeParams;

_ JettonBridgeParams = ConfigParam 79; // ETH->TON token bridge
_ JettonBridgeParams = ConfigParam 81; // BNB->TON token bridge
_ JettonBridgeParams = ConfigParam 82; // Polygon->TON token bridge


//
//  PROOFS
//
block_signatures_pure#_ sig_count:uint32 sig_weight:uint64
  signatures:(HashmapE 16 CryptoSignaturePair) = BlockSignaturesPure;
block_signatures#11 validator_info:ValidatorBaseInfo pure_signatures:BlockSignaturesPure = BlockSignatures;
block_proof#c3 proof_for:BlockIdExt root:^Cell signatures:(Maybe ^BlockSignatures) = BlockProof;

chain_empty$_ = ProofChain 0;
chain_link$_ {n:#} root:^Cell prev:n?^(ProofChain n) = ProofChain (n + 1);
top_block_descr#d5 proof_for:BlockIdExt signatures:(Maybe ^BlockSignatures) 
  len:(## 8) { len >= 1 } { len <= 8 } chain:(ProofChain len) = TopBlockDescr;

//
//  COLLATED DATA
//
top_block_descr_set#4ac789f3 collection:(HashmapE 96 ^TopBlockDescr) = TopBlockDescrSet;

//
//  VALIDATOR MISBEHAVIOR COMPLAINTS
//
prod_info#34 utime:uint32 mc_blk_ref:ExtBlkRef state_proof:^(MERKLE_PROOF Block)
  prod_proof:^(MERKLE_PROOF ShardState) = ProducerInfo;
no_blk_gen from_utime:uint32 prod_info:^ProducerInfo = ComplaintDescr;
no_blk_gen_diff prod_info_old:^ProducerInfo prod_info_new:^ProducerInfo = ComplaintDescr;
validator_complaint#bc validator_pubkey:bits256 description:^ComplaintDescr created_at:uint32 severity:uint8 reward_addr:uint256 paid:Grams suggested_fine:Grams suggested_fine_part:uint32 = ValidatorComplaint;
complaint_status#2d complaint:^ValidatorComplaint voters:(HashmapE 16 True) vset_id:uint256 weight_remaining:int64 = ValidatorComplaintStatus;

//
//  TVM REFLECTION
//
vm_stk_null#00 = VmStackValue;
vm_stk_tinyint#01 value:int64 = VmStackValue;
vm_stk_int#0201_ value:int257 = VmStackValue;
vm_stk_nan#02ff = VmStackValue;
vm_stk_cell#03 cell:^Cell = VmStackValue;
_ cell:^Cell st_bits:(## 10) end_bits:(## 10) { st_bits <= end_bits }
  st_ref:(#<= 4) end_ref:(#<= 4) { st_ref <= end_ref } = VmCellSlice;
vm_stk_slice#04 _:VmCellSlice = VmStackValue;
vm_stk_builder#05 cell:^Cell = VmStackValue;
vm_stk_cont#06 cont:VmCont = VmStackValue;
vm_tupref_nil$_ = VmTupleRef 0;
vm_tupref_single$_ entry:^VmStackValue = VmTupleRef 1;
vm_tupref_any$_ {n:#} ref:^(VmTuple (n + 2)) = VmTupleRef (n + 2);
vm_tuple_nil$_ = VmTuple 0;
vm_tuple_tcons$_ {n:#} head:(VmTupleRef n) tail:^VmStackValue = VmTuple (n + 1);
vm_stk_tuple#07 len:(## 16) data:(VmTuple len) = VmStackValue;

vm_stack#_ depth:(## 24) stack:(VmStackList depth) = VmStack;
vm_stk_cons#_ {n:#} rest:^(VmStackList n) tos:VmStackValue = VmStackList (n + 1);
vm_stk_nil#_ = VmStackList 0;

_ cregs:(HashmapE 4 VmStackValue) = VmSaveList;
gas_limits#_ remaining:int64 _:^[ max_limit:int64 cur_limit:int64 credit:int64 ]
  = VmGasLimits;
_ libraries:(HashmapE 256 ^Cell) = VmLibraries;

vm_ctl_data$_ nargs:(Maybe uint13) stack:(Maybe VmStack) save:VmSaveList
cp:(Maybe int16) = VmControlData;
vmc_std$00 cdata:VmControlData code:VmCellSlice = VmCont;
vmc_envelope$01 cdata:VmControlData next:^VmCont = VmCont;
vmc_quit$1000 exit_code:int32 = VmCont;
vmc_quit_exc$1001 = VmCont;
vmc_repeat$10100 count:uint63 body:^VmCont after:^VmCont = VmCont; 
vmc_until$110000 body:^VmCont after:^VmCont = VmCont;
vmc_again$110001 body:^VmCont = VmCont;
vmc_while_cond$110010 cond:^VmCont body:^VmCont
after:^VmCont = VmCont;
vmc_while_body$110011 cond:^VmCont body:^VmCont
after:^VmCont = VmCont;
vmc_pushint$1111 value:int32 next:^VmCont = VmCont;

//
//  DNS RECORDS
//
_ (HashmapE 256 ^DNSRecord) = DNS_RecordSet;

chunk_ref$_ {n:#} ref:^(TextChunks (n + 1)) = TextChunkRef (n + 1);
chunk_ref_empty$_ = TextChunkRef 0;
text_chunk$_ {n:#} len:(## 8) data:(bits (len * 8)) next:(TextChunkRef n) = TextChunks (n + 1);
text_chunk_empty$_ = TextChunks 0;
text$_ chunks:(## 8) rest:(TextChunks chunks) = Text;
dns_text#1eda _:Text = DNSRecord;

dns_next_resolver#ba93 resolver:MsgAddressInt = DNSRecord;  // usually in record #-1

dns_adnl_address#ad01 adnl_addr:bits256 flags:(## 8) { flags <= 1 }
  proto_list:flags . 0?ProtoList = DNSRecord;  // often in record #2
proto_list_nil$0 = ProtoList;
proto_list_next$1 head:Protocol tail:ProtoList = ProtoList;
proto_http#4854 = Protocol;

dns_smc_address#9fd3 smc_addr:MsgAddressInt flags:(## 8) { flags <= 1 }
  cap_list:flags . 0?SmcCapList = DNSRecord;   // often in record #1
cap_list_nil$0 = SmcCapList;
cap_list_next$1 head:SmcCapability tail:SmcCapList = SmcCapList;
cap_method_seqno#5371 = SmcCapability;
cap_method_pubkey#71f4 = SmcCapability;
cap_is_wallet#2177 = SmcCapability;
cap_name#ff name:Text = SmcCapability;

dns_storage_address#7473 bag_id:bits256 = DNSRecord;

//
// PAYMENT CHANNELS
//

chan_config$_  init_timeout:uint32 close_timeout:uint32 a_key:bits256 b_key:bits256 
  a_addr:^MsgAddressInt b_addr:^MsgAddressInt channel_id:uint64 min_A_extra:Grams = ChanConfig;

chan_state_init$000  signed_A:Bool signed_B:Bool min_A:Grams min_B:Grams expire_at:uint32 A:Grams B:Grams = ChanState;
chan_state_close$001 signed_A:Bool signed_B:Bool promise_A:Grams promise_B:Grams expire_at:uint32 A:Grams B:Grams = ChanState;
chan_state_payout$010 A:Grams B:Grams = ChanState;

chan_promise$_ channel_id:uint64 promise_A:Grams promise_B:Grams = ChanPromise;
chan_signed_promise#_ sig:(Maybe ^bits512) promise:ChanPromise = ChanSignedPromise;

chan_msg_init#27317822 inc_A:Grams inc_B:Grams min_A:Grams min_B:Grams channel_id:uint64 = ChanMsg;
chan_msg_close#f28ae183 extra_A:Grams extra_B:Grams promise:ChanSignedPromise  = ChanMsg;
chan_msg_timeout#43278a28 = ChanMsg;
chan_msg_payout#37fe7810 = ChanMsg;

chan_signed_msg$_ sig_A:(Maybe ^bits512) sig_B:(Maybe ^bits512) msg:ChanMsg = ChanSignedMsg;

chan_op_cmd#912838d1 msg:ChanSignedMsg = ChanOp;


chan_data$_ config:^ChanConfig state:^ChanState = ChanData;
`;
  return schema;
}
var hasRequiredDist$2;
function requireDist$2() {
  if (hasRequiredDist$2) return dist$4;
  hasRequiredDist$2 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.blockSchema = exports.unwrap = exports.TLBSchemaError = exports.TLBRuntimeError = exports.TLBDataError = exports.parseTLB = exports.TLBRuntime = exports.parseCell = exports.encodeCell = exports.replacer = void 0;
    var parser_1 = requireParser();
    Object.defineProperty(exports, "replacer", { enumerable: true, get: function() {
      return parser_1.replacer;
    } });
    Object.defineProperty(exports, "encodeCell", { enumerable: true, get: function() {
      return parser_1.encodeCell;
    } });
    Object.defineProperty(exports, "parseCell", { enumerable: true, get: function() {
      return parser_1.parseCell;
    } });
    var TLBRuntime_1 = requireTLBRuntime();
    Object.defineProperty(exports, "TLBRuntime", { enumerable: true, get: function() {
      return TLBRuntime_1.TLBRuntime;
    } });
    Object.defineProperty(exports, "parseTLB", { enumerable: true, get: function() {
      return TLBRuntime_1.parseTLB;
    } });
    Object.defineProperty(exports, "TLBDataError", { enumerable: true, get: function() {
      return TLBRuntime_1.TLBDataError;
    } });
    Object.defineProperty(exports, "TLBRuntimeError", { enumerable: true, get: function() {
      return TLBRuntime_1.TLBRuntimeError;
    } });
    Object.defineProperty(exports, "TLBSchemaError", { enumerable: true, get: function() {
      return TLBRuntime_1.TLBSchemaError;
    } });
    var Result_1 = requireResult();
    Object.defineProperty(exports, "unwrap", { enumerable: true, get: function() {
      return Result_1.unwrap;
    } });
    var schema_1 = requireSchema();
    Object.defineProperty(exports, "blockSchema", { enumerable: true, get: function() {
      return schema_1.blockSchema;
    } });
  })(dist$4);
  return dist$4;
}
requireDist$2();
globalLogger.createChild("SignDataHandler");
globalLogger.createChild("EventRouter");
var distExports = requireDist$6();
function signed_crc_table() {
  var c = 0, table = new Array(256);
  for (var n = 0; n != 256; ++n) {
    c = n;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    table[n] = c;
  }
  return typeof Int32Array !== "undefined" ? new Int32Array(table) : table;
}
var T0 = signed_crc_table();
function slice_by_16_tables(T2) {
  var c = 0, v2 = 0, n = 0, table = typeof Int32Array !== "undefined" ? new Int32Array(4096) : new Array(4096);
  for (n = 0; n != 256; ++n)
    table[n] = T2[n];
  for (n = 0; n != 256; ++n) {
    v2 = T2[n];
    for (c = 256 + n; c < 4096; c += 256)
      v2 = table[c] = v2 >>> 8 ^ T2[v2 & 255];
  }
  var out = [];
  for (n = 1; n != 16; ++n)
    out[n - 1] = typeof Int32Array !== "undefined" ? table.subarray(n * 256, n * 256 + 256) : table.slice(n * 256, n * 256 + 256);
  return out;
}
var TT = slice_by_16_tables(T0);
TT[0];
TT[1];
TT[2];
TT[3];
TT[4];
TT[5];
TT[6];
TT[7];
TT[8];
TT[9];
TT[10];
TT[11];
TT[12];
TT[13];
TT[14];
globalLogger.createChild("RequestProcessor");
globalLogger.createChild("EventStore");
globalLogger.createChild("EventProcessor");
globalLogger.createChild("WalletTonClass");
var dist$1 = {};
var sdk = {};
var pinata = {};
var utils$1 = {};
var hasRequiredUtils$1;
function requireUtils$1() {
  if (hasRequiredUtils$1) return utils$1;
  hasRequiredUtils$1 = 1;
  Object.defineProperty(utils$1, "__esModule", { value: true });
  utils$1.defer = utils$1.internalOnchainContentToCell = utils$1.sleep = void 0;
  const core_1 = requireDist$5();
  const crypto_1 = requireDist$6();
  function sleep(timeout) {
    return new Promise((res) => {
      setTimeout(() => res(), timeout);
    });
  }
  utils$1.sleep = sleep;
  function internalOnchainContentToCell(internal) {
    const dict = core_1.Dictionary.empty(core_1.Dictionary.Keys.Buffer(32), core_1.Dictionary.Values.Cell());
    for (const k in internal) {
      if (internal[k] === void 0) {
        continue;
      }
      const b = (0, core_1.beginCell)();
      if (k === "image_data") {
        const chunks = core_1.Dictionary.empty(core_1.Dictionary.Keys.Uint(32), core_1.Dictionary.Values.Cell());
        const buf = Buffer.from(internal[k], "base64");
        for (let i = 0; i * 127 < buf.length; i++) {
          chunks.set(i, (0, core_1.beginCell)().storeBuffer(buf.subarray(i * 127, (i + 1) * 127)).endCell());
        }
        b.storeUint(1, 8).storeDict(chunks).endCell();
      } else {
        b.storeUint(0, 8).storeStringTail(internal[k].toString());
      }
      dict.set((0, crypto_1.sha256_sync)(k), b.endCell());
    }
    return (0, core_1.beginCell)().storeUint(0, 8).storeDict(dict).endCell();
  }
  utils$1.internalOnchainContentToCell = internalOnchainContentToCell;
  function defer(factory) {
    return (...args) => factory(...args);
  }
  utils$1.defer = defer;
  return utils$1;
}
var hasRequiredPinata;
function requirePinata() {
  if (hasRequiredPinata) return pinata;
  hasRequiredPinata = 1;
  var __createBinding = pinata && pinata.__createBinding || (Object.create ? (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  }) : (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  }));
  var __setModuleDefault = pinata && pinata.__setModuleDefault || (Object.create ? (function(o, v2) {
    Object.defineProperty(o, "default", { enumerable: true, value: v2 });
  }) : function(o, v2) {
    o["default"] = v2;
  });
  var __importStar = pinata && pinata.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(pinata, "__esModule", { value: true });
  pinata.PinataStorage = void 0;
  const utils_1 = requireUtils$1();
  class PinataStorage {
    constructor(apiKey, secretApiKey) {
      this.client = (0, utils_1.defer)(async () => {
        const pinata2 = await Promise.resolve().then(() => __importStar(require$$4$2)).then((m) => m.default);
        return new pinata2(this.apiKey, this.secretApiKey);
      });
      this.stream = (0, utils_1.defer)(async (contents) => {
        const stream = await Promise.resolve().then(() => __importStar(require$$4$2)).then((m) => m.Readable);
        return stream.from(contents);
      });
      this.apiKey = apiKey;
      this.secretApiKey = secretApiKey;
    }
    static create(params) {
      return new PinataStorage(params.pinataApiKey, params.pinataSecretKey);
    }
    async uploadFile(contents) {
      const client = await this.client();
      const stream = await this.stream(contents);
      const result = await client.pinFileToIPFS(stream, {
        pinataMetadata: {
          name: "Assets SDK Jetton"
        }
      });
      return "ipfs://" + result.IpfsHash;
    }
  }
  pinata.PinataStorage = PinataStorage;
  return pinata;
}
var s3 = {};
var hasRequiredS3;
function requireS3() {
  if (hasRequiredS3) return s3;
  hasRequiredS3 = 1;
  var __createBinding = s3 && s3.__createBinding || (Object.create ? (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  }) : (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  }));
  var __setModuleDefault = s3 && s3.__setModuleDefault || (Object.create ? (function(o, v2) {
    Object.defineProperty(o, "default", { enumerable: true, value: v2 });
  }) : function(o, v2) {
    o["default"] = v2;
  });
  var __importStar = s3 && s3.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(s3, "__esModule", { value: true });
  s3.S3Storage = void 0;
  const utils_1 = requireUtils$1();
  class S3Storage {
    constructor(accessKeyId, secretAccessKey, bucket) {
      this.s3 = (0, utils_1.defer)(async () => {
        const s32 = await Promise.resolve().then(() => __importStar(require$$4$2)).then((m) => m.S3);
        return new s32({
          credentials: {
            accessKeyId: this.accessKeyId,
            secretAccessKey: this.secretAccessKey
          }
        });
      });
      this.accessKeyId = accessKeyId;
      this.secretAccessKey = secretAccessKey;
      this.bucket = bucket;
    }
    static create(params) {
      return new S3Storage(params.s3AccessKeyId, params.s3SecretAccessKey, params.s3Bucket);
    }
    async uploadFile(contents) {
      const s32 = await this.s3();
      const key2 = "jetton/" + Math.random().toString(36).substring(2);
      await s32.putObject({
        Bucket: this.bucket,
        Key: key2,
        Body: contents
      });
      return "https://" + this.bucket + ".s3.amazonaws.com/" + key2;
    }
  }
  s3.S3Storage = S3Storage;
  return s3;
}
var content$2 = {};
var zod = {};
var external = {};
var errors = {};
var en = {};
var ZodError = {};
var util = {};
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getParsedType = exports.ZodParsedType = exports.objectUtil = exports.util = void 0;
    var util2;
    (function(util3) {
      util3.assertEqual = (_) => {
      };
      function assertIs(_arg) {
      }
      util3.assertIs = assertIs;
      function assertNever(_x) {
        throw new Error();
      }
      util3.assertNever = assertNever;
      util3.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
          obj[item] = item;
        }
        return obj;
      };
      util3.getValidEnumValues = (obj) => {
        const validKeys = util3.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys) {
          filtered[k] = obj[k];
        }
        return util3.objectValues(filtered);
      };
      util3.objectValues = (obj) => {
        return util3.objectKeys(obj).map(function(e) {
          return obj[e];
        });
      };
      util3.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
        const keys = [];
        for (const key2 in object) {
          if (Object.prototype.hasOwnProperty.call(object, key2)) {
            keys.push(key2);
          }
        }
        return keys;
      };
      util3.find = (arr, checker) => {
        for (const item of arr) {
          if (checker(item))
            return item;
        }
        return void 0;
      };
      util3.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
      function joinValues(array, separator = " | ") {
        return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
      }
      util3.joinValues = joinValues;
      util3.jsonStringifyReplacer = (_, value) => {
        if (typeof value === "bigint") {
          return value.toString();
        }
        return value;
      };
    })(util2 || (exports.util = util2 = {}));
    var objectUtil;
    (function(objectUtil2) {
      objectUtil2.mergeShapes = (first, second) => {
        return {
          ...first,
          ...second
          // second overwrites first
        };
      };
    })(objectUtil || (exports.objectUtil = objectUtil = {}));
    exports.ZodParsedType = util2.arrayToEnum([
      "string",
      "nan",
      "number",
      "integer",
      "float",
      "boolean",
      "date",
      "bigint",
      "symbol",
      "function",
      "undefined",
      "null",
      "array",
      "object",
      "unknown",
      "promise",
      "void",
      "never",
      "map",
      "set"
    ]);
    const getParsedType = (data) => {
      const t = typeof data;
      switch (t) {
        case "undefined":
          return exports.ZodParsedType.undefined;
        case "string":
          return exports.ZodParsedType.string;
        case "number":
          return Number.isNaN(data) ? exports.ZodParsedType.nan : exports.ZodParsedType.number;
        case "boolean":
          return exports.ZodParsedType.boolean;
        case "function":
          return exports.ZodParsedType.function;
        case "bigint":
          return exports.ZodParsedType.bigint;
        case "symbol":
          return exports.ZodParsedType.symbol;
        case "object":
          if (Array.isArray(data)) {
            return exports.ZodParsedType.array;
          }
          if (data === null) {
            return exports.ZodParsedType.null;
          }
          if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
            return exports.ZodParsedType.promise;
          }
          if (typeof Map !== "undefined" && data instanceof Map) {
            return exports.ZodParsedType.map;
          }
          if (typeof Set !== "undefined" && data instanceof Set) {
            return exports.ZodParsedType.set;
          }
          if (typeof Date !== "undefined" && data instanceof Date) {
            return exports.ZodParsedType.date;
          }
          return exports.ZodParsedType.object;
        default:
          return exports.ZodParsedType.unknown;
      }
    };
    exports.getParsedType = getParsedType;
  })(util);
  return util;
}
var hasRequiredZodError;
function requireZodError() {
  if (hasRequiredZodError) return ZodError;
  hasRequiredZodError = 1;
  Object.defineProperty(ZodError, "__esModule", { value: true });
  ZodError.ZodError = ZodError.quotelessJson = ZodError.ZodIssueCode = void 0;
  const util_js_1 = /* @__PURE__ */ requireUtil();
  ZodError.ZodIssueCode = util_js_1.util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
  ]);
  const quotelessJson = (obj) => {
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
  };
  ZodError.quotelessJson = quotelessJson;
  let ZodError$1 = class ZodError2 extends Error {
    get errors() {
      return this.issues;
    }
    constructor(issues) {
      super();
      this.issues = [];
      this.addIssue = (sub) => {
        this.issues = [...this.issues, sub];
      };
      this.addIssues = (subs = []) => {
        this.issues = [...this.issues, ...subs];
      };
      const actualProto = new.target.prototype;
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(this, actualProto);
      } else {
        this.__proto__ = actualProto;
      }
      this.name = "ZodError";
      this.issues = issues;
    }
    format(_mapper) {
      const mapper = _mapper || function(issue) {
        return issue.message;
      };
      const fieldErrors = { _errors: [] };
      const processError = (error2) => {
        for (const issue of error2.issues) {
          if (issue.code === "invalid_union") {
            issue.unionErrors.map(processError);
          } else if (issue.code === "invalid_return_type") {
            processError(issue.returnTypeError);
          } else if (issue.code === "invalid_arguments") {
            processError(issue.argumentsError);
          } else if (issue.path.length === 0) {
            fieldErrors._errors.push(mapper(issue));
          } else {
            let curr = fieldErrors;
            let i = 0;
            while (i < issue.path.length) {
              const el = issue.path[i];
              const terminal = i === issue.path.length - 1;
              if (!terminal) {
                curr[el] = curr[el] || { _errors: [] };
              } else {
                curr[el] = curr[el] || { _errors: [] };
                curr[el]._errors.push(mapper(issue));
              }
              curr = curr[el];
              i++;
            }
          }
        }
      };
      processError(this);
      return fieldErrors;
    }
    static assert(value) {
      if (!(value instanceof ZodError2)) {
        throw new Error(`Not a ZodError: ${value}`);
      }
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, util_js_1.util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
      const fieldErrors = {};
      const formErrors = [];
      for (const sub of this.issues) {
        if (sub.path.length > 0) {
          const firstEl = sub.path[0];
          fieldErrors[firstEl] = fieldErrors[firstEl] || [];
          fieldErrors[firstEl].push(mapper(sub));
        } else {
          formErrors.push(mapper(sub));
        }
      }
      return { formErrors, fieldErrors };
    }
    get formErrors() {
      return this.flatten();
    }
  };
  ZodError.ZodError = ZodError$1;
  ZodError$1.create = (issues) => {
    const error2 = new ZodError$1(issues);
    return error2;
  };
  return ZodError;
}
var hasRequiredEn;
function requireEn() {
  if (hasRequiredEn) return en;
  hasRequiredEn = 1;
  Object.defineProperty(en, "__esModule", { value: true });
  const ZodError_js_1 = /* @__PURE__ */ requireZodError();
  const util_js_1 = /* @__PURE__ */ requireUtil();
  const errorMap = (issue, _ctx) => {
    let message;
    switch (issue.code) {
      case ZodError_js_1.ZodIssueCode.invalid_type:
        if (issue.received === util_js_1.ZodParsedType.undefined) {
          message = "Required";
        } else {
          message = `Expected ${issue.expected}, received ${issue.received}`;
        }
        break;
      case ZodError_js_1.ZodIssueCode.invalid_literal:
        message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util_js_1.util.jsonStringifyReplacer)}`;
        break;
      case ZodError_js_1.ZodIssueCode.unrecognized_keys:
        message = `Unrecognized key(s) in object: ${util_js_1.util.joinValues(issue.keys, ", ")}`;
        break;
      case ZodError_js_1.ZodIssueCode.invalid_union:
        message = `Invalid input`;
        break;
      case ZodError_js_1.ZodIssueCode.invalid_union_discriminator:
        message = `Invalid discriminator value. Expected ${util_js_1.util.joinValues(issue.options)}`;
        break;
      case ZodError_js_1.ZodIssueCode.invalid_enum_value:
        message = `Invalid enum value. Expected ${util_js_1.util.joinValues(issue.options)}, received '${issue.received}'`;
        break;
      case ZodError_js_1.ZodIssueCode.invalid_arguments:
        message = `Invalid function arguments`;
        break;
      case ZodError_js_1.ZodIssueCode.invalid_return_type:
        message = `Invalid function return type`;
        break;
      case ZodError_js_1.ZodIssueCode.invalid_date:
        message = `Invalid date`;
        break;
      case ZodError_js_1.ZodIssueCode.invalid_string:
        if (typeof issue.validation === "object") {
          if ("includes" in issue.validation) {
            message = `Invalid input: must include "${issue.validation.includes}"`;
            if (typeof issue.validation.position === "number") {
              message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
            }
          } else if ("startsWith" in issue.validation) {
            message = `Invalid input: must start with "${issue.validation.startsWith}"`;
          } else if ("endsWith" in issue.validation) {
            message = `Invalid input: must end with "${issue.validation.endsWith}"`;
          } else {
            util_js_1.util.assertNever(issue.validation);
          }
        } else if (issue.validation !== "regex") {
          message = `Invalid ${issue.validation}`;
        } else {
          message = "Invalid";
        }
        break;
      case ZodError_js_1.ZodIssueCode.too_small:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
        else if (issue.type === "bigint")
          message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
        else
          message = "Invalid input";
        break;
      case ZodError_js_1.ZodIssueCode.too_big:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "bigint")
          message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
        else
          message = "Invalid input";
        break;
      case ZodError_js_1.ZodIssueCode.custom:
        message = `Invalid input`;
        break;
      case ZodError_js_1.ZodIssueCode.invalid_intersection_types:
        message = `Intersection results could not be merged`;
        break;
      case ZodError_js_1.ZodIssueCode.not_multiple_of:
        message = `Number must be a multiple of ${issue.multipleOf}`;
        break;
      case ZodError_js_1.ZodIssueCode.not_finite:
        message = "Number must be finite";
        break;
      default:
        message = _ctx.defaultError;
        util_js_1.util.assertNever(issue);
    }
    return { message };
  };
  en.default = errorMap;
  return en;
}
var hasRequiredErrors;
function requireErrors() {
  if (hasRequiredErrors) return errors;
  hasRequiredErrors = 1;
  var __importDefault = errors && errors.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(errors, "__esModule", { value: true });
  errors.defaultErrorMap = void 0;
  errors.setErrorMap = setErrorMap;
  errors.getErrorMap = getErrorMap;
  const en_js_1 = __importDefault(/* @__PURE__ */ requireEn());
  errors.defaultErrorMap = en_js_1.default;
  let overrideErrorMap = en_js_1.default;
  function setErrorMap(map) {
    overrideErrorMap = map;
  }
  function getErrorMap() {
    return overrideErrorMap;
  }
  return errors;
}
var parseUtil = {};
var hasRequiredParseUtil;
function requireParseUtil() {
  if (hasRequiredParseUtil) return parseUtil;
  hasRequiredParseUtil = 1;
  (function(exports) {
    var __importDefault = parseUtil && parseUtil.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAsync = exports.isValid = exports.isDirty = exports.isAborted = exports.OK = exports.DIRTY = exports.INVALID = exports.ParseStatus = exports.EMPTY_PATH = exports.makeIssue = void 0;
    exports.addIssueToContext = addIssueToContext;
    const errors_js_1 = /* @__PURE__ */ requireErrors();
    const en_js_1 = __importDefault(/* @__PURE__ */ requireEn());
    const makeIssue = (params) => {
      const { data, path, errorMaps, issueData } = params;
      const fullPath = [...path, ...issueData.path || []];
      const fullIssue = {
        ...issueData,
        path: fullPath
      };
      if (issueData.message !== void 0) {
        return {
          ...issueData,
          path: fullPath,
          message: issueData.message
        };
      }
      let errorMessage = "";
      const maps = errorMaps.filter((m) => !!m).slice().reverse();
      for (const map of maps) {
        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
      }
      return {
        ...issueData,
        path: fullPath,
        message: errorMessage
      };
    };
    exports.makeIssue = makeIssue;
    exports.EMPTY_PATH = [];
    function addIssueToContext(ctx, issueData) {
      const overrideMap = (0, errors_js_1.getErrorMap)();
      const issue = (0, exports.makeIssue)({
        issueData,
        data: ctx.data,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          // contextual error map is first priority
          ctx.schemaErrorMap,
          // then schema-bound map if available
          overrideMap,
          // then global override map
          overrideMap === en_js_1.default ? void 0 : en_js_1.default
          // then global default map
        ].filter((x) => !!x)
      });
      ctx.common.issues.push(issue);
    }
    class ParseStatus {
      constructor() {
        this.value = "valid";
      }
      dirty() {
        if (this.value === "valid")
          this.value = "dirty";
      }
      abort() {
        if (this.value !== "aborted")
          this.value = "aborted";
      }
      static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results) {
          if (s.status === "aborted")
            return exports.INVALID;
          if (s.status === "dirty")
            status.dirty();
          arrayValue.push(s.value);
        }
        return { status: status.value, value: arrayValue };
      }
      static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
          const key2 = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key: key2,
            value
          });
        }
        return ParseStatus.mergeObjectSync(status, syncPairs);
      }
      static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
          const { key: key2, value } = pair;
          if (key2.status === "aborted")
            return exports.INVALID;
          if (value.status === "aborted")
            return exports.INVALID;
          if (key2.status === "dirty")
            status.dirty();
          if (value.status === "dirty")
            status.dirty();
          if (key2.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
            finalObject[key2.value] = value.value;
          }
        }
        return { status: status.value, value: finalObject };
      }
    }
    exports.ParseStatus = ParseStatus;
    exports.INVALID = Object.freeze({
      status: "aborted"
    });
    const DIRTY = (value) => ({ status: "dirty", value });
    exports.DIRTY = DIRTY;
    const OK = (value) => ({ status: "valid", value });
    exports.OK = OK;
    const isAborted = (x) => x.status === "aborted";
    exports.isAborted = isAborted;
    const isDirty = (x) => x.status === "dirty";
    exports.isDirty = isDirty;
    const isValid = (x) => x.status === "valid";
    exports.isValid = isValid;
    const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
    exports.isAsync = isAsync;
  })(parseUtil);
  return parseUtil;
}
var typeAliases = {};
var hasRequiredTypeAliases;
function requireTypeAliases() {
  if (hasRequiredTypeAliases) return typeAliases;
  hasRequiredTypeAliases = 1;
  Object.defineProperty(typeAliases, "__esModule", { value: true });
  return typeAliases;
}
var types$1 = {};
var errorUtil = {};
var hasRequiredErrorUtil;
function requireErrorUtil() {
  if (hasRequiredErrorUtil) return errorUtil;
  hasRequiredErrorUtil = 1;
  Object.defineProperty(errorUtil, "__esModule", { value: true });
  errorUtil.errorUtil = void 0;
  var errorUtil$1;
  (function(errorUtil2) {
    errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
  })(errorUtil$1 || (errorUtil.errorUtil = errorUtil$1 = {}));
  return errorUtil;
}
var hasRequiredTypes$1;
function requireTypes$1() {
  if (hasRequiredTypes$1) return types$1;
  hasRequiredTypes$1 = 1;
  Object.defineProperty(types$1, "__esModule", { value: true });
  types$1.discriminatedUnion = types$1.date = types$1.boolean = types$1.bigint = types$1.array = types$1.any = types$1.coerce = types$1.ZodFirstPartyTypeKind = types$1.late = types$1.ZodSchema = types$1.Schema = types$1.ZodReadonly = types$1.ZodPipeline = types$1.ZodBranded = types$1.BRAND = types$1.ZodNaN = types$1.ZodCatch = types$1.ZodDefault = types$1.ZodNullable = types$1.ZodOptional = types$1.ZodTransformer = types$1.ZodEffects = types$1.ZodPromise = types$1.ZodNativeEnum = types$1.ZodEnum = types$1.ZodLiteral = types$1.ZodLazy = types$1.ZodFunction = types$1.ZodSet = types$1.ZodMap = types$1.ZodRecord = types$1.ZodTuple = types$1.ZodIntersection = types$1.ZodDiscriminatedUnion = types$1.ZodUnion = types$1.ZodObject = types$1.ZodArray = types$1.ZodVoid = types$1.ZodNever = types$1.ZodUnknown = types$1.ZodAny = types$1.ZodNull = types$1.ZodUndefined = types$1.ZodSymbol = types$1.ZodDate = types$1.ZodBoolean = types$1.ZodBigInt = types$1.ZodNumber = types$1.ZodString = types$1.ZodType = void 0;
  types$1.NEVER = types$1.void = types$1.unknown = types$1.union = types$1.undefined = types$1.tuple = types$1.transformer = types$1.symbol = types$1.string = types$1.strictObject = types$1.set = types$1.record = types$1.promise = types$1.preprocess = types$1.pipeline = types$1.ostring = types$1.optional = types$1.onumber = types$1.oboolean = types$1.object = types$1.number = types$1.nullable = types$1.null = types$1.never = types$1.nativeEnum = types$1.nan = types$1.map = types$1.literal = types$1.lazy = types$1.intersection = types$1.instanceof = types$1.function = types$1.enum = types$1.effect = void 0;
  types$1.datetimeRegex = datetimeRegex;
  types$1.custom = custom;
  const ZodError_js_1 = /* @__PURE__ */ requireZodError();
  const errors_js_1 = /* @__PURE__ */ requireErrors();
  const errorUtil_js_1 = /* @__PURE__ */ requireErrorUtil();
  const parseUtil_js_1 = /* @__PURE__ */ requireParseUtil();
  const util_js_1 = /* @__PURE__ */ requireUtil();
  class ParseInputLazyPath {
    constructor(parent, value, path, key2) {
      this._cachedPath = [];
      this.parent = parent;
      this.data = value;
      this._path = path;
      this._key = key2;
    }
    get path() {
      if (!this._cachedPath.length) {
        if (Array.isArray(this._key)) {
          this._cachedPath.push(...this._path, ...this._key);
        } else {
          this._cachedPath.push(...this._path, this._key);
        }
      }
      return this._cachedPath;
    }
  }
  const handleResult = (ctx, result) => {
    if ((0, parseUtil_js_1.isValid)(result)) {
      return { success: true, data: result.value };
    } else {
      if (!ctx.common.issues.length) {
        throw new Error("Validation failed but no issues detected.");
      }
      return {
        success: false,
        get error() {
          if (this._error)
            return this._error;
          const error2 = new ZodError_js_1.ZodError(ctx.common.issues);
          this._error = error2;
          return this._error;
        }
      };
    }
  };
  function processCreateParams(params) {
    if (!params)
      return {};
    const { errorMap, invalid_type_error, required_error, description } = params;
    if (errorMap && (invalid_type_error || required_error)) {
      throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap)
      return { errorMap, description };
    const customMap = (iss, ctx) => {
      const { message } = params;
      if (iss.code === "invalid_enum_value") {
        return { message: message ?? ctx.defaultError };
      }
      if (typeof ctx.data === "undefined") {
        return { message: message ?? required_error ?? ctx.defaultError };
      }
      if (iss.code !== "invalid_type")
        return { message: ctx.defaultError };
      return { message: message ?? invalid_type_error ?? ctx.defaultError };
    };
    return { errorMap: customMap, description };
  }
  class ZodType {
    get description() {
      return this._def.description;
    }
    _getType(input) {
      return (0, util_js_1.getParsedType)(input.data);
    }
    _getOrReturnCtx(input, ctx) {
      return ctx || {
        common: input.parent.common,
        data: input.data,
        parsedType: (0, util_js_1.getParsedType)(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      };
    }
    _processInputParams(input) {
      return {
        status: new parseUtil_js_1.ParseStatus(),
        ctx: {
          common: input.parent.common,
          data: input.data,
          parsedType: (0, util_js_1.getParsedType)(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        }
      };
    }
    _parseSync(input) {
      const result = this._parse(input);
      if ((0, parseUtil_js_1.isAsync)(result)) {
        throw new Error("Synchronous parse encountered promise.");
      }
      return result;
    }
    _parseAsync(input) {
      const result = this._parse(input);
      return Promise.resolve(result);
    }
    parse(data, params) {
      const result = this.safeParse(data, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    safeParse(data, params) {
      const ctx = {
        common: {
          issues: [],
          async: params?.async ?? false,
          contextualErrorMap: params?.errorMap
        },
        path: params?.path || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: (0, util_js_1.getParsedType)(data)
      };
      const result = this._parseSync({ data, path: ctx.path, parent: ctx });
      return handleResult(ctx, result);
    }
    "~validate"(data) {
      const ctx = {
        common: {
          issues: [],
          async: !!this["~standard"].async
        },
        path: [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: (0, util_js_1.getParsedType)(data)
      };
      if (!this["~standard"].async) {
        try {
          const result = this._parseSync({ data, path: [], parent: ctx });
          return (0, parseUtil_js_1.isValid)(result) ? {
            value: result.value
          } : {
            issues: ctx.common.issues
          };
        } catch (err) {
          if (err?.message?.toLowerCase()?.includes("encountered")) {
            this["~standard"].async = true;
          }
          ctx.common = {
            issues: [],
            async: true
          };
        }
      }
      return this._parseAsync({ data, path: [], parent: ctx }).then((result) => (0, parseUtil_js_1.isValid)(result) ? {
        value: result.value
      } : {
        issues: ctx.common.issues
      });
    }
    async parseAsync(data, params) {
      const result = await this.safeParseAsync(data, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    async safeParseAsync(data, params) {
      const ctx = {
        common: {
          issues: [],
          contextualErrorMap: params?.errorMap,
          async: true
        },
        path: params?.path || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: (0, util_js_1.getParsedType)(data)
      };
      const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
      const result = await ((0, parseUtil_js_1.isAsync)(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
      return handleResult(ctx, result);
    }
    refine(check, message) {
      const getIssueProperties = (val) => {
        if (typeof message === "string" || typeof message === "undefined") {
          return { message };
        } else if (typeof message === "function") {
          return message(val);
        } else {
          return message;
        }
      };
      return this._refinement((val, ctx) => {
        const result = check(val);
        const setError = () => ctx.addIssue({
          code: ZodError_js_1.ZodIssueCode.custom,
          ...getIssueProperties(val)
        });
        if (typeof Promise !== "undefined" && result instanceof Promise) {
          return result.then((data) => {
            if (!data) {
              setError();
              return false;
            } else {
              return true;
            }
          });
        }
        if (!result) {
          setError();
          return false;
        } else {
          return true;
        }
      });
    }
    refinement(check, refinementData) {
      return this._refinement((val, ctx) => {
        if (!check(val)) {
          ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
          return false;
        } else {
          return true;
        }
      });
    }
    _refinement(refinement) {
      return new ZodEffects({
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "refinement", refinement }
      });
    }
    superRefine(refinement) {
      return this._refinement(refinement);
    }
    constructor(def) {
      this.spa = this.safeParseAsync;
      this._def = def;
      this.parse = this.parse.bind(this);
      this.safeParse = this.safeParse.bind(this);
      this.parseAsync = this.parseAsync.bind(this);
      this.safeParseAsync = this.safeParseAsync.bind(this);
      this.spa = this.spa.bind(this);
      this.refine = this.refine.bind(this);
      this.refinement = this.refinement.bind(this);
      this.superRefine = this.superRefine.bind(this);
      this.optional = this.optional.bind(this);
      this.nullable = this.nullable.bind(this);
      this.nullish = this.nullish.bind(this);
      this.array = this.array.bind(this);
      this.promise = this.promise.bind(this);
      this.or = this.or.bind(this);
      this.and = this.and.bind(this);
      this.transform = this.transform.bind(this);
      this.brand = this.brand.bind(this);
      this.default = this.default.bind(this);
      this.catch = this.catch.bind(this);
      this.describe = this.describe.bind(this);
      this.pipe = this.pipe.bind(this);
      this.readonly = this.readonly.bind(this);
      this.isNullable = this.isNullable.bind(this);
      this.isOptional = this.isOptional.bind(this);
      this["~standard"] = {
        version: 1,
        vendor: "zod",
        validate: (data) => this["~validate"](data)
      };
    }
    optional() {
      return ZodOptional.create(this, this._def);
    }
    nullable() {
      return ZodNullable.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return ZodArray.create(this);
    }
    promise() {
      return ZodPromise.create(this, this._def);
    }
    or(option) {
      return ZodUnion.create([this, option], this._def);
    }
    and(incoming) {
      return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform) {
      return new ZodEffects({
        ...processCreateParams(this._def),
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "transform", transform }
      });
    }
    default(def) {
      const defaultValueFunc = typeof def === "function" ? def : () => def;
      return new ZodDefault({
        ...processCreateParams(this._def),
        innerType: this,
        defaultValue: defaultValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodDefault
      });
    }
    brand() {
      return new ZodBranded({
        typeName: ZodFirstPartyTypeKind.ZodBranded,
        type: this,
        ...processCreateParams(this._def)
      });
    }
    catch(def) {
      const catchValueFunc = typeof def === "function" ? def : () => def;
      return new ZodCatch({
        ...processCreateParams(this._def),
        innerType: this,
        catchValue: catchValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodCatch
      });
    }
    describe(description) {
      const This = this.constructor;
      return new This({
        ...this._def,
        description
      });
    }
    pipe(target) {
      return ZodPipeline.create(this, target);
    }
    readonly() {
      return ZodReadonly.create(this);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  }
  types$1.ZodType = ZodType;
  types$1.Schema = ZodType;
  types$1.ZodSchema = ZodType;
  const cuidRegex = /^c[^\s-]{8,}$/i;
  const cuid2Regex = /^[0-9a-z]+$/;
  const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
  const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
  const nanoidRegex = /^[a-z0-9_-]{21}$/i;
  const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
  const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
  const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
  const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
  let emojiRegex;
  const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
  const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
  const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
  const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
  const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
  const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
  const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
  const dateRegex = new RegExp(`^${dateRegexSource}$`);
  function timeRegexSource(args) {
    let secondsRegexSource = `[0-5]\\d`;
    if (args.precision) {
      secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
    } else if (args.precision == null) {
      secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
    }
    const secondsQuantifier = args.precision ? "+" : "?";
    return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
  }
  function timeRegex(args) {
    return new RegExp(`^${timeRegexSource(args)}$`);
  }
  function datetimeRegex(args) {
    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
    const opts = [];
    opts.push(args.local ? `Z?` : `Z`);
    if (args.offset)
      opts.push(`([+-]\\d{2}:?\\d{2})`);
    regex = `${regex}(${opts.join("|")})`;
    return new RegExp(`^${regex}$`);
  }
  function isValidIP(ip, version2) {
    if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
      return true;
    }
    if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
      return true;
    }
    return false;
  }
  function isValidJWT(jwt, alg) {
    if (!jwtRegex.test(jwt))
      return false;
    try {
      const [header] = jwt.split(".");
      if (!header)
        return false;
      const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
      const decoded = JSON.parse(atob(base64));
      if (typeof decoded !== "object" || decoded === null)
        return false;
      if ("typ" in decoded && decoded?.typ !== "JWT")
        return false;
      if (!decoded.alg)
        return false;
      if (alg && decoded.alg !== alg)
        return false;
      return true;
    } catch {
      return false;
    }
  }
  function isValidCidr(ip, version2) {
    if ((version2 === "v4" || !version2) && ipv4CidrRegex.test(ip)) {
      return true;
    }
    if ((version2 === "v6" || !version2) && ipv6CidrRegex.test(ip)) {
      return true;
    }
    return false;
  }
  class ZodString extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = String(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== util_js_1.ZodParsedType.string) {
        const ctx2 = this._getOrReturnCtx(input);
        (0, parseUtil_js_1.addIssueToContext)(ctx2, {
          code: ZodError_js_1.ZodIssueCode.invalid_type,
          expected: util_js_1.ZodParsedType.string,
          received: ctx2.parsedType
        });
        return parseUtil_js_1.INVALID;
      }
      const status = new parseUtil_js_1.ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.length < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.length > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "length") {
          const tooBig = input.data.length > check.value;
          const tooSmall = input.data.length < check.value;
          if (tooBig || tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            if (tooBig) {
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            } else if (tooSmall) {
              (0, parseUtil_js_1.addIssueToContext)(ctx, {
                code: ZodError_js_1.ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            }
            status.dirty();
          }
        } else if (check.kind === "email") {
          if (!emailRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              validation: "email",
              code: ZodError_js_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "emoji") {
          if (!emojiRegex) {
            emojiRegex = new RegExp(_emojiRegex, "u");
          }
          if (!emojiRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              validation: "emoji",
              code: ZodError_js_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "uuid") {
          if (!uuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              validation: "uuid",
              code: ZodError_js_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "nanoid") {
          if (!nanoidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              validation: "nanoid",
              code: ZodError_js_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid") {
          if (!cuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              validation: "cuid",
              code: ZodError_js_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid2") {
          if (!cuid2Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              validation: "cuid2",
              code: ZodError_js_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ulid") {
          if (!ulidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              validation: "ulid",
              code: ZodError_js_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "url") {
          try {
            new URL(input.data);
          } catch {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              validation: "url",
              code: ZodError_js_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "regex") {
          check.regex.lastIndex = 0;
          const testResult = check.regex.test(input.data);
          if (!testResult) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              validation: "regex",
              code: ZodError_js_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "trim") {
          input.data = input.data.trim();
        } else if (check.kind === "includes") {
          if (!input.data.includes(check.value, check.position)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.invalid_string,
              validation: { includes: check.value, position: check.position },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "toLowerCase") {
          input.data = input.data.toLowerCase();
        } else if (check.kind === "toUpperCase") {
          input.data = input.data.toUpperCase();
        } else if (check.kind === "startsWith") {
          if (!input.data.startsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.invalid_string,
              validation: { startsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "endsWith") {
          if (!input.data.endsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.invalid_string,
              validation: { endsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "datetime") {
          const regex = datetimeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.invalid_string,
              validation: "datetime",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "date") {
          const regex = dateRegex;
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.invalid_string,
              validation: "date",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "time") {
          const regex = timeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.invalid_string,
              validation: "time",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "duration") {
          if (!durationRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              validation: "duration",
              code: ZodError_js_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ip") {
          if (!isValidIP(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              validation: "ip",
              code: ZodError_js_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "jwt") {
          if (!isValidJWT(input.data, check.alg)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              validation: "jwt",
              code: ZodError_js_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cidr") {
          if (!isValidCidr(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              validation: "cidr",
              code: ZodError_js_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "base64") {
          if (!base64Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              validation: "base64",
              code: ZodError_js_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "base64url") {
          if (!base64urlRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              validation: "base64url",
              code: ZodError_js_1.ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util_js_1.util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _regex(regex, validation, message) {
      return this.refinement((data) => regex.test(data), {
        validation,
        code: ZodError_js_1.ZodIssueCode.invalid_string,
        ...errorUtil_js_1.errorUtil.errToObj(message)
      });
    }
    _addCheck(check) {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    email(message) {
      return this._addCheck({ kind: "email", ...errorUtil_js_1.errorUtil.errToObj(message) });
    }
    url(message) {
      return this._addCheck({ kind: "url", ...errorUtil_js_1.errorUtil.errToObj(message) });
    }
    emoji(message) {
      return this._addCheck({ kind: "emoji", ...errorUtil_js_1.errorUtil.errToObj(message) });
    }
    uuid(message) {
      return this._addCheck({ kind: "uuid", ...errorUtil_js_1.errorUtil.errToObj(message) });
    }
    nanoid(message) {
      return this._addCheck({ kind: "nanoid", ...errorUtil_js_1.errorUtil.errToObj(message) });
    }
    cuid(message) {
      return this._addCheck({ kind: "cuid", ...errorUtil_js_1.errorUtil.errToObj(message) });
    }
    cuid2(message) {
      return this._addCheck({ kind: "cuid2", ...errorUtil_js_1.errorUtil.errToObj(message) });
    }
    ulid(message) {
      return this._addCheck({ kind: "ulid", ...errorUtil_js_1.errorUtil.errToObj(message) });
    }
    base64(message) {
      return this._addCheck({ kind: "base64", ...errorUtil_js_1.errorUtil.errToObj(message) });
    }
    base64url(message) {
      return this._addCheck({
        kind: "base64url",
        ...errorUtil_js_1.errorUtil.errToObj(message)
      });
    }
    jwt(options) {
      return this._addCheck({ kind: "jwt", ...errorUtil_js_1.errorUtil.errToObj(options) });
    }
    ip(options) {
      return this._addCheck({ kind: "ip", ...errorUtil_js_1.errorUtil.errToObj(options) });
    }
    cidr(options) {
      return this._addCheck({ kind: "cidr", ...errorUtil_js_1.errorUtil.errToObj(options) });
    }
    datetime(options) {
      if (typeof options === "string") {
        return this._addCheck({
          kind: "datetime",
          precision: null,
          offset: false,
          local: false,
          message: options
        });
      }
      return this._addCheck({
        kind: "datetime",
        precision: typeof options?.precision === "undefined" ? null : options?.precision,
        offset: options?.offset ?? false,
        local: options?.local ?? false,
        ...errorUtil_js_1.errorUtil.errToObj(options?.message)
      });
    }
    date(message) {
      return this._addCheck({ kind: "date", message });
    }
    time(options) {
      if (typeof options === "string") {
        return this._addCheck({
          kind: "time",
          precision: null,
          message: options
        });
      }
      return this._addCheck({
        kind: "time",
        precision: typeof options?.precision === "undefined" ? null : options?.precision,
        ...errorUtil_js_1.errorUtil.errToObj(options?.message)
      });
    }
    duration(message) {
      return this._addCheck({ kind: "duration", ...errorUtil_js_1.errorUtil.errToObj(message) });
    }
    regex(regex, message) {
      return this._addCheck({
        kind: "regex",
        regex,
        ...errorUtil_js_1.errorUtil.errToObj(message)
      });
    }
    includes(value, options) {
      return this._addCheck({
        kind: "includes",
        value,
        position: options?.position,
        ...errorUtil_js_1.errorUtil.errToObj(options?.message)
      });
    }
    startsWith(value, message) {
      return this._addCheck({
        kind: "startsWith",
        value,
        ...errorUtil_js_1.errorUtil.errToObj(message)
      });
    }
    endsWith(value, message) {
      return this._addCheck({
        kind: "endsWith",
        value,
        ...errorUtil_js_1.errorUtil.errToObj(message)
      });
    }
    min(minLength, message) {
      return this._addCheck({
        kind: "min",
        value: minLength,
        ...errorUtil_js_1.errorUtil.errToObj(message)
      });
    }
    max(maxLength, message) {
      return this._addCheck({
        kind: "max",
        value: maxLength,
        ...errorUtil_js_1.errorUtil.errToObj(message)
      });
    }
    length(len, message) {
      return this._addCheck({
        kind: "length",
        value: len,
        ...errorUtil_js_1.errorUtil.errToObj(message)
      });
    }
    /**
     * Equivalent to `.min(1)`
     */
    nonempty(message) {
      return this.min(1, errorUtil_js_1.errorUtil.errToObj(message));
    }
    trim() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }]
      });
    }
    toLowerCase() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      });
    }
    toUpperCase() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isDate() {
      return !!this._def.checks.find((ch) => ch.kind === "date");
    }
    get isTime() {
      return !!this._def.checks.find((ch) => ch.kind === "time");
    }
    get isDuration() {
      return !!this._def.checks.find((ch) => ch.kind === "duration");
    }
    get isEmail() {
      return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((ch) => ch.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isNANOID() {
      return !!this._def.checks.find((ch) => ch.kind === "nanoid");
    }
    get isCUID() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((ch) => ch.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((ch) => ch.kind === "ip");
    }
    get isCIDR() {
      return !!this._def.checks.find((ch) => ch.kind === "cidr");
    }
    get isBase64() {
      return !!this._def.checks.find((ch) => ch.kind === "base64");
    }
    get isBase64url() {
      return !!this._def.checks.find((ch) => ch.kind === "base64url");
    }
    get minLength() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxLength() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  }
  types$1.ZodString = ZodString;
  ZodString.create = (params) => {
    return new ZodString({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodString,
      coerce: params?.coerce ?? false,
      ...processCreateParams(params)
    });
  };
  function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
    return valInt % stepInt / 10 ** decCount;
  }
  class ZodNumber extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
      this.step = this.multipleOf;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = Number(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== util_js_1.ZodParsedType.number) {
        const ctx2 = this._getOrReturnCtx(input);
        (0, parseUtil_js_1.addIssueToContext)(ctx2, {
          code: ZodError_js_1.ZodIssueCode.invalid_type,
          expected: util_js_1.ZodParsedType.number,
          received: ctx2.parsedType
        });
        return parseUtil_js_1.INVALID;
      }
      let ctx = void 0;
      const status = new parseUtil_js_1.ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "int") {
          if (!util_js_1.util.isInteger(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.invalid_type,
              expected: "integer",
              received: "float",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.too_small,
              minimum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.too_big,
              maximum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (floatSafeRemainder(input.data, check.value) !== 0) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "finite") {
          if (!Number.isFinite(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.not_finite,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util_js_1.util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil_js_1.errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil_js_1.errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil_js_1.errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil_js_1.errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new ZodNumber({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil_js_1.errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodNumber({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    int(message) {
      return this._addCheck({
        kind: "int",
        message: errorUtil_js_1.errorUtil.toString(message)
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: false,
        message: errorUtil_js_1.errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: false,
        message: errorUtil_js_1.errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: true,
        message: errorUtil_js_1.errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: true,
        message: errorUtil_js_1.errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil_js_1.errorUtil.toString(message)
      });
    }
    finite(message) {
      return this._addCheck({
        kind: "finite",
        message: errorUtil_js_1.errorUtil.toString(message)
      });
    }
    safe(message) {
      return this._addCheck({
        kind: "min",
        inclusive: true,
        value: Number.MIN_SAFE_INTEGER,
        message: errorUtil_js_1.errorUtil.toString(message)
      })._addCheck({
        kind: "max",
        inclusive: true,
        value: Number.MAX_SAFE_INTEGER,
        message: errorUtil_js_1.errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
    get isInt() {
      return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util_js_1.util.isInteger(ch.value));
    }
    get isFinite() {
      let max = null;
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
          return true;
        } else if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        } else if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return Number.isFinite(min) && Number.isFinite(max);
    }
  }
  types$1.ZodNumber = ZodNumber;
  ZodNumber.create = (params) => {
    return new ZodNumber({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodNumber,
      coerce: params?.coerce || false,
      ...processCreateParams(params)
    });
  };
  class ZodBigInt extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
    }
    _parse(input) {
      if (this._def.coerce) {
        try {
          input.data = BigInt(input.data);
        } catch {
          return this._getInvalidInput(input);
        }
      }
      const parsedType = this._getType(input);
      if (parsedType !== util_js_1.ZodParsedType.bigint) {
        return this._getInvalidInput(input);
      }
      let ctx = void 0;
      const status = new parseUtil_js_1.ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.too_small,
              type: "bigint",
              minimum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.too_big,
              type: "bigint",
              maximum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (input.data % check.value !== BigInt(0)) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util_js_1.util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _getInvalidInput(input) {
      const ctx = this._getOrReturnCtx(input);
      (0, parseUtil_js_1.addIssueToContext)(ctx, {
        code: ZodError_js_1.ZodIssueCode.invalid_type,
        expected: util_js_1.ZodParsedType.bigint,
        received: ctx.parsedType
      });
      return parseUtil_js_1.INVALID;
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil_js_1.errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil_js_1.errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil_js_1.errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil_js_1.errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new ZodBigInt({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil_js_1.errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodBigInt({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil_js_1.errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil_js_1.errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil_js_1.errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil_js_1.errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil_js_1.errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  }
  types$1.ZodBigInt = ZodBigInt;
  ZodBigInt.create = (params) => {
    return new ZodBigInt({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodBigInt,
      coerce: params?.coerce ?? false,
      ...processCreateParams(params)
    });
  };
  class ZodBoolean extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = Boolean(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== util_js_1.ZodParsedType.boolean) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          code: ZodError_js_1.ZodIssueCode.invalid_type,
          expected: util_js_1.ZodParsedType.boolean,
          received: ctx.parsedType
        });
        return parseUtil_js_1.INVALID;
      }
      return (0, parseUtil_js_1.OK)(input.data);
    }
  }
  types$1.ZodBoolean = ZodBoolean;
  ZodBoolean.create = (params) => {
    return new ZodBoolean({
      typeName: ZodFirstPartyTypeKind.ZodBoolean,
      coerce: params?.coerce || false,
      ...processCreateParams(params)
    });
  };
  class ZodDate extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = new Date(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== util_js_1.ZodParsedType.date) {
        const ctx2 = this._getOrReturnCtx(input);
        (0, parseUtil_js_1.addIssueToContext)(ctx2, {
          code: ZodError_js_1.ZodIssueCode.invalid_type,
          expected: util_js_1.ZodParsedType.date,
          received: ctx2.parsedType
        });
        return parseUtil_js_1.INVALID;
      }
      if (Number.isNaN(input.data.getTime())) {
        const ctx2 = this._getOrReturnCtx(input);
        (0, parseUtil_js_1.addIssueToContext)(ctx2, {
          code: ZodError_js_1.ZodIssueCode.invalid_date
        });
        return parseUtil_js_1.INVALID;
      }
      const status = new parseUtil_js_1.ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.getTime() < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.too_small,
              message: check.message,
              inclusive: true,
              exact: false,
              minimum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.getTime() > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.too_big,
              message: check.message,
              inclusive: true,
              exact: false,
              maximum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else {
          util_js_1.util.assertNever(check);
        }
      }
      return {
        status: status.value,
        value: new Date(input.data.getTime())
      };
    }
    _addCheck(check) {
      return new ZodDate({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    min(minDate, message) {
      return this._addCheck({
        kind: "min",
        value: minDate.getTime(),
        message: errorUtil_js_1.errorUtil.toString(message)
      });
    }
    max(maxDate, message) {
      return this._addCheck({
        kind: "max",
        value: maxDate.getTime(),
        message: errorUtil_js_1.errorUtil.toString(message)
      });
    }
    get minDate() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min != null ? new Date(min) : null;
    }
    get maxDate() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max != null ? new Date(max) : null;
    }
  }
  types$1.ZodDate = ZodDate;
  ZodDate.create = (params) => {
    return new ZodDate({
      checks: [],
      coerce: params?.coerce || false,
      typeName: ZodFirstPartyTypeKind.ZodDate,
      ...processCreateParams(params)
    });
  };
  class ZodSymbol extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== util_js_1.ZodParsedType.symbol) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          code: ZodError_js_1.ZodIssueCode.invalid_type,
          expected: util_js_1.ZodParsedType.symbol,
          received: ctx.parsedType
        });
        return parseUtil_js_1.INVALID;
      }
      return (0, parseUtil_js_1.OK)(input.data);
    }
  }
  types$1.ZodSymbol = ZodSymbol;
  ZodSymbol.create = (params) => {
    return new ZodSymbol({
      typeName: ZodFirstPartyTypeKind.ZodSymbol,
      ...processCreateParams(params)
    });
  };
  class ZodUndefined extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== util_js_1.ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          code: ZodError_js_1.ZodIssueCode.invalid_type,
          expected: util_js_1.ZodParsedType.undefined,
          received: ctx.parsedType
        });
        return parseUtil_js_1.INVALID;
      }
      return (0, parseUtil_js_1.OK)(input.data);
    }
  }
  types$1.ZodUndefined = ZodUndefined;
  ZodUndefined.create = (params) => {
    return new ZodUndefined({
      typeName: ZodFirstPartyTypeKind.ZodUndefined,
      ...processCreateParams(params)
    });
  };
  class ZodNull extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== util_js_1.ZodParsedType.null) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          code: ZodError_js_1.ZodIssueCode.invalid_type,
          expected: util_js_1.ZodParsedType.null,
          received: ctx.parsedType
        });
        return parseUtil_js_1.INVALID;
      }
      return (0, parseUtil_js_1.OK)(input.data);
    }
  }
  types$1.ZodNull = ZodNull;
  ZodNull.create = (params) => {
    return new ZodNull({
      typeName: ZodFirstPartyTypeKind.ZodNull,
      ...processCreateParams(params)
    });
  };
  class ZodAny extends ZodType {
    constructor() {
      super(...arguments);
      this._any = true;
    }
    _parse(input) {
      return (0, parseUtil_js_1.OK)(input.data);
    }
  }
  types$1.ZodAny = ZodAny;
  ZodAny.create = (params) => {
    return new ZodAny({
      typeName: ZodFirstPartyTypeKind.ZodAny,
      ...processCreateParams(params)
    });
  };
  class ZodUnknown extends ZodType {
    constructor() {
      super(...arguments);
      this._unknown = true;
    }
    _parse(input) {
      return (0, parseUtil_js_1.OK)(input.data);
    }
  }
  types$1.ZodUnknown = ZodUnknown;
  ZodUnknown.create = (params) => {
    return new ZodUnknown({
      typeName: ZodFirstPartyTypeKind.ZodUnknown,
      ...processCreateParams(params)
    });
  };
  class ZodNever extends ZodType {
    _parse(input) {
      const ctx = this._getOrReturnCtx(input);
      (0, parseUtil_js_1.addIssueToContext)(ctx, {
        code: ZodError_js_1.ZodIssueCode.invalid_type,
        expected: util_js_1.ZodParsedType.never,
        received: ctx.parsedType
      });
      return parseUtil_js_1.INVALID;
    }
  }
  types$1.ZodNever = ZodNever;
  ZodNever.create = (params) => {
    return new ZodNever({
      typeName: ZodFirstPartyTypeKind.ZodNever,
      ...processCreateParams(params)
    });
  };
  class ZodVoid extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== util_js_1.ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          code: ZodError_js_1.ZodIssueCode.invalid_type,
          expected: util_js_1.ZodParsedType.void,
          received: ctx.parsedType
        });
        return parseUtil_js_1.INVALID;
      }
      return (0, parseUtil_js_1.OK)(input.data);
    }
  }
  types$1.ZodVoid = ZodVoid;
  ZodVoid.create = (params) => {
    return new ZodVoid({
      typeName: ZodFirstPartyTypeKind.ZodVoid,
      ...processCreateParams(params)
    });
  };
  class ZodArray extends ZodType {
    _parse(input) {
      const { ctx, status } = this._processInputParams(input);
      const def = this._def;
      if (ctx.parsedType !== util_js_1.ZodParsedType.array) {
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          code: ZodError_js_1.ZodIssueCode.invalid_type,
          expected: util_js_1.ZodParsedType.array,
          received: ctx.parsedType
        });
        return parseUtil_js_1.INVALID;
      }
      if (def.exactLength !== null) {
        const tooBig = ctx.data.length > def.exactLength.value;
        const tooSmall = ctx.data.length < def.exactLength.value;
        if (tooBig || tooSmall) {
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: tooBig ? ZodError_js_1.ZodIssueCode.too_big : ZodError_js_1.ZodIssueCode.too_small,
            minimum: tooSmall ? def.exactLength.value : void 0,
            maximum: tooBig ? def.exactLength.value : void 0,
            type: "array",
            inclusive: true,
            exact: true,
            message: def.exactLength.message
          });
          status.dirty();
        }
      }
      if (def.minLength !== null) {
        if (ctx.data.length < def.minLength.value) {
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.too_small,
            minimum: def.minLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.minLength.message
          });
          status.dirty();
        }
      }
      if (def.maxLength !== null) {
        if (ctx.data.length > def.maxLength.value) {
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.too_big,
            maximum: def.maxLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.maxLength.message
          });
          status.dirty();
        }
      }
      if (ctx.common.async) {
        return Promise.all([...ctx.data].map((item, i) => {
          return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        })).then((result2) => {
          return parseUtil_js_1.ParseStatus.mergeArray(status, result2);
        });
      }
      const result = [...ctx.data].map((item, i) => {
        return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      });
      return parseUtil_js_1.ParseStatus.mergeArray(status, result);
    }
    get element() {
      return this._def.type;
    }
    min(minLength, message) {
      return new ZodArray({
        ...this._def,
        minLength: { value: minLength, message: errorUtil_js_1.errorUtil.toString(message) }
      });
    }
    max(maxLength, message) {
      return new ZodArray({
        ...this._def,
        maxLength: { value: maxLength, message: errorUtil_js_1.errorUtil.toString(message) }
      });
    }
    length(len, message) {
      return new ZodArray({
        ...this._def,
        exactLength: { value: len, message: errorUtil_js_1.errorUtil.toString(message) }
      });
    }
    nonempty(message) {
      return this.min(1, message);
    }
  }
  types$1.ZodArray = ZodArray;
  ZodArray.create = (schema2, params) => {
    return new ZodArray({
      type: schema2,
      minLength: null,
      maxLength: null,
      exactLength: null,
      typeName: ZodFirstPartyTypeKind.ZodArray,
      ...processCreateParams(params)
    });
  };
  function deepPartialify(schema2) {
    if (schema2 instanceof ZodObject) {
      const newShape = {};
      for (const key2 in schema2.shape) {
        const fieldSchema = schema2.shape[key2];
        newShape[key2] = ZodOptional.create(deepPartialify(fieldSchema));
      }
      return new ZodObject({
        ...schema2._def,
        shape: () => newShape
      });
    } else if (schema2 instanceof ZodArray) {
      return new ZodArray({
        ...schema2._def,
        type: deepPartialify(schema2.element)
      });
    } else if (schema2 instanceof ZodOptional) {
      return ZodOptional.create(deepPartialify(schema2.unwrap()));
    } else if (schema2 instanceof ZodNullable) {
      return ZodNullable.create(deepPartialify(schema2.unwrap()));
    } else if (schema2 instanceof ZodTuple) {
      return ZodTuple.create(schema2.items.map((item) => deepPartialify(item)));
    } else {
      return schema2;
    }
  }
  class ZodObject extends ZodType {
    constructor() {
      super(...arguments);
      this._cached = null;
      this.nonstrict = this.passthrough;
      this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      const shape = this._def.shape();
      const keys = util_js_1.util.objectKeys(shape);
      this._cached = { shape, keys };
      return this._cached;
    }
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== util_js_1.ZodParsedType.object) {
        const ctx2 = this._getOrReturnCtx(input);
        (0, parseUtil_js_1.addIssueToContext)(ctx2, {
          code: ZodError_js_1.ZodIssueCode.invalid_type,
          expected: util_js_1.ZodParsedType.object,
          received: ctx2.parsedType
        });
        return parseUtil_js_1.INVALID;
      }
      const { status, ctx } = this._processInputParams(input);
      const { shape, keys: shapeKeys } = this._getCached();
      const extraKeys = [];
      if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
        for (const key2 in ctx.data) {
          if (!shapeKeys.includes(key2)) {
            extraKeys.push(key2);
          }
        }
      }
      const pairs = [];
      for (const key2 of shapeKeys) {
        const keyValidator = shape[key2];
        const value = ctx.data[key2];
        pairs.push({
          key: { status: "valid", value: key2 },
          value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key2)),
          alwaysSet: key2 in ctx.data
        });
      }
      if (this._def.catchall instanceof ZodNever) {
        const unknownKeys = this._def.unknownKeys;
        if (unknownKeys === "passthrough") {
          for (const key2 of extraKeys) {
            pairs.push({
              key: { status: "valid", value: key2 },
              value: { status: "valid", value: ctx.data[key2] }
            });
          }
        } else if (unknownKeys === "strict") {
          if (extraKeys.length > 0) {
            (0, parseUtil_js_1.addIssueToContext)(ctx, {
              code: ZodError_js_1.ZodIssueCode.unrecognized_keys,
              keys: extraKeys
            });
            status.dirty();
          }
        } else if (unknownKeys === "strip") ;
        else {
          throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
        }
      } else {
        const catchall = this._def.catchall;
        for (const key2 of extraKeys) {
          const value = ctx.data[key2];
          pairs.push({
            key: { status: "valid", value: key2 },
            value: catchall._parse(
              new ParseInputLazyPath(ctx, value, ctx.path, key2)
              //, ctx.child(key), value, getParsedType(value)
            ),
            alwaysSet: key2 in ctx.data
          });
        }
      }
      if (ctx.common.async) {
        return Promise.resolve().then(async () => {
          const syncPairs = [];
          for (const pair of pairs) {
            const key2 = await pair.key;
            const value = await pair.value;
            syncPairs.push({
              key: key2,
              value,
              alwaysSet: pair.alwaysSet
            });
          }
          return syncPairs;
        }).then((syncPairs) => {
          return parseUtil_js_1.ParseStatus.mergeObjectSync(status, syncPairs);
        });
      } else {
        return parseUtil_js_1.ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get shape() {
      return this._def.shape();
    }
    strict(message) {
      errorUtil_js_1.errorUtil.errToObj;
      return new ZodObject({
        ...this._def,
        unknownKeys: "strict",
        ...message !== void 0 ? {
          errorMap: (issue, ctx) => {
            const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
            if (issue.code === "unrecognized_keys")
              return {
                message: errorUtil_js_1.errorUtil.errToObj(message).message ?? defaultError
              };
            return {
              message: defaultError
            };
          }
        } : {}
      });
    }
    strip() {
      return new ZodObject({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new ZodObject({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(augmentation) {
      return new ZodObject({
        ...this._def,
        shape: () => ({
          ...this._def.shape(),
          ...augmentation
        })
      });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(merging) {
      const merged = new ZodObject({
        unknownKeys: merging._def.unknownKeys,
        catchall: merging._def.catchall,
        shape: () => ({
          ...this._def.shape(),
          ...merging._def.shape()
        }),
        typeName: ZodFirstPartyTypeKind.ZodObject
      });
      return merged;
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(key2, schema2) {
      return this.augment({ [key2]: schema2 });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(index) {
      return new ZodObject({
        ...this._def,
        catchall: index
      });
    }
    pick(mask) {
      const shape = {};
      for (const key2 of util_js_1.util.objectKeys(mask)) {
        if (mask[key2] && this.shape[key2]) {
          shape[key2] = this.shape[key2];
        }
      }
      return new ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    omit(mask) {
      const shape = {};
      for (const key2 of util_js_1.util.objectKeys(this.shape)) {
        if (!mask[key2]) {
          shape[key2] = this.shape[key2];
        }
      }
      return new ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    /**
     * @deprecated
     */
    deepPartial() {
      return deepPartialify(this);
    }
    partial(mask) {
      const newShape = {};
      for (const key2 of util_js_1.util.objectKeys(this.shape)) {
        const fieldSchema = this.shape[key2];
        if (mask && !mask[key2]) {
          newShape[key2] = fieldSchema;
        } else {
          newShape[key2] = fieldSchema.optional();
        }
      }
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    required(mask) {
      const newShape = {};
      for (const key2 of util_js_1.util.objectKeys(this.shape)) {
        if (mask && !mask[key2]) {
          newShape[key2] = this.shape[key2];
        } else {
          const fieldSchema = this.shape[key2];
          let newField = fieldSchema;
          while (newField instanceof ZodOptional) {
            newField = newField._def.innerType;
          }
          newShape[key2] = newField;
        }
      }
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    keyof() {
      return createZodEnum(util_js_1.util.objectKeys(this.shape));
    }
  }
  types$1.ZodObject = ZodObject;
  ZodObject.create = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strict",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
      shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  class ZodUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const options = this._def.options;
      function handleResults(results) {
        for (const result of results) {
          if (result.result.status === "valid") {
            return result.result;
          }
        }
        for (const result of results) {
          if (result.result.status === "dirty") {
            ctx.common.issues.push(...result.ctx.common.issues);
            return result.result;
          }
        }
        const unionErrors = results.map((result) => new ZodError_js_1.ZodError(result.ctx.common.issues));
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          code: ZodError_js_1.ZodIssueCode.invalid_union,
          unionErrors
        });
        return parseUtil_js_1.INVALID;
      }
      if (ctx.common.async) {
        return Promise.all(options.map(async (option) => {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            }),
            ctx: childCtx
          };
        })).then(handleResults);
      } else {
        let dirty = void 0;
        const issues = [];
        for (const option of options) {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          const result = option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          });
          if (result.status === "valid") {
            return result;
          } else if (result.status === "dirty" && !dirty) {
            dirty = { result, ctx: childCtx };
          }
          if (childCtx.common.issues.length) {
            issues.push(childCtx.common.issues);
          }
        }
        if (dirty) {
          ctx.common.issues.push(...dirty.ctx.common.issues);
          return dirty.result;
        }
        const unionErrors = issues.map((issues2) => new ZodError_js_1.ZodError(issues2));
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          code: ZodError_js_1.ZodIssueCode.invalid_union,
          unionErrors
        });
        return parseUtil_js_1.INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  }
  types$1.ZodUnion = ZodUnion;
  ZodUnion.create = (types2, params) => {
    return new ZodUnion({
      options: types2,
      typeName: ZodFirstPartyTypeKind.ZodUnion,
      ...processCreateParams(params)
    });
  };
  const getDiscriminator = (type) => {
    if (type instanceof ZodLazy) {
      return getDiscriminator(type.schema);
    } else if (type instanceof ZodEffects) {
      return getDiscriminator(type.innerType());
    } else if (type instanceof ZodLiteral) {
      return [type.value];
    } else if (type instanceof ZodEnum) {
      return type.options;
    } else if (type instanceof ZodNativeEnum) {
      return util_js_1.util.objectValues(type.enum);
    } else if (type instanceof ZodDefault) {
      return getDiscriminator(type._def.innerType);
    } else if (type instanceof ZodUndefined) {
      return [void 0];
    } else if (type instanceof ZodNull) {
      return [null];
    } else if (type instanceof ZodOptional) {
      return [void 0, ...getDiscriminator(type.unwrap())];
    } else if (type instanceof ZodNullable) {
      return [null, ...getDiscriminator(type.unwrap())];
    } else if (type instanceof ZodBranded) {
      return getDiscriminator(type.unwrap());
    } else if (type instanceof ZodReadonly) {
      return getDiscriminator(type.unwrap());
    } else if (type instanceof ZodCatch) {
      return getDiscriminator(type._def.innerType);
    } else {
      return [];
    }
  };
  class ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== util_js_1.ZodParsedType.object) {
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          code: ZodError_js_1.ZodIssueCode.invalid_type,
          expected: util_js_1.ZodParsedType.object,
          received: ctx.parsedType
        });
        return parseUtil_js_1.INVALID;
      }
      const discriminator = this.discriminator;
      const discriminatorValue = ctx.data[discriminator];
      const option = this.optionsMap.get(discriminatorValue);
      if (!option) {
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          code: ZodError_js_1.ZodIssueCode.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [discriminator]
        });
        return parseUtil_js_1.INVALID;
      }
      if (ctx.common.async) {
        return option._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      } else {
        return option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(discriminator, options, params) {
      const optionsMap = /* @__PURE__ */ new Map();
      for (const type of options) {
        const discriminatorValues = getDiscriminator(type.shape[discriminator]);
        if (!discriminatorValues.length) {
          throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
        }
        for (const value of discriminatorValues) {
          if (optionsMap.has(value)) {
            throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
          }
          optionsMap.set(value, type);
        }
      }
      return new ZodDiscriminatedUnion({
        typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
        discriminator,
        options,
        optionsMap,
        ...processCreateParams(params)
      });
    }
  }
  types$1.ZodDiscriminatedUnion = ZodDiscriminatedUnion;
  function mergeValues(a, b) {
    const aType = (0, util_js_1.getParsedType)(a);
    const bType = (0, util_js_1.getParsedType)(b);
    if (a === b) {
      return { valid: true, data: a };
    } else if (aType === util_js_1.ZodParsedType.object && bType === util_js_1.ZodParsedType.object) {
      const bKeys = util_js_1.util.objectKeys(b);
      const sharedKeys = util_js_1.util.objectKeys(a).filter((key2) => bKeys.indexOf(key2) !== -1);
      const newObj = { ...a, ...b };
      for (const key2 of sharedKeys) {
        const sharedValue = mergeValues(a[key2], b[key2]);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newObj[key2] = sharedValue.data;
      }
      return { valid: true, data: newObj };
    } else if (aType === util_js_1.ZodParsedType.array && bType === util_js_1.ZodParsedType.array) {
      if (a.length !== b.length) {
        return { valid: false };
      }
      const newArray = [];
      for (let index = 0; index < a.length; index++) {
        const itemA = a[index];
        const itemB = b[index];
        const sharedValue = mergeValues(itemA, itemB);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newArray.push(sharedValue.data);
      }
      return { valid: true, data: newArray };
    } else if (aType === util_js_1.ZodParsedType.date && bType === util_js_1.ZodParsedType.date && +a === +b) {
      return { valid: true, data: a };
    } else {
      return { valid: false };
    }
  }
  class ZodIntersection extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const handleParsed = (parsedLeft, parsedRight) => {
        if ((0, parseUtil_js_1.isAborted)(parsedLeft) || (0, parseUtil_js_1.isAborted)(parsedRight)) {
          return parseUtil_js_1.INVALID;
        }
        const merged = mergeValues(parsedLeft.value, parsedRight.value);
        if (!merged.valid) {
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.invalid_intersection_types
          });
          return parseUtil_js_1.INVALID;
        }
        if ((0, parseUtil_js_1.isDirty)(parsedLeft) || (0, parseUtil_js_1.isDirty)(parsedRight)) {
          status.dirty();
        }
        return { status: status.value, value: merged.data };
      };
      if (ctx.common.async) {
        return Promise.all([
          this._def.left._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }),
          this._def.right._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          })
        ]).then(([left, right]) => handleParsed(left, right));
      } else {
        return handleParsed(this._def.left._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }), this._def.right._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }));
      }
    }
  }
  types$1.ZodIntersection = ZodIntersection;
  ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
      left,
      right,
      typeName: ZodFirstPartyTypeKind.ZodIntersection,
      ...processCreateParams(params)
    });
  };
  class ZodTuple extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== util_js_1.ZodParsedType.array) {
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          code: ZodError_js_1.ZodIssueCode.invalid_type,
          expected: util_js_1.ZodParsedType.array,
          received: ctx.parsedType
        });
        return parseUtil_js_1.INVALID;
      }
      if (ctx.data.length < this._def.items.length) {
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          code: ZodError_js_1.ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        return parseUtil_js_1.INVALID;
      }
      const rest = this._def.rest;
      if (!rest && ctx.data.length > this._def.items.length) {
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          code: ZodError_js_1.ZodIssueCode.too_big,
          maximum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        status.dirty();
      }
      const items = [...ctx.data].map((item, itemIndex) => {
        const schema2 = this._def.items[itemIndex] || this._def.rest;
        if (!schema2)
          return null;
        return schema2._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
      }).filter((x) => !!x);
      if (ctx.common.async) {
        return Promise.all(items).then((results) => {
          return parseUtil_js_1.ParseStatus.mergeArray(status, results);
        });
      } else {
        return parseUtil_js_1.ParseStatus.mergeArray(status, items);
      }
    }
    get items() {
      return this._def.items;
    }
    rest(rest) {
      return new ZodTuple({
        ...this._def,
        rest
      });
    }
  }
  types$1.ZodTuple = ZodTuple;
  ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
      items: schemas,
      typeName: ZodFirstPartyTypeKind.ZodTuple,
      rest: null,
      ...processCreateParams(params)
    });
  };
  class ZodRecord extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== util_js_1.ZodParsedType.object) {
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          code: ZodError_js_1.ZodIssueCode.invalid_type,
          expected: util_js_1.ZodParsedType.object,
          received: ctx.parsedType
        });
        return parseUtil_js_1.INVALID;
      }
      const pairs = [];
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      for (const key2 in ctx.data) {
        pairs.push({
          key: keyType._parse(new ParseInputLazyPath(ctx, key2, ctx.path, key2)),
          value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key2], ctx.path, key2)),
          alwaysSet: key2 in ctx.data
        });
      }
      if (ctx.common.async) {
        return parseUtil_js_1.ParseStatus.mergeObjectAsync(status, pairs);
      } else {
        return parseUtil_js_1.ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get element() {
      return this._def.valueType;
    }
    static create(first, second, third) {
      if (second instanceof ZodType) {
        return new ZodRecord({
          keyType: first,
          valueType: second,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(third)
        });
      }
      return new ZodRecord({
        keyType: ZodString.create(),
        valueType: first,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(second)
      });
    }
  }
  types$1.ZodRecord = ZodRecord;
  class ZodMap extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== util_js_1.ZodParsedType.map) {
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          code: ZodError_js_1.ZodIssueCode.invalid_type,
          expected: util_js_1.ZodParsedType.map,
          received: ctx.parsedType
        });
        return parseUtil_js_1.INVALID;
      }
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      const pairs = [...ctx.data.entries()].map(([key2, value], index) => {
        return {
          key: keyType._parse(new ParseInputLazyPath(ctx, key2, ctx.path, [index, "key"])),
          value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
        };
      });
      if (ctx.common.async) {
        const finalMap = /* @__PURE__ */ new Map();
        return Promise.resolve().then(async () => {
          for (const pair of pairs) {
            const key2 = await pair.key;
            const value = await pair.value;
            if (key2.status === "aborted" || value.status === "aborted") {
              return parseUtil_js_1.INVALID;
            }
            if (key2.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key2.value, value.value);
          }
          return { status: status.value, value: finalMap };
        });
      } else {
        const finalMap = /* @__PURE__ */ new Map();
        for (const pair of pairs) {
          const key2 = pair.key;
          const value = pair.value;
          if (key2.status === "aborted" || value.status === "aborted") {
            return parseUtil_js_1.INVALID;
          }
          if (key2.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key2.value, value.value);
        }
        return { status: status.value, value: finalMap };
      }
    }
  }
  types$1.ZodMap = ZodMap;
  ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
      valueType,
      keyType,
      typeName: ZodFirstPartyTypeKind.ZodMap,
      ...processCreateParams(params)
    });
  };
  class ZodSet extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== util_js_1.ZodParsedType.set) {
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          code: ZodError_js_1.ZodIssueCode.invalid_type,
          expected: util_js_1.ZodParsedType.set,
          received: ctx.parsedType
        });
        return parseUtil_js_1.INVALID;
      }
      const def = this._def;
      if (def.minSize !== null) {
        if (ctx.data.size < def.minSize.value) {
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.too_small,
            minimum: def.minSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.minSize.message
          });
          status.dirty();
        }
      }
      if (def.maxSize !== null) {
        if (ctx.data.size > def.maxSize.value) {
          (0, parseUtil_js_1.addIssueToContext)(ctx, {
            code: ZodError_js_1.ZodIssueCode.too_big,
            maximum: def.maxSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.maxSize.message
          });
          status.dirty();
        }
      }
      const valueType = this._def.valueType;
      function finalizeSet(elements2) {
        const parsedSet = /* @__PURE__ */ new Set();
        for (const element of elements2) {
          if (element.status === "aborted")
            return parseUtil_js_1.INVALID;
          if (element.status === "dirty")
            status.dirty();
          parsedSet.add(element.value);
        }
        return { status: status.value, value: parsedSet };
      }
      const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
      if (ctx.common.async) {
        return Promise.all(elements).then((elements2) => finalizeSet(elements2));
      } else {
        return finalizeSet(elements);
      }
    }
    min(minSize, message) {
      return new ZodSet({
        ...this._def,
        minSize: { value: minSize, message: errorUtil_js_1.errorUtil.toString(message) }
      });
    }
    max(maxSize, message) {
      return new ZodSet({
        ...this._def,
        maxSize: { value: maxSize, message: errorUtil_js_1.errorUtil.toString(message) }
      });
    }
    size(size, message) {
      return this.min(size, message).max(size, message);
    }
    nonempty(message) {
      return this.min(1, message);
    }
  }
  types$1.ZodSet = ZodSet;
  ZodSet.create = (valueType, params) => {
    return new ZodSet({
      valueType,
      minSize: null,
      maxSize: null,
      typeName: ZodFirstPartyTypeKind.ZodSet,
      ...processCreateParams(params)
    });
  };
  class ZodFunction extends ZodType {
    constructor() {
      super(...arguments);
      this.validate = this.implement;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== util_js_1.ZodParsedType.function) {
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          code: ZodError_js_1.ZodIssueCode.invalid_type,
          expected: util_js_1.ZodParsedType.function,
          received: ctx.parsedType
        });
        return parseUtil_js_1.INVALID;
      }
      function makeArgsIssue(args, error2) {
        return (0, parseUtil_js_1.makeIssue)({
          data: args,
          path: ctx.path,
          errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, (0, errors_js_1.getErrorMap)(), errors_js_1.defaultErrorMap].filter((x) => !!x),
          issueData: {
            code: ZodError_js_1.ZodIssueCode.invalid_arguments,
            argumentsError: error2
          }
        });
      }
      function makeReturnsIssue(returns, error2) {
        return (0, parseUtil_js_1.makeIssue)({
          data: returns,
          path: ctx.path,
          errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, (0, errors_js_1.getErrorMap)(), errors_js_1.defaultErrorMap].filter((x) => !!x),
          issueData: {
            code: ZodError_js_1.ZodIssueCode.invalid_return_type,
            returnTypeError: error2
          }
        });
      }
      const params = { errorMap: ctx.common.contextualErrorMap };
      const fn = ctx.data;
      if (this._def.returns instanceof ZodPromise) {
        const me = this;
        return (0, parseUtil_js_1.OK)(async function(...args) {
          const error2 = new ZodError_js_1.ZodError([]);
          const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
            error2.addIssue(makeArgsIssue(args, e));
            throw error2;
          });
          const result = await Reflect.apply(fn, this, parsedArgs);
          const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
            error2.addIssue(makeReturnsIssue(result, e));
            throw error2;
          });
          return parsedReturns;
        });
      } else {
        const me = this;
        return (0, parseUtil_js_1.OK)(function(...args) {
          const parsedArgs = me._def.args.safeParse(args, params);
          if (!parsedArgs.success) {
            throw new ZodError_js_1.ZodError([makeArgsIssue(args, parsedArgs.error)]);
          }
          const result = Reflect.apply(fn, this, parsedArgs.data);
          const parsedReturns = me._def.returns.safeParse(result, params);
          if (!parsedReturns.success) {
            throw new ZodError_js_1.ZodError([makeReturnsIssue(result, parsedReturns.error)]);
          }
          return parsedReturns.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...items) {
      return new ZodFunction({
        ...this._def,
        args: ZodTuple.create(items).rest(ZodUnknown.create())
      });
    }
    returns(returnType) {
      return new ZodFunction({
        ...this._def,
        returns: returnType
      });
    }
    implement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    strictImplement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    static create(args, returns, params) {
      return new ZodFunction({
        args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
        returns: returns || ZodUnknown.create(),
        typeName: ZodFirstPartyTypeKind.ZodFunction,
        ...processCreateParams(params)
      });
    }
  }
  types$1.ZodFunction = ZodFunction;
  class ZodLazy extends ZodType {
    get schema() {
      return this._def.getter();
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const lazySchema = this._def.getter();
      return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
  }
  types$1.ZodLazy = ZodLazy;
  ZodLazy.create = (getter, params) => {
    return new ZodLazy({
      getter,
      typeName: ZodFirstPartyTypeKind.ZodLazy,
      ...processCreateParams(params)
    });
  };
  class ZodLiteral extends ZodType {
    _parse(input) {
      if (input.data !== this._def.value) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          received: ctx.data,
          code: ZodError_js_1.ZodIssueCode.invalid_literal,
          expected: this._def.value
        });
        return parseUtil_js_1.INVALID;
      }
      return { status: "valid", value: input.data };
    }
    get value() {
      return this._def.value;
    }
  }
  types$1.ZodLiteral = ZodLiteral;
  ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
      value,
      typeName: ZodFirstPartyTypeKind.ZodLiteral,
      ...processCreateParams(params)
    });
  };
  function createZodEnum(values, params) {
    return new ZodEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodEnum,
      ...processCreateParams(params)
    });
  }
  class ZodEnum extends ZodType {
    _parse(input) {
      if (typeof input.data !== "string") {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          expected: util_js_1.util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodError_js_1.ZodIssueCode.invalid_type
        });
        return parseUtil_js_1.INVALID;
      }
      if (!this._cache) {
        this._cache = new Set(this._def.values);
      }
      if (!this._cache.has(input.data)) {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          received: ctx.data,
          code: ZodError_js_1.ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return parseUtil_js_1.INVALID;
      }
      return (0, parseUtil_js_1.OK)(input.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Values() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    extract(values, newDef = this._def) {
      return ZodEnum.create(values, {
        ...this._def,
        ...newDef
      });
    }
    exclude(values, newDef = this._def) {
      return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
        ...this._def,
        ...newDef
      });
    }
  }
  types$1.ZodEnum = ZodEnum;
  ZodEnum.create = createZodEnum;
  class ZodNativeEnum extends ZodType {
    _parse(input) {
      const nativeEnumValues = util_js_1.util.getValidEnumValues(this._def.values);
      const ctx = this._getOrReturnCtx(input);
      if (ctx.parsedType !== util_js_1.ZodParsedType.string && ctx.parsedType !== util_js_1.ZodParsedType.number) {
        const expectedValues = util_js_1.util.objectValues(nativeEnumValues);
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          expected: util_js_1.util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodError_js_1.ZodIssueCode.invalid_type
        });
        return parseUtil_js_1.INVALID;
      }
      if (!this._cache) {
        this._cache = new Set(util_js_1.util.getValidEnumValues(this._def.values));
      }
      if (!this._cache.has(input.data)) {
        const expectedValues = util_js_1.util.objectValues(nativeEnumValues);
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          received: ctx.data,
          code: ZodError_js_1.ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return parseUtil_js_1.INVALID;
      }
      return (0, parseUtil_js_1.OK)(input.data);
    }
    get enum() {
      return this._def.values;
    }
  }
  types$1.ZodNativeEnum = ZodNativeEnum;
  ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
      ...processCreateParams(params)
    });
  };
  class ZodPromise extends ZodType {
    unwrap() {
      return this._def.type;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== util_js_1.ZodParsedType.promise && ctx.common.async === false) {
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          code: ZodError_js_1.ZodIssueCode.invalid_type,
          expected: util_js_1.ZodParsedType.promise,
          received: ctx.parsedType
        });
        return parseUtil_js_1.INVALID;
      }
      const promisified = ctx.parsedType === util_js_1.ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
      return (0, parseUtil_js_1.OK)(promisified.then((data) => {
        return this._def.type.parseAsync(data, {
          path: ctx.path,
          errorMap: ctx.common.contextualErrorMap
        });
      }));
    }
  }
  types$1.ZodPromise = ZodPromise;
  ZodPromise.create = (schema2, params) => {
    return new ZodPromise({
      type: schema2,
      typeName: ZodFirstPartyTypeKind.ZodPromise,
      ...processCreateParams(params)
    });
  };
  class ZodEffects extends ZodType {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const effect = this._def.effect || null;
      const checkCtx = {
        addIssue: (arg) => {
          (0, parseUtil_js_1.addIssueToContext)(ctx, arg);
          if (arg.fatal) {
            status.abort();
          } else {
            status.dirty();
          }
        },
        get path() {
          return ctx.path;
        }
      };
      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
      if (effect.type === "preprocess") {
        const processed = effect.transform(ctx.data, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(processed).then(async (processed2) => {
            if (status.value === "aborted")
              return parseUtil_js_1.INVALID;
            const result = await this._def.schema._parseAsync({
              data: processed2,
              path: ctx.path,
              parent: ctx
            });
            if (result.status === "aborted")
              return parseUtil_js_1.INVALID;
            if (result.status === "dirty")
              return (0, parseUtil_js_1.DIRTY)(result.value);
            if (status.value === "dirty")
              return (0, parseUtil_js_1.DIRTY)(result.value);
            return result;
          });
        } else {
          if (status.value === "aborted")
            return parseUtil_js_1.INVALID;
          const result = this._def.schema._parseSync({
            data: processed,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return parseUtil_js_1.INVALID;
          if (result.status === "dirty")
            return (0, parseUtil_js_1.DIRTY)(result.value);
          if (status.value === "dirty")
            return (0, parseUtil_js_1.DIRTY)(result.value);
          return result;
        }
      }
      if (effect.type === "refinement") {
        const executeRefinement = (acc) => {
          const result = effect.refinement(acc, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(result);
          }
          if (result instanceof Promise) {
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          }
          return acc;
        };
        if (ctx.common.async === false) {
          const inner = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inner.status === "aborted")
            return parseUtil_js_1.INVALID;
          if (inner.status === "dirty")
            status.dirty();
          executeRefinement(inner.value);
          return { status: status.value, value: inner.value };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
            if (inner.status === "aborted")
              return parseUtil_js_1.INVALID;
            if (inner.status === "dirty")
              status.dirty();
            return executeRefinement(inner.value).then(() => {
              return { status: status.value, value: inner.value };
            });
          });
        }
      }
      if (effect.type === "transform") {
        if (ctx.common.async === false) {
          const base = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (!(0, parseUtil_js_1.isValid)(base))
            return parseUtil_js_1.INVALID;
          const result = effect.transform(base.value, checkCtx);
          if (result instanceof Promise) {
            throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
          }
          return { status: status.value, value: result };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
            if (!(0, parseUtil_js_1.isValid)(base))
              return parseUtil_js_1.INVALID;
            return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
              status: status.value,
              value: result
            }));
          });
        }
      }
      util_js_1.util.assertNever(effect);
    }
  }
  types$1.ZodEffects = ZodEffects;
  types$1.ZodTransformer = ZodEffects;
  ZodEffects.create = (schema2, effect, params) => {
    return new ZodEffects({
      schema: schema2,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect,
      ...processCreateParams(params)
    });
  };
  ZodEffects.createWithPreprocess = (preprocess, schema2, params) => {
    return new ZodEffects({
      schema: schema2,
      effect: { type: "preprocess", transform: preprocess },
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      ...processCreateParams(params)
    });
  };
  class ZodOptional extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === util_js_1.ZodParsedType.undefined) {
        return (0, parseUtil_js_1.OK)(void 0);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  types$1.ZodOptional = ZodOptional;
  ZodOptional.create = (type, params) => {
    return new ZodOptional({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodOptional,
      ...processCreateParams(params)
    });
  };
  class ZodNullable extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === util_js_1.ZodParsedType.null) {
        return (0, parseUtil_js_1.OK)(null);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  types$1.ZodNullable = ZodNullable;
  ZodNullable.create = (type, params) => {
    return new ZodNullable({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodNullable,
      ...processCreateParams(params)
    });
  };
  class ZodDefault extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      let data = ctx.data;
      if (ctx.parsedType === util_js_1.ZodParsedType.undefined) {
        data = this._def.defaultValue();
      }
      return this._def.innerType._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  }
  types$1.ZodDefault = ZodDefault;
  ZodDefault.create = (type, params) => {
    return new ZodDefault({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodDefault,
      defaultValue: typeof params.default === "function" ? params.default : () => params.default,
      ...processCreateParams(params)
    });
  };
  class ZodCatch extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const newCtx = {
        ...ctx,
        common: {
          ...ctx.common,
          issues: []
        }
      };
      const result = this._def.innerType._parse({
        data: newCtx.data,
        path: newCtx.path,
        parent: {
          ...newCtx
        }
      });
      if ((0, parseUtil_js_1.isAsync)(result)) {
        return result.then((result2) => {
          return {
            status: "valid",
            value: result2.status === "valid" ? result2.value : this._def.catchValue({
              get error() {
                return new ZodError_js_1.ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        });
      } else {
        return {
          status: "valid",
          value: result.status === "valid" ? result.value : this._def.catchValue({
            get error() {
              return new ZodError_js_1.ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      }
    }
    removeCatch() {
      return this._def.innerType;
    }
  }
  types$1.ZodCatch = ZodCatch;
  ZodCatch.create = (type, params) => {
    return new ZodCatch({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodCatch,
      catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
      ...processCreateParams(params)
    });
  };
  class ZodNaN extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== util_js_1.ZodParsedType.nan) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_js_1.addIssueToContext)(ctx, {
          code: ZodError_js_1.ZodIssueCode.invalid_type,
          expected: util_js_1.ZodParsedType.nan,
          received: ctx.parsedType
        });
        return parseUtil_js_1.INVALID;
      }
      return { status: "valid", value: input.data };
    }
  }
  types$1.ZodNaN = ZodNaN;
  ZodNaN.create = (params) => {
    return new ZodNaN({
      typeName: ZodFirstPartyTypeKind.ZodNaN,
      ...processCreateParams(params)
    });
  };
  types$1.BRAND = Symbol("zod_brand");
  class ZodBranded extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const data = ctx.data;
      return this._def.type._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    unwrap() {
      return this._def.type;
    }
  }
  types$1.ZodBranded = ZodBranded;
  class ZodPipeline extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.common.async) {
        const handleAsync = async () => {
          const inResult = await this._def.in._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return parseUtil_js_1.INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return (0, parseUtil_js_1.DIRTY)(inResult.value);
          } else {
            return this._def.out._parseAsync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        };
        return handleAsync();
      } else {
        const inResult = this._def.in._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return parseUtil_js_1.INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return {
            status: "dirty",
            value: inResult.value
          };
        } else {
          return this._def.out._parseSync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }
    }
    static create(a, b) {
      return new ZodPipeline({
        in: a,
        out: b,
        typeName: ZodFirstPartyTypeKind.ZodPipeline
      });
    }
  }
  types$1.ZodPipeline = ZodPipeline;
  class ZodReadonly extends ZodType {
    _parse(input) {
      const result = this._def.innerType._parse(input);
      const freeze = (data) => {
        if ((0, parseUtil_js_1.isValid)(data)) {
          data.value = Object.freeze(data.value);
        }
        return data;
      };
      return (0, parseUtil_js_1.isAsync)(result) ? result.then((data) => freeze(data)) : freeze(result);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  types$1.ZodReadonly = ZodReadonly;
  ZodReadonly.create = (type, params) => {
    return new ZodReadonly({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodReadonly,
      ...processCreateParams(params)
    });
  };
  function cleanParams(params, data) {
    const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
    const p2 = typeof p === "string" ? { message: p } : p;
    return p2;
  }
  function custom(check, _params = {}, fatal) {
    if (check)
      return ZodAny.create().superRefine((data, ctx) => {
        const r = check(data);
        if (r instanceof Promise) {
          return r.then((r2) => {
            if (!r2) {
              const params = cleanParams(_params, data);
              const _fatal = params.fatal ?? fatal ?? true;
              ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
            }
          });
        }
        if (!r) {
          const params = cleanParams(_params, data);
          const _fatal = params.fatal ?? fatal ?? true;
          ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
        }
        return;
      });
    return ZodAny.create();
  }
  types$1.late = {
    object: ZodObject.lazycreate
  };
  var ZodFirstPartyTypeKind;
  (function(ZodFirstPartyTypeKind2) {
    ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
  })(ZodFirstPartyTypeKind || (types$1.ZodFirstPartyTypeKind = ZodFirstPartyTypeKind = {}));
  const instanceOfType = (cls, params = {
    message: `Input not instance of ${cls.name}`
  }) => custom((data) => data instanceof cls, params);
  types$1.instanceof = instanceOfType;
  const stringType = ZodString.create;
  types$1.string = stringType;
  const numberType = ZodNumber.create;
  types$1.number = numberType;
  const nanType = ZodNaN.create;
  types$1.nan = nanType;
  const bigIntType = ZodBigInt.create;
  types$1.bigint = bigIntType;
  const booleanType = ZodBoolean.create;
  types$1.boolean = booleanType;
  const dateType = ZodDate.create;
  types$1.date = dateType;
  const symbolType = ZodSymbol.create;
  types$1.symbol = symbolType;
  const undefinedType = ZodUndefined.create;
  types$1.undefined = undefinedType;
  const nullType = ZodNull.create;
  types$1.null = nullType;
  const anyType = ZodAny.create;
  types$1.any = anyType;
  const unknownType = ZodUnknown.create;
  types$1.unknown = unknownType;
  const neverType = ZodNever.create;
  types$1.never = neverType;
  const voidType = ZodVoid.create;
  types$1.void = voidType;
  const arrayType = ZodArray.create;
  types$1.array = arrayType;
  const objectType = ZodObject.create;
  types$1.object = objectType;
  const strictObjectType = ZodObject.strictCreate;
  types$1.strictObject = strictObjectType;
  const unionType = ZodUnion.create;
  types$1.union = unionType;
  const discriminatedUnionType = ZodDiscriminatedUnion.create;
  types$1.discriminatedUnion = discriminatedUnionType;
  const intersectionType = ZodIntersection.create;
  types$1.intersection = intersectionType;
  const tupleType = ZodTuple.create;
  types$1.tuple = tupleType;
  const recordType = ZodRecord.create;
  types$1.record = recordType;
  const mapType = ZodMap.create;
  types$1.map = mapType;
  const setType = ZodSet.create;
  types$1.set = setType;
  const functionType = ZodFunction.create;
  types$1.function = functionType;
  const lazyType = ZodLazy.create;
  types$1.lazy = lazyType;
  const literalType = ZodLiteral.create;
  types$1.literal = literalType;
  const enumType = ZodEnum.create;
  types$1.enum = enumType;
  const nativeEnumType = ZodNativeEnum.create;
  types$1.nativeEnum = nativeEnumType;
  const promiseType = ZodPromise.create;
  types$1.promise = promiseType;
  const effectsType = ZodEffects.create;
  types$1.effect = effectsType;
  types$1.transformer = effectsType;
  const optionalType = ZodOptional.create;
  types$1.optional = optionalType;
  const nullableType = ZodNullable.create;
  types$1.nullable = nullableType;
  const preprocessType = ZodEffects.createWithPreprocess;
  types$1.preprocess = preprocessType;
  const pipelineType = ZodPipeline.create;
  types$1.pipeline = pipelineType;
  const ostring = () => stringType().optional();
  types$1.ostring = ostring;
  const onumber = () => numberType().optional();
  types$1.onumber = onumber;
  const oboolean = () => booleanType().optional();
  types$1.oboolean = oboolean;
  types$1.coerce = {
    string: ((arg) => ZodString.create({ ...arg, coerce: true })),
    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),
    boolean: ((arg) => ZodBoolean.create({
      ...arg,
      coerce: true
    })),
    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),
    date: ((arg) => ZodDate.create({ ...arg, coerce: true }))
  };
  types$1.NEVER = parseUtil_js_1.INVALID;
  return types$1;
}
var hasRequiredExternal;
function requireExternal() {
  if (hasRequiredExternal) return external;
  hasRequiredExternal = 1;
  (function(exports) {
    var __createBinding = external && external.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = external && external.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(/* @__PURE__ */ requireErrors(), exports);
    __exportStar(/* @__PURE__ */ requireParseUtil(), exports);
    __exportStar(/* @__PURE__ */ requireTypeAliases(), exports);
    __exportStar(/* @__PURE__ */ requireUtil(), exports);
    __exportStar(/* @__PURE__ */ requireTypes$1(), exports);
    __exportStar(/* @__PURE__ */ requireZodError(), exports);
  })(external);
  return external;
}
var hasRequiredZod;
function requireZod() {
  if (hasRequiredZod) return zod;
  hasRequiredZod = 1;
  (function(exports) {
    var __createBinding = zod && zod.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = zod && zod.__setModuleDefault || (Object.create ? (function(o, v2) {
      Object.defineProperty(o, "default", { enumerable: true, value: v2 });
    }) : function(o, v2) {
      o["default"] = v2;
    });
    var __importStar = zod && zod.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = zod && zod.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.z = void 0;
    const z = __importStar(/* @__PURE__ */ requireExternal());
    exports.z = z;
    __exportStar(/* @__PURE__ */ requireExternal(), exports);
    exports.default = z;
  })(zod);
  return zod;
}
var content$1 = {};
var hasRequiredContent$2;
function requireContent$2() {
  if (hasRequiredContent$2) return content$1;
  hasRequiredContent$2 = 1;
  Object.defineProperty(content$1, "__esModule", { value: true });
  content$1.bufferToStr = content$1.decodeImage = content$1.decodeSimpleFields = content$1.loadFullContent = content$1.DefaultContentResolver = void 0;
  const core_1 = requireDist$5();
  const crypto_1 = requireDist$6();
  class DefaultContentResolver {
    constructor(ipfsGateway) {
      this.ipfsGateway = ipfsGateway ?? ((id) => `https://ipfs.io/ipfs/${id}`);
    }
    async resolve(url) {
      if (url.startsWith("ipfs://")) {
        url = this.ipfsGateway(url.slice(7));
      }
      if (!(url.startsWith("https://") || url.startsWith("http://"))) {
        throw new Error("Unknown URL: " + url);
      }
      return Buffer.from(await (await fetch(url)).arrayBuffer());
    }
  }
  content$1.DefaultContentResolver = DefaultContentResolver;
  function loadSnake(s) {
    const b = [];
    while (s.remainingBits > 0 || s.remainingRefs > 0) {
      if (s.remainingBits % 8 !== 0) {
        throw new Error("Slice must contain an integer number of bytes");
      }
      b.push(s.loadBuffer(s.remainingBits / 8));
      if (s.remainingRefs === 1) {
        s = s.loadRef().beginParse();
      } else if (s.remainingRefs > 1) {
        throw new Error("Slice must contain at most 1 ref");
      }
    }
    return Buffer.concat(b);
  }
  const BufferValue = {
    serialize: () => {
      throw new Error("Buffer serialization is not supported");
    },
    parse: (src2) => {
      const r = src2.loadRef().beginParse();
      if (r.remainingBits % 8 !== 0) {
        throw new Error("Slice must contain an integer number of bytes");
      }
      if (r.remainingRefs !== 0) {
        throw new Error("Slice must not contain refs");
      }
      return r.loadBuffer(r.remainingBits / 8);
    }
  };
  function loadChunked(s) {
    const d = s.loadDict(core_1.Dictionary.Keys.Uint(32), BufferValue);
    const b = [];
    for (let i = 0; i < d.size; i++) {
      const cb = d.get(i);
      if (cb === void 0) {
        throw new Error("Dict must contain sequential keys");
      }
      b.push(cb);
    }
    return Buffer.concat(b);
  }
  const ContentDataValue = {
    serialize: () => {
      throw new Error("ContentData serialization is not supported");
    },
    parse: (src2) => {
      const r = src2.loadRef().beginParse();
      const type = r.loadUint(8);
      if (type === 0) {
        return loadSnake(r);
      } else if (type === 1) {
        return loadChunked(r);
      } else {
        throw new Error("Unknown ContentData type: " + type);
      }
    }
  };
  function bufferToObj(b) {
    const parsed = JSON.parse(b.toString("utf-8"));
    if (typeof parsed !== "object") {
      throw new Error("Data must be an object");
    }
    return parsed;
  }
  function hashKey(key2) {
    return BigInt("0x" + (0, crypto_1.sha256_sync)(key2).toString("hex"));
  }
  async function loadFullContent(data, contentResolver) {
    const ds = data.beginParse();
    const type = ds.loadUint(8);
    if (type === 0) {
      const data2 = ds.loadDict(core_1.Dictionary.Keys.BigUint(256), ContentDataValue);
      const uri = data2.get(hashKey("uri"));
      if (uri !== void 0) {
        const uriStr = uri.toString("utf-8");
        const offchain = await contentResolver.resolve(uriStr);
        return {
          type: "semichain",
          offchainFields: bufferToObj(offchain),
          onchainFields: data2,
          offchainUrl: uriStr
        };
      }
      return {
        type: "onchain",
        onchainFields: data2
      };
    } else if (type === 1) {
      const uri = ds.loadStringTail();
      const data2 = await contentResolver.resolve(uri);
      return {
        type: "offchain",
        offchainFields: bufferToObj(data2),
        offchainUrl: uri
      };
    } else {
      throw new Error("Unknown FullContent type: " + type);
    }
  }
  content$1.loadFullContent = loadFullContent;
  function decodeSimpleFields(dc, parsers) {
    const out = {};
    for (const k in parsers) {
      if (dc.onchainFields !== void 0) {
        const h = hashKey(k);
        const v2 = dc.onchainFields.get(h);
        if (v2 !== void 0) {
          out[k] = parsers[k].onchain(v2);
          dc.onchainFields.delete(h);
          continue;
        }
      }
      if (dc.offchainFields !== void 0) {
        if (k in dc.offchainFields) {
          out[k] = parsers[k].offchain(dc.offchainFields[k]);
          delete dc.offchainFields[k];
        }
      }
    }
    return out;
  }
  content$1.decodeSimpleFields = decodeSimpleFields;
  function decodeImage(dc) {
    if (dc.onchainFields !== void 0 && dc.onchainFields.has(hashKey("image")) && dc.onchainFields.has(hashKey("image_data"))) {
      throw new Error("Onchain fields contain both image and image_data");
    }
    if (dc.offchainFields !== void 0 && "image" in dc.offchainFields && "image_data" in dc.offchainFields) {
      throw new Error("Offchain fields contain both image and image_data");
    }
    if (dc.onchainFields !== void 0) {
      const image = dc.onchainFields.get(hashKey("image"));
      if (image !== void 0) {
        dc.onchainFields.delete(hashKey("image"));
        return image.toString("utf-8");
      }
      const imageData = dc.onchainFields.get(hashKey("image_data"));
      if (imageData !== void 0) {
        dc.onchainFields.delete(hashKey("image_data"));
        return imageData;
      }
    }
    if (dc.offchainFields !== void 0) {
      if ("image" in dc.offchainFields) {
        const image = dc.offchainFields.image;
        if (typeof image !== "string") {
          throw new Error("Image URI must be a string");
        }
        delete dc.offchainFields.image;
        return image;
      }
      if ("image_data" in dc.offchainFields) {
        const imageData = dc.offchainFields.image_data;
        if (typeof imageData !== "string") {
          throw new Error("Offchain image data must be a string");
        }
        delete dc.offchainFields.image_data;
        return Buffer.from(imageData, "base64");
      }
    }
    return void 0;
  }
  content$1.decodeImage = decodeImage;
  const bufferToStr = (b) => b.toString("utf-8");
  content$1.bufferToStr = bufferToStr;
  return content$1;
}
var hasRequiredContent$1;
function requireContent$1() {
  if (hasRequiredContent$1) return content$2;
  hasRequiredContent$1 = 1;
  var __importDefault = content$2 && content$2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(content$2, "__esModule", { value: true });
  content$2.parseJettonContent = content$2.jettonContentToInternal = void 0;
  const core_1 = requireDist$5();
  const zod_1 = __importDefault(/* @__PURE__ */ requireZod());
  const content_1 = requireContent$2();
  function jettonContentToInternal(content2) {
    return {
      uri: content2.uri,
      name: content2.name,
      description: content2.description,
      image: content2.image,
      image_data: content2.imageData?.toString("base64"),
      symbol: content2.symbol,
      decimals: content2.decimals?.toString(),
      amount_style: content2.amountStyle,
      render_type: content2.renderType
    };
  }
  content$2.jettonContentToInternal = jettonContentToInternal;
  function parseJettonContent(dc) {
    const decoded = (0, content_1.decodeSimpleFields)(dc, {
      name: {
        onchain: content_1.bufferToStr,
        offchain: (v2) => zod_1.default.string().parse(v2)
      },
      description: {
        onchain: content_1.bufferToStr,
        offchain: (v2) => zod_1.default.string().parse(v2)
      },
      symbol: {
        onchain: content_1.bufferToStr,
        offchain: (v2) => zod_1.default.string().parse(v2)
      },
      decimals: {
        onchain: (v2) => parseInt((0, content_1.bufferToStr)(v2)),
        offchain: (v2) => zod_1.default.union([zod_1.default.string(), zod_1.default.number()]).transform((v3) => Number(v3)).parse(v2)
      },
      amount_style: {
        onchain: (v2) => {
          const s = (0, content_1.bufferToStr)(v2);
          if (!["n", "n-of-total", "%"].includes(s)) {
            throw new Error("Unknown amount_style: " + s);
          }
          return s;
        },
        offchain: (v2) => zod_1.default.union([zod_1.default.literal("n"), zod_1.default.literal("n-of-total"), zod_1.default.literal("%")]).parse(v2)
      },
      render_type: {
        onchain: (v2) => {
          const s = (0, content_1.bufferToStr)(v2);
          if (!["currency", "game"].includes(s)) {
            throw new Error("Unknown render_type: " + s);
          }
          return s;
        },
        offchain: (v2) => zod_1.default.union([zod_1.default.literal("currency"), zod_1.default.literal("game")]).parse(v2)
      }
    });
    decoded.image = (0, content_1.decodeImage)(dc);
    const out = {
      ...decoded,
      type: dc.type,
      unknownOffchainFields: dc.offchainFields ?? {},
      unknownOnchainFields: dc.onchainFields ?? core_1.Dictionary.empty(),
      offchainUrl: dc.offchainUrl
    };
    return out;
  }
  content$2.parseJettonContent = parseJettonContent;
  return content$2;
}
var content = {};
var hasRequiredContent;
function requireContent() {
  if (hasRequiredContent) return content;
  hasRequiredContent = 1;
  var __importDefault = content && content.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(content, "__esModule", { value: true });
  content.parseNftContent = content.nftContentToInternal = void 0;
  const core_1 = requireDist$5();
  const zod_1 = __importDefault(/* @__PURE__ */ requireZod());
  const content_1 = requireContent$2();
  function nftContentToInternal(content2) {
    return {
      uri: content2.uri,
      name: content2.name,
      description: content2.description,
      image: content2.image,
      image_data: content2.imageData?.toString("base64")
    };
  }
  content.nftContentToInternal = nftContentToInternal;
  function parseNftContent(dc) {
    const decoded = (0, content_1.decodeSimpleFields)(dc, {
      name: {
        onchain: content_1.bufferToStr,
        offchain: (v2) => zod_1.default.string().parse(v2)
      },
      description: {
        onchain: content_1.bufferToStr,
        offchain: (v2) => zod_1.default.string().parse(v2)
      }
    });
    decoded.image = (0, content_1.decodeImage)(dc);
    const out = {
      ...decoded,
      type: dc.type,
      unknownOffchainFields: dc.offchainFields ?? {},
      unknownOnchainFields: dc.onchainFields ?? core_1.Dictionary.empty(),
      offchainUrl: dc.offchainUrl
    };
    return out;
  }
  content.parseNftContent = parseNftContent;
  return content;
}
var JettonWallet$1 = {};
var jettonWallet = {};
var hasRequiredJettonWallet$2;
function requireJettonWallet$2() {
  if (hasRequiredJettonWallet$2) return jettonWallet;
  hasRequiredJettonWallet$2 = 1;
  Object.defineProperty(jettonWallet, "__esModule", { value: true });
  jettonWallet.jettonWalletCode = void 0;
  jettonWallet.jettonWalletCode = {
    codeBoc: "te6ccgECEgEAAzQAART/APSkE/S88sgLAQIBYgIDAgLMBAUAG6D2BdqJofQB9IH0gahhAgHUBgcCAUgICQDDCDHAJJfBOAB0NMDAXGwlRNfA/AL4PpA+kAx+gAxcdch+gAx+gAwc6m0AALTH4IQD4p+pVIgupUxNFnwCOCCEBeNRRlSILqWMUREA/AJ4DWCEFlfB7y6k1nwCuBfBIQP8vCAAET6RDBwuvLhTYAIBIAoLAgEgEBEB8QD0z/6APpAIfAB7UTQ+gD6QPpA1DBRNqFSKscF8uLBKML/8uLCVDRCcFQgE1QUA8hQBPoCWM8WAc8WzMkiyMsBEvQA9ADLAMkg+QBwdMjLAsoHy//J0AT6QPQEMfoAINdJwgDy4sR3gBjIywVQCM8WcPoCF8trE8yAMA/c7UTQ+gD6QPpA1DAI0z/6AFFRoAX6QPpAU1vHBVRzbXBUIBNUFAPIUAT6AljPFgHPFszJIsjLARL0APQAywDJ+QBwdMjLAsoHy//J0FANxwUcsfLiwwr6AFGooYIImJaAggiYloAStgihggjk4cCgGKEn4w8l1wsBwwAjgDQ4PAK6CEBeNRRnIyx8Zyz9QB/oCIs8WUAbPFiX6AlADzxbJUAXMI5FykXHiUAioE6CCCOThwKoAggiYloCgoBS88uLFBMmAQPsAECPIUAT6AljPFgHPFszJ7VQAcFJ5oBihghBzYtCcyMsfUjDLP1j6AlAHzxZQB88WyXGAEMjLBSTPFlAG+gIVy2oUzMlx+wAQJBAjAA4QSRA4N18EAHbCALCOIYIQ1TJ223CAEMjLBVAIzxZQBPoCFstqEssfEss/yXL7AJM1bCHiA8hQBPoCWM8WAc8WzMntVADbO1E0PoA+kD6QNQwB9M/+gD6QDBRUaFSSccF8uLBJ8L/8uLCggjk4cCqABagFrzy4sOCEHvdl97Iyx8Vyz9QA/oCIs8WAc8WyXGAGMjLBSTPFnD6AstqzMmAQPsAQBPIUAT6AljPFgHPFszJ7VSAAgyAINch7UTQ+gD6QPpA1DAE0x+CEBeNRRlSILqCEHvdl94TuhKx8uLF0z8x+gAwE6BQI8hQBPoCWM8WAc8WzMntVIA=="
  };
  return jettonWallet;
}
var types = {};
var hasRequiredTypes;
function requireTypes() {
  if (hasRequiredTypes) return types;
  hasRequiredTypes = 1;
  Object.defineProperty(types, "__esModule", { value: true });
  types.parseExcessReturnOptions = types.parseNotifyOptions = void 0;
  const core_1 = requireDist$5();
  function parseNotifyOptions(options) {
    if (options === false) {
      return null;
    }
    if (typeof options === "object") {
      return {
        amount: options.amount ?? (0, core_1.toNano)("0.01"),
        payload: options.payload ?? null
      };
    }
    return {
      amount: (0, core_1.toNano)("0.01"),
      payload: null
    };
  }
  types.parseNotifyOptions = parseNotifyOptions;
  function parseExcessReturnOptions(options, sender) {
    if (options === false) {
      return null;
    }
    if (typeof options === "object") {
      return {
        address: options.address ?? sender.address
      };
    }
    return {
      address: sender.address
    };
  }
  types.parseExcessReturnOptions = parseExcessReturnOptions;
  return types;
}
var JettonTransferMessage = {};
var opcodes$1 = {};
var hasRequiredOpcodes$1;
function requireOpcodes$1() {
  if (hasRequiredOpcodes$1) return opcodes$1;
  hasRequiredOpcodes$1 = 1;
  Object.defineProperty(opcodes$1, "__esModule", { value: true });
  opcodes$1.JETTON_EXCESSES_OPCODE = opcodes$1.JETTON_BURN_NOTIFICATION_OPCODE = opcodes$1.JETTON_BURN_OPCODE = opcodes$1.JETTON_TRANSFER_NOTIFICATION_OPCODE = opcodes$1.JETTON_TRANSFER_OPCODE = opcodes$1.JETTON_CHANGE_CONTENT_OPCODE = opcodes$1.JETTON_CHANGE_ADMIN_OPCODE = opcodes$1.JETTON_INTERNAL_TRANSFER_OPCODE = opcodes$1.JETTON_MINT_OPCODE = void 0;
  opcodes$1.JETTON_MINT_OPCODE = 21;
  opcodes$1.JETTON_INTERNAL_TRANSFER_OPCODE = 395134233;
  opcodes$1.JETTON_CHANGE_ADMIN_OPCODE = 3;
  opcodes$1.JETTON_CHANGE_CONTENT_OPCODE = 4;
  opcodes$1.JETTON_TRANSFER_OPCODE = 260734629;
  opcodes$1.JETTON_TRANSFER_NOTIFICATION_OPCODE = 1935855772;
  opcodes$1.JETTON_BURN_OPCODE = 1499400124;
  opcodes$1.JETTON_BURN_NOTIFICATION_OPCODE = 2078119902;
  opcodes$1.JETTON_EXCESSES_OPCODE = 3576854235;
  return opcodes$1;
}
var hasRequiredJettonTransferMessage;
function requireJettonTransferMessage() {
  if (hasRequiredJettonTransferMessage) return JettonTransferMessage;
  hasRequiredJettonTransferMessage = 1;
  Object.defineProperty(JettonTransferMessage, "__esModule", { value: true });
  JettonTransferMessage.loadJettonTransferMessage = JettonTransferMessage.storeJettonTransferMessage = void 0;
  const opcodes_1 = requireOpcodes$1();
  function storeJettonTransferMessage(src2) {
    return (builder2) => {
      builder2.storeUint(opcodes_1.JETTON_TRANSFER_OPCODE, 32);
      builder2.storeUint(src2.queryId, 64);
      builder2.storeCoins(src2.amount);
      builder2.storeAddress(src2.destination);
      builder2.storeAddress(src2.responseDestination);
      builder2.storeMaybeRef(src2.customPayload);
      builder2.storeCoins(src2.forwardAmount ?? 0);
      builder2.storeMaybeRef(src2.forwardPayload);
    };
  }
  JettonTransferMessage.storeJettonTransferMessage = storeJettonTransferMessage;
  function loadJettonTransferMessage(slice) {
    if (slice.loadUint(32) !== opcodes_1.JETTON_TRANSFER_OPCODE) {
      throw new Error("Wrong opcode");
    }
    const queryId = slice.loadUintBig(64);
    const amount = slice.loadCoins();
    const to = slice.loadAddress();
    const responseDestination = slice.loadMaybeAddress();
    const customPayload = slice.loadMaybeRef();
    const forwardAmount = slice.loadCoins();
    const eitherPayload = slice.loadBoolean();
    const forwardPayload = eitherPayload ? slice.loadRef() : slice.asCell();
    return {
      queryId,
      amount,
      destination: to,
      responseDestination,
      customPayload,
      forwardAmount,
      forwardPayload
    };
  }
  JettonTransferMessage.loadJettonTransferMessage = loadJettonTransferMessage;
  return JettonTransferMessage;
}
var JettonBurnMessage = {};
var hasRequiredJettonBurnMessage;
function requireJettonBurnMessage() {
  if (hasRequiredJettonBurnMessage) return JettonBurnMessage;
  hasRequiredJettonBurnMessage = 1;
  Object.defineProperty(JettonBurnMessage, "__esModule", { value: true });
  JettonBurnMessage.loadJettonBurnMessage = JettonBurnMessage.storeJettonBurnMessage = void 0;
  const opcodes_1 = requireOpcodes$1();
  function storeJettonBurnMessage(src2) {
    return (builder2) => {
      builder2.storeUint(opcodes_1.JETTON_BURN_OPCODE, 32);
      builder2.storeUint(src2.queryId, 64);
      builder2.storeCoins(src2.amount);
      builder2.storeAddress(src2.responseDestination);
      builder2.storeMaybeRef(src2.customPayload);
    };
  }
  JettonBurnMessage.storeJettonBurnMessage = storeJettonBurnMessage;
  function loadJettonBurnMessage(slice) {
    if (slice.loadUint(32) !== opcodes_1.JETTON_BURN_OPCODE) {
      throw new Error("Wrong opcode");
    }
    const queryId = slice.loadUintBig(64);
    const amount = slice.loadCoins();
    const responseDestination = slice.loadMaybeAddress();
    const customPayload = slice.loadMaybeRef();
    return {
      queryId,
      amount,
      responseDestination,
      customPayload
    };
  }
  JettonBurnMessage.loadJettonBurnMessage = loadJettonBurnMessage;
  return JettonBurnMessage;
}
var JettonWalletAction = {};
var JettonWalletMessage = {};
var JettonInternalTransferMessage = {};
var hasRequiredJettonInternalTransferMessage;
function requireJettonInternalTransferMessage() {
  if (hasRequiredJettonInternalTransferMessage) return JettonInternalTransferMessage;
  hasRequiredJettonInternalTransferMessage = 1;
  Object.defineProperty(JettonInternalTransferMessage, "__esModule", { value: true });
  JettonInternalTransferMessage.loadJettonInternalTransferMessage = JettonInternalTransferMessage.storeJettonInternalTransferMessage = void 0;
  const opcodes_1 = requireOpcodes$1();
  function storeJettonInternalTransferMessage(src2) {
    return (builder2) => {
      builder2.storeUint(opcodes_1.JETTON_INTERNAL_TRANSFER_OPCODE, 32);
      builder2.storeUint(src2.queryId, 64);
      builder2.storeCoins(src2.amount);
      builder2.storeAddress(src2.from);
      builder2.storeAddress(src2.responseAddress);
      builder2.storeCoins(src2.forwardTonAmount);
      builder2.storeMaybeRef(src2.forwardPayload);
    };
  }
  JettonInternalTransferMessage.storeJettonInternalTransferMessage = storeJettonInternalTransferMessage;
  function loadJettonInternalTransferMessage(slice) {
    if (slice.loadUint(32) !== opcodes_1.JETTON_INTERNAL_TRANSFER_OPCODE) {
      throw new Error("Wrong opcode");
    }
    const queryId = slice.loadUintBig(64);
    const amount = slice.loadCoins();
    const from = slice.loadAddress();
    const responseAddress = slice.loadAddress();
    const forwardTonAmount = slice.loadCoins();
    const eitherPayload = slice.loadBoolean();
    const forwardPayload = eitherPayload ? slice.loadRef() : slice.asCell();
    return {
      queryId,
      amount,
      from,
      responseAddress,
      forwardTonAmount,
      forwardPayload
    };
  }
  JettonInternalTransferMessage.loadJettonInternalTransferMessage = loadJettonInternalTransferMessage;
  return JettonInternalTransferMessage;
}
var JettonBurnNotificationMessage = {};
var hasRequiredJettonBurnNotificationMessage;
function requireJettonBurnNotificationMessage() {
  if (hasRequiredJettonBurnNotificationMessage) return JettonBurnNotificationMessage;
  hasRequiredJettonBurnNotificationMessage = 1;
  Object.defineProperty(JettonBurnNotificationMessage, "__esModule", { value: true });
  JettonBurnNotificationMessage.loadJettonBurnNotificationMessage = JettonBurnNotificationMessage.storeJettonBurnNotificationMessage = void 0;
  const opcodes_1 = requireOpcodes$1();
  function storeJettonBurnNotificationMessage(src2) {
    return (builder2) => {
      builder2.storeUint(opcodes_1.JETTON_BURN_NOTIFICATION_OPCODE, 32);
      builder2.storeUint(src2.queryId, 64);
      builder2.storeCoins(src2.amount);
      builder2.storeAddress(src2.sender);
      builder2.storeAddress(src2.responseDestination);
    };
  }
  JettonBurnNotificationMessage.storeJettonBurnNotificationMessage = storeJettonBurnNotificationMessage;
  function loadJettonBurnNotificationMessage(slice) {
    if (slice.loadUint(32) !== opcodes_1.JETTON_BURN_NOTIFICATION_OPCODE) {
      throw new Error("Wrong opcode");
    }
    const queryId = slice.loadUintBig(64);
    const amount = slice.loadCoins();
    const sender = slice.loadAddress();
    const responseDestination = slice.loadMaybeAddress();
    return {
      queryId,
      amount,
      sender,
      responseDestination
    };
  }
  JettonBurnNotificationMessage.loadJettonBurnNotificationMessage = loadJettonBurnNotificationMessage;
  return JettonBurnNotificationMessage;
}
var JettonTransferNotificationMessage = {};
var hasRequiredJettonTransferNotificationMessage;
function requireJettonTransferNotificationMessage() {
  if (hasRequiredJettonTransferNotificationMessage) return JettonTransferNotificationMessage;
  hasRequiredJettonTransferNotificationMessage = 1;
  Object.defineProperty(JettonTransferNotificationMessage, "__esModule", { value: true });
  JettonTransferNotificationMessage.loadJettonTransferNotificationMessage = JettonTransferNotificationMessage.storeJettonTransferNotificationMessage = void 0;
  const opcodes_1 = requireOpcodes$1();
  function storeJettonTransferNotificationMessage(src2) {
    return (builder2) => {
      builder2.storeUint(opcodes_1.JETTON_TRANSFER_NOTIFICATION_OPCODE, 32);
      builder2.storeUint(src2.queryId, 64);
      builder2.storeCoins(src2.amount);
      builder2.storeAddress(src2.sender);
      builder2.storeMaybeRef(src2.forwardPayload);
    };
  }
  JettonTransferNotificationMessage.storeJettonTransferNotificationMessage = storeJettonTransferNotificationMessage;
  function loadJettonTransferNotificationMessage(slice) {
    if (slice.loadUint(32) !== opcodes_1.JETTON_TRANSFER_NOTIFICATION_OPCODE) {
      throw new Error("Wrong opcode");
    }
    const queryId = slice.loadUintBig(64);
    const amount = slice.loadCoins();
    const sender = slice.loadAddress();
    const eitherPayload = slice.loadBoolean();
    const forwardPayload = eitherPayload ? slice.loadRef() : slice.asCell();
    return {
      queryId,
      amount,
      sender,
      forwardPayload
    };
  }
  JettonTransferNotificationMessage.loadJettonTransferNotificationMessage = loadJettonTransferNotificationMessage;
  return JettonTransferNotificationMessage;
}
var hasRequiredJettonWalletMessage;
function requireJettonWalletMessage() {
  if (hasRequiredJettonWalletMessage) return JettonWalletMessage;
  hasRequiredJettonWalletMessage = 1;
  Object.defineProperty(JettonWalletMessage, "__esModule", { value: true });
  JettonWalletMessage.loadJettonWalletMessage = void 0;
  const opcodes_1 = requireOpcodes$1();
  const JettonTransferMessage_1 = requireJettonTransferMessage();
  const JettonInternalTransferMessage_1 = requireJettonInternalTransferMessage();
  const JettonBurnMessage_1 = requireJettonBurnMessage();
  const JettonBurnNotificationMessage_1 = requireJettonBurnNotificationMessage();
  const JettonTransferNotificationMessage_1 = requireJettonTransferNotificationMessage();
  function loadJettonWalletMessage(slice) {
    try {
      const opcode = slice.preloadUint(32);
      switch (opcode) {
        case opcodes_1.JETTON_TRANSFER_OPCODE:
          return { kind: "jetton_transfer", ...(0, JettonTransferMessage_1.loadJettonTransferMessage)(slice) };
        case opcodes_1.JETTON_INTERNAL_TRANSFER_OPCODE:
          return { kind: "jetton_internal_transfer", ...(0, JettonInternalTransferMessage_1.loadJettonInternalTransferMessage)(slice) };
        case opcodes_1.JETTON_TRANSFER_NOTIFICATION_OPCODE:
          return { kind: "transfer_notification", ...(0, JettonTransferNotificationMessage_1.loadJettonTransferNotificationMessage)(slice) };
        case opcodes_1.JETTON_BURN_OPCODE:
          return { kind: "jetton_burn", ...(0, JettonBurnMessage_1.loadJettonBurnMessage)(slice) };
        case opcodes_1.JETTON_BURN_NOTIFICATION_OPCODE:
          return { kind: "jetton_burn_notification", ...(0, JettonBurnNotificationMessage_1.loadJettonBurnNotificationMessage)(slice) };
        case opcodes_1.JETTON_EXCESSES_OPCODE:
          return { kind: "excesses", ...{ queryId: slice.loadUintBig(64) } };
      }
    } catch (e) {
    }
    return { kind: "unknown" };
  }
  JettonWalletMessage.loadJettonWalletMessage = loadJettonWalletMessage;
  return JettonWalletMessage;
}
var TransferAction = {};
var TransferMessage = {};
var hasRequiredTransferMessage;
function requireTransferMessage() {
  if (hasRequiredTransferMessage) return TransferMessage;
  hasRequiredTransferMessage = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadTransferMessage = exports.loadEncryptedMessage = exports.storeEncryptedMessage = exports.loadTextMessage = exports.storeTextMessage = exports.loadSimpleTransferMessage = exports.storeSimpleTransferMessage = exports.ENCRYPTED_MESSAGE_OPCODE = exports.TEXT_OPCODE = void 0;
    exports.TEXT_OPCODE = 0;
    exports.ENCRYPTED_MESSAGE_OPCODE = 560454219;
    function storeSimpleTransferMessage(value) {
      return (builder2) => {
      };
    }
    exports.storeSimpleTransferMessage = storeSimpleTransferMessage;
    function loadSimpleTransferMessage(slice) {
      return {};
    }
    exports.loadSimpleTransferMessage = loadSimpleTransferMessage;
    function storeTextMessage(value) {
      return (builder2) => {
        builder2.storeUint(0, 32);
        builder2.storeStringTail(value.text);
      };
    }
    exports.storeTextMessage = storeTextMessage;
    function loadTextMessage(slice) {
      if (slice.loadUint(32) !== 0) {
        throw new Error("Wrong opcode");
      }
      return { text: slice.loadStringTail() };
    }
    exports.loadTextMessage = loadTextMessage;
    function storeEncryptedMessage(value) {
      return (builder2) => {
        builder2.storeUint(exports.ENCRYPTED_MESSAGE_OPCODE, 32);
        builder2.storeStringTail(value.data.toString("utf-8"));
      };
    }
    exports.storeEncryptedMessage = storeEncryptedMessage;
    function loadEncryptedMessage(slice) {
      if (slice.loadUint(32) !== exports.ENCRYPTED_MESSAGE_OPCODE) {
        throw new Error("Wrong opcode");
      }
      const data = slice.loadStringTail();
      return { data: Buffer.from(data, "utf-8") };
    }
    exports.loadEncryptedMessage = loadEncryptedMessage;
    function loadTransferMessage(slice) {
      if (slice.remainingBits === 0) {
        return { kind: "simple_transfer" };
      }
      try {
        const opcode = slice.preloadUint(32);
        switch (opcode) {
          case exports.TEXT_OPCODE:
            return { kind: "text_message", ...loadTextMessage(slice) };
          case exports.ENCRYPTED_MESSAGE_OPCODE:
            return { kind: "encrypted_message", ...loadEncryptedMessage(slice) };
        }
      } catch (e) {
      }
      return { kind: "unknown" };
    }
    exports.loadTransferMessage = loadTransferMessage;
  })(TransferMessage);
  return TransferMessage;
}
var hasRequiredTransferAction;
function requireTransferAction() {
  if (hasRequiredTransferAction) return TransferAction;
  hasRequiredTransferAction = 1;
  Object.defineProperty(TransferAction, "__esModule", { value: true });
  TransferAction.parseTransferTransaction = void 0;
  const TransferMessage_1 = requireTransferMessage();
  function parseTransferTransaction(tx) {
    if (tx.description.type !== "generic") {
      return { kind: "unknown", transaction: tx };
    }
    if (!tx.inMessage) {
      return { kind: "unknown", transaction: tx };
    }
    if (tx.inMessage.info.type !== "internal") {
      return { kind: "unknown", transaction: tx };
    }
    const body = tx.inMessage.body.beginParse();
    const inMessage = (0, TransferMessage_1.loadTransferMessage)(body);
    if (inMessage.kind === "simple_transfer") {
      return {
        kind: "simple_transfer",
        from: tx.inMessage.info.src,
        to: tx.inMessage.info.dest,
        amount: tx.inMessage.info.value.coins,
        transaction: tx
      };
    }
    if (inMessage.kind === "text_message") {
      return {
        kind: "text_message",
        from: tx.inMessage.info.src,
        to: tx.inMessage.info.dest,
        amount: tx.inMessage.info.value.coins,
        text: inMessage.text,
        transaction: tx
      };
    }
    if (inMessage.kind === "encrypted_message") {
      return {
        kind: "encrypted_message",
        from: tx.inMessage.info.src,
        to: tx.inMessage.info.dest,
        amount: tx.inMessage.info.value.coins,
        data: inMessage.data,
        transaction: tx
      };
    }
    return { kind: "unknown", transaction: tx };
  }
  TransferAction.parseTransferTransaction = parseTransferTransaction;
  return TransferAction;
}
var hasRequiredJettonWalletAction;
function requireJettonWalletAction() {
  if (hasRequiredJettonWalletAction) return JettonWalletAction;
  hasRequiredJettonWalletAction = 1;
  Object.defineProperty(JettonWalletAction, "__esModule", { value: true });
  JettonWalletAction.parseJettonWalletTransaction = void 0;
  const JettonWalletMessage_1 = requireJettonWalletMessage();
  const TransferAction_1 = requireTransferAction();
  function parseJettonWalletTransaction(tx) {
    const mayBeTransfer = (0, TransferAction_1.parseTransferTransaction)(tx);
    if (mayBeTransfer.kind !== "unknown") {
      return mayBeTransfer;
    }
    if (tx.description.type !== "generic") {
      return { kind: "unknown", transaction: tx };
    }
    if (!tx.inMessage) {
      return { kind: "unknown", transaction: tx };
    }
    if (tx.inMessage.info.type !== "internal") {
      return { kind: "unknown", transaction: tx };
    }
    if (tx.description.computePhase.type !== "vm") {
      return { kind: "unknown", transaction: tx };
    }
    if (tx.description.computePhase.exitCode !== 0) {
      return { kind: "unknown", transaction: tx };
    }
    if (!tx.inMessage.body) {
      return { kind: "unknown", transaction: tx };
    }
    const isBounced = tx.inMessage.info.bounced;
    const inMessage = (0, JettonWalletMessage_1.loadJettonWalletMessage)(tx.inMessage.body.beginParse());
    if (inMessage.kind === "jetton_transfer") {
      return {
        kind: "jetton_transfer",
        queryId: inMessage.queryId,
        from: tx.inMessage.info.src,
        to: inMessage.destination,
        amount: inMessage.amount,
        responseAddress: inMessage.responseDestination,
        forwardTonAmount: inMessage.forwardAmount,
        forwardPayload: inMessage.forwardPayload,
        transaction: tx
      };
    }
    if (isBounced && inMessage.kind === "jetton_internal_transfer") {
      return {
        kind: "jetton_transfer_failed",
        queryId: inMessage.queryId,
        amount: inMessage.amount,
        transaction: tx
      };
    }
    if (inMessage.kind === "jetton_internal_transfer") {
      return {
        kind: "jetton_transfer_received",
        queryId: inMessage.queryId,
        amount: inMessage.amount,
        from: tx.inMessage.info.src,
        transaction: tx
      };
    }
    if (inMessage.kind === "jetton_burn") {
      return {
        kind: "jetton_burn",
        queryId: inMessage.queryId,
        amount: inMessage.amount,
        transaction: tx
      };
    }
    if (isBounced && inMessage.kind === "jetton_burn_notification") {
      return {
        kind: "jetton_burn_failed",
        queryId: inMessage.queryId,
        amount: inMessage.amount,
        transaction: tx
      };
    }
    return { kind: "unknown", transaction: tx };
  }
  JettonWalletAction.parseJettonWalletTransaction = parseJettonWalletTransaction;
  return JettonWalletAction;
}
var hasRequiredJettonWallet$1;
function requireJettonWallet$1() {
  if (hasRequiredJettonWallet$1) return JettonWallet$1;
  hasRequiredJettonWallet$1 = 1;
  Object.defineProperty(JettonWallet$1, "__esModule", { value: true });
  JettonWallet$1.JettonWallet = JettonWallet$1.jettonWalletConfigToCell = void 0;
  const core_1 = requireDist$5();
  const jetton_wallet_1 = requireJettonWallet$2();
  const types_1 = requireTypes();
  const JettonTransferMessage_1 = requireJettonTransferMessage();
  const JettonBurnMessage_1 = requireJettonBurnMessage();
  const JettonWalletAction_1 = requireJettonWalletAction();
  function jettonWalletConfigToCell(config) {
    return (0, core_1.beginCell)().storeCoins(config.balance).storeAddress(config.owner).storeAddress(config.jettonMaster).storeRef(config.jettonWalletCode).endCell();
  }
  JettonWallet$1.jettonWalletConfigToCell = jettonWalletConfigToCell;
  class JettonWallet2 {
    constructor(address, init) {
      this.address = address;
      this.init = init;
    }
    static createFromConfig(config, code, workchain) {
      const data = jettonWalletConfigToCell({
        balance: 0n,
        owner: config.owner,
        jettonMaster: config.jettonMaster,
        jettonWalletCode: code ?? JettonWallet2.code
      });
      const init = { data, code: code ?? JettonWallet2.code };
      return new JettonWallet2((0, core_1.contractAddress)(workchain ?? 0, init), init);
    }
    static createFromAddress(address) {
      return new JettonWallet2(address);
    }
    async sendDeploy(provider, sender, value) {
      await provider.internal(sender, {
        value: value ?? (0, core_1.toNano)("0.05"),
        bounce: true
      });
    }
    async send(provider, sender, recipient, amount, options) {
      const notification = (0, types_1.parseNotifyOptions)(options?.notify);
      const excessReturn = (0, types_1.parseExcessReturnOptions)(options?.returnExcess, sender);
      await provider.internal(sender, {
        value: (options?.value ?? (0, core_1.toNano)("0.05")) + (notification?.amount ?? 0n),
        bounce: true,
        sendMode: core_1.SendMode.PAY_GAS_SEPARATELY,
        body: (0, core_1.beginCell)().store((0, JettonTransferMessage_1.storeJettonTransferMessage)({
          queryId: options?.queryId ?? 0n,
          amount,
          destination: recipient,
          responseDestination: excessReturn?.address ?? null,
          customPayload: options?.customPayload ?? null,
          forwardAmount: notification?.amount ?? 0n,
          forwardPayload: notification?.payload ?? null
        })).endCell()
      });
    }
    async sendBurn(provider, sender, amount, options) {
      const excessReturn = (0, types_1.parseExcessReturnOptions)(options?.returnExcess, sender);
      await provider.internal(sender, {
        value: options?.value ?? (0, core_1.toNano)("0.05"),
        bounce: true,
        sendMode: core_1.SendMode.PAY_GAS_SEPARATELY,
        body: (0, core_1.beginCell)().store((0, JettonBurnMessage_1.storeJettonBurnMessage)({
          queryId: options?.queryId ?? 0n,
          amount,
          responseDestination: excessReturn?.address ?? null,
          customPayload: options?.customPayload ?? null
        })).endCell()
      });
    }
    async getData(provider) {
      const { stack } = await provider.get("get_wallet_data", []);
      return {
        balance: stack.readBigNumber(),
        owner: stack.readAddress(),
        jettonMaster: stack.readAddress(),
        jettonWalletCode: stack.readCell()
      };
    }
    async getActions(provider, options) {
      let { lt, hash, limit } = options ?? {};
      if (!lt || !hash) {
        const state = await provider.getState();
        if (!state.last) {
          return [];
        }
        lt = state.last.lt;
        hash = state.last.hash;
      }
      const transactions = await provider.getTransactions(this.address, lt, hash, limit);
      return transactions.map((tx) => (0, JettonWalletAction_1.parseJettonWalletTransaction)(tx));
    }
  }
  JettonWallet$1.JettonWallet = JettonWallet2;
  JettonWallet2.code = core_1.Cell.fromBase64(jetton_wallet_1.jettonWalletCode.codeBoc);
  return JettonWallet$1;
}
var JettonMinter = {};
var jettonMinter = {};
var hasRequiredJettonMinter$1;
function requireJettonMinter$1() {
  if (hasRequiredJettonMinter$1) return jettonMinter;
  hasRequiredJettonMinter$1 = 1;
  Object.defineProperty(jettonMinter, "__esModule", { value: true });
  jettonMinter.jettonMinterCode = void 0;
  jettonMinter.jettonMinterCode = {
    codeBoc: "te6ccgECDgEAAqMAART/APSkE/S88sgLAQIBYgIDAgLMBAUCA3pgDA0B9dkGOASS+B8ADoaYGAuNhJL4HwfSB9IBj9ABi465D9ABj9ABg51NoAAWmP6Z/2omh9AH0gamoYQAqpOF1HGZqamxsommOC+XAkgX0gfQBqGBBoQDBrkP0AGBKIGigheASKUCgZ5CgCfQEsZ4tmZmT2qnBBCD3uy+8pOF1AYAk7PwUIgG4KhAJqgoB5CgCfQEsZ4sA54tmZJFkZYCJegB6AGWAZJB8gDg6ZGWBZQPl/+ToO8AMZGWCrGeLKAJ9AQnltYlmZmS4/YBBPSO4DY3NwH6APpA+ChUEgZwVCATVBQDyFAE+gJYzxYBzxbMySLIywES9AD0AMsAyfkAcHTIywLKB8v/ydBQBscF8uBKoQNFRchQBPoCWM8WzMzJ7VQB+kAwINcLAcMAkVvjDeCCECx2uXNScLrjAjU3NyPAA+MCNQLABAcICQoAPoIQ1TJ223CAEMjLBVADzxYi+gISy2rLH8s/yYBC+wAB/jZfA4IImJaAFaAVvPLgSwL6QNMAMJXIIc8WyZFt4oIQ0XNUAHCAGMjLBVAFzxYk+gIUy2oTyx8Uyz8j+kQwcLqOM/goRANwVCATVBQDyFAE+gJYzxYBzxbMySLIywES9AD0AMsAyfkAcHTIywLKB8v/ydDPFpZsInABywHi9AALADQzUDXHBfLgSQP6QDBZyFAE+gJYzxbMzMntVABCjhhRJMcF8uBJ1DBDAMhQBPoCWM8WzMzJ7VTgXwWED/LwAArJgED7AAB9rbz2omh9AH0gamoYNhj8FAC4KhAJqgoB5CgCfQEsZ4sA54tmZJFkZYCJegB6AGWAZPyAODpkZYFlA+X/5OhAAB+vFvaiaH0AfSBqahg/qpBA"
  };
  return jettonMinter;
}
var JettonMintMessage = {};
var hasRequiredJettonMintMessage;
function requireJettonMintMessage() {
  if (hasRequiredJettonMintMessage) return JettonMintMessage;
  hasRequiredJettonMintMessage = 1;
  Object.defineProperty(JettonMintMessage, "__esModule", { value: true });
  JettonMintMessage.loadJettonMintMessage = JettonMintMessage.storeJettonMintMessage = void 0;
  const core_1 = requireDist$5();
  const opcodes_1 = requireOpcodes$1();
  const JettonInternalTransferMessage_1 = requireJettonInternalTransferMessage();
  function storeJettonMintMessage(src2) {
    return (builder2) => {
      builder2.storeUint(opcodes_1.JETTON_MINT_OPCODE, 32);
      builder2.storeUint(src2.queryId, 64);
      builder2.storeAddress(src2.to);
      builder2.storeCoins(src2.walletForwardValue);
      builder2.storeRef((0, core_1.beginCell)().store((0, JettonInternalTransferMessage_1.storeJettonInternalTransferMessage)(src2)).endCell());
    };
  }
  JettonMintMessage.storeJettonMintMessage = storeJettonMintMessage;
  function loadJettonMintMessage(slice) {
    if (slice.loadUint(32) !== opcodes_1.JETTON_MINT_OPCODE) {
      throw new Error("Wrong opcode");
    }
    const queryId = slice.loadUintBig(64);
    const to = slice.loadAddress();
    const walletForwardValue = slice.loadCoins();
    const internalTransfer = (0, JettonInternalTransferMessage_1.loadJettonInternalTransferMessage)(slice.loadRef().beginParse());
    return {
      queryId,
      amount: internalTransfer.amount,
      from: internalTransfer.from,
      to,
      responseAddress: internalTransfer.responseAddress,
      forwardTonAmount: internalTransfer.forwardTonAmount,
      forwardPayload: internalTransfer.forwardPayload,
      walletForwardValue
    };
  }
  JettonMintMessage.loadJettonMintMessage = loadJettonMintMessage;
  return JettonMintMessage;
}
var JettonMinterContent = {};
var hasRequiredJettonMinterContent;
function requireJettonMinterContent() {
  if (hasRequiredJettonMinterContent) return JettonMinterContent;
  hasRequiredJettonMinterContent = 1;
  Object.defineProperty(JettonMinterContent, "__esModule", { value: true });
  JettonMinterContent.loadJettonMinterContent = JettonMinterContent.storeJettonMinterContent = void 0;
  function storeJettonMinterContent(src2) {
    return (builder2) => {
      builder2.storeCoins(0);
      builder2.storeAddress(src2.admin);
      builder2.storeRef(src2.content);
      builder2.storeRef(src2.jettonWalletCode);
    };
  }
  JettonMinterContent.storeJettonMinterContent = storeJettonMinterContent;
  function loadJettonMinterContent(slice) {
    slice.loadCoins();
    const adminAddress = slice.loadAddress();
    const jettonContent = slice.loadRef();
    const jettonWalletCode = slice.loadRef();
    return {
      admin: adminAddress,
      content: jettonContent,
      jettonWalletCode
    };
  }
  JettonMinterContent.loadJettonMinterContent = loadJettonMinterContent;
  return JettonMinterContent;
}
var JettonChangeAdminMessage = {};
var hasRequiredJettonChangeAdminMessage;
function requireJettonChangeAdminMessage() {
  if (hasRequiredJettonChangeAdminMessage) return JettonChangeAdminMessage;
  hasRequiredJettonChangeAdminMessage = 1;
  Object.defineProperty(JettonChangeAdminMessage, "__esModule", { value: true });
  JettonChangeAdminMessage.loadJettonChangeAdminMessage = JettonChangeAdminMessage.storeJettonChangeAdminMessage = void 0;
  const opcodes_1 = requireOpcodes$1();
  function storeJettonChangeAdminMessage(src2) {
    return (builder2) => {
      builder2.storeUint(opcodes_1.JETTON_CHANGE_ADMIN_OPCODE, 32);
      builder2.storeUint(src2.queryId, 64);
      builder2.storeAddress(src2.newAdmin);
    };
  }
  JettonChangeAdminMessage.storeJettonChangeAdminMessage = storeJettonChangeAdminMessage;
  function loadJettonChangeAdminMessage(slice) {
    if (slice.loadUint(32) !== opcodes_1.JETTON_CHANGE_ADMIN_OPCODE) {
      throw new Error("Wrong opcode");
    }
    const queryId = slice.loadUintBig(64);
    const newAdmin = slice.loadAddress();
    return {
      queryId,
      newAdmin
    };
  }
  JettonChangeAdminMessage.loadJettonChangeAdminMessage = loadJettonChangeAdminMessage;
  return JettonChangeAdminMessage;
}
var JettonChangeContentMessage = {};
var hasRequiredJettonChangeContentMessage;
function requireJettonChangeContentMessage() {
  if (hasRequiredJettonChangeContentMessage) return JettonChangeContentMessage;
  hasRequiredJettonChangeContentMessage = 1;
  Object.defineProperty(JettonChangeContentMessage, "__esModule", { value: true });
  JettonChangeContentMessage.loadJettonChangeContentMessage = JettonChangeContentMessage.storeJettonChangeContentMessage = void 0;
  const opcodes_1 = requireOpcodes$1();
  function storeJettonChangeContentMessage(src2) {
    return (builder2) => {
      builder2.storeUint(opcodes_1.JETTON_CHANGE_CONTENT_OPCODE, 32);
      builder2.storeUint(src2.queryId, 64);
      builder2.storeRef(src2.newContent);
    };
  }
  JettonChangeContentMessage.storeJettonChangeContentMessage = storeJettonChangeContentMessage;
  function loadJettonChangeContentMessage(slice) {
    if (slice.loadUint(32) !== opcodes_1.JETTON_CHANGE_CONTENT_OPCODE) {
      throw new Error("Wrong opcode");
    }
    const queryId = slice.loadUintBig(64);
    const newContent = slice.loadRef();
    return {
      queryId,
      newContent
    };
  }
  JettonChangeContentMessage.loadJettonChangeContentMessage = loadJettonChangeContentMessage;
  return JettonChangeContentMessage;
}
var JettonMinterAction = {};
var JettonMinterMessage = {};
var hasRequiredJettonMinterMessage;
function requireJettonMinterMessage() {
  if (hasRequiredJettonMinterMessage) return JettonMinterMessage;
  hasRequiredJettonMinterMessage = 1;
  Object.defineProperty(JettonMinterMessage, "__esModule", { value: true });
  JettonMinterMessage.loadJettonMinterMessage = void 0;
  const JettonMintMessage_1 = requireJettonMintMessage();
  const JettonInternalTransferMessage_1 = requireJettonInternalTransferMessage();
  const JettonChangeAdminMessage_1 = requireJettonChangeAdminMessage();
  const JettonChangeContentMessage_1 = requireJettonChangeContentMessage();
  const opcodes_1 = requireOpcodes$1();
  function loadJettonMinterMessage(slice) {
    try {
      const opcode = slice.preloadUint(32);
      switch (opcode) {
        case opcodes_1.JETTON_MINT_OPCODE:
          return { kind: "mint", ...(0, JettonMintMessage_1.loadJettonMintMessage)(slice) };
        case opcodes_1.JETTON_INTERNAL_TRANSFER_OPCODE:
          return { kind: "internal_transfer", ...(0, JettonInternalTransferMessage_1.loadJettonInternalTransferMessage)(slice) };
        case opcodes_1.JETTON_CHANGE_ADMIN_OPCODE:
          return { kind: "change_admin", ...(0, JettonChangeAdminMessage_1.loadJettonChangeAdminMessage)(slice) };
        case opcodes_1.JETTON_CHANGE_CONTENT_OPCODE:
          return { kind: "change_content", ...(0, JettonChangeContentMessage_1.loadJettonChangeContentMessage)(slice) };
      }
    } catch (e) {
    }
    return { kind: "unknown" };
  }
  JettonMinterMessage.loadJettonMinterMessage = loadJettonMinterMessage;
  return JettonMinterMessage;
}
var hasRequiredJettonMinterAction;
function requireJettonMinterAction() {
  if (hasRequiredJettonMinterAction) return JettonMinterAction;
  hasRequiredJettonMinterAction = 1;
  Object.defineProperty(JettonMinterAction, "__esModule", { value: true });
  JettonMinterAction.parseJettonMinterTransaction = void 0;
  const JettonMinterMessage_1 = requireJettonMinterMessage();
  const TransferAction_1 = requireTransferAction();
  function parseJettonMinterTransaction(tx) {
    const mayBeTransfer = (0, TransferAction_1.parseTransferTransaction)(tx);
    if (mayBeTransfer.kind !== "unknown") {
      return mayBeTransfer;
    }
    if (tx.description.type !== "generic") {
      return { kind: "unknown", transaction: tx };
    }
    if (!tx.inMessage) {
      return { kind: "unknown", transaction: tx };
    }
    if (tx.inMessage.info.type !== "internal") {
      return { kind: "unknown", transaction: tx };
    }
    if (tx.description.computePhase.type !== "vm") {
      return { kind: "unknown", transaction: tx };
    }
    if (tx.description.computePhase.exitCode !== 0) {
      return { kind: "unknown", transaction: tx };
    }
    const inMessage = (0, JettonMinterMessage_1.loadJettonMinterMessage)(tx.inMessage.body.beginParse());
    if (inMessage.kind === "mint") {
      return {
        kind: "mint",
        queryId: inMessage.queryId,
        amount: inMessage.amount,
        recipient: inMessage.to,
        responseAddress: inMessage.responseAddress,
        forwardPayload: inMessage.forwardPayload,
        forwardTonAmount: inMessage.forwardTonAmount,
        value: tx.inMessage.info.value.coins,
        transaction: tx
      };
    }
    if (inMessage.kind === "internal_transfer") {
      return {
        kind: "burn",
        queryId: inMessage.queryId,
        amount: inMessage.amount,
        from: inMessage.from,
        value: tx.inMessage.info.value.coins,
        transaction: tx
      };
    }
    if (inMessage.kind === "change_admin") {
      return {
        kind: "change_admin",
        queryId: inMessage.queryId,
        newAdmin: inMessage.newAdmin,
        value: tx.inMessage.info.value.coins,
        transaction: tx
      };
    }
    if (inMessage.kind === "change_content") {
      return {
        kind: "change_content",
        queryId: inMessage.queryId,
        newContent: inMessage.newContent,
        value: tx.inMessage.info.value.coins,
        transaction: tx
      };
    }
    return { kind: "unknown", transaction: tx };
  }
  JettonMinterAction.parseJettonMinterTransaction = parseJettonMinterTransaction;
  return JettonMinterAction;
}
var hasRequiredJettonMinter;
function requireJettonMinter() {
  if (hasRequiredJettonMinter) return JettonMinter;
  hasRequiredJettonMinter = 1;
  Object.defineProperty(JettonMinter, "__esModule", { value: true });
  JettonMinter.JettonMinter = JettonMinter.jettonMinterConfigToCell = void 0;
  const core_1 = requireDist$5();
  const JettonWallet_1 = requireJettonWallet$1();
  const content_1 = requireContent$2();
  const content_2 = requireContent$1();
  const jetton_minter_1 = requireJettonMinter$1();
  const types_1 = requireTypes();
  const JettonMintMessage_1 = requireJettonMintMessage();
  const JettonMinterContent_1 = requireJettonMinterContent();
  const JettonChangeAdminMessage_1 = requireJettonChangeAdminMessage();
  const JettonChangeContentMessage_1 = requireJettonChangeContentMessage();
  const JettonMinterAction_1 = requireJettonMinterAction();
  function jettonMinterConfigToCell(config) {
    return (0, core_1.beginCell)().store((0, JettonMinterContent_1.storeJettonMinterContent)({
      admin: config.admin,
      content: config.content,
      jettonWalletCode: config.jettonWalletCode ?? JettonWallet_1.JettonWallet.code
    })).endCell();
  }
  JettonMinter.jettonMinterConfigToCell = jettonMinterConfigToCell;
  let JettonMinter$1 = class JettonMinter2 {
    constructor(address, init, contentResolver) {
      this.address = address;
      this.init = init;
      this.contentResolver = contentResolver;
    }
    static createFromAddress(address, contentResolver) {
      return new JettonMinter2(address, void 0, contentResolver);
    }
    static createFromConfig(config, code, workchain, contentResolver) {
      const data = jettonMinterConfigToCell(config);
      const init = { data, code: code ?? JettonMinter2.code };
      return new JettonMinter2((0, core_1.contractAddress)(workchain ?? 0, init), init, contentResolver);
    }
    async sendDeploy(provider, sender, value) {
      await provider.internal(sender, {
        value: value ?? (0, core_1.toNano)("0.05"),
        bounce: true
      });
    }
    async sendMint(provider, sender, recipient, amount, options) {
      const notification = (0, types_1.parseNotifyOptions)(options?.notify);
      const excessReturn = (0, types_1.parseExcessReturnOptions)(options?.returnExcess, sender);
      await provider.internal(sender, {
        value: options?.value ?? (0, core_1.toNano)("0.05"),
        bounce: true,
        body: (0, core_1.beginCell)().store((0, JettonMintMessage_1.storeJettonMintMessage)({
          queryId: options?.queryId ?? 0n,
          amount,
          from: this.address,
          to: recipient,
          responseAddress: excessReturn?.address ?? null,
          forwardPayload: notification?.payload ?? null,
          forwardTonAmount: notification?.amount ?? 0n,
          walletForwardValue: (notification?.amount ?? 0n) + (excessReturn ? (0, core_1.toNano)("0.01") : 0n) + (0, core_1.toNano)(0.02)
        })).endCell()
      });
    }
    async sendChangeAdmin(provider, sender, newAdmin, options) {
      await provider.internal(sender, {
        value: options?.value ?? (0, core_1.toNano)("0.05"),
        bounce: true,
        body: (0, core_1.beginCell)().store((0, JettonChangeAdminMessage_1.storeJettonChangeAdminMessage)({
          queryId: options?.queryId ?? 0n,
          newAdmin
        })).endCell()
      });
    }
    async sendChangeContent(provider, sender, newContent, options) {
      await provider.internal(sender, {
        value: options?.value ?? (0, core_1.toNano)("0.05"),
        bounce: true,
        body: (0, core_1.beginCell)().store((0, JettonChangeContentMessage_1.storeJettonChangeContentMessage)({
          queryId: options?.queryId ?? 0n,
          newContent
        })).endCell()
      });
    }
    async getData(provider) {
      const builder2 = new core_1.TupleBuilder();
      const { stack } = await provider.get("get_jetton_data", builder2.build());
      return {
        totalSupply: stack.readBigNumber(),
        mintable: stack.readBigNumber() !== 0n,
        adminAddress: stack.readAddressOpt(),
        jettonContent: stack.readCell(),
        jettonWalletCode: stack.readCell()
      };
    }
    async getWalletAddress(provider, owner) {
      const builder2 = new core_1.TupleBuilder();
      builder2.writeAddress(owner);
      const { stack } = await provider.get("get_wallet_address", builder2.build());
      return stack.readAddress();
    }
    async getWallet(provider, owner) {
      const jettonWalletAddress = await this.getWalletAddress(provider, owner);
      return provider.open(new JettonWallet_1.JettonWallet(jettonWalletAddress));
    }
    async getContent(provider) {
      if (!this.contentResolver) {
        throw new Error("No content resolver");
      }
      const data = await this.getData(provider);
      return (0, content_2.parseJettonContent)(await (0, content_1.loadFullContent)(data.jettonContent, this.contentResolver));
    }
    async getActions(provider, options) {
      let { lt, hash, limit } = options ?? {};
      if (!lt || !hash) {
        const state = await provider.getState();
        if (!state.last) {
          return [];
        }
        lt = state.last.lt;
        hash = state.last.hash;
      }
      const transactions = await provider.getTransactions(this.address, lt, hash, limit);
      return transactions.map((tx) => (0, JettonMinterAction_1.parseJettonMinterTransaction)(tx));
    }
  };
  JettonMinter.JettonMinter = JettonMinter$1;
  JettonMinter$1.code = core_1.Cell.fromBase64(jetton_minter_1.jettonMinterCode.codeBoc);
  return JettonMinter;
}
var NftCollection = {};
var NftCollectionBase = {};
var nftCollectionEditable = {};
var hasRequiredNftCollectionEditable;
function requireNftCollectionEditable() {
  if (hasRequiredNftCollectionEditable) return nftCollectionEditable;
  hasRequiredNftCollectionEditable = 1;
  Object.defineProperty(nftCollectionEditable, "__esModule", { value: true });
  nftCollectionEditable.nftCollectionEditableCode = void 0;
  nftCollectionEditable.nftCollectionEditableCode = {
    codeBoc: "te6ccgECFAEAAh8AART/APSkE/S88sgLAQIBYgIDAgLNBAUCASAODwTn0QY4BIrfAA6GmBgLjYSK3wfSAYAOmP6Z/2omh9IGmf6mpqGEEINJ6cqClAXUcUG6+CgOhBCFRlgFa4QAhkZYKoAueLEn0BCmW1CeWP5Z+A54tkwCB9gHAbKLnjgvlwyJLgAPGBEuABcYES4AHxgRgZgeACQGBwgJAgEgCgsAYDUC0z9TE7vy4ZJTE7oB+gDUMCgQNFnwBo4SAaRDQ8hQBc8WE8s/zMzMye1Ukl8F4gCmNXAD1DCON4BA9JZvpSCOKQakIIEA+r6T8sGP3oEBkyGgUyW78vQC+gDUMCJUSzDwBiO6kwKkAt4Ekmwh4rPmMDJQREMTyFAFzxYTyz/MzMzJ7VQALDI0AfpAMEFEyFAFzxYTyz/MzMzJ7VQAPI4V1NQwEDRBMMhQBc8WE8s/zMzMye1U4F8EhA/y8AIBIAwNAD1FrwBHAh8AV3gBjIywVYzxZQBPoCE8trEszMyXH7AIAC0AcjLP/gozxbJcCDIywET9AD0AMsAyYAAbPkAdMjLAhLKB8v/ydCACASAQEQAlvILfaiaH0gaZ/qamoYLehqGCxABDuLXTHtRND6QNM/1NTUMBAkXwTQ1DHUMNBxyMsHAc8WzMmAIBIBITAC+12v2omh9IGmf6mpqGDYg6GmH6Yf9IBhAALbT0faiaH0gaZ/qamoYCi+CeAI4APgCw"
  };
  return nftCollectionEditable;
}
var NftChangeContentMessage = {};
var NftRoyaltyParams = {};
var hasRequiredNftRoyaltyParams;
function requireNftRoyaltyParams() {
  if (hasRequiredNftRoyaltyParams) return NftRoyaltyParams;
  hasRequiredNftRoyaltyParams = 1;
  Object.defineProperty(NftRoyaltyParams, "__esModule", { value: true });
  NftRoyaltyParams.loadNftRoyaltyParams = NftRoyaltyParams.storeNftRoyaltyParams = void 0;
  function storeNftRoyaltyParams(src2) {
    return (builder2) => {
      builder2.storeUint(src2.numerator, 16);
      builder2.storeUint(src2.denominator, 16);
      builder2.storeAddress(src2.recipient);
    };
  }
  NftRoyaltyParams.storeNftRoyaltyParams = storeNftRoyaltyParams;
  function loadNftRoyaltyParams(slice) {
    return {
      numerator: slice.loadUintBig(16),
      denominator: slice.loadUintBig(16),
      recipient: slice.loadAddress()
    };
  }
  NftRoyaltyParams.loadNftRoyaltyParams = loadNftRoyaltyParams;
  return NftRoyaltyParams;
}
var opcodes = {};
var hasRequiredOpcodes;
function requireOpcodes() {
  if (hasRequiredOpcodes) return opcodes;
  hasRequiredOpcodes = 1;
  Object.defineProperty(opcodes, "__esModule", { value: true });
  opcodes.NFT_EXCESSES_OPCODE = opcodes.NFT_REPORT_STATIC_DATA_OPCODE = opcodes.NFT_GET_STATIC_DATA_OPCODE = opcodes.NFT_OWNER_ASSIGNED_OPCODE = opcodes.NFT_TRANSFER_OPCODE = opcodes.NFT_CHANGE_CONTENT_OPCODE = opcodes.NFT_CHANGE_ADMIN_OPCODE = opcodes.NFT_BATCH_MINT_OPCODE = opcodes.NFT_MINT_OPCODE = void 0;
  opcodes.NFT_MINT_OPCODE = 1;
  opcodes.NFT_BATCH_MINT_OPCODE = 2;
  opcodes.NFT_CHANGE_ADMIN_OPCODE = 3;
  opcodes.NFT_CHANGE_CONTENT_OPCODE = 4;
  opcodes.NFT_TRANSFER_OPCODE = 1607220500;
  opcodes.NFT_OWNER_ASSIGNED_OPCODE = 85167505;
  opcodes.NFT_GET_STATIC_DATA_OPCODE = 801842850;
  opcodes.NFT_REPORT_STATIC_DATA_OPCODE = 2339837749;
  opcodes.NFT_EXCESSES_OPCODE = 3576854235;
  return opcodes;
}
var hasRequiredNftChangeContentMessage;
function requireNftChangeContentMessage() {
  if (hasRequiredNftChangeContentMessage) return NftChangeContentMessage;
  hasRequiredNftChangeContentMessage = 1;
  Object.defineProperty(NftChangeContentMessage, "__esModule", { value: true });
  NftChangeContentMessage.loadNftChangeContentMessage = NftChangeContentMessage.storeNftChangeContentMessage = void 0;
  const NftRoyaltyParams_1 = requireNftRoyaltyParams();
  const opcodes_1 = requireOpcodes();
  function storeNftChangeContentMessage(src2) {
    return (builder2) => {
      builder2.storeUint(opcodes_1.NFT_CHANGE_CONTENT_OPCODE, 32);
      builder2.storeUint(src2.queryId, 64);
      builder2.storeRef(src2.newContent);
      builder2.store((0, NftRoyaltyParams_1.storeNftRoyaltyParams)(src2.newRoyaltyParams));
    };
  }
  NftChangeContentMessage.storeNftChangeContentMessage = storeNftChangeContentMessage;
  function loadNftChangeContentMessage(slice) {
    if (slice.loadUint(32) !== opcodes_1.NFT_CHANGE_CONTENT_OPCODE) {
      throw new Error("Wrong opcode");
    }
    const queryId = slice.loadUintBig(64);
    const newContent = slice.loadRef();
    const newRoyaltyParams = (0, NftRoyaltyParams_1.loadNftRoyaltyParams)(slice.loadRef().beginParse());
    return {
      queryId,
      newContent,
      newRoyaltyParams
    };
  }
  NftChangeContentMessage.loadNftChangeContentMessage = loadNftChangeContentMessage;
  return NftChangeContentMessage;
}
var NftMintMessage = {};
var hasRequiredNftMintMessage;
function requireNftMintMessage() {
  if (hasRequiredNftMintMessage) return NftMintMessage;
  hasRequiredNftMintMessage = 1;
  Object.defineProperty(NftMintMessage, "__esModule", { value: true });
  NftMintMessage.loadNftMintMessage = NftMintMessage.storeNftMintMessage = void 0;
  const core_1 = requireDist$5();
  const opcodes_1 = requireOpcodes();
  function storeNftMintMessage(src2, storeParams) {
    return (builder2) => {
      builder2.storeUint(opcodes_1.NFT_MINT_OPCODE, 32);
      builder2.storeUint(src2.queryId, 64);
      builder2.storeUint(src2.itemIndex, 64);
      builder2.storeCoins(src2.value);
      builder2.storeRef((0, core_1.beginCell)().store(storeParams(src2.itemParams)).endCell());
    };
  }
  NftMintMessage.storeNftMintMessage = storeNftMintMessage;
  function loadNftMintMessage(slice, loadParams) {
    if (slice.loadUint(32) !== opcodes_1.NFT_MINT_OPCODE) {
      throw new Error("Wrong opcode");
    }
    const queryId = slice.loadUintBig(64);
    const itemIndex = slice.loadUintBig(64);
    const value = slice.loadCoins();
    const itemParams = slice.loadRef();
    return {
      itemIndex,
      value,
      itemParams: loadParams(itemParams.beginParse()),
      queryId
    };
  }
  NftMintMessage.loadNftMintMessage = loadNftMintMessage;
  return NftMintMessage;
}
var NftBatchMintMessage = {};
var hasRequiredNftBatchMintMessage;
function requireNftBatchMintMessage() {
  if (hasRequiredNftBatchMintMessage) return NftBatchMintMessage;
  hasRequiredNftBatchMintMessage = 1;
  Object.defineProperty(NftBatchMintMessage, "__esModule", { value: true });
  NftBatchMintMessage.createNftMintItemValue = NftBatchMintMessage.loadNftBatchMintItem = NftBatchMintMessage.storeNftBatchMintItem = NftBatchMintMessage.loadNftBatchMintMessage = NftBatchMintMessage.storeNftBatchMintMessage = void 0;
  const core_1 = requireDist$5();
  const opcodes_1 = requireOpcodes();
  function storeNftBatchMintMessage(src2, storeParams) {
    return (builder2) => {
      const dict = core_1.Dictionary.empty(core_1.Dictionary.Keys.BigUint(64), createNftMintItemValue(storeParams));
      for (const r of src2.requests) {
        if (dict.has(r.index)) {
          throw new Error("Duplicate items");
        }
        dict.set(r.index, r);
      }
      builder2.storeUint(opcodes_1.NFT_BATCH_MINT_OPCODE, 32);
      builder2.storeUint(src2.queryId ?? 0, 64);
      builder2.storeRef((0, core_1.beginCell)().storeDictDirect(dict));
    };
  }
  NftBatchMintMessage.storeNftBatchMintMessage = storeNftBatchMintMessage;
  function loadNftBatchMintMessage(slice, loadParams) {
    if (slice.loadUint(32) !== opcodes_1.NFT_BATCH_MINT_OPCODE) {
      throw new Error("Wrong opcode");
    }
    const queryId = slice.loadUintBig(64);
    const requests = slice.loadDictDirect(core_1.Dictionary.Keys.BigUint(64), createNftMintItemValue(void 0, loadParams));
    return {
      queryId,
      requests: requests.values()
    };
  }
  NftBatchMintMessage.loadNftBatchMintMessage = loadNftBatchMintMessage;
  function storeNftBatchMintItem(request, storeParams) {
    return (builder2) => {
      builder2.storeCoins(request.value ?? (0, core_1.toNano)("0.03"));
      builder2.storeRef((0, core_1.beginCell)().store(storeParams(request.params)).endCell());
    };
  }
  NftBatchMintMessage.storeNftBatchMintItem = storeNftBatchMintItem;
  function loadNftBatchMintItem(slice, loadParams) {
    const itemIndex = slice.loadUintBig(64);
    const value = slice.loadCoins();
    const params = slice.loadRef();
    return {
      index: itemIndex,
      value,
      params: loadParams(params.beginParse())
    };
  }
  NftBatchMintMessage.loadNftBatchMintItem = loadNftBatchMintItem;
  function createNftMintItemValue(storeParams, loadParams) {
    return {
      serialize(src2, builder2) {
        if (!storeParams) {
          throw new Error("storeParams is not defined");
        }
        builder2.store(storeNftBatchMintItem(src2, storeParams));
      },
      parse(src2) {
        if (!loadParams) {
          throw new Error("loadParams is not defined");
        }
        return loadNftBatchMintItem(src2, loadParams);
      }
    };
  }
  NftBatchMintMessage.createNftMintItemValue = createNftMintItemValue;
  return NftBatchMintMessage;
}
var NftChangeAdminMessage = {};
var hasRequiredNftChangeAdminMessage;
function requireNftChangeAdminMessage() {
  if (hasRequiredNftChangeAdminMessage) return NftChangeAdminMessage;
  hasRequiredNftChangeAdminMessage = 1;
  Object.defineProperty(NftChangeAdminMessage, "__esModule", { value: true });
  NftChangeAdminMessage.loadNftChangeAdminMessage = NftChangeAdminMessage.storeNftChangeAdminMessage = void 0;
  const opcodes_1 = requireOpcodes();
  function storeNftChangeAdminMessage(src2) {
    return (builder2) => {
      builder2.storeUint(opcodes_1.NFT_CHANGE_ADMIN_OPCODE, 32);
      builder2.storeUint(src2.queryId ?? 0, 64);
      builder2.storeAddress(src2.newAdmin);
    };
  }
  NftChangeAdminMessage.storeNftChangeAdminMessage = storeNftChangeAdminMessage;
  function loadNftChangeAdminMessage(slice) {
    if (slice.loadUint(32) !== opcodes_1.NFT_CHANGE_ADMIN_OPCODE) {
      throw new Error("Wrong opcode");
    }
    const queryId = slice.loadUintBig(64);
    const newAdmin = slice.loadAddress();
    return {
      queryId,
      newAdmin
    };
  }
  NftChangeAdminMessage.loadNftChangeAdminMessage = loadNftChangeAdminMessage;
  return NftChangeAdminMessage;
}
var hasRequiredNftCollectionBase;
function requireNftCollectionBase() {
  if (hasRequiredNftCollectionBase) return NftCollectionBase;
  hasRequiredNftCollectionBase = 1;
  Object.defineProperty(NftCollectionBase, "__esModule", { value: true });
  NftCollectionBase.NftCollectionBase = void 0;
  const core_1 = requireDist$5();
  const content_1 = requireContent$2();
  const content_2 = requireContent();
  const nft_collection_editable_1 = requireNftCollectionEditable();
  const NftChangeContentMessage_1 = requireNftChangeContentMessage();
  const NftMintMessage_1 = requireNftMintMessage();
  const NftBatchMintMessage_1 = requireNftBatchMintMessage();
  const NftChangeAdminMessage_1 = requireNftChangeAdminMessage();
  let NftCollectionBase$1 = class NftCollectionBase {
    constructor(address, init, contentResolver, nftItemParamsValue) {
      this.address = address;
      this.init = init;
      this.contentResolver = contentResolver;
      this.itemParamsValue = nftItemParamsValue;
    }
    async sendDeploy(provider, sender, value) {
      await provider.internal(sender, {
        value: value ?? (0, core_1.toNano)("0.05"),
        bounce: true
      });
    }
    async sendMint(provider, sender, item, options) {
      if (this.itemParamsValue === void 0) {
        throw new Error("No item params value");
      }
      await provider.internal(sender, {
        value: options?.value ?? (0, core_1.toNano)("0.05"),
        bounce: true,
        sendMode: core_1.SendMode.PAY_GAS_SEPARATELY,
        body: (0, core_1.beginCell)().store((0, NftMintMessage_1.storeNftMintMessage)({
          queryId: options?.queryId ?? 0n,
          itemIndex: item.index,
          itemParams: item,
          value: item.value ?? (0, core_1.toNano)("0.03")
        }, this.itemParamsValue.store)).endCell()
      });
    }
    async sendBatchMint(provider, sender, items, options) {
      if (this.itemParamsValue === void 0) {
        throw new Error("No item params value");
      }
      await provider.internal(sender, {
        value: options?.value ?? (0, core_1.toNano)("0.05") * BigInt(items.length),
        bounce: true,
        body: (0, core_1.beginCell)().store((0, NftBatchMintMessage_1.storeNftBatchMintMessage)({
          queryId: options?.queryId ?? 0n,
          requests: items.map((item) => ({
            index: item.index,
            params: item,
            value: item.value ?? (0, core_1.toNano)("0.03")
          }))
        }, this.itemParamsValue.store)).endCell()
      });
    }
    async sendChangeAdmin(provider, sender, newAdmin, options) {
      await provider.internal(sender, {
        value: options?.value ?? (0, core_1.toNano)("0.05"),
        bounce: true,
        body: (0, core_1.beginCell)().store((0, NftChangeAdminMessage_1.storeNftChangeAdminMessage)({
          newAdmin,
          queryId: options?.queryId ?? 0n
        })).endCell()
      });
    }
    async sendChangeContent(provider, sender, message, options) {
      await provider.internal(sender, {
        value: options?.value ?? (0, core_1.toNano)("0.05"),
        bounce: true,
        body: (0, core_1.beginCell)().store((0, NftChangeContentMessage_1.storeNftChangeContentMessage)({
          queryId: options?.queryId ?? 0n,
          newContent: message.newContent,
          newRoyaltyParams: message.newRoyaltyParams
        })).endCell()
      });
    }
    async getItemAddress(provider, index) {
      const ret = await provider.get("get_nft_address_by_index", [{ type: "int", value: index }]);
      return ret.stack.readAddress();
    }
    async getData(provider) {
      const ret = await provider.get("get_collection_data", []);
      return {
        nextItemIndex: ret.stack.readBigNumber(),
        content: ret.stack.readCell(),
        owner: ret.stack.readAddressOpt()
      };
    }
    async getContent(provider) {
      if (this.contentResolver === void 0) {
        throw new Error("No content resolver");
      }
      const data = await this.getData(provider);
      return (0, content_2.parseNftContent)(await (0, content_1.loadFullContent)(data.content, this.contentResolver));
    }
    async getItemContent(provider, index, individualContent) {
      const res = await provider.get("get_nft_content", [{
        type: "int",
        value: index
      }, {
        type: "cell",
        cell: individualContent
      }]);
      return res.stack.readCell();
    }
  };
  NftCollectionBase.NftCollectionBase = NftCollectionBase$1;
  NftCollectionBase$1.code = core_1.Cell.fromBase64(nft_collection_editable_1.nftCollectionEditableCode.codeBoc);
  return NftCollectionBase;
}
var NftItem = {};
var nftItem = {};
var hasRequiredNftItem$1;
function requireNftItem$1() {
  if (hasRequiredNftItem$1) return nftItem;
  hasRequiredNftItem$1 = 1;
  Object.defineProperty(nftItem, "__esModule", { value: true });
  nftItem.nftItemCode = void 0;
  nftItem.nftItemCode = {
    codeBoc: "te6ccgECDgEAAdwAART/APSkE/S88sgLAQIBYgIDAgLOBAUACaEfn+AFAgEgBgcCASAMDQLPDIhxwCSXwPg0NMDAXGwkl8D4PpA+kAx+gAxcdch+gAx+gAwc6m0APACBLOOFDBsIjRSMscF8uGVAfpA1DAQI/AD4AbTH9M/ghBfzD0UUjC64wIwNDQ1NYIQL8smohK64wJfBIQP8vCAICQARPpEMHC68uFNgAqwyEDdeMkATUTXHBfLhkfpAIfAB+kDSADH6ACDXScIA8uLEggr68IAboSGUUxWgod4i1wsBwwAgkgahkTbiIML/8uGSIZQQKjdb4w0CkzAyNOMNVQLwAwoLAHJwghCLdxc1BcjL/1AEzxYQJIBAcIAQyMsFUAfPFlAF+gIVy2oSyx/LPyJus5RYzxcBkTLiAckB+wAAfIIQBRONkchQCc8WUAvPFnEkSRRURqBwgBDIywVQB88WUAX6AhXLahLLH8s/Im6zlFjPFwGRMuIByQH7ABBHAGom8AGCENUydtsQN0QAbXFwgBDIywVQB88WUAX6AhXLahLLH8s/Im6zlFjPFwGRMuIByQH7AAA7O1E0NM/+kAg10nCAJp/AfpA1DAQJBAj4DBwWW1tgAB0A8jLP1jPFgHPFszJ7VSA="
  };
  return nftItem;
}
var NftItemParams = {};
var hasRequiredNftItemParams;
function requireNftItemParams() {
  if (hasRequiredNftItemParams) return NftItemParams;
  hasRequiredNftItemParams = 1;
  Object.defineProperty(NftItemParams, "__esModule", { value: true });
  NftItemParams.createNftItemParamsValue = NftItemParams.loadNftItemParams = NftItemParams.storeNftItemParams = void 0;
  const core_1 = requireDist$5();
  function storeNftItemParams(src2) {
    return (builder2) => {
      builder2.storeAddress(src2.owner);
      if (typeof src2.individualContent === "string") {
        builder2.storeRef((0, core_1.beginCell)().storeStringTail(src2.individualContent).endCell());
      } else {
        builder2.storeRef(src2.individualContent);
      }
    };
  }
  NftItemParams.storeNftItemParams = storeNftItemParams;
  function loadNftItemParams(slice) {
    return {
      owner: slice.loadAddress(),
      individualContent: slice.loadRef()
    };
  }
  NftItemParams.loadNftItemParams = loadNftItemParams;
  function createNftItemParamsValue() {
    return {
      store: storeNftItemParams,
      load: loadNftItemParams
    };
  }
  NftItemParams.createNftItemParamsValue = createNftItemParamsValue;
  return NftItemParams;
}
var NftTransferMessage = {};
var hasRequiredNftTransferMessage;
function requireNftTransferMessage() {
  if (hasRequiredNftTransferMessage) return NftTransferMessage;
  hasRequiredNftTransferMessage = 1;
  Object.defineProperty(NftTransferMessage, "__esModule", { value: true });
  NftTransferMessage.loadNftTransferMessage = NftTransferMessage.storeNftTransferMessage = void 0;
  const opcodes_1 = requireOpcodes();
  function storeNftTransferMessage(message) {
    return (builder2) => {
      const { queryId, newOwner, responseDestination, customPayload, forwardAmount, forwardPayload } = message;
      builder2.storeUint(opcodes_1.NFT_TRANSFER_OPCODE, 32).storeUint(queryId, 64).storeAddress(newOwner).storeAddress(responseDestination).storeMaybeRef(customPayload).storeCoins(forwardAmount).storeMaybeRef(forwardPayload);
    };
  }
  NftTransferMessage.storeNftTransferMessage = storeNftTransferMessage;
  function loadNftTransferMessage(slice) {
    if (slice.loadUint(32) !== opcodes_1.NFT_TRANSFER_OPCODE) {
      throw new Error("Wrong opcode");
    }
    const queryId = slice.loadUintBig(64);
    const newOwner = slice.loadAddress();
    const responseDestination = slice.loadMaybeAddress();
    const customPayload = slice.loadMaybeRef();
    const forwardAmount = slice.loadCoins();
    const eitherPayload = slice.loadBoolean();
    const forwardPayload = eitherPayload ? slice.loadRef() : slice.asCell();
    return {
      queryId,
      newOwner,
      responseDestination,
      customPayload,
      forwardAmount,
      forwardPayload
    };
  }
  NftTransferMessage.loadNftTransferMessage = loadNftTransferMessage;
  return NftTransferMessage;
}
var NftItemAction = {};
var NftMessage = {};
var NftDeployMessage = {};
var hasRequiredNftDeployMessage;
function requireNftDeployMessage() {
  if (hasRequiredNftDeployMessage) return NftDeployMessage;
  hasRequiredNftDeployMessage = 1;
  Object.defineProperty(NftDeployMessage, "__esModule", { value: true });
  NftDeployMessage.loadNftDeployMessage = NftDeployMessage.storeNftDeployMessage = void 0;
  function storeNftDeployMessage(message) {
    return (builder2) => {
      const { owner, content: content2 } = message;
      builder2.storeAddress(owner).storeRef(content2);
    };
  }
  NftDeployMessage.storeNftDeployMessage = storeNftDeployMessage;
  function loadNftDeployMessage(slice) {
    const owner = slice.loadAddress();
    const content2 = slice.loadRef();
    return {
      owner,
      content: content2
    };
  }
  NftDeployMessage.loadNftDeployMessage = loadNftDeployMessage;
  return NftDeployMessage;
}
var NftGetStaticDataMessage = {};
var hasRequiredNftGetStaticDataMessage;
function requireNftGetStaticDataMessage() {
  if (hasRequiredNftGetStaticDataMessage) return NftGetStaticDataMessage;
  hasRequiredNftGetStaticDataMessage = 1;
  Object.defineProperty(NftGetStaticDataMessage, "__esModule", { value: true });
  NftGetStaticDataMessage.loadNftGetStaticDataMessage = NftGetStaticDataMessage.storeNftGetStaticDataMessage = void 0;
  const opcodes_1 = requireOpcodes();
  function storeNftGetStaticDataMessage(message) {
    return (builder2) => {
      const { queryId } = message;
      builder2.storeUint(opcodes_1.NFT_GET_STATIC_DATA_OPCODE, 32).storeUint(queryId, 64);
    };
  }
  NftGetStaticDataMessage.storeNftGetStaticDataMessage = storeNftGetStaticDataMessage;
  function loadNftGetStaticDataMessage(slice) {
    if (slice.loadUint(32) !== opcodes_1.NFT_GET_STATIC_DATA_OPCODE) {
      throw new Error("Wrong opcode");
    }
    const queryId = slice.loadUintBig(64);
    return {
      queryId
    };
  }
  NftGetStaticDataMessage.loadNftGetStaticDataMessage = loadNftGetStaticDataMessage;
  return NftGetStaticDataMessage;
}
var NftReportStaticDataMessage = {};
var hasRequiredNftReportStaticDataMessage;
function requireNftReportStaticDataMessage() {
  if (hasRequiredNftReportStaticDataMessage) return NftReportStaticDataMessage;
  hasRequiredNftReportStaticDataMessage = 1;
  Object.defineProperty(NftReportStaticDataMessage, "__esModule", { value: true });
  NftReportStaticDataMessage.loadNftReportStaticDataMessage = NftReportStaticDataMessage.storeNftReportStaticDataMessage = void 0;
  const opcodes_1 = requireOpcodes();
  function storeNftReportStaticDataMessage(message) {
    return (builder2) => {
      const { queryId, index, collection } = message;
      builder2.storeUint(opcodes_1.NFT_REPORT_STATIC_DATA_OPCODE, 32).storeUint(queryId, 64).storeUint(index, 256).storeAddress(collection);
    };
  }
  NftReportStaticDataMessage.storeNftReportStaticDataMessage = storeNftReportStaticDataMessage;
  function loadNftReportStaticDataMessage(slice) {
    if (slice.loadUint(32) !== opcodes_1.NFT_REPORT_STATIC_DATA_OPCODE) {
      throw new Error("Wrong opcode");
    }
    const queryId = slice.loadUintBig(64);
    const index = slice.loadUintBig(256);
    const collection = slice.loadAddress();
    return {
      queryId,
      index,
      collection
    };
  }
  NftReportStaticDataMessage.loadNftReportStaticDataMessage = loadNftReportStaticDataMessage;
  return NftReportStaticDataMessage;
}
var NftOwnerAssignedMessage = {};
var hasRequiredNftOwnerAssignedMessage;
function requireNftOwnerAssignedMessage() {
  if (hasRequiredNftOwnerAssignedMessage) return NftOwnerAssignedMessage;
  hasRequiredNftOwnerAssignedMessage = 1;
  Object.defineProperty(NftOwnerAssignedMessage, "__esModule", { value: true });
  NftOwnerAssignedMessage.loadNftOwnerAssignedMessage = NftOwnerAssignedMessage.storeNftOwnerAssignedMessage = void 0;
  const opcodes_1 = requireOpcodes();
  function storeNftOwnerAssignedMessage(message) {
    return (builder2) => {
      const { queryId, previousOwner, payload } = message;
      builder2.storeUint(opcodes_1.NFT_OWNER_ASSIGNED_OPCODE, 32).storeUint(queryId, 64).storeAddress(previousOwner).storeMaybeRef(payload);
    };
  }
  NftOwnerAssignedMessage.storeNftOwnerAssignedMessage = storeNftOwnerAssignedMessage;
  function loadNftOwnerAssignedMessage(slice) {
    if (slice.loadUint(32) !== opcodes_1.NFT_OWNER_ASSIGNED_OPCODE) {
      throw new Error("Wrong opcode");
    }
    const queryId = slice.loadUintBig(64);
    const previousOwner = slice.loadAddress();
    const eitherPayload = slice.loadBoolean();
    const payload = eitherPayload ? slice.loadRef() : slice.asCell();
    return {
      queryId,
      previousOwner,
      payload
    };
  }
  NftOwnerAssignedMessage.loadNftOwnerAssignedMessage = loadNftOwnerAssignedMessage;
  return NftOwnerAssignedMessage;
}
var NftExcessesMessage = {};
var hasRequiredNftExcessesMessage;
function requireNftExcessesMessage() {
  if (hasRequiredNftExcessesMessage) return NftExcessesMessage;
  hasRequiredNftExcessesMessage = 1;
  Object.defineProperty(NftExcessesMessage, "__esModule", { value: true });
  NftExcessesMessage.loadNftExcessesMessage = NftExcessesMessage.storeNftExcessesMessage = void 0;
  const opcodes_1 = requireOpcodes();
  function storeNftExcessesMessage(message) {
    return (builder2) => {
      const { queryId } = message;
      builder2.storeUint(opcodes_1.NFT_EXCESSES_OPCODE, 32).storeUint(queryId, 64);
    };
  }
  NftExcessesMessage.storeNftExcessesMessage = storeNftExcessesMessage;
  function loadNftExcessesMessage(slice) {
    if (slice.loadUint(32) !== opcodes_1.NFT_EXCESSES_OPCODE) {
      throw new Error("Wrong opcode");
    }
    const queryId = slice.loadUintBig(64);
    return {
      queryId
    };
  }
  NftExcessesMessage.loadNftExcessesMessage = loadNftExcessesMessage;
  return NftExcessesMessage;
}
var hasRequiredNftMessage;
function requireNftMessage() {
  if (hasRequiredNftMessage) return NftMessage;
  hasRequiredNftMessage = 1;
  Object.defineProperty(NftMessage, "__esModule", { value: true });
  NftMessage.loadNftMessage = void 0;
  const NftDeployMessage_1 = requireNftDeployMessage();
  const NftTransferMessage_1 = requireNftTransferMessage();
  const NftGetStaticDataMessage_1 = requireNftGetStaticDataMessage();
  const NftReportStaticDataMessage_1 = requireNftReportStaticDataMessage();
  const NftOwnerAssignedMessage_1 = requireNftOwnerAssignedMessage();
  const opcodes_1 = requireOpcodes();
  const NftExcessesMessage_1 = requireNftExcessesMessage();
  function loadNftMessage(slice) {
    try {
      const opcode = slice.preloadUint(32);
      switch (opcode) {
        case opcodes_1.NFT_TRANSFER_OPCODE:
          return { kind: "nft_transfer", ...(0, NftTransferMessage_1.loadNftTransferMessage)(slice) };
        case opcodes_1.NFT_OWNER_ASSIGNED_OPCODE:
          return { kind: "owner_assigned", ...(0, NftOwnerAssignedMessage_1.loadNftOwnerAssignedMessage)(slice) };
        case opcodes_1.NFT_REPORT_STATIC_DATA_OPCODE:
          return { kind: "report_static_data", ...(0, NftReportStaticDataMessage_1.loadNftReportStaticDataMessage)(slice) };
        case opcodes_1.NFT_GET_STATIC_DATA_OPCODE:
          return { kind: "get_static_data", ...(0, NftGetStaticDataMessage_1.loadNftGetStaticDataMessage)(slice) };
        case opcodes_1.NFT_EXCESSES_OPCODE:
          return { kind: "excesses", ...(0, NftExcessesMessage_1.loadNftExcessesMessage)(slice) };
      }
      if (slice.remainingBits === 256 + 11 && slice.remainingRefs === 1) {
        return { kind: "nft_deploy", ...(0, NftDeployMessage_1.loadNftDeployMessage)(slice) };
      }
    } catch (e) {
    }
    return { kind: "unknown" };
  }
  NftMessage.loadNftMessage = loadNftMessage;
  return NftMessage;
}
var hasRequiredNftItemAction;
function requireNftItemAction() {
  if (hasRequiredNftItemAction) return NftItemAction;
  hasRequiredNftItemAction = 1;
  Object.defineProperty(NftItemAction, "__esModule", { value: true });
  NftItemAction.parseNftItemTransaction = void 0;
  const NftMessage_1 = requireNftMessage();
  const TransferAction_1 = requireTransferAction();
  function parseNftItemTransaction(tx) {
    const mayBeTransfer = (0, TransferAction_1.parseTransferTransaction)(tx);
    if (mayBeTransfer.kind !== "unknown") {
      return mayBeTransfer;
    }
    if (tx.description.type !== "generic") {
      return { kind: "unknown", transaction: tx };
    }
    if (!tx.inMessage) {
      return { kind: "unknown", transaction: tx };
    }
    if (tx.inMessage.info.type !== "internal") {
      return { kind: "unknown", transaction: tx };
    }
    if (tx.description.computePhase.type !== "vm") {
      return { kind: "unknown", transaction: tx };
    }
    if (tx.description.computePhase.exitCode !== 0) {
      return { kind: "unknown", transaction: tx };
    }
    const inMessage = (0, NftMessage_1.loadNftMessage)(tx.inMessage.body.beginParse());
    if (inMessage.kind === "nft_deploy") {
      return {
        kind: "deploy",
        owner: inMessage.owner,
        content: inMessage.content,
        collection: tx.inMessage.info.src,
        transaction: tx
      };
    }
    if (inMessage.kind === "nft_transfer") {
      return {
        kind: "nft_transfer",
        queryId: inMessage.queryId,
        newOwner: inMessage.newOwner,
        customPayload: inMessage.customPayload ?? null,
        forwardAmount: inMessage.forwardAmount,
        forwardPayload: inMessage.forwardPayload ?? null,
        transaction: tx
      };
    }
    return { kind: "unknown", transaction: tx };
  }
  NftItemAction.parseNftItemTransaction = parseNftItemTransaction;
  return NftItemAction;
}
var hasRequiredNftItem;
function requireNftItem() {
  if (hasRequiredNftItem) return NftItem;
  hasRequiredNftItem = 1;
  Object.defineProperty(NftItem, "__esModule", { value: true });
  NftItem.NftItem = NftItem.nftItemConfigToCell = void 0;
  const core_1 = requireDist$5();
  const content_1 = requireContent$2();
  const NftCollection_1 = requireNftCollection();
  const content_2 = requireContent();
  const nft_item_1 = requireNftItem$1();
  const types_1 = requireTypes();
  const NftItemParams_1 = requireNftItemParams();
  const NftTransferMessage_1 = requireNftTransferMessage();
  const NftItemAction_1 = requireNftItemAction();
  function nftItemConfigToCell(config) {
    return (0, core_1.beginCell)().storeUint(config.index, 64).storeAddress(config.collection).endCell();
  }
  NftItem.nftItemConfigToCell = nftItemConfigToCell;
  let NftItem$1 = class NftItem2 {
    constructor(address, init, contentResolver) {
      this.address = address;
      this.init = init;
      this.contentResolver = contentResolver;
    }
    static createFromConfig(config, code, workchain, contentResolver) {
      const data = nftItemConfigToCell(config);
      const init = { data, code: code ?? NftItem2.nftCode };
      return new NftItem2((0, core_1.contractAddress)(workchain ?? 0, init), init, contentResolver);
    }
    static createFromAddress(address, contentResolver) {
      return new NftItem2(address, void 0, contentResolver);
    }
    async sendDeploy(provider, sender, params, value) {
      await provider.internal(sender, {
        value: value ?? (0, core_1.toNano)("0.05"),
        bounce: true,
        body: (0, core_1.beginCell)().store((0, NftItemParams_1.storeNftItemParams)(params)).endCell()
      });
    }
    async send(provider, sender, newOwner, options) {
      const notification = (0, types_1.parseNotifyOptions)(options?.notify);
      const excessReturn = (0, types_1.parseExcessReturnOptions)(options?.returnExcess, sender);
      await provider.internal(sender, {
        value: (options?.value ?? (0, core_1.toNano)("0.05")) + (notification?.amount ?? 0n),
        bounce: true,
        sendMode: core_1.SendMode.PAY_GAS_SEPARATELY,
        body: (0, core_1.beginCell)().store((0, NftTransferMessage_1.storeNftTransferMessage)({
          queryId: options?.queryId ?? 0n,
          newOwner,
          responseDestination: excessReturn?.address ?? null,
          customPayload: options?.customPayload ?? null,
          forwardAmount: notification?.amount ?? 0n,
          forwardPayload: notification?.payload ?? null
        })).endCell()
      });
    }
    async getData(provider) {
      const { stack } = await provider.get("get_nft_data", []);
      return {
        initialized: stack.readBoolean(),
        index: stack.readBigNumber(),
        collection: stack.readAddressOpt(),
        owner: stack.readAddressOpt(),
        individualContent: stack.readCellOpt()
      };
    }
    async getContent(provider) {
      if (this.contentResolver === void 0) {
        throw new Error("No content resolver");
      }
      const { collection, individualContent, index } = await this.getData(provider);
      if (individualContent === null) {
        throw new Error("Individual content is null");
      }
      let content2;
      if (collection === null) {
        content2 = individualContent;
      } else {
        const collectionContract = provider.open(NftCollection_1.NftCollection.createFromAddress(collection, this.contentResolver));
        content2 = await collectionContract.getItemContent(index, individualContent);
      }
      return (0, content_2.parseNftContent)(await (0, content_1.loadFullContent)(content2, this.contentResolver));
    }
    async getRoyaltyParams(provider) {
      const { collection } = await this.getData(provider);
      if (collection === null) {
        return this.getNftItemRoyaltyParams(provider);
      }
      const collectionContract = provider.open(NftCollection_1.NftCollection.createFromAddress(collection, this.contentResolver));
      return collectionContract.getRoyaltyParams();
    }
    async getNftItemRoyaltyParams(provider) {
      const { stack } = await provider.get("get_royalty_params", []);
      return {
        numerator: stack.readBigNumber(),
        denominator: stack.readBigNumber(),
        recipient: stack.readAddress()
      };
    }
    async getActions(provider, options) {
      let { lt, hash, limit } = options ?? {};
      if (!lt || !hash) {
        const state = await provider.getState();
        if (!state.last) {
          return [];
        }
        lt = state.last.lt;
        hash = state.last.hash;
      }
      const transactions = await provider.getTransactions(this.address, lt, hash, limit);
      return transactions.map((tx) => (0, NftItemAction_1.parseNftItemTransaction)(tx));
    }
  };
  NftItem.NftItem = NftItem$1;
  NftItem$1.nftCode = core_1.Cell.fromBase64(nft_item_1.nftItemCode.codeBoc);
  return NftItem;
}
var NftCollectionData = {};
var hasRequiredNftCollectionData;
function requireNftCollectionData() {
  if (hasRequiredNftCollectionData) return NftCollectionData;
  hasRequiredNftCollectionData = 1;
  Object.defineProperty(NftCollectionData, "__esModule", { value: true });
  NftCollectionData.loadNftCollectionData = NftCollectionData.storeNftCollectionData = void 0;
  const core_1 = requireDist$5();
  const NftRoyaltyParams_1 = requireNftRoyaltyParams();
  function storeNftCollectionData(src2) {
    return (builder2) => {
      builder2.storeAddress(src2.admin);
      builder2.storeUint(0, 64);
      builder2.storeRef(src2.content);
      builder2.storeRef(src2.itemCode);
      builder2.storeRef((0, core_1.beginCell)().store((0, NftRoyaltyParams_1.storeNftRoyaltyParams)(src2.royalty)).endCell());
    };
  }
  NftCollectionData.storeNftCollectionData = storeNftCollectionData;
  function loadNftCollectionData(slice) {
    return {
      admin: slice.loadAddress(),
      content: slice.loadRef(),
      itemCode: slice.loadRef(),
      royalty: (0, NftRoyaltyParams_1.loadNftRoyaltyParams)(slice)
    };
  }
  NftCollectionData.loadNftCollectionData = loadNftCollectionData;
  return NftCollectionData;
}
var NftCollectionAction = {};
var NftCollectionMessage = {};
var hasRequiredNftCollectionMessage;
function requireNftCollectionMessage() {
  if (hasRequiredNftCollectionMessage) return NftCollectionMessage;
  hasRequiredNftCollectionMessage = 1;
  Object.defineProperty(NftCollectionMessage, "__esModule", { value: true });
  NftCollectionMessage.loadNftCollectionMessage = void 0;
  const opcodes_1 = requireOpcodes();
  const NftMintMessage_1 = requireNftMintMessage();
  const NftBatchMintMessage_1 = requireNftBatchMintMessage();
  const NftChangeAdminMessage_1 = requireNftChangeAdminMessage();
  const NftChangeContentMessage_1 = requireNftChangeContentMessage();
  function loadNftCollectionMessage(slice, paramsValue) {
    try {
      const op = slice.preloadUint(32);
      switch (op) {
        case opcodes_1.NFT_MINT_OPCODE: {
          return { kind: "mint", ...(0, NftMintMessage_1.loadNftMintMessage)(slice, paramsValue.load) };
        }
        case opcodes_1.NFT_BATCH_MINT_OPCODE: {
          return { kind: "mint_batch", ...(0, NftBatchMintMessage_1.loadNftBatchMintMessage)(slice, paramsValue.load) };
        }
        case opcodes_1.NFT_CHANGE_ADMIN_OPCODE: {
          return { kind: "change_admin", ...(0, NftChangeAdminMessage_1.loadNftChangeAdminMessage)(slice) };
        }
        case opcodes_1.NFT_CHANGE_CONTENT_OPCODE: {
          return { kind: "change_content", ...(0, NftChangeContentMessage_1.loadNftChangeContentMessage)(slice) };
        }
      }
    } catch (e) {
    }
    return { kind: "unknown" };
  }
  NftCollectionMessage.loadNftCollectionMessage = loadNftCollectionMessage;
  return NftCollectionMessage;
}
var hasRequiredNftCollectionAction;
function requireNftCollectionAction() {
  if (hasRequiredNftCollectionAction) return NftCollectionAction;
  hasRequiredNftCollectionAction = 1;
  Object.defineProperty(NftCollectionAction, "__esModule", { value: true });
  NftCollectionAction.parseNftCollectionTransaction = void 0;
  const NftCollectionMessage_1 = requireNftCollectionMessage();
  const NftItemParams_1 = requireNftItemParams();
  const TransferAction_1 = requireTransferAction();
  function parseNftCollectionTransaction(tx) {
    const mayBeTransfer = (0, TransferAction_1.parseTransferTransaction)(tx);
    if (mayBeTransfer.kind !== "unknown") {
      return mayBeTransfer;
    }
    if (tx.description.type !== "generic") {
      return { kind: "unknown", transaction: tx };
    }
    if (!tx.inMessage) {
      return { kind: "unknown", transaction: tx };
    }
    if (tx.inMessage.info.type !== "internal") {
      return { kind: "unknown", transaction: tx };
    }
    if (tx.description.computePhase.type !== "vm") {
      return { kind: "unknown", transaction: tx };
    }
    if (tx.description.computePhase.exitCode !== 0) {
      return { kind: "unknown", transaction: tx };
    }
    const inMessage = (0, NftCollectionMessage_1.loadNftCollectionMessage)(tx.inMessage.body.beginParse(), (0, NftItemParams_1.createNftItemParamsValue)());
    if (inMessage.kind === "mint") {
      return {
        kind: "mint",
        queryId: inMessage.queryId,
        index: inMessage.itemIndex,
        owner: inMessage.itemParams.owner,
        content: inMessage.itemParams.individualContent,
        transaction: tx
      };
    }
    if (inMessage.kind === "mint_batch") {
      return {
        kind: "mint_batch",
        queryId: inMessage.queryId,
        items: inMessage.requests.map((item) => ({
          index: item.index,
          owner: item.params.owner,
          content: item.params.individualContent
        })),
        transaction: tx
      };
    }
    if (inMessage.kind === "change_admin") {
      return {
        kind: "change_owner",
        queryId: inMessage.queryId,
        newOwner: inMessage.newAdmin,
        transaction: tx
      };
    }
    if (inMessage.kind === "change_content") {
      return {
        kind: "change_content",
        queryId: inMessage.queryId,
        newContent: inMessage.newContent,
        newRoyalty: inMessage.newRoyaltyParams,
        transaction: tx
      };
    }
    return { kind: "unknown", transaction: tx };
  }
  NftCollectionAction.parseNftCollectionTransaction = parseNftCollectionTransaction;
  return NftCollectionAction;
}
var hasRequiredNftCollection;
function requireNftCollection() {
  if (hasRequiredNftCollection) return NftCollection;
  hasRequiredNftCollection = 1;
  Object.defineProperty(NftCollection, "__esModule", { value: true });
  NftCollection.NftCollection = NftCollection.nftCollectionConfigToCell = void 0;
  const core_1 = requireDist$5();
  const NftCollectionBase_1 = requireNftCollectionBase();
  const NftItem_1 = requireNftItem();
  const NftCollectionData_1 = requireNftCollectionData();
  const NftItemParams_1 = requireNftItemParams();
  const NftCollectionAction_1 = requireNftCollectionAction();
  function nftCollectionConfigToCell(config) {
    return (0, core_1.beginCell)().store((0, NftCollectionData_1.storeNftCollectionData)({
      admin: config.admin,
      content: config.content,
      itemCode: config.itemCode ?? NftItem_1.NftItem.nftCode,
      royalty: {
        numerator: config.royalty?.numerator ?? 0n,
        denominator: config.royalty?.denominator ?? 1n,
        recipient: config.royalty?.recipient ?? config.admin
      }
    })).endCell();
  }
  NftCollection.nftCollectionConfigToCell = nftCollectionConfigToCell;
  let NftCollection$1 = class NftCollection2 extends NftCollectionBase_1.NftCollectionBase {
    static createFromConfig(config, code, workchain, contentResolver) {
      const data = nftCollectionConfigToCell(config);
      const init = { data, code: code ?? NftCollectionBase_1.NftCollectionBase.code };
      return new NftCollection2((0, core_1.contractAddress)(workchain ?? 0, init), init, contentResolver, (0, NftItemParams_1.createNftItemParamsValue)());
    }
    static createFromAddress(address, contentResolver) {
      return new NftCollection2(address, void 0, contentResolver, (0, NftItemParams_1.createNftItemParamsValue)());
    }
    async getItem(provider, index) {
      const nftItemAddress = await this.getItemAddress(provider, index);
      return provider.open(new NftItem_1.NftItem(nftItemAddress, void 0, this.contentResolver));
    }
    async getRoyaltyParams(provider) {
      const { stack } = await provider.get("royalty_params", []);
      return {
        numerator: stack.readBigNumber(),
        denominator: stack.readBigNumber(),
        recipient: stack.readAddress()
      };
    }
    async getActions(provider, options) {
      let { lt, hash, limit } = options ?? {};
      if (!lt || !hash) {
        const state = await provider.getState();
        if (!state.last) {
          return [];
        }
        lt = state.last.lt;
        hash = state.last.hash;
      }
      const messages = await provider.getTransactions(this.address, lt, hash, limit);
      return messages.map((tx) => (0, NftCollectionAction_1.parseNftCollectionTransaction)(tx));
    }
  };
  NftCollection.NftCollection = NftCollection$1;
  return NftCollection;
}
var SbtCollection = {};
var SbtItem = {};
var sbtItem = {};
var hasRequiredSbtItem$1;
function requireSbtItem$1() {
  if (hasRequiredSbtItem$1) return sbtItem;
  hasRequiredSbtItem$1 = 1;
  Object.defineProperty(sbtItem, "__esModule", { value: true });
  sbtItem.sbtItemCode = void 0;
  sbtItem.sbtItemCode = {
    codeBoc: "te6ccgECEwEAAzsAART/APSkE/S88sgLAQIBYgIDAgLOBAUCASAPEAS9RsIiDHAJFb4AHQ0wP6QDDwAvhCs44cMfhDAccF8uGV+kAB+GTUAfhm+kAw+GVw+GfwA+AC0x8CcbDjAgHTP4IQ0MO/6lIwuuMCghAE3tFIUjC64wIwghAvyyaiUiC6gGBwgJAgEgDQ4AlDAx0x+CEAUkx64Suo450z8wgBD4RHCCEMGOhtJVA22AQAPIyx8Syz8hbrOTAc8XkTHiyXEFyMsFUATPFlj6AhPLaszJAfsAkTDiAMJsEvpA1NMAMPhH+EHIy/9QBs8W+ETPFhLMFMs/UjDLAAPDAJb4RlADzALegBB4sXCCEA3WB+NANRSAQAPIyx8Syz8hbrOTAc8XkTHiyXEFyMsFUATPFlj6AhPLaszJAfsAAMYy+ERQA8cF8uGR+kDU0wAw+Ef4QcjL//hEzxYTzBLLP1IQywABwwCU+EYBzN6AEHixcIIQBSTHrkBVA4BAA8jLHxLLPyFus5MBzxeRMeLJcQXIywVQBM8WWPoCE8tqzMkB+wAD+o5AMfhByMv/+EPPFoAQcIIQi3cXNUAVUEQDgEADyMsfEss/IW6zkwHPF5Ex4slxBcjLBVAEzxZY+gITy2rMyQH7AOCCEB8EU3pSILrjAoIQb4n141Iguo4WW/hFAccF8uGR+EfAAPLhk/gj+GfwA+CCENE207NSILrjAjAxCgsMAJIx+EQixwXy4ZGAEHCCENUydtsQJFUCbYMGA8jLHxLLPyFus5MBzxeRMeLJcQXIywVQBM8WWPoCE8tqzMkB+wCLAvhkiwL4ZfADAI4x+EQixwXy4ZGCCvrwgHD7AoAQcIIQ1TJ22xAkVQJtgwYDyMsfEss/IW6zkwHPF5Ex4slxBcjLBVAEzxZY+gITy2rMyQH7AAAgghBfzD0UupPywZ3ehA/y8ABhO1E0NM/Afhh+kAB+GNw+GIg10nCAI4Wf/hi+kAB+GTUAfhm+kAB+GXTPzD4Z5Ew4oAA3PhH+Eb4QcjLP/hDzxb4RM8WzPhFzxbLP8ntVIAIBWBESAB28fn+AF8IXwg/CH8InwjQADbVjHgBfCLAADbewfgBfCPA="
  };
  return sbtItem;
}
var SbtItemParams = {};
var hasRequiredSbtItemParams;
function requireSbtItemParams() {
  if (hasRequiredSbtItemParams) return SbtItemParams;
  hasRequiredSbtItemParams = 1;
  Object.defineProperty(SbtItemParams, "__esModule", { value: true });
  SbtItemParams.createSbtItemParamsValue = SbtItemParams.loadSbtItemParams = SbtItemParams.storeSbtItemParams = void 0;
  const core_1 = requireDist$5();
  function storeSbtItemParams(src2) {
    return (builder2) => {
      builder2.storeAddress(src2.owner);
      if (typeof src2.individualContent === "string") {
        builder2.storeRef((0, core_1.beginCell)().storeStringTail(src2.individualContent).endCell());
      } else {
        builder2.storeRef(src2.individualContent);
      }
      builder2.storeAddress(src2.authority);
    };
  }
  SbtItemParams.storeSbtItemParams = storeSbtItemParams;
  function loadSbtItemParams(slice) {
    const owner = slice.loadAddress();
    const content2 = slice.loadRef();
    const authority = slice.loadMaybeAddress();
    return { owner, individualContent: content2, authority };
  }
  SbtItemParams.loadSbtItemParams = loadSbtItemParams;
  function createSbtItemParamsValue() {
    return {
      store: storeSbtItemParams,
      load: loadSbtItemParams
    };
  }
  SbtItemParams.createSbtItemParamsValue = createSbtItemParamsValue;
  return SbtItemParams;
}
var SbtItemAction = {};
var hasRequiredSbtItemAction;
function requireSbtItemAction() {
  if (hasRequiredSbtItemAction) return SbtItemAction;
  hasRequiredSbtItemAction = 1;
  Object.defineProperty(SbtItemAction, "__esModule", { value: true });
  SbtItemAction.parseSbtItemTransaction = void 0;
  const NftMessage_1 = requireNftMessage();
  const TransferAction_1 = requireTransferAction();
  function parseSbtItemTransaction(tx) {
    const mayBeTransfer = (0, TransferAction_1.parseTransferTransaction)(tx);
    if (mayBeTransfer.kind !== "unknown") {
      return mayBeTransfer;
    }
    if (tx.description.type !== "generic") {
      return { kind: "unknown", transaction: tx };
    }
    if (!tx.inMessage) {
      return { kind: "unknown", transaction: tx };
    }
    if (tx.inMessage.info.type !== "internal") {
      return { kind: "unknown", transaction: tx };
    }
    if (tx.description.computePhase.type !== "vm") {
      return { kind: "unknown", transaction: tx };
    }
    if (tx.description.computePhase.exitCode !== 0) {
      return { kind: "unknown", transaction: tx };
    }
    const inMessage = (0, NftMessage_1.loadNftMessage)(tx.inMessage.body.beginParse());
    if (inMessage.kind === "nft_deploy") {
      return {
        kind: "sbt_deploy",
        owner: inMessage.owner,
        content: inMessage.content,
        collection: tx.inMessage.info.src,
        transaction: tx
      };
    }
    return { kind: "unknown", transaction: tx };
  }
  SbtItemAction.parseSbtItemTransaction = parseSbtItemTransaction;
  return SbtItemAction;
}
var hasRequiredSbtItem;
function requireSbtItem() {
  if (hasRequiredSbtItem) return SbtItem;
  hasRequiredSbtItem = 1;
  Object.defineProperty(SbtItem, "__esModule", { value: true });
  SbtItem.SbtItem = SbtItem.sbtItemConfigToCell = void 0;
  const core_1 = requireDist$5();
  const content_1 = requireContent$2();
  const NftCollection_1 = requireNftCollection();
  const content_2 = requireContent();
  const sbt_item_1 = requireSbtItem$1();
  const SbtItemParams_1 = requireSbtItemParams();
  const SbtItemAction_1 = requireSbtItemAction();
  function sbtItemConfigToCell(config) {
    return (0, core_1.beginCell)().storeUint(config.index, 64).storeAddress(config.collection).endCell();
  }
  SbtItem.sbtItemConfigToCell = sbtItemConfigToCell;
  let SbtItem$1 = class SbtItem2 {
    constructor(address, init, contentResolver) {
      this.address = address;
      this.init = init;
      this.contentResolver = contentResolver;
    }
    static createFromConfig(config, code, workchain, contentResolver) {
      const data = sbtItemConfigToCell(config);
      const init = { data, code: code ?? SbtItem2.sbtCode };
      return new SbtItem2((0, core_1.contractAddress)(workchain ?? 0, init), init, contentResolver);
    }
    static createFromAddress(address, contentResolver) {
      return new SbtItem2(address, void 0, contentResolver);
    }
    async sendDeploy(provider, sender, params, value) {
      await provider.internal(sender, {
        value: value ?? (0, core_1.toNano)("0.03"),
        bounce: true,
        body: (0, core_1.beginCell)().store((0, SbtItemParams_1.storeSbtItemParams)(params)).endCell()
      });
    }
    async getData(provider) {
      const { stack } = await provider.get("get_nft_data", []);
      return {
        initialized: stack.readBoolean(),
        index: stack.readBigNumber(),
        collection: stack.readAddressOpt(),
        owner: stack.readAddressOpt(),
        individualContent: stack.readCellOpt()
      };
    }
    async getContent(provider) {
      if (this.contentResolver === void 0) {
        throw new Error("No content resolver");
      }
      const { collection, individualContent, index } = await this.getData(provider);
      if (individualContent === null) {
        throw new Error("Individual content is null");
      }
      let content2;
      if (collection === null) {
        content2 = individualContent;
      } else {
        const collectionContract = provider.open(NftCollection_1.NftCollection.createFromAddress(collection, this.contentResolver));
        content2 = await collectionContract.getItemContent(index, individualContent);
      }
      return (0, content_2.parseNftContent)(await (0, content_1.loadFullContent)(content2, this.contentResolver));
    }
    async getActions(provider, options) {
      let { lt, hash, limit } = options ?? {};
      if (!lt || !hash) {
        const state = await provider.getState();
        if (!state.last) {
          return [];
        }
        lt = state.last.lt;
        hash = state.last.hash;
      }
      const transactions = await provider.getTransactions(this.address, lt, hash, limit);
      return transactions.map((tx) => (0, SbtItemAction_1.parseSbtItemTransaction)(tx));
    }
  };
  SbtItem.SbtItem = SbtItem$1;
  SbtItem$1.sbtCode = core_1.Cell.fromBase64(sbt_item_1.sbtItemCode.codeBoc);
  return SbtItem;
}
var SbtCollectionAction = {};
var hasRequiredSbtCollectionAction;
function requireSbtCollectionAction() {
  if (hasRequiredSbtCollectionAction) return SbtCollectionAction;
  hasRequiredSbtCollectionAction = 1;
  Object.defineProperty(SbtCollectionAction, "__esModule", { value: true });
  SbtCollectionAction.parseSbtCollectionTransaction = void 0;
  const SbtItemParams_1 = requireSbtItemParams();
  const NftCollectionMessage_1 = requireNftCollectionMessage();
  function parseSbtCollectionTransaction(tx) {
    if (tx.description.type !== "generic") {
      return { kind: "unknown", transaction: tx };
    }
    if (!tx.inMessage) {
      return { kind: "unknown", transaction: tx };
    }
    if (tx.inMessage.info.type !== "internal") {
      return { kind: "unknown", transaction: tx };
    }
    if (tx.description.computePhase.type !== "vm") {
      return { kind: "unknown", transaction: tx };
    }
    if (tx.description.computePhase.exitCode !== 0) {
      return { kind: "unknown", transaction: tx };
    }
    const inMessage = (0, NftCollectionMessage_1.loadNftCollectionMessage)(tx.inMessage.body.beginParse(), (0, SbtItemParams_1.createSbtItemParamsValue)());
    if (inMessage.kind === "mint") {
      return {
        kind: "mint",
        index: inMessage.itemIndex,
        owner: inMessage.itemParams.owner,
        content: inMessage.itemParams.individualContent,
        authority: inMessage.itemParams.authority,
        transaction: tx
      };
    }
    if (inMessage.kind === "mint_batch") {
      return {
        kind: "mint_batch",
        items: inMessage.requests.map((item) => ({
          index: item.index,
          owner: item.params.owner,
          content: item.params.individualContent,
          authority: item.params.authority
        })),
        transaction: tx
      };
    }
    if (inMessage.kind === "change_admin") {
      return {
        kind: "change_owner",
        newOwner: inMessage.newAdmin,
        transaction: tx
      };
    }
    if (inMessage.kind === "change_content") {
      return {
        kind: "change_content",
        newContent: inMessage.newContent,
        newRoyalty: inMessage.newRoyaltyParams,
        transaction: tx
      };
    }
    return { kind: "unknown", transaction: tx };
  }
  SbtCollectionAction.parseSbtCollectionTransaction = parseSbtCollectionTransaction;
  return SbtCollectionAction;
}
var hasRequiredSbtCollection;
function requireSbtCollection() {
  if (hasRequiredSbtCollection) return SbtCollection;
  hasRequiredSbtCollection = 1;
  Object.defineProperty(SbtCollection, "__esModule", { value: true });
  SbtCollection.SbtCollection = SbtCollection.sbtCollectionConfigToCell = void 0;
  const core_1 = requireDist$5();
  const NftCollectionBase_1 = requireNftCollectionBase();
  const SbtItem_1 = requireSbtItem();
  const SbtCollectionAction_1 = requireSbtCollectionAction();
  const NftCollectionData_1 = requireNftCollectionData();
  const SbtItemParams_1 = requireSbtItemParams();
  function sbtCollectionConfigToCell(config) {
    return (0, core_1.beginCell)().store((0, NftCollectionData_1.storeNftCollectionData)({
      admin: config.admin,
      content: config.content,
      itemCode: config.itemCode ?? SbtItem_1.SbtItem.sbtCode,
      royalty: {
        numerator: 0n,
        denominator: 1n,
        recipient: config.admin
      }
    })).endCell();
  }
  SbtCollection.sbtCollectionConfigToCell = sbtCollectionConfigToCell;
  let SbtCollection$1 = class SbtCollection2 extends NftCollectionBase_1.NftCollectionBase {
    static createFromConfig(config, code, workchain, contentResolver) {
      const data = sbtCollectionConfigToCell(config);
      const init = { data, code: code ?? SbtCollection2.code };
      return new SbtCollection2((0, core_1.contractAddress)(workchain ?? 0, init), init, contentResolver, (0, SbtItemParams_1.createSbtItemParamsValue)());
    }
    static createFromAddress(address, contentResolver) {
      return new SbtCollection2(address, void 0, contentResolver, (0, SbtItemParams_1.createSbtItemParamsValue)());
    }
    async getItem(provider, index) {
      const nftItemAddress = await this.getItemAddress(provider, index);
      return provider.open(new SbtItem_1.SbtItem(nftItemAddress, void 0, this.contentResolver));
    }
    async getActions(provider, options) {
      let { lt, hash, limit } = options ?? {};
      if (!lt || !hash) {
        const state = await provider.getState();
        if (!state.last) {
          return [];
        }
        lt = state.last.lt;
        hash = state.last.hash;
      }
      const messages = await provider.getTransactions(this.address, lt, hash, limit);
      return messages.map((tx) => (0, SbtCollectionAction_1.parseSbtCollectionTransaction)(tx));
    }
  };
  SbtCollection.SbtCollection = SbtCollection$1;
  return SbtCollection;
}
var NftSale = {};
var hasRequiredNftSale;
function requireNftSale() {
  if (hasRequiredNftSale) return NftSale;
  hasRequiredNftSale = 1;
  Object.defineProperty(NftSale, "__esModule", { value: true });
  NftSale.NftSale = void 0;
  const core_1 = requireDist$5();
  let NftSale$1 = class NftSale2 {
    constructor(address, init) {
      this.address = address;
      this.init = init;
    }
    static createFromConfig(params, code, workchain) {
      const data = (0, core_1.beginCell)().storeBit(false).storeUint(params.createdAt, 32).storeAddress(params.marketplace).storeAddress(params.nft).storeAddress(null).storeCoins(params.fullPrice).storeRef((0, core_1.beginCell)().storeAddress(params.marketplaceFeeTo).storeCoins(params.marketplaceFee).storeAddress(params.royaltyTo).storeCoins(params.royalty)).storeBit(params.canDeployByExternal).endCell();
      const init = { data, code: code ?? NftSale2.code };
      return new NftSale2((0, core_1.contractAddress)(workchain ?? 0, init), init);
    }
    static createFromAddress(address) {
      return new NftSale2(address);
    }
    async sendDeploy(provider, sender, value) {
      await provider.internal(sender, {
        value: value ?? (0, core_1.toNano)("1"),
        bounce: true,
        sendMode: core_1.SendMode.PAY_GAS_SEPARATELY
      });
    }
    async sendDeployExternal(provider) {
      await provider.external(new core_1.Cell());
    }
    async sendTopup(provider, sender, options) {
      await provider.internal(sender, {
        value: options?.value ?? (0, core_1.toNano)("0.05"),
        bounce: true,
        sendMode: core_1.SendMode.PAY_GAS_SEPARATELY,
        body: (0, core_1.beginCell)().storeUint(1, 32).storeUint(options?.queryId ?? 0, 64).endCell()
      });
    }
    async sendAdminMessage(provider, sender, params, value, queryId) {
      const builder2 = (0, core_1.beginCell)().storeUint(555, 32).storeUint(queryId ?? 0, 64);
      if (params.message instanceof core_1.Cell) {
        builder2.storeRef(builder2);
      } else {
        builder2.storeRef((0, core_1.beginCell)().store((0, core_1.storeMessageRelaxed)(params.message)));
      }
      await provider.internal(sender, {
        value: value ?? (0, core_1.toNano)("0.05"),
        bounce: true,
        sendMode: core_1.SendMode.PAY_GAS_SEPARATELY,
        body: builder2.storeUint(params.sendMode, 8).endCell()
      });
    }
    async sendCancel(provider, sender, options) {
      const { isComplete } = await this.getData(provider);
      if (isComplete) {
        throw new Error("Sale is complete");
      }
      await provider.internal(sender, {
        value: options?.value ?? (0, core_1.toNano)("1"),
        bounce: true,
        sendMode: core_1.SendMode.PAY_GAS_SEPARATELY,
        body: (0, core_1.beginCell)().storeUint(3, 32).storeUint(options?.queryId ?? 0, 64).endCell()
      });
    }
    async sendBuy(provider, sender, options) {
      const { isComplete, nftOwner, fullPrice } = await this.getData(provider);
      if (!isComplete) {
        throw new Error("Sale is not complete");
      }
      if (nftOwner === null) {
        throw new Error("NFT owner is not set");
      }
      await provider.internal(sender, {
        value: options?.value ?? fullPrice + (0, core_1.toNano)(1),
        bounce: true,
        sendMode: core_1.SendMode.PAY_GAS_SEPARATELY,
        body: (0, core_1.beginCell)().storeUint(2, 32).storeUint(options?.queryId ?? 0, 64).endCell()
      });
    }
    async getData(provider) {
      const { stack } = await provider.get("get_sale_data", []);
      return {
        type: stack.readNumber(),
        isComplete: stack.readBoolean(),
        createdAt: stack.readNumber(),
        marketplace: stack.readAddress(),
        nft: stack.readAddress(),
        nftOwner: stack.readAddressOpt(),
        fullPrice: stack.readBigNumber(),
        marketplaceFeeTo: stack.readAddress(),
        marketplaceFee: stack.readBigNumber(),
        royaltyTo: stack.readAddressOpt(),
        royalty: stack.readBigNumber()
      };
    }
  };
  NftSale.NftSale = NftSale$1;
  NftSale$1.code = core_1.Cell.fromBase64("te6cckECCwEAArkAART/APSkE/S88sgLAQIBIAMCAH7yMO1E0NMA0x/6QPpA+kD6ANTTADDAAY4d+ABwB8jLABbLH1AEzxZYzxYBzxYB+gLMywDJ7VTgXweCAP/+8vACAUgFBABXoDhZ2omhpgGmP/SB9IH0gfQBqaYAYGGh9IH0AfSB9ABhBCCMkrCgFYACqwECAs0IBgH3ZghA7msoAUmCgUjC+8uHCJND6QPoA+kD6ADBTkqEhoVCHoRagUpBwgBDIywVQA88WAfoCy2rJcfsAJcIAJddJwgKwjhdQRXCAEMjLBVADzxYB+gLLaslx+wAQI5I0NOJacIAQyMsFUAPPFgH6AstqyXH7AHAgghBfzD0UgcAlsjLHxPLPyPPFlADzxbKAIIJycOA+gLKAMlxgBjIywUmzxZw+gLLaszJgwb7AHFVUHAHyMsAFssfUATPFljPFgHPFgH6AszLAMntVAH30A6GmBgLjYSS+CcH0gGHaiaGmAaY/9IH0gfSB9AGppgBgYOCmE44BgAEqYhOmPhW8Q4YBKGATpn8cIxbMbC3MbK2QV44LJOZlvKAVxFWAAyS+G8BJrpOEBFcCBFd0VYACRWdjYKdxjgthOjq+G6hhoaYPqGAD9gHAU4ADAkB6PLRlLOOQjEzOTlTUscFkl8J4FFRxwXy4fSCEAUTjZEWuvLh9QP6QDBGUBA0WXAHyMsAFssfUATPFljPFgHPFgH6AszLAMntVOAwNyjAA+MCKMAAnDY3EDhHZRRDMHDwBeAIwAKYVUQQJBAj8AXgXwqED/LwCgDUODmCEDuaygAYvvLhyVNGxwVRUscFFbHy4cpwIIIQX8w9FCGAEMjLBSjPFiH6Astqyx8Vyz8nzxYnzxYUygAj+gITygDJgwb7AHFQZkUVBHAHyMsAFssfUATPFljPFgHPFgH6AszLAMntVOBqUYM=");
  return NftSale;
}
var noop = {};
var hasRequiredNoop;
function requireNoop() {
  if (hasRequiredNoop) return noop;
  hasRequiredNoop = 1;
  Object.defineProperty(noop, "__esModule", { value: true });
  noop.NoopStorage = void 0;
  class NoopStorage {
    async uploadFile(contents) {
      throw new Error(`No storage provider configured`);
    }
  }
  noop.NoopStorage = NoopStorage;
  return noop;
}
var common = {};
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1;
  var __importDefault = common && common.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(common, "__esModule", { value: true });
  common.retry = common.formatAddressLink = common.formatAddress = common.printAddress = common.printInfo = common.createEnv = common.createContentResolver = common.createStorageEnv = void 0;
  const core_1 = requireDist$5();
  const __1 = requireDist();
  const content_1 = requireContent$2();
  const chalk_1 = __importDefault(require$$4$2);
  const boxen_1 = __importDefault(require$$4$2);
  function createStorageEnv() {
    if (process.env.STORAGE_TYPE === void 0)
      throw new Error("No STORAGE_TYPE in env!");
    if (process.env.STORAGE_TYPE === "pinata") {
      if (process.env.PINATA_API_KEY === void 0)
        throw new Error("No PINATA_API_KEY in env!");
      if (process.env.PINATA_SECRET_KEY === void 0)
        throw new Error("No PINATA_SECRET_KEY in env!");
      return new __1.PinataStorage(process.env.PINATA_API_KEY, process.env.PINATA_SECRET_KEY);
    } else if (process.env.STORAGE_TYPE === "s3") {
      if (process.env.S3_ACCESS_KEY_ID === void 0)
        throw new Error("No S3_ACCESS_KEY_ID in env!");
      if (process.env.S3_SECRET_ACCESS_KEY === void 0)
        throw new Error("No S3_SECRET_ACCESS_KEY in env!");
      if (process.env.S3_BUCKET === void 0)
        throw new Error("No S3_BUCKET in env!");
      return new __1.S3Storage(process.env.S3_ACCESS_KEY_ID, process.env.S3_SECRET_ACCESS_KEY, process.env.S3_BUCKET);
    }
    throw new Error(`Unknown storage type: ${process.env.STORAGE_TYPE}`);
  }
  common.createStorageEnv = createStorageEnv;
  function createContentResolver() {
    if (process.env.IPFS_GATEWAY_TYPE === void 0)
      throw new Error("No IPFS_GATEWAY_TYPE in env!");
    if (process.env.IPFS_GATEWAY_TYPE === "ipfs.io") {
      return new content_1.DefaultContentResolver((id) => `https://ipfs.io/ipfs/${id}`);
    }
    if (process.env.IPFS_GATEWAY_TYPE === "https") {
      if (process.env.IPFS_GATEWAY === void 0)
        throw new Error("No IPFS_GATEWAY in env!");
      const ipfsGateway = new URL(process.env.IPFS_GATEWAY);
      return new content_1.DefaultContentResolver((id) => {
        ipfsGateway.pathname = "/ipfs/" + id;
        return ipfsGateway.toString();
      });
    }
    if (process.env.IPFS_GATEWAY_TYPE === "pinata") {
      if (process.env.IPFS_GATEWAY === void 0)
        throw new Error("No IPFS_GATEWAY in env!");
      if (process.env.IPFS_GATEWAY_API_KEY === void 0)
        throw new Error("No IPFS_GATEWAY_API_KEY in env!");
      const ipfsGateway = new URL(process.env.IPFS_GATEWAY);
      return new content_1.DefaultContentResolver((id) => {
        ipfsGateway.pathname = "/ipfs/" + id;
        ipfsGateway.searchParams.set("pinataGatewayToken", process.env.IPFS_GATEWAY_API_KEY);
        return ipfsGateway.toString();
      });
    }
    throw new Error(`Unknown IPFS gateway type: ${process.env.IPFS_GATEWAY_TYPE}`);
  }
  common.createContentResolver = createContentResolver;
  async function createEnv() {
    if (process.env.WALLET_TYPE === void 0)
      throw new Error("No WALLET_TYPE in env!");
    if (process.env.WALLET_TYPE !== "highload-v2")
      throw new Error(`Unknown wallet type: ${process.env.WALLET_TYPE}`);
    if (process.env.MNEMONIC === void 0)
      throw new Error("No MNEMONIC in env!");
    if (process.env.NETWORK === void 0)
      throw new Error("No NETWORK in env!");
    if (process.env.NETWORK !== "mainnet" && process.env.NETWORK !== "testnet")
      throw new Error(`Unknown network: ${process.env.NETWORK}`);
    const contentResolver = createContentResolver();
    const storage = createStorageEnv();
    const client = await (0, __1.createApi)(process.env.NETWORK);
    const keyPair = await (0, __1.importKey)(process.env.MNEMONIC);
    const { publicKey, secretKey } = keyPair;
    const walletContract = await (0, __1.createWallet)(process.env.WALLET_TYPE, publicKey);
    const sender = client.open(walletContract).sender(keyPair.secretKey);
    const sdk2 = __1.AssetsSDK.create({
      storage,
      api: client,
      sender,
      contentResolver
    });
    return {
      sdk: sdk2,
      network: process.env.NETWORK,
      storage,
      sender,
      client
    };
  }
  common.createEnv = createEnv;
  function printInfo(info, network) {
    const keys = Object.keys(info);
    const rows = [];
    for (const key2 of keys) {
      let value = info[key2];
      if (typeof value === "string") {
        value = chalk_1.default.green(value);
      } else if (typeof value === "bigint") {
        value = chalk_1.default.yellow(value.toString());
      } else if (typeof value === "number") {
        value = chalk_1.default.cyan(value);
      } else if (typeof value === "boolean") {
        value = chalk_1.default.blue(value);
      } else if (value === null) {
        value = chalk_1.default.red("null");
      } else if (value === void 0) {
        value = chalk_1.default.red("undefined");
      } else if (core_1.Address.isAddress(value)) {
        value = `${chalk_1.default.magenta(formatAddress(value, network))} ${chalk_1.default.blue(formatAddressLink(value, network))}`;
      } else if (value instanceof core_1.Cell) {
        value = chalk_1.default.blue(value.toString("base64"));
      } else {
        throw new Error(`Unknown type: ${typeof value}`);
      }
      rows.push([key2, value]);
    }
    console.log((0, boxen_1.default)(rows.filter(([key2]) => key2 !== "name").map(([key2, value]) => `${chalk_1.default.bold(key2)}: ${value}`).join("\n"), {
      padding: {
        top: 0,
        bottom: 0,
        left: 1,
        right: 1
      },
      borderStyle: "round",
      borderColor: "green",
      title: rows.find(([key2, value]) => key2 === "name")?.[1]
    }));
  }
  common.printInfo = printInfo;
  function printAddress(address, network, name = "wallet") {
    const formattedAddress = formatAddress(address, network);
    const formattedAddressLink = formatAddressLink(address, network);
    console.log(`Your ${name} has the address ${formattedAddress}
You can view it at ${formattedAddressLink}`);
  }
  common.printAddress = printAddress;
  function formatAddress(address, network) {
    if (!address) {
      return "null";
    }
    return address.toString({ testOnly: network === "testnet", bounceable: true });
  }
  common.formatAddress = formatAddress;
  function formatAddressLink(address, network) {
    if (!address) {
      return "null";
    }
    return `https://${network === "testnet" ? "testnet." : ""}tonviewer.com/${formatAddress(address, network)}`;
  }
  common.formatAddressLink = formatAddressLink;
  async function retry(fn, options) {
    let { retries, delay, name } = { retries: 3, delay: 1e3, ...options };
    for (let i = 0; i < retries; i++) {
      try {
        return await fn();
      } catch (e) {
        console.log(`Attempt ${i + 1} failed: ${name ? name + ": " : ""}${e}`);
      }
      await new Promise((resolve) => setTimeout(resolve, delay * 2 ** i));
    }
    throw new Error("Exceeded number of retries");
  }
  common.retry = retry;
  return common;
}
var hasRequiredSdk;
function requireSdk() {
  if (hasRequiredSdk) return sdk;
  hasRequiredSdk = 1;
  Object.defineProperty(sdk, "__esModule", { value: true });
  sdk.AssetsSDK = void 0;
  const core_1 = requireDist$5();
  const pinata_1 = requirePinata();
  const s3_1 = requireS3();
  const content_1 = requireContent$1();
  const content_2 = requireContent();
  const utils_1 = requireUtils$1();
  const JettonWallet_1 = requireJettonWallet$1();
  const JettonMinter_1 = requireJettonMinter();
  const NftCollection_1 = requireNftCollection();
  const NftItem_1 = requireNftItem();
  const SbtCollection_1 = requireSbtCollection();
  const content_3 = requireContent$2();
  const NftSale_1 = requireNftSale();
  const noop_1 = requireNoop();
  const common_1 = requireCommon();
  const WORKCHAIN = 0;
  class AssetsSDK {
    constructor(storage, api, sender, contentResolver) {
      this.storage = storage;
      this.api = api;
      this.sender = sender;
      this.contentResolver = contentResolver;
    }
    static create(params) {
      let { api, storage, sender, contentResolver } = params;
      if (!storage) {
        storage = new noop_1.NoopStorage();
      } else if ("pinataApiKey" in storage) {
        storage = pinata_1.PinataStorage.create(storage);
      } else if ("s3AccessKeyId" in storage) {
        storage = s3_1.S3Storage.create(storage);
      }
      contentResolver ?? (contentResolver = new content_3.DefaultContentResolver());
      return new AssetsSDK(storage, api, sender, contentResolver);
    }
    async deployJetton(content2, options) {
      if (!this.sender) {
        throw new Error("Sender must be defined");
      }
      const adminAddress = options?.adminAddress ?? this.sender?.address;
      if (adminAddress === void 0) {
        throw new Error("Admin address must be defined in options or be available in Sender");
      }
      const jettonMinterContract = JettonMinter_1.JettonMinter.createFromConfig({
        admin: adminAddress,
        content: await this.contentToCell((0, content_1.jettonContentToInternal)(content2), options?.onchainContent ?? false)
      }, JettonMinter_1.JettonMinter.code, WORKCHAIN, this.contentResolver);
      const jetton = this.api.open(jettonMinterContract);
      const premintAmount = options?.premintAmount;
      if (typeof premintAmount === "bigint" && premintAmount > 0n) {
        await jetton.sendMint(this.sender, adminAddress, premintAmount, {
          ...options?.premintOptions,
          value: options?.value,
          queryId: options?.queryId
        });
      } else {
        await jetton.sendDeploy(this.sender, options?.value);
      }
      return jetton;
    }
    openJetton(address) {
      return this.api.open(JettonMinter_1.JettonMinter.createFromAddress(address, this.contentResolver));
    }
    async deployNftCollection(content2, options) {
      if (!this.sender) {
        throw new Error("Sender must be defined");
      }
      const adminAddress = options?.adminAddress ?? this.sender?.address;
      if (adminAddress === void 0) {
        throw new Error("Admin address must be defined in options or be available in Sender");
      }
      const collection = this.api.open(NftCollection_1.NftCollection.createFromConfig({
        admin: adminAddress,
        content: (0, core_1.beginCell)().storeRef(await this.contentToCell((0, content_2.nftContentToInternal)(content2.collectionContent), options?.onchainContent ?? false)).storeRef((0, core_1.beginCell)().storeStringTail(content2.commonContent)).endCell(),
        royalty: options?.royaltyParams
      }, NftCollection_1.NftCollection.code, WORKCHAIN, this.contentResolver));
      if (typeof options?.premintItems?.length === "number" && options?.premintItems.length > 0) {
        await collection.sendBatchMint(this.sender, options?.premintItems, {
          value: options?.value,
          queryId: options?.queryId
        });
      } else {
        await collection.sendDeploy(this.sender, options?.value);
      }
      return collection;
    }
    openNftCollection(address) {
      return this.api.open(NftCollection_1.NftCollection.createFromAddress(address, this.contentResolver));
    }
    async deploySbtCollection(content2, options) {
      if (!this.sender) {
        throw new Error("Sender must be defined");
      }
      const adminAddress = options?.adminAddress ?? this.sender?.address;
      if (adminAddress === void 0) {
        throw new Error("Admin address must be defined in options or be available in Sender");
      }
      const collection = this.api.open(SbtCollection_1.SbtCollection.createFromConfig({
        admin: adminAddress,
        content: (0, core_1.beginCell)().storeRef(await this.contentToCell((0, content_2.nftContentToInternal)(content2.collectionContent), content2?.onchainContent ?? false)).storeRef((0, core_1.beginCell)().storeStringTail(content2.commonContent)).endCell()
      }, SbtCollection_1.SbtCollection.code, WORKCHAIN, this.contentResolver));
      if (typeof options?.premintItems?.length === "number" && options?.premintItems.length > 0) {
        await collection.sendBatchMint(this.sender, options?.premintItems, {
          value: options?.value,
          queryId: options?.queryId
        });
      } else {
        await collection.sendDeploy(this.sender, options?.value);
      }
      return collection;
    }
    openSbtCollection(address) {
      return this.api.open(SbtCollection_1.SbtCollection.createFromAddress(address, this.contentResolver));
    }
    openJettonWallet(address) {
      return this.api.open(new JettonWallet_1.JettonWallet(address));
    }
    openNftItem(address) {
      return this.api.open(new NftItem_1.NftItem(address, void 0, this.contentResolver));
    }
    async deployNftSale(params) {
      if (!this.sender) {
        throw new Error("Sender must be defined");
      }
      const marketplaceAddress = params.marketplace ?? this.sender?.address;
      if (marketplaceAddress === void 0) {
        throw new Error("Marketplace address must be defined in options or be available in Sender");
      }
      const sale = this.api.open(NftSale_1.NftSale.createFromConfig({
        createdAt: params.createdAt ?? Math.floor(Date.now() / 1e3),
        marketplace: params.marketplace ?? null,
        nft: params.nft,
        fullPrice: params.fullPrice,
        marketplaceFeeTo: params.marketplaceFeeTo ?? null,
        marketplaceFee: params.marketplaceFee ?? 0n,
        royaltyTo: params.royaltyTo ?? null,
        royalty: params.royalty ?? 0n,
        canDeployByExternal: params.canDeployByExternal ?? true
      }));
      await sale.sendTopup(this.sender, { value: params.value, queryId: params.queryId });
      return sale;
    }
    openNftSale(address) {
      return this.api.open(NftSale_1.NftSale.createFromAddress(address));
    }
    async internalOffchainContentToCell(internal) {
      const contents = Buffer.from(JSON.stringify(internal), "utf-8");
      const contentUrl = await (0, common_1.retry)(() => this.storage.uploadFile(contents), { name: "upload content" });
      return (0, core_1.beginCell)().storeUint(1, 8).storeStringTail(contentUrl).endCell();
    }
    async contentToCell(internal, onchain) {
      return onchain ? (0, utils_1.internalOnchainContentToCell)(internal) : await this.internalOffchainContentToCell(internal);
    }
  }
  sdk.AssetsSDK = AssetsSDK;
  return sdk;
}
var tonClientApi = {};
var dist = {};
var HttpApi = {};
var TonCache = {};
var hasRequiredTonCache;
function requireTonCache() {
  if (hasRequiredTonCache) return TonCache;
  hasRequiredTonCache = 1;
  Object.defineProperty(TonCache, "__esModule", { value: true });
  TonCache.InMemoryCache = void 0;
  class InMemoryCache {
    constructor() {
      this.cache = /* @__PURE__ */ new Map();
      this.set = async (namespace, key2, value) => {
        if (value !== null) {
          this.cache.set(namespace + "$$" + key2, value);
        } else {
          this.cache.delete(namespace + "$$" + key2);
        }
      };
      this.get = async (namespace, key2) => {
        let res = this.cache.get(namespace + "$$" + key2);
        if (res !== void 0) {
          return res;
        } else {
          return null;
        }
      };
    }
  }
  TonCache.InMemoryCache = InMemoryCache;
  return TonCache;
}
var dataloader;
var hasRequiredDataloader;
function requireDataloader() {
  if (hasRequiredDataloader) return dataloader;
  hasRequiredDataloader = 1;
  var DataLoader = /* @__PURE__ */ (function() {
    function DataLoader2(batchLoadFn, options) {
      if (typeof batchLoadFn !== "function") {
        throw new TypeError("DataLoader must be constructed with a function which accepts " + ("Array<key> and returns Promise<Array<value>>, but got: " + batchLoadFn + "."));
      }
      this._batchLoadFn = batchLoadFn;
      this._maxBatchSize = getValidMaxBatchSize(options);
      this._batchScheduleFn = getValidBatchScheduleFn(options);
      this._cacheKeyFn = getValidCacheKeyFn(options);
      this._cacheMap = getValidCacheMap(options);
      this._batch = null;
      this.name = getValidName(options);
    }
    var _proto = DataLoader2.prototype;
    _proto.load = function load(key2) {
      if (key2 === null || key2 === void 0) {
        throw new TypeError("The loader.load() function must be called with a value, " + ("but got: " + String(key2) + "."));
      }
      var batch = getCurrentBatch(this);
      var cacheMap = this._cacheMap;
      var cacheKey;
      if (cacheMap) {
        cacheKey = this._cacheKeyFn(key2);
        var cachedPromise = cacheMap.get(cacheKey);
        if (cachedPromise) {
          var cacheHits = batch.cacheHits || (batch.cacheHits = []);
          return new Promise(function(resolve) {
            cacheHits.push(function() {
              resolve(cachedPromise);
            });
          });
        }
      }
      batch.keys.push(key2);
      var promise = new Promise(function(resolve, reject) {
        batch.callbacks.push({
          resolve,
          reject
        });
      });
      if (cacheMap) {
        cacheMap.set(cacheKey, promise);
      }
      return promise;
    };
    _proto.loadMany = function loadMany(keys) {
      if (!isArrayLike(keys)) {
        throw new TypeError("The loader.loadMany() function must be called with Array<key> " + ("but got: " + keys + "."));
      }
      var loadPromises = [];
      for (var i = 0; i < keys.length; i++) {
        loadPromises.push(this.load(keys[i])["catch"](function(error2) {
          return error2;
        }));
      }
      return Promise.all(loadPromises);
    };
    _proto.clear = function clear(key2) {
      var cacheMap = this._cacheMap;
      if (cacheMap) {
        var cacheKey = this._cacheKeyFn(key2);
        cacheMap["delete"](cacheKey);
      }
      return this;
    };
    _proto.clearAll = function clearAll() {
      var cacheMap = this._cacheMap;
      if (cacheMap) {
        cacheMap.clear();
      }
      return this;
    };
    _proto.prime = function prime(key2, value) {
      var cacheMap = this._cacheMap;
      if (cacheMap) {
        var cacheKey = this._cacheKeyFn(key2);
        if (cacheMap.get(cacheKey) === void 0) {
          var promise;
          if (value instanceof Error) {
            promise = Promise.reject(value);
            promise["catch"](function() {
            });
          } else {
            promise = Promise.resolve(value);
          }
          cacheMap.set(cacheKey, promise);
        }
      }
      return this;
    };
    return DataLoader2;
  })();
  var enqueuePostPromiseJob = typeof process === "object" && typeof process.nextTick === "function" ? function(fn) {
    if (!resolvedPromise) {
      resolvedPromise = Promise.resolve();
    }
    resolvedPromise.then(function() {
      process.nextTick(fn);
    });
  } : typeof setImmediate === "function" ? function(fn) {
    setImmediate(fn);
  } : function(fn) {
    setTimeout(fn);
  };
  var resolvedPromise;
  function getCurrentBatch(loader) {
    var existingBatch = loader._batch;
    if (existingBatch !== null && !existingBatch.hasDispatched && existingBatch.keys.length < loader._maxBatchSize) {
      return existingBatch;
    }
    var newBatch = {
      hasDispatched: false,
      keys: [],
      callbacks: []
    };
    loader._batch = newBatch;
    loader._batchScheduleFn(function() {
      dispatchBatch(loader, newBatch);
    });
    return newBatch;
  }
  function dispatchBatch(loader, batch) {
    batch.hasDispatched = true;
    if (batch.keys.length === 0) {
      resolveCacheHits(batch);
      return;
    }
    var batchPromise;
    try {
      batchPromise = loader._batchLoadFn(batch.keys);
    } catch (e) {
      return failedDispatch(loader, batch, new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function " + ("errored synchronously: " + String(e) + ".")));
    }
    if (!batchPromise || typeof batchPromise.then !== "function") {
      return failedDispatch(loader, batch, new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did " + ("not return a Promise: " + String(batchPromise) + ".")));
    }
    batchPromise.then(function(values) {
      if (!isArrayLike(values)) {
        throw new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did " + ("not return a Promise of an Array: " + String(values) + "."));
      }
      if (values.length !== batch.keys.length) {
        throw new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise of an Array of the same length as the Array of keys." + ("\n\nKeys:\n" + String(batch.keys)) + ("\n\nValues:\n" + String(values)));
      }
      resolveCacheHits(batch);
      for (var i = 0; i < batch.callbacks.length; i++) {
        var _value = values[i];
        if (_value instanceof Error) {
          batch.callbacks[i].reject(_value);
        } else {
          batch.callbacks[i].resolve(_value);
        }
      }
    })["catch"](function(error2) {
      failedDispatch(loader, batch, error2);
    });
  }
  function failedDispatch(loader, batch, error2) {
    resolveCacheHits(batch);
    for (var i = 0; i < batch.keys.length; i++) {
      loader.clear(batch.keys[i]);
      batch.callbacks[i].reject(error2);
    }
  }
  function resolveCacheHits(batch) {
    if (batch.cacheHits) {
      for (var i = 0; i < batch.cacheHits.length; i++) {
        batch.cacheHits[i]();
      }
    }
  }
  function getValidMaxBatchSize(options) {
    var shouldBatch = !options || options.batch !== false;
    if (!shouldBatch) {
      return 1;
    }
    var maxBatchSize = options && options.maxBatchSize;
    if (maxBatchSize === void 0) {
      return Infinity;
    }
    if (typeof maxBatchSize !== "number" || maxBatchSize < 1) {
      throw new TypeError("maxBatchSize must be a positive number: " + maxBatchSize);
    }
    return maxBatchSize;
  }
  function getValidBatchScheduleFn(options) {
    var batchScheduleFn = options && options.batchScheduleFn;
    if (batchScheduleFn === void 0) {
      return enqueuePostPromiseJob;
    }
    if (typeof batchScheduleFn !== "function") {
      throw new TypeError("batchScheduleFn must be a function: " + batchScheduleFn);
    }
    return batchScheduleFn;
  }
  function getValidCacheKeyFn(options) {
    var cacheKeyFn = options && options.cacheKeyFn;
    if (cacheKeyFn === void 0) {
      return function(key2) {
        return key2;
      };
    }
    if (typeof cacheKeyFn !== "function") {
      throw new TypeError("cacheKeyFn must be a function: " + cacheKeyFn);
    }
    return cacheKeyFn;
  }
  function getValidCacheMap(options) {
    var shouldCache = !options || options.cache !== false;
    if (!shouldCache) {
      return null;
    }
    var cacheMap = options && options.cacheMap;
    if (cacheMap === void 0) {
      return /* @__PURE__ */ new Map();
    }
    if (cacheMap !== null) {
      var cacheFunctions = ["get", "set", "delete", "clear"];
      var missingFunctions = cacheFunctions.filter(function(fnName) {
        return cacheMap && typeof cacheMap[fnName] !== "function";
      });
      if (missingFunctions.length !== 0) {
        throw new TypeError("Custom cacheMap missing methods: " + missingFunctions.join(", "));
      }
    }
    return cacheMap;
  }
  function getValidName(options) {
    if (options && options.name) {
      return options.name;
    }
    return null;
  }
  function isArrayLike(x) {
    return typeof x === "object" && x !== null && typeof x.length === "number" && (x.length === 0 || x.length > 0 && Object.prototype.hasOwnProperty.call(x, x.length - 1));
  }
  dataloader = DataLoader;
  return dataloader;
}
var axios_1$1;
var hasRequiredAxios$1;
function requireAxios$1() {
  if (hasRequiredAxios$1) return axios_1$1;
  hasRequiredAxios$1 = 1;
  function bind(fn, thisArg) {
    return function wrap() {
      return fn.apply(thisArg, arguments);
    };
  }
  const { toString } = Object.prototype;
  const { getPrototypeOf } = Object;
  const { iterator, toStringTag } = Symbol;
  const kindOf = /* @__PURE__ */ ((cache) => (thing) => {
    const str = toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
  })(/* @__PURE__ */ Object.create(null));
  const kindOfTest = (type) => {
    type = type.toLowerCase();
    return (thing) => kindOf(thing) === type;
  };
  const typeOfTest = (type) => (thing) => typeof thing === type;
  const { isArray } = Array;
  const isUndefined = typeOfTest("undefined");
  function isBuffer2(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction$1(val.constructor.isBuffer) && val.constructor.isBuffer(val);
  }
  const isArrayBuffer = kindOfTest("ArrayBuffer");
  function isArrayBufferView(val) {
    let result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
      result = ArrayBuffer.isView(val);
    } else {
      result = val && val.buffer && isArrayBuffer(val.buffer);
    }
    return result;
  }
  const isString = typeOfTest("string");
  const isFunction$1 = typeOfTest("function");
  const isNumber = typeOfTest("number");
  const isObject = (thing) => thing !== null && typeof thing === "object";
  const isBoolean = (thing) => thing === true || thing === false;
  const isPlainObject = (val) => {
    if (kindOf(val) !== "object") {
      return false;
    }
    const prototype2 = getPrototypeOf(val);
    return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(toStringTag in val) && !(iterator in val);
  };
  const isEmptyObject = (val) => {
    if (!isObject(val) || isBuffer2(val)) {
      return false;
    }
    try {
      return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
    } catch (e) {
      return false;
    }
  };
  const isDate = kindOfTest("Date");
  const isFile = kindOfTest("File");
  const isBlob = kindOfTest("Blob");
  const isFileList = kindOfTest("FileList");
  const isStream = (val) => isObject(val) && isFunction$1(val.pipe);
  const isFormData = (thing) => {
    let kind;
    return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction$1(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
    kind === "object" && isFunction$1(thing.toString) && thing.toString() === "[object FormData]"));
  };
  const isURLSearchParams = kindOfTest("URLSearchParams");
  const [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
  const trim2 = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  function forEach(obj, fn, { allOwnKeys = false } = {}) {
    if (obj === null || typeof obj === "undefined") {
      return;
    }
    let i;
    let l;
    if (typeof obj !== "object") {
      obj = [obj];
    }
    if (isArray(obj)) {
      for (i = 0, l = obj.length; i < l; i++) {
        fn.call(null, obj[i], i, obj);
      }
    } else {
      if (isBuffer2(obj)) {
        return;
      }
      const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
      const len = keys.length;
      let key2;
      for (i = 0; i < len; i++) {
        key2 = keys[i];
        fn.call(null, obj[key2], key2, obj);
      }
    }
  }
  function findKey(obj, key2) {
    if (isBuffer2(obj)) {
      return null;
    }
    key2 = key2.toLowerCase();
    const keys = Object.keys(obj);
    let i = keys.length;
    let _key;
    while (i-- > 0) {
      _key = keys[i];
      if (key2 === _key.toLowerCase()) {
        return _key;
      }
    }
    return null;
  }
  const _global = (() => {
    if (typeof globalThis !== "undefined") return globalThis;
    return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : commonjsGlobal;
  })();
  const isContextDefined = (context) => !isUndefined(context) && context !== _global;
  function merge() {
    const { caseless, skipUndefined } = isContextDefined(this) && this || {};
    const result = {};
    const assignValue = (val, key2) => {
      const targetKey = caseless && findKey(result, key2) || key2;
      if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
        result[targetKey] = merge(result[targetKey], val);
      } else if (isPlainObject(val)) {
        result[targetKey] = merge({}, val);
      } else if (isArray(val)) {
        result[targetKey] = val.slice();
      } else if (!skipUndefined || !isUndefined(val)) {
        result[targetKey] = val;
      }
    };
    for (let i = 0, l = arguments.length; i < l; i++) {
      arguments[i] && forEach(arguments[i], assignValue);
    }
    return result;
  }
  const extend = (a, b, thisArg, { allOwnKeys } = {}) => {
    forEach(b, (val, key2) => {
      if (thisArg && isFunction$1(val)) {
        a[key2] = bind(val, thisArg);
      } else {
        a[key2] = val;
      }
    }, { allOwnKeys });
    return a;
  };
  const stripBOM = (content2) => {
    if (content2.charCodeAt(0) === 65279) {
      content2 = content2.slice(1);
    }
    return content2;
  };
  const inherits = (constructor, superConstructor, props, descriptors2) => {
    constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
    constructor.prototype.constructor = constructor;
    Object.defineProperty(constructor, "super", {
      value: superConstructor.prototype
    });
    props && Object.assign(constructor.prototype, props);
  };
  const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
    let props;
    let i;
    let prop;
    const merged = {};
    destObj = destObj || {};
    if (sourceObj == null) return destObj;
    do {
      props = Object.getOwnPropertyNames(sourceObj);
      i = props.length;
      while (i-- > 0) {
        prop = props[i];
        if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
          destObj[prop] = sourceObj[prop];
          merged[prop] = true;
        }
      }
      sourceObj = filter !== false && getPrototypeOf(sourceObj);
    } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
    return destObj;
  };
  const endsWith = (str, searchString, position) => {
    str = String(str);
    if (position === void 0 || position > str.length) {
      position = str.length;
    }
    position -= searchString.length;
    const lastIndex = str.indexOf(searchString, position);
    return lastIndex !== -1 && lastIndex === position;
  };
  const toArray = (thing) => {
    if (!thing) return null;
    if (isArray(thing)) return thing;
    let i = thing.length;
    if (!isNumber(i)) return null;
    const arr = new Array(i);
    while (i-- > 0) {
      arr[i] = thing[i];
    }
    return arr;
  };
  const isTypedArray = /* @__PURE__ */ ((TypedArray) => {
    return (thing) => {
      return TypedArray && thing instanceof TypedArray;
    };
  })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
  const forEachEntry = (obj, fn) => {
    const generator2 = obj && obj[iterator];
    const _iterator = generator2.call(obj);
    let result;
    while ((result = _iterator.next()) && !result.done) {
      const pair = result.value;
      fn.call(obj, pair[0], pair[1]);
    }
  };
  const matchAll = (regExp, str) => {
    let matches;
    const arr = [];
    while ((matches = regExp.exec(str)) !== null) {
      arr.push(matches);
    }
    return arr;
  };
  const isHTMLForm = kindOfTest("HTMLFormElement");
  const toCamelCase = (str) => {
    return str.toLowerCase().replace(
      /[-_\s]([a-z\d])(\w*)/g,
      function replacer(m, p1, p2) {
        return p1.toUpperCase() + p2;
      }
    );
  };
  const hasOwnProperty2 = (({ hasOwnProperty: hasOwnProperty3 }) => (obj, prop) => hasOwnProperty3.call(obj, prop))(Object.prototype);
  const isRegExp = kindOfTest("RegExp");
  const reduceDescriptors = (obj, reducer) => {
    const descriptors2 = Object.getOwnPropertyDescriptors(obj);
    const reducedDescriptors = {};
    forEach(descriptors2, (descriptor2, name) => {
      let ret;
      if ((ret = reducer(descriptor2, name, obj)) !== false) {
        reducedDescriptors[name] = ret || descriptor2;
      }
    });
    Object.defineProperties(obj, reducedDescriptors);
  };
  const freezeMethods = (obj) => {
    reduceDescriptors(obj, (descriptor2, name) => {
      if (isFunction$1(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
        return false;
      }
      const value = obj[name];
      if (!isFunction$1(value)) return;
      descriptor2.enumerable = false;
      if ("writable" in descriptor2) {
        descriptor2.writable = false;
        return;
      }
      if (!descriptor2.set) {
        descriptor2.set = () => {
          throw Error("Can not rewrite read-only method '" + name + "'");
        };
      }
    });
  };
  const toObjectSet = (arrayOrString, delimiter) => {
    const obj = {};
    const define = (arr) => {
      arr.forEach((value) => {
        obj[value] = true;
      });
    };
    isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
    return obj;
  };
  const noop2 = () => {
  };
  const toFiniteNumber = (value, defaultValue) => {
    return value != null && Number.isFinite(value = +value) ? value : defaultValue;
  };
  function isSpecCompliantForm(thing) {
    return !!(thing && isFunction$1(thing.append) && thing[toStringTag] === "FormData" && thing[iterator]);
  }
  const toJSONObject = (obj) => {
    const stack = new Array(10);
    const visit2 = (source, i) => {
      if (isObject(source)) {
        if (stack.indexOf(source) >= 0) {
          return;
        }
        if (isBuffer2(source)) {
          return source;
        }
        if (!("toJSON" in source)) {
          stack[i] = source;
          const target = isArray(source) ? [] : {};
          forEach(source, (value, key2) => {
            const reducedValue = visit2(value, i + 1);
            !isUndefined(reducedValue) && (target[key2] = reducedValue);
          });
          stack[i] = void 0;
          return target;
        }
      }
      return source;
    };
    return visit2(obj, 0);
  };
  const isAsyncFn = kindOfTest("AsyncFunction");
  const isThenable = (thing) => thing && (isObject(thing) || isFunction$1(thing)) && isFunction$1(thing.then) && isFunction$1(thing.catch);
  const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
    if (setImmediateSupported) {
      return setImmediate;
    }
    return postMessageSupported ? ((token, callbacks) => {
      _global.addEventListener("message", ({ source, data }) => {
        if (source === _global && data === token) {
          callbacks.length && callbacks.shift()();
        }
      }, false);
      return (cb) => {
        callbacks.push(cb);
        _global.postMessage(token, "*");
      };
    })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
  })(
    typeof setImmediate === "function",
    isFunction$1(_global.postMessage)
  );
  const asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
  const isIterable = (thing) => thing != null && isFunction$1(thing[iterator]);
  var utils$12 = {
    isArray,
    isArrayBuffer,
    isBuffer: isBuffer2,
    isFormData,
    isArrayBufferView,
    isString,
    isNumber,
    isBoolean,
    isObject,
    isPlainObject,
    isEmptyObject,
    isReadableStream,
    isRequest,
    isResponse,
    isHeaders,
    isUndefined,
    isDate,
    isFile,
    isBlob,
    isRegExp,
    isFunction: isFunction$1,
    isStream,
    isURLSearchParams,
    isTypedArray,
    isFileList,
    forEach,
    merge,
    extend,
    trim: trim2,
    stripBOM,
    inherits,
    toFlatObject,
    kindOf,
    kindOfTest,
    endsWith,
    toArray,
    forEachEntry,
    matchAll,
    isHTMLForm,
    hasOwnProperty: hasOwnProperty2,
    hasOwnProp: hasOwnProperty2,
    // an alias to avoid ESLint no-prototype-builtins detection
    reduceDescriptors,
    freezeMethods,
    toObjectSet,
    toCamelCase,
    noop: noop2,
    toFiniteNumber,
    findKey,
    global: _global,
    isContextDefined,
    isSpecCompliantForm,
    toJSONObject,
    isAsyncFn,
    isThenable,
    setImmediate: _setImmediate,
    asap,
    isIterable
  };
  function AxiosError(message, code, config, request, response) {
    Error.call(this);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error().stack;
    }
    this.message = message;
    this.name = "AxiosError";
    code && (this.code = code);
    config && (this.config = config);
    request && (this.request = request);
    if (response) {
      this.response = response;
      this.status = response.status ? response.status : null;
    }
  }
  utils$12.inherits(AxiosError, Error, {
    toJSON: function toJSON() {
      return {
        // Standard
        message: this.message,
        name: this.name,
        // Microsoft
        description: this.description,
        number: this.number,
        // Mozilla
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        // Axios
        config: utils$12.toJSONObject(this.config),
        code: this.code,
        status: this.status
      };
    }
  });
  const prototype$1 = AxiosError.prototype;
  const descriptors = {};
  [
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED",
    "ERR_NOT_SUPPORT",
    "ERR_INVALID_URL"
    // eslint-disable-next-line func-names
  ].forEach((code) => {
    descriptors[code] = { value: code };
  });
  Object.defineProperties(AxiosError, descriptors);
  Object.defineProperty(prototype$1, "isAxiosError", { value: true });
  AxiosError.from = (error2, code, config, request, response, customProps) => {
    const axiosError = Object.create(prototype$1);
    utils$12.toFlatObject(error2, axiosError, function filter(obj) {
      return obj !== Error.prototype;
    }, (prop) => {
      return prop !== "isAxiosError";
    });
    const msg = error2 && error2.message ? error2.message : "Error";
    const errCode = code == null && error2 ? error2.code : code;
    AxiosError.call(axiosError, msg, errCode, config, request, response);
    if (error2 && axiosError.cause == null) {
      Object.defineProperty(axiosError, "cause", { value: error2, configurable: true });
    }
    axiosError.name = error2 && error2.name || "Error";
    customProps && Object.assign(axiosError, customProps);
    return axiosError;
  };
  var httpAdapter = null;
  function isVisitable(thing) {
    return utils$12.isPlainObject(thing) || utils$12.isArray(thing);
  }
  function removeBrackets(key2) {
    return utils$12.endsWith(key2, "[]") ? key2.slice(0, -2) : key2;
  }
  function renderKey(path, key2, dots) {
    if (!path) return key2;
    return path.concat(key2).map(function each(token, i) {
      token = removeBrackets(token);
      return !dots && i ? "[" + token + "]" : token;
    }).join(dots ? "." : "");
  }
  function isFlatArray(arr) {
    return utils$12.isArray(arr) && !arr.some(isVisitable);
  }
  const predicates = utils$12.toFlatObject(utils$12, {}, null, function filter(prop) {
    return /^is[A-Z]/.test(prop);
  });
  function toFormData(obj, formData, options) {
    if (!utils$12.isObject(obj)) {
      throw new TypeError("target must be an object");
    }
    formData = formData || new FormData();
    options = utils$12.toFlatObject(options, {
      metaTokens: true,
      dots: false,
      indexes: false
    }, false, function defined(option, source) {
      return !utils$12.isUndefined(source[option]);
    });
    const metaTokens = options.metaTokens;
    const visitor = options.visitor || defaultVisitor;
    const dots = options.dots;
    const indexes = options.indexes;
    const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
    const useBlob = _Blob && utils$12.isSpecCompliantForm(formData);
    if (!utils$12.isFunction(visitor)) {
      throw new TypeError("visitor must be a function");
    }
    function convertValue(value) {
      if (value === null) return "";
      if (utils$12.isDate(value)) {
        return value.toISOString();
      }
      if (utils$12.isBoolean(value)) {
        return value.toString();
      }
      if (!useBlob && utils$12.isBlob(value)) {
        throw new AxiosError("Blob is not supported. Use a Buffer instead.");
      }
      if (utils$12.isArrayBuffer(value) || utils$12.isTypedArray(value)) {
        return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
      }
      return value;
    }
    function defaultVisitor(value, key2, path) {
      let arr = value;
      if (value && !path && typeof value === "object") {
        if (utils$12.endsWith(key2, "{}")) {
          key2 = metaTokens ? key2 : key2.slice(0, -2);
          value = JSON.stringify(value);
        } else if (utils$12.isArray(value) && isFlatArray(value) || (utils$12.isFileList(value) || utils$12.endsWith(key2, "[]")) && (arr = utils$12.toArray(value))) {
          key2 = removeBrackets(key2);
          arr.forEach(function each(el, index) {
            !(utils$12.isUndefined(el) || el === null) && formData.append(
              // eslint-disable-next-line no-nested-ternary
              indexes === true ? renderKey([key2], index, dots) : indexes === null ? key2 : key2 + "[]",
              convertValue(el)
            );
          });
          return false;
        }
      }
      if (isVisitable(value)) {
        return true;
      }
      formData.append(renderKey(path, key2, dots), convertValue(value));
      return false;
    }
    const stack = [];
    const exposedHelpers = Object.assign(predicates, {
      defaultVisitor,
      convertValue,
      isVisitable
    });
    function build2(value, path) {
      if (utils$12.isUndefined(value)) return;
      if (stack.indexOf(value) !== -1) {
        throw Error("Circular reference detected in " + path.join("."));
      }
      stack.push(value);
      utils$12.forEach(value, function each(el, key2) {
        const result = !(utils$12.isUndefined(el) || el === null) && visitor.call(
          formData,
          el,
          utils$12.isString(key2) ? key2.trim() : key2,
          path,
          exposedHelpers
        );
        if (result === true) {
          build2(el, path ? path.concat(key2) : [key2]);
        }
      });
      stack.pop();
    }
    if (!utils$12.isObject(obj)) {
      throw new TypeError("data must be an object");
    }
    build2(obj);
    return formData;
  }
  function encode$1(str) {
    const charMap = {
      "!": "%21",
      "'": "%27",
      "(": "%28",
      ")": "%29",
      "~": "%7E",
      "%20": "+",
      "%00": "\0"
    };
    return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
      return charMap[match];
    });
  }
  function AxiosURLSearchParams(params, options) {
    this._pairs = [];
    params && toFormData(params, this, options);
  }
  const prototype = AxiosURLSearchParams.prototype;
  prototype.append = function append(name, value) {
    this._pairs.push([name, value]);
  };
  prototype.toString = function toString2(encoder) {
    const _encode = encoder ? function(value) {
      return encoder.call(this, value, encode$1);
    } : encode$1;
    return this._pairs.map(function each(pair) {
      return _encode(pair[0]) + "=" + _encode(pair[1]);
    }, "").join("&");
  };
  function encode(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+");
  }
  function buildURL(url, params, options) {
    if (!params) {
      return url;
    }
    const _encode = options && options.encode || encode;
    if (utils$12.isFunction(options)) {
      options = {
        serialize: options
      };
    }
    const serializeFn = options && options.serialize;
    let serializedParams;
    if (serializeFn) {
      serializedParams = serializeFn(params, options);
    } else {
      serializedParams = utils$12.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
    }
    if (serializedParams) {
      const hashmarkIndex = url.indexOf("#");
      if (hashmarkIndex !== -1) {
        url = url.slice(0, hashmarkIndex);
      }
      url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url;
  }
  class InterceptorManager {
    constructor() {
      this.handlers = [];
    }
    /**
     * Add a new interceptor to the stack
     *
     * @param {Function} fulfilled The function to handle `then` for a `Promise`
     * @param {Function} rejected The function to handle `reject` for a `Promise`
     *
     * @return {Number} An ID used to remove interceptor later
     */
    use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    }
    /**
     * Remove an interceptor from the stack
     *
     * @param {Number} id The ID that was returned by `use`
     *
     * @returns {void}
     */
    eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    }
    /**
     * Clear all interceptors from the stack
     *
     * @returns {void}
     */
    clear() {
      if (this.handlers) {
        this.handlers = [];
      }
    }
    /**
     * Iterate over all the registered interceptors
     *
     * This method is particularly useful for skipping over any
     * interceptors that may have become `null` calling `eject`.
     *
     * @param {Function} fn The function to call for each interceptor
     *
     * @returns {void}
     */
    forEach(fn) {
      utils$12.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    }
  }
  var InterceptorManager$1 = InterceptorManager;
  var transitionalDefaults = {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  };
  var URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
  var FormData$1 = typeof FormData !== "undefined" ? FormData : null;
  var Blob$1 = typeof Blob !== "undefined" ? Blob : null;
  var platform$1 = {
    isBrowser: true,
    classes: {
      URLSearchParams: URLSearchParams$1,
      FormData: FormData$1,
      Blob: Blob$1
    },
    protocols: ["http", "https", "file", "blob", "url", "data"]
  };
  const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
  const _navigator = typeof navigator === "object" && navigator || void 0;
  const hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
  const hasStandardBrowserWebWorkerEnv = (() => {
    return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
  })();
  const origin = hasBrowserEnv && window.location.href || "http://localhost";
  var utils2 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    hasBrowserEnv,
    hasStandardBrowserWebWorkerEnv,
    hasStandardBrowserEnv,
    navigator: _navigator,
    origin
  });
  var platform = {
    ...utils2,
    ...platform$1
  };
  function toURLEncodedForm(data, options) {
    return toFormData(data, new platform.classes.URLSearchParams(), {
      visitor: function(value, key2, path, helpers) {
        if (platform.isNode && utils$12.isBuffer(value)) {
          this.append(key2, value.toString("base64"));
          return false;
        }
        return helpers.defaultVisitor.apply(this, arguments);
      },
      ...options
    });
  }
  function parsePropPath(name) {
    return utils$12.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
      return match[0] === "[]" ? "" : match[1] || match[0];
    });
  }
  function arrayToObject(arr) {
    const obj = {};
    const keys = Object.keys(arr);
    let i;
    const len = keys.length;
    let key2;
    for (i = 0; i < len; i++) {
      key2 = keys[i];
      obj[key2] = arr[key2];
    }
    return obj;
  }
  function formDataToJSON(formData) {
    function buildPath(path, value, target, index) {
      let name = path[index++];
      if (name === "__proto__") return true;
      const isNumericKey = Number.isFinite(+name);
      const isLast = index >= path.length;
      name = !name && utils$12.isArray(target) ? target.length : name;
      if (isLast) {
        if (utils$12.hasOwnProp(target, name)) {
          target[name] = [target[name], value];
        } else {
          target[name] = value;
        }
        return !isNumericKey;
      }
      if (!target[name] || !utils$12.isObject(target[name])) {
        target[name] = [];
      }
      const result = buildPath(path, value, target[name], index);
      if (result && utils$12.isArray(target[name])) {
        target[name] = arrayToObject(target[name]);
      }
      return !isNumericKey;
    }
    if (utils$12.isFormData(formData) && utils$12.isFunction(formData.entries)) {
      const obj = {};
      utils$12.forEachEntry(formData, (name, value) => {
        buildPath(parsePropPath(name), value, obj, 0);
      });
      return obj;
    }
    return null;
  }
  function stringifySafely(rawValue, parser2, encoder) {
    if (utils$12.isString(rawValue)) {
      try {
        (parser2 || JSON.parse)(rawValue);
        return utils$12.trim(rawValue);
      } catch (e) {
        if (e.name !== "SyntaxError") {
          throw e;
        }
      }
    }
    return (encoder || JSON.stringify)(rawValue);
  }
  const defaults = {
    transitional: transitionalDefaults,
    adapter: ["xhr", "http", "fetch"],
    transformRequest: [function transformRequest(data, headers) {
      const contentType = headers.getContentType() || "";
      const hasJSONContentType = contentType.indexOf("application/json") > -1;
      const isObjectPayload = utils$12.isObject(data);
      if (isObjectPayload && utils$12.isHTMLForm(data)) {
        data = new FormData(data);
      }
      const isFormData2 = utils$12.isFormData(data);
      if (isFormData2) {
        return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
      }
      if (utils$12.isArrayBuffer(data) || utils$12.isBuffer(data) || utils$12.isStream(data) || utils$12.isFile(data) || utils$12.isBlob(data) || utils$12.isReadableStream(data)) {
        return data;
      }
      if (utils$12.isArrayBufferView(data)) {
        return data.buffer;
      }
      if (utils$12.isURLSearchParams(data)) {
        headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
        return data.toString();
      }
      let isFileList2;
      if (isObjectPayload) {
        if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
          return toURLEncodedForm(data, this.formSerializer).toString();
        }
        if ((isFileList2 = utils$12.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
          const _FormData = this.env && this.env.FormData;
          return toFormData(
            isFileList2 ? { "files[]": data } : data,
            _FormData && new _FormData(),
            this.formSerializer
          );
        }
      }
      if (isObjectPayload || hasJSONContentType) {
        headers.setContentType("application/json", false);
        return stringifySafely(data);
      }
      return data;
    }],
    transformResponse: [function transformResponse(data) {
      const transitional = this.transitional || defaults.transitional;
      const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
      const JSONRequested = this.responseType === "json";
      if (utils$12.isResponse(data) || utils$12.isReadableStream(data)) {
        return data;
      }
      if (data && utils$12.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
        const silentJSONParsing = transitional && transitional.silentJSONParsing;
        const strictJSONParsing = !silentJSONParsing && JSONRequested;
        try {
          return JSON.parse(data, this.parseReviver);
        } catch (e) {
          if (strictJSONParsing) {
            if (e.name === "SyntaxError") {
              throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
            }
            throw e;
          }
        }
      }
      return data;
    }],
    /**
     * A timeout in milliseconds to abort a request. If set to 0 (default) a
     * timeout is not created.
     */
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
      FormData: platform.classes.FormData,
      Blob: platform.classes.Blob
    },
    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    },
    headers: {
      common: {
        "Accept": "application/json, text/plain, */*",
        "Content-Type": void 0
      }
    }
  };
  utils$12.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
    defaults.headers[method] = {};
  });
  var defaults$1 = defaults;
  const ignoreDuplicateOf = utils$12.toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ]);
  var parseHeaders2 = (rawHeaders) => {
    const parsed = {};
    let key2;
    let val;
    let i;
    rawHeaders && rawHeaders.split("\n").forEach(function parser2(line) {
      i = line.indexOf(":");
      key2 = line.substring(0, i).trim().toLowerCase();
      val = line.substring(i + 1).trim();
      if (!key2 || parsed[key2] && ignoreDuplicateOf[key2]) {
        return;
      }
      if (key2 === "set-cookie") {
        if (parsed[key2]) {
          parsed[key2].push(val);
        } else {
          parsed[key2] = [val];
        }
      } else {
        parsed[key2] = parsed[key2] ? parsed[key2] + ", " + val : val;
      }
    });
    return parsed;
  };
  const $internals = Symbol("internals");
  function normalizeHeader(header) {
    return header && String(header).trim().toLowerCase();
  }
  function normalizeValue2(value) {
    if (value === false || value == null) {
      return value;
    }
    return utils$12.isArray(value) ? value.map(normalizeValue2) : String(value);
  }
  function parseTokens(str) {
    const tokens = /* @__PURE__ */ Object.create(null);
    const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let match;
    while (match = tokensRE.exec(str)) {
      tokens[match[1]] = match[2];
    }
    return tokens;
  }
  const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
  function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
    if (utils$12.isFunction(filter)) {
      return filter.call(this, value, header);
    }
    if (isHeaderNameFilter) {
      value = header;
    }
    if (!utils$12.isString(value)) return;
    if (utils$12.isString(filter)) {
      return value.indexOf(filter) !== -1;
    }
    if (utils$12.isRegExp(filter)) {
      return filter.test(value);
    }
  }
  function formatHeader(header) {
    return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
      return char.toUpperCase() + str;
    });
  }
  function buildAccessors(obj, header) {
    const accessorName = utils$12.toCamelCase(" " + header);
    ["get", "set", "has"].forEach((methodName) => {
      Object.defineProperty(obj, methodName + accessorName, {
        value: function(arg1, arg2, arg3) {
          return this[methodName].call(this, header, arg1, arg2, arg3);
        },
        configurable: true
      });
    });
  }
  class AxiosHeaders {
    constructor(headers) {
      headers && this.set(headers);
    }
    set(header, valueOrRewrite, rewrite) {
      const self2 = this;
      function setHeader(_value, _header, _rewrite) {
        const lHeader = normalizeHeader(_header);
        if (!lHeader) {
          throw new Error("header name must be a non-empty string");
        }
        const key2 = utils$12.findKey(self2, lHeader);
        if (!key2 || self2[key2] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key2] !== false) {
          self2[key2 || _header] = normalizeValue2(_value);
        }
      }
      const setHeaders = (headers, _rewrite) => utils$12.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
      if (utils$12.isPlainObject(header) || header instanceof this.constructor) {
        setHeaders(header, valueOrRewrite);
      } else if (utils$12.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
        setHeaders(parseHeaders2(header), valueOrRewrite);
      } else if (utils$12.isObject(header) && utils$12.isIterable(header)) {
        let obj = {}, dest, key2;
        for (const entry of header) {
          if (!utils$12.isArray(entry)) {
            throw TypeError("Object iterator must return a key-value pair");
          }
          obj[key2 = entry[0]] = (dest = obj[key2]) ? utils$12.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
        }
        setHeaders(obj, valueOrRewrite);
      } else {
        header != null && setHeader(valueOrRewrite, header, rewrite);
      }
      return this;
    }
    get(header, parser2) {
      header = normalizeHeader(header);
      if (header) {
        const key2 = utils$12.findKey(this, header);
        if (key2) {
          const value = this[key2];
          if (!parser2) {
            return value;
          }
          if (parser2 === true) {
            return parseTokens(value);
          }
          if (utils$12.isFunction(parser2)) {
            return parser2.call(this, value, key2);
          }
          if (utils$12.isRegExp(parser2)) {
            return parser2.exec(value);
          }
          throw new TypeError("parser must be boolean|regexp|function");
        }
      }
    }
    has(header, matcher) {
      header = normalizeHeader(header);
      if (header) {
        const key2 = utils$12.findKey(this, header);
        return !!(key2 && this[key2] !== void 0 && (!matcher || matchHeaderValue(this, this[key2], key2, matcher)));
      }
      return false;
    }
    delete(header, matcher) {
      const self2 = this;
      let deleted = false;
      function deleteHeader(_header) {
        _header = normalizeHeader(_header);
        if (_header) {
          const key2 = utils$12.findKey(self2, _header);
          if (key2 && (!matcher || matchHeaderValue(self2, self2[key2], key2, matcher))) {
            delete self2[key2];
            deleted = true;
          }
        }
      }
      if (utils$12.isArray(header)) {
        header.forEach(deleteHeader);
      } else {
        deleteHeader(header);
      }
      return deleted;
    }
    clear(matcher) {
      const keys = Object.keys(this);
      let i = keys.length;
      let deleted = false;
      while (i--) {
        const key2 = keys[i];
        if (!matcher || matchHeaderValue(this, this[key2], key2, matcher, true)) {
          delete this[key2];
          deleted = true;
        }
      }
      return deleted;
    }
    normalize(format) {
      const self2 = this;
      const headers = {};
      utils$12.forEach(this, (value, header) => {
        const key2 = utils$12.findKey(headers, header);
        if (key2) {
          self2[key2] = normalizeValue2(value);
          delete self2[header];
          return;
        }
        const normalized = format ? formatHeader(header) : String(header).trim();
        if (normalized !== header) {
          delete self2[header];
        }
        self2[normalized] = normalizeValue2(value);
        headers[normalized] = true;
      });
      return this;
    }
    concat(...targets) {
      return this.constructor.concat(this, ...targets);
    }
    toJSON(asStrings) {
      const obj = /* @__PURE__ */ Object.create(null);
      utils$12.forEach(this, (value, header) => {
        value != null && value !== false && (obj[header] = asStrings && utils$12.isArray(value) ? value.join(", ") : value);
      });
      return obj;
    }
    [Symbol.iterator]() {
      return Object.entries(this.toJSON())[Symbol.iterator]();
    }
    toString() {
      return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
    }
    getSetCookie() {
      return this.get("set-cookie") || [];
    }
    get [Symbol.toStringTag]() {
      return "AxiosHeaders";
    }
    static from(thing) {
      return thing instanceof this ? thing : new this(thing);
    }
    static concat(first, ...targets) {
      const computed = new this(first);
      targets.forEach((target) => computed.set(target));
      return computed;
    }
    static accessor(header) {
      const internals = this[$internals] = this[$internals] = {
        accessors: {}
      };
      const accessors = internals.accessors;
      const prototype2 = this.prototype;
      function defineAccessor(_header) {
        const lHeader = normalizeHeader(_header);
        if (!accessors[lHeader]) {
          buildAccessors(prototype2, _header);
          accessors[lHeader] = true;
        }
      }
      utils$12.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
      return this;
    }
  }
  AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
  utils$12.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key2) => {
    let mapped = key2[0].toUpperCase() + key2.slice(1);
    return {
      get: () => value,
      set(headerValue) {
        this[mapped] = headerValue;
      }
    };
  });
  utils$12.freezeMethods(AxiosHeaders);
  var AxiosHeaders$1 = AxiosHeaders;
  function transformData(fns, response) {
    const config = this || defaults$1;
    const context = response || config;
    const headers = AxiosHeaders$1.from(context.headers);
    let data = context.data;
    utils$12.forEach(fns, function transform(fn) {
      data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
    });
    headers.normalize();
    return data;
  }
  function isCancel(value) {
    return !!(value && value.__CANCEL__);
  }
  function CanceledError(message, config, request) {
    AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request);
    this.name = "CanceledError";
  }
  utils$12.inherits(CanceledError, AxiosError, {
    __CANCEL__: true
  });
  function settle(resolve, reject, response) {
    const validateStatus = response.config.validateStatus;
    if (!response.status || !validateStatus || validateStatus(response.status)) {
      resolve(response);
    } else {
      reject(new AxiosError(
        "Request failed with status code " + response.status,
        [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
        response.config,
        response.request,
        response
      ));
    }
  }
  function parseProtocol(url) {
    const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
    return match && match[1] || "";
  }
  function speedometer(samplesCount, min) {
    samplesCount = samplesCount || 10;
    const bytes = new Array(samplesCount);
    const timestamps = new Array(samplesCount);
    let head = 0;
    let tail = 0;
    let firstSampleTS;
    min = min !== void 0 ? min : 1e3;
    return function push(chunkLength) {
      const now = Date.now();
      const startedAt = timestamps[tail];
      if (!firstSampleTS) {
        firstSampleTS = now;
      }
      bytes[head] = chunkLength;
      timestamps[head] = now;
      let i = tail;
      let bytesCount = 0;
      while (i !== head) {
        bytesCount += bytes[i++];
        i = i % samplesCount;
      }
      head = (head + 1) % samplesCount;
      if (head === tail) {
        tail = (tail + 1) % samplesCount;
      }
      if (now - firstSampleTS < min) {
        return;
      }
      const passed = startedAt && now - startedAt;
      return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
    };
  }
  function throttle(fn, freq) {
    let timestamp = 0;
    let threshold = 1e3 / freq;
    let lastArgs;
    let timer;
    const invoke = (args, now = Date.now()) => {
      timestamp = now;
      lastArgs = null;
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      fn(...args);
    };
    const throttled = (...args) => {
      const now = Date.now();
      const passed = now - timestamp;
      if (passed >= threshold) {
        invoke(args, now);
      } else {
        lastArgs = args;
        if (!timer) {
          timer = setTimeout(() => {
            timer = null;
            invoke(lastArgs);
          }, threshold - passed);
        }
      }
    };
    const flush = () => lastArgs && invoke(lastArgs);
    return [throttled, flush];
  }
  const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
    let bytesNotified = 0;
    const _speedometer = speedometer(50, 250);
    return throttle((e) => {
      const loaded = e.loaded;
      const total = e.lengthComputable ? e.total : void 0;
      const progressBytes = loaded - bytesNotified;
      const rate = _speedometer(progressBytes);
      const inRange = loaded <= total;
      bytesNotified = loaded;
      const data = {
        loaded,
        total,
        progress: total ? loaded / total : void 0,
        bytes: progressBytes,
        rate: rate ? rate : void 0,
        estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
        event: e,
        lengthComputable: total != null,
        [isDownloadStream ? "download" : "upload"]: true
      };
      listener(data);
    }, freq);
  };
  const progressEventDecorator = (total, throttled) => {
    const lengthComputable = total != null;
    return [(loaded) => throttled[0]({
      lengthComputable,
      total,
      loaded
    }), throttled[1]];
  };
  const asyncDecorator = (fn) => (...args) => utils$12.asap(() => fn(...args));
  var isURLSameOrigin = platform.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url) => {
    url = new URL(url, platform.origin);
    return origin2.protocol === url.protocol && origin2.host === url.host && (isMSIE || origin2.port === url.port);
  })(
    new URL(platform.origin),
    platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)
  ) : () => true;
  var cookies = platform.hasStandardBrowserEnv ? (
    // Standard browser envs support document.cookie
    {
      write(name, value, expires, path, domain, secure, sameSite) {
        if (typeof document === "undefined") return;
        const cookie = [`${name}=${encodeURIComponent(value)}`];
        if (utils$12.isNumber(expires)) {
          cookie.push(`expires=${new Date(expires).toUTCString()}`);
        }
        if (utils$12.isString(path)) {
          cookie.push(`path=${path}`);
        }
        if (utils$12.isString(domain)) {
          cookie.push(`domain=${domain}`);
        }
        if (secure === true) {
          cookie.push("secure");
        }
        if (utils$12.isString(sameSite)) {
          cookie.push(`SameSite=${sameSite}`);
        }
        document.cookie = cookie.join("; ");
      },
      read(name) {
        if (typeof document === "undefined") return null;
        const match = document.cookie.match(new RegExp("(?:^|; )" + name + "=([^;]*)"));
        return match ? decodeURIComponent(match[1]) : null;
      },
      remove(name) {
        this.write(name, "", Date.now() - 864e5, "/");
      }
    }
  ) : (
    // Non-standard browser env (web workers, react-native) lack needed support.
    {
      write() {
      },
      read() {
        return null;
      },
      remove() {
      }
    }
  );
  function isAbsoluteURL(url) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
  }
  function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
  }
  function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
    let isRelativeUrl = !isAbsoluteURL(requestedURL);
    if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
      return combineURLs(baseURL, requestedURL);
    }
    return requestedURL;
  }
  const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;
  function mergeConfig(config1, config2) {
    config2 = config2 || {};
    const config = {};
    function getMergedValue(target, source, prop, caseless) {
      if (utils$12.isPlainObject(target) && utils$12.isPlainObject(source)) {
        return utils$12.merge.call({ caseless }, target, source);
      } else if (utils$12.isPlainObject(source)) {
        return utils$12.merge({}, source);
      } else if (utils$12.isArray(source)) {
        return source.slice();
      }
      return source;
    }
    function mergeDeepProperties(a, b, prop, caseless) {
      if (!utils$12.isUndefined(b)) {
        return getMergedValue(a, b, prop, caseless);
      } else if (!utils$12.isUndefined(a)) {
        return getMergedValue(void 0, a, prop, caseless);
      }
    }
    function valueFromConfig2(a, b) {
      if (!utils$12.isUndefined(b)) {
        return getMergedValue(void 0, b);
      }
    }
    function defaultToConfig2(a, b) {
      if (!utils$12.isUndefined(b)) {
        return getMergedValue(void 0, b);
      } else if (!utils$12.isUndefined(a)) {
        return getMergedValue(void 0, a);
      }
    }
    function mergeDirectKeys(a, b, prop) {
      if (prop in config2) {
        return getMergedValue(a, b);
      } else if (prop in config1) {
        return getMergedValue(void 0, a);
      }
    }
    const mergeMap = {
      url: valueFromConfig2,
      method: valueFromConfig2,
      data: valueFromConfig2,
      baseURL: defaultToConfig2,
      transformRequest: defaultToConfig2,
      transformResponse: defaultToConfig2,
      paramsSerializer: defaultToConfig2,
      timeout: defaultToConfig2,
      timeoutMessage: defaultToConfig2,
      withCredentials: defaultToConfig2,
      withXSRFToken: defaultToConfig2,
      adapter: defaultToConfig2,
      responseType: defaultToConfig2,
      xsrfCookieName: defaultToConfig2,
      xsrfHeaderName: defaultToConfig2,
      onUploadProgress: defaultToConfig2,
      onDownloadProgress: defaultToConfig2,
      decompress: defaultToConfig2,
      maxContentLength: defaultToConfig2,
      maxBodyLength: defaultToConfig2,
      beforeRedirect: defaultToConfig2,
      transport: defaultToConfig2,
      httpAgent: defaultToConfig2,
      httpsAgent: defaultToConfig2,
      cancelToken: defaultToConfig2,
      socketPath: defaultToConfig2,
      responseEncoding: defaultToConfig2,
      validateStatus: mergeDirectKeys,
      headers: (a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
    };
    utils$12.forEach(Object.keys({ ...config1, ...config2 }), function computeConfigValue(prop) {
      const merge2 = mergeMap[prop] || mergeDeepProperties;
      const configValue = merge2(config1[prop], config2[prop], prop);
      utils$12.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
    });
    return config;
  }
  var resolveConfig = (config) => {
    const newConfig = mergeConfig({}, config);
    let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
    newConfig.headers = headers = AxiosHeaders$1.from(headers);
    newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);
    if (auth) {
      headers.set(
        "Authorization",
        "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
      );
    }
    if (utils$12.isFormData(data)) {
      if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
        headers.setContentType(void 0);
      } else if (utils$12.isFunction(data.getHeaders)) {
        const formHeaders = data.getHeaders();
        const allowedHeaders = ["content-type", "content-length"];
        Object.entries(formHeaders).forEach(([key2, val]) => {
          if (allowedHeaders.includes(key2.toLowerCase())) {
            headers.set(key2, val);
          }
        });
      }
    }
    if (platform.hasStandardBrowserEnv) {
      withXSRFToken && utils$12.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
      if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
        const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
        if (xsrfValue) {
          headers.set(xsrfHeaderName, xsrfValue);
        }
      }
    }
    return newConfig;
  };
  const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
  var xhrAdapter = isXHRAdapterSupported && function(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
      const _config = resolveConfig(config);
      let requestData = _config.data;
      const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
      let { responseType, onUploadProgress, onDownloadProgress } = _config;
      let onCanceled;
      let uploadThrottled, downloadThrottled;
      let flushUpload, flushDownload;
      function done() {
        flushUpload && flushUpload();
        flushDownload && flushDownload();
        _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
        _config.signal && _config.signal.removeEventListener("abort", onCanceled);
      }
      let request = new XMLHttpRequest();
      request.open(_config.method.toUpperCase(), _config.url, true);
      request.timeout = _config.timeout;
      function onloadend() {
        if (!request) {
          return;
        }
        const responseHeaders = AxiosHeaders$1.from(
          "getAllResponseHeaders" in request && request.getAllResponseHeaders()
        );
        const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
        const response = {
          data: responseData,
          status: request.status,
          statusText: request.statusText,
          headers: responseHeaders,
          config,
          request
        };
        settle(function _resolve(value) {
          resolve(value);
          done();
        }, function _reject(err) {
          reject(err);
          done();
        }, response);
        request = null;
      }
      if ("onloadend" in request) {
        request.onloadend = onloadend;
      } else {
        request.onreadystatechange = function handleLoad() {
          if (!request || request.readyState !== 4) {
            return;
          }
          if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
            return;
          }
          setTimeout(onloadend);
        };
      }
      request.onabort = function handleAbort() {
        if (!request) {
          return;
        }
        reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
        request = null;
      };
      request.onerror = function handleError(event) {
        const msg = event && event.message ? event.message : "Network Error";
        const err = new AxiosError(msg, AxiosError.ERR_NETWORK, config, request);
        err.event = event || null;
        reject(err);
        request = null;
      };
      request.ontimeout = function handleTimeout() {
        let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
        const transitional = _config.transitional || transitionalDefaults;
        if (_config.timeoutErrorMessage) {
          timeoutErrorMessage = _config.timeoutErrorMessage;
        }
        reject(new AxiosError(
          timeoutErrorMessage,
          transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
          config,
          request
        ));
        request = null;
      };
      requestData === void 0 && requestHeaders.setContentType(null);
      if ("setRequestHeader" in request) {
        utils$12.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key2) {
          request.setRequestHeader(key2, val);
        });
      }
      if (!utils$12.isUndefined(_config.withCredentials)) {
        request.withCredentials = !!_config.withCredentials;
      }
      if (responseType && responseType !== "json") {
        request.responseType = _config.responseType;
      }
      if (onDownloadProgress) {
        [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
        request.addEventListener("progress", downloadThrottled);
      }
      if (onUploadProgress && request.upload) {
        [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
        request.upload.addEventListener("progress", uploadThrottled);
        request.upload.addEventListener("loadend", flushUpload);
      }
      if (_config.cancelToken || _config.signal) {
        onCanceled = (cancel) => {
          if (!request) {
            return;
          }
          reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
          request.abort();
          request = null;
        };
        _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
        if (_config.signal) {
          _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
        }
      }
      const protocol = parseProtocol(_config.url);
      if (protocol && platform.protocols.indexOf(protocol) === -1) {
        reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
        return;
      }
      request.send(requestData || null);
    });
  };
  const composeSignals = (signals, timeout) => {
    const { length } = signals = signals ? signals.filter(Boolean) : [];
    if (timeout || length) {
      let controller = new AbortController();
      let aborted;
      const onabort = function(reason) {
        if (!aborted) {
          aborted = true;
          unsubscribe();
          const err = reason instanceof Error ? reason : this.reason;
          controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));
        }
      };
      let timer = timeout && setTimeout(() => {
        timer = null;
        onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT));
      }, timeout);
      const unsubscribe = () => {
        if (signals) {
          timer && clearTimeout(timer);
          timer = null;
          signals.forEach((signal2) => {
            signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
          });
          signals = null;
        }
      };
      signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
      const { signal } = controller;
      signal.unsubscribe = () => utils$12.asap(unsubscribe);
      return signal;
    }
  };
  var composeSignals$1 = composeSignals;
  const streamChunk = function* (chunk, chunkSize) {
    let len = chunk.byteLength;
    if (len < chunkSize) {
      yield chunk;
      return;
    }
    let pos = 0;
    let end2;
    while (pos < len) {
      end2 = pos + chunkSize;
      yield chunk.slice(pos, end2);
      pos = end2;
    }
  };
  const readBytes = async function* (iterable, chunkSize) {
    for await (const chunk of readStream(iterable)) {
      yield* streamChunk(chunk, chunkSize);
    }
  };
  const readStream = async function* (stream) {
    if (stream[Symbol.asyncIterator]) {
      yield* stream;
      return;
    }
    const reader2 = stream.getReader();
    try {
      for (; ; ) {
        const { done, value } = await reader2.read();
        if (done) {
          break;
        }
        yield value;
      }
    } finally {
      await reader2.cancel();
    }
  };
  const trackStream = (stream, chunkSize, onProgress, onFinish) => {
    const iterator2 = readBytes(stream, chunkSize);
    let bytes = 0;
    let done;
    let _onFinish = (e) => {
      if (!done) {
        done = true;
        onFinish && onFinish(e);
      }
    };
    return new ReadableStream({
      async pull(controller) {
        try {
          const { done: done2, value } = await iterator2.next();
          if (done2) {
            _onFinish();
            controller.close();
            return;
          }
          let len = value.byteLength;
          if (onProgress) {
            let loadedBytes = bytes += len;
            onProgress(loadedBytes);
          }
          controller.enqueue(new Uint8Array(value));
        } catch (err) {
          _onFinish(err);
          throw err;
        }
      },
      cancel(reason) {
        _onFinish(reason);
        return iterator2.return();
      }
    }, {
      highWaterMark: 2
    });
  };
  const DEFAULT_CHUNK_SIZE = 64 * 1024;
  const { isFunction } = utils$12;
  const globalFetchAPI = (({ Request: Request2, Response: Response2 }) => ({
    Request: Request2,
    Response: Response2
  }))(utils$12.global);
  const {
    ReadableStream: ReadableStream$1,
    TextEncoder: TextEncoder2
  } = utils$12.global;
  const test = (fn, ...args) => {
    try {
      return !!fn(...args);
    } catch (e) {
      return false;
    }
  };
  const factory = (env) => {
    env = utils$12.merge.call({
      skipUndefined: true
    }, globalFetchAPI, env);
    const { fetch: envFetch, Request: Request2, Response: Response2 } = env;
    const isFetchSupported = envFetch ? isFunction(envFetch) : typeof fetch === "function";
    const isRequestSupported = isFunction(Request2);
    const isResponseSupported = isFunction(Response2);
    if (!isFetchSupported) {
      return false;
    }
    const isReadableStreamSupported = isFetchSupported && isFunction(ReadableStream$1);
    const encodeText = isFetchSupported && (typeof TextEncoder2 === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder2()) : async (str) => new Uint8Array(await new Request2(str).arrayBuffer()));
    const supportsRequestStream = isRequestSupported && isReadableStreamSupported && test(() => {
      let duplexAccessed = false;
      const hasContentType = new Request2(platform.origin, {
        body: new ReadableStream$1(),
        method: "POST",
        get duplex() {
          duplexAccessed = true;
          return "half";
        }
      }).headers.has("Content-Type");
      return duplexAccessed && !hasContentType;
    });
    const supportsResponseStream = isResponseSupported && isReadableStreamSupported && test(() => utils$12.isReadableStream(new Response2("").body));
    const resolvers = {
      stream: supportsResponseStream && ((res) => res.body)
    };
    isFetchSupported && (() => {
      ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
        !resolvers[type] && (resolvers[type] = (res, config) => {
          let method = res && res[type];
          if (method) {
            return method.call(res);
          }
          throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);
        });
      });
    })();
    const getBodyLength = async (body) => {
      if (body == null) {
        return 0;
      }
      if (utils$12.isBlob(body)) {
        return body.size;
      }
      if (utils$12.isSpecCompliantForm(body)) {
        const _request = new Request2(platform.origin, {
          method: "POST",
          body
        });
        return (await _request.arrayBuffer()).byteLength;
      }
      if (utils$12.isArrayBufferView(body) || utils$12.isArrayBuffer(body)) {
        return body.byteLength;
      }
      if (utils$12.isURLSearchParams(body)) {
        body = body + "";
      }
      if (utils$12.isString(body)) {
        return (await encodeText(body)).byteLength;
      }
    };
    const resolveBodyLength = async (headers, body) => {
      const length = utils$12.toFiniteNumber(headers.getContentLength());
      return length == null ? getBodyLength(body) : length;
    };
    return async (config) => {
      let {
        url,
        method,
        data,
        signal,
        cancelToken,
        timeout,
        onDownloadProgress,
        onUploadProgress,
        responseType,
        headers,
        withCredentials = "same-origin",
        fetchOptions
      } = resolveConfig(config);
      let _fetch = envFetch || fetch;
      responseType = responseType ? (responseType + "").toLowerCase() : "text";
      let composedSignal = composeSignals$1([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
      let request = null;
      const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
        composedSignal.unsubscribe();
      });
      let requestContentLength;
      try {
        if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
          let _request = new Request2(url, {
            method: "POST",
            body: data,
            duplex: "half"
          });
          let contentTypeHeader;
          if (utils$12.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
            headers.setContentType(contentTypeHeader);
          }
          if (_request.body) {
            const [onProgress, flush] = progressEventDecorator(
              requestContentLength,
              progressEventReducer(asyncDecorator(onUploadProgress))
            );
            data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
          }
        }
        if (!utils$12.isString(withCredentials)) {
          withCredentials = withCredentials ? "include" : "omit";
        }
        const isCredentialsSupported = isRequestSupported && "credentials" in Request2.prototype;
        const resolvedOptions = {
          ...fetchOptions,
          signal: composedSignal,
          method: method.toUpperCase(),
          headers: headers.normalize().toJSON(),
          body: data,
          duplex: "half",
          credentials: isCredentialsSupported ? withCredentials : void 0
        };
        request = isRequestSupported && new Request2(url, resolvedOptions);
        let response = await (isRequestSupported ? _fetch(request, fetchOptions) : _fetch(url, resolvedOptions));
        const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
        if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
          const options = {};
          ["status", "statusText", "headers"].forEach((prop) => {
            options[prop] = response[prop];
          });
          const responseContentLength = utils$12.toFiniteNumber(response.headers.get("content-length"));
          const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
            responseContentLength,
            progressEventReducer(asyncDecorator(onDownloadProgress), true)
          ) || [];
          response = new Response2(
            trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
              flush && flush();
              unsubscribe && unsubscribe();
            }),
            options
          );
        }
        responseType = responseType || "text";
        let responseData = await resolvers[utils$12.findKey(resolvers, responseType) || "text"](response, config);
        !isStreamResponse && unsubscribe && unsubscribe();
        return await new Promise((resolve, reject) => {
          settle(resolve, reject, {
            data: responseData,
            headers: AxiosHeaders$1.from(response.headers),
            status: response.status,
            statusText: response.statusText,
            config,
            request
          });
        });
      } catch (err) {
        unsubscribe && unsubscribe();
        if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
          throw Object.assign(
            new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request),
            {
              cause: err.cause || err
            }
          );
        }
        throw AxiosError.from(err, err && err.code, config, request);
      }
    };
  };
  const seedCache = /* @__PURE__ */ new Map();
  const getFetch = (config) => {
    let env = config && config.env || {};
    const { fetch: fetch2, Request: Request2, Response: Response2 } = env;
    const seeds = [
      Request2,
      Response2,
      fetch2
    ];
    let len = seeds.length, i = len, seed, target, map = seedCache;
    while (i--) {
      seed = seeds[i];
      target = map.get(seed);
      target === void 0 && map.set(seed, target = i ? /* @__PURE__ */ new Map() : factory(env));
      map = target;
    }
    return target;
  };
  getFetch();
  const knownAdapters = {
    http: httpAdapter,
    xhr: xhrAdapter,
    fetch: {
      get: getFetch
    }
  };
  utils$12.forEach(knownAdapters, (fn, value) => {
    if (fn) {
      try {
        Object.defineProperty(fn, "name", { value });
      } catch (e) {
      }
      Object.defineProperty(fn, "adapterName", { value });
    }
  });
  const renderReason = (reason) => `- ${reason}`;
  const isResolvedHandle = (adapter) => utils$12.isFunction(adapter) || adapter === null || adapter === false;
  function getAdapter(adapters2, config) {
    adapters2 = utils$12.isArray(adapters2) ? adapters2 : [adapters2];
    const { length } = adapters2;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters2[i];
      let id;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError(`Unknown adapter '${id}'`);
        }
      }
      if (adapter && (utils$12.isFunction(adapter) || (adapter = adapter.get(config)))) {
        break;
      }
      rejectedReasons[id || "#" + i] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError(
        `There is no suitable adapter to dispatch the request ` + s,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  }
  var adapters = {
    /**
     * Resolve an adapter from a list of adapter names or functions.
     * @type {Function}
     */
    getAdapter,
    /**
     * Exposes all known adapters
     * @type {Object<string, Function|Object>}
     */
    adapters: knownAdapters
  };
  function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
      config.cancelToken.throwIfRequested();
    }
    if (config.signal && config.signal.aborted) {
      throw new CanceledError(null, config);
    }
  }
  function dispatchRequest(config) {
    throwIfCancellationRequested(config);
    config.headers = AxiosHeaders$1.from(config.headers);
    config.data = transformData.call(
      config,
      config.transformRequest
    );
    if (["post", "put", "patch"].indexOf(config.method) !== -1) {
      config.headers.setContentType("application/x-www-form-urlencoded", false);
    }
    const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter, config);
    return adapter(config).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config);
      response.data = transformData.call(
        config,
        config.transformResponse,
        response
      );
      response.headers = AxiosHeaders$1.from(response.headers);
      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel(reason)) {
        throwIfCancellationRequested(config);
        if (reason && reason.response) {
          reason.response.data = transformData.call(
            config,
            config.transformResponse,
            reason.response
          );
          reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
        }
      }
      return Promise.reject(reason);
    });
  }
  const VERSION = "1.13.2";
  const validators$1 = {};
  ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
    validators$1[type] = function validator2(thing) {
      return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
    };
  });
  const deprecatedWarnings = {};
  validators$1.transitional = function transitional(validator2, version2, message) {
    function formatMessage(opt, desc) {
      return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
    }
    return (value, opt, opts) => {
      if (validator2 === false) {
        throw new AxiosError(
          formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
          AxiosError.ERR_DEPRECATED
        );
      }
      if (version2 && !deprecatedWarnings[opt]) {
        deprecatedWarnings[opt] = true;
        console.warn(
          formatMessage(
            opt,
            " has been deprecated since v" + version2 + " and will be removed in the near future"
          )
        );
      }
      return validator2 ? validator2(value, opt, opts) : true;
    };
  };
  validators$1.spelling = function spelling(correctSpelling) {
    return (value, opt) => {
      console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
      return true;
    };
  };
  function assertOptions(options, schema2, allowUnknown) {
    if (typeof options !== "object") {
      throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
    }
    const keys = Object.keys(options);
    let i = keys.length;
    while (i-- > 0) {
      const opt = keys[i];
      const validator2 = schema2[opt];
      if (validator2) {
        const value = options[opt];
        const result = value === void 0 || validator2(value, opt, options);
        if (result !== true) {
          throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
        }
        continue;
      }
      if (allowUnknown !== true) {
        throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
      }
    }
  }
  var validator = {
    assertOptions,
    validators: validators$1
  };
  const validators = validator.validators;
  class Axios {
    constructor(instanceConfig) {
      this.defaults = instanceConfig || {};
      this.interceptors = {
        request: new InterceptorManager$1(),
        response: new InterceptorManager$1()
      };
    }
    /**
     * Dispatch a request
     *
     * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
     * @param {?Object} config
     *
     * @returns {Promise} The Promise to be fulfilled
     */
    async request(configOrUrl, config) {
      try {
        return await this._request(configOrUrl, config);
      } catch (err) {
        if (err instanceof Error) {
          let dummy = {};
          Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
          const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
          try {
            if (!err.stack) {
              err.stack = stack;
            } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
              err.stack += "\n" + stack;
            }
          } catch (e) {
          }
        }
        throw err;
      }
    }
    _request(configOrUrl, config) {
      if (typeof configOrUrl === "string") {
        config = config || {};
        config.url = configOrUrl;
      } else {
        config = configOrUrl || {};
      }
      config = mergeConfig(this.defaults, config);
      const { transitional, paramsSerializer, headers } = config;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      if (paramsSerializer != null) {
        if (utils$12.isFunction(paramsSerializer)) {
          config.paramsSerializer = {
            serialize: paramsSerializer
          };
        } else {
          validator.assertOptions(paramsSerializer, {
            encode: validators.function,
            serialize: validators.function
          }, true);
        }
      }
      if (config.allowAbsoluteUrls !== void 0) ;
      else if (this.defaults.allowAbsoluteUrls !== void 0) {
        config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
      } else {
        config.allowAbsoluteUrls = true;
      }
      validator.assertOptions(config, {
        baseUrl: validators.spelling("baseURL"),
        withXsrfToken: validators.spelling("withXSRFToken")
      }, true);
      config.method = (config.method || this.defaults.method || "get").toLowerCase();
      let contextHeaders = headers && utils$12.merge(
        headers.common,
        headers[config.method]
      );
      headers && utils$12.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        (method) => {
          delete headers[method];
        }
      );
      config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
      const requestInterceptorChain = [];
      let synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      const responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      let promise;
      let i = 0;
      let len;
      if (!synchronousRequestInterceptors) {
        const chain = [dispatchRequest.bind(this), void 0];
        chain.unshift(...requestInterceptorChain);
        chain.push(...responseInterceptorChain);
        len = chain.length;
        promise = Promise.resolve(config);
        while (i < len) {
          promise = promise.then(chain[i++], chain[i++]);
        }
        return promise;
      }
      len = requestInterceptorChain.length;
      let newConfig = config;
      while (i < len) {
        const onFulfilled = requestInterceptorChain[i++];
        const onRejected = requestInterceptorChain[i++];
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error2) {
          onRejected.call(this, error2);
          break;
        }
      }
      try {
        promise = dispatchRequest.call(this, newConfig);
      } catch (error2) {
        return Promise.reject(error2);
      }
      i = 0;
      len = responseInterceptorChain.length;
      while (i < len) {
        promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
      }
      return promise;
    }
    getUri(config) {
      config = mergeConfig(this.defaults, config);
      const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
      return buildURL(fullPath, config.params, config.paramsSerializer);
    }
  }
  utils$12.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
    Axios.prototype[method] = function(url, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        url,
        data: (config || {}).data
      }));
    };
  });
  utils$12.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
    function generateHTTPMethod(isForm) {
      return function httpMethod(url, data, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          headers: isForm ? {
            "Content-Type": "multipart/form-data"
          } : {},
          url,
          data
        }));
      };
    }
    Axios.prototype[method] = generateHTTPMethod();
    Axios.prototype[method + "Form"] = generateHTTPMethod(true);
  });
  var Axios$1 = Axios;
  class CancelToken {
    constructor(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      let resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      const token = this;
      this.promise.then((cancel) => {
        if (!token._listeners) return;
        let i = token._listeners.length;
        while (i-- > 0) {
          token._listeners[i](cancel);
        }
        token._listeners = null;
      });
      this.promise.then = (onfulfilled) => {
        let _resolve;
        const promise = new Promise((resolve) => {
          token.subscribe(resolve);
          _resolve = resolve;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message, config, request) {
        if (token.reason) {
          return;
        }
        token.reason = new CanceledError(message, config, request);
        resolvePromise(token.reason);
      });
    }
    /**
     * Throws a `CanceledError` if cancellation has been requested.
     */
    throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    }
    /**
     * Subscribe to the cancel signal
     */
    subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    }
    /**
     * Unsubscribe from the cancel signal
     */
    unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      const index = this._listeners.indexOf(listener);
      if (index !== -1) {
        this._listeners.splice(index, 1);
      }
    }
    toAbortSignal() {
      const controller = new AbortController();
      const abort = (err) => {
        controller.abort(err);
      };
      this.subscribe(abort);
      controller.signal.unsubscribe = () => this.unsubscribe(abort);
      return controller.signal;
    }
    /**
     * Returns an object that contains a new `CancelToken` and a function that, when called,
     * cancels the `CancelToken`.
     */
    static source() {
      let cancel;
      const token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel
      };
    }
  }
  var CancelToken$1 = CancelToken;
  function spread(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  }
  function isAxiosError(payload) {
    return utils$12.isObject(payload) && payload.isAxiosError === true;
  }
  const HttpStatusCode = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511,
    WebServerIsDown: 521,
    ConnectionTimedOut: 522,
    OriginIsUnreachable: 523,
    TimeoutOccurred: 524,
    SslHandshakeFailed: 525,
    InvalidSslCertificate: 526
  };
  Object.entries(HttpStatusCode).forEach(([key2, value]) => {
    HttpStatusCode[value] = key2;
  });
  var HttpStatusCode$1 = HttpStatusCode;
  function createInstance(defaultConfig) {
    const context = new Axios$1(defaultConfig);
    const instance = bind(Axios$1.prototype.request, context);
    utils$12.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
    utils$12.extend(instance, context, null, { allOwnKeys: true });
    instance.create = function create(instanceConfig) {
      return createInstance(mergeConfig(defaultConfig, instanceConfig));
    };
    return instance;
  }
  const axios = createInstance(defaults$1);
  axios.Axios = Axios$1;
  axios.CanceledError = CanceledError;
  axios.CancelToken = CancelToken$1;
  axios.isCancel = isCancel;
  axios.VERSION = VERSION;
  axios.toFormData = toFormData;
  axios.AxiosError = AxiosError;
  axios.Cancel = axios.CanceledError;
  axios.all = function all(promises) {
    return Promise.all(promises);
  };
  axios.spread = spread;
  axios.isAxiosError = isAxiosError;
  axios.mergeConfig = mergeConfig;
  axios.AxiosHeaders = AxiosHeaders$1;
  axios.formToJSON = (thing) => formDataToJSON(utils$12.isHTMLForm(thing) ? new FormData(thing) : thing);
  axios.getAdapter = adapters.getAdapter;
  axios.HttpStatusCode = HttpStatusCode$1;
  axios.default = axios;
  axios_1$1 = axios;
  return axios_1$1;
}
const version$1 = "15.3.1";
const require$$4$1 = {
  version: version$1
};
var hasRequiredHttpApi;
function requireHttpApi() {
  if (hasRequiredHttpApi) return HttpApi;
  hasRequiredHttpApi = 1;
  var __importDefault = HttpApi && HttpApi.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(HttpApi, "__esModule", { value: true });
  HttpApi.HttpApi = void 0;
  const TonCache_1 = requireTonCache();
  const dataloader_1 = __importDefault(requireDataloader());
  const axios_12 = __importDefault(/* @__PURE__ */ requireAxios$1());
  const zod_1 = /* @__PURE__ */ requireZod();
  const version2 = require$$4$1.version;
  const blockIdExt = zod_1.z.object({
    "@type": zod_1.z.literal("ton.blockIdExt"),
    workchain: zod_1.z.number(),
    shard: zod_1.z.string(),
    seqno: zod_1.z.number(),
    root_hash: zod_1.z.string(),
    file_hash: zod_1.z.string()
  });
  const addressInformation = zod_1.z.object({
    balance: zod_1.z.union([zod_1.z.number(), zod_1.z.string()]),
    extra_currencies: zod_1.z.optional(zod_1.z.array(zod_1.z.object({
      "@type": zod_1.z.literal("extraCurrency"),
      id: zod_1.z.number(),
      amount: zod_1.z.string()
    }))),
    state: zod_1.z.union([zod_1.z.literal("active"), zod_1.z.literal("uninitialized"), zod_1.z.literal("frozen")]),
    data: zod_1.z.string(),
    code: zod_1.z.string(),
    last_transaction_id: zod_1.z.object({
      "@type": zod_1.z.literal("internal.transactionId"),
      lt: zod_1.z.string(),
      hash: zod_1.z.string()
    }),
    block_id: blockIdExt,
    sync_utime: zod_1.z.number()
  });
  const bocResponse = zod_1.z.object({
    "@type": zod_1.z.literal("ok")
  });
  const feeResponse = zod_1.z.object({
    "@type": zod_1.z.literal("query.fees"),
    source_fees: zod_1.z.object({
      "@type": zod_1.z.literal("fees"),
      in_fwd_fee: zod_1.z.number(),
      storage_fee: zod_1.z.number(),
      gas_fee: zod_1.z.number(),
      fwd_fee: zod_1.z.number()
    })
  });
  const callGetMethod = zod_1.z.object({
    gas_used: zod_1.z.number(),
    exit_code: zod_1.z.number(),
    stack: zod_1.z.array(zod_1.z.unknown())
  });
  const messageData = zod_1.z.union([
    zod_1.z.object({
      "@type": zod_1.z.literal("msg.dataRaw"),
      "body": zod_1.z.string()
    }),
    zod_1.z.object({
      "@type": zod_1.z.literal("msg.dataText"),
      "text": zod_1.z.string()
    }),
    zod_1.z.object({
      "@type": zod_1.z.literal("msg.dataDecryptedText"),
      "text": zod_1.z.string()
    }),
    zod_1.z.object({
      "@type": zod_1.z.literal("msg.dataEncryptedText"),
      "text": zod_1.z.string()
    })
  ]);
  const message = zod_1.z.object({
    source: zod_1.z.string(),
    destination: zod_1.z.string(),
    value: zod_1.z.string(),
    fwd_fee: zod_1.z.string(),
    ihr_fee: zod_1.z.string(),
    created_lt: zod_1.z.string(),
    body_hash: zod_1.z.string(),
    msg_data: messageData,
    message: zod_1.z.string().optional()
  });
  const transaction = zod_1.z.object({
    data: zod_1.z.string(),
    utime: zod_1.z.number(),
    transaction_id: zod_1.z.object({
      lt: zod_1.z.string(),
      hash: zod_1.z.string()
    }),
    fee: zod_1.z.string(),
    storage_fee: zod_1.z.string(),
    other_fee: zod_1.z.string(),
    in_msg: zod_1.z.union([zod_1.z.undefined(), message]),
    out_msgs: zod_1.z.array(message)
  });
  const getTransactions = zod_1.z.array(transaction);
  const getMasterchain = zod_1.z.object({
    state_root_hash: zod_1.z.string(),
    last: blockIdExt,
    init: blockIdExt
  });
  const getShards = zod_1.z.object({
    shards: zod_1.z.array(blockIdExt)
  });
  const blockShortTxt = zod_1.z.object({
    "@type": zod_1.z.literal("blocks.shortTxId"),
    mode: zod_1.z.number(),
    account: zod_1.z.string(),
    lt: zod_1.z.string(),
    hash: zod_1.z.string()
  });
  const getBlockTransactions = zod_1.z.object({
    id: blockIdExt,
    req_count: zod_1.z.number(),
    incomplete: zod_1.z.boolean(),
    transactions: zod_1.z.array(blockShortTxt)
  });
  class TypedCache {
    constructor(namespace, cache, codec, keyEncoder) {
      this.namespace = namespace;
      this.cache = cache;
      this.codec = codec;
      this.keyEncoder = keyEncoder;
    }
    async get(key2) {
      let ex = await this.cache.get(this.namespace, this.keyEncoder(key2));
      if (ex) {
        let decoded = this.codec.safeParse(JSON.parse(ex));
        if (decoded.success) {
          return decoded.data;
        }
      }
      return null;
    }
    async set(key2, value) {
      if (value !== null) {
        await this.cache.set(this.namespace, this.keyEncoder(key2), JSON.stringify(value));
      } else {
        await this.cache.set(this.namespace, this.keyEncoder(key2), null);
      }
    }
  }
  let HttpApi$1 = class HttpApi {
    constructor(endpoint, parameters) {
      this.endpoint = endpoint;
      this.cache = new TonCache_1.InMemoryCache();
      this.parameters = {
        timeout: parameters?.timeout || 3e4,
        // 30 seconds by default
        apiKey: parameters?.apiKey,
        adapter: parameters?.adapter
      };
      this.shardCache = new TypedCache("ton-shard", this.cache, zod_1.z.array(blockIdExt), (src2) => src2 + "");
      this.shardLoader = new dataloader_1.default(async (src2) => {
        return await Promise.all(src2.map(async (v2) => {
          const cached = await this.shardCache.get(v2);
          if (cached) {
            return cached;
          }
          let loaded = (await this.doCall("shards", { seqno: v2 }, getShards)).shards;
          await this.shardCache.set(v2, loaded);
          return loaded;
        }));
      });
      this.shardTransactionsCache = new TypedCache("ton-shard-tx", this.cache, getBlockTransactions, (src2) => src2.workchain + ":" + src2.shard + ":" + src2.seqno);
      this.shardTransactionsLoader = new dataloader_1.default(async (src2) => {
        return await Promise.all(src2.map(async (v2) => {
          const cached = await this.shardTransactionsCache.get(v2);
          if (cached) {
            return cached;
          }
          let loaded = await this.doCall("getBlockTransactions", { workchain: v2.workchain, seqno: v2.seqno, shard: v2.shard }, getBlockTransactions);
          await this.shardTransactionsCache.set(v2, loaded);
          return loaded;
        }));
      }, { cacheKeyFn: (src2) => src2.workchain + ":" + src2.shard + ":" + src2.seqno });
    }
    getAddressInformation(address) {
      return this.doCall("getAddressInformation", { address: address.toString() }, addressInformation);
    }
    async getTransactions(address, opts) {
      const inclusive = opts.inclusive;
      delete opts.inclusive;
      let hash = void 0;
      if (opts.hash) {
        hash = Buffer.from(opts.hash, "base64").toString("hex");
      }
      let limit = opts.limit;
      if (opts.hash && opts.lt && inclusive !== true) {
        limit++;
      }
      let res = await this.doCall("getTransactions", { address: address.toString(), ...opts, limit, hash }, getTransactions);
      if (res.length > limit) {
        res = res.slice(0, limit);
      }
      if (opts.hash && opts.lt && inclusive !== true) {
        res.shift();
        return res;
      } else {
        return res;
      }
    }
    async getMasterchainInfo() {
      return await this.doCall("getMasterchainInfo", {}, getMasterchain);
    }
    async getShards(seqno) {
      return await this.shardLoader.load(seqno);
    }
    async getBlockTransactions(workchain, seqno, shard) {
      return await this.shardTransactionsLoader.load({ workchain, seqno, shard });
    }
    async getTransaction(address, lt, hash) {
      let convHash = Buffer.from(hash, "base64").toString("hex");
      let res = await this.doCall("getTransactions", { address: address.toString(), lt, hash: convHash, limit: 1 }, getTransactions);
      let ex = res.find((v2) => v2.transaction_id.lt === lt && v2.transaction_id.hash === hash);
      if (ex) {
        return ex;
      } else {
        return null;
      }
    }
    async callGetMethod(address, method, stack) {
      return await this.doCall("runGetMethod", { address: address.toString(), method, stack: serializeStack(stack) }, callGetMethod);
    }
    async sendBoc(body) {
      await this.doCall("sendBoc", { boc: body.toString("base64") }, bocResponse);
    }
    async estimateFee(address, args) {
      return await this.doCall("estimateFee", {
        address: address.toString(),
        body: args.body.toBoc().toString("base64"),
        "init_data": args.initData ? args.initData.toBoc().toString("base64") : "",
        "init_code": args.initCode ? args.initCode.toBoc().toString("base64") : "",
        ignore_chksig: args.ignoreSignature
      }, feeResponse);
    }
    async tryLocateResultTx(source, destination, created_lt) {
      return await this.doCall("tryLocateResultTx", { source: source.toString(), destination: destination.toString(), created_lt }, transaction);
    }
    async tryLocateSourceTx(source, destination, created_lt) {
      return await this.doCall("tryLocateSourceTx", { source: source.toString(), destination: destination.toString(), created_lt }, transaction);
    }
    async doCall(method, body, codec) {
      let headers = {
        "Content-Type": "application/json",
        "X-Ton-Client-Version": version2
      };
      if (this.parameters.apiKey) {
        headers["X-API-Key"] = this.parameters.apiKey;
      }
      let res = await axios_12.default.post(this.endpoint, JSON.stringify({
        id: "1",
        jsonrpc: "2.0",
        method,
        params: body
      }), {
        headers,
        timeout: this.parameters.timeout,
        adapter: this.parameters.adapter
      });
      if (res.status !== 200 || !res.data.ok) {
        throw Error("Received error: " + JSON.stringify(res.data));
      }
      let decoded = codec.safeParse(res.data.result);
      if (decoded.success) {
        return decoded.data;
      } else {
        throw Error("Malformed response: " + decoded.error.format()._errors.join(", "));
      }
    }
  };
  HttpApi.HttpApi = HttpApi$1;
  function serializeStack(src2) {
    let stack = [];
    for (let s of src2) {
      if (s.type === "int") {
        stack.push(["num", s.value.toString()]);
      } else if (s.type === "cell") {
        stack.push(["tvm.Cell", s.cell.toBoc().toString("base64")]);
      } else if (s.type === "slice") {
        stack.push(["tvm.Slice", s.cell.toBoc().toString("base64")]);
      } else if (s.type === "builder") {
        stack.push(["tvm.Builder", s.cell.toBoc().toString("base64")]);
      } else {
        throw Error("Unsupported stack item type: " + s.type);
      }
    }
    return stack;
  }
  return HttpApi;
}
var TonClient = {};
var hasRequiredTonClient;
function requireTonClient() {
  if (hasRequiredTonClient) return TonClient;
  hasRequiredTonClient = 1;
  Object.defineProperty(TonClient, "__esModule", { value: true });
  TonClient.TonClient = void 0;
  const HttpApi_1 = requireHttpApi();
  const core_1 = requireDist$5();
  let TonClient$1 = class TonClient {
    constructor(parameters) {
      this.parameters = {
        endpoint: parameters.endpoint
      };
      this.api = new HttpApi_1.HttpApi(this.parameters.endpoint, {
        timeout: parameters.timeout,
        apiKey: parameters.apiKey,
        adapter: parameters.httpAdapter
      });
    }
    /**
     * Get Address Balance
     * @param address address for balance check
     * @returns balance
     */
    async getBalance(address) {
      return (await this.getContractState(address)).balance;
    }
    /**
     * Invoke get method
     * @param address contract address
     * @param name name of method
     * @param params optional parameters
     * @returns stack and gas_used field
     */
    async runMethod(address, name, stack = []) {
      let res = await this.api.callGetMethod(address, name, stack);
      if (res.exit_code !== 0) {
        throw Error("Unable to execute get method. Got exit_code: " + res.exit_code);
      }
      return { gas_used: res.gas_used, stack: parseStack(res.stack) };
    }
    /**
     * Invoke get method
     * @param address contract address
     * @param name name of method
     * @param params optional parameters
     * @returns stack and gas_used field
     * @deprecated use runMethod instead
     */
    async callGetMethod(address, name, stack = []) {
      return this.runMethod(address, name, stack);
    }
    /**
     * Invoke get method that returns error code instead of throwing error
     * @param address contract address
     * @param name name of method
     * @param params optional parameters
     * @returns stack and gas_used field
    */
    async runMethodWithError(address, name, params = []) {
      let res = await this.api.callGetMethod(address, name, params);
      return { gas_used: res.gas_used, stack: parseStack(res.stack), exit_code: res.exit_code };
    }
    /**
     * Invoke get method that returns error code instead of throwing error
     * @param address contract address
     * @param name name of method
     * @param params optional parameters
     * @returns stack and gas_used field
     * @deprecated use runMethodWithError instead
     */
    async callGetMethodWithError(address, name, stack = []) {
      return this.runMethodWithError(address, name, stack);
    }
    /**
     * Get transactions
     * @param address address
     */
    async getTransactions(address, opts) {
      let tx = await this.api.getTransactions(address, opts);
      let res = [];
      for (let r of tx) {
        res.push((0, core_1.loadTransaction)(core_1.Cell.fromBoc(Buffer.from(r.data, "base64"))[0].beginParse()));
      }
      return res;
    }
    /**
     * Get transaction by it's id
     * @param address address
     * @param lt logical time
     * @param hash transaction hash
     * @returns transaction or null if not exist
     */
    async getTransaction(address, lt, hash) {
      let res = await this.api.getTransaction(address, lt, hash);
      if (res) {
        return (0, core_1.loadTransaction)(core_1.Cell.fromBoc(Buffer.from(res.data, "base64"))[0].beginParse());
      } else {
        return null;
      }
    }
    /**
     * Locate outcoming transaction of destination address by incoming message
     * @param source message source address
     * @param destination message destination address
     * @param created_lt message's created lt
     * @returns transaction
     */
    async tryLocateResultTx(source, destination, created_lt) {
      let res = await this.api.tryLocateResultTx(source, destination, created_lt);
      return (0, core_1.loadTransaction)(core_1.Cell.fromBase64(res.data).beginParse());
    }
    /**
     * Locate incoming transaction of source address by outcoming message
     * @param source message source address
     * @param destination message destination address
     * @param created_lt message's created lt
     * @returns transaction
     */
    async tryLocateSourceTx(source, destination, created_lt) {
      let res = await this.api.tryLocateSourceTx(source, destination, created_lt);
      return (0, core_1.loadTransaction)(core_1.Cell.fromBase64(res.data).beginParse());
    }
    /**
     * Fetch latest masterchain info
     * @returns masterchain info
     */
    async getMasterchainInfo() {
      let r = await this.api.getMasterchainInfo();
      return {
        workchain: r.init.workchain,
        shard: r.last.shard,
        initSeqno: r.init.seqno,
        latestSeqno: r.last.seqno
      };
    }
    /**
     * Fetch latest workchain shards
     * @param seqno masterchain seqno
     */
    async getWorkchainShards(seqno) {
      let r = await this.api.getShards(seqno);
      return r.map((m) => ({
        workchain: m.workchain,
        shard: m.shard,
        seqno: m.seqno
      }));
    }
    /**
     * Fetch transactions inf shards
     * @param workchain
     * @param seqno
     * @param shard
     */
    async getShardTransactions(workchain, seqno, shard) {
      let tx = await this.api.getBlockTransactions(workchain, seqno, shard);
      if (tx.incomplete) {
        throw Error("Unsupported");
      }
      return tx.transactions.map((v2) => ({
        account: core_1.Address.parseRaw(v2.account),
        lt: v2.lt,
        hash: v2.hash
      }));
    }
    /**
     * Send message to a network
     * @param src source message
     */
    async sendMessage(src2) {
      const boc = (0, core_1.beginCell)().store((0, core_1.storeMessage)(src2)).endCell().toBoc();
      await this.api.sendBoc(boc);
    }
    /**
     * Send file to a network
     * @param src source file
     */
    async sendFile(src2) {
      await this.api.sendBoc(src2);
    }
    /**
     * Estimate fees for external message
     * @param address target address
     * @returns
     */
    async estimateExternalMessageFee(address, args) {
      return await this.api.estimateFee(address, { body: args.body, initCode: args.initCode, initData: args.initData, ignoreSignature: args.ignoreSignature });
    }
    /**
     * Send external message to contract
     * @param contract contract to send message
     * @param src message body
     */
    async sendExternalMessage(contract, src2) {
      if (await this.isContractDeployed(contract.address) || !contract.init) {
        const message = (0, core_1.external)({
          to: contract.address,
          body: src2
        });
        await this.sendMessage(message);
      } else {
        const message = (0, core_1.external)({
          to: contract.address,
          init: contract.init,
          body: src2
        });
        await this.sendMessage(message);
      }
    }
    /**
     * Check if contract is deployed
     * @param address addres to check
     * @returns true if contract is in active state
     */
    async isContractDeployed(address) {
      return (await this.getContractState(address)).state === "active";
    }
    /**
     * Resolves contract state
     * @param address contract address
     */
    async getContractState(address) {
      let info = await this.api.getAddressInformation(address);
      let balance = BigInt(info.balance);
      let state = info.state;
      return {
        balance,
        extra_currencies: info.extra_currencies,
        state,
        code: info.code !== "" ? Buffer.from(info.code, "base64") : null,
        data: info.data !== "" ? Buffer.from(info.data, "base64") : null,
        lastTransaction: info.last_transaction_id.lt !== "0" ? {
          lt: info.last_transaction_id.lt,
          hash: info.last_transaction_id.hash
        } : null,
        blockId: {
          workchain: info.block_id.workchain,
          shard: info.block_id.shard,
          seqno: info.block_id.seqno
        },
        timestampt: info.sync_utime
      };
    }
    /**
     * Open contract
     * @param src source contract
     * @returns contract
     */
    open(src2) {
      return (0, core_1.openContract)(src2, (args) => createProvider(this, args.address, args.init));
    }
    /**
     * Create a provider
     * @param address address
     * @param init optional init
     * @returns provider
     */
    provider(address, init) {
      return createProvider(this, address, init ?? null);
    }
  };
  TonClient.TonClient = TonClient$1;
  function parseStackEntry(x) {
    const typeName = x["@type"];
    switch (typeName) {
      case "tvm.list":
      case "tvm.tuple":
        return x.elements.map(parseStackEntry);
      case "tvm.cell":
        return core_1.Cell.fromBoc(Buffer.from(x.bytes, "base64"))[0];
      case "tvm.slice":
        return core_1.Cell.fromBoc(Buffer.from(x.bytes, "base64"))[0];
      case "tvm.stackEntryCell":
        return parseStackEntry(x.cell);
      case "tvm.stackEntrySlice":
        return parseStackEntry(x.slice);
      case "tvm.stackEntryTuple":
        return parseStackEntry(x.tuple);
      case "tvm.stackEntryList":
        return parseStackEntry(x.list);
      case "tvm.stackEntryNumber":
        return parseStackEntry(x.number);
      case "tvm.numberDecimal":
        return BigInt(x.number);
      default:
        throw Error("Unsupported item type: " + typeName);
    }
  }
  function parseStackItem(s) {
    if (s[0] === "num") {
      let val = s[1];
      if (val.startsWith("-")) {
        return { type: "int", value: -BigInt(val.slice(1)) };
      } else {
        return { type: "int", value: BigInt(val) };
      }
    } else if (s[0] === "null") {
      return { type: "null" };
    } else if (s[0] === "cell") {
      return { type: "cell", cell: core_1.Cell.fromBoc(Buffer.from(s[1].bytes, "base64"))[0] };
    } else if (s[0] === "slice") {
      return { type: "slice", cell: core_1.Cell.fromBoc(Buffer.from(s[1].bytes, "base64"))[0] };
    } else if (s[0] === "builder") {
      return { type: "builder", cell: core_1.Cell.fromBoc(Buffer.from(s[1].bytes, "base64"))[0] };
    } else if (s[0] === "tuple" || s[0] === "list") {
      if (s[1].elements.length === 0) {
        return { type: "null" };
      }
      return { type: "tuple", items: s[1].elements.map(parseStackEntry) };
    } else {
      throw Error("Unsupported stack item type: " + s[0]);
    }
  }
  function parseStack(src2) {
    let stack = [];
    for (let s of src2) {
      stack.push(parseStackItem(s));
    }
    return new core_1.TupleReader(stack);
  }
  function createProvider(client, address, init) {
    return {
      async getState() {
        let state = await client.getContractState(address);
        let balance = state.balance;
        let last = state.lastTransaction ? { lt: BigInt(state.lastTransaction.lt), hash: Buffer.from(state.lastTransaction.hash, "base64") } : null;
        let ecMap = null;
        let storage;
        if (state.state === "active") {
          storage = {
            type: "active",
            code: state.code ? state.code : null,
            data: state.data ? state.data : null
          };
        } else if (state.state === "uninitialized") {
          storage = {
            type: "uninit"
          };
        } else if (state.state === "frozen") {
          storage = {
            type: "frozen",
            stateHash: Buffer.alloc(0)
          };
        } else {
          throw Error("Unsupported state");
        }
        if (state.extra_currencies && state.extra_currencies.length > 0) {
          ecMap = {};
          for (let ec of state.extra_currencies) {
            ecMap[ec.id] = BigInt(ec.amount);
          }
        }
        return {
          balance,
          extracurrency: ecMap,
          last,
          state: storage
        };
      },
      async get(name, args) {
        if (typeof name !== "string") {
          throw new Error("Method name must be a string for TonClient provider");
        }
        let method = await client.runMethod(address, name, args);
        return { stack: method.stack };
      },
      async external(message) {
        let neededInit = null;
        if (init && !await client.isContractDeployed(address)) {
          neededInit = init;
        }
        const ext = (0, core_1.external)({
          to: address,
          init: neededInit,
          body: message
        });
        let boc = (0, core_1.beginCell)().store((0, core_1.storeMessage)(ext)).endCell().toBoc();
        await client.sendFile(boc);
      },
      async internal(via, message) {
        let neededInit = null;
        if (init && !await client.isContractDeployed(address)) {
          neededInit = init;
        }
        let bounce = true;
        if (message.bounce !== null && message.bounce !== void 0) {
          bounce = message.bounce;
        }
        let value;
        if (typeof message.value === "string") {
          value = (0, core_1.toNano)(message.value);
        } else {
          value = message.value;
        }
        let body = null;
        if (typeof message.body === "string") {
          body = (0, core_1.comment)(message.body);
        } else if (message.body) {
          body = message.body;
        }
        await via.send({
          to: address,
          value,
          bounce,
          sendMode: message.sendMode,
          extracurrency: message.extracurrency,
          init: neededInit,
          body
        });
      },
      open(contract) {
        return (0, core_1.openContract)(contract, (args) => createProvider(client, args.address, args.init ?? null));
      },
      getTransactions(address2, lt, hash, limit) {
        return client.getTransactions(address2, { limit: limit ?? 100, lt: lt.toString(), hash: hash.toString("base64"), inclusive: true });
      }
    };
  }
  return TonClient;
}
var TonClient4 = {};
var toUrlSafe = {};
var hasRequiredToUrlSafe;
function requireToUrlSafe() {
  if (hasRequiredToUrlSafe) return toUrlSafe;
  hasRequiredToUrlSafe = 1;
  Object.defineProperty(toUrlSafe, "__esModule", { value: true });
  toUrlSafe.toUrlSafe = toUrlSafe$1;
  function toUrlSafe$1(src2) {
    while (src2.indexOf("/") >= 0) {
      src2 = src2.replace("/", "_");
    }
    while (src2.indexOf("+") >= 0) {
      src2 = src2.replace("+", "-");
    }
    while (src2.indexOf("=") >= 0) {
      src2 = src2.replace("=", "");
    }
    return src2;
  }
  return toUrlSafe;
}
var hasRequiredTonClient4;
function requireTonClient4() {
  if (hasRequiredTonClient4) return TonClient4;
  hasRequiredTonClient4 = 1;
  var __classPrivateFieldSet = TonClient4 && TonClient4.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = TonClient4 && TonClient4.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var __importDefault = TonClient4 && TonClient4.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  var _TonClient4_endpoint, _TonClient4_timeout, _TonClient4_adapter, _TonClient4_axios;
  Object.defineProperty(TonClient4, "__esModule", { value: true });
  TonClient4.TonClient4 = void 0;
  const axios_12 = __importDefault(/* @__PURE__ */ requireAxios$1());
  const core_1 = requireDist$5();
  const toUrlSafe_1 = requireToUrlSafe();
  const zod_1 = /* @__PURE__ */ requireZod();
  let TonClient4$1 = class TonClient4 {
    constructor(args) {
      _TonClient4_endpoint.set(this, void 0);
      _TonClient4_timeout.set(this, void 0);
      _TonClient4_adapter.set(this, void 0);
      _TonClient4_axios.set(this, void 0);
      __classPrivateFieldSet(this, _TonClient4_axios, axios_12.default.create(), "f");
      __classPrivateFieldSet(this, _TonClient4_endpoint, args.endpoint, "f");
      __classPrivateFieldSet(this, _TonClient4_timeout, args.timeout || 5e3, "f");
      __classPrivateFieldSet(this, _TonClient4_adapter, args.httpAdapter, "f");
      if (args.requestInterceptor) {
        __classPrivateFieldGet(this, _TonClient4_axios, "f").interceptors.request.use(args.requestInterceptor);
      }
    }
    /**
     * Get Last Block
     * @returns last block info
     */
    async getLastBlock() {
      let res = await __classPrivateFieldGet(this, _TonClient4_axios, "f").get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/latest", { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
      let lastBlock = lastBlockCodec.safeParse(res.data);
      if (!lastBlock.success) {
        throw Error("Mailformed response: " + lastBlock.error.format()._errors.join(", "));
      }
      return lastBlock.data;
    }
    /**
     * Get block info
     * @param seqno block sequence number
     * @returns block info
     */
    async getBlock(seqno) {
      let res = await __classPrivateFieldGet(this, _TonClient4_axios, "f").get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno, { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
      let block = blockCodec.safeParse(res.data);
      if (!block.success) {
        throw Error("Mailformed response");
      }
      if (!block.data.exist) {
        throw Error("Block is out of scope");
      }
      return block.data.block;
    }
    /**
     * Get block info by unix timestamp
     * @param ts unix timestamp
     * @returns block info
     */
    async getBlockByUtime(ts) {
      let res = await __classPrivateFieldGet(this, _TonClient4_axios, "f").get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/utime/" + ts, { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
      let block = blockCodec.safeParse(res.data);
      if (!block.success) {
        throw Error("Mailformed response");
      }
      if (!block.data.exist) {
        throw Error("Block is out of scope");
      }
      return block.data.block;
    }
    /**
     * Get block info by unix timestamp
     * @param seqno block sequence number
     * @param address account address
     * @returns account info
     */
    async getAccount(seqno, address) {
      let res = await __classPrivateFieldGet(this, _TonClient4_axios, "f").get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno + "/" + address.toString({ urlSafe: true }), { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
      let account = accountCodec.safeParse(res.data);
      if (!account.success) {
        throw Error("Mailformed response");
      }
      return account.data;
    }
    /**
     * Get account lite info (without code and data)
     * @param seqno block sequence number
     * @param address account address
     * @returns account lite info
     */
    async getAccountLite(seqno, address) {
      let res = await __classPrivateFieldGet(this, _TonClient4_axios, "f").get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno + "/" + address.toString({ urlSafe: true }) + "/lite", { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
      let account = accountLiteCodec.safeParse(res.data);
      if (!account.success) {
        throw Error("Mailformed response");
      }
      return account.data;
    }
    /**
     * Check if contract is deployed
     * @param address addres to check
     * @returns true if contract is in active state
     */
    async isContractDeployed(seqno, address) {
      let account = await this.getAccountLite(seqno, address);
      return account.account.state.type === "active";
    }
    /**
     * Check if account was updated since
     * @param seqno block sequence number
     * @param address account address
     * @param lt account last transaction lt
     * @returns account change info
     */
    async isAccountChanged(seqno, address, lt) {
      let res = await __classPrivateFieldGet(this, _TonClient4_axios, "f").get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno + "/" + address.toString({ urlSafe: true }) + "/changed/" + lt.toString(10), { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
      let changed = changedCodec.safeParse(res.data);
      if (!changed.success) {
        throw Error("Mailformed response");
      }
      return changed.data;
    }
    /**
     * Load unparsed account transactions
     * @param address address
     * @param lt last transaction lt
     * @param hash last transaction hash
     * @returns unparsed transactions
     */
    async getAccountTransactions(address, lt, hash) {
      let res = await __classPrivateFieldGet(this, _TonClient4_axios, "f").get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/account/" + address.toString({ urlSafe: true }) + "/tx/" + lt.toString(10) + "/" + (0, toUrlSafe_1.toUrlSafe)(hash.toString("base64")), { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
      let transactions = transactionsCodec.safeParse(res.data);
      if (!transactions.success) {
        throw Error("Mailformed response");
      }
      let data = transactions.data;
      let tx = [];
      let cells = core_1.Cell.fromBoc(Buffer.from(data.boc, "base64"));
      for (let i = 0; i < data.blocks.length; i++) {
        tx.push({
          block: data.blocks[i],
          tx: (0, core_1.loadTransaction)(cells[i].beginParse())
        });
      }
      return tx;
    }
    /**
     * Load parsed account transactions
     * @param address address
     * @param lt last transaction lt
     * @param hash last transaction hash
     * @param count number of transactions to load
     * @returns parsed transactions
     */
    async getAccountTransactionsParsed(address, lt, hash, count = 20) {
      let res = await __classPrivateFieldGet(this, _TonClient4_axios, "f").get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/account/" + address.toString({ urlSafe: true }) + "/tx/parsed/" + lt.toString(10) + "/" + (0, toUrlSafe_1.toUrlSafe)(hash.toString("base64")), {
        adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"),
        timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f"),
        params: {
          count
        }
      });
      let parsedTransactionsRes = parsedTransactionsCodec.safeParse(res.data);
      if (!parsedTransactionsRes.success) {
        throw Error("Mailformed response");
      }
      return parsedTransactionsRes.data;
    }
    /**
     * Get network config
     * @param seqno block sequence number
     * @param ids optional config ids
     * @returns network config
     */
    async getConfig(seqno, ids) {
      let tail = "";
      if (ids && ids.length > 0) {
        tail = "/" + [...ids].sort().join(",");
      }
      let res = await __classPrivateFieldGet(this, _TonClient4_axios, "f").get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno + "/config" + tail, { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
      let config = configCodec.safeParse(res.data);
      if (!config.success) {
        throw Error("Mailformed response");
      }
      return config.data;
    }
    /**
     * Execute run method
     * @param seqno block sequence number
     * @param address account address
     * @param name method name
     * @param args method arguments
     * @returns method result
     */
    async runMethod(seqno, address, name, args) {
      let tail = args && args.length > 0 ? "/" + (0, toUrlSafe_1.toUrlSafe)((0, core_1.serializeTuple)(args).toBoc({ idx: false, crc32: false }).toString("base64")) : "";
      let url = __classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno + "/" + address.toString({ urlSafe: true }) + "/run/" + encodeURIComponent(name) + tail;
      let res = await __classPrivateFieldGet(this, _TonClient4_axios, "f").get(url, { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
      let runMethod = runMethodCodec.safeParse(res.data);
      if (!runMethod.success) {
        throw Error("Mailformed response");
      }
      let resultTuple = runMethod.data.resultRaw ? (0, core_1.parseTuple)(core_1.Cell.fromBoc(Buffer.from(runMethod.data.resultRaw, "base64"))[0]) : [];
      return {
        exitCode: runMethod.data.exitCode,
        result: resultTuple,
        resultRaw: runMethod.data.resultRaw,
        block: runMethod.data.block,
        shardBlock: runMethod.data.shardBlock,
        reader: new core_1.TupleReader(resultTuple)
      };
    }
    /**
     * Send external message
     * @param message message boc
     * @returns message status
     */
    async sendMessage(message) {
      let res = await __classPrivateFieldGet(this, _TonClient4_axios, "f").post(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/send", { boc: message.toString("base64") }, { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
      let send = sendCodec.safeParse(res.data);
      if (!send.success) {
        throw Error("Mailformed response");
      }
      return { status: res.data.status };
    }
    /**
     * Open smart contract
     * @param contract contract
     * @returns opened contract
     */
    open(contract) {
      return (0, core_1.openContract)(contract, (args) => createProvider(this, null, args.address, args.init));
    }
    /**
     * Open smart contract
     * @param block block number
     * @param contract contract
     * @returns opened contract
     */
    openAt(block, contract) {
      return (0, core_1.openContract)(contract, (args) => createProvider(this, block, args.address, args.init));
    }
    /**
     * Create provider
     * @param address address
     * @param init optional init data
     * @returns provider
     */
    provider(address, init) {
      return createProvider(this, null, address, init ?? null);
    }
    /**
     * Create provider at specified block number
     * @param block block number
     * @param address address
     * @param init optional init data
     * @returns provider
     */
    providerAt(block, address, init) {
      return createProvider(this, block, address, init ?? null);
    }
  };
  TonClient4.TonClient4 = TonClient4$1;
  _TonClient4_endpoint = /* @__PURE__ */ new WeakMap(), _TonClient4_timeout = /* @__PURE__ */ new WeakMap(), _TonClient4_adapter = /* @__PURE__ */ new WeakMap(), _TonClient4_axios = /* @__PURE__ */ new WeakMap();
  function createProvider(client, block, address, init) {
    return {
      async getState() {
        let sq = block;
        if (sq === null) {
          let res = await client.getLastBlock();
          sq = res.last.seqno;
        }
        let state = await client.getAccount(sq, address);
        let last = state.account.last ? { lt: BigInt(state.account.last.lt), hash: Buffer.from(state.account.last.hash, "base64") } : null;
        let storage;
        if (state.account.state.type === "active") {
          storage = {
            type: "active",
            code: state.account.state.code ? Buffer.from(state.account.state.code, "base64") : null,
            data: state.account.state.data ? Buffer.from(state.account.state.data, "base64") : null
          };
        } else if (state.account.state.type === "uninit") {
          storage = {
            type: "uninit"
          };
        } else if (state.account.state.type === "frozen") {
          storage = {
            type: "frozen",
            stateHash: Buffer.from(state.account.state.stateHash, "base64")
          };
        } else {
          throw Error("Unsupported state");
        }
        let ecMap = null;
        if (state.account.balance.currencies) {
          ecMap = {};
          let currencies = state.account.balance.currencies;
          for (let [k, v2] of Object.entries(currencies)) {
            ecMap[Number(k)] = BigInt(v2);
          }
        }
        return {
          balance: BigInt(state.account.balance.coins),
          extracurrency: ecMap,
          last,
          state: storage
        };
      },
      async get(name, args) {
        if (typeof name !== "string") {
          throw new Error("Method name must be a string for TonClient4 provider");
        }
        let sq = block;
        if (sq === null) {
          let res = await client.getLastBlock();
          sq = res.last.seqno;
        }
        let method = await client.runMethod(sq, address, name, args);
        if (method.exitCode !== 0 && method.exitCode !== 1) {
          throw Error("Exit code: " + method.exitCode);
        }
        return {
          stack: new core_1.TupleReader(method.result)
        };
      },
      async external(message) {
        let last = await client.getLastBlock();
        let neededInit = null;
        if (init && (await client.getAccountLite(last.last.seqno, address)).account.state.type !== "active") {
          neededInit = init;
        }
        const ext = (0, core_1.external)({
          to: address,
          init: neededInit,
          body: message
        });
        let pkg = (0, core_1.beginCell)().store((0, core_1.storeMessage)(ext)).endCell().toBoc();
        await client.sendMessage(pkg);
      },
      async internal(via, message) {
        let last = await client.getLastBlock();
        let neededInit = null;
        if (init && (await client.getAccountLite(last.last.seqno, address)).account.state.type !== "active") {
          neededInit = init;
        }
        let bounce = true;
        if (message.bounce !== null && message.bounce !== void 0) {
          bounce = message.bounce;
        }
        let value;
        if (typeof message.value === "string") {
          value = (0, core_1.toNano)(message.value);
        } else {
          value = message.value;
        }
        let body = null;
        if (typeof message.body === "string") {
          body = (0, core_1.comment)(message.body);
        } else if (message.body) {
          body = message.body;
        }
        await via.send({
          to: address,
          value,
          extracurrency: message.extracurrency,
          bounce,
          sendMode: message.sendMode,
          init: neededInit,
          body
        });
      },
      open(contract) {
        return (0, core_1.openContract)(contract, (args) => createProvider(client, block, args.address, args.init ?? null));
      },
      async getTransactions(address2, lt, hash, limit) {
        const useLimit = typeof limit === "number";
        if (useLimit && limit <= 0) {
          return [];
        }
        let transactions = [];
        do {
          const txs = await client.getAccountTransactions(address2, lt, hash);
          const firstTx = txs[0].tx;
          const [firstLt, firstHash] = [firstTx.lt, firstTx.hash()];
          const needSkipFirst = transactions.length > 0 && firstLt === lt && firstHash.equals(hash);
          if (needSkipFirst) {
            txs.shift();
          }
          if (txs.length === 0) {
            break;
          }
          const lastTx = txs[txs.length - 1].tx;
          const [lastLt, lastHash] = [lastTx.lt, lastTx.hash()];
          if (lastLt === lt && lastHash.equals(hash)) {
            break;
          }
          transactions.push(...txs.map((tx) => tx.tx));
          lt = lastLt;
          hash = lastHash;
        } while (useLimit && transactions.length < limit);
        if (useLimit) {
          transactions = transactions.slice(0, limit);
        }
        return transactions;
      }
    };
  }
  const lastBlockCodec = zod_1.z.object({
    last: zod_1.z.object({
      seqno: zod_1.z.number(),
      shard: zod_1.z.string(),
      workchain: zod_1.z.number(),
      fileHash: zod_1.z.string(),
      rootHash: zod_1.z.string()
    }),
    init: zod_1.z.object({
      fileHash: zod_1.z.string(),
      rootHash: zod_1.z.string()
    }),
    stateRootHash: zod_1.z.string(),
    now: zod_1.z.number()
  });
  const blockCodec = zod_1.z.union([zod_1.z.object({
    exist: zod_1.z.literal(false)
  }), zod_1.z.object({
    exist: zod_1.z.literal(true),
    block: zod_1.z.object({
      shards: zod_1.z.array(zod_1.z.object({
        workchain: zod_1.z.number(),
        seqno: zod_1.z.number(),
        shard: zod_1.z.string(),
        rootHash: zod_1.z.string(),
        fileHash: zod_1.z.string(),
        transactions: zod_1.z.array(zod_1.z.object({
          account: zod_1.z.string(),
          hash: zod_1.z.string(),
          lt: zod_1.z.string()
        }))
      }))
    })
  })]);
  const storageStatCodec = zod_1.z.object({
    lastPaid: zod_1.z.number(),
    duePayment: zod_1.z.union([zod_1.z.null(), zod_1.z.string()]),
    used: zod_1.z.object({
      bits: zod_1.z.number(),
      cells: zod_1.z.number(),
      publicCells: zod_1.z.number().optional()
    })
  });
  const accountCodec = zod_1.z.object({
    account: zod_1.z.object({
      state: zod_1.z.union([
        zod_1.z.object({ type: zod_1.z.literal("uninit") }),
        zod_1.z.object({ type: zod_1.z.literal("active"), code: zod_1.z.union([zod_1.z.string(), zod_1.z.null()]), data: zod_1.z.union([zod_1.z.string(), zod_1.z.null()]) }),
        zod_1.z.object({ type: zod_1.z.literal("frozen"), stateHash: zod_1.z.string() })
      ]),
      balance: zod_1.z.object({
        coins: zod_1.z.string(),
        currencies: zod_1.z.record(zod_1.z.string(), zod_1.z.string())
      }),
      last: zod_1.z.union([
        zod_1.z.null(),
        zod_1.z.object({
          lt: zod_1.z.string(),
          hash: zod_1.z.string()
        })
      ]),
      storageStat: zod_1.z.union([zod_1.z.null(), storageStatCodec])
    }),
    block: zod_1.z.object({
      workchain: zod_1.z.number(),
      seqno: zod_1.z.number(),
      shard: zod_1.z.string(),
      rootHash: zod_1.z.string(),
      fileHash: zod_1.z.string()
    })
  });
  const accountLiteCodec = zod_1.z.object({
    account: zod_1.z.object({
      state: zod_1.z.union([
        zod_1.z.object({ type: zod_1.z.literal("uninit") }),
        zod_1.z.object({ type: zod_1.z.literal("active"), codeHash: zod_1.z.string(), dataHash: zod_1.z.string() }),
        zod_1.z.object({ type: zod_1.z.literal("frozen"), stateHash: zod_1.z.string() })
      ]),
      balance: zod_1.z.object({
        coins: zod_1.z.string(),
        currencies: zod_1.z.record(zod_1.z.string(), zod_1.z.string())
      }),
      last: zod_1.z.union([
        zod_1.z.null(),
        zod_1.z.object({
          lt: zod_1.z.string(),
          hash: zod_1.z.string()
        })
      ]),
      storageStat: zod_1.z.union([zod_1.z.null(), storageStatCodec])
    })
  });
  const changedCodec = zod_1.z.object({
    changed: zod_1.z.boolean(),
    block: zod_1.z.object({
      workchain: zod_1.z.number(),
      seqno: zod_1.z.number(),
      shard: zod_1.z.string(),
      rootHash: zod_1.z.string(),
      fileHash: zod_1.z.string()
    })
  });
  const runMethodCodec = zod_1.z.object({
    exitCode: zod_1.z.number(),
    resultRaw: zod_1.z.union([zod_1.z.string(), zod_1.z.null()]),
    block: zod_1.z.object({
      workchain: zod_1.z.number(),
      seqno: zod_1.z.number(),
      shard: zod_1.z.string(),
      rootHash: zod_1.z.string(),
      fileHash: zod_1.z.string()
    }),
    shardBlock: zod_1.z.object({
      workchain: zod_1.z.number(),
      seqno: zod_1.z.number(),
      shard: zod_1.z.string(),
      rootHash: zod_1.z.string(),
      fileHash: zod_1.z.string()
    })
  });
  const configCodec = zod_1.z.object({
    config: zod_1.z.object({
      cell: zod_1.z.string(),
      address: zod_1.z.string(),
      globalBalance: zod_1.z.object({
        coins: zod_1.z.string()
      })
    })
  });
  const sendCodec = zod_1.z.object({
    status: zod_1.z.number()
  });
  const blocksCodec = zod_1.z.array(zod_1.z.object({
    workchain: zod_1.z.number(),
    seqno: zod_1.z.number(),
    shard: zod_1.z.string(),
    rootHash: zod_1.z.string(),
    fileHash: zod_1.z.string()
  }));
  const transactionsCodec = zod_1.z.object({
    blocks: blocksCodec,
    boc: zod_1.z.string()
  });
  const parsedAddressExternalCodec = zod_1.z.object({
    bits: zod_1.z.number(),
    data: zod_1.z.string()
  });
  const parsedMessageInfoCodec = zod_1.z.union([
    zod_1.z.object({
      type: zod_1.z.literal("internal"),
      value: zod_1.z.string(),
      dest: zod_1.z.string(),
      src: zod_1.z.string(),
      bounced: zod_1.z.boolean(),
      bounce: zod_1.z.boolean(),
      ihrDisabled: zod_1.z.boolean(),
      createdAt: zod_1.z.number(),
      createdLt: zod_1.z.string(),
      fwdFee: zod_1.z.string(),
      ihrFee: zod_1.z.string()
    }),
    zod_1.z.object({
      type: zod_1.z.literal("external-in"),
      dest: zod_1.z.string(),
      src: zod_1.z.union([parsedAddressExternalCodec, zod_1.z.null()]),
      importFee: zod_1.z.string()
    }),
    zod_1.z.object({
      type: zod_1.z.literal("external-out"),
      dest: zod_1.z.union([parsedAddressExternalCodec, zod_1.z.null()])
    })
  ]);
  const parsedStateInitCodec = zod_1.z.object({
    splitDepth: zod_1.z.union([zod_1.z.number(), zod_1.z.null()]),
    code: zod_1.z.union([zod_1.z.string(), zod_1.z.null()]),
    data: zod_1.z.union([zod_1.z.string(), zod_1.z.null()]),
    special: zod_1.z.union([zod_1.z.object({ tick: zod_1.z.boolean(), tock: zod_1.z.boolean() }), zod_1.z.null()])
  });
  const parsedMessageCodec = zod_1.z.object({
    body: zod_1.z.string(),
    info: parsedMessageInfoCodec,
    init: zod_1.z.union([parsedStateInitCodec, zod_1.z.null()])
  });
  const accountStatusCodec = zod_1.z.union([zod_1.z.literal("uninitialized"), zod_1.z.literal("frozen"), zod_1.z.literal("active"), zod_1.z.literal("non-existing")]);
  const txBodyCodec = zod_1.z.union([
    zod_1.z.object({ type: zod_1.z.literal("comment"), comment: zod_1.z.string() }),
    zod_1.z.object({ type: zod_1.z.literal("payload"), cell: zod_1.z.string() })
  ]);
  const parsedOperationItemCodec = zod_1.z.union([
    zod_1.z.object({ kind: zod_1.z.literal("ton"), amount: zod_1.z.string() }),
    zod_1.z.object({ kind: zod_1.z.literal("token"), amount: zod_1.z.string() })
  ]);
  const supportedMessageTypeCodec = zod_1.z.union([
    zod_1.z.literal("jetton::excesses"),
    zod_1.z.literal("jetton::transfer"),
    zod_1.z.literal("jetton::transfer_notification"),
    zod_1.z.literal("deposit"),
    zod_1.z.literal("deposit::ok"),
    zod_1.z.literal("withdraw"),
    zod_1.z.literal("withdraw::all"),
    zod_1.z.literal("withdraw::delayed"),
    zod_1.z.literal("withdraw::ok"),
    zod_1.z.literal("airdrop")
  ]);
  const opCodec = zod_1.z.object({
    type: supportedMessageTypeCodec,
    options: zod_1.z.optional(zod_1.z.record(zod_1.z.string()))
  });
  const parsedOperationCodec = zod_1.z.object({
    address: zod_1.z.string(),
    comment: zod_1.z.optional(zod_1.z.string()),
    items: zod_1.z.array(parsedOperationItemCodec),
    op: zod_1.z.optional(opCodec)
  });
  const parsedTransactionCodec = zod_1.z.object({
    address: zod_1.z.string(),
    lt: zod_1.z.string(),
    hash: zod_1.z.string(),
    prevTransaction: zod_1.z.object({
      lt: zod_1.z.string(),
      hash: zod_1.z.string()
    }),
    time: zod_1.z.number(),
    outMessagesCount: zod_1.z.number(),
    oldStatus: accountStatusCodec,
    newStatus: accountStatusCodec,
    fees: zod_1.z.string(),
    update: zod_1.z.object({
      oldHash: zod_1.z.string(),
      newHash: zod_1.z.string()
    }),
    inMessage: zod_1.z.union([parsedMessageCodec, zod_1.z.null()]),
    outMessages: zod_1.z.array(parsedMessageCodec),
    parsed: zod_1.z.object({
      seqno: zod_1.z.union([zod_1.z.number(), zod_1.z.null()]),
      body: zod_1.z.union([txBodyCodec, zod_1.z.null()]),
      status: zod_1.z.union([zod_1.z.literal("success"), zod_1.z.literal("failed"), zod_1.z.literal("pending")]),
      dest: zod_1.z.union([zod_1.z.string(), zod_1.z.null()]),
      kind: zod_1.z.union([zod_1.z.literal("out"), zod_1.z.literal("in")]),
      amount: zod_1.z.string(),
      resolvedAddress: zod_1.z.string(),
      bounced: zod_1.z.boolean(),
      mentioned: zod_1.z.array(zod_1.z.string())
    }),
    operation: parsedOperationCodec
  });
  const parsedTransactionsCodec = zod_1.z.object({
    blocks: blocksCodec,
    transactions: zod_1.z.array(parsedTransactionCodec)
  });
  return TonClient4;
}
var WalletContractV1R1 = {};
var createWalletTransfer = {};
var WalletContractV5Beta$1 = {};
var WalletV5BetaWalletId = {};
var hasRequiredWalletV5BetaWalletId;
function requireWalletV5BetaWalletId() {
  if (hasRequiredWalletV5BetaWalletId) return WalletV5BetaWalletId;
  hasRequiredWalletV5BetaWalletId = 1;
  Object.defineProperty(WalletV5BetaWalletId, "__esModule", { value: true });
  WalletV5BetaWalletId.loadWalletIdV5Beta = loadWalletIdV5Beta;
  WalletV5BetaWalletId.storeWalletIdV5Beta = storeWalletIdV5Beta;
  const core_1 = requireDist$5();
  const walletV5BetaVersionsSerialisation = {
    v5: 0
  };
  function loadWalletIdV5Beta(value) {
    const bitReader = new core_1.BitReader(new core_1.BitString(typeof value === "bigint" ? Buffer.from(value.toString(16), "hex") : value instanceof core_1.Slice ? value.loadBuffer(10) : value, 0, 80));
    const networkGlobalId = bitReader.loadInt(32);
    const workchain = bitReader.loadInt(8);
    const walletVersionRaw = bitReader.loadUint(8);
    const subwalletNumber = bitReader.loadUint(32);
    const walletVersion = Object.entries(walletV5BetaVersionsSerialisation).find(([_, value2]) => value2 === walletVersionRaw)?.[0];
    if (walletVersion === void 0) {
      throw new Error(`Can't deserialize walletId: unknown wallet version ${walletVersionRaw}`);
    }
    return { networkGlobalId, workchain, walletVersion, subwalletNumber };
  }
  function storeWalletIdV5Beta(walletId) {
    return (builder2) => {
      builder2.storeInt(walletId.networkGlobalId, 32);
      builder2.storeInt(walletId.workchain, 8);
      builder2.storeUint(walletV5BetaVersionsSerialisation[walletId.walletVersion], 8);
      builder2.storeUint(walletId.subwalletNumber, 32);
    };
  }
  return WalletV5BetaWalletId;
}
var hasRequiredWalletContractV5Beta$1;
function requireWalletContractV5Beta$1() {
  if (hasRequiredWalletContractV5Beta$1) return WalletContractV5Beta$1;
  hasRequiredWalletContractV5Beta$1 = 1;
  Object.defineProperty(WalletContractV5Beta$1, "__esModule", { value: true });
  WalletContractV5Beta$1.WalletContractV5Beta = void 0;
  const core_1 = requireDist$5();
  const createWalletTransfer_1 = requireCreateWalletTransfer();
  const WalletV5BetaWalletId_1 = requireWalletV5BetaWalletId();
  class WalletContractV5Beta2 {
    static create(args) {
      const walletId = {
        networkGlobalId: args.walletId?.networkGlobalId ?? -239,
        workchain: args?.walletId?.workchain ?? 0,
        subwalletNumber: args?.walletId?.subwalletNumber ?? 0,
        walletVersion: args?.walletId?.walletVersion ?? "v5"
      };
      return new WalletContractV5Beta2(walletId, args.publicKey);
    }
    constructor(walletId, publicKey) {
      this.walletId = walletId;
      this.publicKey = publicKey;
      this.walletId = walletId;
      let code = core_1.Cell.fromBoc(Buffer.from("te6cckEBAQEAIwAIQgLkzzsvTG1qYeoPK1RH0mZ4WyavNjfbLe7mvNGqgm80Eg3NjhE=", "base64"))[0];
      let data = (0, core_1.beginCell)().storeInt(0, 33).store((0, WalletV5BetaWalletId_1.storeWalletIdV5Beta)(this.walletId)).storeBuffer(this.publicKey, 32).storeBit(0).endCell();
      this.init = { code, data };
      this.address = (0, core_1.contractAddress)(this.walletId.workchain, { code, data });
    }
    /**
     * Get Wallet Balance
     */
    async getBalance(provider) {
      let state = await provider.getState();
      return state.balance;
    }
    /**
     * Get Wallet Seqno
     */
    async getSeqno(provider) {
      let state = await provider.getState();
      if (state.state.type === "active") {
        let res = await provider.get("seqno", []);
        return res.stack.readNumber();
      } else {
        return 0;
      }
    }
    /**
     * Get Wallet Extensions
     */
    async getExtensions(provider) {
      let state = await provider.getState();
      if (state.state.type === "active") {
        const result = await provider.get("get_extensions", []);
        return result.stack.readCellOpt();
      } else {
        return null;
      }
    }
    /**
     * Get Wallet Extensions
     */
    async getExtensionsArray(provider) {
      const extensions = await this.getExtensions(provider);
      if (!extensions) {
        return [];
      }
      const dict = core_1.Dictionary.loadDirect(core_1.Dictionary.Keys.BigUint(256), core_1.Dictionary.Values.BigInt(8), extensions);
      return dict.keys().map((key2) => {
        const wc = dict.get(key2);
        const addressHex = key2 ^ wc + 1n;
        return core_1.Address.parseRaw(`${wc}:${addressHex.toString(16).padStart(64, "0")}`);
      });
    }
    /**
     * Get is secret-key authentication enabled
     */
    async getIsSecretKeyAuthEnabled(provider) {
      let res = await provider.get("get_is_signature_auth_allowed", []);
      const result = res.stack.readNumber();
      return result !== 0;
    }
    /**
     * Send signed transfer
     */
    async send(provider, message) {
      await provider.external(message);
    }
    /**
     * Sign and send transfer
     */
    async sendTransfer(provider, args) {
      const transfer = await this.createTransfer(args);
      await this.send(provider, transfer);
    }
    /**
     * Sign and send add extension request
     */
    async sendAddExtension(provider, args) {
      const request = await this.createAddExtension(args);
      await this.send(provider, request);
    }
    /**
     * Sign and send remove extension request
     */
    async sendRemoveExtension(provider, args) {
      const request = await this.createRemoveExtension(args);
      await this.send(provider, request);
    }
    /**
     * Sign and send actions batch
     */
    async sendActionsBatch(provider, args) {
      const request = await this.createRequest(args);
      await this.send(provider, request);
    }
    createActions(args) {
      const actions = args.messages.map((message) => ({ type: "sendMsg", mode: args.sendMode, outMsg: message }));
      return actions;
    }
    /**
     * Create signed transfer
     */
    createTransfer(args) {
      return this.createRequest({
        ...args,
        actions: this.createActions({ messages: args.messages, sendMode: args.sendMode })
      });
    }
    /**
     * Create signed add extension request
     */
    createAddExtension(args) {
      return this.createRequest({
        ...args,
        actions: [{
          type: "addExtension",
          address: args.extensionAddress
        }]
      });
    }
    /**
     * Create signed remove extension request
     */
    createRemoveExtension(args) {
      return this.createRequest({
        ...args,
        actions: [{
          type: "removeExtension",
          address: args.extensionAddress
        }]
      });
    }
    /**
     * Create signed request or extension auth request
     */
    createRequest(args) {
      if (args.authType === "extension") {
        return (0, createWalletTransfer_1.createWalletTransferV5Beta)(args);
      }
      return (0, createWalletTransfer_1.createWalletTransferV5Beta)({
        ...args,
        walletId: (0, WalletV5BetaWalletId_1.storeWalletIdV5Beta)(this.walletId)
      });
    }
    /**
     * Create sender
     */
    sender(provider, secretKey) {
      return {
        send: async (args) => {
          let seqno = await this.getSeqno(provider);
          let transfer = this.createTransfer({
            seqno,
            secretKey,
            sendMode: args.sendMode ?? core_1.SendMode.PAY_GAS_SEPARATELY + core_1.SendMode.IGNORE_ERRORS,
            messages: [(0, core_1.internal)({
              to: args.to,
              value: args.value,
              extracurrency: args.extracurrency,
              init: args.init,
              body: args.body,
              bounce: args.bounce
            })]
          });
          await this.send(provider, transfer);
        }
      };
    }
  }
  WalletContractV5Beta$1.WalletContractV5Beta = WalletContractV5Beta2;
  WalletContractV5Beta2.OpCodes = {
    auth_extension: 1702392942,
    auth_signed_external: 1936287598,
    auth_signed_internal: 1936289396
  };
  return WalletContractV5Beta$1;
}
var WalletV5BetaActions = {};
var WalletV5OutActions = {};
var hasRequiredWalletV5OutActions;
function requireWalletV5OutActions() {
  if (hasRequiredWalletV5OutActions) return WalletV5OutActions;
  hasRequiredWalletV5OutActions = 1;
  Object.defineProperty(WalletV5OutActions, "__esModule", { value: true });
  WalletV5OutActions.isOutActionExtended = isOutActionExtended;
  WalletV5OutActions.isOutActionBasic = isOutActionBasic;
  function isOutActionExtended(action) {
    return action.type === "setIsPublicKeyEnabled" || action.type === "addExtension" || action.type === "removeExtension";
  }
  function isOutActionBasic(action) {
    return !isOutActionExtended(action);
  }
  return WalletV5OutActions;
}
var hasRequiredWalletV5BetaActions;
function requireWalletV5BetaActions() {
  if (hasRequiredWalletV5BetaActions) return WalletV5BetaActions;
  hasRequiredWalletV5BetaActions = 1;
  Object.defineProperty(WalletV5BetaActions, "__esModule", { value: true });
  WalletV5BetaActions.storeOutActionExtendedV5Beta = storeOutActionExtendedV5Beta;
  WalletV5BetaActions.loadOutActionV5BetaExtended = loadOutActionV5BetaExtended;
  WalletV5BetaActions.storeOutListExtendedV5Beta = storeOutListExtendedV5Beta;
  WalletV5BetaActions.loadOutListExtendedV5Beta = loadOutListExtendedV5Beta;
  const core_1 = requireDist$5();
  const WalletV5OutActions_1 = requireWalletV5OutActions();
  const outActionSetIsPublicKeyEnabledTag = 550222170;
  function storeOutActionSetIsPublicKeyEnabled(action) {
    return (builder2) => {
      builder2.storeUint(outActionSetIsPublicKeyEnabledTag, 32).storeUint(action.isEnabled ? 1 : 0, 1);
    };
  }
  const outActionAddExtensionTag = 474012575;
  function storeOutActionAddExtension(action) {
    return (builder2) => {
      builder2.storeUint(outActionAddExtensionTag, 32).storeAddress(action.address);
    };
  }
  const outActionRemoveExtensionTag = 1588524196;
  function storeOutActionRemoveExtension(action) {
    return (builder2) => {
      builder2.storeUint(outActionRemoveExtensionTag, 32).storeAddress(action.address);
    };
  }
  function storeOutActionExtendedV5Beta(action) {
    switch (action.type) {
      case "setIsPublicKeyEnabled":
        return storeOutActionSetIsPublicKeyEnabled(action);
      case "addExtension":
        return storeOutActionAddExtension(action);
      case "removeExtension":
        return storeOutActionRemoveExtension(action);
      default:
        throw new Error("Unknown action type" + action?.type);
    }
  }
  function loadOutActionV5BetaExtended(slice) {
    const tag = slice.loadUint(32);
    switch (tag) {
      case outActionSetIsPublicKeyEnabledTag:
        return {
          type: "setIsPublicKeyEnabled",
          isEnabled: !!slice.loadUint(1)
        };
      case outActionAddExtensionTag:
        return {
          type: "addExtension",
          address: slice.loadAddress()
        };
      case outActionRemoveExtensionTag:
        return {
          type: "removeExtension",
          address: slice.loadAddress()
        };
      default:
        throw new Error(`Unknown extended out action tag 0x${tag.toString(16)}`);
    }
  }
  function storeOutListExtendedV5Beta(actions) {
    const [action, ...rest] = actions;
    if (!action || !(0, WalletV5OutActions_1.isOutActionExtended)(action)) {
      if (actions.some(WalletV5OutActions_1.isOutActionExtended)) {
        throw new Error("Can't serialize actions list: all extended actions must be placed before out actions");
      }
      return (builder2) => {
        builder2.storeUint(0, 1).storeRef((0, core_1.beginCell)().store((0, core_1.storeOutList)(actions)).endCell());
      };
    }
    return (builder2) => {
      builder2.storeUint(1, 1).store(storeOutActionExtendedV5Beta(action)).storeRef((0, core_1.beginCell)().store(storeOutListExtendedV5Beta(rest)).endCell());
    };
  }
  function loadOutListExtendedV5Beta(slice) {
    const actions = [];
    while (slice.loadUint(1)) {
      const action = loadOutActionV5BetaExtended(slice);
      actions.push(action);
      slice = slice.loadRef().beginParse();
    }
    const commonAction = (0, core_1.loadOutList)(slice.loadRef().beginParse());
    if (commonAction.some((i) => i.type === "setCode")) {
      throw new Error("Can't deserialize actions list: only sendMsg actions are allowed for wallet v5");
    }
    return actions.concat(commonAction);
  }
  return WalletV5BetaActions;
}
var singer = {};
var hasRequiredSinger;
function requireSinger() {
  if (hasRequiredSinger) return singer;
  hasRequiredSinger = 1;
  Object.defineProperty(singer, "__esModule", { value: true });
  singer.signPayload = signPayload;
  const crypto_1 = requireDist$6();
  function signPayload(args, signingMessage, packMessage) {
    if ("secretKey" in args) {
      return packMessage((0, crypto_1.sign)(signingMessage.endCell().hash(), args.secretKey), signingMessage);
    } else {
      return args.signer(signingMessage.endCell()).then((signature) => packMessage(signature, signingMessage));
    }
  }
  return singer;
}
var WalletContractV5R1$1 = {};
var WalletV5R1WalletId = {};
var hasRequiredWalletV5R1WalletId;
function requireWalletV5R1WalletId() {
  if (hasRequiredWalletV5R1WalletId) return WalletV5R1WalletId;
  hasRequiredWalletV5R1WalletId = 1;
  Object.defineProperty(WalletV5R1WalletId, "__esModule", { value: true });
  WalletV5R1WalletId.isWalletIdV5R1ClientContext = isWalletIdV5R1ClientContext;
  WalletV5R1WalletId.loadWalletIdV5R1 = loadWalletIdV5R1;
  WalletV5R1WalletId.storeWalletIdV5R1 = storeWalletIdV5R1;
  const core_1 = requireDist$5();
  function isWalletIdV5R1ClientContext(context) {
    return typeof context !== "number";
  }
  const walletV5R1VersionsSerialisation = {
    v5r1: 0
  };
  function loadWalletIdV5R1(value, networkGlobalId) {
    const val = new core_1.BitReader(new core_1.BitString(typeof value === "bigint" ? Buffer.from(value.toString(16), "hex") : value instanceof core_1.Slice ? value.loadBuffer(4) : value, 0, 32)).loadInt(32);
    const context = BigInt(val) ^ BigInt(networkGlobalId);
    const bitReader = (0, core_1.beginCell)().storeInt(context, 32).endCell().beginParse();
    const isClientContext = bitReader.loadUint(1);
    if (isClientContext) {
      const workchain = bitReader.loadInt(8);
      const walletVersionRaw = bitReader.loadUint(8);
      const subwalletNumber = bitReader.loadUint(15);
      const walletVersion = Object.entries(walletV5R1VersionsSerialisation).find(([_, value2]) => value2 === walletVersionRaw)?.[0];
      if (walletVersion === void 0) {
        throw new Error(`Can't deserialize walletId: unknown wallet version ${walletVersionRaw}`);
      }
      return {
        networkGlobalId,
        context: {
          walletVersion,
          workchain,
          subwalletNumber
        }
      };
    } else {
      const context2 = bitReader.loadUint(31);
      return {
        networkGlobalId,
        context: context2
      };
    }
  }
  function storeWalletIdV5R1(walletId) {
    return (builder2) => {
      let context;
      if (isWalletIdV5R1ClientContext(walletId.context)) {
        context = (0, core_1.beginCell)().storeUint(1, 1).storeInt(walletId.context.workchain, 8).storeUint(walletV5R1VersionsSerialisation[walletId.context.walletVersion], 8).storeUint(walletId.context.subwalletNumber, 15).endCell().beginParse().loadInt(32);
      } else {
        context = (0, core_1.beginCell)().storeUint(0, 1).storeUint(walletId.context, 31).endCell().beginParse().loadInt(32);
      }
      return builder2.storeInt(BigInt(walletId.networkGlobalId) ^ BigInt(context), 32);
    };
  }
  return WalletV5R1WalletId;
}
var hasRequiredWalletContractV5R1$1;
function requireWalletContractV5R1$1() {
  if (hasRequiredWalletContractV5R1$1) return WalletContractV5R1$1;
  hasRequiredWalletContractV5R1$1 = 1;
  Object.defineProperty(WalletContractV5R1$1, "__esModule", { value: true });
  WalletContractV5R1$1.WalletContractV5R1 = void 0;
  const core_1 = requireDist$5();
  const createWalletTransfer_1 = requireCreateWalletTransfer();
  const WalletV5R1WalletId_1 = requireWalletV5R1WalletId();
  class WalletContractV5R12 {
    static create(args) {
      let workchain = 0;
      if ("workchain" in args && args.workchain != void 0) {
        workchain = args.workchain;
      }
      if (args.walletId?.context && (0, WalletV5R1WalletId_1.isWalletIdV5R1ClientContext)(args.walletId.context) && args.walletId.context.workchain != void 0) {
        workchain = args.walletId.context.workchain;
      }
      return new WalletContractV5R12(workchain, args.publicKey, {
        networkGlobalId: args.walletId?.networkGlobalId ?? -239,
        context: args.walletId?.context ?? {
          workchain: 0,
          walletVersion: "v5r1",
          subwalletNumber: 0
        }
      });
    }
    constructor(workchain, publicKey, walletId) {
      this.publicKey = publicKey;
      this.walletId = walletId;
      this.walletId = walletId;
      let code = core_1.Cell.fromBoc(Buffer.from("b5ee9c7241021401000281000114ff00f4a413f4bcf2c80b01020120020d020148030402dcd020d749c120915b8f6320d70b1f2082106578746ebd21821073696e74bdb0925f03e082106578746eba8eb48020d72101d074d721fa4030fa44f828fa443058bd915be0ed44d0810141d721f4058307f40e6fa1319130e18040d721707fdb3ce03120d749810280b99130e070e2100f020120050c020120060902016e07080019adce76a2684020eb90eb85ffc00019af1df6a2684010eb90eb858fc00201480a0b0017b325fb51341c75c875c2c7e00011b262fb513435c280200019be5f0f6a2684080a0eb90fa02c0102f20e011e20d70b1f82107369676ebaf2e08a7f0f01e68ef0eda2edfb218308d722028308d723208020d721d31fd31fd31fed44d0d200d31f20d31fd3ffd70a000af90140ccf9109a28945f0adb31e1f2c087df02b35007b0f2d0845125baf2e0855036baf2e086f823bbf2d0882292f800de01a47fc8ca00cb1f01cf16c9ed542092f80fde70db3cd81003f6eda2edfb02f404216e926c218e4c0221d73930709421c700b38e2d01d72820761e436c20d749c008f2e09320d74ac002f2e09320d71d06c712c2005230b0f2d089d74cd7393001a4e86c128407bbf2e093d74ac000f2e093ed55e2d20001c000915be0ebd72c08142091709601d72c081c12e25210b1e30f20d74a111213009601fa4001fa44f828fa443058baf2e091ed44d0810141d718f405049d7fc8ca0040048307f453f2e08b8e14038307f45bf2e08c22d70a00216e01b3b0f2d090e2c85003cf1612f400c9ed54007230d72c08248e2d21f2e092d200ed44d0d2005113baf2d08f54503091319c01810140d721d70a00f2e08ee2c8ca0058cf16c9ed5493f2c08de20010935bdb31e1d74cd0b4d6c35e", "hex"))[0];
      let data = (0, core_1.beginCell)().storeUint(1, 1).storeUint(0, 32).store((0, WalletV5R1WalletId_1.storeWalletIdV5R1)(this.walletId)).storeBuffer(this.publicKey, 32).storeBit(0).endCell();
      this.init = { code, data };
      this.address = (0, core_1.contractAddress)(workchain, { code, data });
    }
    /**
     * Get Wallet Balance
     */
    async getBalance(provider) {
      let state = await provider.getState();
      return state.balance;
    }
    /**
     * Get Wallet Seqno
     */
    async getSeqno(provider) {
      let state = await provider.getState();
      if (state.state.type === "active") {
        let res = await provider.get("seqno", []);
        return res.stack.readNumber();
      } else {
        return 0;
      }
    }
    /**
     * Get Wallet Extensions
     */
    async getExtensions(provider) {
      let state = await provider.getState();
      if (state.state.type === "active") {
        const result = await provider.get("get_extensions", []);
        return result.stack.readCellOpt();
      } else {
        return null;
      }
    }
    /**
     * Get Wallet Extensions
     */
    async getExtensionsArray(provider) {
      const extensions = await this.getExtensions(provider);
      if (!extensions) {
        return [];
      }
      const dict = core_1.Dictionary.loadDirect(core_1.Dictionary.Keys.BigUint(256), core_1.Dictionary.Values.BigInt(1), extensions);
      return dict.keys().map((addressHex) => {
        const wc = this.address.workChain;
        return core_1.Address.parseRaw(`${wc}:${addressHex.toString(16).padStart(64, "0")}`);
      });
    }
    /**
     * Get is secret-key authentication enabled
     */
    async getIsSecretKeyAuthEnabled(provider) {
      let res = await provider.get("is_signature_allowed", []);
      return res.stack.readBoolean();
    }
    /**
     * Send signed transfer
     */
    async send(provider, message) {
      await provider.external(message);
    }
    /**
     * Sign and send transfer
     */
    async sendTransfer(provider, args) {
      const transfer = await this.createTransfer(args);
      await this.send(provider, transfer);
    }
    /**
     * Sign and send add extension request
     */
    async sendAddExtension(provider, args) {
      const request = await this.createAddExtension(args);
      await this.send(provider, request);
    }
    /**
     * Sign and send remove extension request
     */
    async sendRemoveExtension(provider, args) {
      const request = await this.createRemoveExtension(args);
      await this.send(provider, request);
    }
    createActions(args) {
      const actions = args.messages.map((message) => ({ type: "sendMsg", mode: args.sendMode, outMsg: message }));
      return actions;
    }
    /**
     * Create signed transfer
     */
    createTransfer(args) {
      return this.createRequest({
        actions: this.createActions({ messages: args.messages, sendMode: args.sendMode }),
        ...args
      });
    }
    /**
     * Create signed add extension request
     */
    createAddExtension(args) {
      return this.createRequest({
        actions: [{
          type: "addExtension",
          address: args.extensionAddress
        }],
        ...args
      });
    }
    /**
     * Create signed remove extension request
     */
    createRemoveExtension(args) {
      return this.createRequest({
        actions: [{
          type: "removeExtension",
          address: args.extensionAddress
        }],
        ...args
      });
    }
    /**
     * Create signed request or extension auth request
     */
    createRequest(args) {
      if (args.authType === "extension") {
        return (0, createWalletTransfer_1.createWalletTransferV5R1)(args);
      }
      return (0, createWalletTransfer_1.createWalletTransferV5R1)({
        ...args,
        walletId: (0, WalletV5R1WalletId_1.storeWalletIdV5R1)(this.walletId)
      });
    }
    /**
     * Create sender
     */
    sender(provider, secretKey) {
      return {
        send: async (args) => {
          let seqno = await this.getSeqno(provider);
          let transfer = this.createTransfer({
            seqno,
            secretKey,
            sendMode: args.sendMode ?? core_1.SendMode.PAY_GAS_SEPARATELY + core_1.SendMode.IGNORE_ERRORS,
            messages: [(0, core_1.internal)({
              to: args.to,
              value: args.value,
              extracurrency: args.extracurrency,
              init: args.init,
              body: args.body,
              bounce: args.bounce
            })]
          });
          await this.send(provider, transfer);
        }
      };
    }
  }
  WalletContractV5R1$1.WalletContractV5R1 = WalletContractV5R12;
  WalletContractV5R12.OpCodes = {
    auth_extension: 1702392942,
    auth_signed_external: 1936287598,
    auth_signed_internal: 1936289396
  };
  return WalletContractV5R1$1;
}
var WalletV5R1Actions = {};
var hasRequiredWalletV5R1Actions;
function requireWalletV5R1Actions() {
  if (hasRequiredWalletV5R1Actions) return WalletV5R1Actions;
  hasRequiredWalletV5R1Actions = 1;
  Object.defineProperty(WalletV5R1Actions, "__esModule", { value: true });
  WalletV5R1Actions.storeOutActionExtendedV5R1 = storeOutActionExtendedV5R1;
  WalletV5R1Actions.loadOutActionExtendedV5R1 = loadOutActionExtendedV5R1;
  WalletV5R1Actions.storeOutListExtendedV5R1 = storeOutListExtendedV5R1;
  WalletV5R1Actions.loadOutListExtendedV5R1 = loadOutListExtendedV5R1;
  WalletV5R1Actions.toSafeV5R1SendMode = toSafeV5R1SendMode;
  WalletV5R1Actions.patchV5R1ActionsSendMode = patchV5R1ActionsSendMode;
  const core_1 = requireDist$5();
  const WalletV5OutActions_1 = requireWalletV5OutActions();
  const outActionSetIsPublicKeyEnabledTag = 4;
  function storeOutActionSetIsPublicKeyEnabled(action) {
    return (builder2) => {
      builder2.storeUint(outActionSetIsPublicKeyEnabledTag, 8).storeUint(action.isEnabled ? 1 : 0, 1);
    };
  }
  const outActionAddExtensionTag = 2;
  function storeOutActionAddExtension(action) {
    return (builder2) => {
      builder2.storeUint(outActionAddExtensionTag, 8).storeAddress(action.address);
    };
  }
  const outActionRemoveExtensionTag = 3;
  function storeOutActionRemoveExtension(action) {
    return (builder2) => {
      builder2.storeUint(outActionRemoveExtensionTag, 8).storeAddress(action.address);
    };
  }
  function storeOutActionExtendedV5R1(action) {
    switch (action.type) {
      case "setIsPublicKeyEnabled":
        return storeOutActionSetIsPublicKeyEnabled(action);
      case "addExtension":
        return storeOutActionAddExtension(action);
      case "removeExtension":
        return storeOutActionRemoveExtension(action);
      default:
        throw new Error("Unknown action type" + action?.type);
    }
  }
  function loadOutActionExtendedV5R1(slice) {
    const tag = slice.loadUint(8);
    switch (tag) {
      case outActionSetIsPublicKeyEnabledTag:
        return {
          type: "setIsPublicKeyEnabled",
          isEnabled: !!slice.loadUint(1)
        };
      case outActionAddExtensionTag:
        return {
          type: "addExtension",
          address: slice.loadAddress()
        };
      case outActionRemoveExtensionTag:
        return {
          type: "removeExtension",
          address: slice.loadAddress()
        };
      default:
        throw new Error(`Unknown extended out action tag 0x${tag.toString(16)}`);
    }
  }
  function storeOutListExtendedV5R1(actions) {
    const extendedActions = actions.filter(WalletV5OutActions_1.isOutActionExtended);
    const basicActions = actions.filter(WalletV5OutActions_1.isOutActionBasic);
    return (builder2) => {
      const outListPacked = basicActions.length ? (0, core_1.beginCell)().store((0, core_1.storeOutList)(basicActions.slice().reverse())) : null;
      builder2.storeMaybeRef(outListPacked);
      if (extendedActions.length === 0) {
        builder2.storeUint(0, 1);
      } else {
        const [first, ...rest] = extendedActions;
        builder2.storeUint(1, 1).store(storeOutActionExtendedV5R1(first));
        if (rest.length > 0) {
          builder2.storeRef(packExtendedActionsRec(rest));
        }
      }
    };
  }
  function packExtendedActionsRec(extendedActions) {
    const [first, ...rest] = extendedActions;
    let builder2 = (0, core_1.beginCell)().store(storeOutActionExtendedV5R1(first));
    if (rest.length > 0) {
      builder2 = builder2.storeRef(packExtendedActionsRec(rest));
    }
    return builder2.endCell();
  }
  function loadOutListExtendedV5R1(slice) {
    const actions = [];
    const outListPacked = slice.loadMaybeRef();
    if (outListPacked) {
      const loadedActions = (0, core_1.loadOutList)(outListPacked.beginParse());
      if (loadedActions.some((a) => a.type !== "sendMsg")) {
        throw new Error("Can't deserialize actions list: only sendMsg actions are allowed for wallet v5r1");
      }
      actions.push(...loadedActions);
    }
    if (slice.loadBoolean()) {
      const action = loadOutActionExtendedV5R1(slice);
      actions.push(action);
    }
    while (slice.remainingRefs > 0) {
      slice = slice.loadRef().beginParse();
      const action = loadOutActionExtendedV5R1(slice);
      actions.push(action);
    }
    return actions;
  }
  function toSafeV5R1SendMode(sendMode, authType) {
    if (authType === "internal" || authType === "extension") {
      return sendMode;
    }
    return sendMode | core_1.SendMode.IGNORE_ERRORS;
  }
  function patchV5R1ActionsSendMode(actions, authType) {
    return actions.map((action) => action.type === "sendMsg" ? {
      ...action,
      mode: toSafeV5R1SendMode(action.mode, authType)
    } : action);
  }
  return WalletV5R1Actions;
}
var hasRequiredCreateWalletTransfer;
function requireCreateWalletTransfer() {
  if (hasRequiredCreateWalletTransfer) return createWalletTransfer;
  hasRequiredCreateWalletTransfer = 1;
  Object.defineProperty(createWalletTransfer, "__esModule", { value: true });
  createWalletTransfer.createWalletTransferV1 = createWalletTransferV1;
  createWalletTransfer.createWalletTransferV2 = createWalletTransferV2;
  createWalletTransfer.createWalletTransferV3 = createWalletTransferV3;
  createWalletTransfer.createWalletTransferV4 = createWalletTransferV4;
  createWalletTransfer.createWalletTransferV5Beta = createWalletTransferV5Beta;
  createWalletTransfer.createWalletTransferV5R1 = createWalletTransferV5R1;
  const core_1 = requireDist$5();
  const crypto_1 = requireDist$6();
  const WalletContractV5Beta_1 = requireWalletContractV5Beta$1();
  const WalletV5BetaActions_1 = requireWalletV5BetaActions();
  const singer_1 = requireSinger();
  const WalletContractV5R1_1 = requireWalletContractV5R1$1();
  const WalletV5R1Actions_1 = requireWalletV5R1Actions();
  function packSignatureToFront(signature, signingMessage) {
    const body = (0, core_1.beginCell)().storeBuffer(signature).storeBuilder(signingMessage).endCell();
    return body;
  }
  function packSignatureToTail(signature, signingMessage) {
    const body = (0, core_1.beginCell)().storeBuilder(signingMessage).storeBuffer(signature).endCell();
    return body;
  }
  function createWalletTransferV1(args) {
    let signingMessage = (0, core_1.beginCell)().storeUint(args.seqno, 32);
    if (args.message) {
      signingMessage.storeUint(args.sendMode, 8);
      signingMessage.storeRef((0, core_1.beginCell)().store((0, core_1.storeMessageRelaxed)(args.message)));
    }
    let signature = (0, crypto_1.sign)(signingMessage.endCell().hash(), args.secretKey);
    const body = (0, core_1.beginCell)().storeBuffer(signature).storeBuilder(signingMessage).endCell();
    return body;
  }
  function createWalletTransferV2(args) {
    if (args.messages.length > 4) {
      throw Error("Maximum number of messages in a single transfer is 4");
    }
    let signingMessage = (0, core_1.beginCell)().storeUint(args.seqno, 32);
    if (args.seqno === 0) {
      for (let i = 0; i < 32; i++) {
        signingMessage.storeBit(1);
      }
    } else {
      signingMessage.storeUint(args.timeout || Math.floor(Date.now() / 1e3) + 60, 32);
    }
    for (let m of args.messages) {
      signingMessage.storeUint(args.sendMode, 8);
      signingMessage.storeRef((0, core_1.beginCell)().store((0, core_1.storeMessageRelaxed)(m)));
    }
    let signature = (0, crypto_1.sign)(signingMessage.endCell().hash(), args.secretKey);
    const body = (0, core_1.beginCell)().storeBuffer(signature).storeBuilder(signingMessage).endCell();
    return body;
  }
  function createWalletTransferV3(args) {
    if (args.messages.length > 4) {
      throw Error("Maximum number of messages in a single transfer is 4");
    }
    let signingMessage = (0, core_1.beginCell)().storeUint(args.walletId, 32);
    if (args.seqno === 0) {
      for (let i = 0; i < 32; i++) {
        signingMessage.storeBit(1);
      }
    } else {
      signingMessage.storeUint(args.timeout || Math.floor(Date.now() / 1e3) + 60, 32);
    }
    signingMessage.storeUint(args.seqno, 32);
    for (let m of args.messages) {
      signingMessage.storeUint(args.sendMode, 8);
      signingMessage.storeRef((0, core_1.beginCell)().store((0, core_1.storeMessageRelaxed)(m)));
    }
    return (0, singer_1.signPayload)(args, signingMessage, packSignatureToFront);
  }
  function createWalletTransferV4(args) {
    if (args.messages.length > 4) {
      throw Error("Maximum number of messages in a single transfer is 4");
    }
    let signingMessage = (0, core_1.beginCell)().storeUint(args.walletId, 32);
    if (args.seqno === 0) {
      for (let i = 0; i < 32; i++) {
        signingMessage.storeBit(1);
      }
    } else {
      signingMessage.storeUint(args.timeout || Math.floor(Date.now() / 1e3) + 60, 32);
    }
    signingMessage.storeUint(args.seqno, 32);
    signingMessage.storeUint(0, 8);
    for (let m of args.messages) {
      signingMessage.storeUint(args.sendMode, 8);
      signingMessage.storeRef((0, core_1.beginCell)().store((0, core_1.storeMessageRelaxed)(m)));
    }
    return (0, singer_1.signPayload)(args, signingMessage, packSignatureToFront);
  }
  function createWalletTransferV5Beta(args) {
    if (args.actions.length > 255) {
      throw Error("Maximum number of OutActions in a single request is 255");
    }
    if (args.authType === "extension") {
      return (0, core_1.beginCell)().storeUint(WalletContractV5Beta_1.WalletContractV5Beta.OpCodes.auth_extension, 32).store((0, WalletV5BetaActions_1.storeOutListExtendedV5Beta)(args.actions)).endCell();
    }
    const signingMessage = (0, core_1.beginCell)().storeUint(args.authType === "internal" ? WalletContractV5Beta_1.WalletContractV5Beta.OpCodes.auth_signed_internal : WalletContractV5Beta_1.WalletContractV5Beta.OpCodes.auth_signed_external, 32).store(args.walletId);
    if (args.seqno === 0) {
      for (let i = 0; i < 32; i++) {
        signingMessage.storeBit(1);
      }
    } else {
      signingMessage.storeUint(args.timeout || Math.floor(Date.now() / 1e3) + 60, 32);
    }
    signingMessage.storeUint(args.seqno, 32).store((0, WalletV5BetaActions_1.storeOutListExtendedV5Beta)(args.actions));
    return (0, singer_1.signPayload)(args, signingMessage, packSignatureToTail);
  }
  function createWalletTransferV5R1(args) {
    if (args.actions.length > 255) {
      throw Error("Maximum number of OutActions in a single request is 255");
    }
    args = { ...args };
    if (args.authType === "extension") {
      return (0, core_1.beginCell)().storeUint(WalletContractV5R1_1.WalletContractV5R1.OpCodes.auth_extension, 32).storeUint(args.queryId ?? 0, 64).store((0, WalletV5R1Actions_1.storeOutListExtendedV5R1)(args.actions)).endCell();
    }
    args.actions = (0, WalletV5R1Actions_1.patchV5R1ActionsSendMode)(args.actions, args.authType);
    const signingMessage = (0, core_1.beginCell)().storeUint(args.authType === "internal" ? WalletContractV5R1_1.WalletContractV5R1.OpCodes.auth_signed_internal : WalletContractV5R1_1.WalletContractV5R1.OpCodes.auth_signed_external, 32).store(args.walletId);
    if (args.seqno === 0) {
      for (let i = 0; i < 32; i++) {
        signingMessage.storeBit(1);
      }
    } else {
      signingMessage.storeUint(args.timeout || Math.floor(Date.now() / 1e3) + 60, 32);
    }
    signingMessage.storeUint(args.seqno, 32).store((0, WalletV5R1Actions_1.storeOutListExtendedV5R1)(args.actions));
    return (0, singer_1.signPayload)(args, signingMessage, packSignatureToTail);
  }
  return createWalletTransfer;
}
var hasRequiredWalletContractV1R1;
function requireWalletContractV1R1() {
  if (hasRequiredWalletContractV1R1) return WalletContractV1R1;
  hasRequiredWalletContractV1R1 = 1;
  Object.defineProperty(WalletContractV1R1, "__esModule", { value: true });
  WalletContractV1R1.WalletContractV1R1 = void 0;
  const core_1 = requireDist$5();
  const createWalletTransfer_1 = requireCreateWalletTransfer();
  let WalletContractV1R1$1 = class WalletContractV1R12 {
    static create(args) {
      return new WalletContractV1R12(args.workchain, args.publicKey);
    }
    constructor(workchain, publicKey) {
      this.workchain = workchain;
      this.publicKey = publicKey;
      let code = core_1.Cell.fromBoc(Buffer.from("te6cckEBAQEARAAAhP8AIN2k8mCBAgDXGCDXCx/tRNDTH9P/0VESuvKhIvkBVBBE+RDyovgAAdMfMSDXSpbTB9QC+wDe0aTIyx/L/8ntVEH98Ik=", "base64"))[0];
      let data = (0, core_1.beginCell)().storeUint(0, 32).storeBuffer(publicKey).endCell();
      this.init = { code, data };
      this.address = (0, core_1.contractAddress)(workchain, { code, data });
    }
    /**
     * Get Wallet Balance
     */
    async getBalance(provider) {
      let state = await provider.getState();
      return state.balance;
    }
    /**
     * Get Wallet Seqno
     */
    async getSeqno(provider) {
      let state = await provider.getState();
      if (state.state.type === "active") {
        return core_1.Cell.fromBoc(state.state.data)[0].beginParse().loadUint(32);
      } else {
        return 0;
      }
    }
    /**
     * Send signed transfer
     */
    async send(provider, message) {
      await provider.external(message);
    }
    /**
     * Sign and send transfer
     */
    async sendTransfer(provider, args) {
      let transfer = this.createTransfer(args);
      await this.send(provider, transfer);
    }
    /**
     * Create signed transfer
     */
    createTransfer(args) {
      let sendMode = core_1.SendMode.PAY_GAS_SEPARATELY;
      if (args.sendMode !== null && args.sendMode !== void 0) {
        sendMode = args.sendMode;
      }
      return (0, createWalletTransfer_1.createWalletTransferV1)({
        seqno: args.seqno,
        sendMode,
        secretKey: args.secretKey,
        message: args.message
      });
    }
    /**
     * Create sender
     */
    sender(provider, secretKey) {
      return {
        send: async (args) => {
          let seqno = await this.getSeqno(provider);
          let transfer = this.createTransfer({
            seqno,
            secretKey,
            sendMode: args.sendMode,
            message: (0, core_1.internal)({
              to: args.to,
              value: args.value,
              extracurrency: args.extracurrency,
              init: args.init,
              body: args.body,
              bounce: args.bounce
            })
          });
          await this.send(provider, transfer);
        }
      };
    }
  };
  WalletContractV1R1.WalletContractV1R1 = WalletContractV1R1$1;
  return WalletContractV1R1;
}
var WalletContractV1R2 = {};
var hasRequiredWalletContractV1R2;
function requireWalletContractV1R2() {
  if (hasRequiredWalletContractV1R2) return WalletContractV1R2;
  hasRequiredWalletContractV1R2 = 1;
  Object.defineProperty(WalletContractV1R2, "__esModule", { value: true });
  WalletContractV1R2.WalletContractV1R2 = void 0;
  const core_1 = requireDist$5();
  const createWalletTransfer_1 = requireCreateWalletTransfer();
  let WalletContractV1R2$1 = class WalletContractV1R22 {
    static create(args) {
      return new WalletContractV1R22(args.workchain, args.publicKey);
    }
    constructor(workchain, publicKey) {
      this.workchain = workchain;
      this.publicKey = publicKey;
      let code = core_1.Cell.fromBoc(Buffer.from("te6cckEBAQEAUwAAov8AIN0gggFMl7qXMO1E0NcLH+Ck8mCBAgDXGCDXCx/tRNDTH9P/0VESuvKhIvkBVBBE+RDyovgAAdMfMSDXSpbTB9QC+wDe0aTIyx/L/8ntVNDieG8=", "base64"))[0];
      let data = (0, core_1.beginCell)().storeUint(0, 32).storeBuffer(publicKey).endCell();
      this.init = { code, data };
      this.address = (0, core_1.contractAddress)(workchain, { code, data });
    }
    /**
     * Get Wallet Balance
     */
    async getBalance(provider) {
      let state = await provider.getState();
      return state.balance;
    }
    /**
     * Get Wallet Seqno
     */
    async getSeqno(provider) {
      let state = await provider.getState();
      if (state.state.type === "active") {
        let res = await provider.get("seqno", []);
        return res.stack.readNumber();
      } else {
        return 0;
      }
    }
    /**
     * Send signed transfer
     */
    async send(provider, message) {
      await provider.external(message);
    }
    /**
     * Sign and send transfer
     */
    async sendTransfer(provider, args) {
      let transfer = this.createTransfer(args);
      await this.send(provider, transfer);
    }
    /**
     * Create signed transfer
     */
    createTransfer(args) {
      let sendMode = core_1.SendMode.PAY_GAS_SEPARATELY;
      if (args.sendMode !== null && args.sendMode !== void 0) {
        sendMode = args.sendMode;
      }
      return (0, createWalletTransfer_1.createWalletTransferV1)({
        seqno: args.seqno,
        sendMode,
        secretKey: args.secretKey,
        message: args.message
      });
    }
    /**
     * Create sender
     */
    sender(provider, secretKey) {
      return {
        send: async (args) => {
          let seqno = await this.getSeqno(provider);
          let transfer = this.createTransfer({
            seqno,
            secretKey,
            sendMode: args.sendMode,
            message: (0, core_1.internal)({
              to: args.to,
              value: args.value,
              extracurrency: args.extracurrency,
              init: args.init,
              body: args.body,
              bounce: args.bounce
            })
          });
          await this.send(provider, transfer);
        }
      };
    }
  };
  WalletContractV1R2.WalletContractV1R2 = WalletContractV1R2$1;
  return WalletContractV1R2;
}
var WalletContractV1R3 = {};
var hasRequiredWalletContractV1R3;
function requireWalletContractV1R3() {
  if (hasRequiredWalletContractV1R3) return WalletContractV1R3;
  hasRequiredWalletContractV1R3 = 1;
  Object.defineProperty(WalletContractV1R3, "__esModule", { value: true });
  WalletContractV1R3.WalletContractV1R3 = void 0;
  const core_1 = requireDist$5();
  const createWalletTransfer_1 = requireCreateWalletTransfer();
  let WalletContractV1R3$1 = class WalletContractV1R32 {
    static create(args) {
      return new WalletContractV1R32(args.workchain, args.publicKey);
    }
    constructor(workchain, publicKey) {
      this.workchain = workchain;
      this.publicKey = publicKey;
      let code = core_1.Cell.fromBoc(Buffer.from("te6cckEBAQEAXwAAuv8AIN0gggFMl7ohggEznLqxnHGw7UTQ0x/XC//jBOCk8mCBAgDXGCDXCx/tRNDTH9P/0VESuvKhIvkBVBBE+RDyovgAAdMfMSDXSpbTB9QC+wDe0aTIyx/L/8ntVLW4bkI=", "base64"))[0];
      let data = (0, core_1.beginCell)().storeUint(0, 32).storeBuffer(publicKey).endCell();
      this.init = { code, data };
      this.address = (0, core_1.contractAddress)(workchain, { code, data });
    }
    /**
     * Get Wallet Balance
     */
    async getBalance(provider) {
      let state = await provider.getState();
      return state.balance;
    }
    /**
     * Get Wallet Seqno
     */
    async getSeqno(provider) {
      let state = await provider.getState();
      if (state.state.type === "active") {
        let res = await provider.get("seqno", []);
        return res.stack.readNumber();
      } else {
        return 0;
      }
    }
    /**
     * Send signed transfer
     */
    async send(executor, message) {
      await executor.external(message);
    }
    /**
     * Sign and send transfer
     */
    async sendTransfer(provider, args) {
      let transfer = this.createTransfer(args);
      await this.send(provider, transfer);
    }
    /**
     * Create signed transfer
     */
    createTransfer(args) {
      let sendMode = core_1.SendMode.PAY_GAS_SEPARATELY;
      if (args.sendMode !== null && args.sendMode !== void 0) {
        sendMode = args.sendMode;
      }
      return (0, createWalletTransfer_1.createWalletTransferV1)({
        seqno: args.seqno,
        sendMode,
        secretKey: args.secretKey,
        message: args.message
      });
    }
    /**
     * Create sender
     */
    sender(provider, secretKey) {
      return {
        send: async (args) => {
          let seqno = await this.getSeqno(provider);
          let transfer = this.createTransfer({
            seqno,
            secretKey,
            sendMode: args.sendMode,
            message: (0, core_1.internal)({
              to: args.to,
              value: args.value,
              init: args.init,
              body: args.body,
              bounce: args.bounce
            })
          });
          await this.send(provider, transfer);
        }
      };
    }
  };
  WalletContractV1R3.WalletContractV1R3 = WalletContractV1R3$1;
  return WalletContractV1R3;
}
var WalletContractV2R1 = {};
var hasRequiredWalletContractV2R1;
function requireWalletContractV2R1() {
  if (hasRequiredWalletContractV2R1) return WalletContractV2R1;
  hasRequiredWalletContractV2R1 = 1;
  Object.defineProperty(WalletContractV2R1, "__esModule", { value: true });
  WalletContractV2R1.WalletContractV2R1 = void 0;
  const core_1 = requireDist$5();
  const createWalletTransfer_1 = requireCreateWalletTransfer();
  let WalletContractV2R1$1 = class WalletContractV2R12 {
    static create(args) {
      return new WalletContractV2R12(args.workchain, args.publicKey);
    }
    constructor(workchain, publicKey) {
      this.workchain = workchain;
      this.publicKey = publicKey;
      let code = core_1.Cell.fromBoc(Buffer.from("te6cckEBAQEAVwAAqv8AIN0gggFMl7qXMO1E0NcLH+Ck8mCDCNcYINMf0x8B+CO78mPtRNDTH9P/0VExuvKhA/kBVBBC+RDyovgAApMg10qW0wfUAvsA6NGkyMsfy//J7VShNwu2", "base64"))[0];
      let data = (0, core_1.beginCell)().storeUint(0, 32).storeBuffer(publicKey).endCell();
      this.init = { code, data };
      this.address = (0, core_1.contractAddress)(workchain, { code, data });
    }
    /**
     * Get Wallet Balance
     */
    async getBalance(provider) {
      let state = await provider.getState();
      return state.balance;
    }
    /**
     * Get Wallet Seqno
     */
    async getSeqno(provider) {
      let state = await provider.getState();
      if (state.state.type === "active") {
        let res = await provider.get("seqno", []);
        return res.stack.readNumber();
      } else {
        return 0;
      }
    }
    /**
     * Send signed transfer
     */
    async send(provider, message) {
      await provider.external(message);
    }
    /**
     * Sign and send transfer
     */
    async sendTransfer(provider, args) {
      let transfer = this.createTransfer(args);
      await this.send(provider, transfer);
    }
    /**
     * Create signed transfer
     */
    createTransfer(args) {
      let sendMode = core_1.SendMode.PAY_GAS_SEPARATELY;
      if (args.sendMode !== null && args.sendMode !== void 0) {
        sendMode = args.sendMode;
      }
      return (0, createWalletTransfer_1.createWalletTransferV2)({
        seqno: args.seqno,
        sendMode,
        secretKey: args.secretKey,
        messages: args.messages,
        timeout: args.timeout
      });
    }
    /**
     * Create sender
     */
    sender(provider, secretKey) {
      return {
        send: async (args) => {
          let seqno = await this.getSeqno(provider);
          let transfer = this.createTransfer({
            seqno,
            secretKey,
            sendMode: args.sendMode,
            messages: [(0, core_1.internal)({
              to: args.to,
              value: args.value,
              extracurrency: args.extracurrency,
              init: args.init,
              body: args.body,
              bounce: args.bounce
            })]
          });
          await this.send(provider, transfer);
        }
      };
    }
  };
  WalletContractV2R1.WalletContractV2R1 = WalletContractV2R1$1;
  return WalletContractV2R1;
}
var WalletContractV2R2 = {};
var hasRequiredWalletContractV2R2;
function requireWalletContractV2R2() {
  if (hasRequiredWalletContractV2R2) return WalletContractV2R2;
  hasRequiredWalletContractV2R2 = 1;
  Object.defineProperty(WalletContractV2R2, "__esModule", { value: true });
  WalletContractV2R2.WalletContractV2R2 = void 0;
  const core_1 = requireDist$5();
  const createWalletTransfer_1 = requireCreateWalletTransfer();
  let WalletContractV2R2$1 = class WalletContractV2R22 {
    static create(args) {
      return new WalletContractV2R22(args.workchain, args.publicKey);
    }
    constructor(workchain, publicKey) {
      this.workchain = workchain;
      this.publicKey = publicKey;
      let code = core_1.Cell.fromBoc(Buffer.from("te6cckEBAQEAYwAAwv8AIN0gggFMl7ohggEznLqxnHGw7UTQ0x/XC//jBOCk8mCDCNcYINMf0x8B+CO78mPtRNDTH9P/0VExuvKhA/kBVBBC+RDyovgAApMg10qW0wfUAvsA6NGkyMsfy//J7VQETNeh", "base64"))[0];
      let data = (0, core_1.beginCell)().storeUint(0, 32).storeBuffer(publicKey).endCell();
      this.init = { code, data };
      this.address = (0, core_1.contractAddress)(workchain, { code, data });
    }
    /**
     * Get Wallet Balance
     */
    async getBalance(provider) {
      let state = await provider.getState();
      return state.balance;
    }
    /**
     * Get Wallet Seqno
     */
    async getSeqno(provider) {
      let state = await provider.getState();
      if (state.state.type === "active") {
        let res = await provider.get("seqno", []);
        return res.stack.readNumber();
      } else {
        return 0;
      }
    }
    /**
     * Send signed transfer
     */
    async send(provider, message) {
      await provider.external(message);
    }
    /**
     * Sign and send transfer
     */
    async sendTransfer(provider, args) {
      let transfer = this.createTransfer(args);
      await this.send(provider, transfer);
    }
    /**
     * Create signed transfer
     */
    createTransfer(args) {
      let sendMode = core_1.SendMode.PAY_GAS_SEPARATELY;
      if (args.sendMode !== null && args.sendMode !== void 0) {
        sendMode = args.sendMode;
      }
      return (0, createWalletTransfer_1.createWalletTransferV2)({
        seqno: args.seqno,
        sendMode,
        secretKey: args.secretKey,
        messages: args.messages,
        timeout: args.timeout
      });
    }
    /**
     * Create sender
     */
    sender(provider, secretKey) {
      return {
        send: async (args) => {
          let seqno = await this.getSeqno(provider);
          let transfer = this.createTransfer({
            seqno,
            secretKey,
            sendMode: args.sendMode,
            messages: [(0, core_1.internal)({
              to: args.to,
              value: args.value,
              extracurrency: args.extracurrency,
              init: args.init,
              body: args.body,
              bounce: args.bounce
            })]
          });
          await this.send(provider, transfer);
        }
      };
    }
  };
  WalletContractV2R2.WalletContractV2R2 = WalletContractV2R2$1;
  return WalletContractV2R2;
}
var WalletContractV3R1 = {};
var hasRequiredWalletContractV3R1;
function requireWalletContractV3R1() {
  if (hasRequiredWalletContractV3R1) return WalletContractV3R1;
  hasRequiredWalletContractV3R1 = 1;
  Object.defineProperty(WalletContractV3R1, "__esModule", { value: true });
  WalletContractV3R1.WalletContractV3R1 = void 0;
  const core_1 = requireDist$5();
  const createWalletTransfer_1 = requireCreateWalletTransfer();
  let WalletContractV3R1$1 = class WalletContractV3R12 {
    static create(args) {
      return new WalletContractV3R12(args.workchain, args.publicKey, args.walletId);
    }
    constructor(workchain, publicKey, walletId) {
      this.workchain = workchain;
      this.publicKey = publicKey;
      if (walletId !== null && walletId !== void 0) {
        this.walletId = walletId;
      } else {
        this.walletId = 698983191 + workchain;
      }
      let code = core_1.Cell.fromBoc(Buffer.from("te6cckEBAQEAYgAAwP8AIN0gggFMl7qXMO1E0NcLH+Ck8mCDCNcYINMf0x/TH/gjE7vyY+1E0NMf0x/T/9FRMrryoVFEuvKiBPkBVBBV+RDyo/gAkyDXSpbTB9QC+wDo0QGkyMsfyx/L/8ntVD++buA=", "base64"))[0];
      let data = (0, core_1.beginCell)().storeUint(0, 32).storeUint(this.walletId, 32).storeBuffer(publicKey).endCell();
      this.init = { code, data };
      this.address = (0, core_1.contractAddress)(workchain, { code, data });
    }
    /**
     * Get wallet balance
     */
    async getBalance(provider) {
      let state = await provider.getState();
      return state.balance;
    }
    /**
     * Get Wallet Seqno
     */
    async getSeqno(provider) {
      let state = await provider.getState();
      if (state.state.type === "active") {
        let res = await provider.get("seqno", []);
        return res.stack.readNumber();
      } else {
        return 0;
      }
    }
    /**
     * Send signed transfer
     */
    async send(provider, message) {
      await provider.external(message);
    }
    /**
     * Sign and send transfer
     */
    async sendTransfer(provider, args) {
      let transfer = this.createTransfer(args);
      await this.send(provider, transfer);
    }
    /**
     * Create transfer
     */
    createTransfer(args) {
      return (0, createWalletTransfer_1.createWalletTransferV3)({
        ...args,
        sendMode: args.sendMode ?? core_1.SendMode.PAY_GAS_SEPARATELY,
        walletId: this.walletId
      });
    }
    /**
     * Create sender
     */
    sender(provider, secretKey) {
      return {
        send: async (args) => {
          let seqno = await this.getSeqno(provider);
          let transfer = this.createTransfer({
            seqno,
            secretKey,
            sendMode: args.sendMode,
            messages: [(0, core_1.internal)({
              to: args.to,
              value: args.value,
              extracurrency: args.extracurrency,
              init: args.init,
              body: args.body,
              bounce: args.bounce
            })]
          });
          await this.send(provider, transfer);
        }
      };
    }
  };
  WalletContractV3R1.WalletContractV3R1 = WalletContractV3R1$1;
  return WalletContractV3R1;
}
var WalletContractV3R2 = {};
var hasRequiredWalletContractV3R2;
function requireWalletContractV3R2() {
  if (hasRequiredWalletContractV3R2) return WalletContractV3R2;
  hasRequiredWalletContractV3R2 = 1;
  Object.defineProperty(WalletContractV3R2, "__esModule", { value: true });
  WalletContractV3R2.WalletContractV3R2 = void 0;
  const core_1 = requireDist$5();
  const createWalletTransfer_1 = requireCreateWalletTransfer();
  let WalletContractV3R2$1 = class WalletContractV3R22 {
    static create(args) {
      return new WalletContractV3R22(args.workchain, args.publicKey, args.walletId);
    }
    constructor(workchain, publicKey, walletId) {
      this.workchain = workchain;
      this.publicKey = publicKey;
      if (walletId !== null && walletId !== void 0) {
        this.walletId = walletId;
      } else {
        this.walletId = 698983191 + workchain;
      }
      let code = core_1.Cell.fromBoc(Buffer.from("te6cckEBAQEAcQAA3v8AIN0gggFMl7ohggEznLqxn3Gw7UTQ0x/THzHXC//jBOCk8mCDCNcYINMf0x/TH/gjE7vyY+1E0NMf0x/T/9FRMrryoVFEuvKiBPkBVBBV+RDyo/gAkyDXSpbTB9QC+wDo0QGkyMsfyx/L/8ntVBC9ba0=", "base64"))[0];
      let data = (0, core_1.beginCell)().storeUint(0, 32).storeUint(this.walletId, 32).storeBuffer(publicKey).endCell();
      this.init = { code, data };
      this.address = (0, core_1.contractAddress)(workchain, { code, data });
    }
    /**
     * Get wallet balance
     */
    async getBalance(provider) {
      let state = await provider.getState();
      return state.balance;
    }
    /**
     * Get Wallet Seqno
     */
    async getSeqno(provider) {
      let state = await provider.getState();
      if (state.state.type === "active") {
        let res = await provider.get("seqno", []);
        return res.stack.readNumber();
      } else {
        return 0;
      }
    }
    /**
     * Send signed transfer
     */
    async send(provider, message) {
      await provider.external(message);
    }
    /**
     * Sign and send transfer
     */
    async sendTransfer(provider, args) {
      let transfer = this.createTransfer(args);
      await this.send(provider, transfer);
    }
    /**
     * Create transfer
     */
    createTransfer(args) {
      return (0, createWalletTransfer_1.createWalletTransferV3)({
        ...args,
        sendMode: args.sendMode ?? core_1.SendMode.PAY_GAS_SEPARATELY,
        walletId: this.walletId
      });
    }
    /**
     * Create sender
     */
    sender(provider, secretKey) {
      return {
        send: async (args) => {
          let seqno = await this.getSeqno(provider);
          let transfer = this.createTransfer({
            seqno,
            secretKey,
            sendMode: args.sendMode,
            messages: [(0, core_1.internal)({
              to: args.to,
              value: args.value,
              extracurrency: args.extracurrency,
              init: args.init,
              body: args.body,
              bounce: args.bounce
            })]
          });
          await this.send(provider, transfer);
        }
      };
    }
  };
  WalletContractV3R2.WalletContractV3R2 = WalletContractV3R2$1;
  return WalletContractV3R2;
}
var WalletContractV4 = {};
var hasRequiredWalletContractV4;
function requireWalletContractV4() {
  if (hasRequiredWalletContractV4) return WalletContractV4;
  hasRequiredWalletContractV4 = 1;
  Object.defineProperty(WalletContractV4, "__esModule", { value: true });
  WalletContractV4.WalletContractV4 = void 0;
  const core_1 = requireDist$5();
  const createWalletTransfer_1 = requireCreateWalletTransfer();
  let WalletContractV4$1 = class WalletContractV42 {
    static create(args) {
      return new WalletContractV42(args.workchain, args.publicKey, args.walletId);
    }
    constructor(workchain, publicKey, walletId) {
      this.workchain = workchain;
      this.publicKey = publicKey;
      if (walletId !== null && walletId !== void 0) {
        this.walletId = walletId;
      } else {
        this.walletId = 698983191 + workchain;
      }
      let code = core_1.Cell.fromBoc(Buffer.from("te6ccgECFAEAAtQAART/APSkE/S88sgLAQIBIAIDAgFIBAUE+PKDCNcYINMf0x/THwL4I7vyZO1E0NMf0x/T//QE0VFDuvKhUVG68qIF+QFUEGT5EPKj+AAkpMjLH1JAyx9SMMv/UhD0AMntVPgPAdMHIcAAn2xRkyDXSpbTB9QC+wDoMOAhwAHjACHAAuMAAcADkTDjDQOkyMsfEssfy/8QERITAubQAdDTAyFxsJJfBOAi10nBIJJfBOAC0x8hghBwbHVnvSKCEGRzdHK9sJJfBeAD+kAwIPpEAcjKB8v/ydDtRNCBAUDXIfQEMFyBAQj0Cm+hMbOSXwfgBdM/yCWCEHBsdWe6kjgw4w0DghBkc3RyupJfBuMNBgcCASAICQB4AfoA9AQw+CdvIjBQCqEhvvLgUIIQcGx1Z4MesXCAGFAEywUmzxZY+gIZ9ADLaRfLH1Jgyz8gyYBA+wAGAIpQBIEBCPRZMO1E0IEBQNcgyAHPFvQAye1UAXKwjiOCEGRzdHKDHrFwgBhQBcsFUAPPFiP6AhPLassfyz/JgED7AJJfA+ICASAKCwBZvSQrb2omhAgKBrkPoCGEcNQICEekk30pkQzmkD6f+YN4EoAbeBAUiYcVnzGEAgFYDA0AEbjJftRNDXCx+AA9sp37UTQgQFA1yH0BDACyMoHy//J0AGBAQj0Cm+hMYAIBIA4PABmtznaiaEAga5Drhf/AABmvHfaiaEAQa5DrhY/AAG7SB/oA1NQi+QAFyMoHFcv/ydB3dIAYyMsFywIizxZQBfoCFMtrEszMyXP7AMhAFIEBCPRR8qcCAHCBAQjXGPoA0z/IVCBHgQEI9FHyp4IQbm90ZXB0gBjIywXLAlAGzxZQBPoCFMtqEssfyz/Jc/sAAgBsgQEI1xj6ANM/MFIkgQEI9Fnyp4IQZHN0cnB0gBjIywXLAlAFzxZQA/oCE8tqyx8Syz/Jc/sAAAr0AMntVA==", "base64"))[0];
      let data = (0, core_1.beginCell)().storeUint(0, 32).storeUint(this.walletId, 32).storeBuffer(this.publicKey).storeBit(0).endCell();
      this.init = { code, data };
      this.address = (0, core_1.contractAddress)(workchain, { code, data });
    }
    /**
     * Get Wallet Balance
     */
    async getBalance(provider) {
      let state = await provider.getState();
      return state.balance;
    }
    /**
     * Get Wallet Seqno
     */
    async getSeqno(provider) {
      let state = await provider.getState();
      if (state.state.type === "active") {
        let res = await provider.get("seqno", []);
        return res.stack.readNumber();
      } else {
        return 0;
      }
    }
    /**
     * Send signed transfer
     */
    async send(provider, message) {
      await provider.external(message);
    }
    /**
     * Sign and send transfer
     */
    async sendTransfer(provider, args) {
      let transfer = this.createTransfer(args);
      await this.send(provider, transfer);
    }
    /**
     * Create signed transfer
     */
    createTransfer(args) {
      return (0, createWalletTransfer_1.createWalletTransferV4)({
        ...args,
        sendMode: args.sendMode ?? core_1.SendMode.PAY_GAS_SEPARATELY,
        walletId: this.walletId
      });
    }
    /**
     * Create sender
     */
    sender(provider, secretKey) {
      return {
        send: async (args) => {
          let seqno = await this.getSeqno(provider);
          let transfer = this.createTransfer({
            seqno,
            secretKey,
            sendMode: args.sendMode,
            messages: [(0, core_1.internal)({
              to: args.to,
              value: args.value,
              extracurrency: args.extracurrency,
              init: args.init,
              body: args.body,
              bounce: args.bounce
            })]
          });
          await this.send(provider, transfer);
        }
      };
    }
  };
  WalletContractV4.WalletContractV4 = WalletContractV4$1;
  return WalletContractV4;
}
var WalletContractV5Beta = {};
var hasRequiredWalletContractV5Beta;
function requireWalletContractV5Beta() {
  if (hasRequiredWalletContractV5Beta) return WalletContractV5Beta;
  hasRequiredWalletContractV5Beta = 1;
  (function(exports) {
    var __createBinding = WalletContractV5Beta && WalletContractV5Beta.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = WalletContractV5Beta && WalletContractV5Beta.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(requireWalletContractV5Beta$1(), exports);
    __exportStar(requireWalletV5BetaActions(), exports);
    __exportStar(requireWalletV5BetaWalletId(), exports);
  })(WalletContractV5Beta);
  return WalletContractV5Beta;
}
var WalletContractV5R1 = {};
var hasRequiredWalletContractV5R1;
function requireWalletContractV5R1() {
  if (hasRequiredWalletContractV5R1) return WalletContractV5R1;
  hasRequiredWalletContractV5R1 = 1;
  (function(exports) {
    var __createBinding = WalletContractV5R1 && WalletContractV5R1.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = WalletContractV5R1 && WalletContractV5R1.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(requireWalletContractV5R1$1(), exports);
    __exportStar(requireWalletV5R1Actions(), exports);
    __exportStar(requireWalletV5R1WalletId(), exports);
  })(WalletContractV5R1);
  return WalletContractV5R1;
}
var JettonMaster = {};
var hasRequiredJettonMaster;
function requireJettonMaster() {
  if (hasRequiredJettonMaster) return JettonMaster;
  hasRequiredJettonMaster = 1;
  Object.defineProperty(JettonMaster, "__esModule", { value: true });
  JettonMaster.JettonMaster = void 0;
  const core_1 = requireDist$5();
  let JettonMaster$1 = class JettonMaster2 {
    static create(address) {
      return new JettonMaster2(address);
    }
    constructor(address) {
      this.address = address;
    }
    async getWalletAddress(provider, owner) {
      let res = await provider.get("get_wallet_address", [{ type: "slice", cell: (0, core_1.beginCell)().storeAddress(owner).endCell() }]);
      return res.stack.readAddress();
    }
    async getJettonData(provider) {
      let res = await provider.get("get_jetton_data", []);
      let totalSupply = res.stack.readBigNumber();
      let mintable = res.stack.readBoolean();
      let adminAddress = res.stack.readAddress();
      let content2 = res.stack.readCell();
      let walletCode = res.stack.readCell();
      return {
        totalSupply,
        mintable,
        adminAddress,
        content: content2,
        walletCode
      };
    }
  };
  JettonMaster.JettonMaster = JettonMaster$1;
  return JettonMaster;
}
var JettonWallet = {};
var hasRequiredJettonWallet;
function requireJettonWallet() {
  if (hasRequiredJettonWallet) return JettonWallet;
  hasRequiredJettonWallet = 1;
  Object.defineProperty(JettonWallet, "__esModule", { value: true });
  JettonWallet.JettonWallet = void 0;
  let JettonWallet$12 = class JettonWallet2 {
    static create(address) {
      return new JettonWallet2(address);
    }
    constructor(address) {
      this.address = address;
    }
    async getBalance(provider) {
      let state = await provider.getState();
      if (state.state.type !== "active") {
        return 0n;
      }
      let res = await provider.get("get_wallet_data", []);
      return res.stack.readBigNumber();
    }
  };
  JettonWallet.JettonWallet = JettonWallet$12;
  return JettonWallet;
}
var MultisigOrder = {};
var hasRequiredMultisigOrder;
function requireMultisigOrder() {
  if (hasRequiredMultisigOrder) return MultisigOrder;
  hasRequiredMultisigOrder = 1;
  Object.defineProperty(MultisigOrder, "__esModule", { value: true });
  MultisigOrder.MultisigOrder = void 0;
  const crypto_1 = requireDist$6();
  const core_1 = requireDist$5();
  let MultisigOrder$1 = class MultisigOrder2 {
    constructor(payload) {
      this.signatures = {};
      this.payload = payload;
    }
    static fromCell(cell) {
      let s = cell.beginParse();
      let signatures = s.loadMaybeRef()?.beginParse();
      const messagesCell = s.asCell();
      let order = new MultisigOrder2(messagesCell);
      if (signatures) {
        while (signatures.remainingBits > 0) {
          const signature = signatures.loadBuffer(64);
          const ownerId = signatures.loadUint(8);
          order.signatures[ownerId] = signature;
          if (signatures.remainingRefs > 0) {
            signatures = signatures.loadRef().asSlice();
          } else {
            signatures.skip(1);
          }
        }
        signatures.endParse();
      }
      return order;
    }
    static fromPayload(payload) {
      return new MultisigOrder2(payload);
    }
    addSignature(ownerId, signature, multisig) {
      const signingHash = this.payload.hash();
      if (!(0, crypto_1.signVerify)(signingHash, signature, multisig.owners.get(ownerId).slice(0, -1))) {
        throw Error("invalid signature");
      }
      this.signatures[ownerId] = signature;
    }
    sign(ownerId, secretKey) {
      const signingHash = this.payload.hash();
      this.signatures[ownerId] = (0, crypto_1.sign)(signingHash, secretKey);
      return signingHash;
    }
    unionSignatures(other) {
      this.signatures = Object.assign({}, this.signatures, other.signatures);
    }
    clearSignatures() {
      this.signatures = {};
    }
    toCell(ownerId) {
      let b = (0, core_1.beginCell)().storeBit(0);
      for (const ownerId2 in this.signatures) {
        const signature = this.signatures[ownerId2];
        b = (0, core_1.beginCell)().storeBit(1).storeRef((0, core_1.beginCell)().storeBuffer(signature).storeUint(parseInt(ownerId2), 8).storeBuilder(b).endCell());
      }
      return (0, core_1.beginCell)().storeUint(ownerId, 8).storeBuilder(b).storeBuilder(this.payload.asBuilder()).endCell();
    }
  };
  MultisigOrder.MultisigOrder = MultisigOrder$1;
  return MultisigOrder;
}
var MultisigOrderBuilder = {};
var hasRequiredMultisigOrderBuilder;
function requireMultisigOrderBuilder() {
  if (hasRequiredMultisigOrderBuilder) return MultisigOrderBuilder;
  hasRequiredMultisigOrderBuilder = 1;
  Object.defineProperty(MultisigOrderBuilder, "__esModule", { value: true });
  MultisigOrderBuilder.MultisigOrderBuilder = void 0;
  const core_1 = requireDist$5();
  const MultisigOrder_1 = requireMultisigOrder();
  let MultisigOrderBuilder$1 = class MultisigOrderBuilder {
    constructor(walletId, offset) {
      this.messages = (0, core_1.beginCell)();
      this.queryId = 0n;
      this.walletId = walletId;
      this.queryOffset = offset || 7200;
    }
    addMessage(message, mode) {
      if (this.messages.refs >= 4) {
        throw Error("only 4 refs are allowed");
      }
      this.updateQueryId();
      this.messages.storeUint(mode, 8);
      this.messages.storeRef((0, core_1.beginCell)().store((0, core_1.storeMessageRelaxed)(message)).endCell());
    }
    clearMessages() {
      this.messages = (0, core_1.beginCell)();
    }
    build() {
      return MultisigOrder_1.MultisigOrder.fromPayload((0, core_1.beginCell)().storeUint(this.walletId, 32).storeUint(this.queryId, 64).storeBuilder(this.messages).endCell());
    }
    updateQueryId() {
      const time = BigInt(Math.floor(Date.now() / 1e3 + this.queryOffset));
      this.queryId = time << 32n;
    }
  };
  MultisigOrderBuilder.MultisigOrderBuilder = MultisigOrderBuilder$1;
  return MultisigOrderBuilder;
}
var MultisigWallet = {};
var hasRequiredMultisigWallet;
function requireMultisigWallet() {
  if (hasRequiredMultisigWallet) return MultisigWallet;
  hasRequiredMultisigWallet = 1;
  Object.defineProperty(MultisigWallet, "__esModule", { value: true });
  MultisigWallet.MultisigWallet = void 0;
  const crypto_1 = requireDist$6();
  const core_1 = requireDist$5();
  const MULTISIG_CODE = core_1.Cell.fromBase64("te6ccgECKwEABBgAART/APSkE/S88sgLAQIBIAIDAgFIBAUE2vIgxwCOgzDbPOCDCNcYIPkBAdMH2zwiwAAToVNxePQOb6Hyn9s8VBq6+RDyoAb0BCD5AQHTH1EYuvKq0z9wUwHwCgHCCAGDCryx8mhTFYBA9A5voSCYDqQgwgryZw7f+COqH1NAufJhVCOjU04gIyEiAgLMBgcCASAMDQIBIAgJAgFmCgsAA9GEAiPymAvHoHN9CYbZ5S7Z4BPHohwhJQAtAKkItdJEqCTItdKlwLUAdAT8ArobBKAATwhbpEx4CBukTDgAdAg10rDAJrUAvALyFjPFszJ4HHXI8gBzxb0AMmACASAODwIBIBQVARW77ZbVA0cFUg2zyCoCAUgQEQIBIBITAXOxHXQgwjXGCD5AQHTB4IB1MTtQ9hTIHj0Dm+h8p/XC/9eMfkQ8qCuAfQEIW6TW3Ey4PkBWNs8AaQBgJwA9rtqA6ADoAPoCAXoCEfyAgPyA3XlP+AXkegAA54tkwAAXrhlXP8EA1WZ2oexAAgEgFhcCASAYGQFRtyVbZ4YmRmpGEAgegc30McJNhFpAADMaYeYuAFrgJhwLb+4cC3d0bhAjAYm1WZtnhqvgb+2xxsoicAgej430pBHEoFpAADHDhBACGuQkuuBk9kUWE5kAOeLKhACQCB6IYFImHFImHFImXEA2YlzNijAjAgEgGhsAF7UGtc4QQDVZnah7EAIBIBwdAgOZOB4fARGsGm2eL4G2CUAjABWt+UEAzJV2oewYQAENqTbPBVfBYCMAFa3f3CCAarM7UPYgAiDbPALyZfgAUENxQxPbPO1UIyoACtP/0wcwBKDbPC+uUyCw8mISsQKkJbNTHLmwJYEA4aojoCi8sPJpggGGoPgBBZcCERACPj4wjo0REB/bPEDXePRDEL0F4lQWW1Rz51YQU9zbPFRxClR6vCQlKCYAIO1E0NMf0wfTB9M/9AT0BNEAXgGOGjDSAAHyo9MH0wdQA9cBIPkBBfkBFbrypFAD4GwhIddKqgIi10m68qtwVCATAAwByMv/ywcE1ts87VT4D3AlblOJvrGYEG4QLVDHXwePGzBUJANQTds8UFWgRlAQSRA6SwlTuds8UFQWf+L4AAeDJaGOLCaAQPSWb6UglDBTA7neII4WODk5CNIAAZfTBzAW8AcFkTDifwgHBZJsMeKz5jAGKicoKQBgcI4pA9CDCNcY0wf0BDBTFnj0Dm+h8qXXC/9URUT5EPKmrlIgsVIDvRShI27mbCIyAH5SML6OIF8D+ACTItdKmALTB9QC+wAC6DJwyMoAQBSAQPRDAvAHjhdxyMsAFMsHEssHWM8BWM8WQBOAQPRDAeIBII6KEEUQNEMA2zztVJJfBuIqABzIyx/LB8sHyz/0APQAyQ==");
  let MultisigWallet$1 = class MultisigWallet2 {
    constructor(publicKeys, workchain, walletId, k, opts) {
      this.provider = null;
      this.owners = core_1.Dictionary.empty();
      this.workchain = workchain;
      this.walletId = walletId;
      this.k = k;
      for (let i = 0; i < publicKeys.length; i += 1) {
        this.owners.set(i, Buffer.concat([publicKeys[i], Buffer.alloc(1)]));
      }
      this.init = {
        code: MULTISIG_CODE,
        data: (0, core_1.beginCell)().storeUint(this.walletId, 32).storeUint(this.owners.size, 8).storeUint(this.k, 8).storeUint(0, 64).storeDict(this.owners, core_1.Dictionary.Keys.Uint(8), core_1.Dictionary.Values.Buffer(33)).storeBit(0).endCell()
      };
      this.address = opts?.address || (0, core_1.contractAddress)(workchain, this.init);
      if (opts?.provider) {
        this.provider = opts.provider;
      } else if (opts?.client) {
        this.provider = opts.client.provider(this.address, {
          code: this.init.code,
          data: this.init.data
        });
      }
    }
    static async fromAddress(address, opts) {
      let provider;
      if (opts.provider) {
        provider = opts.provider;
      } else {
        if (!opts.client) {
          throw Error("Either provider or client must be specified");
        }
        provider = opts.client.provider(address, {
          code: null,
          data: null
        });
      }
      const contractState = (await provider.getState()).state;
      if (contractState.type !== "active") {
        throw Error("Contract must be active");
      }
      const data = core_1.Cell.fromBoc(contractState.data)[0].beginParse();
      const walletId = data.loadUint(32);
      data.skip(8);
      const k = data.loadUint(8);
      data.skip(64);
      const owners = data.loadDict(core_1.Dictionary.Keys.Uint(8), core_1.Dictionary.Values.Buffer(33));
      let publicKeys = [];
      for (const [key2, value] of owners) {
        const publicKey = value.subarray(0, 32);
        publicKeys.push(publicKey);
      }
      return new MultisigWallet2(publicKeys, address.workChain, walletId, k, {
        address,
        provider,
        client: opts.client
      });
    }
    async deployExternal(provider) {
      if (!provider && !this.provider) {
        throw Error("you must specify provider if there is no such property in MultisigWallet instance");
      }
      if (!provider) {
        provider = this.provider;
      }
      await provider.external(core_1.Cell.EMPTY);
    }
    async deployInternal(sender, value = 1000000000n) {
      await sender.send({
        sendMode: core_1.SendMode.PAY_GAS_SEPARATELY + core_1.SendMode.IGNORE_ERRORS,
        to: this.address,
        value,
        init: this.init,
        body: core_1.Cell.EMPTY,
        bounce: true
      });
    }
    async sendOrder(order, secretKey, provider) {
      if (!provider && !this.provider) {
        throw Error("you must specify provider if there is no such property in MultisigWallet instance");
      }
      if (!provider) {
        provider = this.provider;
      }
      let publicKey = (0, crypto_1.keyPairFromSecretKey)(secretKey).publicKey;
      let ownerId = this.getOwnerIdByPubkey(publicKey);
      let cell = order.toCell(ownerId);
      let signature = (0, crypto_1.sign)(cell.hash(), secretKey);
      cell = (0, core_1.beginCell)().storeBuffer(signature).storeSlice(cell.asSlice()).endCell();
      await provider.external(cell);
    }
    async sendOrderWithoutSecretKey(order, signature, ownerId, provider) {
      if (!provider && !this.provider) {
        throw Error("you must specify provider if there is no such property in MultisigWallet instance");
      }
      if (!provider) {
        provider = this.provider;
      }
      let cell = order.toCell(ownerId);
      cell = (0, core_1.beginCell)().storeBuffer(signature).storeSlice(cell.asSlice()).endCell();
      await provider.external(cell);
    }
    getOwnerIdByPubkey(publicKey) {
      for (const [key2, value] of this.owners) {
        if (value.subarray(0, 32).equals(publicKey)) {
          return key2;
        }
      }
      throw Error("public key is not an owner");
    }
  };
  MultisigWallet.MultisigWallet = MultisigWallet$1;
  return MultisigWallet;
}
var ElectorContract = {};
var hasRequiredElectorContract;
function requireElectorContract() {
  if (hasRequiredElectorContract) return ElectorContract;
  hasRequiredElectorContract = 1;
  Object.defineProperty(ElectorContract, "__esModule", { value: true });
  ElectorContract.ElectorContract = void 0;
  const core_1 = requireDist$5();
  const FrozenDictValue = {
    serialize(src2, builder2) {
      throw Error("not implemented");
    },
    parse(src2) {
      const address = new core_1.Address(-1, src2.loadBuffer(32));
      const weight = src2.loadUintBig(64);
      const stake = src2.loadCoins();
      return { address, weight, stake };
    }
  };
  const EntitiesDictValue = {
    serialize(src2, builder2) {
      throw Error("not implemented");
    },
    parse(src2) {
      const stake = src2.loadCoins();
      src2.skip(64);
      const address = new core_1.Address(-1, src2.loadBuffer(32));
      const adnl = src2.loadBuffer(32);
      return { stake, address, adnl };
    }
  };
  let ElectorContract$1 = class ElectorContract2 {
    //readonly source: ContractSource = new UnknownContractSource('org.ton.elector', -1, 'Elector Contract');
    static create() {
      return new ElectorContract2();
    }
    constructor() {
      this.address = core_1.Address.parseRaw("-1:3333333333333333333333333333333333333333333333333333333333333333");
    }
    async getReturnedStake(provider, address) {
      if (address.workChain !== -1) {
        throw Error("Only masterchain addresses could have stake");
      }
      const res = await provider.get("compute_returned_stake", [{ type: "int", value: BigInt("0x" + address.hash.toString("hex")) }]);
      return res.stack.readBigNumber();
    }
    async getPastElectionsList(provider) {
      const res = await provider.get("past_elections_list", []);
      const electionsListRaw = new core_1.TupleReader(res.stack.readLispList());
      const elections = [];
      while (electionsListRaw.remaining > 0) {
        const electionsListEntry = electionsListRaw.readTuple();
        const id = electionsListEntry.readNumber();
        const unfreezeAt = electionsListEntry.readNumber();
        electionsListEntry.pop();
        const stakeHeld = electionsListEntry.readNumber();
        elections.push({ id, unfreezeAt, stakeHeld });
      }
      return elections;
    }
    async getPastElections(provider) {
      const res = await provider.get("past_elections", []);
      const electionsRaw = new core_1.TupleReader(res.stack.readLispList());
      const elections = [];
      while (electionsRaw.remaining > 0) {
        const electionsEntry = electionsRaw.readTuple();
        const id = electionsEntry.readNumber();
        const unfreezeAt = electionsEntry.readNumber();
        const stakeHeld = electionsEntry.readNumber();
        electionsEntry.pop();
        const frozenDict = electionsEntry.readCell();
        const totalStake = electionsEntry.readBigNumber();
        const bonuses = electionsEntry.readBigNumber();
        let frozen = /* @__PURE__ */ new Map();
        const frozenData = frozenDict.beginParse().loadDictDirect(core_1.Dictionary.Keys.Buffer(32), FrozenDictValue);
        for (const [key2, value] of frozenData) {
          frozen.set(BigInt("0x" + key2.toString("hex")).toString(10), { address: value["address"], weight: value["weight"], stake: value["stake"] });
        }
        elections.push({ id, unfreezeAt, stakeHeld, totalStake, bonuses, frozen });
      }
      return elections;
    }
    async getElectionEntities(provider) {
      const account = await provider.getState();
      if (account.state.type !== "active") {
        throw Error("Unexpected error");
      }
      const cell = core_1.Cell.fromBoc(account.state.data)[0];
      const cs = cell.beginParse();
      if (!cs.loadBit()) {
        return null;
      }
      const sc = cs.loadRef().beginParse();
      const startWorkTime = sc.loadUint(32);
      const endElectionsTime = sc.loadUint(32);
      const minStake = sc.loadCoins();
      const allStakes = sc.loadCoins();
      const entitiesData = sc.loadDict(core_1.Dictionary.Keys.Buffer(32), EntitiesDictValue);
      let entities = [];
      if (entitiesData) {
        for (const [key2, value] of entitiesData) {
          entities.push({ pubkey: key2, stake: value["stake"], address: value["address"], adnl: value["adnl"] });
        }
      }
      return { minStake, allStakes, endElectionsTime, startWorkTime, entities };
    }
    // possible code for fetching data via get method if it is possible to set gas limit by request
    // async getElectionEntities(block: number) {
    //     const res = await this.client.runMethod(block, this.address, 'participant_list_extended');
    //     if (res.exitCode !== 0 && res.exitCode !== 1) {
    //         throw Error('Exit code: ' + res.exitCode);
    //     }
    //     let tuple = new TupleReader(res.result);
    //     const startWorkTime = tuple.readNumber();
    //     const endElectionsTime = tuple.readNumber();
    //     const minStake = tuple.readBigNumber();
    //     const allStakes = tuple.readBigNumber();
    //     let entriesTuple = tuple.readTuple();
    //     const entriesRaw = new TupleReader(entriesTuple.readLispList());
    //     let entities: { pubkey: Buffer, stake: bigint, address: Address, adnl: Buffer }[] = [];
    //     while (entriesRaw.remaining > 0) {
    //         const electionsEntry = entriesRaw.readTuple();
    //         const pubkey = electionsEntry.readBuffer();
    //         const stake = electionsEntry.readBigNumber();
    //         const address = electionsEntry.readAddress();
    //         const adnl = electionsEntry.readBuffer();
    //         entities.push({ pubkey, stake, address, adnl });
    //     }
    //     return { minStake, allStakes, endElectionsTime, startWorkTime, entities };
    // }
    async getActiveElectionId(provider) {
      const res = await provider.get("active_election_id", []);
      const electionId = res.stack.readNumber();
      return electionId > 0 ? electionId : null;
    }
    async getComplaints(provider, electionId) {
      const b = new core_1.TupleBuilder();
      b.writeNumber(electionId);
      const res = await provider.get("list_complaints", b.build());
      if (res.stack.peek().type === "null") {
        return [];
      }
      const complaintsRaw = new core_1.TupleReader(res.stack.readLispList());
      const results = [];
      while (complaintsRaw.remaining > 0) {
        const complaintsEntry = complaintsRaw.readTuple();
        const id = complaintsEntry.readBigNumber();
        const completeUnpackedComplaint = complaintsEntry.readTuple();
        const unpackedComplaints = completeUnpackedComplaint.readTuple();
        const publicKey = Buffer.from(unpackedComplaints.readBigNumber().toString(16), "hex");
        unpackedComplaints.readCell();
        const createdAt = unpackedComplaints.readNumber();
        const severity = unpackedComplaints.readNumber();
        const rewardAddress = new core_1.Address(-1, Buffer.from(unpackedComplaints.readBigNumber().toString(16), "hex"));
        const paid = unpackedComplaints.readBigNumber();
        const suggestedFine = unpackedComplaints.readBigNumber();
        const suggestedFinePart = unpackedComplaints.readBigNumber();
        const votes = [];
        const votersListRaw = new core_1.TupleReader(completeUnpackedComplaint.readLispList());
        while (votersListRaw.remaining > 0) {
          votes.push(votersListRaw.readNumber());
        }
        const vsetId = completeUnpackedComplaint.readBigNumber();
        const remainingWeight = completeUnpackedComplaint.readBigNumber();
        results.push({
          id,
          publicKey,
          createdAt,
          severity,
          paid,
          suggestedFine,
          suggestedFinePart,
          rewardAddress,
          votes,
          remainingWeight,
          vsetId
        });
      }
      return results;
    }
  };
  ElectorContract.ElectorContract = ElectorContract$1;
  return ElectorContract;
}
var ConfigParser = {};
var hasRequiredConfigParser;
function requireConfigParser() {
  if (hasRequiredConfigParser) return ConfigParser;
  hasRequiredConfigParser = 1;
  Object.defineProperty(ConfigParser, "__esModule", { value: true });
  ConfigParser.configParseMasterAddress = configParseMasterAddress;
  ConfigParser.parseValidatorSet = parseValidatorSet;
  ConfigParser.parseBridge = parseBridge;
  ConfigParser.configParseMasterAddressRequired = configParseMasterAddressRequired;
  ConfigParser.configParse5 = configParse5;
  ConfigParser.configParse13 = configParse13;
  ConfigParser.configParse15 = configParse15;
  ConfigParser.configParse16 = configParse16;
  ConfigParser.configParse17 = configParse17;
  ConfigParser.configParse18 = configParse18;
  ConfigParser.configParse8 = configParse8;
  ConfigParser.configParse40 = configParse40;
  ConfigParser.configParseWorkchainDescriptor = configParseWorkchainDescriptor;
  ConfigParser.configParse12 = configParse12;
  ConfigParser.configParseValidatorSet = configParseValidatorSet;
  ConfigParser.configParseBridge = configParseBridge;
  ConfigParser.configParseGasLimitsPrices = configParseGasLimitsPrices;
  ConfigParser.configParseMsgPrices = configParseMsgPrices;
  ConfigParser.configParse28 = configParse28;
  ConfigParser.configParse29 = configParse29;
  ConfigParser.parseProposalSetup = parseProposalSetup;
  ConfigParser.parseVotingSetup = parseVotingSetup;
  ConfigParser.loadConfigParamById = loadConfigParamById;
  ConfigParser.loadConfigParamsAsSlice = loadConfigParamsAsSlice;
  ConfigParser.parseFullConfig = parseFullConfig;
  const core_1 = requireDist$5();
  function configParseMasterAddress(slice) {
    if (slice) {
      return new core_1.Address(-1, slice.loadBuffer(32));
    } else {
      return null;
    }
  }
  function readPublicKey(slice) {
    if (slice.loadUint(32) !== 2390828938) {
      throw Error("Invalid config");
    }
    return slice.loadBuffer(32);
  }
  const ValidatorDescriptionDictValue = {
    serialize(src2, builder2) {
      throw Error("not implemented");
    },
    parse(src2) {
      const header = src2.loadUint(8);
      if (header === 83) {
        return {
          publicKey: readPublicKey(src2),
          weight: src2.loadUintBig(64),
          adnlAddress: null
        };
      } else if (header === 115) {
        return {
          publicKey: readPublicKey(src2),
          weight: src2.loadUintBig(64),
          adnlAddress: src2.loadBuffer(32)
        };
      } else {
        throw Error("Invalid config");
      }
    }
  };
  function parseValidatorSet(slice) {
    const header = slice.loadUint(8);
    if (header === 17) {
      const timeSince = slice.loadUint(32);
      const timeUntil = slice.loadUint(32);
      const total = slice.loadUint(16);
      const main2 = slice.loadUint(16);
      const list = slice.loadDictDirect(core_1.Dictionary.Keys.Uint(16), ValidatorDescriptionDictValue);
      return {
        timeSince,
        timeUntil,
        total,
        main: main2,
        totalWeight: null,
        list
      };
    } else if (header === 18) {
      const timeSince = slice.loadUint(32);
      const timeUntil = slice.loadUint(32);
      const total = slice.loadUint(16);
      const main2 = slice.loadUint(16);
      const totalWeight = slice.loadUintBig(64);
      const list = slice.loadDict(core_1.Dictionary.Keys.Uint(16), ValidatorDescriptionDictValue);
      return {
        timeSince,
        timeUntil,
        total,
        main: main2,
        totalWeight,
        list
      };
    }
  }
  function parseBridge(slice) {
    const bridgeAddress = new core_1.Address(-1, slice.loadBuffer(32));
    const oracleMultisigAddress = new core_1.Address(-1, slice.loadBuffer(32));
    const oraclesDict = slice.loadDict(core_1.Dictionary.Keys.Buffer(32), core_1.Dictionary.Values.Buffer(32));
    const oracles = /* @__PURE__ */ new Map();
    for (const [local, remote] of oraclesDict) {
      oracles.set(new core_1.Address(-1, local).toString(), remote);
    }
    const externalChainAddress = slice.loadBuffer(32);
    return {
      bridgeAddress,
      oracleMultisigAddress,
      oracles,
      externalChainAddress
    };
  }
  function configParseMasterAddressRequired(slice) {
    if (!slice) {
      throw Error("Invalid config");
    }
    return configParseMasterAddress(slice);
  }
  function configParse5(slice) {
    if (!slice) {
      throw Error("Invalid config");
    }
    const magic = slice.loadUint(8);
    if (magic === 1) {
      const blackholeAddr = slice.loadBit() ? new core_1.Address(-1, slice.loadBuffer(32)) : null;
      const feeBurnNominator = slice.loadUint(32);
      const feeBurnDenominator = slice.loadUint(32);
      return {
        blackholeAddr,
        feeBurnNominator,
        feeBurnDenominator
      };
    }
    throw new Error("Invalid config");
  }
  function configParse13(slice) {
    if (!slice) {
      throw Error("Invalid config");
    }
    const magic = slice.loadUint(8);
    if (magic === 26) {
      const deposit = slice.loadCoins();
      const bitPrice = slice.loadCoins();
      const cellPrice = slice.loadCoins();
      return {
        deposit,
        bitPrice,
        cellPrice
      };
    }
    throw new Error("Invalid config");
  }
  function configParse15(slice) {
    if (!slice) {
      throw Error("Invalid config");
    }
    const validatorsElectedFor = slice.loadUint(32);
    const electorsStartBefore = slice.loadUint(32);
    const electorsEndBefore = slice.loadUint(32);
    const stakeHeldFor = slice.loadUint(32);
    return {
      validatorsElectedFor,
      electorsStartBefore,
      electorsEndBefore,
      stakeHeldFor
    };
  }
  function configParse16(slice) {
    if (!slice) {
      throw Error("Invalid config");
    }
    const maxValidators = slice.loadUint(16);
    const maxMainValidators = slice.loadUint(16);
    const minValidators = slice.loadUint(16);
    return {
      maxValidators,
      maxMainValidators,
      minValidators
    };
  }
  function configParse17(slice) {
    if (!slice) {
      throw Error("Invalid config");
    }
    const minStake = slice.loadCoins();
    const maxStake = slice.loadCoins();
    const minTotalStake = slice.loadCoins();
    const maxStakeFactor = slice.loadUint(32);
    return {
      minStake,
      maxStake,
      minTotalStake,
      maxStakeFactor
    };
  }
  const StoragePricesDictValue = {
    serialize(src2, builder2) {
      throw Error("not implemented");
    },
    parse(src2) {
      const header = src2.loadUint(8);
      if (header !== 204) {
        throw Error("Invalid config");
      }
      const utime_since = src2.loadUint(32);
      const bit_price_ps = src2.loadUintBig(64);
      const cell_price_ps = src2.loadUintBig(64);
      const mc_bit_price_ps = src2.loadUintBig(64);
      const mc_cell_price_ps = src2.loadUintBig(64);
      return {
        utime_since,
        bit_price_ps,
        cell_price_ps,
        mc_bit_price_ps,
        mc_cell_price_ps
      };
    }
  };
  function configParse18(slice) {
    if (!slice) {
      throw Error("Invalid config");
    }
    return slice.loadDictDirect(core_1.Dictionary.Keys.Buffer(4), StoragePricesDictValue).values();
  }
  function configParse8(slice) {
    if (!slice) {
      return {
        version: 0,
        capabilities: 0n
      };
    }
    const version2 = slice.loadUint(32);
    const capabilities = slice.loadUintBig(64);
    return {
      version: version2,
      capabilities
    };
  }
  function configParse40(slice) {
    if (!slice) {
      return null;
    }
    const header = slice.loadUint(8);
    if (header !== 1) {
      throw Error("Invalid config");
    }
    const defaultFlatFine = slice.loadCoins();
    const defaultProportionaFine = slice.loadCoins();
    const severityFlatMult = slice.loadUint(16);
    const severityProportionalMult = slice.loadUint(16);
    const unfunishableInterval = slice.loadUint(16);
    const longInterval = slice.loadUint(16);
    const longFlatMult = slice.loadUint(16);
    const longProportionalMult = slice.loadUint(16);
    const mediumInterval = slice.loadUint(16);
    const mediumFlatMult = slice.loadUint(16);
    const mediumProportionalMult = slice.loadUint(16);
    return {
      defaultFlatFine,
      defaultProportionaFine,
      severityFlatMult,
      severityProportionalMult,
      unfunishableInterval,
      longInterval,
      longFlatMult,
      longProportionalMult,
      mediumInterval,
      mediumFlatMult,
      mediumProportionalMult
    };
  }
  function configParseWorkchainDescriptor(slice) {
    const constructorTag = slice.loadUint(8);
    if (!(constructorTag == 166 || constructorTag == 167)) {
      throw Error("Invalid config");
    }
    const enabledSince = slice.loadUint(32);
    const actialMinSplit = slice.loadUint(8);
    const min_split = slice.loadUint(8);
    const max_split = slice.loadUint(8);
    const basic = slice.loadBit();
    const active = slice.loadBit();
    const accept_msgs = slice.loadBit();
    const flags = slice.loadUint(13);
    const zerostateRootHash = slice.loadBuffer(32);
    const zerostateFileHash = slice.loadBuffer(32);
    const version2 = slice.loadUint(32);
    if (!slice.loadUint(4)) {
      throw Error("Invalid config");
    }
    const vmVersion = slice.loadInt(32);
    const vmMode = slice.loadUintBig(64);
    let extension = void 0;
    if (constructorTag == 167) {
      const splitMergeTimings = parseWorkchainSplitMergeTimings(slice);
      const stateSplitDepth = slice.loadUint(8);
      if (stateSplitDepth > 63) {
        throw RangeError(`Invalid persistent_state_split_depth: ${stateSplitDepth} expected <= 63`);
      }
      extension = {
        split_merge_timings: splitMergeTimings,
        persistent_state_split_depth: stateSplitDepth
      };
    }
    return {
      enabledSince,
      actialMinSplit,
      min_split,
      max_split,
      basic,
      active,
      accept_msgs,
      flags,
      zerostateRootHash,
      zerostateFileHash,
      version: version2,
      format: {
        vmVersion,
        vmMode
      },
      workchain_v2: extension
    };
  }
  function parseWorkchainSplitMergeTimings(slice) {
    if (slice.loadUint(4) !== 0) {
      throw Error(`Invalid WcSplitMergeTimings tag expected 0!`);
    }
    return {
      split_merge_delay: slice.loadUint(32),
      split_merge_interval: slice.loadUint(32),
      min_split_merge_interval: slice.loadUint(32),
      max_split_merge_delay: slice.loadUint(32)
    };
  }
  const WorkchainDescriptorDictValue = {
    serialize(src2, builder2) {
      throw Error("not implemented");
    },
    parse(src2) {
      return configParseWorkchainDescriptor(src2);
    }
  };
  function configParse12(slice) {
    if (!slice) {
      throw Error("Invalid config");
    }
    const wd = slice.loadDict(core_1.Dictionary.Keys.Uint(32), WorkchainDescriptorDictValue);
    if (wd) {
      return wd;
    }
    throw Error("No workchains exist");
  }
  function configParseValidatorSet(slice) {
    if (!slice) {
      return null;
    }
    return parseValidatorSet(slice);
  }
  function configParseBridge(slice) {
    if (!slice) {
      return null;
    }
    return parseBridge(slice);
  }
  function parseGasLimitsInternal(slice) {
    const tag = slice.loadUint(8);
    if (tag === 222) {
      const gasPrice = slice.loadUintBig(64);
      const gasLimit = slice.loadUintBig(64);
      const specialGasLimit = slice.loadUintBig(64);
      const gasCredit = slice.loadUintBig(64);
      const blockGasLimit = slice.loadUintBig(64);
      const freezeDueLimit = slice.loadUintBig(64);
      const deleteDueLimit = slice.loadUintBig(64);
      return {
        gasPrice,
        gasLimit,
        specialGasLimit,
        gasCredit,
        blockGasLimit,
        freezeDueLimit,
        deleteDueLimit
      };
    } else if (tag === 221) {
      const gasPrice = slice.loadUintBig(64);
      const gasLimit = slice.loadUintBig(64);
      const gasCredit = slice.loadUintBig(64);
      const blockGasLimit = slice.loadUintBig(64);
      const freezeDueLimit = slice.loadUintBig(64);
      const deleteDueLimit = slice.loadUintBig(64);
      return {
        gasPrice,
        gasLimit,
        gasCredit,
        blockGasLimit,
        freezeDueLimit,
        deleteDueLimit
      };
    } else {
      throw Error("Invalid config");
    }
  }
  function configParseGasLimitsPrices(slice) {
    if (!slice) {
      throw Error("Invalid config");
    }
    const tag = slice.loadUint(8);
    if (tag === 209) {
      const flatLimit = slice.loadUintBig(64);
      const flatGasPrice = slice.loadUintBig(64);
      const other = parseGasLimitsInternal(slice);
      return {
        flatLimit,
        flatGasPrice,
        other
      };
    } else {
      throw Error("Invalid config");
    }
  }
  function configParseMsgPrices(slice) {
    if (!slice) {
      throw new Error("Invalid config");
    }
    const magic = slice.loadUint(8);
    if (magic !== 234) {
      throw new Error("Invalid msg prices param");
    }
    return {
      lumpPrice: slice.loadUintBig(64),
      bitPrice: slice.loadUintBig(64),
      cellPrice: slice.loadUintBig(64),
      ihrPriceFactor: slice.loadUint(32),
      firstFrac: slice.loadUint(16),
      nextFrac: slice.loadUint(16)
    };
  }
  function configParse28(slice) {
    if (!slice) {
      throw new Error("Invalid config");
    }
    const magic = slice.loadUint(8);
    if (magic === 193) {
      const masterCatchainLifetime = slice.loadUint(32);
      const shardCatchainLifetime = slice.loadUint(32);
      const shardValidatorsLifetime = slice.loadUint(32);
      const shardValidatorsCount = slice.loadUint(32);
      return {
        masterCatchainLifetime,
        shardCatchainLifetime,
        shardValidatorsLifetime,
        shardValidatorsCount
      };
    }
    if (magic === 194) {
      const flags = slice.loadUint(7);
      const suffleMasterValidators = slice.loadBit();
      const masterCatchainLifetime = slice.loadUint(32);
      const shardCatchainLifetime = slice.loadUint(32);
      const shardValidatorsLifetime = slice.loadUint(32);
      const shardValidatorsCount = slice.loadUint(32);
      return {
        flags,
        suffleMasterValidators,
        masterCatchainLifetime,
        shardCatchainLifetime,
        shardValidatorsLifetime,
        shardValidatorsCount
      };
    }
    throw new Error("Invalid config");
  }
  function configParse29(slice) {
    if (!slice) {
      throw new Error("Invalid config");
    }
    const magic = slice.loadUint(8);
    if (magic === 214) {
      const roundCandidates = slice.loadUint(32);
      const nextCandidateDelay = slice.loadUint(32);
      const consensusTimeout = slice.loadUint(32);
      const fastAttempts = slice.loadUint(32);
      const attemptDuration = slice.loadUint(32);
      const catchainMaxDeps = slice.loadUint(32);
      const maxBlockBytes = slice.loadUint(32);
      const maxColaltedBytes = slice.loadUint(32);
      return {
        roundCandidates,
        nextCandidateDelay,
        consensusTimeout,
        fastAttempts,
        attemptDuration,
        catchainMaxDeps,
        maxBlockBytes,
        maxColaltedBytes
      };
    } else if (magic === 215) {
      const flags = slice.loadUint(7);
      const newCatchainIds = slice.loadBit();
      const roundCandidates = slice.loadUint(8);
      const nextCandidateDelay = slice.loadUint(32);
      const consensusTimeout = slice.loadUint(32);
      const fastAttempts = slice.loadUint(32);
      const attemptDuration = slice.loadUint(32);
      const catchainMaxDeps = slice.loadUint(32);
      const maxBlockBytes = slice.loadUint(32);
      const maxColaltedBytes = slice.loadUint(32);
      return {
        flags,
        newCatchainIds,
        roundCandidates,
        nextCandidateDelay,
        consensusTimeout,
        fastAttempts,
        attemptDuration,
        catchainMaxDeps,
        maxBlockBytes,
        maxColaltedBytes
      };
    } else if (magic === 216) {
      const flags = slice.loadUint(7);
      const newCatchainIds = slice.loadBit();
      const roundCandidates = slice.loadUint(8);
      const nextCandidateDelay = slice.loadUint(32);
      const consensusTimeout = slice.loadUint(32);
      const fastAttempts = slice.loadUint(32);
      const attemptDuration = slice.loadUint(32);
      const catchainMaxDeps = slice.loadUint(32);
      const maxBlockBytes = slice.loadUint(32);
      const maxColaltedBytes = slice.loadUint(32);
      const protoVersion = slice.loadUint(16);
      return {
        flags,
        newCatchainIds,
        roundCandidates,
        nextCandidateDelay,
        consensusTimeout,
        fastAttempts,
        attemptDuration,
        catchainMaxDeps,
        maxBlockBytes,
        maxColaltedBytes,
        protoVersion
      };
    } else if (magic === 217) {
      const flags = slice.loadUint(7);
      const newCatchainIds = slice.loadBit();
      const roundCandidates = slice.loadUint(8);
      const nextCandidateDelay = slice.loadUint(32);
      const consensusTimeout = slice.loadUint(32);
      const fastAttempts = slice.loadUint(32);
      const attemptDuration = slice.loadUint(32);
      const catchainMaxDeps = slice.loadUint(32);
      const maxBlockBytes = slice.loadUint(32);
      const maxColaltedBytes = slice.loadUint(32);
      const protoVersion = slice.loadUint(16);
      const catchainMaxBlocksCoeff = slice.loadUint(32);
      return {
        flags,
        newCatchainIds,
        roundCandidates,
        nextCandidateDelay,
        consensusTimeout,
        fastAttempts,
        attemptDuration,
        catchainMaxDeps,
        maxBlockBytes,
        maxColaltedBytes,
        protoVersion,
        catchainMaxBlocksCoeff
      };
    }
    throw new Error("Invalid config");
  }
  function parseProposalSetup(slice) {
    const magic = slice.loadUint(8);
    if (magic !== 54) {
      throw new Error("Invalid config");
    }
    const minTotalRounds = slice.loadUint(8);
    const maxTotalRounds = slice.loadUint(8);
    const minWins = slice.loadUint(8);
    const maxLoses = slice.loadUint(8);
    const minStoreSec = slice.loadUint(32);
    const maxStoreSec = slice.loadUint(32);
    const bitPrice = slice.loadUint(32);
    const cellPrice = slice.loadUint(32);
    return { minTotalRounds, maxTotalRounds, minWins, maxLoses, minStoreSec, maxStoreSec, bitPrice, cellPrice };
  }
  function parseVotingSetup(slice) {
    if (!slice) {
      throw new Error("Invalid config");
    }
    const magic = slice.loadUint(8);
    if (magic !== 145) {
      throw new Error("Invalid config");
    }
    const normalParams = parseProposalSetup(slice.loadRef().beginParse());
    const criticalParams = parseProposalSetup(slice.loadRef().beginParse());
    return { normalParams, criticalParams };
  }
  function loadConfigParams(configBase64) {
    const comfigMap = core_1.Cell.fromBase64(configBase64).beginParse().loadDictDirect(core_1.Dictionary.Keys.Int(32), core_1.Dictionary.Values.Cell());
    return comfigMap;
  }
  function loadConfigParamById(configBase64, id) {
    return loadConfigParams(configBase64).get(id);
  }
  function loadConfigParamsAsSlice(configBase64) {
    const pramsAsCells = loadConfigParams(configBase64);
    const params = /* @__PURE__ */ new Map();
    for (const [key2, value] of pramsAsCells) {
      params.set(key2, value.beginParse());
    }
    return params;
  }
  function parseFullConfig(configs) {
    return {
      configAddress: configParseMasterAddressRequired(configs.get(0)),
      electorAddress: configParseMasterAddressRequired(configs.get(1)),
      minterAddress: configParseMasterAddress(configs.get(2)),
      feeCollectorAddress: configParseMasterAddress(configs.get(3)),
      dnsRootAddress: configParseMasterAddress(configs.get(4)),
      burningConfig: configParse5(configs.get(5)),
      globalVersion: configParse8(configs.get(8)),
      workchains: configParse12(configs.get(12)),
      voting: parseVotingSetup(configs.get(11)),
      validators: {
        ...configParse15(configs.get(15)),
        ...configParse16(configs.get(16)),
        ...configParse17(configs.get(17))
      },
      storagePrices: configParse18(configs.get(18)),
      gasPrices: {
        masterchain: configParseGasLimitsPrices(configs.get(20)),
        workchain: configParseGasLimitsPrices(configs.get(21))
      },
      msgPrices: {
        masterchain: configParseMsgPrices(configs.get(24)),
        workchain: configParseMsgPrices(configs.get(25))
      },
      validatorSets: {
        prevValidators: configParseValidatorSet(configs.get(32)),
        prevTempValidators: configParseValidatorSet(configs.get(33)),
        currentValidators: configParseValidatorSet(configs.get(34)),
        currentTempValidators: configParseValidatorSet(configs.get(35)),
        nextValidators: configParseValidatorSet(configs.get(36)),
        nextTempValidators: configParseValidatorSet(configs.get(37))
      },
      validatorsPunish: configParse40(configs.get(40)),
      bridges: {
        ethereum: configParseBridge(configs.get(71)),
        binance: configParseBridge(configs.get(72)),
        polygon: configParseBridge(configs.get(73))
      },
      catchain: configParse28(configs.get(28)),
      consensus: configParse29(configs.get(29))
      // TODO: mint_new_price:Grams mint_add_price:Grams = ConfigParam 6;
      // TODO: to_mint:ExtraCurrencyCollection = ConfigParam 7
      // TODO: mandatory_params:(Hashmap 32 True) = ConfigParam 9
      // TODO: critical_params:(Hashmap 32 True) = ConfigParam 10
      // TODO: BlockCreateFees = ConfigParam 14
    };
  }
  return ConfigParser;
}
var fees = {};
var hasRequiredFees;
function requireFees() {
  if (hasRequiredFees) return fees;
  hasRequiredFees = 1;
  Object.defineProperty(fees, "__esModule", { value: true });
  fees.computeStorageFees = computeStorageFees;
  fees.computeFwdFees = computeFwdFees;
  fees.computeGasPrices = computeGasPrices;
  fees.computeExternalMessageFees = computeExternalMessageFees;
  fees.computeMessageForwardFees = computeMessageForwardFees;
  const core_1 = requireDist$5();
  function computeStorageFees(data) {
    const { lastPaid, now, storagePrices, storageStat, special, masterchain } = data;
    if (now <= lastPaid || storagePrices.length === 0 || now < storagePrices[0].utime_since || special) {
      return BigInt(0);
    }
    let upto = Math.max(lastPaid, storagePrices[0].utime_since);
    let total = BigInt(0);
    for (let i = 0; i < storagePrices.length && upto < now; i++) {
      let valid_until = i < storagePrices.length - 1 ? Math.min(now, storagePrices[i + 1].utime_since) : now;
      let payment = BigInt(0);
      if (upto < valid_until) {
        let delta = valid_until - upto;
        payment += BigInt(storageStat.cells) * (masterchain ? storagePrices[i].mc_cell_price_ps : storagePrices[i].cell_price_ps);
        payment += BigInt(storageStat.bits) * (masterchain ? storagePrices[i].mc_bit_price_ps : storagePrices[i].bit_price_ps);
        payment = payment * BigInt(delta);
      }
      upto = valid_until;
      total += payment;
    }
    return shr16ceil(total);
  }
  function computeFwdFees(msgPrices, cells, bits) {
    return msgPrices.lumpPrice + shr16ceil(msgPrices.bitPrice * bits + msgPrices.cellPrice * cells);
  }
  function computeGasPrices(gasUsed, prices) {
    if (gasUsed <= prices.flatLimit) {
      return prices.flatPrice;
    } else {
      return prices.flatPrice + (prices.price * (gasUsed - prices.flatLimit) >> 16n);
    }
  }
  function computeExternalMessageFees(msgPrices, cell) {
    let storageStats = collectCellStats(cell);
    storageStats.bits -= cell.bits.length;
    storageStats.cells -= 1;
    return computeFwdFees(msgPrices, BigInt(storageStats.cells), BigInt(storageStats.bits));
  }
  function computeMessageForwardFees(msgPrices, cell) {
    let msg = (0, core_1.loadMessageRelaxed)(cell.beginParse());
    let storageStats = { bits: 0, cells: 0 };
    if (msg.init) {
      const rawBuilder = new core_1.Cell().asBuilder();
      (0, core_1.storeStateInit)(msg.init)(rawBuilder);
      const raw = rawBuilder.endCell();
      let c = collectCellStats(raw);
      c.bits -= raw.bits.length;
      c.cells -= 1;
      storageStats.bits += c.bits;
      storageStats.cells += c.cells;
    }
    let bc = collectCellStats(msg.body);
    bc.bits -= msg.body.bits.length;
    bc.cells -= 1;
    storageStats.bits += bc.bits;
    storageStats.cells += bc.cells;
    let fees2 = computeFwdFees(msgPrices, BigInt(storageStats.cells), BigInt(storageStats.bits));
    let res = fees2 * BigInt(msgPrices.firstFrac) >> 16n;
    let remaining = fees2 - res;
    return { fees: res, remaining };
  }
  function collectCellStats(cell) {
    let bits = cell.bits.length;
    let cells = 1;
    for (let ref of cell.refs) {
      let r = collectCellStats(ref);
      cells += r.cells;
      bits += r.bits;
    }
    return { bits, cells };
  }
  function shr16ceil(src2) {
    let rem = src2 % 65536n;
    let res = src2 >> 16n;
    if (rem !== 0n) {
      res += 1n;
    }
    return res;
  }
  return fees;
}
var hasRequiredDist$1;
function requireDist$1() {
  if (hasRequiredDist$1) return dist;
  hasRequiredDist$1 = 1;
  (function(exports) {
    var __createBinding = dist && dist.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = dist && dist.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.computeStorageFees = exports.computeMessageForwardFees = exports.computeGasPrices = exports.computeFwdFees = exports.computeExternalMessageFees = exports.loadConfigParamsAsSlice = exports.loadConfigParamById = exports.parseFullConfig = exports.parseVotingSetup = exports.parseValidatorSet = exports.parseProposalSetup = exports.parseBridge = exports.configParseWorkchainDescriptor = exports.configParseValidatorSet = exports.configParseMsgPrices = exports.configParseMasterAddressRequired = exports.configParseMasterAddress = exports.configParseGasLimitsPrices = exports.configParseBridge = exports.configParse40 = exports.configParse29 = exports.configParse28 = exports.configParse18 = exports.configParse17 = exports.configParse16 = exports.configParse15 = exports.configParse13 = exports.configParse12 = exports.configParse8 = exports.configParse5 = exports.ElectorContract = exports.MultisigWallet = exports.MultisigOrderBuilder = exports.MultisigOrder = exports.JettonWallet = exports.JettonMaster = exports.WalletContractV5R1 = exports.WalletContractV5Beta = exports.WalletContractV4 = exports.WalletContractV3R2 = exports.WalletContractV3R1 = exports.WalletContractV2R2 = exports.WalletContractV2R1 = exports.WalletContractV1R3 = exports.WalletContractV1R2 = exports.WalletContractV1R1 = exports.TonClient4 = exports.TonClient = exports.HttpApi = void 0;
    __exportStar(requireDist$5(), exports);
    var HttpApi_1 = requireHttpApi();
    Object.defineProperty(exports, "HttpApi", { enumerable: true, get: function() {
      return HttpApi_1.HttpApi;
    } });
    var TonClient_1 = requireTonClient();
    Object.defineProperty(exports, "TonClient", { enumerable: true, get: function() {
      return TonClient_1.TonClient;
    } });
    var TonClient4_1 = requireTonClient4();
    Object.defineProperty(exports, "TonClient4", { enumerable: true, get: function() {
      return TonClient4_1.TonClient4;
    } });
    var WalletContractV1R1_1 = requireWalletContractV1R1();
    Object.defineProperty(exports, "WalletContractV1R1", { enumerable: true, get: function() {
      return WalletContractV1R1_1.WalletContractV1R1;
    } });
    var WalletContractV1R2_1 = requireWalletContractV1R2();
    Object.defineProperty(exports, "WalletContractV1R2", { enumerable: true, get: function() {
      return WalletContractV1R2_1.WalletContractV1R2;
    } });
    var WalletContractV1R3_1 = requireWalletContractV1R3();
    Object.defineProperty(exports, "WalletContractV1R3", { enumerable: true, get: function() {
      return WalletContractV1R3_1.WalletContractV1R3;
    } });
    var WalletContractV2R1_1 = requireWalletContractV2R1();
    Object.defineProperty(exports, "WalletContractV2R1", { enumerable: true, get: function() {
      return WalletContractV2R1_1.WalletContractV2R1;
    } });
    var WalletContractV2R2_1 = requireWalletContractV2R2();
    Object.defineProperty(exports, "WalletContractV2R2", { enumerable: true, get: function() {
      return WalletContractV2R2_1.WalletContractV2R2;
    } });
    var WalletContractV3R1_1 = requireWalletContractV3R1();
    Object.defineProperty(exports, "WalletContractV3R1", { enumerable: true, get: function() {
      return WalletContractV3R1_1.WalletContractV3R1;
    } });
    var WalletContractV3R2_1 = requireWalletContractV3R2();
    Object.defineProperty(exports, "WalletContractV3R2", { enumerable: true, get: function() {
      return WalletContractV3R2_1.WalletContractV3R2;
    } });
    var WalletContractV4_1 = requireWalletContractV4();
    Object.defineProperty(exports, "WalletContractV4", { enumerable: true, get: function() {
      return WalletContractV4_1.WalletContractV4;
    } });
    var WalletContractV5Beta_1 = requireWalletContractV5Beta();
    Object.defineProperty(exports, "WalletContractV5Beta", { enumerable: true, get: function() {
      return WalletContractV5Beta_1.WalletContractV5Beta;
    } });
    var WalletContractV5R1_1 = requireWalletContractV5R1();
    Object.defineProperty(exports, "WalletContractV5R1", { enumerable: true, get: function() {
      return WalletContractV5R1_1.WalletContractV5R1;
    } });
    var JettonMaster_1 = requireJettonMaster();
    Object.defineProperty(exports, "JettonMaster", { enumerable: true, get: function() {
      return JettonMaster_1.JettonMaster;
    } });
    var JettonWallet_1 = requireJettonWallet();
    Object.defineProperty(exports, "JettonWallet", { enumerable: true, get: function() {
      return JettonWallet_1.JettonWallet;
    } });
    var MultisigOrder_1 = requireMultisigOrder();
    Object.defineProperty(exports, "MultisigOrder", { enumerable: true, get: function() {
      return MultisigOrder_1.MultisigOrder;
    } });
    var MultisigOrderBuilder_1 = requireMultisigOrderBuilder();
    Object.defineProperty(exports, "MultisigOrderBuilder", { enumerable: true, get: function() {
      return MultisigOrderBuilder_1.MultisigOrderBuilder;
    } });
    var MultisigWallet_1 = requireMultisigWallet();
    Object.defineProperty(exports, "MultisigWallet", { enumerable: true, get: function() {
      return MultisigWallet_1.MultisigWallet;
    } });
    var ElectorContract_1 = requireElectorContract();
    Object.defineProperty(exports, "ElectorContract", { enumerable: true, get: function() {
      return ElectorContract_1.ElectorContract;
    } });
    var ConfigParser_1 = requireConfigParser();
    Object.defineProperty(exports, "configParse5", { enumerable: true, get: function() {
      return ConfigParser_1.configParse5;
    } });
    Object.defineProperty(exports, "configParse8", { enumerable: true, get: function() {
      return ConfigParser_1.configParse8;
    } });
    Object.defineProperty(exports, "configParse12", { enumerable: true, get: function() {
      return ConfigParser_1.configParse12;
    } });
    Object.defineProperty(exports, "configParse13", { enumerable: true, get: function() {
      return ConfigParser_1.configParse13;
    } });
    Object.defineProperty(exports, "configParse15", { enumerable: true, get: function() {
      return ConfigParser_1.configParse15;
    } });
    Object.defineProperty(exports, "configParse16", { enumerable: true, get: function() {
      return ConfigParser_1.configParse16;
    } });
    Object.defineProperty(exports, "configParse17", { enumerable: true, get: function() {
      return ConfigParser_1.configParse17;
    } });
    Object.defineProperty(exports, "configParse18", { enumerable: true, get: function() {
      return ConfigParser_1.configParse18;
    } });
    Object.defineProperty(exports, "configParse28", { enumerable: true, get: function() {
      return ConfigParser_1.configParse28;
    } });
    Object.defineProperty(exports, "configParse29", { enumerable: true, get: function() {
      return ConfigParser_1.configParse29;
    } });
    Object.defineProperty(exports, "configParse40", { enumerable: true, get: function() {
      return ConfigParser_1.configParse40;
    } });
    Object.defineProperty(exports, "configParseBridge", { enumerable: true, get: function() {
      return ConfigParser_1.configParseBridge;
    } });
    Object.defineProperty(exports, "configParseGasLimitsPrices", { enumerable: true, get: function() {
      return ConfigParser_1.configParseGasLimitsPrices;
    } });
    Object.defineProperty(exports, "configParseMasterAddress", { enumerable: true, get: function() {
      return ConfigParser_1.configParseMasterAddress;
    } });
    Object.defineProperty(exports, "configParseMasterAddressRequired", { enumerable: true, get: function() {
      return ConfigParser_1.configParseMasterAddressRequired;
    } });
    Object.defineProperty(exports, "configParseMsgPrices", { enumerable: true, get: function() {
      return ConfigParser_1.configParseMsgPrices;
    } });
    Object.defineProperty(exports, "configParseValidatorSet", { enumerable: true, get: function() {
      return ConfigParser_1.configParseValidatorSet;
    } });
    Object.defineProperty(exports, "configParseWorkchainDescriptor", { enumerable: true, get: function() {
      return ConfigParser_1.configParseWorkchainDescriptor;
    } });
    Object.defineProperty(exports, "parseBridge", { enumerable: true, get: function() {
      return ConfigParser_1.parseBridge;
    } });
    Object.defineProperty(exports, "parseProposalSetup", { enumerable: true, get: function() {
      return ConfigParser_1.parseProposalSetup;
    } });
    Object.defineProperty(exports, "parseValidatorSet", { enumerable: true, get: function() {
      return ConfigParser_1.parseValidatorSet;
    } });
    Object.defineProperty(exports, "parseVotingSetup", { enumerable: true, get: function() {
      return ConfigParser_1.parseVotingSetup;
    } });
    Object.defineProperty(exports, "parseFullConfig", { enumerable: true, get: function() {
      return ConfigParser_1.parseFullConfig;
    } });
    Object.defineProperty(exports, "loadConfigParamById", { enumerable: true, get: function() {
      return ConfigParser_1.loadConfigParamById;
    } });
    Object.defineProperty(exports, "loadConfigParamsAsSlice", { enumerable: true, get: function() {
      return ConfigParser_1.loadConfigParamsAsSlice;
    } });
    var fees_1 = requireFees();
    Object.defineProperty(exports, "computeExternalMessageFees", { enumerable: true, get: function() {
      return fees_1.computeExternalMessageFees;
    } });
    Object.defineProperty(exports, "computeFwdFees", { enumerable: true, get: function() {
      return fees_1.computeFwdFees;
    } });
    Object.defineProperty(exports, "computeGasPrices", { enumerable: true, get: function() {
      return fees_1.computeGasPrices;
    } });
    Object.defineProperty(exports, "computeMessageForwardFees", { enumerable: true, get: function() {
      return fees_1.computeMessageForwardFees;
    } });
    Object.defineProperty(exports, "computeStorageFees", { enumerable: true, get: function() {
      return fees_1.computeStorageFees;
    } });
  })(dist);
  return dist;
}
var lib = {};
var nodes = {};
var g = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || // eslint-disable-next-line no-undef
typeof global !== "undefined" && global || {};
var support = {
  searchParams: "URLSearchParams" in g,
  iterable: "Symbol" in g && "iterator" in Symbol,
  blob: "FileReader" in g && "Blob" in g && (function() {
    try {
      new Blob();
      return true;
    } catch (e) {
      return false;
    }
  })(),
  formData: "FormData" in g,
  arrayBuffer: "ArrayBuffer" in g
};
function isDataView(obj) {
  return obj && DataView.prototype.isPrototypeOf(obj);
}
if (support.arrayBuffer) {
  var viewClasses = [
    "[object Int8Array]",
    "[object Uint8Array]",
    "[object Uint8ClampedArray]",
    "[object Int16Array]",
    "[object Uint16Array]",
    "[object Int32Array]",
    "[object Uint32Array]",
    "[object Float32Array]",
    "[object Float64Array]"
  ];
  var isArrayBufferView = ArrayBuffer.isView || function(obj) {
    return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
  };
}
function normalizeName(name) {
  if (typeof name !== "string") {
    name = String(name);
  }
  if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
    throw new TypeError('Invalid character in header field name: "' + name + '"');
  }
  return name.toLowerCase();
}
function normalizeValue(value) {
  if (typeof value !== "string") {
    value = String(value);
  }
  return value;
}
function iteratorFor(items) {
  var iterator = {
    next: function() {
      var value = items.shift();
      return { done: value === void 0, value };
    }
  };
  if (support.iterable) {
    iterator[Symbol.iterator] = function() {
      return iterator;
    };
  }
  return iterator;
}
function Headers(headers) {
  this.map = {};
  if (headers instanceof Headers) {
    headers.forEach(function(value, name) {
      this.append(name, value);
    }, this);
  } else if (Array.isArray(headers)) {
    headers.forEach(function(header) {
      if (header.length != 2) {
        throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + header.length);
      }
      this.append(header[0], header[1]);
    }, this);
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function(name) {
      this.append(name, headers[name]);
    }, this);
  }
}
Headers.prototype.append = function(name, value) {
  name = normalizeName(name);
  value = normalizeValue(value);
  var oldValue = this.map[name];
  this.map[name] = oldValue ? oldValue + ", " + value : value;
};
Headers.prototype["delete"] = function(name) {
  delete this.map[normalizeName(name)];
};
Headers.prototype.get = function(name) {
  name = normalizeName(name);
  return this.has(name) ? this.map[name] : null;
};
Headers.prototype.has = function(name) {
  return this.map.hasOwnProperty(normalizeName(name));
};
Headers.prototype.set = function(name, value) {
  this.map[normalizeName(name)] = normalizeValue(value);
};
Headers.prototype.forEach = function(callback, thisArg) {
  for (var name in this.map) {
    if (this.map.hasOwnProperty(name)) {
      callback.call(thisArg, this.map[name], name, this);
    }
  }
};
Headers.prototype.keys = function() {
  var items = [];
  this.forEach(function(value, name) {
    items.push(name);
  });
  return iteratorFor(items);
};
Headers.prototype.values = function() {
  var items = [];
  this.forEach(function(value) {
    items.push(value);
  });
  return iteratorFor(items);
};
Headers.prototype.entries = function() {
  var items = [];
  this.forEach(function(value, name) {
    items.push([name, value]);
  });
  return iteratorFor(items);
};
if (support.iterable) {
  Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
}
function consumed(body) {
  if (body._noBody) return;
  if (body.bodyUsed) {
    return Promise.reject(new TypeError("Already read"));
  }
  body.bodyUsed = true;
}
function fileReaderReady(reader2) {
  return new Promise(function(resolve, reject) {
    reader2.onload = function() {
      resolve(reader2.result);
    };
    reader2.onerror = function() {
      reject(reader2.error);
    };
  });
}
function readBlobAsArrayBuffer(blob) {
  var reader2 = new FileReader();
  var promise = fileReaderReady(reader2);
  reader2.readAsArrayBuffer(blob);
  return promise;
}
function readBlobAsText(blob) {
  var reader2 = new FileReader();
  var promise = fileReaderReady(reader2);
  var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
  var encoding = match ? match[1] : "utf-8";
  reader2.readAsText(blob, encoding);
  return promise;
}
function readArrayBufferAsText(buf) {
  var view = new Uint8Array(buf);
  var chars = new Array(view.length);
  for (var i = 0; i < view.length; i++) {
    chars[i] = String.fromCharCode(view[i]);
  }
  return chars.join("");
}
function bufferClone(buf) {
  if (buf.slice) {
    return buf.slice(0);
  } else {
    var view = new Uint8Array(buf.byteLength);
    view.set(new Uint8Array(buf));
    return view.buffer;
  }
}
function Body() {
  this.bodyUsed = false;
  this._initBody = function(body) {
    this.bodyUsed = this.bodyUsed;
    this._bodyInit = body;
    if (!body) {
      this._noBody = true;
      this._bodyText = "";
    } else if (typeof body === "string") {
      this._bodyText = body;
    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
      this._bodyBlob = body;
    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
      this._bodyFormData = body;
    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
      this._bodyText = body.toString();
    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
      this._bodyArrayBuffer = bufferClone(body.buffer);
      this._bodyInit = new Blob([this._bodyArrayBuffer]);
    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
      this._bodyArrayBuffer = bufferClone(body);
    } else {
      this._bodyText = body = Object.prototype.toString.call(body);
    }
    if (!this.headers.get("content-type")) {
      if (typeof body === "string") {
        this.headers.set("content-type", "text/plain;charset=UTF-8");
      } else if (this._bodyBlob && this._bodyBlob.type) {
        this.headers.set("content-type", this._bodyBlob.type);
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
      }
    }
  };
  if (support.blob) {
    this.blob = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected;
      }
      if (this._bodyBlob) {
        return Promise.resolve(this._bodyBlob);
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(new Blob([this._bodyArrayBuffer]));
      } else if (this._bodyFormData) {
        throw new Error("could not read FormData body as blob");
      } else {
        return Promise.resolve(new Blob([this._bodyText]));
      }
    };
  }
  this.arrayBuffer = function() {
    if (this._bodyArrayBuffer) {
      var isConsumed = consumed(this);
      if (isConsumed) {
        return isConsumed;
      } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
        return Promise.resolve(
          this._bodyArrayBuffer.buffer.slice(
            this._bodyArrayBuffer.byteOffset,
            this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
          )
        );
      } else {
        return Promise.resolve(this._bodyArrayBuffer);
      }
    } else if (support.blob) {
      return this.blob().then(readBlobAsArrayBuffer);
    } else {
      throw new Error("could not read as ArrayBuffer");
    }
  };
  this.text = function() {
    var rejected = consumed(this);
    if (rejected) {
      return rejected;
    }
    if (this._bodyBlob) {
      return readBlobAsText(this._bodyBlob);
    } else if (this._bodyArrayBuffer) {
      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
    } else if (this._bodyFormData) {
      throw new Error("could not read FormData body as text");
    } else {
      return Promise.resolve(this._bodyText);
    }
  };
  if (support.formData) {
    this.formData = function() {
      return this.text().then(decode);
    };
  }
  this.json = function() {
    return this.text().then(JSON.parse);
  };
  return this;
}
var methods = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
function normalizeMethod(method) {
  var upcased = method.toUpperCase();
  return methods.indexOf(upcased) > -1 ? upcased : method;
}
function Request$1(input, options) {
  if (!(this instanceof Request$1)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  }
  options = options || {};
  var body = options.body;
  if (input instanceof Request$1) {
    if (input.bodyUsed) {
      throw new TypeError("Already read");
    }
    this.url = input.url;
    this.credentials = input.credentials;
    if (!options.headers) {
      this.headers = new Headers(input.headers);
    }
    this.method = input.method;
    this.mode = input.mode;
    this.signal = input.signal;
    if (!body && input._bodyInit != null) {
      body = input._bodyInit;
      input.bodyUsed = true;
    }
  } else {
    this.url = String(input);
  }
  this.credentials = options.credentials || this.credentials || "same-origin";
  if (options.headers || !this.headers) {
    this.headers = new Headers(options.headers);
  }
  this.method = normalizeMethod(options.method || this.method || "GET");
  this.mode = options.mode || this.mode || null;
  this.signal = options.signal || this.signal || (function() {
    if ("AbortController" in g) {
      var ctrl = new AbortController();
      return ctrl.signal;
    }
  })();
  this.referrer = null;
  if ((this.method === "GET" || this.method === "HEAD") && body) {
    throw new TypeError("Body not allowed for GET or HEAD requests");
  }
  this._initBody(body);
  if (this.method === "GET" || this.method === "HEAD") {
    if (options.cache === "no-store" || options.cache === "no-cache") {
      var reParamSearch = /([?&])_=[^&]*/;
      if (reParamSearch.test(this.url)) {
        this.url = this.url.replace(reParamSearch, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
      } else {
        var reQueryString = /\?/;
        this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
      }
    }
  }
}
Request$1.prototype.clone = function() {
  return new Request$1(this, { body: this._bodyInit });
};
function decode(body) {
  var form = new FormData();
  body.trim().split("&").forEach(function(bytes) {
    if (bytes) {
      var split = bytes.split("=");
      var name = split.shift().replace(/\+/g, " ");
      var value = split.join("=").replace(/\+/g, " ");
      form.append(decodeURIComponent(name), decodeURIComponent(value));
    }
  });
  return form;
}
function parseHeaders(rawHeaders) {
  var headers = new Headers();
  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
  preProcessedHeaders.split("\r").map(function(header) {
    return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
  }).forEach(function(line) {
    var parts = line.split(":");
    var key2 = parts.shift().trim();
    if (key2) {
      var value = parts.join(":").trim();
      try {
        headers.append(key2, value);
      } catch (error2) {
        console.warn("Response " + error2.message);
      }
    }
  });
  return headers;
}
Body.call(Request$1.prototype);
function Response$1(bodyInit, options) {
  if (!(this instanceof Response$1)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  }
  if (!options) {
    options = {};
  }
  this.type = "default";
  this.status = options.status === void 0 ? 200 : options.status;
  if (this.status < 200 || this.status > 599) {
    throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
  }
  this.ok = this.status >= 200 && this.status < 300;
  this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
  this.headers = new Headers(options.headers);
  this.url = options.url || "";
  this._initBody(bodyInit);
}
Body.call(Response$1.prototype);
Response$1.prototype.clone = function() {
  return new Response$1(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new Headers(this.headers),
    url: this.url
  });
};
Response$1.error = function() {
  var response = new Response$1(null, { status: 200, statusText: "" });
  response.ok = false;
  response.status = 0;
  response.type = "error";
  return response;
};
var redirectStatuses = [301, 302, 303, 307, 308];
Response$1.redirect = function(url, status) {
  if (redirectStatuses.indexOf(status) === -1) {
    throw new RangeError("Invalid status code");
  }
  return new Response$1(null, { status, headers: { location: url } });
};
var DOMException = g.DOMException;
try {
  new DOMException();
} catch (err) {
  DOMException = function(message, name) {
    this.message = message;
    this.name = name;
    var error2 = Error(message);
    this.stack = error2.stack;
  };
  DOMException.prototype = Object.create(Error.prototype);
  DOMException.prototype.constructor = DOMException;
}
function fetch$1(input, init) {
  return new Promise(function(resolve, reject) {
    var request = new Request$1(input, init);
    if (request.signal && request.signal.aborted) {
      return reject(new DOMException("Aborted", "AbortError"));
    }
    var xhr = new XMLHttpRequest();
    function abortXhr() {
      xhr.abort();
    }
    xhr.onload = function() {
      var options = {
        statusText: xhr.statusText,
        headers: parseHeaders(xhr.getAllResponseHeaders() || "")
      };
      if (request.url.indexOf("file://") === 0 && (xhr.status < 200 || xhr.status > 599)) {
        options.status = 200;
      } else {
        options.status = xhr.status;
      }
      options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
      var body = "response" in xhr ? xhr.response : xhr.responseText;
      setTimeout(function() {
        resolve(new Response$1(body, options));
      }, 0);
    };
    xhr.onerror = function() {
      setTimeout(function() {
        reject(new TypeError("Network request failed"));
      }, 0);
    };
    xhr.ontimeout = function() {
      setTimeout(function() {
        reject(new TypeError("Network request timed out"));
      }, 0);
    };
    xhr.onabort = function() {
      setTimeout(function() {
        reject(new DOMException("Aborted", "AbortError"));
      }, 0);
    };
    function fixUrl(url) {
      try {
        return url === "" && g.location.href ? g.location.href : url;
      } catch (e) {
        return url;
      }
    }
    xhr.open(request.method, fixUrl(request.url), true);
    if (request.credentials === "include") {
      xhr.withCredentials = true;
    } else if (request.credentials === "omit") {
      xhr.withCredentials = false;
    }
    if ("responseType" in xhr) {
      if (support.blob) {
        xhr.responseType = "blob";
      } else if (support.arrayBuffer) {
        xhr.responseType = "arraybuffer";
      }
    }
    if (init && typeof init.headers === "object" && !(init.headers instanceof Headers || g.Headers && init.headers instanceof g.Headers)) {
      var names = [];
      Object.getOwnPropertyNames(init.headers).forEach(function(name) {
        names.push(normalizeName(name));
        xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
      });
      request.headers.forEach(function(value, name) {
        if (names.indexOf(name) === -1) {
          xhr.setRequestHeader(name, value);
        }
      });
    } else {
      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });
    }
    if (request.signal) {
      request.signal.addEventListener("abort", abortXhr);
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
          request.signal.removeEventListener("abort", abortXhr);
        }
      };
    }
    xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
  });
}
fetch$1.polyfill = true;
if (!g.fetch) {
  g.fetch = fetch$1;
  g.Headers = Headers;
  g.Request = Request$1;
  g.Response = Response$1;
}
var fetchNpmBrowserify;
var hasRequiredFetchNpmBrowserify;
function requireFetchNpmBrowserify() {
  if (hasRequiredFetchNpmBrowserify) return fetchNpmBrowserify;
  hasRequiredFetchNpmBrowserify = 1;
  fetchNpmBrowserify = self.fetch.bind(self);
  return fetchNpmBrowserify;
}
var hasRequiredNodes;
function requireNodes() {
  if (hasRequiredNodes) return nodes;
  hasRequiredNodes = 1;
  var __awaiter = nodes && nodes.__awaiter || function(thisArg, _arguments, P2, generator2) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator2.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator2["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator2 = generator2.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(nodes, "__esModule", { value: true });
  nodes.Nodes = void 0;
  requireFetchNpmBrowserify();
  class Nodes {
    ///////////////////////////////////
    constructor() {
      this.nodeIndex = -1;
      this.committee = /* @__PURE__ */ new Set();
      this.topology = [];
      this.initTime = 0;
    }
    ///////////////////////////////////
    init(nodesUrl) {
      return __awaiter(this, void 0, void 0, function* () {
        this.nodeIndex = -1;
        this.committee.clear();
        this.topology = [];
        this.initTime = Date.now();
        let topology = [];
        try {
          const response = yield fetch(nodesUrl);
          const data = yield response.json();
          topology = data;
        } catch (e) {
          throw new Error(`exception in fetch(${nodesUrl}): ${e}`);
        }
        for (const node of topology) {
          if (node.Healthy === "1") {
            this.topology.push(node);
          }
        }
        if (this.topology.length === 0)
          throw new Error(`no healthy nodes in ${nodesUrl}`);
      });
    }
    getHealthyFor(protonet) {
      var _a;
      const res = [];
      for (const node of this.topology) {
        if (node.Weight > 0 && ((_a = node.Mngr) === null || _a === void 0 ? void 0 : _a.health[protonet])) {
          res.push(node);
        }
      }
      return res;
    }
  }
  nodes.Nodes = Nodes;
  return nodes;
}
const version = "2.3.3";
const require$$1$1 = {
  version
};
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib;
  hasRequiredLib = 1;
  var __awaiter = lib && lib.__awaiter || function(thisArg, _arguments, P2, generator2) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator2.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator2["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator2 = generator2.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(lib, "__esModule", { value: true });
  lib.getHttpV4Endpoint = lib.getHttpV4Endpoints = lib.getHttpEndpoint = lib.getHttpEndpoints = lib.Access = void 0;
  const nodes_1 = requireNodes();
  class Access {
    //////////////////////////////////
    constructor() {
      this.host = "ton.access.orbs.network";
      this.urlVersion = 1;
      this.nodes = new nodes_1.Nodes();
    }
    //////////////////////////////////
    init() {
      return __awaiter(this, void 0, void 0, function* () {
        const pjson = require$$1$1;
        yield this.nodes.init(`https://${this.host}/mngr/nodes?npm_version=${pjson.version}`);
      });
    }
    //////////////////////////////////
    makeProtonet(edgeProtocol, network) {
      let res = "";
      switch (edgeProtocol) {
        case "toncenter-api-v2":
          res += "v2-";
          break;
        case "ton-api-v4":
          res += "v4-";
          break;
      }
      res += network;
      return res;
    }
    //////////////////////////////////
    weightedRandom(nodes2) {
      let sumWeights = 0;
      for (const node of nodes2) {
        sumWeights += node.Weight;
      }
      const rnd = Math.floor(Math.random() * sumWeights);
      let cur = 0;
      for (const node of nodes2) {
        if (rnd >= cur && rnd < cur + node.Weight)
          return node;
        cur += node.Weight;
      }
    }
    //////////////////////////////////
    buildUrls(network, edgeProtocol, suffix, single) {
      if (!suffix)
        suffix = "";
      if (!edgeProtocol)
        edgeProtocol = "toncenter-api-v2";
      if (!network)
        network = "mainnet";
      if (suffix.length)
        suffix = suffix.replace(/^\/+/, "");
      const res = [];
      const protonet = this.makeProtonet(edgeProtocol, network);
      let healthyNodes = this.nodes.getHealthyFor(protonet);
      if (!(healthyNodes === null || healthyNodes === void 0 ? void 0 : healthyNodes.length))
        throw new Error(`no healthy nodes for ${protonet}`);
      if (single && healthyNodes.length) {
        const chosen = this.weightedRandom(healthyNodes);
        if (chosen)
          healthyNodes = [chosen];
        else
          throw new Error("weightedRandom return empty");
      }
      for (const node of healthyNodes) {
        let url = `https://${this.host}/${node.NodeId}/${this.urlVersion}/${network}/${edgeProtocol}`;
        if (suffix.length)
          url += `/${suffix}`;
        res.push(url);
      }
      return res;
    }
  }
  lib.Access = Access;
  function getEndpoints(network, edgeProtocol, suffix, single) {
    return __awaiter(this, void 0, void 0, function* () {
      const access = new Access();
      yield access.init();
      const res = access.buildUrls(network, edgeProtocol, suffix, single);
      return res;
    });
  }
  function getHttpEndpoints(config, single) {
    return __awaiter(this, void 0, void 0, function* () {
      const network = (config === null || config === void 0 ? void 0 : config.network) ? config.network : "mainnet";
      let suffix = "jsonRPC";
      if ((config === null || config === void 0 ? void 0 : config.protocol) === "rest") {
        suffix = "";
      }
      return yield getEndpoints(network, "toncenter-api-v2", suffix, single);
    });
  }
  lib.getHttpEndpoints = getHttpEndpoints;
  function getHttpEndpoint(config) {
    return __awaiter(this, void 0, void 0, function* () {
      const endpoints = yield getHttpEndpoints(config, true);
      return endpoints[0];
    });
  }
  lib.getHttpEndpoint = getHttpEndpoint;
  function getHttpV4Endpoints(config, single) {
    return __awaiter(this, void 0, void 0, function* () {
      const network = (config === null || config === void 0 ? void 0 : config.network) ? config.network : "mainnet";
      if ((config === null || config === void 0 ? void 0 : config.protocol) === "json-rpc") {
        throw Error("config.protocol json-rpc is not supported for getTonApiV4Endpoints");
      }
      const suffix = "";
      return yield getEndpoints(network, "ton-api-v4", suffix, single);
    });
  }
  lib.getHttpV4Endpoints = getHttpV4Endpoints;
  function getHttpV4Endpoint(config) {
    return __awaiter(this, void 0, void 0, function* () {
      const endpoints = yield getHttpV4Endpoints(config, true);
      return endpoints[0];
    });
  }
  lib.getHttpV4Endpoint = getHttpV4Endpoint;
  return lib;
}
var hasRequiredTonClientApi;
function requireTonClientApi() {
  if (hasRequiredTonClientApi) return tonClientApi;
  hasRequiredTonClientApi = 1;
  Object.defineProperty(tonClientApi, "__esModule", { value: true });
  tonClientApi.createApi = void 0;
  const ton_1 = requireDist$1();
  const ton_access_1 = requireLib();
  async function createApi(network) {
    const endpoint = await (0, ton_access_1.getHttpV4Endpoint)({ network });
    return new ton_1.TonClient4({ endpoint, timeout: 15e3 });
  }
  tonClientApi.createApi = createApi;
  return tonClientApi;
}
var key = {};
var hasRequiredKey;
function requireKey() {
  if (hasRequiredKey) return key;
  hasRequiredKey = 1;
  Object.defineProperty(key, "__esModule", { value: true });
  key.importKey = void 0;
  const crypto_1 = requireDist$6();
  async function importKey(key2) {
    if (typeof key2 === "string") {
      return await (0, crypto_1.mnemonicToWalletKey)(key2.split(" "));
    } else if (Array.isArray(key2)) {
      return await (0, crypto_1.mnemonicToWalletKey)(key2);
    } else {
      return (0, crypto_1.keyPairFromSecretKey)(key2);
    }
  }
  key.importKey = importKey;
  return key;
}
var wallets = {};
var HighloadWalletContractV2 = {};
var hasRequiredHighloadWalletContractV2;
function requireHighloadWalletContractV2() {
  if (hasRequiredHighloadWalletContractV2) return HighloadWalletContractV2;
  hasRequiredHighloadWalletContractV2 = 1;
  Object.defineProperty(HighloadWalletContractV2, "__esModule", { value: true });
  HighloadWalletContractV2.HighloadWalletContractV2 = void 0;
  const core_1 = requireDist$5();
  const crypto_1 = requireDist$6();
  const utils_1 = requireUtils$1();
  let HighloadWalletContractV2$1 = class HighloadWalletContractV22 {
    constructor(workchain, publicKey, walletId) {
      this.workchain = workchain;
      this.publicKey = publicKey;
      if (walletId !== null && walletId !== void 0) {
        this.walletId = walletId;
      } else {
        this.walletId = 698983191 + workchain;
      }
      const code = core_1.Cell.fromBase64("te6cckEBCQEA5QABFP8A9KQT9LzyyAsBAgEgAgMCAUgEBQHq8oMI1xgg0x/TP/gjqh9TILnyY+1E0NMf0z/T//QE0VNggED0Dm+hMfJgUXO68qIH+QFUEIf5EPKjAvQE0fgAf44WIYAQ9HhvpSCYAtMH1DAB+wCRMuIBs+ZbgyWhyEA0gED0Q4rmMQHIyx8Tyz/L//QAye1UCAAE0DACASAGBwAXvZznaiaGmvmOuF/8AEG+X5dqJoaY+Y6Z/p/5j6AmipEEAgegc30JjJLb/JXdHxQANCCAQPSWb6VsEiCUMFMDud4gkzM2AZJsIeKzn55UWg==");
      const data = (0, core_1.beginCell)().storeUint(this.walletId, 32).storeUint(0, 64).storeBuffer(this.publicKey, 32).storeDict(null).endCell();
      this.init = { code, data };
      this.address = (0, core_1.contractAddress)(this.workchain, this.init);
    }
    static create(args) {
      return new HighloadWalletContractV22(args.workchain, args.publicKey, args.walletId);
    }
    /**
     * Get wallet balance.
     */
    async getBalance(provider) {
      const state = await provider.getState();
      return state.balance;
    }
    /**
     * Send signed message.
     */
    async send(provider, message) {
      await provider.external(message);
    }
    /**
     * Sign and send message.
     */
    async sendTransfer(provider, args) {
      const message = this.createTransfer(args);
      await this.send(provider, message);
    }
    /**
     * Create signed message.
     */
    createTransfer(args) {
      let seqno = Math.floor(Math.random() * (1 << 32));
      if (args.seqno !== null && args.seqno !== void 0) {
        seqno = args.seqno;
      }
      let timeout = 5 * 60;
      if (args.timeout !== null && args.timeout !== void 0 && args.timeout < timeout) {
        timeout = args.timeout;
      }
      let sendMode = core_1.SendMode.PAY_GAS_SEPARATELY | core_1.SendMode.IGNORE_ERRORS;
      if (args.sendMode !== null && args.sendMode !== void 0) {
        sendMode = args.sendMode;
      }
      let now = Date.now();
      if (args.now !== null && args.now !== void 0) {
        now = args.now;
      }
      return (0, core_1.beginCell)().store(storeSignedTransferHighloadWalletV2({
        secretKey: args.secretKey,
        messages: args.messages,
        seqno,
        sendMode,
        timeout,
        walletId: this.walletId,
        now
      })).endCell();
    }
    /**
     * Load signed message.
     */
    loadTransfer(src2) {
      return loadSignedTransferHighloadWalletV2(src2);
    }
    /**
     * Send signed message and wait for processing.
     */
    async sendTransferAndWait(provider, args, sleepInterval = 3e3) {
      const transfer = this.createTransfer(args);
      const { queryId } = this.loadTransfer(transfer.beginParse());
      while (true) {
        try {
          await provider.external(transfer);
        } catch (e) {
        }
        await (0, utils_1.sleep)(sleepInterval);
        const state = await provider.getState();
        if (state.state.type === "uninit") {
          continue;
        }
        const status = await this.getProcessedStatus(provider, queryId);
        if (status === "processed") {
          return;
        } else if (status === "forgotten") {
          throw new Error("The transfer was forgotten");
        }
      }
    }
    /**
     * Get processed status of message.
     */
    async getProcessedStatus(provider, queryId) {
      const { stack } = await provider.get("processed?", [{ type: "int", value: queryId }]);
      const processedStatus = stack.readBigNumber();
      switch (processedStatus) {
        case -1n:
          return "processed";
        case 0n:
          return "unprocessed";
        case 1n:
          return "forgotten";
        default:
          throw new Error("Unknown processed status " + processedStatus);
      }
    }
    /**
     * Create sender.
     */
    sender(provider, secretKey) {
      return {
        send: async (args) => {
          await this.sendTransferAndWait(provider, {
            secretKey,
            sendMode: args.sendMode,
            messages: [(0, core_1.internal)({
              to: args.to,
              value: args.value,
              bounce: args.bounce,
              init: args.init,
              body: args.body
            })]
          });
        },
        address: this.address
      };
    }
  };
  HighloadWalletContractV2.HighloadWalletContractV2 = HighloadWalletContractV2$1;
  function createMessageRelaxedValue() {
    return {
      serialize: (args, builder2) => {
        const { sendMode, message } = args;
        const messageRelaxed = (0, core_1.beginCell)().storeWritable((0, core_1.storeMessageRelaxed)(message));
        builder2.storeUint(sendMode, 8);
        builder2.storeRef(messageRelaxed);
      },
      parse: (src2) => {
        const sendMode = src2.loadUint(8);
        const message = (0, core_1.loadMessageRelaxed)(src2.loadRef().beginParse());
        return { sendMode, message };
      }
    };
  }
  function getQueryId(now, timeout, seqno) {
    const validUntil = Math.floor(now / 1e3) + timeout;
    return (BigInt(validUntil) << 32n) + BigInt(seqno);
  }
  function storeSignedTransferHighloadWalletV2(args) {
    return (builder2) => {
      const { secretKey, messages, seqno, sendMode, now, timeout, walletId } = args;
      const queryId = getQueryId(now, timeout, seqno);
      const dict = core_1.Dictionary.empty(core_1.Dictionary.Keys.Int(16), createMessageRelaxedValue());
      for (const [i, message] of messages.entries()) {
        dict.set(i, { sendMode, message });
      }
      const signedMessage = (0, core_1.beginCell)().storeUint(walletId, 32).storeUint(queryId, 64).storeDict(dict).endCell();
      const hash = signedMessage.hash();
      const signature = (0, crypto_1.sign)(hash, secretKey);
      builder2.storeBuffer(signature);
      builder2.storeSlice(signedMessage.beginParse());
    };
  }
  function loadSignedTransferHighloadWalletV2(src2) {
    const signature = src2.loadBuffer(64);
    const walletId = src2.loadUint(32);
    const queryId = src2.loadUintBig(64);
    const dict = src2.loadDict(core_1.Dictionary.Keys.Int(16), createMessageRelaxedValue());
    const messages = dict.values();
    return {
      signature,
      walletId,
      queryId,
      messages
    };
  }
  return HighloadWalletContractV2;
}
var hasRequiredWallets;
function requireWallets() {
  if (hasRequiredWallets) return wallets;
  hasRequiredWallets = 1;
  Object.defineProperty(wallets, "__esModule", { value: true });
  wallets.createSender = wallets.createWallet = wallets.createHighloadV2 = void 0;
  const HighloadWalletContractV2_1 = requireHighloadWalletContractV2();
  const ton_client_api_1 = requireTonClientApi();
  const WORKCHAIN = 0;
  function createHighloadV2(publicKey) {
    return HighloadWalletContractV2_1.HighloadWalletContractV2.create({ workchain: WORKCHAIN, publicKey });
  }
  wallets.createHighloadV2 = createHighloadV2;
  function createWallet(walletType, publicKey) {
    switch (walletType) {
      case "highload-v2":
        return createHighloadV2(publicKey);
      default:
        throw new Error("Unsupported wallet type");
    }
  }
  wallets.createWallet = createWallet;
  async function createSender(walletType, keypair, clientOrNetwork) {
    const isNetwork = clientOrNetwork === "testnet" || clientOrNetwork === "mainnet";
    const client = isNetwork ? await (0, ton_client_api_1.createApi)(clientOrNetwork) : clientOrNetwork;
    const wallet = createWallet(walletType, keypair.publicKey);
    return client.open(wallet).sender(keypair.secretKey);
  }
  wallets.createSender = createSender;
  return wallets;
}
var error = {};
var hasRequiredError;
function requireError() {
  if (hasRequiredError) return error;
  hasRequiredError = 1;
  Object.defineProperty(error, "__esModule", { value: true });
  error.NoSenderError = void 0;
  class NoSenderError extends Error {
    constructor() {
      super("Sender is not set");
    }
  }
  error.NoSenderError = NoSenderError;
  return error;
}
var TonAPI = {};
var axios_1;
var hasRequiredAxios;
function requireAxios() {
  if (hasRequiredAxios) return axios_1;
  hasRequiredAxios = 1;
  function bind(fn, thisArg) {
    return function wrap() {
      return fn.apply(thisArg, arguments);
    };
  }
  const { toString } = Object.prototype;
  const { getPrototypeOf } = Object;
  const { iterator, toStringTag } = Symbol;
  const kindOf = /* @__PURE__ */ ((cache) => (thing) => {
    const str = toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
  })(/* @__PURE__ */ Object.create(null));
  const kindOfTest = (type) => {
    type = type.toLowerCase();
    return (thing) => kindOf(thing) === type;
  };
  const typeOfTest = (type) => (thing) => typeof thing === type;
  const { isArray } = Array;
  const isUndefined = typeOfTest("undefined");
  function isBuffer2(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
  }
  const isArrayBuffer = kindOfTest("ArrayBuffer");
  function isArrayBufferView(val) {
    let result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
      result = ArrayBuffer.isView(val);
    } else {
      result = val && val.buffer && isArrayBuffer(val.buffer);
    }
    return result;
  }
  const isString = typeOfTest("string");
  const isFunction = typeOfTest("function");
  const isNumber = typeOfTest("number");
  const isObject = (thing) => thing !== null && typeof thing === "object";
  const isBoolean = (thing) => thing === true || thing === false;
  const isPlainObject = (val) => {
    if (kindOf(val) !== "object") {
      return false;
    }
    const prototype2 = getPrototypeOf(val);
    return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(toStringTag in val) && !(iterator in val);
  };
  const isEmptyObject = (val) => {
    if (!isObject(val) || isBuffer2(val)) {
      return false;
    }
    try {
      return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
    } catch (e) {
      return false;
    }
  };
  const isDate = kindOfTest("Date");
  const isFile = kindOfTest("File");
  const isBlob = kindOfTest("Blob");
  const isFileList = kindOfTest("FileList");
  const isStream = (val) => isObject(val) && isFunction(val.pipe);
  const isFormData = (thing) => {
    let kind;
    return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
    kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
  };
  const isURLSearchParams = kindOfTest("URLSearchParams");
  const [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
  const trim2 = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  function forEach(obj, fn, { allOwnKeys = false } = {}) {
    if (obj === null || typeof obj === "undefined") {
      return;
    }
    let i;
    let l;
    if (typeof obj !== "object") {
      obj = [obj];
    }
    if (isArray(obj)) {
      for (i = 0, l = obj.length; i < l; i++) {
        fn.call(null, obj[i], i, obj);
      }
    } else {
      if (isBuffer2(obj)) {
        return;
      }
      const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
      const len = keys.length;
      let key2;
      for (i = 0; i < len; i++) {
        key2 = keys[i];
        fn.call(null, obj[key2], key2, obj);
      }
    }
  }
  function findKey(obj, key2) {
    if (isBuffer2(obj)) {
      return null;
    }
    key2 = key2.toLowerCase();
    const keys = Object.keys(obj);
    let i = keys.length;
    let _key;
    while (i-- > 0) {
      _key = keys[i];
      if (key2 === _key.toLowerCase()) {
        return _key;
      }
    }
    return null;
  }
  const _global = (() => {
    if (typeof globalThis !== "undefined") return globalThis;
    return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : commonjsGlobal;
  })();
  const isContextDefined = (context) => !isUndefined(context) && context !== _global;
  function merge() {
    const { caseless } = isContextDefined(this) && this || {};
    const result = {};
    const assignValue = (val, key2) => {
      const targetKey = caseless && findKey(result, key2) || key2;
      if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
        result[targetKey] = merge(result[targetKey], val);
      } else if (isPlainObject(val)) {
        result[targetKey] = merge({}, val);
      } else if (isArray(val)) {
        result[targetKey] = val.slice();
      } else {
        result[targetKey] = val;
      }
    };
    for (let i = 0, l = arguments.length; i < l; i++) {
      arguments[i] && forEach(arguments[i], assignValue);
    }
    return result;
  }
  const extend = (a, b, thisArg, { allOwnKeys } = {}) => {
    forEach(b, (val, key2) => {
      if (thisArg && isFunction(val)) {
        a[key2] = bind(val, thisArg);
      } else {
        a[key2] = val;
      }
    }, { allOwnKeys });
    return a;
  };
  const stripBOM = (content2) => {
    if (content2.charCodeAt(0) === 65279) {
      content2 = content2.slice(1);
    }
    return content2;
  };
  const inherits = (constructor, superConstructor, props, descriptors2) => {
    constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
    constructor.prototype.constructor = constructor;
    Object.defineProperty(constructor, "super", {
      value: superConstructor.prototype
    });
    props && Object.assign(constructor.prototype, props);
  };
  const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
    let props;
    let i;
    let prop;
    const merged = {};
    destObj = destObj || {};
    if (sourceObj == null) return destObj;
    do {
      props = Object.getOwnPropertyNames(sourceObj);
      i = props.length;
      while (i-- > 0) {
        prop = props[i];
        if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
          destObj[prop] = sourceObj[prop];
          merged[prop] = true;
        }
      }
      sourceObj = filter !== false && getPrototypeOf(sourceObj);
    } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
    return destObj;
  };
  const endsWith = (str, searchString, position) => {
    str = String(str);
    if (position === void 0 || position > str.length) {
      position = str.length;
    }
    position -= searchString.length;
    const lastIndex = str.indexOf(searchString, position);
    return lastIndex !== -1 && lastIndex === position;
  };
  const toArray = (thing) => {
    if (!thing) return null;
    if (isArray(thing)) return thing;
    let i = thing.length;
    if (!isNumber(i)) return null;
    const arr = new Array(i);
    while (i-- > 0) {
      arr[i] = thing[i];
    }
    return arr;
  };
  const isTypedArray = /* @__PURE__ */ ((TypedArray) => {
    return (thing) => {
      return TypedArray && thing instanceof TypedArray;
    };
  })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
  const forEachEntry = (obj, fn) => {
    const generator2 = obj && obj[iterator];
    const _iterator = generator2.call(obj);
    let result;
    while ((result = _iterator.next()) && !result.done) {
      const pair = result.value;
      fn.call(obj, pair[0], pair[1]);
    }
  };
  const matchAll = (regExp, str) => {
    let matches;
    const arr = [];
    while ((matches = regExp.exec(str)) !== null) {
      arr.push(matches);
    }
    return arr;
  };
  const isHTMLForm = kindOfTest("HTMLFormElement");
  const toCamelCase = (str) => {
    return str.toLowerCase().replace(
      /[-_\s]([a-z\d])(\w*)/g,
      function replacer(m, p1, p2) {
        return p1.toUpperCase() + p2;
      }
    );
  };
  const hasOwnProperty2 = (({ hasOwnProperty: hasOwnProperty3 }) => (obj, prop) => hasOwnProperty3.call(obj, prop))(Object.prototype);
  const isRegExp = kindOfTest("RegExp");
  const reduceDescriptors = (obj, reducer) => {
    const descriptors2 = Object.getOwnPropertyDescriptors(obj);
    const reducedDescriptors = {};
    forEach(descriptors2, (descriptor2, name) => {
      let ret;
      if ((ret = reducer(descriptor2, name, obj)) !== false) {
        reducedDescriptors[name] = ret || descriptor2;
      }
    });
    Object.defineProperties(obj, reducedDescriptors);
  };
  const freezeMethods = (obj) => {
    reduceDescriptors(obj, (descriptor2, name) => {
      if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
        return false;
      }
      const value = obj[name];
      if (!isFunction(value)) return;
      descriptor2.enumerable = false;
      if ("writable" in descriptor2) {
        descriptor2.writable = false;
        return;
      }
      if (!descriptor2.set) {
        descriptor2.set = () => {
          throw Error("Can not rewrite read-only method '" + name + "'");
        };
      }
    });
  };
  const toObjectSet = (arrayOrString, delimiter) => {
    const obj = {};
    const define = (arr) => {
      arr.forEach((value) => {
        obj[value] = true;
      });
    };
    isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
    return obj;
  };
  const noop2 = () => {
  };
  const toFiniteNumber = (value, defaultValue) => {
    return value != null && Number.isFinite(value = +value) ? value : defaultValue;
  };
  function isSpecCompliantForm(thing) {
    return !!(thing && isFunction(thing.append) && thing[toStringTag] === "FormData" && thing[iterator]);
  }
  const toJSONObject = (obj) => {
    const stack = new Array(10);
    const visit2 = (source, i) => {
      if (isObject(source)) {
        if (stack.indexOf(source) >= 0) {
          return;
        }
        if (isBuffer2(source)) {
          return source;
        }
        if (!("toJSON" in source)) {
          stack[i] = source;
          const target = isArray(source) ? [] : {};
          forEach(source, (value, key2) => {
            const reducedValue = visit2(value, i + 1);
            !isUndefined(reducedValue) && (target[key2] = reducedValue);
          });
          stack[i] = void 0;
          return target;
        }
      }
      return source;
    };
    return visit2(obj, 0);
  };
  const isAsyncFn = kindOfTest("AsyncFunction");
  const isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
  const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
    if (setImmediateSupported) {
      return setImmediate;
    }
    return postMessageSupported ? ((token, callbacks) => {
      _global.addEventListener("message", ({ source, data }) => {
        if (source === _global && data === token) {
          callbacks.length && callbacks.shift()();
        }
      }, false);
      return (cb) => {
        callbacks.push(cb);
        _global.postMessage(token, "*");
      };
    })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
  })(
    typeof setImmediate === "function",
    isFunction(_global.postMessage)
  );
  const asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
  const isIterable = (thing) => thing != null && isFunction(thing[iterator]);
  var utils$12 = {
    isArray,
    isArrayBuffer,
    isBuffer: isBuffer2,
    isFormData,
    isArrayBufferView,
    isString,
    isNumber,
    isBoolean,
    isObject,
    isPlainObject,
    isEmptyObject,
    isReadableStream,
    isRequest,
    isResponse,
    isHeaders,
    isUndefined,
    isDate,
    isFile,
    isBlob,
    isRegExp,
    isFunction,
    isStream,
    isURLSearchParams,
    isTypedArray,
    isFileList,
    forEach,
    merge,
    extend,
    trim: trim2,
    stripBOM,
    inherits,
    toFlatObject,
    kindOf,
    kindOfTest,
    endsWith,
    toArray,
    forEachEntry,
    matchAll,
    isHTMLForm,
    hasOwnProperty: hasOwnProperty2,
    hasOwnProp: hasOwnProperty2,
    // an alias to avoid ESLint no-prototype-builtins detection
    reduceDescriptors,
    freezeMethods,
    toObjectSet,
    toCamelCase,
    noop: noop2,
    toFiniteNumber,
    findKey,
    global: _global,
    isContextDefined,
    isSpecCompliantForm,
    toJSONObject,
    isAsyncFn,
    isThenable,
    setImmediate: _setImmediate,
    asap,
    isIterable
  };
  function AxiosError(message, code, config, request, response) {
    Error.call(this);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error().stack;
    }
    this.message = message;
    this.name = "AxiosError";
    code && (this.code = code);
    config && (this.config = config);
    request && (this.request = request);
    if (response) {
      this.response = response;
      this.status = response.status ? response.status : null;
    }
  }
  utils$12.inherits(AxiosError, Error, {
    toJSON: function toJSON() {
      return {
        // Standard
        message: this.message,
        name: this.name,
        // Microsoft
        description: this.description,
        number: this.number,
        // Mozilla
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        // Axios
        config: utils$12.toJSONObject(this.config),
        code: this.code,
        status: this.status
      };
    }
  });
  const prototype$1 = AxiosError.prototype;
  const descriptors = {};
  [
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED",
    "ERR_NOT_SUPPORT",
    "ERR_INVALID_URL"
    // eslint-disable-next-line func-names
  ].forEach((code) => {
    descriptors[code] = { value: code };
  });
  Object.defineProperties(AxiosError, descriptors);
  Object.defineProperty(prototype$1, "isAxiosError", { value: true });
  AxiosError.from = (error2, code, config, request, response, customProps) => {
    const axiosError = Object.create(prototype$1);
    utils$12.toFlatObject(error2, axiosError, function filter(obj) {
      return obj !== Error.prototype;
    }, (prop) => {
      return prop !== "isAxiosError";
    });
    AxiosError.call(axiosError, error2.message, code, config, request, response);
    axiosError.cause = error2;
    axiosError.name = error2.name;
    customProps && Object.assign(axiosError, customProps);
    return axiosError;
  };
  var httpAdapter = null;
  function isVisitable(thing) {
    return utils$12.isPlainObject(thing) || utils$12.isArray(thing);
  }
  function removeBrackets(key2) {
    return utils$12.endsWith(key2, "[]") ? key2.slice(0, -2) : key2;
  }
  function renderKey(path, key2, dots) {
    if (!path) return key2;
    return path.concat(key2).map(function each(token, i) {
      token = removeBrackets(token);
      return !dots && i ? "[" + token + "]" : token;
    }).join(dots ? "." : "");
  }
  function isFlatArray(arr) {
    return utils$12.isArray(arr) && !arr.some(isVisitable);
  }
  const predicates = utils$12.toFlatObject(utils$12, {}, null, function filter(prop) {
    return /^is[A-Z]/.test(prop);
  });
  function toFormData(obj, formData, options) {
    if (!utils$12.isObject(obj)) {
      throw new TypeError("target must be an object");
    }
    formData = formData || new FormData();
    options = utils$12.toFlatObject(options, {
      metaTokens: true,
      dots: false,
      indexes: false
    }, false, function defined(option, source) {
      return !utils$12.isUndefined(source[option]);
    });
    const metaTokens = options.metaTokens;
    const visitor = options.visitor || defaultVisitor;
    const dots = options.dots;
    const indexes = options.indexes;
    const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
    const useBlob = _Blob && utils$12.isSpecCompliantForm(formData);
    if (!utils$12.isFunction(visitor)) {
      throw new TypeError("visitor must be a function");
    }
    function convertValue(value) {
      if (value === null) return "";
      if (utils$12.isDate(value)) {
        return value.toISOString();
      }
      if (utils$12.isBoolean(value)) {
        return value.toString();
      }
      if (!useBlob && utils$12.isBlob(value)) {
        throw new AxiosError("Blob is not supported. Use a Buffer instead.");
      }
      if (utils$12.isArrayBuffer(value) || utils$12.isTypedArray(value)) {
        return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
      }
      return value;
    }
    function defaultVisitor(value, key2, path) {
      let arr = value;
      if (value && !path && typeof value === "object") {
        if (utils$12.endsWith(key2, "{}")) {
          key2 = metaTokens ? key2 : key2.slice(0, -2);
          value = JSON.stringify(value);
        } else if (utils$12.isArray(value) && isFlatArray(value) || (utils$12.isFileList(value) || utils$12.endsWith(key2, "[]")) && (arr = utils$12.toArray(value))) {
          key2 = removeBrackets(key2);
          arr.forEach(function each(el, index) {
            !(utils$12.isUndefined(el) || el === null) && formData.append(
              // eslint-disable-next-line no-nested-ternary
              indexes === true ? renderKey([key2], index, dots) : indexes === null ? key2 : key2 + "[]",
              convertValue(el)
            );
          });
          return false;
        }
      }
      if (isVisitable(value)) {
        return true;
      }
      formData.append(renderKey(path, key2, dots), convertValue(value));
      return false;
    }
    const stack = [];
    const exposedHelpers = Object.assign(predicates, {
      defaultVisitor,
      convertValue,
      isVisitable
    });
    function build2(value, path) {
      if (utils$12.isUndefined(value)) return;
      if (stack.indexOf(value) !== -1) {
        throw Error("Circular reference detected in " + path.join("."));
      }
      stack.push(value);
      utils$12.forEach(value, function each(el, key2) {
        const result = !(utils$12.isUndefined(el) || el === null) && visitor.call(
          formData,
          el,
          utils$12.isString(key2) ? key2.trim() : key2,
          path,
          exposedHelpers
        );
        if (result === true) {
          build2(el, path ? path.concat(key2) : [key2]);
        }
      });
      stack.pop();
    }
    if (!utils$12.isObject(obj)) {
      throw new TypeError("data must be an object");
    }
    build2(obj);
    return formData;
  }
  function encode$1(str) {
    const charMap = {
      "!": "%21",
      "'": "%27",
      "(": "%28",
      ")": "%29",
      "~": "%7E",
      "%20": "+",
      "%00": "\0"
    };
    return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
      return charMap[match];
    });
  }
  function AxiosURLSearchParams(params, options) {
    this._pairs = [];
    params && toFormData(params, this, options);
  }
  const prototype = AxiosURLSearchParams.prototype;
  prototype.append = function append(name, value) {
    this._pairs.push([name, value]);
  };
  prototype.toString = function toString2(encoder) {
    const _encode = encoder ? function(value) {
      return encoder.call(this, value, encode$1);
    } : encode$1;
    return this._pairs.map(function each(pair) {
      return _encode(pair[0]) + "=" + _encode(pair[1]);
    }, "").join("&");
  };
  function encode(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  }
  function buildURL(url, params, options) {
    if (!params) {
      return url;
    }
    const _encode = options && options.encode || encode;
    if (utils$12.isFunction(options)) {
      options = {
        serialize: options
      };
    }
    const serializeFn = options && options.serialize;
    let serializedParams;
    if (serializeFn) {
      serializedParams = serializeFn(params, options);
    } else {
      serializedParams = utils$12.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
    }
    if (serializedParams) {
      const hashmarkIndex = url.indexOf("#");
      if (hashmarkIndex !== -1) {
        url = url.slice(0, hashmarkIndex);
      }
      url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url;
  }
  class InterceptorManager {
    constructor() {
      this.handlers = [];
    }
    /**
     * Add a new interceptor to the stack
     *
     * @param {Function} fulfilled The function to handle `then` for a `Promise`
     * @param {Function} rejected The function to handle `reject` for a `Promise`
     *
     * @return {Number} An ID used to remove interceptor later
     */
    use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    }
    /**
     * Remove an interceptor from the stack
     *
     * @param {Number} id The ID that was returned by `use`
     *
     * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
     */
    eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    }
    /**
     * Clear all interceptors from the stack
     *
     * @returns {void}
     */
    clear() {
      if (this.handlers) {
        this.handlers = [];
      }
    }
    /**
     * Iterate over all the registered interceptors
     *
     * This method is particularly useful for skipping over any
     * interceptors that may have become `null` calling `eject`.
     *
     * @param {Function} fn The function to call for each interceptor
     *
     * @returns {void}
     */
    forEach(fn) {
      utils$12.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    }
  }
  var InterceptorManager$1 = InterceptorManager;
  var transitionalDefaults = {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  };
  var URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
  var FormData$1 = typeof FormData !== "undefined" ? FormData : null;
  var Blob$1 = typeof Blob !== "undefined" ? Blob : null;
  var platform$1 = {
    isBrowser: true,
    classes: {
      URLSearchParams: URLSearchParams$1,
      FormData: FormData$1,
      Blob: Blob$1
    },
    protocols: ["http", "https", "file", "blob", "url", "data"]
  };
  const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
  const _navigator = typeof navigator === "object" && navigator || void 0;
  const hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
  const hasStandardBrowserWebWorkerEnv = (() => {
    return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
  })();
  const origin = hasBrowserEnv && window.location.href || "http://localhost";
  var utils2 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    hasBrowserEnv,
    hasStandardBrowserWebWorkerEnv,
    hasStandardBrowserEnv,
    navigator: _navigator,
    origin
  });
  var platform = {
    ...utils2,
    ...platform$1
  };
  function toURLEncodedForm(data, options) {
    return toFormData(data, new platform.classes.URLSearchParams(), {
      visitor: function(value, key2, path, helpers) {
        if (platform.isNode && utils$12.isBuffer(value)) {
          this.append(key2, value.toString("base64"));
          return false;
        }
        return helpers.defaultVisitor.apply(this, arguments);
      },
      ...options
    });
  }
  function parsePropPath(name) {
    return utils$12.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
      return match[0] === "[]" ? "" : match[1] || match[0];
    });
  }
  function arrayToObject(arr) {
    const obj = {};
    const keys = Object.keys(arr);
    let i;
    const len = keys.length;
    let key2;
    for (i = 0; i < len; i++) {
      key2 = keys[i];
      obj[key2] = arr[key2];
    }
    return obj;
  }
  function formDataToJSON(formData) {
    function buildPath(path, value, target, index) {
      let name = path[index++];
      if (name === "__proto__") return true;
      const isNumericKey = Number.isFinite(+name);
      const isLast = index >= path.length;
      name = !name && utils$12.isArray(target) ? target.length : name;
      if (isLast) {
        if (utils$12.hasOwnProp(target, name)) {
          target[name] = [target[name], value];
        } else {
          target[name] = value;
        }
        return !isNumericKey;
      }
      if (!target[name] || !utils$12.isObject(target[name])) {
        target[name] = [];
      }
      const result = buildPath(path, value, target[name], index);
      if (result && utils$12.isArray(target[name])) {
        target[name] = arrayToObject(target[name]);
      }
      return !isNumericKey;
    }
    if (utils$12.isFormData(formData) && utils$12.isFunction(formData.entries)) {
      const obj = {};
      utils$12.forEachEntry(formData, (name, value) => {
        buildPath(parsePropPath(name), value, obj, 0);
      });
      return obj;
    }
    return null;
  }
  function stringifySafely(rawValue, parser2, encoder) {
    if (utils$12.isString(rawValue)) {
      try {
        (parser2 || JSON.parse)(rawValue);
        return utils$12.trim(rawValue);
      } catch (e) {
        if (e.name !== "SyntaxError") {
          throw e;
        }
      }
    }
    return (encoder || JSON.stringify)(rawValue);
  }
  const defaults = {
    transitional: transitionalDefaults,
    adapter: ["xhr", "http", "fetch"],
    transformRequest: [function transformRequest(data, headers) {
      const contentType = headers.getContentType() || "";
      const hasJSONContentType = contentType.indexOf("application/json") > -1;
      const isObjectPayload = utils$12.isObject(data);
      if (isObjectPayload && utils$12.isHTMLForm(data)) {
        data = new FormData(data);
      }
      const isFormData2 = utils$12.isFormData(data);
      if (isFormData2) {
        return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
      }
      if (utils$12.isArrayBuffer(data) || utils$12.isBuffer(data) || utils$12.isStream(data) || utils$12.isFile(data) || utils$12.isBlob(data) || utils$12.isReadableStream(data)) {
        return data;
      }
      if (utils$12.isArrayBufferView(data)) {
        return data.buffer;
      }
      if (utils$12.isURLSearchParams(data)) {
        headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
        return data.toString();
      }
      let isFileList2;
      if (isObjectPayload) {
        if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
          return toURLEncodedForm(data, this.formSerializer).toString();
        }
        if ((isFileList2 = utils$12.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
          const _FormData = this.env && this.env.FormData;
          return toFormData(
            isFileList2 ? { "files[]": data } : data,
            _FormData && new _FormData(),
            this.formSerializer
          );
        }
      }
      if (isObjectPayload || hasJSONContentType) {
        headers.setContentType("application/json", false);
        return stringifySafely(data);
      }
      return data;
    }],
    transformResponse: [function transformResponse(data) {
      const transitional = this.transitional || defaults.transitional;
      const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
      const JSONRequested = this.responseType === "json";
      if (utils$12.isResponse(data) || utils$12.isReadableStream(data)) {
        return data;
      }
      if (data && utils$12.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
        const silentJSONParsing = transitional && transitional.silentJSONParsing;
        const strictJSONParsing = !silentJSONParsing && JSONRequested;
        try {
          return JSON.parse(data);
        } catch (e) {
          if (strictJSONParsing) {
            if (e.name === "SyntaxError") {
              throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
            }
            throw e;
          }
        }
      }
      return data;
    }],
    /**
     * A timeout in milliseconds to abort a request. If set to 0 (default) a
     * timeout is not created.
     */
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
      FormData: platform.classes.FormData,
      Blob: platform.classes.Blob
    },
    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    },
    headers: {
      common: {
        "Accept": "application/json, text/plain, */*",
        "Content-Type": void 0
      }
    }
  };
  utils$12.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
    defaults.headers[method] = {};
  });
  var defaults$1 = defaults;
  const ignoreDuplicateOf = utils$12.toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ]);
  var parseHeaders2 = (rawHeaders) => {
    const parsed = {};
    let key2;
    let val;
    let i;
    rawHeaders && rawHeaders.split("\n").forEach(function parser2(line) {
      i = line.indexOf(":");
      key2 = line.substring(0, i).trim().toLowerCase();
      val = line.substring(i + 1).trim();
      if (!key2 || parsed[key2] && ignoreDuplicateOf[key2]) {
        return;
      }
      if (key2 === "set-cookie") {
        if (parsed[key2]) {
          parsed[key2].push(val);
        } else {
          parsed[key2] = [val];
        }
      } else {
        parsed[key2] = parsed[key2] ? parsed[key2] + ", " + val : val;
      }
    });
    return parsed;
  };
  const $internals = Symbol("internals");
  function normalizeHeader(header) {
    return header && String(header).trim().toLowerCase();
  }
  function normalizeValue2(value) {
    if (value === false || value == null) {
      return value;
    }
    return utils$12.isArray(value) ? value.map(normalizeValue2) : String(value);
  }
  function parseTokens(str) {
    const tokens = /* @__PURE__ */ Object.create(null);
    const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let match;
    while (match = tokensRE.exec(str)) {
      tokens[match[1]] = match[2];
    }
    return tokens;
  }
  const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
  function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
    if (utils$12.isFunction(filter)) {
      return filter.call(this, value, header);
    }
    if (isHeaderNameFilter) {
      value = header;
    }
    if (!utils$12.isString(value)) return;
    if (utils$12.isString(filter)) {
      return value.indexOf(filter) !== -1;
    }
    if (utils$12.isRegExp(filter)) {
      return filter.test(value);
    }
  }
  function formatHeader(header) {
    return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
      return char.toUpperCase() + str;
    });
  }
  function buildAccessors(obj, header) {
    const accessorName = utils$12.toCamelCase(" " + header);
    ["get", "set", "has"].forEach((methodName) => {
      Object.defineProperty(obj, methodName + accessorName, {
        value: function(arg1, arg2, arg3) {
          return this[methodName].call(this, header, arg1, arg2, arg3);
        },
        configurable: true
      });
    });
  }
  class AxiosHeaders {
    constructor(headers) {
      headers && this.set(headers);
    }
    set(header, valueOrRewrite, rewrite) {
      const self2 = this;
      function setHeader(_value, _header, _rewrite) {
        const lHeader = normalizeHeader(_header);
        if (!lHeader) {
          throw new Error("header name must be a non-empty string");
        }
        const key2 = utils$12.findKey(self2, lHeader);
        if (!key2 || self2[key2] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key2] !== false) {
          self2[key2 || _header] = normalizeValue2(_value);
        }
      }
      const setHeaders = (headers, _rewrite) => utils$12.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
      if (utils$12.isPlainObject(header) || header instanceof this.constructor) {
        setHeaders(header, valueOrRewrite);
      } else if (utils$12.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
        setHeaders(parseHeaders2(header), valueOrRewrite);
      } else if (utils$12.isObject(header) && utils$12.isIterable(header)) {
        let obj = {}, dest, key2;
        for (const entry of header) {
          if (!utils$12.isArray(entry)) {
            throw TypeError("Object iterator must return a key-value pair");
          }
          obj[key2 = entry[0]] = (dest = obj[key2]) ? utils$12.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
        }
        setHeaders(obj, valueOrRewrite);
      } else {
        header != null && setHeader(valueOrRewrite, header, rewrite);
      }
      return this;
    }
    get(header, parser2) {
      header = normalizeHeader(header);
      if (header) {
        const key2 = utils$12.findKey(this, header);
        if (key2) {
          const value = this[key2];
          if (!parser2) {
            return value;
          }
          if (parser2 === true) {
            return parseTokens(value);
          }
          if (utils$12.isFunction(parser2)) {
            return parser2.call(this, value, key2);
          }
          if (utils$12.isRegExp(parser2)) {
            return parser2.exec(value);
          }
          throw new TypeError("parser must be boolean|regexp|function");
        }
      }
    }
    has(header, matcher) {
      header = normalizeHeader(header);
      if (header) {
        const key2 = utils$12.findKey(this, header);
        return !!(key2 && this[key2] !== void 0 && (!matcher || matchHeaderValue(this, this[key2], key2, matcher)));
      }
      return false;
    }
    delete(header, matcher) {
      const self2 = this;
      let deleted = false;
      function deleteHeader(_header) {
        _header = normalizeHeader(_header);
        if (_header) {
          const key2 = utils$12.findKey(self2, _header);
          if (key2 && (!matcher || matchHeaderValue(self2, self2[key2], key2, matcher))) {
            delete self2[key2];
            deleted = true;
          }
        }
      }
      if (utils$12.isArray(header)) {
        header.forEach(deleteHeader);
      } else {
        deleteHeader(header);
      }
      return deleted;
    }
    clear(matcher) {
      const keys = Object.keys(this);
      let i = keys.length;
      let deleted = false;
      while (i--) {
        const key2 = keys[i];
        if (!matcher || matchHeaderValue(this, this[key2], key2, matcher, true)) {
          delete this[key2];
          deleted = true;
        }
      }
      return deleted;
    }
    normalize(format) {
      const self2 = this;
      const headers = {};
      utils$12.forEach(this, (value, header) => {
        const key2 = utils$12.findKey(headers, header);
        if (key2) {
          self2[key2] = normalizeValue2(value);
          delete self2[header];
          return;
        }
        const normalized = format ? formatHeader(header) : String(header).trim();
        if (normalized !== header) {
          delete self2[header];
        }
        self2[normalized] = normalizeValue2(value);
        headers[normalized] = true;
      });
      return this;
    }
    concat(...targets) {
      return this.constructor.concat(this, ...targets);
    }
    toJSON(asStrings) {
      const obj = /* @__PURE__ */ Object.create(null);
      utils$12.forEach(this, (value, header) => {
        value != null && value !== false && (obj[header] = asStrings && utils$12.isArray(value) ? value.join(", ") : value);
      });
      return obj;
    }
    [Symbol.iterator]() {
      return Object.entries(this.toJSON())[Symbol.iterator]();
    }
    toString() {
      return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
    }
    getSetCookie() {
      return this.get("set-cookie") || [];
    }
    get [Symbol.toStringTag]() {
      return "AxiosHeaders";
    }
    static from(thing) {
      return thing instanceof this ? thing : new this(thing);
    }
    static concat(first, ...targets) {
      const computed = new this(first);
      targets.forEach((target) => computed.set(target));
      return computed;
    }
    static accessor(header) {
      const internals = this[$internals] = this[$internals] = {
        accessors: {}
      };
      const accessors = internals.accessors;
      const prototype2 = this.prototype;
      function defineAccessor(_header) {
        const lHeader = normalizeHeader(_header);
        if (!accessors[lHeader]) {
          buildAccessors(prototype2, _header);
          accessors[lHeader] = true;
        }
      }
      utils$12.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
      return this;
    }
  }
  AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
  utils$12.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key2) => {
    let mapped = key2[0].toUpperCase() + key2.slice(1);
    return {
      get: () => value,
      set(headerValue) {
        this[mapped] = headerValue;
      }
    };
  });
  utils$12.freezeMethods(AxiosHeaders);
  var AxiosHeaders$1 = AxiosHeaders;
  function transformData(fns, response) {
    const config = this || defaults$1;
    const context = response || config;
    const headers = AxiosHeaders$1.from(context.headers);
    let data = context.data;
    utils$12.forEach(fns, function transform(fn) {
      data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
    });
    headers.normalize();
    return data;
  }
  function isCancel(value) {
    return !!(value && value.__CANCEL__);
  }
  function CanceledError(message, config, request) {
    AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request);
    this.name = "CanceledError";
  }
  utils$12.inherits(CanceledError, AxiosError, {
    __CANCEL__: true
  });
  function settle(resolve, reject, response) {
    const validateStatus = response.config.validateStatus;
    if (!response.status || !validateStatus || validateStatus(response.status)) {
      resolve(response);
    } else {
      reject(new AxiosError(
        "Request failed with status code " + response.status,
        [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
        response.config,
        response.request,
        response
      ));
    }
  }
  function parseProtocol(url) {
    const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
    return match && match[1] || "";
  }
  function speedometer(samplesCount, min) {
    samplesCount = samplesCount || 10;
    const bytes = new Array(samplesCount);
    const timestamps = new Array(samplesCount);
    let head = 0;
    let tail = 0;
    let firstSampleTS;
    min = min !== void 0 ? min : 1e3;
    return function push(chunkLength) {
      const now = Date.now();
      const startedAt = timestamps[tail];
      if (!firstSampleTS) {
        firstSampleTS = now;
      }
      bytes[head] = chunkLength;
      timestamps[head] = now;
      let i = tail;
      let bytesCount = 0;
      while (i !== head) {
        bytesCount += bytes[i++];
        i = i % samplesCount;
      }
      head = (head + 1) % samplesCount;
      if (head === tail) {
        tail = (tail + 1) % samplesCount;
      }
      if (now - firstSampleTS < min) {
        return;
      }
      const passed = startedAt && now - startedAt;
      return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
    };
  }
  function throttle(fn, freq) {
    let timestamp = 0;
    let threshold = 1e3 / freq;
    let lastArgs;
    let timer;
    const invoke = (args, now = Date.now()) => {
      timestamp = now;
      lastArgs = null;
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      fn(...args);
    };
    const throttled = (...args) => {
      const now = Date.now();
      const passed = now - timestamp;
      if (passed >= threshold) {
        invoke(args, now);
      } else {
        lastArgs = args;
        if (!timer) {
          timer = setTimeout(() => {
            timer = null;
            invoke(lastArgs);
          }, threshold - passed);
        }
      }
    };
    const flush = () => lastArgs && invoke(lastArgs);
    return [throttled, flush];
  }
  const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
    let bytesNotified = 0;
    const _speedometer = speedometer(50, 250);
    return throttle((e) => {
      const loaded = e.loaded;
      const total = e.lengthComputable ? e.total : void 0;
      const progressBytes = loaded - bytesNotified;
      const rate = _speedometer(progressBytes);
      const inRange = loaded <= total;
      bytesNotified = loaded;
      const data = {
        loaded,
        total,
        progress: total ? loaded / total : void 0,
        bytes: progressBytes,
        rate: rate ? rate : void 0,
        estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
        event: e,
        lengthComputable: total != null,
        [isDownloadStream ? "download" : "upload"]: true
      };
      listener(data);
    }, freq);
  };
  const progressEventDecorator = (total, throttled) => {
    const lengthComputable = total != null;
    return [(loaded) => throttled[0]({
      lengthComputable,
      total,
      loaded
    }), throttled[1]];
  };
  const asyncDecorator = (fn) => (...args) => utils$12.asap(() => fn(...args));
  var isURLSameOrigin = platform.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url) => {
    url = new URL(url, platform.origin);
    return origin2.protocol === url.protocol && origin2.host === url.host && (isMSIE || origin2.port === url.port);
  })(
    new URL(platform.origin),
    platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)
  ) : () => true;
  var cookies = platform.hasStandardBrowserEnv ? (
    // Standard browser envs support document.cookie
    {
      write(name, value, expires, path, domain, secure) {
        const cookie = [name + "=" + encodeURIComponent(value)];
        utils$12.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
        utils$12.isString(path) && cookie.push("path=" + path);
        utils$12.isString(domain) && cookie.push("domain=" + domain);
        secure === true && cookie.push("secure");
        document.cookie = cookie.join("; ");
      },
      read(name) {
        const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
        return match ? decodeURIComponent(match[3]) : null;
      },
      remove(name) {
        this.write(name, "", Date.now() - 864e5);
      }
    }
  ) : (
    // Non-standard browser env (web workers, react-native) lack needed support.
    {
      write() {
      },
      read() {
        return null;
      },
      remove() {
      }
    }
  );
  function isAbsoluteURL(url) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
  }
  function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
  }
  function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
    let isRelativeUrl = !isAbsoluteURL(requestedURL);
    if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
      return combineURLs(baseURL, requestedURL);
    }
    return requestedURL;
  }
  const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;
  function mergeConfig(config1, config2) {
    config2 = config2 || {};
    const config = {};
    function getMergedValue(target, source, prop, caseless) {
      if (utils$12.isPlainObject(target) && utils$12.isPlainObject(source)) {
        return utils$12.merge.call({ caseless }, target, source);
      } else if (utils$12.isPlainObject(source)) {
        return utils$12.merge({}, source);
      } else if (utils$12.isArray(source)) {
        return source.slice();
      }
      return source;
    }
    function mergeDeepProperties(a, b, prop, caseless) {
      if (!utils$12.isUndefined(b)) {
        return getMergedValue(a, b, prop, caseless);
      } else if (!utils$12.isUndefined(a)) {
        return getMergedValue(void 0, a, prop, caseless);
      }
    }
    function valueFromConfig2(a, b) {
      if (!utils$12.isUndefined(b)) {
        return getMergedValue(void 0, b);
      }
    }
    function defaultToConfig2(a, b) {
      if (!utils$12.isUndefined(b)) {
        return getMergedValue(void 0, b);
      } else if (!utils$12.isUndefined(a)) {
        return getMergedValue(void 0, a);
      }
    }
    function mergeDirectKeys(a, b, prop) {
      if (prop in config2) {
        return getMergedValue(a, b);
      } else if (prop in config1) {
        return getMergedValue(void 0, a);
      }
    }
    const mergeMap = {
      url: valueFromConfig2,
      method: valueFromConfig2,
      data: valueFromConfig2,
      baseURL: defaultToConfig2,
      transformRequest: defaultToConfig2,
      transformResponse: defaultToConfig2,
      paramsSerializer: defaultToConfig2,
      timeout: defaultToConfig2,
      timeoutMessage: defaultToConfig2,
      withCredentials: defaultToConfig2,
      withXSRFToken: defaultToConfig2,
      adapter: defaultToConfig2,
      responseType: defaultToConfig2,
      xsrfCookieName: defaultToConfig2,
      xsrfHeaderName: defaultToConfig2,
      onUploadProgress: defaultToConfig2,
      onDownloadProgress: defaultToConfig2,
      decompress: defaultToConfig2,
      maxContentLength: defaultToConfig2,
      maxBodyLength: defaultToConfig2,
      beforeRedirect: defaultToConfig2,
      transport: defaultToConfig2,
      httpAgent: defaultToConfig2,
      httpsAgent: defaultToConfig2,
      cancelToken: defaultToConfig2,
      socketPath: defaultToConfig2,
      responseEncoding: defaultToConfig2,
      validateStatus: mergeDirectKeys,
      headers: (a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
    };
    utils$12.forEach(Object.keys({ ...config1, ...config2 }), function computeConfigValue(prop) {
      const merge2 = mergeMap[prop] || mergeDeepProperties;
      const configValue = merge2(config1[prop], config2[prop], prop);
      utils$12.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
    });
    return config;
  }
  var resolveConfig = (config) => {
    const newConfig = mergeConfig({}, config);
    let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
    newConfig.headers = headers = AxiosHeaders$1.from(headers);
    newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);
    if (auth) {
      headers.set(
        "Authorization",
        "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
      );
    }
    let contentType;
    if (utils$12.isFormData(data)) {
      if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
        headers.setContentType(void 0);
      } else if ((contentType = headers.getContentType()) !== false) {
        const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
        headers.setContentType([type || "multipart/form-data", ...tokens].join("; "));
      }
    }
    if (platform.hasStandardBrowserEnv) {
      withXSRFToken && utils$12.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
      if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
        const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
        if (xsrfValue) {
          headers.set(xsrfHeaderName, xsrfValue);
        }
      }
    }
    return newConfig;
  };
  const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
  var xhrAdapter = isXHRAdapterSupported && function(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
      const _config = resolveConfig(config);
      let requestData = _config.data;
      const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
      let { responseType, onUploadProgress, onDownloadProgress } = _config;
      let onCanceled;
      let uploadThrottled, downloadThrottled;
      let flushUpload, flushDownload;
      function done() {
        flushUpload && flushUpload();
        flushDownload && flushDownload();
        _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
        _config.signal && _config.signal.removeEventListener("abort", onCanceled);
      }
      let request = new XMLHttpRequest();
      request.open(_config.method.toUpperCase(), _config.url, true);
      request.timeout = _config.timeout;
      function onloadend() {
        if (!request) {
          return;
        }
        const responseHeaders = AxiosHeaders$1.from(
          "getAllResponseHeaders" in request && request.getAllResponseHeaders()
        );
        const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
        const response = {
          data: responseData,
          status: request.status,
          statusText: request.statusText,
          headers: responseHeaders,
          config,
          request
        };
        settle(function _resolve(value) {
          resolve(value);
          done();
        }, function _reject(err) {
          reject(err);
          done();
        }, response);
        request = null;
      }
      if ("onloadend" in request) {
        request.onloadend = onloadend;
      } else {
        request.onreadystatechange = function handleLoad() {
          if (!request || request.readyState !== 4) {
            return;
          }
          if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
            return;
          }
          setTimeout(onloadend);
        };
      }
      request.onabort = function handleAbort() {
        if (!request) {
          return;
        }
        reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
        request = null;
      };
      request.onerror = function handleError() {
        reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request));
        request = null;
      };
      request.ontimeout = function handleTimeout() {
        let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
        const transitional = _config.transitional || transitionalDefaults;
        if (_config.timeoutErrorMessage) {
          timeoutErrorMessage = _config.timeoutErrorMessage;
        }
        reject(new AxiosError(
          timeoutErrorMessage,
          transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
          config,
          request
        ));
        request = null;
      };
      requestData === void 0 && requestHeaders.setContentType(null);
      if ("setRequestHeader" in request) {
        utils$12.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key2) {
          request.setRequestHeader(key2, val);
        });
      }
      if (!utils$12.isUndefined(_config.withCredentials)) {
        request.withCredentials = !!_config.withCredentials;
      }
      if (responseType && responseType !== "json") {
        request.responseType = _config.responseType;
      }
      if (onDownloadProgress) {
        [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
        request.addEventListener("progress", downloadThrottled);
      }
      if (onUploadProgress && request.upload) {
        [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
        request.upload.addEventListener("progress", uploadThrottled);
        request.upload.addEventListener("loadend", flushUpload);
      }
      if (_config.cancelToken || _config.signal) {
        onCanceled = (cancel) => {
          if (!request) {
            return;
          }
          reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
          request.abort();
          request = null;
        };
        _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
        if (_config.signal) {
          _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
        }
      }
      const protocol = parseProtocol(_config.url);
      if (protocol && platform.protocols.indexOf(protocol) === -1) {
        reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
        return;
      }
      request.send(requestData || null);
    });
  };
  const composeSignals = (signals, timeout) => {
    const { length } = signals = signals ? signals.filter(Boolean) : [];
    if (timeout || length) {
      let controller = new AbortController();
      let aborted;
      const onabort = function(reason) {
        if (!aborted) {
          aborted = true;
          unsubscribe();
          const err = reason instanceof Error ? reason : this.reason;
          controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));
        }
      };
      let timer = timeout && setTimeout(() => {
        timer = null;
        onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT));
      }, timeout);
      const unsubscribe = () => {
        if (signals) {
          timer && clearTimeout(timer);
          timer = null;
          signals.forEach((signal2) => {
            signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
          });
          signals = null;
        }
      };
      signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
      const { signal } = controller;
      signal.unsubscribe = () => utils$12.asap(unsubscribe);
      return signal;
    }
  };
  var composeSignals$1 = composeSignals;
  const streamChunk = function* (chunk, chunkSize) {
    let len = chunk.byteLength;
    if (len < chunkSize) {
      yield chunk;
      return;
    }
    let pos = 0;
    let end2;
    while (pos < len) {
      end2 = pos + chunkSize;
      yield chunk.slice(pos, end2);
      pos = end2;
    }
  };
  const readBytes = async function* (iterable, chunkSize) {
    for await (const chunk of readStream(iterable)) {
      yield* streamChunk(chunk, chunkSize);
    }
  };
  const readStream = async function* (stream) {
    if (stream[Symbol.asyncIterator]) {
      yield* stream;
      return;
    }
    const reader2 = stream.getReader();
    try {
      for (; ; ) {
        const { done, value } = await reader2.read();
        if (done) {
          break;
        }
        yield value;
      }
    } finally {
      await reader2.cancel();
    }
  };
  const trackStream = (stream, chunkSize, onProgress, onFinish) => {
    const iterator2 = readBytes(stream, chunkSize);
    let bytes = 0;
    let done;
    let _onFinish = (e) => {
      if (!done) {
        done = true;
        onFinish && onFinish(e);
      }
    };
    return new ReadableStream({
      async pull(controller) {
        try {
          const { done: done2, value } = await iterator2.next();
          if (done2) {
            _onFinish();
            controller.close();
            return;
          }
          let len = value.byteLength;
          if (onProgress) {
            let loadedBytes = bytes += len;
            onProgress(loadedBytes);
          }
          controller.enqueue(new Uint8Array(value));
        } catch (err) {
          _onFinish(err);
          throw err;
        }
      },
      cancel(reason) {
        _onFinish(reason);
        return iterator2.return();
      }
    }, {
      highWaterMark: 2
    });
  };
  const isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
  const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
  const encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
  const test = (fn, ...args) => {
    try {
      return !!fn(...args);
    } catch (e) {
      return false;
    }
  };
  const supportsRequestStream = isReadableStreamSupported && test(() => {
    let duplexAccessed = false;
    const hasContentType = new Request(platform.origin, {
      body: new ReadableStream(),
      method: "POST",
      get duplex() {
        duplexAccessed = true;
        return "half";
      }
    }).headers.has("Content-Type");
    return duplexAccessed && !hasContentType;
  });
  const DEFAULT_CHUNK_SIZE = 64 * 1024;
  const supportsResponseStream = isReadableStreamSupported && test(() => utils$12.isReadableStream(new Response("").body));
  const resolvers = {
    stream: supportsResponseStream && ((res) => res.body)
  };
  isFetchSupported && ((res) => {
    ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
      !resolvers[type] && (resolvers[type] = utils$12.isFunction(res[type]) ? (res2) => res2[type]() : (_, config) => {
        throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);
      });
    });
  })(new Response());
  const getBodyLength = async (body) => {
    if (body == null) {
      return 0;
    }
    if (utils$12.isBlob(body)) {
      return body.size;
    }
    if (utils$12.isSpecCompliantForm(body)) {
      const _request = new Request(platform.origin, {
        method: "POST",
        body
      });
      return (await _request.arrayBuffer()).byteLength;
    }
    if (utils$12.isArrayBufferView(body) || utils$12.isArrayBuffer(body)) {
      return body.byteLength;
    }
    if (utils$12.isURLSearchParams(body)) {
      body = body + "";
    }
    if (utils$12.isString(body)) {
      return (await encodeText(body)).byteLength;
    }
  };
  const resolveBodyLength = async (headers, body) => {
    const length = utils$12.toFiniteNumber(headers.getContentLength());
    return length == null ? getBodyLength(body) : length;
  };
  var fetchAdapter = isFetchSupported && (async (config) => {
    let {
      url,
      method,
      data,
      signal,
      cancelToken,
      timeout,
      onDownloadProgress,
      onUploadProgress,
      responseType,
      headers,
      withCredentials = "same-origin",
      fetchOptions
    } = resolveConfig(config);
    responseType = responseType ? (responseType + "").toLowerCase() : "text";
    let composedSignal = composeSignals$1([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
    let request;
    const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
      composedSignal.unsubscribe();
    });
    let requestContentLength;
    try {
      if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
        let _request = new Request(url, {
          method: "POST",
          body: data,
          duplex: "half"
        });
        let contentTypeHeader;
        if (utils$12.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
          headers.setContentType(contentTypeHeader);
        }
        if (_request.body) {
          const [onProgress, flush] = progressEventDecorator(
            requestContentLength,
            progressEventReducer(asyncDecorator(onUploadProgress))
          );
          data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
        }
      }
      if (!utils$12.isString(withCredentials)) {
        withCredentials = withCredentials ? "include" : "omit";
      }
      const isCredentialsSupported = "credentials" in Request.prototype;
      request = new Request(url, {
        ...fetchOptions,
        signal: composedSignal,
        method: method.toUpperCase(),
        headers: headers.normalize().toJSON(),
        body: data,
        duplex: "half",
        credentials: isCredentialsSupported ? withCredentials : void 0
      });
      let response = await fetch(request, fetchOptions);
      const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
      if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
        const options = {};
        ["status", "statusText", "headers"].forEach((prop) => {
          options[prop] = response[prop];
        });
        const responseContentLength = utils$12.toFiniteNumber(response.headers.get("content-length"));
        const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
          responseContentLength,
          progressEventReducer(asyncDecorator(onDownloadProgress), true)
        ) || [];
        response = new Response(
          trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
            flush && flush();
            unsubscribe && unsubscribe();
          }),
          options
        );
      }
      responseType = responseType || "text";
      let responseData = await resolvers[utils$12.findKey(resolvers, responseType) || "text"](response, config);
      !isStreamResponse && unsubscribe && unsubscribe();
      return await new Promise((resolve, reject) => {
        settle(resolve, reject, {
          data: responseData,
          headers: AxiosHeaders$1.from(response.headers),
          status: response.status,
          statusText: response.statusText,
          config,
          request
        });
      });
    } catch (err) {
      unsubscribe && unsubscribe();
      if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
        throw Object.assign(
          new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request),
          {
            cause: err.cause || err
          }
        );
      }
      throw AxiosError.from(err, err && err.code, config, request);
    }
  });
  const knownAdapters = {
    http: httpAdapter,
    xhr: xhrAdapter,
    fetch: fetchAdapter
  };
  utils$12.forEach(knownAdapters, (fn, value) => {
    if (fn) {
      try {
        Object.defineProperty(fn, "name", { value });
      } catch (e) {
      }
      Object.defineProperty(fn, "adapterName", { value });
    }
  });
  const renderReason = (reason) => `- ${reason}`;
  const isResolvedHandle = (adapter) => utils$12.isFunction(adapter) || adapter === null || adapter === false;
  var adapters = {
    getAdapter: (adapters2) => {
      adapters2 = utils$12.isArray(adapters2) ? adapters2 : [adapters2];
      const { length } = adapters2;
      let nameOrAdapter;
      let adapter;
      const rejectedReasons = {};
      for (let i = 0; i < length; i++) {
        nameOrAdapter = adapters2[i];
        let id;
        adapter = nameOrAdapter;
        if (!isResolvedHandle(nameOrAdapter)) {
          adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
          if (adapter === void 0) {
            throw new AxiosError(`Unknown adapter '${id}'`);
          }
        }
        if (adapter) {
          break;
        }
        rejectedReasons[id || "#" + i] = adapter;
      }
      if (!adapter) {
        const reasons = Object.entries(rejectedReasons).map(
          ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
        );
        let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
        throw new AxiosError(
          `There is no suitable adapter to dispatch the request ` + s,
          "ERR_NOT_SUPPORT"
        );
      }
      return adapter;
    },
    adapters: knownAdapters
  };
  function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
      config.cancelToken.throwIfRequested();
    }
    if (config.signal && config.signal.aborted) {
      throw new CanceledError(null, config);
    }
  }
  function dispatchRequest(config) {
    throwIfCancellationRequested(config);
    config.headers = AxiosHeaders$1.from(config.headers);
    config.data = transformData.call(
      config,
      config.transformRequest
    );
    if (["post", "put", "patch"].indexOf(config.method) !== -1) {
      config.headers.setContentType("application/x-www-form-urlencoded", false);
    }
    const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);
    return adapter(config).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config);
      response.data = transformData.call(
        config,
        config.transformResponse,
        response
      );
      response.headers = AxiosHeaders$1.from(response.headers);
      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel(reason)) {
        throwIfCancellationRequested(config);
        if (reason && reason.response) {
          reason.response.data = transformData.call(
            config,
            config.transformResponse,
            reason.response
          );
          reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
        }
      }
      return Promise.reject(reason);
    });
  }
  const VERSION = "1.11.0";
  const validators$1 = {};
  ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
    validators$1[type] = function validator2(thing) {
      return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
    };
  });
  const deprecatedWarnings = {};
  validators$1.transitional = function transitional(validator2, version2, message) {
    function formatMessage(opt, desc) {
      return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
    }
    return (value, opt, opts) => {
      if (validator2 === false) {
        throw new AxiosError(
          formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
          AxiosError.ERR_DEPRECATED
        );
      }
      if (version2 && !deprecatedWarnings[opt]) {
        deprecatedWarnings[opt] = true;
        console.warn(
          formatMessage(
            opt,
            " has been deprecated since v" + version2 + " and will be removed in the near future"
          )
        );
      }
      return validator2 ? validator2(value, opt, opts) : true;
    };
  };
  validators$1.spelling = function spelling(correctSpelling) {
    return (value, opt) => {
      console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
      return true;
    };
  };
  function assertOptions(options, schema2, allowUnknown) {
    if (typeof options !== "object") {
      throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
    }
    const keys = Object.keys(options);
    let i = keys.length;
    while (i-- > 0) {
      const opt = keys[i];
      const validator2 = schema2[opt];
      if (validator2) {
        const value = options[opt];
        const result = value === void 0 || validator2(value, opt, options);
        if (result !== true) {
          throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
        }
        continue;
      }
      if (allowUnknown !== true) {
        throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
      }
    }
  }
  var validator = {
    assertOptions,
    validators: validators$1
  };
  const validators = validator.validators;
  class Axios {
    constructor(instanceConfig) {
      this.defaults = instanceConfig || {};
      this.interceptors = {
        request: new InterceptorManager$1(),
        response: new InterceptorManager$1()
      };
    }
    /**
     * Dispatch a request
     *
     * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
     * @param {?Object} config
     *
     * @returns {Promise} The Promise to be fulfilled
     */
    async request(configOrUrl, config) {
      try {
        return await this._request(configOrUrl, config);
      } catch (err) {
        if (err instanceof Error) {
          let dummy = {};
          Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
          const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
          try {
            if (!err.stack) {
              err.stack = stack;
            } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
              err.stack += "\n" + stack;
            }
          } catch (e) {
          }
        }
        throw err;
      }
    }
    _request(configOrUrl, config) {
      if (typeof configOrUrl === "string") {
        config = config || {};
        config.url = configOrUrl;
      } else {
        config = configOrUrl || {};
      }
      config = mergeConfig(this.defaults, config);
      const { transitional, paramsSerializer, headers } = config;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      if (paramsSerializer != null) {
        if (utils$12.isFunction(paramsSerializer)) {
          config.paramsSerializer = {
            serialize: paramsSerializer
          };
        } else {
          validator.assertOptions(paramsSerializer, {
            encode: validators.function,
            serialize: validators.function
          }, true);
        }
      }
      if (config.allowAbsoluteUrls !== void 0) ;
      else if (this.defaults.allowAbsoluteUrls !== void 0) {
        config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
      } else {
        config.allowAbsoluteUrls = true;
      }
      validator.assertOptions(config, {
        baseUrl: validators.spelling("baseURL"),
        withXsrfToken: validators.spelling("withXSRFToken")
      }, true);
      config.method = (config.method || this.defaults.method || "get").toLowerCase();
      let contextHeaders = headers && utils$12.merge(
        headers.common,
        headers[config.method]
      );
      headers && utils$12.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        (method) => {
          delete headers[method];
        }
      );
      config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
      const requestInterceptorChain = [];
      let synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      const responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      let promise;
      let i = 0;
      let len;
      if (!synchronousRequestInterceptors) {
        const chain = [dispatchRequest.bind(this), void 0];
        chain.unshift(...requestInterceptorChain);
        chain.push(...responseInterceptorChain);
        len = chain.length;
        promise = Promise.resolve(config);
        while (i < len) {
          promise = promise.then(chain[i++], chain[i++]);
        }
        return promise;
      }
      len = requestInterceptorChain.length;
      let newConfig = config;
      i = 0;
      while (i < len) {
        const onFulfilled = requestInterceptorChain[i++];
        const onRejected = requestInterceptorChain[i++];
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error2) {
          onRejected.call(this, error2);
          break;
        }
      }
      try {
        promise = dispatchRequest.call(this, newConfig);
      } catch (error2) {
        return Promise.reject(error2);
      }
      i = 0;
      len = responseInterceptorChain.length;
      while (i < len) {
        promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
      }
      return promise;
    }
    getUri(config) {
      config = mergeConfig(this.defaults, config);
      const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
      return buildURL(fullPath, config.params, config.paramsSerializer);
    }
  }
  utils$12.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
    Axios.prototype[method] = function(url, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        url,
        data: (config || {}).data
      }));
    };
  });
  utils$12.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
    function generateHTTPMethod(isForm) {
      return function httpMethod(url, data, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          headers: isForm ? {
            "Content-Type": "multipart/form-data"
          } : {},
          url,
          data
        }));
      };
    }
    Axios.prototype[method] = generateHTTPMethod();
    Axios.prototype[method + "Form"] = generateHTTPMethod(true);
  });
  var Axios$1 = Axios;
  class CancelToken {
    constructor(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      let resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      const token = this;
      this.promise.then((cancel) => {
        if (!token._listeners) return;
        let i = token._listeners.length;
        while (i-- > 0) {
          token._listeners[i](cancel);
        }
        token._listeners = null;
      });
      this.promise.then = (onfulfilled) => {
        let _resolve;
        const promise = new Promise((resolve) => {
          token.subscribe(resolve);
          _resolve = resolve;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message, config, request) {
        if (token.reason) {
          return;
        }
        token.reason = new CanceledError(message, config, request);
        resolvePromise(token.reason);
      });
    }
    /**
     * Throws a `CanceledError` if cancellation has been requested.
     */
    throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    }
    /**
     * Subscribe to the cancel signal
     */
    subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    }
    /**
     * Unsubscribe from the cancel signal
     */
    unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      const index = this._listeners.indexOf(listener);
      if (index !== -1) {
        this._listeners.splice(index, 1);
      }
    }
    toAbortSignal() {
      const controller = new AbortController();
      const abort = (err) => {
        controller.abort(err);
      };
      this.subscribe(abort);
      controller.signal.unsubscribe = () => this.unsubscribe(abort);
      return controller.signal;
    }
    /**
     * Returns an object that contains a new `CancelToken` and a function that, when called,
     * cancels the `CancelToken`.
     */
    static source() {
      let cancel;
      const token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel
      };
    }
  }
  var CancelToken$1 = CancelToken;
  function spread(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  }
  function isAxiosError(payload) {
    return utils$12.isObject(payload) && payload.isAxiosError === true;
  }
  const HttpStatusCode = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
  };
  Object.entries(HttpStatusCode).forEach(([key2, value]) => {
    HttpStatusCode[value] = key2;
  });
  var HttpStatusCode$1 = HttpStatusCode;
  function createInstance(defaultConfig) {
    const context = new Axios$1(defaultConfig);
    const instance = bind(Axios$1.prototype.request, context);
    utils$12.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
    utils$12.extend(instance, context, null, { allOwnKeys: true });
    instance.create = function create(instanceConfig) {
      return createInstance(mergeConfig(defaultConfig, instanceConfig));
    };
    return instance;
  }
  const axios = createInstance(defaults$1);
  axios.Axios = Axios$1;
  axios.CanceledError = CanceledError;
  axios.CancelToken = CancelToken$1;
  axios.isCancel = isCancel;
  axios.VERSION = VERSION;
  axios.toFormData = toFormData;
  axios.AxiosError = AxiosError;
  axios.Cancel = axios.CanceledError;
  axios.all = function all(promises) {
    return Promise.all(promises);
  };
  axios.spread = spread;
  axios.isAxiosError = isAxiosError;
  axios.mergeConfig = mergeConfig;
  axios.AxiosHeaders = AxiosHeaders$1;
  axios.formToJSON = (thing) => formDataToJSON(utils$12.isHTMLForm(thing) ? new FormData(thing) : thing);
  axios.getAdapter = adapters.getAdapter;
  axios.HttpStatusCode = HttpStatusCode$1;
  axios.default = axios;
  axios_1 = axios;
  return axios_1;
}
var hasRequiredTonAPI;
function requireTonAPI() {
  if (hasRequiredTonAPI) return TonAPI;
  hasRequiredTonAPI = 1;
  var __importDefault = TonAPI && TonAPI.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(TonAPI, "__esModule", { value: true });
  TonAPI.TonAPI = void 0;
  const core_1 = requireDist$5();
  const zod_1 = __importDefault(/* @__PURE__ */ requireZod());
  const axios_12 = __importDefault(/* @__PURE__ */ requireAxios());
  const Address2 = zod_1.default.string().transform((v2) => core_1.Address.parseRaw(v2));
  const HexBuffer = zod_1.default.string().transform((v2) => Buffer.from(v2, "hex"));
  const zBigint = zod_1.default.union([zod_1.default.number(), zod_1.default.string()]).transform((v2) => BigInt(v2));
  const zStrnum = zod_1.default.union([zod_1.default.number(), zod_1.default.string()]).transform((v2) => Number(v2));
  const ImagePreview = zod_1.default.object({
    resolution: zod_1.default.string(),
    url: zod_1.default.string()
  });
  const AccountAddress = zod_1.default.object({
    address: Address2,
    name: zod_1.default.optional(zod_1.default.string()),
    is_scam: zod_1.default.boolean(),
    icon: zod_1.default.optional(zod_1.default.string()),
    is_wallet: zod_1.default.boolean()
  });
  const NftCollection2 = zod_1.default.object({
    address: Address2,
    next_item_index: zBigint,
    owner: zod_1.default.optional(AccountAddress),
    metadata: zod_1.default.optional(zod_1.default.record(zod_1.default.any())),
    raw_collection_content: HexBuffer,
    previews: zod_1.default.optional(zod_1.default.array(ImagePreview)),
    approved_by: zod_1.default.array(zod_1.default.string())
  });
  const NftCollections = zod_1.default.object({
    nft_collections: zod_1.default.array(NftCollection2)
  });
  const Price = zod_1.default.object({
    value: zBigint,
    token_name: zod_1.default.string()
  });
  const Sale = zod_1.default.object({
    address: Address2,
    market: AccountAddress,
    owner: zod_1.default.optional(AccountAddress),
    price: Price
  });
  const NftItem2 = zod_1.default.object({
    address: Address2,
    index: zBigint,
    owner: zod_1.default.optional(AccountAddress),
    collection: zod_1.default.optional(zod_1.default.object({
      address: Address2,
      name: zod_1.default.string(),
      description: zod_1.default.string()
    })),
    verified: zod_1.default.boolean(),
    metadata: zod_1.default.record(zod_1.default.any()),
    sale: zod_1.default.optional(Sale),
    previews: zod_1.default.optional(zod_1.default.array(ImagePreview)),
    dns: zod_1.default.optional(zod_1.default.string()),
    approved_by: zod_1.default.array(zod_1.default.string())
  });
  const NftItems = zod_1.default.object({
    nft_items: zod_1.default.array(NftItem2)
  });
  const JettonVerificationType = zod_1.default.union([zod_1.default.literal("whitelist"), zod_1.default.literal("blacklist"), zod_1.default.literal("none")]);
  const JettonMetadata = zod_1.default.object({
    address: Address2,
    name: zod_1.default.string(),
    symbol: zod_1.default.string(),
    decimals: zStrnum,
    image: zod_1.default.optional(zod_1.default.string()),
    description: zod_1.default.optional(zod_1.default.string()),
    social: zod_1.default.optional(zod_1.default.array(zod_1.default.string())),
    websites: zod_1.default.optional(zod_1.default.array(zod_1.default.string())),
    catalogs: zod_1.default.optional(zod_1.default.array(zod_1.default.string()))
  });
  const JettonInfo = zod_1.default.object({
    mintable: zod_1.default.boolean(),
    total_supply: zBigint,
    metadata: JettonMetadata,
    verification: JettonVerificationType,
    holders_count: zod_1.default.number()
  });
  const Jettons = zod_1.default.object({
    jettons: zod_1.default.array(JettonInfo)
  });
  const JettonHolder = zod_1.default.object({
    address: Address2,
    owner: AccountAddress,
    balance: zBigint
  });
  const JettonHolders = zod_1.default.object({
    addresses: zod_1.default.array(JettonHolder)
  });
  const EncryptedComment = zod_1.default.object({
    encryption_type: zod_1.default.string(),
    cipher_text: HexBuffer
  });
  const Refund = zod_1.default.object({
    type: zod_1.default.string(),
    origin: Address2
  });
  const NftItemTransferAction = zod_1.default.object({
    sender: zod_1.default.optional(AccountAddress),
    recipient: zod_1.default.optional(AccountAddress),
    nft: Address2,
    comment: zod_1.default.optional(zod_1.default.string()),
    encrypted_comment: zod_1.default.optional(EncryptedComment),
    payload: zod_1.default.optional(HexBuffer),
    refund: zod_1.default.optional(Refund)
  });
  const ActionStatus = zod_1.default.union([zod_1.default.literal("ok"), zod_1.default.literal("failed")]);
  const ActionSpecificNftItemTransfer = zod_1.default.object({
    type: zod_1.default.literal("NftItemTransfer"),
    status: ActionStatus,
    NftItemTransfer: NftItemTransferAction
  }).transform((v2) => ({
    status: v2.status,
    ...v2.NftItemTransfer
  }));
  const AccountEventGeneric = (t) => zod_1.default.object({
    event_id: zod_1.default.string(),
    account: AccountAddress,
    timestamp: zod_1.default.number(),
    actions: zod_1.default.array(t),
    is_scam: zod_1.default.boolean(),
    lt: zBigint,
    in_progress: zod_1.default.boolean()
  });
  const AccountEventNftItemTransfer = AccountEventGeneric(ActionSpecificNftItemTransfer);
  const AccountEventsGeneric = (t) => zod_1.default.object({
    events: zod_1.default.array(t),
    next_from: zBigint
  });
  const AccountEventsNftItemTransfer = AccountEventsGeneric(AccountEventNftItemTransfer);
  const TokenRates = zod_1.default.object({
    prices: zod_1.default.optional(zod_1.default.record(zod_1.default.number())),
    diff_24h: zod_1.default.optional(zod_1.default.record(zod_1.default.string())),
    diff_7d: zod_1.default.optional(zod_1.default.record(zod_1.default.string())),
    diff_30d: zod_1.default.optional(zod_1.default.record(zod_1.default.string()))
  });
  const JettonPreview = zod_1.default.object({
    address: Address2,
    name: zod_1.default.string(),
    symbol: zod_1.default.string(),
    decimals: zStrnum,
    image: zod_1.default.string(),
    verification: JettonVerificationType
  });
  const JettonBalance = zod_1.default.object({
    balance: zBigint,
    price: zod_1.default.optional(TokenRates),
    wallet_address: AccountAddress,
    jetton: JettonPreview
  });
  const JettonBalances = zod_1.default.object({
    balances: zod_1.default.array(JettonBalance)
  });
  const rawAddress = (address) => {
    return typeof address === "string" ? address : address.toRawString();
  };
  let TonAPI$1 = class TonAPI {
    constructor(params) {
      this.instance = axios_12.default.create({
        baseURL: params?.baseURL ?? "https://tonapi.io",
        headers: params?.token === void 0 ? {} : {
          "Authorization": "Bearer " + params.token
        }
      });
    }
    async getNftCollections(params) {
      return NftCollections.parse((await this.instance.get("/v2/nfts/collections", {
        params
      })).data).nft_collections;
    }
    async getNftCollection(collection) {
      return NftCollection2.parse((await this.instance.get(`/v2/nfts/collections/${rawAddress(collection)}`)).data);
    }
    async getNftCollectionItems(collection, params) {
      return NftItems.parse((await this.instance.get(`/v2/nfts/collections/${rawAddress(collection)}/items`, {
        params
      })).data).nft_items;
    }
    async getNftItems(items) {
      return NftItems.parse((await this.instance.post(`/v2/nfts/_bulk`, {
        account_ids: items.map(rawAddress)
      })).data).nft_items;
    }
    async getNftItem(item) {
      return NftItem2.parse((await this.instance.get(`/v2/nfts/${rawAddress(item)}`)).data);
    }
    async getJettons(params) {
      return Jettons.parse((await this.instance.get("/v2/jettons", {
        params
      })).data).jettons;
    }
    async getJetton(jettonMaster) {
      return JettonInfo.parse((await this.instance.get(`/v2/jettons/${rawAddress(jettonMaster)}`)).data);
    }
    async getJettonHolders(jettonMaster, params) {
      return JettonHolders.parse((await this.instance.get(`/v2/jettons/${rawAddress(jettonMaster)}/holders`, {
        params
      })).data).addresses;
    }
    async getNftItemTransferHistory(item, params) {
      return AccountEventsNftItemTransfer.parse((await this.instance.get(`/v2/nfts/${rawAddress(item)}/history`, {
        params: {
          limit: 100,
          ...params
        }
      })).data);
    }
    async getAccountNfts(account, params) {
      return NftItems.parse((await this.instance.get(`/v2/accounts/${rawAddress(account)}/nfts`, {
        params: {
          ...params,
          collection: params?.collection === void 0 ? void 0 : rawAddress(params.collection)
        }
      })).data).nft_items;
    }
    async getAccountJettons(account, params) {
      return JettonBalances.parse((await this.instance.get(`/v2/accounts/${rawAddress(account)}/jettons`, {
        params: {
          currencies: params?.currencies === void 0 ? void 0 : params.currencies.join(",")
        }
      })).data).balances;
    }
  };
  TonAPI.TonAPI = TonAPI$1;
  return TonAPI;
}
var JettonExcessesMessage = {};
var hasRequiredJettonExcessesMessage;
function requireJettonExcessesMessage() {
  if (hasRequiredJettonExcessesMessage) return JettonExcessesMessage;
  hasRequiredJettonExcessesMessage = 1;
  Object.defineProperty(JettonExcessesMessage, "__esModule", { value: true });
  JettonExcessesMessage.loadJettonExcessesMessage = JettonExcessesMessage.storeJettonExcessesMessage = void 0;
  const opcodes_1 = requireOpcodes$1();
  function storeJettonExcessesMessage(src2) {
    return (builder2) => {
      builder2.storeUint(opcodes_1.JETTON_EXCESSES_OPCODE, 32);
      builder2.storeUint(src2.queryId, 64);
    };
  }
  JettonExcessesMessage.storeJettonExcessesMessage = storeJettonExcessesMessage;
  function loadJettonExcessesMessage(slice) {
    if (slice.loadUint(32) !== opcodes_1.JETTON_EXCESSES_OPCODE) {
      throw new Error("Wrong opcode");
    }
    let queryId = slice.loadUintBig(64);
    return {
      queryId
    };
  }
  JettonExcessesMessage.loadJettonExcessesMessage = loadJettonExcessesMessage;
  return JettonExcessesMessage;
}
var hasRequiredDist;
function requireDist() {
  if (hasRequiredDist) return dist$1;
  hasRequiredDist = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeNftGetStaticDataMessage = exports.loadNftGetStaticDataMessage = exports.storeNftExcessesMessage = exports.loadNftExcessesMessage = exports.storeNftDeployMessage = exports.loadNftDeployMessage = exports.loadNftCollectionMessage = exports.storeNftCollectionData = exports.loadNftCollectionData = exports.parseNftCollectionTransaction = exports.storeNftChangeContentMessage = exports.loadNftChangeContentMessage = exports.storeNftChangeAdminMessage = exports.loadNftChangeAdminMessage = exports.storeNftBatchMintMessage = exports.loadNftBatchMintMessage = exports.createNftMintItemValue = exports.storeNftBatchMintItem = exports.loadNftBatchMintItem = exports.NFT_MINT_OPCODE = exports.NFT_CHANGE_CONTENT_OPCODE = exports.NFT_CHANGE_ADMIN_OPCODE = exports.NFT_BATCH_MINT_OPCODE = exports.NFT_OWNER_ASSIGNED_OPCODE = exports.NFT_REPORT_STATIC_DATA_OPCODE = exports.NFT_GET_STATIC_DATA_OPCODE = exports.NFT_EXCESSES_OPCODE = exports.NFT_TRANSFER_OPCODE = exports.TonAPI = exports.NoSenderError = exports.parseTransferTransaction = exports.storeEncryptedMessage = exports.storeTextMessage = exports.storeSimpleTransferMessage = exports.loadEncryptedMessage = exports.loadTextMessage = exports.loadSimpleTransferMessage = exports.loadTransferMessage = exports.ENCRYPTED_MESSAGE_OPCODE = exports.TEXT_OPCODE = exports.HighloadWalletContractV2 = exports.createSender = exports.createHighloadV2 = exports.createWallet = exports.importKey = exports.createApi = exports.NoopStorage = exports.S3Storage = exports.PinataStorage = exports.AssetsSDK = void 0;
    exports.storeJettonChangeContentMessage = exports.loadJettonChangeContentMessage = exports.storeJettonChangeAdminMessage = exports.loadJettonChangeAdminMessage = exports.storeJettonBurnNotificationMessage = exports.loadJettonBurnNotificationMessage = exports.storeJettonBurnMessage = exports.loadJettonBurnMessage = exports.jettonContentToInternal = exports.parseJettonContent = exports.jettonWalletConfigToCell = exports.JettonWallet = exports.jettonMinterConfigToCell = exports.JettonMinter = exports.JETTON_TRANSFER_NOTIFICATION_OPCODE = exports.JETTON_EXCESSES_OPCODE = exports.JETTON_MINT_OPCODE = exports.JETTON_INTERNAL_TRANSFER_OPCODE = exports.JETTON_TRANSFER_OPCODE = exports.JETTON_CHANGE_CONTENT_OPCODE = exports.JETTON_CHANGE_ADMIN_OPCODE = exports.JETTON_BURN_OPCODE = exports.JETTON_BURN_NOTIFICATION_OPCODE = exports.NftSale = exports.nftItemConfigToCell = exports.NftItem = exports.sbtCollectionConfigToCell = exports.SbtCollection = exports.nftCollectionConfigToCell = exports.NftCollection = exports.createSbtItemParamsValue = exports.storeSbtItemParams = exports.loadSbtItemParams = exports.parseSbtItemTransaction = exports.parseSbtCollectionTransaction = exports.storeNftTransferMessage = exports.loadNftTransferMessage = exports.storeNftRoyaltyParams = exports.loadNftRoyaltyParams = exports.storeNftReportStaticDataMessage = exports.loadNftReportStaticDataMessage = exports.storeNftOwnerAssignedMessage = exports.loadNftOwnerAssignedMessage = exports.storeNftMintMessage = exports.loadNftMintMessage = exports.loadNftMessage = exports.createNftItemParamsValue = exports.storeNftItemParams = exports.loadNftItemParams = exports.parseNftItemTransaction = void 0;
    exports.loadJettonWalletMessage = exports.parseJettonWalletTransaction = exports.loadJettonMinterMessage = exports.parseJettonMinterTransaction = exports.storeJettonTransferNotificationMessage = exports.loadJettonTransferNotificationMessage = exports.storeJettonTransferMessage = exports.loadJettonTransferMessage = exports.storeJettonMintMessage = exports.loadJettonMintMessage = exports.storeJettonMinterContent = exports.loadJettonMinterContent = exports.storeJettonInternalTransferMessage = exports.loadJettonInternalTransferMessage = exports.storeJettonExcessesMessage = exports.loadJettonExcessesMessage = void 0;
    var sdk_1 = requireSdk();
    Object.defineProperty(exports, "AssetsSDK", { enumerable: true, get: function() {
      return sdk_1.AssetsSDK;
    } });
    var pinata_1 = requirePinata();
    Object.defineProperty(exports, "PinataStorage", { enumerable: true, get: function() {
      return pinata_1.PinataStorage;
    } });
    var s3_1 = requireS3();
    Object.defineProperty(exports, "S3Storage", { enumerable: true, get: function() {
      return s3_1.S3Storage;
    } });
    var noop_1 = requireNoop();
    Object.defineProperty(exports, "NoopStorage", { enumerable: true, get: function() {
      return noop_1.NoopStorage;
    } });
    var ton_client_api_1 = requireTonClientApi();
    Object.defineProperty(exports, "createApi", { enumerable: true, get: function() {
      return ton_client_api_1.createApi;
    } });
    var key_1 = requireKey();
    Object.defineProperty(exports, "importKey", { enumerable: true, get: function() {
      return key_1.importKey;
    } });
    var wallets_1 = requireWallets();
    Object.defineProperty(exports, "createWallet", { enumerable: true, get: function() {
      return wallets_1.createWallet;
    } });
    Object.defineProperty(exports, "createHighloadV2", { enumerable: true, get: function() {
      return wallets_1.createHighloadV2;
    } });
    Object.defineProperty(exports, "createSender", { enumerable: true, get: function() {
      return wallets_1.createSender;
    } });
    var HighloadWalletContractV2_1 = requireHighloadWalletContractV2();
    Object.defineProperty(exports, "HighloadWalletContractV2", { enumerable: true, get: function() {
      return HighloadWalletContractV2_1.HighloadWalletContractV2;
    } });
    var TransferMessage_1 = requireTransferMessage();
    Object.defineProperty(exports, "TEXT_OPCODE", { enumerable: true, get: function() {
      return TransferMessage_1.TEXT_OPCODE;
    } });
    Object.defineProperty(exports, "ENCRYPTED_MESSAGE_OPCODE", { enumerable: true, get: function() {
      return TransferMessage_1.ENCRYPTED_MESSAGE_OPCODE;
    } });
    Object.defineProperty(exports, "loadTransferMessage", { enumerable: true, get: function() {
      return TransferMessage_1.loadTransferMessage;
    } });
    Object.defineProperty(exports, "loadSimpleTransferMessage", { enumerable: true, get: function() {
      return TransferMessage_1.loadSimpleTransferMessage;
    } });
    Object.defineProperty(exports, "loadTextMessage", { enumerable: true, get: function() {
      return TransferMessage_1.loadTextMessage;
    } });
    Object.defineProperty(exports, "loadEncryptedMessage", { enumerable: true, get: function() {
      return TransferMessage_1.loadEncryptedMessage;
    } });
    Object.defineProperty(exports, "storeSimpleTransferMessage", { enumerable: true, get: function() {
      return TransferMessage_1.storeSimpleTransferMessage;
    } });
    Object.defineProperty(exports, "storeTextMessage", { enumerable: true, get: function() {
      return TransferMessage_1.storeTextMessage;
    } });
    Object.defineProperty(exports, "storeEncryptedMessage", { enumerable: true, get: function() {
      return TransferMessage_1.storeEncryptedMessage;
    } });
    var TransferAction_1 = requireTransferAction();
    Object.defineProperty(exports, "parseTransferTransaction", { enumerable: true, get: function() {
      return TransferAction_1.parseTransferTransaction;
    } });
    var error_1 = requireError();
    Object.defineProperty(exports, "NoSenderError", { enumerable: true, get: function() {
      return error_1.NoSenderError;
    } });
    var TonAPI_1 = requireTonAPI();
    Object.defineProperty(exports, "TonAPI", { enumerable: true, get: function() {
      return TonAPI_1.TonAPI;
    } });
    var opcodes_1 = requireOpcodes();
    Object.defineProperty(exports, "NFT_TRANSFER_OPCODE", { enumerable: true, get: function() {
      return opcodes_1.NFT_TRANSFER_OPCODE;
    } });
    Object.defineProperty(exports, "NFT_EXCESSES_OPCODE", { enumerable: true, get: function() {
      return opcodes_1.NFT_EXCESSES_OPCODE;
    } });
    Object.defineProperty(exports, "NFT_GET_STATIC_DATA_OPCODE", { enumerable: true, get: function() {
      return opcodes_1.NFT_GET_STATIC_DATA_OPCODE;
    } });
    Object.defineProperty(exports, "NFT_REPORT_STATIC_DATA_OPCODE", { enumerable: true, get: function() {
      return opcodes_1.NFT_REPORT_STATIC_DATA_OPCODE;
    } });
    Object.defineProperty(exports, "NFT_OWNER_ASSIGNED_OPCODE", { enumerable: true, get: function() {
      return opcodes_1.NFT_OWNER_ASSIGNED_OPCODE;
    } });
    Object.defineProperty(exports, "NFT_BATCH_MINT_OPCODE", { enumerable: true, get: function() {
      return opcodes_1.NFT_BATCH_MINT_OPCODE;
    } });
    Object.defineProperty(exports, "NFT_CHANGE_ADMIN_OPCODE", { enumerable: true, get: function() {
      return opcodes_1.NFT_CHANGE_ADMIN_OPCODE;
    } });
    Object.defineProperty(exports, "NFT_CHANGE_CONTENT_OPCODE", { enumerable: true, get: function() {
      return opcodes_1.NFT_CHANGE_CONTENT_OPCODE;
    } });
    Object.defineProperty(exports, "NFT_MINT_OPCODE", { enumerable: true, get: function() {
      return opcodes_1.NFT_MINT_OPCODE;
    } });
    var NftBatchMintMessage_1 = requireNftBatchMintMessage();
    Object.defineProperty(exports, "loadNftBatchMintItem", { enumerable: true, get: function() {
      return NftBatchMintMessage_1.loadNftBatchMintItem;
    } });
    var NftBatchMintMessage_2 = requireNftBatchMintMessage();
    Object.defineProperty(exports, "storeNftBatchMintItem", { enumerable: true, get: function() {
      return NftBatchMintMessage_2.storeNftBatchMintItem;
    } });
    var NftBatchMintMessage_3 = requireNftBatchMintMessage();
    Object.defineProperty(exports, "createNftMintItemValue", { enumerable: true, get: function() {
      return NftBatchMintMessage_3.createNftMintItemValue;
    } });
    var NftBatchMintMessage_4 = requireNftBatchMintMessage();
    Object.defineProperty(exports, "loadNftBatchMintMessage", { enumerable: true, get: function() {
      return NftBatchMintMessage_4.loadNftBatchMintMessage;
    } });
    var NftBatchMintMessage_5 = requireNftBatchMintMessage();
    Object.defineProperty(exports, "storeNftBatchMintMessage", { enumerable: true, get: function() {
      return NftBatchMintMessage_5.storeNftBatchMintMessage;
    } });
    var NftChangeAdminMessage_1 = requireNftChangeAdminMessage();
    Object.defineProperty(exports, "loadNftChangeAdminMessage", { enumerable: true, get: function() {
      return NftChangeAdminMessage_1.loadNftChangeAdminMessage;
    } });
    var NftChangeAdminMessage_2 = requireNftChangeAdminMessage();
    Object.defineProperty(exports, "storeNftChangeAdminMessage", { enumerable: true, get: function() {
      return NftChangeAdminMessage_2.storeNftChangeAdminMessage;
    } });
    var NftChangeContentMessage_1 = requireNftChangeContentMessage();
    Object.defineProperty(exports, "loadNftChangeContentMessage", { enumerable: true, get: function() {
      return NftChangeContentMessage_1.loadNftChangeContentMessage;
    } });
    var NftChangeContentMessage_2 = requireNftChangeContentMessage();
    Object.defineProperty(exports, "storeNftChangeContentMessage", { enumerable: true, get: function() {
      return NftChangeContentMessage_2.storeNftChangeContentMessage;
    } });
    var NftCollectionAction_1 = requireNftCollectionAction();
    Object.defineProperty(exports, "parseNftCollectionTransaction", { enumerable: true, get: function() {
      return NftCollectionAction_1.parseNftCollectionTransaction;
    } });
    var NftCollectionData_1 = requireNftCollectionData();
    Object.defineProperty(exports, "loadNftCollectionData", { enumerable: true, get: function() {
      return NftCollectionData_1.loadNftCollectionData;
    } });
    var NftCollectionData_2 = requireNftCollectionData();
    Object.defineProperty(exports, "storeNftCollectionData", { enumerable: true, get: function() {
      return NftCollectionData_2.storeNftCollectionData;
    } });
    var NftCollectionMessage_1 = requireNftCollectionMessage();
    Object.defineProperty(exports, "loadNftCollectionMessage", { enumerable: true, get: function() {
      return NftCollectionMessage_1.loadNftCollectionMessage;
    } });
    var NftDeployMessage_1 = requireNftDeployMessage();
    Object.defineProperty(exports, "loadNftDeployMessage", { enumerable: true, get: function() {
      return NftDeployMessage_1.loadNftDeployMessage;
    } });
    var NftDeployMessage_2 = requireNftDeployMessage();
    Object.defineProperty(exports, "storeNftDeployMessage", { enumerable: true, get: function() {
      return NftDeployMessage_2.storeNftDeployMessage;
    } });
    var NftExcessesMessage_1 = requireNftExcessesMessage();
    Object.defineProperty(exports, "loadNftExcessesMessage", { enumerable: true, get: function() {
      return NftExcessesMessage_1.loadNftExcessesMessage;
    } });
    var NftExcessesMessage_2 = requireNftExcessesMessage();
    Object.defineProperty(exports, "storeNftExcessesMessage", { enumerable: true, get: function() {
      return NftExcessesMessage_2.storeNftExcessesMessage;
    } });
    var NftGetStaticDataMessage_1 = requireNftGetStaticDataMessage();
    Object.defineProperty(exports, "loadNftGetStaticDataMessage", { enumerable: true, get: function() {
      return NftGetStaticDataMessage_1.loadNftGetStaticDataMessage;
    } });
    var NftGetStaticDataMessage_2 = requireNftGetStaticDataMessage();
    Object.defineProperty(exports, "storeNftGetStaticDataMessage", { enumerable: true, get: function() {
      return NftGetStaticDataMessage_2.storeNftGetStaticDataMessage;
    } });
    var NftItemAction_1 = requireNftItemAction();
    Object.defineProperty(exports, "parseNftItemTransaction", { enumerable: true, get: function() {
      return NftItemAction_1.parseNftItemTransaction;
    } });
    var NftItemParams_1 = requireNftItemParams();
    Object.defineProperty(exports, "loadNftItemParams", { enumerable: true, get: function() {
      return NftItemParams_1.loadNftItemParams;
    } });
    var NftItemParams_2 = requireNftItemParams();
    Object.defineProperty(exports, "storeNftItemParams", { enumerable: true, get: function() {
      return NftItemParams_2.storeNftItemParams;
    } });
    var NftItemParams_3 = requireNftItemParams();
    Object.defineProperty(exports, "createNftItemParamsValue", { enumerable: true, get: function() {
      return NftItemParams_3.createNftItemParamsValue;
    } });
    var NftMessage_1 = requireNftMessage();
    Object.defineProperty(exports, "loadNftMessage", { enumerable: true, get: function() {
      return NftMessage_1.loadNftMessage;
    } });
    var NftMintMessage_1 = requireNftMintMessage();
    Object.defineProperty(exports, "loadNftMintMessage", { enumerable: true, get: function() {
      return NftMintMessage_1.loadNftMintMessage;
    } });
    var NftMintMessage_2 = requireNftMintMessage();
    Object.defineProperty(exports, "storeNftMintMessage", { enumerable: true, get: function() {
      return NftMintMessage_2.storeNftMintMessage;
    } });
    var NftOwnerAssignedMessage_1 = requireNftOwnerAssignedMessage();
    Object.defineProperty(exports, "loadNftOwnerAssignedMessage", { enumerable: true, get: function() {
      return NftOwnerAssignedMessage_1.loadNftOwnerAssignedMessage;
    } });
    var NftOwnerAssignedMessage_2 = requireNftOwnerAssignedMessage();
    Object.defineProperty(exports, "storeNftOwnerAssignedMessage", { enumerable: true, get: function() {
      return NftOwnerAssignedMessage_2.storeNftOwnerAssignedMessage;
    } });
    var NftReportStaticDataMessage_1 = requireNftReportStaticDataMessage();
    Object.defineProperty(exports, "loadNftReportStaticDataMessage", { enumerable: true, get: function() {
      return NftReportStaticDataMessage_1.loadNftReportStaticDataMessage;
    } });
    var NftReportStaticDataMessage_2 = requireNftReportStaticDataMessage();
    Object.defineProperty(exports, "storeNftReportStaticDataMessage", { enumerable: true, get: function() {
      return NftReportStaticDataMessage_2.storeNftReportStaticDataMessage;
    } });
    var NftRoyaltyParams_1 = requireNftRoyaltyParams();
    Object.defineProperty(exports, "loadNftRoyaltyParams", { enumerable: true, get: function() {
      return NftRoyaltyParams_1.loadNftRoyaltyParams;
    } });
    var NftRoyaltyParams_2 = requireNftRoyaltyParams();
    Object.defineProperty(exports, "storeNftRoyaltyParams", { enumerable: true, get: function() {
      return NftRoyaltyParams_2.storeNftRoyaltyParams;
    } });
    var NftTransferMessage_1 = requireNftTransferMessage();
    Object.defineProperty(exports, "loadNftTransferMessage", { enumerable: true, get: function() {
      return NftTransferMessage_1.loadNftTransferMessage;
    } });
    var NftTransferMessage_2 = requireNftTransferMessage();
    Object.defineProperty(exports, "storeNftTransferMessage", { enumerable: true, get: function() {
      return NftTransferMessage_2.storeNftTransferMessage;
    } });
    var SbtCollectionAction_1 = requireSbtCollectionAction();
    Object.defineProperty(exports, "parseSbtCollectionTransaction", { enumerable: true, get: function() {
      return SbtCollectionAction_1.parseSbtCollectionTransaction;
    } });
    var SbtItemAction_1 = requireSbtItemAction();
    Object.defineProperty(exports, "parseSbtItemTransaction", { enumerable: true, get: function() {
      return SbtItemAction_1.parseSbtItemTransaction;
    } });
    var SbtItemParams_1 = requireSbtItemParams();
    Object.defineProperty(exports, "loadSbtItemParams", { enumerable: true, get: function() {
      return SbtItemParams_1.loadSbtItemParams;
    } });
    var SbtItemParams_2 = requireSbtItemParams();
    Object.defineProperty(exports, "storeSbtItemParams", { enumerable: true, get: function() {
      return SbtItemParams_2.storeSbtItemParams;
    } });
    var SbtItemParams_3 = requireSbtItemParams();
    Object.defineProperty(exports, "createSbtItemParamsValue", { enumerable: true, get: function() {
      return SbtItemParams_3.createSbtItemParamsValue;
    } });
    var NftCollection_1 = requireNftCollection();
    Object.defineProperty(exports, "NftCollection", { enumerable: true, get: function() {
      return NftCollection_1.NftCollection;
    } });
    Object.defineProperty(exports, "nftCollectionConfigToCell", { enumerable: true, get: function() {
      return NftCollection_1.nftCollectionConfigToCell;
    } });
    var SbtCollection_1 = requireSbtCollection();
    Object.defineProperty(exports, "SbtCollection", { enumerable: true, get: function() {
      return SbtCollection_1.SbtCollection;
    } });
    Object.defineProperty(exports, "sbtCollectionConfigToCell", { enumerable: true, get: function() {
      return SbtCollection_1.sbtCollectionConfigToCell;
    } });
    var NftItem_1 = requireNftItem();
    Object.defineProperty(exports, "NftItem", { enumerable: true, get: function() {
      return NftItem_1.NftItem;
    } });
    Object.defineProperty(exports, "nftItemConfigToCell", { enumerable: true, get: function() {
      return NftItem_1.nftItemConfigToCell;
    } });
    var NftSale_1 = requireNftSale();
    Object.defineProperty(exports, "NftSale", { enumerable: true, get: function() {
      return NftSale_1.NftSale;
    } });
    var opcodes_2 = requireOpcodes$1();
    Object.defineProperty(exports, "JETTON_BURN_NOTIFICATION_OPCODE", { enumerable: true, get: function() {
      return opcodes_2.JETTON_BURN_NOTIFICATION_OPCODE;
    } });
    Object.defineProperty(exports, "JETTON_BURN_OPCODE", { enumerable: true, get: function() {
      return opcodes_2.JETTON_BURN_OPCODE;
    } });
    Object.defineProperty(exports, "JETTON_CHANGE_ADMIN_OPCODE", { enumerable: true, get: function() {
      return opcodes_2.JETTON_CHANGE_ADMIN_OPCODE;
    } });
    Object.defineProperty(exports, "JETTON_CHANGE_CONTENT_OPCODE", { enumerable: true, get: function() {
      return opcodes_2.JETTON_CHANGE_CONTENT_OPCODE;
    } });
    Object.defineProperty(exports, "JETTON_TRANSFER_OPCODE", { enumerable: true, get: function() {
      return opcodes_2.JETTON_TRANSFER_OPCODE;
    } });
    Object.defineProperty(exports, "JETTON_INTERNAL_TRANSFER_OPCODE", { enumerable: true, get: function() {
      return opcodes_2.JETTON_INTERNAL_TRANSFER_OPCODE;
    } });
    Object.defineProperty(exports, "JETTON_MINT_OPCODE", { enumerable: true, get: function() {
      return opcodes_2.JETTON_MINT_OPCODE;
    } });
    Object.defineProperty(exports, "JETTON_EXCESSES_OPCODE", { enumerable: true, get: function() {
      return opcodes_2.JETTON_EXCESSES_OPCODE;
    } });
    Object.defineProperty(exports, "JETTON_TRANSFER_NOTIFICATION_OPCODE", { enumerable: true, get: function() {
      return opcodes_2.JETTON_TRANSFER_NOTIFICATION_OPCODE;
    } });
    var JettonMinter_1 = requireJettonMinter();
    Object.defineProperty(exports, "JettonMinter", { enumerable: true, get: function() {
      return JettonMinter_1.JettonMinter;
    } });
    Object.defineProperty(exports, "jettonMinterConfigToCell", { enumerable: true, get: function() {
      return JettonMinter_1.jettonMinterConfigToCell;
    } });
    var JettonWallet_1 = requireJettonWallet$1();
    Object.defineProperty(exports, "JettonWallet", { enumerable: true, get: function() {
      return JettonWallet_1.JettonWallet;
    } });
    Object.defineProperty(exports, "jettonWalletConfigToCell", { enumerable: true, get: function() {
      return JettonWallet_1.jettonWalletConfigToCell;
    } });
    var content_1 = requireContent$1();
    Object.defineProperty(exports, "parseJettonContent", { enumerable: true, get: function() {
      return content_1.parseJettonContent;
    } });
    Object.defineProperty(exports, "jettonContentToInternal", { enumerable: true, get: function() {
      return content_1.jettonContentToInternal;
    } });
    var JettonBurnMessage_1 = requireJettonBurnMessage();
    Object.defineProperty(exports, "loadJettonBurnMessage", { enumerable: true, get: function() {
      return JettonBurnMessage_1.loadJettonBurnMessage;
    } });
    var JettonBurnMessage_2 = requireJettonBurnMessage();
    Object.defineProperty(exports, "storeJettonBurnMessage", { enumerable: true, get: function() {
      return JettonBurnMessage_2.storeJettonBurnMessage;
    } });
    var JettonBurnNotificationMessage_1 = requireJettonBurnNotificationMessage();
    Object.defineProperty(exports, "loadJettonBurnNotificationMessage", { enumerable: true, get: function() {
      return JettonBurnNotificationMessage_1.loadJettonBurnNotificationMessage;
    } });
    var JettonBurnNotificationMessage_2 = requireJettonBurnNotificationMessage();
    Object.defineProperty(exports, "storeJettonBurnNotificationMessage", { enumerable: true, get: function() {
      return JettonBurnNotificationMessage_2.storeJettonBurnNotificationMessage;
    } });
    var JettonChangeAdminMessage_1 = requireJettonChangeAdminMessage();
    Object.defineProperty(exports, "loadJettonChangeAdminMessage", { enumerable: true, get: function() {
      return JettonChangeAdminMessage_1.loadJettonChangeAdminMessage;
    } });
    var JettonChangeAdminMessage_2 = requireJettonChangeAdminMessage();
    Object.defineProperty(exports, "storeJettonChangeAdminMessage", { enumerable: true, get: function() {
      return JettonChangeAdminMessage_2.storeJettonChangeAdminMessage;
    } });
    var JettonChangeContentMessage_1 = requireJettonChangeContentMessage();
    Object.defineProperty(exports, "loadJettonChangeContentMessage", { enumerable: true, get: function() {
      return JettonChangeContentMessage_1.loadJettonChangeContentMessage;
    } });
    var JettonChangeContentMessage_2 = requireJettonChangeContentMessage();
    Object.defineProperty(exports, "storeJettonChangeContentMessage", { enumerable: true, get: function() {
      return JettonChangeContentMessage_2.storeJettonChangeContentMessage;
    } });
    var JettonExcessesMessage_1 = requireJettonExcessesMessage();
    Object.defineProperty(exports, "loadJettonExcessesMessage", { enumerable: true, get: function() {
      return JettonExcessesMessage_1.loadJettonExcessesMessage;
    } });
    var JettonExcessesMessage_2 = requireJettonExcessesMessage();
    Object.defineProperty(exports, "storeJettonExcessesMessage", { enumerable: true, get: function() {
      return JettonExcessesMessage_2.storeJettonExcessesMessage;
    } });
    var JettonInternalTransferMessage_1 = requireJettonInternalTransferMessage();
    Object.defineProperty(exports, "loadJettonInternalTransferMessage", { enumerable: true, get: function() {
      return JettonInternalTransferMessage_1.loadJettonInternalTransferMessage;
    } });
    var JettonInternalTransferMessage_2 = requireJettonInternalTransferMessage();
    Object.defineProperty(exports, "storeJettonInternalTransferMessage", { enumerable: true, get: function() {
      return JettonInternalTransferMessage_2.storeJettonInternalTransferMessage;
    } });
    var JettonMinterContent_1 = requireJettonMinterContent();
    Object.defineProperty(exports, "loadJettonMinterContent", { enumerable: true, get: function() {
      return JettonMinterContent_1.loadJettonMinterContent;
    } });
    var JettonMinterContent_2 = requireJettonMinterContent();
    Object.defineProperty(exports, "storeJettonMinterContent", { enumerable: true, get: function() {
      return JettonMinterContent_2.storeJettonMinterContent;
    } });
    var JettonMintMessage_1 = requireJettonMintMessage();
    Object.defineProperty(exports, "loadJettonMintMessage", { enumerable: true, get: function() {
      return JettonMintMessage_1.loadJettonMintMessage;
    } });
    var JettonMintMessage_2 = requireJettonMintMessage();
    Object.defineProperty(exports, "storeJettonMintMessage", { enumerable: true, get: function() {
      return JettonMintMessage_2.storeJettonMintMessage;
    } });
    var JettonTransferMessage_1 = requireJettonTransferMessage();
    Object.defineProperty(exports, "loadJettonTransferMessage", { enumerable: true, get: function() {
      return JettonTransferMessage_1.loadJettonTransferMessage;
    } });
    var JettonTransferMessage_2 = requireJettonTransferMessage();
    Object.defineProperty(exports, "storeJettonTransferMessage", { enumerable: true, get: function() {
      return JettonTransferMessage_2.storeJettonTransferMessage;
    } });
    var JettonTransferNotificationMessage_1 = requireJettonTransferNotificationMessage();
    Object.defineProperty(exports, "loadJettonTransferNotificationMessage", { enumerable: true, get: function() {
      return JettonTransferNotificationMessage_1.loadJettonTransferNotificationMessage;
    } });
    var JettonTransferNotificationMessage_2 = requireJettonTransferNotificationMessage();
    Object.defineProperty(exports, "storeJettonTransferNotificationMessage", { enumerable: true, get: function() {
      return JettonTransferNotificationMessage_2.storeJettonTransferNotificationMessage;
    } });
    var JettonMinterAction_1 = requireJettonMinterAction();
    Object.defineProperty(exports, "parseJettonMinterTransaction", { enumerable: true, get: function() {
      return JettonMinterAction_1.parseJettonMinterTransaction;
    } });
    var JettonMinterMessage_1 = requireJettonMinterMessage();
    Object.defineProperty(exports, "loadJettonMinterMessage", { enumerable: true, get: function() {
      return JettonMinterMessage_1.loadJettonMinterMessage;
    } });
    var JettonWalletAction_1 = requireJettonWalletAction();
    Object.defineProperty(exports, "parseJettonWalletTransaction", { enumerable: true, get: function() {
      return JettonWalletAction_1.parseJettonWalletTransaction;
    } });
    var JettonWalletMessage_1 = requireJettonWalletMessage();
    Object.defineProperty(exports, "loadJettonWalletMessage", { enumerable: true, get: function() {
      return JettonWalletMessage_1.loadJettonWalletMessage;
    } });
  })(dist$1);
  return dist$1;
}
requireDist();
globalLogger.createChild("Initializer");
globalLogger.createChild("JettonsManager");
globalLogger.createChild("EventEmitter");
var ContentType;
(function(ContentType2) {
  ContentType2["Json"] = "application/json";
  ContentType2["JsonApi"] = "application/vnd.api+json";
  ContentType2["FormData"] = "multipart/form-data";
  ContentType2["UrlEncoded"] = "application/x-www-form-urlencoded";
  ContentType2["Text"] = "text/plain";
})(ContentType || (ContentType = {}));
globalLogger.createChild("AnalyticsApi");
var DnsCategory;
(function(DnsCategory2) {
  DnsCategory2["DnsNextResolver"] = "dns_next_resolver";
  DnsCategory2["Wallet"] = "wallet";
  DnsCategory2["Site"] = "site";
  DnsCategory2["BagId"] = "storage";
  DnsCategory2[DnsCategory2["All"] = 0] = "All";
})(DnsCategory || (DnsCategory = {}));
var DnsRecord;
(function(DnsRecord2) {
  DnsRecord2[DnsRecord2["SmcAddress"] = 40915] = "SmcAddress";
  DnsRecord2[DnsRecord2["NextResolver"] = 47763] = "NextResolver";
  DnsRecord2[DnsRecord2["AdnlAddress"] = 44289] = "AdnlAddress";
  DnsRecord2[DnsRecord2["StorageAddress"] = 29811] = "StorageAddress";
})(DnsRecord || (DnsRecord = {}));
globalLogger.createChild("ApiClientToncenter");
globalLogger.createChild("TonWalletKit");
const WalletV5R1CodeBoc = "b5ee9c7201021401000281000114ff00f4a413f4bcf2c80b01020120020302014804050102f20e02dcd020d749c120915b8f6320d70b1f2082106578746ebd21821073696e74bdb0925f03e082106578746eba8eb48020d72101d074d721fa4030fa44f828fa443058bd915be0ed44d0810141d721f4058307f40e6fa1319130e18040d721707fdb3ce03120d749810280b99130e070e2100f020120060702012008090019be5f0f6a2684080a0eb90fa02c02016e0a0b0201480c0d0019adce76a2684020eb90eb85ffc00019af1df6a2684010eb90eb858fc00017b325fb51341c75c875c2c7e00011b262fb513435c28020011e20d70b1f82107369676ebaf2e08a7f0f01e68ef0eda2edfb218308d722028308d723208020d721d31fd31fd31fed44d0d200d31f20d31fd3ffd70a000af90140ccf9109a28945f0adb31e1f2c087df02b35007b0f2d0845125baf2e0855036baf2e086f823bbf2d0882292f800de01a47fc8ca00cb1f01cf16c9ed542092f80fde70db3cd81003f6eda2edfb02f404216e926c218e4c0221d73930709421c700b38e2d01d72820761e436c20d749c008f2e09320d74ac002f2e09320d71d06c712c2005230b0f2d089d74cd7393001a4e86c128407bbf2e093d74ac000f2e093ed55e2d20001c000915be0ebd72c08142091709601d72c081c12e25210b1e30f20d74a111213009601fa4001fa44f828fa443058baf2e091ed44d0810141d718f405049d7fc8ca0040048307f453f2e08b8e14038307f45bf2e08c22d70a00216e01b3b0f2d090e2c85003cf1612f400c9ed54007230d72c08248e2d21f2e092d200ed44d0d2005113baf2d08f54503091319c01810140d721d70a00f2e08ee2c8ca0058cf16c9ed5493f2c08de20010935bdb31e1d74cd0";
distExports$1.Cell.fromBoc(Buffer.from(WalletV5R1CodeBoc, "hex"))[0];
distExports.keyPairFromSeed(Buffer.alloc(32, 0));
globalLogger.createChild("WalletV5R1Adapter");
distExports$1.Cell.fromBoc(Buffer.from("te6ccgECFAEAAtQAART/APSkE/S88sgLAQIBIAIDAgFIBAUE+PKDCNcYINMf0x/THwL4I7vyZO1E0NMf0x/T//QE0VFDuvKhUVG68qIF+QFUEGT5EPKj+AAkpMjLH1JAyx9SMMv/UhD0AMntVPgPAdMHIcAAn2xRkyDXSpbTB9QC+wDoMOAhwAHjACHAAuMAAcADkTDjDQOkyMsfEssfy/8QERITAubQAdDTAyFxsJJfBOAi10nBIJJfBOAC0x8hghBwbHVnvSKCEGRzdHK9sJJfBeAD+kAwIPpEAcjKB8v/ydDtRNCBAUDXIfQEMFyBAQj0Cm+hMbOSXwfgBdM/yCWCEHBsdWe6kjgw4w0DghBkc3RyupJfBuMNBgcCASAICQB4AfoA9AQw+CdvIjBQCqEhvvLgUIIQcGx1Z4MesXCAGFAEywUmzxZY+gIZ9ADLaRfLH1Jgyz8gyYBA+wAGAIpQBIEBCPRZMO1E0IEBQNcgyAHPFvQAye1UAXKwjiOCEGRzdHKDHrFwgBhQBcsFUAPPFiP6AhPLassfyz/JgED7AJJfA+ICASAKCwBZvSQrb2omhAgKBrkPoCGEcNQICEekk30pkQzmkD6f+YN4EoAbeBAUiYcVnzGEAgFYDA0AEbjJftRNDXCx+AA9sp37UTQgQFA1yH0BDACyMoHy//J0AGBAQj0Cm+hMYAIBIA4PABmtznaiaEAga5Drhf/AABmvHfaiaEAQa5DrhY/AAG7SB/oA1NQi+QAFyMoHFcv/ydB3dIAYyMsFywIizxZQBfoCFMtrEszMyXP7AMhAFIEBCPRR8qcCAHCBAQjXGPoA0z/IVCBHgQEI9FHyp4IQbm90ZXB0gBjIywXLAlAGzxZQBPoCFMtqEssfyz/Jc/sAAgBsgQEI1xj6ANM/MFIkgQEI9Fnyp4IQZHN0cnB0gBjIywXLAlAFzxZQA/oCE8tqyx8Syz/Jc/sAAAr0AMntVA==", "base64"))[0];
globalLogger.createChild("WalletV4R2Adapter");
var src = {};
var sha256 = {};
var sha2 = {};
var _md = {};
var utils = {};
var crypto$1 = {};
var hasRequiredCrypto;
function requireCrypto() {
  if (hasRequiredCrypto) return crypto$1;
  hasRequiredCrypto = 1;
  Object.defineProperty(crypto$1, "__esModule", { value: true });
  crypto$1.crypto = void 0;
  crypto$1.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  return crypto$1;
}
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.Hash = exports.nextTick = exports.swap32IfBE = exports.byteSwapIfBE = exports.swap8IfBE = exports.isLE = void 0;
    exports.isBytes = isBytes;
    exports.anumber = anumber;
    exports.abytes = abytes;
    exports.ahash = ahash;
    exports.aexists = aexists;
    exports.aoutput = aoutput;
    exports.u8 = u8;
    exports.u32 = u32;
    exports.clean = clean;
    exports.createView = createView;
    exports.rotr = rotr;
    exports.rotl = rotl;
    exports.byteSwap = byteSwap;
    exports.byteSwap32 = byteSwap32;
    exports.bytesToHex = bytesToHex;
    exports.hexToBytes = hexToBytes;
    exports.asyncLoop = asyncLoop;
    exports.utf8ToBytes = utf8ToBytes;
    exports.bytesToUtf8 = bytesToUtf8;
    exports.toBytes = toBytes;
    exports.kdfInputToBytes = kdfInputToBytes;
    exports.concatBytes = concatBytes;
    exports.checkOpts = checkOpts;
    exports.createHasher = createHasher;
    exports.createOptHasher = createOptHasher;
    exports.createXOFer = createXOFer;
    exports.randomBytes = randomBytes;
    const crypto_1 = /* @__PURE__ */ requireCrypto();
    function isBytes(a) {
      return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
    }
    function anumber(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error("positive integer expected, got " + n);
    }
    function abytes(b, ...lengths) {
      if (!isBytes(b))
        throw new Error("Uint8Array expected");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
    }
    function ahash(h) {
      if (typeof h !== "function" || typeof h.create !== "function")
        throw new Error("Hash should be wrapped by utils.createHasher");
      anumber(h.outputLen);
      anumber(h.blockLen);
    }
    function aexists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    function aoutput(out, instance) {
      abytes(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error("digestInto() expects output buffer of length at least " + min);
      }
    }
    function u8(arr) {
      return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    function u32(arr) {
      return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    }
    function clean(...arrays) {
      for (let i = 0; i < arrays.length; i++) {
        arrays[i].fill(0);
      }
    }
    function createView(arr) {
      return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    function rotr(word, shift) {
      return word << 32 - shift | word >>> shift;
    }
    function rotl(word, shift) {
      return word << shift | word >>> 32 - shift >>> 0;
    }
    exports.isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
    function byteSwap(word) {
      return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
    }
    exports.swap8IfBE = exports.isLE ? (n) => n : (n) => byteSwap(n);
    exports.byteSwapIfBE = exports.swap8IfBE;
    function byteSwap32(arr) {
      for (let i = 0; i < arr.length; i++) {
        arr[i] = byteSwap(arr[i]);
      }
      return arr;
    }
    exports.swap32IfBE = exports.isLE ? (u) => u : byteSwap32;
    const hasHexBuiltin = /* @__PURE__ */ (() => (
      // @ts-ignore
      typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
    ))();
    const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      abytes(bytes);
      if (hasHexBuiltin)
        return bytes.toHex();
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    const asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    function asciiToBase16(ch) {
      if (ch >= asciis._0 && ch <= asciis._9)
        return ch - asciis._0;
      if (ch >= asciis.A && ch <= asciis.F)
        return ch - (asciis.A - 10);
      if (ch >= asciis.a && ch <= asciis.f)
        return ch - (asciis.a - 10);
      return;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      if (hasHexBuiltin)
        return Uint8Array.fromHex(hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("hex string expected, got unpadded hex of length " + hl);
      const array = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n2 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
      }
      return array;
    }
    const nextTick = async () => {
    };
    exports.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i = 0; i < iters; i++) {
        cb(i);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports.nextTick)();
        ts += diff;
      }
    }
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error("string expected");
      return new Uint8Array(new TextEncoder().encode(str));
    }
    function bytesToUtf8(bytes) {
      return new TextDecoder().decode(bytes);
    }
    function toBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      abytes(data);
      return data;
    }
    function kdfInputToBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      abytes(data);
      return data;
    }
    function concatBytes(...arrays) {
      let sum = 0;
      for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        abytes(a);
        sum += a.length;
      }
      const res = new Uint8Array(sum);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
      }
      return res;
    }
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && {}.toString.call(opts) !== "[object Object]")
        throw new Error("options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    class Hash {
    }
    exports.Hash = Hash;
    function createHasher(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    function createOptHasher(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    function createXOFer(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapConstructor = createHasher;
    exports.wrapConstructorWithOpts = createOptHasher;
    exports.wrapXOFConstructorWithOpts = createXOFer;
    function randomBytes(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === "function") {
        return Uint8Array.from(crypto_1.crypto.randomBytes(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
  })(utils);
  return utils;
}
var hasRequired_md;
function require_md() {
  if (hasRequired_md) return _md;
  hasRequired_md = 1;
  Object.defineProperty(_md, "__esModule", { value: true });
  _md.SHA512_IV = _md.SHA384_IV = _md.SHA224_IV = _md.SHA256_IV = _md.HashMD = void 0;
  _md.setBigUint64 = setBigUint64;
  _md.Chi = Chi;
  _md.Maj = Maj;
  const utils_ts_1 = /* @__PURE__ */ requireUtils();
  function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === "function")
      return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh = Number(value >> _32n & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
  }
  function Chi(a, b, c) {
    return a & b ^ ~a & c;
  }
  function Maj(a, b, c) {
    return a & b ^ a & c ^ b & c;
  }
  class HashMD extends utils_ts_1.Hash {
    constructor(blockLen, outputLen, padOffset, isLE) {
      super();
      this.finished = false;
      this.length = 0;
      this.pos = 0;
      this.destroyed = false;
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.padOffset = padOffset;
      this.isLE = isLE;
      this.buffer = new Uint8Array(blockLen);
      this.view = (0, utils_ts_1.createView)(this.buffer);
    }
    update(data) {
      (0, utils_ts_1.aexists)(this);
      data = (0, utils_ts_1.toBytes)(data);
      (0, utils_ts_1.abytes)(data);
      const { view, buffer, blockLen } = this;
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        if (take === blockLen) {
          const dataView = (0, utils_ts_1.createView)(data);
          for (; blockLen <= len - pos; pos += blockLen)
            this.process(dataView, pos);
          continue;
        }
        buffer.set(data.subarray(pos, pos + take), this.pos);
        this.pos += take;
        pos += take;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data.length;
      this.roundClean();
      return this;
    }
    digestInto(out) {
      (0, utils_ts_1.aexists)(this);
      (0, utils_ts_1.aoutput)(out, this);
      this.finished = true;
      const { buffer, view, blockLen, isLE } = this;
      let { pos } = this;
      buffer[pos++] = 128;
      (0, utils_ts_1.clean)(this.buffer.subarray(pos));
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (let i = pos; i < blockLen; i++)
        buffer[i] = 0;
      setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
      this.process(view, 0);
      const oview = (0, utils_ts_1.createView)(out);
      const len = this.outputLen;
      if (len % 4)
        throw new Error("_sha2: outputLen should be aligned to 32bit");
      const outLen = len / 4;
      const state = this.get();
      if (outLen > state.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let i = 0; i < outLen; i++)
        oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to) {
      to || (to = new this.constructor());
      to.set(...this.get());
      const { blockLen, buffer, length, finished, destroyed, pos } = this;
      to.destroyed = destroyed;
      to.finished = finished;
      to.length = length;
      to.pos = pos;
      if (length % blockLen)
        to.buffer.set(buffer);
      return to;
    }
    clone() {
      return this._cloneInto();
    }
  }
  _md.HashMD = HashMD;
  _md.SHA256_IV = Uint32Array.from([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  _md.SHA224_IV = Uint32Array.from([
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ]);
  _md.SHA384_IV = Uint32Array.from([
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ]);
  _md.SHA512_IV = Uint32Array.from([
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ]);
  return _md;
}
var _u64 = {};
var hasRequired_u64;
function require_u64() {
  if (hasRequired_u64) return _u64;
  hasRequired_u64 = 1;
  Object.defineProperty(_u64, "__esModule", { value: true });
  _u64.toBig = _u64.shrSL = _u64.shrSH = _u64.rotrSL = _u64.rotrSH = _u64.rotrBL = _u64.rotrBH = _u64.rotr32L = _u64.rotr32H = _u64.rotlSL = _u64.rotlSH = _u64.rotlBL = _u64.rotlBH = _u64.add5L = _u64.add5H = _u64.add4L = _u64.add4H = _u64.add3L = _u64.add3H = void 0;
  _u64.add = add;
  _u64.fromBig = fromBig;
  _u64.split = split;
  const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
  const _32n = /* @__PURE__ */ BigInt(32);
  function fromBig(n, le = false) {
    if (le)
      return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
    return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
  }
  function split(lst, le = false) {
    const len = lst.length;
    let Ah = new Uint32Array(len);
    let Al = new Uint32Array(len);
    for (let i = 0; i < len; i++) {
      const { h, l } = fromBig(lst[i], le);
      [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
  }
  const toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
  _u64.toBig = toBig;
  const shrSH = (h, _l, s) => h >>> s;
  _u64.shrSH = shrSH;
  const shrSL = (h, l, s) => h << 32 - s | l >>> s;
  _u64.shrSL = shrSL;
  const rotrSH = (h, l, s) => h >>> s | l << 32 - s;
  _u64.rotrSH = rotrSH;
  const rotrSL = (h, l, s) => h << 32 - s | l >>> s;
  _u64.rotrSL = rotrSL;
  const rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
  _u64.rotrBH = rotrBH;
  const rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
  _u64.rotrBL = rotrBL;
  const rotr32H = (_h, l) => l;
  _u64.rotr32H = rotr32H;
  const rotr32L = (h, _l) => h;
  _u64.rotr32L = rotr32L;
  const rotlSH = (h, l, s) => h << s | l >>> 32 - s;
  _u64.rotlSH = rotlSH;
  const rotlSL = (h, l, s) => l << s | h >>> 32 - s;
  _u64.rotlSL = rotlSL;
  const rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
  _u64.rotlBH = rotlBH;
  const rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
  _u64.rotlBL = rotlBL;
  function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
  }
  const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
  _u64.add3L = add3L;
  const add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
  _u64.add3H = add3H;
  const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
  _u64.add4L = add4L;
  const add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
  _u64.add4H = add4H;
  const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
  _u64.add5L = add5L;
  const add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
  _u64.add5H = add5H;
  const u64 = {
    fromBig,
    split,
    toBig,
    shrSH,
    shrSL,
    rotrSH,
    rotrSL,
    rotrBH,
    rotrBL,
    rotr32H,
    rotr32L,
    rotlSH,
    rotlSL,
    rotlBH,
    rotlBL,
    add,
    add3L,
    add3H,
    add4L,
    add4H,
    add5H,
    add5L
  };
  _u64.default = u64;
  return _u64;
}
var hasRequiredSha2;
function requireSha2() {
  if (hasRequiredSha2) return sha2;
  hasRequiredSha2 = 1;
  Object.defineProperty(sha2, "__esModule", { value: true });
  sha2.sha512_224 = sha2.sha512_256 = sha2.sha384 = sha2.sha512 = sha2.sha224 = sha2.sha256 = sha2.SHA512_256 = sha2.SHA512_224 = sha2.SHA384 = sha2.SHA512 = sha2.SHA224 = sha2.SHA256 = void 0;
  const _md_ts_1 = /* @__PURE__ */ require_md();
  const u64 = /* @__PURE__ */ require_u64();
  const utils_ts_1 = /* @__PURE__ */ requireUtils();
  const SHA256_K = /* @__PURE__ */ Uint32Array.from([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
  class SHA256 extends _md_ts_1.HashMD {
    constructor(outputLen = 32) {
      super(64, outputLen, 8, false);
      this.A = _md_ts_1.SHA256_IV[0] | 0;
      this.B = _md_ts_1.SHA256_IV[1] | 0;
      this.C = _md_ts_1.SHA256_IV[2] | 0;
      this.D = _md_ts_1.SHA256_IV[3] | 0;
      this.E = _md_ts_1.SHA256_IV[4] | 0;
      this.F = _md_ts_1.SHA256_IV[5] | 0;
      this.G = _md_ts_1.SHA256_IV[6] | 0;
      this.H = _md_ts_1.SHA256_IV[7] | 0;
    }
    get() {
      const { A: A2, B: B2, C, D, E, F, G, H } = this;
      return [A2, B2, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A2, B2, C, D, E, F, G, H) {
      this.A = A2 | 0;
      this.B = B2 | 0;
      this.C = C | 0;
      this.D = D | 0;
      this.E = E | 0;
      this.F = F | 0;
      this.G = G | 0;
      this.H = H | 0;
    }
    process(view, offset) {
      for (let i = 0; i < 16; i++, offset += 4)
        SHA256_W[i] = view.getUint32(offset, false);
      for (let i = 16; i < 64; i++) {
        const W15 = SHA256_W[i - 15];
        const W2 = SHA256_W[i - 2];
        const s0 = (0, utils_ts_1.rotr)(W15, 7) ^ (0, utils_ts_1.rotr)(W15, 18) ^ W15 >>> 3;
        const s1 = (0, utils_ts_1.rotr)(W2, 17) ^ (0, utils_ts_1.rotr)(W2, 19) ^ W2 >>> 10;
        SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
      }
      let { A: A2, B: B2, C, D, E, F, G, H } = this;
      for (let i = 0; i < 64; i++) {
        const sigma1 = (0, utils_ts_1.rotr)(E, 6) ^ (0, utils_ts_1.rotr)(E, 11) ^ (0, utils_ts_1.rotr)(E, 25);
        const T1 = H + sigma1 + (0, _md_ts_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
        const sigma0 = (0, utils_ts_1.rotr)(A2, 2) ^ (0, utils_ts_1.rotr)(A2, 13) ^ (0, utils_ts_1.rotr)(A2, 22);
        const T2 = sigma0 + (0, _md_ts_1.Maj)(A2, B2, C) | 0;
        H = G;
        G = F;
        F = E;
        E = D + T1 | 0;
        D = C;
        C = B2;
        B2 = A2;
        A2 = T1 + T2 | 0;
      }
      A2 = A2 + this.A | 0;
      B2 = B2 + this.B | 0;
      C = C + this.C | 0;
      D = D + this.D | 0;
      E = E + this.E | 0;
      F = F + this.F | 0;
      G = G + this.G | 0;
      H = H + this.H | 0;
      this.set(A2, B2, C, D, E, F, G, H);
    }
    roundClean() {
      (0, utils_ts_1.clean)(SHA256_W);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
      (0, utils_ts_1.clean)(this.buffer);
    }
  }
  sha2.SHA256 = SHA256;
  class SHA224 extends SHA256 {
    constructor() {
      super(28);
      this.A = _md_ts_1.SHA224_IV[0] | 0;
      this.B = _md_ts_1.SHA224_IV[1] | 0;
      this.C = _md_ts_1.SHA224_IV[2] | 0;
      this.D = _md_ts_1.SHA224_IV[3] | 0;
      this.E = _md_ts_1.SHA224_IV[4] | 0;
      this.F = _md_ts_1.SHA224_IV[5] | 0;
      this.G = _md_ts_1.SHA224_IV[6] | 0;
      this.H = _md_ts_1.SHA224_IV[7] | 0;
    }
  }
  sha2.SHA224 = SHA224;
  const K512 = /* @__PURE__ */ (() => u64.split([
    "0x428a2f98d728ae22",
    "0x7137449123ef65cd",
    "0xb5c0fbcfec4d3b2f",
    "0xe9b5dba58189dbbc",
    "0x3956c25bf348b538",
    "0x59f111f1b605d019",
    "0x923f82a4af194f9b",
    "0xab1c5ed5da6d8118",
    "0xd807aa98a3030242",
    "0x12835b0145706fbe",
    "0x243185be4ee4b28c",
    "0x550c7dc3d5ffb4e2",
    "0x72be5d74f27b896f",
    "0x80deb1fe3b1696b1",
    "0x9bdc06a725c71235",
    "0xc19bf174cf692694",
    "0xe49b69c19ef14ad2",
    "0xefbe4786384f25e3",
    "0x0fc19dc68b8cd5b5",
    "0x240ca1cc77ac9c65",
    "0x2de92c6f592b0275",
    "0x4a7484aa6ea6e483",
    "0x5cb0a9dcbd41fbd4",
    "0x76f988da831153b5",
    "0x983e5152ee66dfab",
    "0xa831c66d2db43210",
    "0xb00327c898fb213f",
    "0xbf597fc7beef0ee4",
    "0xc6e00bf33da88fc2",
    "0xd5a79147930aa725",
    "0x06ca6351e003826f",
    "0x142929670a0e6e70",
    "0x27b70a8546d22ffc",
    "0x2e1b21385c26c926",
    "0x4d2c6dfc5ac42aed",
    "0x53380d139d95b3df",
    "0x650a73548baf63de",
    "0x766a0abb3c77b2a8",
    "0x81c2c92e47edaee6",
    "0x92722c851482353b",
    "0xa2bfe8a14cf10364",
    "0xa81a664bbc423001",
    "0xc24b8b70d0f89791",
    "0xc76c51a30654be30",
    "0xd192e819d6ef5218",
    "0xd69906245565a910",
    "0xf40e35855771202a",
    "0x106aa07032bbd1b8",
    "0x19a4c116b8d2d0c8",
    "0x1e376c085141ab53",
    "0x2748774cdf8eeb99",
    "0x34b0bcb5e19b48a8",
    "0x391c0cb3c5c95a63",
    "0x4ed8aa4ae3418acb",
    "0x5b9cca4f7763e373",
    "0x682e6ff3d6b2b8a3",
    "0x748f82ee5defb2fc",
    "0x78a5636f43172f60",
    "0x84c87814a1f0ab72",
    "0x8cc702081a6439ec",
    "0x90befffa23631e28",
    "0xa4506cebde82bde9",
    "0xbef9a3f7b2c67915",
    "0xc67178f2e372532b",
    "0xca273eceea26619c",
    "0xd186b8c721c0c207",
    "0xeada7dd6cde0eb1e",
    "0xf57d4f7fee6ed178",
    "0x06f067aa72176fba",
    "0x0a637dc5a2c898a6",
    "0x113f9804bef90dae",
    "0x1b710b35131c471b",
    "0x28db77f523047d84",
    "0x32caab7b40c72493",
    "0x3c9ebe0a15c9bebc",
    "0x431d67c49c100d4c",
    "0x4cc5d4becb3e42b6",
    "0x597f299cfc657e2a",
    "0x5fcb6fab3ad6faec",
    "0x6c44198c4a475817"
  ].map((n) => BigInt(n))))();
  const SHA512_Kh = /* @__PURE__ */ (() => K512[0])();
  const SHA512_Kl = /* @__PURE__ */ (() => K512[1])();
  const SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
  const SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
  class SHA512 extends _md_ts_1.HashMD {
    constructor(outputLen = 64) {
      super(128, outputLen, 16, false);
      this.Ah = _md_ts_1.SHA512_IV[0] | 0;
      this.Al = _md_ts_1.SHA512_IV[1] | 0;
      this.Bh = _md_ts_1.SHA512_IV[2] | 0;
      this.Bl = _md_ts_1.SHA512_IV[3] | 0;
      this.Ch = _md_ts_1.SHA512_IV[4] | 0;
      this.Cl = _md_ts_1.SHA512_IV[5] | 0;
      this.Dh = _md_ts_1.SHA512_IV[6] | 0;
      this.Dl = _md_ts_1.SHA512_IV[7] | 0;
      this.Eh = _md_ts_1.SHA512_IV[8] | 0;
      this.El = _md_ts_1.SHA512_IV[9] | 0;
      this.Fh = _md_ts_1.SHA512_IV[10] | 0;
      this.Fl = _md_ts_1.SHA512_IV[11] | 0;
      this.Gh = _md_ts_1.SHA512_IV[12] | 0;
      this.Gl = _md_ts_1.SHA512_IV[13] | 0;
      this.Hh = _md_ts_1.SHA512_IV[14] | 0;
      this.Hl = _md_ts_1.SHA512_IV[15] | 0;
    }
    // prettier-ignore
    get() {
      const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
      return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
    }
    // prettier-ignore
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
      this.Ah = Ah | 0;
      this.Al = Al | 0;
      this.Bh = Bh | 0;
      this.Bl = Bl | 0;
      this.Ch = Ch | 0;
      this.Cl = Cl | 0;
      this.Dh = Dh | 0;
      this.Dl = Dl | 0;
      this.Eh = Eh | 0;
      this.El = El | 0;
      this.Fh = Fh | 0;
      this.Fl = Fl | 0;
      this.Gh = Gh | 0;
      this.Gl = Gl | 0;
      this.Hh = Hh | 0;
      this.Hl = Hl | 0;
    }
    process(view, offset) {
      for (let i = 0; i < 16; i++, offset += 4) {
        SHA512_W_H[i] = view.getUint32(offset);
        SHA512_W_L[i] = view.getUint32(offset += 4);
      }
      for (let i = 16; i < 80; i++) {
        const W15h = SHA512_W_H[i - 15] | 0;
        const W15l = SHA512_W_L[i - 15] | 0;
        const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);
        const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);
        const W2h = SHA512_W_H[i - 2] | 0;
        const W2l = SHA512_W_L[i - 2] | 0;
        const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);
        const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);
        const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
        const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
        SHA512_W_H[i] = SUMh | 0;
        SHA512_W_L[i] = SUMl | 0;
      }
      let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
      for (let i = 0; i < 80; i++) {
        const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);
        const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);
        const CHIh = Eh & Fh ^ ~Eh & Gh;
        const CHIl = El & Fl ^ ~El & Gl;
        const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
        const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
        const T1l = T1ll | 0;
        const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);
        const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);
        const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
        const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
        Hh = Gh | 0;
        Hl = Gl | 0;
        Gh = Fh | 0;
        Gl = Fl | 0;
        Fh = Eh | 0;
        Fl = El | 0;
        ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
        Dh = Ch | 0;
        Dl = Cl | 0;
        Ch = Bh | 0;
        Cl = Bl | 0;
        Bh = Ah | 0;
        Bl = Al | 0;
        const All = u64.add3L(T1l, sigma0l, MAJl);
        Ah = u64.add3H(All, T1h, sigma0h, MAJh);
        Al = All | 0;
      }
      ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
      ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
      ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
      ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
      ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
      ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
      ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
      ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
      this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
      (0, utils_ts_1.clean)(SHA512_W_H, SHA512_W_L);
    }
    destroy() {
      (0, utils_ts_1.clean)(this.buffer);
      this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  }
  sha2.SHA512 = SHA512;
  class SHA384 extends SHA512 {
    constructor() {
      super(48);
      this.Ah = _md_ts_1.SHA384_IV[0] | 0;
      this.Al = _md_ts_1.SHA384_IV[1] | 0;
      this.Bh = _md_ts_1.SHA384_IV[2] | 0;
      this.Bl = _md_ts_1.SHA384_IV[3] | 0;
      this.Ch = _md_ts_1.SHA384_IV[4] | 0;
      this.Cl = _md_ts_1.SHA384_IV[5] | 0;
      this.Dh = _md_ts_1.SHA384_IV[6] | 0;
      this.Dl = _md_ts_1.SHA384_IV[7] | 0;
      this.Eh = _md_ts_1.SHA384_IV[8] | 0;
      this.El = _md_ts_1.SHA384_IV[9] | 0;
      this.Fh = _md_ts_1.SHA384_IV[10] | 0;
      this.Fl = _md_ts_1.SHA384_IV[11] | 0;
      this.Gh = _md_ts_1.SHA384_IV[12] | 0;
      this.Gl = _md_ts_1.SHA384_IV[13] | 0;
      this.Hh = _md_ts_1.SHA384_IV[14] | 0;
      this.Hl = _md_ts_1.SHA384_IV[15] | 0;
    }
  }
  sha2.SHA384 = SHA384;
  const T224_IV = /* @__PURE__ */ Uint32Array.from([
    2352822216,
    424955298,
    1944164710,
    2312950998,
    502970286,
    855612546,
    1738396948,
    1479516111,
    258812777,
    2077511080,
    2011393907,
    79989058,
    1067287976,
    1780299464,
    286451373,
    2446758561
  ]);
  const T256_IV = /* @__PURE__ */ Uint32Array.from([
    573645204,
    4230739756,
    2673172387,
    3360449730,
    596883563,
    1867755857,
    2520282905,
    1497426621,
    2519219938,
    2827943907,
    3193839141,
    1401305490,
    721525244,
    746961066,
    246885852,
    2177182882
  ]);
  class SHA512_224 extends SHA512 {
    constructor() {
      super(28);
      this.Ah = T224_IV[0] | 0;
      this.Al = T224_IV[1] | 0;
      this.Bh = T224_IV[2] | 0;
      this.Bl = T224_IV[3] | 0;
      this.Ch = T224_IV[4] | 0;
      this.Cl = T224_IV[5] | 0;
      this.Dh = T224_IV[6] | 0;
      this.Dl = T224_IV[7] | 0;
      this.Eh = T224_IV[8] | 0;
      this.El = T224_IV[9] | 0;
      this.Fh = T224_IV[10] | 0;
      this.Fl = T224_IV[11] | 0;
      this.Gh = T224_IV[12] | 0;
      this.Gl = T224_IV[13] | 0;
      this.Hh = T224_IV[14] | 0;
      this.Hl = T224_IV[15] | 0;
    }
  }
  sha2.SHA512_224 = SHA512_224;
  class SHA512_256 extends SHA512 {
    constructor() {
      super(32);
      this.Ah = T256_IV[0] | 0;
      this.Al = T256_IV[1] | 0;
      this.Bh = T256_IV[2] | 0;
      this.Bl = T256_IV[3] | 0;
      this.Ch = T256_IV[4] | 0;
      this.Cl = T256_IV[5] | 0;
      this.Dh = T256_IV[6] | 0;
      this.Dl = T256_IV[7] | 0;
      this.Eh = T256_IV[8] | 0;
      this.El = T256_IV[9] | 0;
      this.Fh = T256_IV[10] | 0;
      this.Fl = T256_IV[11] | 0;
      this.Gh = T256_IV[12] | 0;
      this.Gl = T256_IV[13] | 0;
      this.Hh = T256_IV[14] | 0;
      this.Hl = T256_IV[15] | 0;
    }
  }
  sha2.SHA512_256 = SHA512_256;
  sha2.sha256 = (0, utils_ts_1.createHasher)(() => new SHA256());
  sha2.sha224 = (0, utils_ts_1.createHasher)(() => new SHA224());
  sha2.sha512 = (0, utils_ts_1.createHasher)(() => new SHA512());
  sha2.sha384 = (0, utils_ts_1.createHasher)(() => new SHA384());
  sha2.sha512_256 = (0, utils_ts_1.createHasher)(() => new SHA512_256());
  sha2.sha512_224 = (0, utils_ts_1.createHasher)(() => new SHA512_224());
  return sha2;
}
var hasRequiredSha256;
function requireSha256() {
  if (hasRequiredSha256) return sha256;
  hasRequiredSha256 = 1;
  Object.defineProperty(sha256, "__esModule", { value: true });
  sha256.sha224 = sha256.SHA224 = sha256.sha256 = sha256.SHA256 = void 0;
  const sha2_ts_1 = /* @__PURE__ */ requireSha2();
  sha256.SHA256 = sha2_ts_1.SHA256;
  sha256.sha256 = sha2_ts_1.sha256;
  sha256.SHA224 = sha2_ts_1.SHA224;
  sha256.sha224 = sha2_ts_1.sha224;
  return sha256;
}
var sha512 = {};
var hasRequiredSha512;
function requireSha512() {
  if (hasRequiredSha512) return sha512;
  hasRequiredSha512 = 1;
  Object.defineProperty(sha512, "__esModule", { value: true });
  sha512.sha512_256 = sha512.SHA512_256 = sha512.sha512_224 = sha512.SHA512_224 = sha512.sha384 = sha512.SHA384 = sha512.sha512 = sha512.SHA512 = void 0;
  const sha2_ts_1 = /* @__PURE__ */ requireSha2();
  sha512.SHA512 = sha2_ts_1.SHA512;
  sha512.sha512 = sha2_ts_1.sha512;
  sha512.SHA384 = sha2_ts_1.SHA384;
  sha512.sha384 = sha2_ts_1.sha384;
  sha512.SHA512_224 = sha2_ts_1.SHA512_224;
  sha512.sha512_224 = sha2_ts_1.sha512_224;
  sha512.SHA512_256 = sha2_ts_1.SHA512_256;
  sha512.sha512_256 = sha2_ts_1.sha512_256;
  return sha512;
}
var pbkdf2 = {};
var hmac = {};
var hasRequiredHmac;
function requireHmac() {
  if (hasRequiredHmac) return hmac;
  hasRequiredHmac = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hmac = exports.HMAC = void 0;
    const utils_ts_1 = /* @__PURE__ */ requireUtils();
    class HMAC extends utils_ts_1.Hash {
      constructor(hash, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        (0, utils_ts_1.ahash)(hash);
        const key2 = (0, utils_ts_1.toBytes)(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== "function")
          throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        pad.set(key2.length > blockLen ? hash.create().update(key2).digest() : key2);
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54;
        this.iHash.update(pad);
        this.oHash = hash.create();
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54 ^ 92;
        this.oHash.update(pad);
        (0, utils_ts_1.clean)(pad);
      }
      update(buf) {
        (0, utils_ts_1.aexists)(this);
        this.iHash.update(buf);
        return this;
      }
      digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.abytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to) {
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
      }
      clone() {
        return this._cloneInto();
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    }
    exports.HMAC = HMAC;
    const hmac2 = (hash, key2, message) => new HMAC(hash, key2).update(message).digest();
    exports.hmac = hmac2;
    exports.hmac.create = (hash, key2) => new HMAC(hash, key2);
  })(hmac);
  return hmac;
}
var hasRequiredPbkdf2;
function requirePbkdf2() {
  if (hasRequiredPbkdf2) return pbkdf2;
  hasRequiredPbkdf2 = 1;
  Object.defineProperty(pbkdf2, "__esModule", { value: true });
  pbkdf2.pbkdf2 = pbkdf2$12;
  pbkdf2.pbkdf2Async = pbkdf2Async;
  const hmac_ts_1 = /* @__PURE__ */ requireHmac();
  const utils_ts_1 = /* @__PURE__ */ requireUtils();
  function pbkdf2Init(hash, _password, _salt, _opts) {
    (0, utils_ts_1.ahash)(hash);
    const opts = (0, utils_ts_1.checkOpts)({ dkLen: 32, asyncTick: 10 }, _opts);
    const { c, dkLen, asyncTick } = opts;
    (0, utils_ts_1.anumber)(c);
    (0, utils_ts_1.anumber)(dkLen);
    (0, utils_ts_1.anumber)(asyncTick);
    if (c < 1)
      throw new Error("iterations (c) should be >= 1");
    const password = (0, utils_ts_1.kdfInputToBytes)(_password);
    const salt = (0, utils_ts_1.kdfInputToBytes)(_salt);
    const DK = new Uint8Array(dkLen);
    const PRF = hmac_ts_1.hmac.create(hash, password);
    const PRFSalt = PRF._cloneInto().update(salt);
    return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
  }
  function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
    PRF.destroy();
    PRFSalt.destroy();
    if (prfW)
      prfW.destroy();
    (0, utils_ts_1.clean)(u);
    return DK;
  }
  function pbkdf2$12(hash, password, salt, opts) {
    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
    let prfW;
    const arr = new Uint8Array(4);
    const view = (0, utils_ts_1.createView)(arr);
    const u = new Uint8Array(PRF.outputLen);
    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
      const Ti = DK.subarray(pos, pos + PRF.outputLen);
      view.setInt32(0, ti, false);
      (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
      Ti.set(u.subarray(0, Ti.length));
      for (let ui = 1; ui < c; ui++) {
        PRF._cloneInto(prfW).update(u).digestInto(u);
        for (let i = 0; i < Ti.length; i++)
          Ti[i] ^= u[i];
      }
    }
    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
  }
  async function pbkdf2Async(hash, password, salt, opts) {
    const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
    let prfW;
    const arr = new Uint8Array(4);
    const view = (0, utils_ts_1.createView)(arr);
    const u = new Uint8Array(PRF.outputLen);
    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
      const Ti = DK.subarray(pos, pos + PRF.outputLen);
      view.setInt32(0, ti, false);
      (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
      Ti.set(u.subarray(0, Ti.length));
      await (0, utils_ts_1.asyncLoop)(c - 1, asyncTick, () => {
        PRF._cloneInto(prfW).update(u).digestInto(u);
        for (let i = 0; i < Ti.length; i++)
          Ti[i] ^= u[i];
      });
    }
    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
  }
  return pbkdf2;
}
var _wordlists = {};
const require$$0 = /* @__PURE__ */ JSON.parse('["abdikace","abeceda","adresa","agrese","akce","aktovka","alej","alkohol","amputace","ananas","andulka","anekdota","anketa","antika","anulovat","archa","arogance","asfalt","asistent","aspirace","astma","astronom","atlas","atletika","atol","autobus","azyl","babka","bachor","bacil","baculka","badatel","bageta","bagr","bahno","bakterie","balada","baletka","balkon","balonek","balvan","balza","bambus","bankomat","barbar","baret","barman","baroko","barva","baterka","batoh","bavlna","bazalka","bazilika","bazuka","bedna","beran","beseda","bestie","beton","bezinka","bezmoc","beztak","bicykl","bidlo","biftek","bikiny","bilance","biograf","biolog","bitva","bizon","blahobyt","blatouch","blecha","bledule","blesk","blikat","blizna","blokovat","bloudit","blud","bobek","bobr","bodlina","bodnout","bohatost","bojkot","bojovat","bokorys","bolest","borec","borovice","bota","boubel","bouchat","bouda","boule","bourat","boxer","bradavka","brambora","branka","bratr","brepta","briketa","brko","brloh","bronz","broskev","brunetka","brusinka","brzda","brzy","bublina","bubnovat","buchta","buditel","budka","budova","bufet","bujarost","bukvice","buldok","bulva","bunda","bunkr","burza","butik","buvol","buzola","bydlet","bylina","bytovka","bzukot","capart","carevna","cedr","cedule","cejch","cejn","cela","celer","celkem","celnice","cenina","cennost","cenovka","centrum","cenzor","cestopis","cetka","chalupa","chapadlo","charita","chata","chechtat","chemie","chichot","chirurg","chlad","chleba","chlubit","chmel","chmura","chobot","chochol","chodba","cholera","chomout","chopit","choroba","chov","chrapot","chrlit","chrt","chrup","chtivost","chudina","chutnat","chvat","chvilka","chvost","chyba","chystat","chytit","cibule","cigareta","cihelna","cihla","cinkot","cirkus","cisterna","citace","citrus","cizinec","cizost","clona","cokoliv","couvat","ctitel","ctnost","cudnost","cuketa","cukr","cupot","cvaknout","cval","cvik","cvrkot","cyklista","daleko","dareba","datel","datum","dcera","debata","dechovka","decibel","deficit","deflace","dekl","dekret","demokrat","deprese","derby","deska","detektiv","dikobraz","diktovat","dioda","diplom","disk","displej","divadlo","divoch","dlaha","dlouho","dluhopis","dnes","dobro","dobytek","docent","dochutit","dodnes","dohled","dohoda","dohra","dojem","dojnice","doklad","dokola","doktor","dokument","dolar","doleva","dolina","doma","dominant","domluvit","domov","donutit","dopad","dopis","doplnit","doposud","doprovod","dopustit","dorazit","dorost","dort","dosah","doslov","dostatek","dosud","dosyta","dotaz","dotek","dotknout","doufat","doutnat","dovozce","dozadu","doznat","dozorce","drahota","drak","dramatik","dravec","draze","drdol","drobnost","drogerie","drozd","drsnost","drtit","drzost","duben","duchovno","dudek","duha","duhovka","dusit","dusno","dutost","dvojice","dvorec","dynamit","ekolog","ekonomie","elektron","elipsa","email","emise","emoce","empatie","epizoda","epocha","epopej","epos","esej","esence","eskorta","eskymo","etiketa","euforie","evoluce","exekuce","exkurze","expedice","exploze","export","extrakt","facka","fajfka","fakulta","fanatik","fantazie","farmacie","favorit","fazole","federace","fejeton","fenka","fialka","figurant","filozof","filtr","finance","finta","fixace","fjord","flanel","flirt","flotila","fond","fosfor","fotbal","fotka","foton","frakce","freska","fronta","fukar","funkce","fyzika","galeje","garant","genetika","geolog","gilotina","glazura","glejt","golem","golfista","gotika","graf","gramofon","granule","grep","gril","grog","groteska","guma","hadice","hadr","hala","halenka","hanba","hanopis","harfa","harpuna","havran","hebkost","hejkal","hejno","hejtman","hektar","helma","hematom","herec","herna","heslo","hezky","historik","hladovka","hlasivky","hlava","hledat","hlen","hlodavec","hloh","hloupost","hltat","hlubina","hluchota","hmat","hmota","hmyz","hnis","hnojivo","hnout","hoblina","hoboj","hoch","hodiny","hodlat","hodnota","hodovat","hojnost","hokej","holinka","holka","holub","homole","honitba","honorace","horal","horda","horizont","horko","horlivec","hormon","hornina","horoskop","horstvo","hospoda","hostina","hotovost","houba","houf","houpat","houska","hovor","hradba","hranice","hravost","hrazda","hrbolek","hrdina","hrdlo","hrdost","hrnek","hrobka","hromada","hrot","hrouda","hrozen","hrstka","hrubost","hryzat","hubenost","hubnout","hudba","hukot","humr","husita","hustota","hvozd","hybnost","hydrant","hygiena","hymna","hysterik","idylka","ihned","ikona","iluze","imunita","infekce","inflace","inkaso","inovace","inspekce","internet","invalida","investor","inzerce","ironie","jablko","jachta","jahoda","jakmile","jakost","jalovec","jantar","jarmark","jaro","jasan","jasno","jatka","javor","jazyk","jedinec","jedle","jednatel","jehlan","jekot","jelen","jelito","jemnost","jenom","jepice","jeseter","jevit","jezdec","jezero","jinak","jindy","jinoch","jiskra","jistota","jitrnice","jizva","jmenovat","jogurt","jurta","kabaret","kabel","kabinet","kachna","kadet","kadidlo","kahan","kajak","kajuta","kakao","kaktus","kalamita","kalhoty","kalibr","kalnost","kamera","kamkoliv","kamna","kanibal","kanoe","kantor","kapalina","kapela","kapitola","kapka","kaple","kapota","kapr","kapusta","kapybara","karamel","karotka","karton","kasa","katalog","katedra","kauce","kauza","kavalec","kazajka","kazeta","kazivost","kdekoliv","kdesi","kedluben","kemp","keramika","kino","klacek","kladivo","klam","klapot","klasika","klaun","klec","klenba","klepat","klesnout","klid","klima","klisna","klobouk","klokan","klopa","kloub","klubovna","klusat","kluzkost","kmen","kmitat","kmotr","kniha","knot","koalice","koberec","kobka","kobliha","kobyla","kocour","kohout","kojenec","kokos","koktejl","kolaps","koleda","kolize","kolo","komando","kometa","komik","komnata","komora","kompas","komunita","konat","koncept","kondice","konec","konfese","kongres","konina","konkurs","kontakt","konzerva","kopanec","kopie","kopnout","koprovka","korbel","korektor","kormidlo","koroptev","korpus","koruna","koryto","korzet","kosatec","kostka","kotel","kotleta","kotoul","koukat","koupelna","kousek","kouzlo","kovboj","koza","kozoroh","krabice","krach","krajina","kralovat","krasopis","kravata","kredit","krejcar","kresba","kreveta","kriket","kritik","krize","krkavec","krmelec","krmivo","krocan","krok","kronika","kropit","kroupa","krovka","krtek","kruhadlo","krupice","krutost","krvinka","krychle","krypta","krystal","kryt","kudlanka","kufr","kujnost","kukla","kulajda","kulich","kulka","kulomet","kultura","kuna","kupodivu","kurt","kurzor","kutil","kvalita","kvasinka","kvestor","kynolog","kyselina","kytara","kytice","kytka","kytovec","kyvadlo","labrador","lachtan","ladnost","laik","lakomec","lamela","lampa","lanovka","lasice","laso","lastura","latinka","lavina","lebka","leckdy","leden","lednice","ledovka","ledvina","legenda","legie","legrace","lehce","lehkost","lehnout","lektvar","lenochod","lentilka","lepenka","lepidlo","letadlo","letec","letmo","letokruh","levhart","levitace","levobok","libra","lichotka","lidojed","lidskost","lihovina","lijavec","lilek","limetka","linie","linka","linoleum","listopad","litina","litovat","lobista","lodivod","logika","logoped","lokalita","loket","lomcovat","lopata","lopuch","lord","losos","lotr","loudal","louh","louka","louskat","lovec","lstivost","lucerna","lucifer","lump","lusk","lustrace","lvice","lyra","lyrika","lysina","madam","madlo","magistr","mahagon","majetek","majitel","majorita","makak","makovice","makrela","malba","malina","malovat","malvice","maminka","mandle","manko","marnost","masakr","maskot","masopust","matice","matrika","maturita","mazanec","mazivo","mazlit","mazurka","mdloba","mechanik","meditace","medovina","melasa","meloun","mentolka","metla","metoda","metr","mezera","migrace","mihnout","mihule","mikina","mikrofon","milenec","milimetr","milost","mimika","mincovna","minibar","minomet","minulost","miska","mistr","mixovat","mladost","mlha","mlhovina","mlok","mlsat","mluvit","mnich","mnohem","mobil","mocnost","modelka","modlitba","mohyla","mokro","molekula","momentka","monarcha","monokl","monstrum","montovat","monzun","mosaz","moskyt","most","motivace","motorka","motyka","moucha","moudrost","mozaika","mozek","mozol","mramor","mravenec","mrkev","mrtvola","mrzet","mrzutost","mstitel","mudrc","muflon","mulat","mumie","munice","muset","mutace","muzeum","muzikant","myslivec","mzda","nabourat","nachytat","nadace","nadbytek","nadhoz","nadobro","nadpis","nahlas","nahnat","nahodile","nahradit","naivita","najednou","najisto","najmout","naklonit","nakonec","nakrmit","nalevo","namazat","namluvit","nanometr","naoko","naopak","naostro","napadat","napevno","naplnit","napnout","naposled","naprosto","narodit","naruby","narychlo","nasadit","nasekat","naslepo","nastat","natolik","navenek","navrch","navzdory","nazvat","nebe","nechat","necky","nedaleko","nedbat","neduh","negace","nehet","nehoda","nejen","nejprve","neklid","nelibost","nemilost","nemoc","neochota","neonka","nepokoj","nerost","nerv","nesmysl","nesoulad","netvor","neuron","nevina","nezvykle","nicota","nijak","nikam","nikdy","nikl","nikterak","nitro","nocleh","nohavice","nominace","nora","norek","nositel","nosnost","nouze","noviny","novota","nozdra","nuda","nudle","nuget","nutit","nutnost","nutrie","nymfa","obal","obarvit","obava","obdiv","obec","obehnat","obejmout","obezita","obhajoba","obilnice","objasnit","objekt","obklopit","oblast","oblek","obliba","obloha","obluda","obnos","obohatit","obojek","obout","obrazec","obrna","obruba","obrys","obsah","obsluha","obstarat","obuv","obvaz","obvinit","obvod","obvykle","obyvatel","obzor","ocas","ocel","ocenit","ochladit","ochota","ochrana","ocitnout","odboj","odbyt","odchod","odcizit","odebrat","odeslat","odevzdat","odezva","odhadce","odhodit","odjet","odjinud","odkaz","odkoupit","odliv","odluka","odmlka","odolnost","odpad","odpis","odplout","odpor","odpustit","odpykat","odrazka","odsoudit","odstup","odsun","odtok","odtud","odvaha","odveta","odvolat","odvracet","odznak","ofina","ofsajd","ohlas","ohnisko","ohrada","ohrozit","ohryzek","okap","okenice","oklika","okno","okouzlit","okovy","okrasa","okres","okrsek","okruh","okupant","okurka","okusit","olejnina","olizovat","omak","omeleta","omezit","omladina","omlouvat","omluva","omyl","onehdy","opakovat","opasek","operace","opice","opilost","opisovat","opora","opozice","opravdu","oproti","orbital","orchestr","orgie","orlice","orloj","ortel","osada","oschnout","osika","osivo","oslava","oslepit","oslnit","oslovit","osnova","osoba","osolit","ospalec","osten","ostraha","ostuda","ostych","osvojit","oteplit","otisk","otop","otrhat","otrlost","otrok","otruby","otvor","ovanout","ovar","oves","ovlivnit","ovoce","oxid","ozdoba","pachatel","pacient","padouch","pahorek","pakt","palanda","palec","palivo","paluba","pamflet","pamlsek","panenka","panika","panna","panovat","panstvo","pantofle","paprika","parketa","parodie","parta","paruka","paryba","paseka","pasivita","pastelka","patent","patrona","pavouk","pazneht","pazourek","pecka","pedagog","pejsek","peklo","peloton","penalta","pendrek","penze","periskop","pero","pestrost","petarda","petice","petrolej","pevnina","pexeso","pianista","piha","pijavice","pikle","piknik","pilina","pilnost","pilulka","pinzeta","pipeta","pisatel","pistole","pitevna","pivnice","pivovar","placenta","plakat","plamen","planeta","plastika","platit","plavidlo","plaz","plech","plemeno","plenta","ples","pletivo","plevel","plivat","plnit","plno","plocha","plodina","plomba","plout","pluk","plyn","pobavit","pobyt","pochod","pocit","poctivec","podat","podcenit","podepsat","podhled","podivit","podklad","podmanit","podnik","podoba","podpora","podraz","podstata","podvod","podzim","poezie","pohanka","pohnutka","pohovor","pohroma","pohyb","pointa","pojistka","pojmout","pokazit","pokles","pokoj","pokrok","pokuta","pokyn","poledne","polibek","polknout","poloha","polynom","pomalu","pominout","pomlka","pomoc","pomsta","pomyslet","ponechat","ponorka","ponurost","popadat","popel","popisek","poplach","poprosit","popsat","popud","poradce","porce","porod","porucha","poryv","posadit","posed","posila","poskok","poslanec","posoudit","pospolu","postava","posudek","posyp","potah","potkan","potlesk","potomek","potrava","potupa","potvora","poukaz","pouto","pouzdro","povaha","povidla","povlak","povoz","povrch","povstat","povyk","povzdech","pozdrav","pozemek","poznatek","pozor","pozvat","pracovat","prahory","praktika","prales","praotec","praporek","prase","pravda","princip","prkno","probudit","procento","prodej","profese","prohra","projekt","prolomit","promile","pronikat","propad","prorok","prosba","proton","proutek","provaz","prskavka","prsten","prudkost","prut","prvek","prvohory","psanec","psovod","pstruh","ptactvo","puberta","puch","pudl","pukavec","puklina","pukrle","pult","pumpa","punc","pupen","pusa","pusinka","pustina","putovat","putyka","pyramida","pysk","pytel","racek","rachot","radiace","radnice","radon","raft","ragby","raketa","rakovina","rameno","rampouch","rande","rarach","rarita","rasovna","rastr","ratolest","razance","razidlo","reagovat","reakce","recept","redaktor","referent","reflex","rejnok","reklama","rekord","rekrut","rektor","reputace","revize","revma","revolver","rezerva","riskovat","riziko","robotika","rodokmen","rohovka","rokle","rokoko","romaneto","ropovod","ropucha","rorejs","rosol","rostlina","rotmistr","rotoped","rotunda","roubenka","roucho","roup","roura","rovina","rovnice","rozbor","rozchod","rozdat","rozeznat","rozhodce","rozinka","rozjezd","rozkaz","rozloha","rozmar","rozpad","rozruch","rozsah","roztok","rozum","rozvod","rubrika","ruchadlo","rukavice","rukopis","ryba","rybolov","rychlost","rydlo","rypadlo","rytina","ryzost","sadista","sahat","sako","samec","samizdat","samota","sanitka","sardinka","sasanka","satelit","sazba","sazenice","sbor","schovat","sebranka","secese","sedadlo","sediment","sedlo","sehnat","sejmout","sekera","sekta","sekunda","sekvoje","semeno","seno","servis","sesadit","seshora","seskok","seslat","sestra","sesuv","sesypat","setba","setina","setkat","setnout","setrvat","sever","seznam","shoda","shrnout","sifon","silnice","sirka","sirotek","sirup","situace","skafandr","skalisko","skanzen","skaut","skeptik","skica","skladba","sklenice","sklo","skluz","skoba","skokan","skoro","skripta","skrz","skupina","skvost","skvrna","slabika","sladidlo","slanina","slast","slavnost","sledovat","slepec","sleva","slezina","slib","slina","sliznice","slon","sloupek","slovo","sluch","sluha","slunce","slupka","slza","smaragd","smetana","smilstvo","smlouva","smog","smrad","smrk","smrtka","smutek","smysl","snad","snaha","snob","sobota","socha","sodovka","sokol","sopka","sotva","souboj","soucit","soudce","souhlas","soulad","soumrak","souprava","soused","soutok","souviset","spalovna","spasitel","spis","splav","spodek","spojenec","spolu","sponzor","spornost","spousta","sprcha","spustit","sranda","sraz","srdce","srna","srnec","srovnat","srpen","srst","srub","stanice","starosta","statika","stavba","stehno","stezka","stodola","stolek","stopa","storno","stoupat","strach","stres","strhnout","strom","struna","studna","stupnice","stvol","styk","subjekt","subtropy","suchar","sudost","sukno","sundat","sunout","surikata","surovina","svah","svalstvo","svetr","svatba","svazek","svisle","svitek","svoboda","svodidlo","svorka","svrab","sykavka","sykot","synek","synovec","sypat","sypkost","syrovost","sysel","sytost","tabletka","tabule","tahoun","tajemno","tajfun","tajga","tajit","tajnost","taktika","tamhle","tampon","tancovat","tanec","tanker","tapeta","tavenina","tazatel","technika","tehdy","tekutina","telefon","temnota","tendence","tenista","tenor","teplota","tepna","teprve","terapie","termoska","textil","ticho","tiskopis","titulek","tkadlec","tkanina","tlapka","tleskat","tlukot","tlupa","tmel","toaleta","topinka","topol","torzo","touha","toulec","tradice","traktor","tramp","trasa","traverza","trefit","trest","trezor","trhavina","trhlina","trochu","trojice","troska","trouba","trpce","trpitel","trpkost","trubec","truchlit","truhlice","trus","trvat","tudy","tuhnout","tuhost","tundra","turista","turnaj","tuzemsko","tvaroh","tvorba","tvrdost","tvrz","tygr","tykev","ubohost","uboze","ubrat","ubrousek","ubrus","ubytovna","ucho","uctivost","udivit","uhradit","ujednat","ujistit","ujmout","ukazatel","uklidnit","uklonit","ukotvit","ukrojit","ulice","ulita","ulovit","umyvadlo","unavit","uniforma","uniknout","upadnout","uplatnit","uplynout","upoutat","upravit","uran","urazit","usednout","usilovat","usmrtit","usnadnit","usnout","usoudit","ustlat","ustrnout","utahovat","utkat","utlumit","utonout","utopenec","utrousit","uvalit","uvolnit","uvozovka","uzdravit","uzel","uzenina","uzlina","uznat","vagon","valcha","valoun","vana","vandal","vanilka","varan","varhany","varovat","vcelku","vchod","vdova","vedro","vegetace","vejce","velbloud","veletrh","velitel","velmoc","velryba","venkov","veranda","verze","veselka","veskrze","vesnice","vespodu","vesta","veterina","veverka","vibrace","vichr","videohra","vidina","vidle","vila","vinice","viset","vitalita","vize","vizitka","vjezd","vklad","vkus","vlajka","vlak","vlasec","vlevo","vlhkost","vliv","vlnovka","vloupat","vnucovat","vnuk","voda","vodivost","vodoznak","vodstvo","vojensky","vojna","vojsko","volant","volba","volit","volno","voskovka","vozidlo","vozovna","vpravo","vrabec","vracet","vrah","vrata","vrba","vrcholek","vrhat","vrstva","vrtule","vsadit","vstoupit","vstup","vtip","vybavit","vybrat","vychovat","vydat","vydra","vyfotit","vyhledat","vyhnout","vyhodit","vyhradit","vyhubit","vyjasnit","vyjet","vyjmout","vyklopit","vykonat","vylekat","vymazat","vymezit","vymizet","vymyslet","vynechat","vynikat","vynutit","vypadat","vyplatit","vypravit","vypustit","vyrazit","vyrovnat","vyrvat","vyslovit","vysoko","vystavit","vysunout","vysypat","vytasit","vytesat","vytratit","vyvinout","vyvolat","vyvrhel","vyzdobit","vyznat","vzadu","vzbudit","vzchopit","vzdor","vzduch","vzdychat","vzestup","vzhledem","vzkaz","vzlykat","vznik","vzorek","vzpoura","vztah","vztek","xylofon","zabrat","zabydlet","zachovat","zadarmo","zadusit","zafoukat","zahltit","zahodit","zahrada","zahynout","zajatec","zajet","zajistit","zaklepat","zakoupit","zalepit","zamezit","zamotat","zamyslet","zanechat","zanikat","zaplatit","zapojit","zapsat","zarazit","zastavit","zasunout","zatajit","zatemnit","zatknout","zaujmout","zavalit","zavelet","zavinit","zavolat","zavrtat","zazvonit","zbavit","zbrusu","zbudovat","zbytek","zdaleka","zdarma","zdatnost","zdivo","zdobit","zdroj","zdvih","zdymadlo","zelenina","zeman","zemina","zeptat","zezadu","zezdola","zhatit","zhltnout","zhluboka","zhotovit","zhruba","zima","zimnice","zjemnit","zklamat","zkoumat","zkratka","zkumavka","zlato","zlehka","zloba","zlom","zlost","zlozvyk","zmapovat","zmar","zmatek","zmije","zmizet","zmocnit","zmodrat","zmrzlina","zmutovat","znak","znalost","znamenat","znovu","zobrazit","zotavit","zoubek","zoufale","zplodit","zpomalit","zprava","zprostit","zprudka","zprvu","zrada","zranit","zrcadlo","zrnitost","zrno","zrovna","zrychlit","zrzavost","zticha","ztratit","zubovina","zubr","zvednout","zvenku","zvesela","zvon","zvrat","zvukovod","zvyk"]');
const require$$1 = /* @__PURE__ */ JSON.parse('["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""]');
const require$$2 = /* @__PURE__ */ JSON.parse('["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""]');
const require$$3 = /* @__PURE__ */ JSON.parse('["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""]');
const require$$4 = /* @__PURE__ */ JSON.parse('["abaisser","abandon","abdiquer","abeille","abolir","aborder","aboutir","aboyer","abrasif","abreuver","abriter","abroger","abrupt","absence","absolu","absurde","abusif","abyssal","academie","acajou","acarien","accabler","accepter","acclamer","accolade","accroche","accuser","acerbe","achat","acheter","aciduler","acier","acompte","acquerir","acronyme","acteur","actif","actuel","adepte","adequat","adhesif","adjectif","adjuger","admettre","admirer","adopter","adorer","adoucir","adresse","adroit","adulte","adverbe","aerer","aeronef","affaire","affecter","affiche","affreux","affubler","agacer","agencer","agile","agiter","agrafer","agreable","agrume","aider","aiguille","ailier","aimable","aisance","ajouter","ajuster","alarmer","alchimie","alerte","algebre","algue","aliener","aliment","alleger","alliage","allouer","allumer","alourdir","alpaga","altesse","alveole","amateur","ambigu","ambre","amenager","amertume","amidon","amiral","amorcer","amour","amovible","amphibie","ampleur","amusant","analyse","anaphore","anarchie","anatomie","ancien","aneantir","angle","angoisse","anguleux","animal","annexer","annonce","annuel","anodin","anomalie","anonyme","anormal","antenne","antidote","anxieux","apaiser","aperitif","aplanir","apologie","appareil","appeler","apporter","appuyer","aquarium","aqueduc","arbitre","arbuste","ardeur","ardoise","argent","arlequin","armature","armement","armoire","armure","arpenter","arracher","arriver","arroser","arsenic","arteriel","article","aspect","asphalte","aspirer","assaut","asservir","assiette","associer","assurer","asticot","astre","astuce","atelier","atome","atrium","atroce","attaque","attentif","attirer","attraper","aubaine","auberge","audace","audible","augurer","aurore","automne","autruche","avaler","avancer","avarice","avenir","averse","aveugle","aviateur","avide","avion","aviser","avoine","avouer","avril","axial","axiome","badge","bafouer","bagage","baguette","baignade","balancer","balcon","baleine","balisage","bambin","bancaire","bandage","banlieue","banniere","banquier","barbier","baril","baron","barque","barrage","bassin","bastion","bataille","bateau","batterie","baudrier","bavarder","belette","belier","belote","benefice","berceau","berger","berline","bermuda","besace","besogne","betail","beurre","biberon","bicycle","bidule","bijou","bilan","bilingue","billard","binaire","biologie","biopsie","biotype","biscuit","bison","bistouri","bitume","bizarre","blafard","blague","blanchir","blessant","blinder","blond","bloquer","blouson","bobard","bobine","boire","boiser","bolide","bonbon","bondir","bonheur","bonifier","bonus","bordure","borne","botte","boucle","boueux","bougie","boulon","bouquin","bourse","boussole","boutique","boxeur","branche","brasier","brave","brebis","breche","breuvage","bricoler","brigade","brillant","brioche","brique","brochure","broder","bronzer","brousse","broyeur","brume","brusque","brutal","bruyant","buffle","buisson","bulletin","bureau","burin","bustier","butiner","butoir","buvable","buvette","cabanon","cabine","cachette","cadeau","cadre","cafeine","caillou","caisson","calculer","calepin","calibre","calmer","calomnie","calvaire","camarade","camera","camion","campagne","canal","caneton","canon","cantine","canular","capable","caporal","caprice","capsule","capter","capuche","carabine","carbone","caresser","caribou","carnage","carotte","carreau","carton","cascade","casier","casque","cassure","causer","caution","cavalier","caverne","caviar","cedille","ceinture","celeste","cellule","cendrier","censurer","central","cercle","cerebral","cerise","cerner","cerveau","cesser","chagrin","chaise","chaleur","chambre","chance","chapitre","charbon","chasseur","chaton","chausson","chavirer","chemise","chenille","chequier","chercher","cheval","chien","chiffre","chignon","chimere","chiot","chlorure","chocolat","choisir","chose","chouette","chrome","chute","cigare","cigogne","cimenter","cinema","cintrer","circuler","cirer","cirque","citerne","citoyen","citron","civil","clairon","clameur","claquer","classe","clavier","client","cligner","climat","clivage","cloche","clonage","cloporte","cobalt","cobra","cocasse","cocotier","coder","codifier","coffre","cogner","cohesion","coiffer","coincer","colere","colibri","colline","colmater","colonel","combat","comedie","commande","compact","concert","conduire","confier","congeler","connoter","consonne","contact","convexe","copain","copie","corail","corbeau","cordage","corniche","corpus","correct","cortege","cosmique","costume","coton","coude","coupure","courage","couteau","couvrir","coyote","crabe","crainte","cravate","crayon","creature","crediter","cremeux","creuser","crevette","cribler","crier","cristal","critere","croire","croquer","crotale","crucial","cruel","crypter","cubique","cueillir","cuillere","cuisine","cuivre","culminer","cultiver","cumuler","cupide","curatif","curseur","cyanure","cycle","cylindre","cynique","daigner","damier","danger","danseur","dauphin","debattre","debiter","deborder","debrider","debutant","decaler","decembre","dechirer","decider","declarer","decorer","decrire","decupler","dedale","deductif","deesse","defensif","defiler","defrayer","degager","degivrer","deglutir","degrafer","dejeuner","delice","deloger","demander","demeurer","demolir","denicher","denouer","dentelle","denuder","depart","depenser","dephaser","deplacer","deposer","deranger","derober","desastre","descente","desert","designer","desobeir","dessiner","destrier","detacher","detester","detourer","detresse","devancer","devenir","deviner","devoir","diable","dialogue","diamant","dicter","differer","digerer","digital","digne","diluer","dimanche","diminuer","dioxyde","directif","diriger","discuter","disposer","dissiper","distance","divertir","diviser","docile","docteur","dogme","doigt","domaine","domicile","dompter","donateur","donjon","donner","dopamine","dortoir","dorure","dosage","doseur","dossier","dotation","douanier","double","douceur","douter","doyen","dragon","draper","dresser","dribbler","droiture","duperie","duplexe","durable","durcir","dynastie","eblouir","ecarter","echarpe","echelle","eclairer","eclipse","eclore","ecluse","ecole","economie","ecorce","ecouter","ecraser","ecremer","ecrivain","ecrou","ecume","ecureuil","edifier","eduquer","effacer","effectif","effigie","effort","effrayer","effusion","egaliser","egarer","ejecter","elaborer","elargir","electron","elegant","elephant","eleve","eligible","elitisme","eloge","elucider","eluder","emballer","embellir","embryon","emeraude","emission","emmener","emotion","emouvoir","empereur","employer","emporter","emprise","emulsion","encadrer","enchere","enclave","encoche","endiguer","endosser","endroit","enduire","energie","enfance","enfermer","enfouir","engager","engin","englober","enigme","enjamber","enjeu","enlever","ennemi","ennuyeux","enrichir","enrobage","enseigne","entasser","entendre","entier","entourer","entraver","enumerer","envahir","enviable","envoyer","enzyme","eolien","epaissir","epargne","epatant","epaule","epicerie","epidemie","epier","epilogue","epine","episode","epitaphe","epoque","epreuve","eprouver","epuisant","equerre","equipe","eriger","erosion","erreur","eruption","escalier","espadon","espece","espiegle","espoir","esprit","esquiver","essayer","essence","essieu","essorer","estime","estomac","estrade","etagere","etaler","etanche","etatique","eteindre","etendoir","eternel","ethanol","ethique","ethnie","etirer","etoffer","etoile","etonnant","etourdir","etrange","etroit","etude","euphorie","evaluer","evasion","eventail","evidence","eviter","evolutif","evoquer","exact","exagerer","exaucer","exceller","excitant","exclusif","excuse","executer","exemple","exercer","exhaler","exhorter","exigence","exiler","exister","exotique","expedier","explorer","exposer","exprimer","exquis","extensif","extraire","exulter","fable","fabuleux","facette","facile","facture","faiblir","falaise","fameux","famille","farceur","farfelu","farine","farouche","fasciner","fatal","fatigue","faucon","fautif","faveur","favori","febrile","feconder","federer","felin","femme","femur","fendoir","feodal","fermer","feroce","ferveur","festival","feuille","feutre","fevrier","fiasco","ficeler","fictif","fidele","figure","filature","filetage","filiere","filleul","filmer","filou","filtrer","financer","finir","fiole","firme","fissure","fixer","flairer","flamme","flasque","flatteur","fleau","fleche","fleur","flexion","flocon","flore","fluctuer","fluide","fluvial","folie","fonderie","fongible","fontaine","forcer","forgeron","formuler","fortune","fossile","foudre","fougere","fouiller","foulure","fourmi","fragile","fraise","franchir","frapper","frayeur","fregate","freiner","frelon","fremir","frenesie","frere","friable","friction","frisson","frivole","froid","fromage","frontal","frotter","fruit","fugitif","fuite","fureur","furieux","furtif","fusion","futur","gagner","galaxie","galerie","gambader","garantir","gardien","garnir","garrigue","gazelle","gazon","geant","gelatine","gelule","gendarme","general","genie","genou","gentil","geologie","geometre","geranium","germe","gestuel","geyser","gibier","gicler","girafe","givre","glace","glaive","glisser","globe","gloire","glorieux","golfeur","gomme","gonfler","gorge","gorille","goudron","gouffre","goulot","goupille","gourmand","goutte","graduel","graffiti","graine","grand","grappin","gratuit","gravir","grenat","griffure","griller","grimper","grogner","gronder","grotte","groupe","gruger","grutier","gruyere","guepard","guerrier","guide","guimauve","guitare","gustatif","gymnaste","gyrostat","habitude","hachoir","halte","hameau","hangar","hanneton","haricot","harmonie","harpon","hasard","helium","hematome","herbe","herisson","hermine","heron","hesiter","heureux","hiberner","hibou","hilarant","histoire","hiver","homard","hommage","homogene","honneur","honorer","honteux","horde","horizon","horloge","hormone","horrible","houleux","housse","hublot","huileux","humain","humble","humide","humour","hurler","hydromel","hygiene","hymne","hypnose","idylle","ignorer","iguane","illicite","illusion","image","imbiber","imiter","immense","immobile","immuable","impact","imperial","implorer","imposer","imprimer","imputer","incarner","incendie","incident","incliner","incolore","indexer","indice","inductif","inedit","ineptie","inexact","infini","infliger","informer","infusion","ingerer","inhaler","inhiber","injecter","injure","innocent","inoculer","inonder","inscrire","insecte","insigne","insolite","inspirer","instinct","insulter","intact","intense","intime","intrigue","intuitif","inutile","invasion","inventer","inviter","invoquer","ironique","irradier","irreel","irriter","isoler","ivoire","ivresse","jaguar","jaillir","jambe","janvier","jardin","jauger","jaune","javelot","jetable","jeton","jeudi","jeunesse","joindre","joncher","jongler","joueur","jouissif","journal","jovial","joyau","joyeux","jubiler","jugement","junior","jupon","juriste","justice","juteux","juvenile","kayak","kimono","kiosque","label","labial","labourer","lacerer","lactose","lagune","laine","laisser","laitier","lambeau","lamelle","lampe","lanceur","langage","lanterne","lapin","largeur","larme","laurier","lavabo","lavoir","lecture","legal","leger","legume","lessive","lettre","levier","lexique","lezard","liasse","liberer","libre","licence","licorne","liege","lievre","ligature","ligoter","ligue","limer","limite","limonade","limpide","lineaire","lingot","lionceau","liquide","lisiere","lister","lithium","litige","littoral","livreur","logique","lointain","loisir","lombric","loterie","louer","lourd","loutre","louve","loyal","lubie","lucide","lucratif","lueur","lugubre","luisant","lumiere","lunaire","lundi","luron","lutter","luxueux","machine","magasin","magenta","magique","maigre","maillon","maintien","mairie","maison","majorer","malaxer","malefice","malheur","malice","mallette","mammouth","mandater","maniable","manquant","manteau","manuel","marathon","marbre","marchand","mardi","maritime","marqueur","marron","marteler","mascotte","massif","materiel","matiere","matraque","maudire","maussade","mauve","maximal","mechant","meconnu","medaille","medecin","mediter","meduse","meilleur","melange","melodie","membre","memoire","menacer","mener","menhir","mensonge","mentor","mercredi","merite","merle","messager","mesure","metal","meteore","methode","metier","meuble","miauler","microbe","miette","mignon","migrer","milieu","million","mimique","mince","mineral","minimal","minorer","minute","miracle","miroiter","missile","mixte","mobile","moderne","moelleux","mondial","moniteur","monnaie","monotone","monstre","montagne","monument","moqueur","morceau","morsure","mortier","moteur","motif","mouche","moufle","moulin","mousson","mouton","mouvant","multiple","munition","muraille","murene","murmure","muscle","museum","musicien","mutation","muter","mutuel","myriade","myrtille","mystere","mythique","nageur","nappe","narquois","narrer","natation","nation","nature","naufrage","nautique","navire","nebuleux","nectar","nefaste","negation","negliger","negocier","neige","nerveux","nettoyer","neurone","neutron","neveu","niche","nickel","nitrate","niveau","noble","nocif","nocturne","noirceur","noisette","nomade","nombreux","nommer","normatif","notable","notifier","notoire","nourrir","nouveau","novateur","novembre","novice","nuage","nuancer","nuire","nuisible","numero","nuptial","nuque","nutritif","obeir","objectif","obliger","obscur","observer","obstacle","obtenir","obturer","occasion","occuper","ocean","octobre","octroyer","octupler","oculaire","odeur","odorant","offenser","officier","offrir","ogive","oiseau","oisillon","olfactif","olivier","ombrage","omettre","onctueux","onduler","onereux","onirique","opale","opaque","operer","opinion","opportun","opprimer","opter","optique","orageux","orange","orbite","ordonner","oreille","organe","orgueil","orifice","ornement","orque","ortie","osciller","osmose","ossature","otarie","ouragan","ourson","outil","outrager","ouvrage","ovation","oxyde","oxygene","ozone","paisible","palace","palmares","palourde","palper","panache","panda","pangolin","paniquer","panneau","panorama","pantalon","papaye","papier","papoter","papyrus","paradoxe","parcelle","paresse","parfumer","parler","parole","parrain","parsemer","partager","parure","parvenir","passion","pasteque","paternel","patience","patron","pavillon","pavoiser","payer","paysage","peigne","peintre","pelage","pelican","pelle","pelouse","peluche","pendule","penetrer","penible","pensif","penurie","pepite","peplum","perdrix","perforer","periode","permuter","perplexe","persil","perte","peser","petale","petit","petrir","peuple","pharaon","phobie","phoque","photon","phrase","physique","piano","pictural","piece","pierre","pieuvre","pilote","pinceau","pipette","piquer","pirogue","piscine","piston","pivoter","pixel","pizza","placard","plafond","plaisir","planer","plaque","plastron","plateau","pleurer","plexus","pliage","plomb","plonger","pluie","plumage","pochette","poesie","poete","pointe","poirier","poisson","poivre","polaire","policier","pollen","polygone","pommade","pompier","ponctuel","ponderer","poney","portique","position","posseder","posture","potager","poteau","potion","pouce","poulain","poumon","pourpre","poussin","pouvoir","prairie","pratique","precieux","predire","prefixe","prelude","prenom","presence","pretexte","prevoir","primitif","prince","prison","priver","probleme","proceder","prodige","profond","progres","proie","projeter","prologue","promener","propre","prospere","proteger","prouesse","proverbe","prudence","pruneau","psychose","public","puceron","puiser","pulpe","pulsar","punaise","punitif","pupitre","purifier","puzzle","pyramide","quasar","querelle","question","quietude","quitter","quotient","racine","raconter","radieux","ragondin","raideur","raisin","ralentir","rallonge","ramasser","rapide","rasage","ratisser","ravager","ravin","rayonner","reactif","reagir","realiser","reanimer","recevoir","reciter","reclamer","recolter","recruter","reculer","recycler","rediger","redouter","refaire","reflexe","reformer","refrain","refuge","regalien","region","reglage","regulier","reiterer","rejeter","rejouer","relatif","relever","relief","remarque","remede","remise","remonter","remplir","remuer","renard","renfort","renifler","renoncer","rentrer","renvoi","replier","reporter","reprise","reptile","requin","reserve","resineux","resoudre","respect","rester","resultat","retablir","retenir","reticule","retomber","retracer","reunion","reussir","revanche","revivre","revolte","revulsif","richesse","rideau","rieur","rigide","rigoler","rincer","riposter","risible","risque","rituel","rival","riviere","rocheux","romance","rompre","ronce","rondin","roseau","rosier","rotatif","rotor","rotule","rouge","rouille","rouleau","routine","royaume","ruban","rubis","ruche","ruelle","rugueux","ruiner","ruisseau","ruser","rustique","rythme","sabler","saboter","sabre","sacoche","safari","sagesse","saisir","salade","salive","salon","saluer","samedi","sanction","sanglier","sarcasme","sardine","saturer","saugrenu","saumon","sauter","sauvage","savant","savonner","scalpel","scandale","scelerat","scenario","sceptre","schema","science","scinder","score","scrutin","sculpter","seance","secable","secher","secouer","secreter","sedatif","seduire","seigneur","sejour","selectif","semaine","sembler","semence","seminal","senateur","sensible","sentence","separer","sequence","serein","sergent","serieux","serrure","serum","service","sesame","sevir","sevrage","sextuple","sideral","siecle","sieger","siffler","sigle","signal","silence","silicium","simple","sincere","sinistre","siphon","sirop","sismique","situer","skier","social","socle","sodium","soigneux","soldat","soleil","solitude","soluble","sombre","sommeil","somnoler","sonde","songeur","sonnette","sonore","sorcier","sortir","sosie","sottise","soucieux","soudure","souffle","soulever","soupape","source","soutirer","souvenir","spacieux","spatial","special","sphere","spiral","stable","station","sternum","stimulus","stipuler","strict","studieux","stupeur","styliste","sublime","substrat","subtil","subvenir","succes","sucre","suffixe","suggerer","suiveur","sulfate","superbe","supplier","surface","suricate","surmener","surprise","sursaut","survie","suspect","syllabe","symbole","symetrie","synapse","syntaxe","systeme","tabac","tablier","tactile","tailler","talent","talisman","talonner","tambour","tamiser","tangible","tapis","taquiner","tarder","tarif","tartine","tasse","tatami","tatouage","taupe","taureau","taxer","temoin","temporel","tenaille","tendre","teneur","tenir","tension","terminer","terne","terrible","tetine","texte","theme","theorie","therapie","thorax","tibia","tiede","timide","tirelire","tiroir","tissu","titane","titre","tituber","toboggan","tolerant","tomate","tonique","tonneau","toponyme","torche","tordre","tornade","torpille","torrent","torse","tortue","totem","toucher","tournage","tousser","toxine","traction","trafic","tragique","trahir","train","trancher","travail","trefle","tremper","tresor","treuil","triage","tribunal","tricoter","trilogie","triomphe","tripler","triturer","trivial","trombone","tronc","tropical","troupeau","tuile","tulipe","tumulte","tunnel","turbine","tuteur","tutoyer","tuyau","tympan","typhon","typique","tyran","ubuesque","ultime","ultrason","unanime","unifier","union","unique","unitaire","univers","uranium","urbain","urticant","usage","usine","usuel","usure","utile","utopie","vacarme","vaccin","vagabond","vague","vaillant","vaincre","vaisseau","valable","valise","vallon","valve","vampire","vanille","vapeur","varier","vaseux","vassal","vaste","vecteur","vedette","vegetal","vehicule","veinard","veloce","vendredi","venerer","venger","venimeux","ventouse","verdure","verin","vernir","verrou","verser","vertu","veston","veteran","vetuste","vexant","vexer","viaduc","viande","victoire","vidange","video","vignette","vigueur","vilain","village","vinaigre","violon","vipere","virement","virtuose","virus","visage","viseur","vision","visqueux","visuel","vital","vitesse","viticole","vitrine","vivace","vivipare","vocation","voguer","voile","voisin","voiture","volaille","volcan","voltiger","volume","vorace","vortex","voter","vouloir","voyage","voyelle","wagon","xenon","yacht","zebre","zenith","zeste","zoologie"]');
const require$$5 = /* @__PURE__ */ JSON.parse('["abaco","abbaglio","abbinato","abete","abisso","abolire","abrasivo","abrogato","accadere","accenno","accusato","acetone","achille","acido","acqua","acre","acrilico","acrobata","acuto","adagio","addebito","addome","adeguato","aderire","adipe","adottare","adulare","affabile","affetto","affisso","affranto","aforisma","afoso","africano","agave","agente","agevole","aggancio","agire","agitare","agonismo","agricolo","agrumeto","aguzzo","alabarda","alato","albatro","alberato","albo","albume","alce","alcolico","alettone","alfa","algebra","aliante","alibi","alimento","allagato","allegro","allievo","allodola","allusivo","almeno","alogeno","alpaca","alpestre","altalena","alterno","alticcio","altrove","alunno","alveolo","alzare","amalgama","amanita","amarena","ambito","ambrato","ameba","america","ametista","amico","ammasso","ammenda","ammirare","ammonito","amore","ampio","ampliare","amuleto","anacardo","anagrafe","analista","anarchia","anatra","anca","ancella","ancora","andare","andrea","anello","angelo","angolare","angusto","anima","annegare","annidato","anno","annuncio","anonimo","anticipo","anzi","apatico","apertura","apode","apparire","appetito","appoggio","approdo","appunto","aprile","arabica","arachide","aragosta","araldica","arancio","aratura","arazzo","arbitro","archivio","ardito","arenile","argento","argine","arguto","aria","armonia","arnese","arredato","arringa","arrosto","arsenico","arso","artefice","arzillo","asciutto","ascolto","asepsi","asettico","asfalto","asino","asola","aspirato","aspro","assaggio","asse","assoluto","assurdo","asta","astenuto","astice","astratto","atavico","ateismo","atomico","atono","attesa","attivare","attorno","attrito","attuale","ausilio","austria","autista","autonomo","autunno","avanzato","avere","avvenire","avviso","avvolgere","azione","azoto","azzimo","azzurro","babele","baccano","bacino","baco","badessa","badilata","bagnato","baita","balcone","baldo","balena","ballata","balzano","bambino","bandire","baraonda","barbaro","barca","baritono","barlume","barocco","basilico","basso","batosta","battuto","baule","bava","bavosa","becco","beffa","belgio","belva","benda","benevole","benigno","benzina","bere","berlina","beta","bibita","bici","bidone","bifido","biga","bilancia","bimbo","binocolo","biologo","bipede","bipolare","birbante","birra","biscotto","bisesto","bisnonno","bisonte","bisturi","bizzarro","blando","blatta","bollito","bonifico","bordo","bosco","botanico","bottino","bozzolo","braccio","bradipo","brama","branca","bravura","bretella","brevetto","brezza","briglia","brillante","brindare","broccolo","brodo","bronzina","brullo","bruno","bubbone","buca","budino","buffone","buio","bulbo","buono","burlone","burrasca","bussola","busta","cadetto","caduco","calamaro","calcolo","calesse","calibro","calmo","caloria","cambusa","camerata","camicia","cammino","camola","campale","canapa","candela","cane","canino","canotto","cantina","capace","capello","capitolo","capogiro","cappero","capra","capsula","carapace","carcassa","cardo","carisma","carovana","carretto","cartolina","casaccio","cascata","caserma","caso","cassone","castello","casuale","catasta","catena","catrame","cauto","cavillo","cedibile","cedrata","cefalo","celebre","cellulare","cena","cenone","centesimo","ceramica","cercare","certo","cerume","cervello","cesoia","cespo","ceto","chela","chiaro","chicca","chiedere","chimera","china","chirurgo","chitarra","ciao","ciclismo","cifrare","cigno","cilindro","ciottolo","circa","cirrosi","citrico","cittadino","ciuffo","civetta","civile","classico","clinica","cloro","cocco","codardo","codice","coerente","cognome","collare","colmato","colore","colposo","coltivato","colza","coma","cometa","commando","comodo","computer","comune","conciso","condurre","conferma","congelare","coniuge","connesso","conoscere","consumo","continuo","convegno","coperto","copione","coppia","copricapo","corazza","cordata","coricato","cornice","corolla","corpo","corredo","corsia","cortese","cosmico","costante","cottura","covato","cratere","cravatta","creato","credere","cremoso","crescita","creta","criceto","crinale","crisi","critico","croce","cronaca","crostata","cruciale","crusca","cucire","cuculo","cugino","cullato","cupola","curatore","cursore","curvo","cuscino","custode","dado","daino","dalmata","damerino","daniela","dannoso","danzare","datato","davanti","davvero","debutto","decennio","deciso","declino","decollo","decreto","dedicato","definito","deforme","degno","delegare","delfino","delirio","delta","demenza","denotato","dentro","deposito","derapata","derivare","deroga","descritto","deserto","desiderio","desumere","detersivo","devoto","diametro","dicembre","diedro","difeso","diffuso","digerire","digitale","diluvio","dinamico","dinnanzi","dipinto","diploma","dipolo","diradare","dire","dirotto","dirupo","disagio","discreto","disfare","disgelo","disposto","distanza","disumano","dito","divano","divelto","dividere","divorato","doblone","docente","doganale","dogma","dolce","domato","domenica","dominare","dondolo","dono","dormire","dote","dottore","dovuto","dozzina","drago","druido","dubbio","dubitare","ducale","duna","duomo","duplice","duraturo","ebano","eccesso","ecco","eclissi","economia","edera","edicola","edile","editoria","educare","egemonia","egli","egoismo","egregio","elaborato","elargire","elegante","elencato","eletto","elevare","elfico","elica","elmo","elsa","eluso","emanato","emblema","emesso","emiro","emotivo","emozione","empirico","emulo","endemico","enduro","energia","enfasi","enoteca","entrare","enzima","epatite","epilogo","episodio","epocale","eppure","equatore","erario","erba","erboso","erede","eremita","erigere","ermetico","eroe","erosivo","errante","esagono","esame","esanime","esaudire","esca","esempio","esercito","esibito","esigente","esistere","esito","esofago","esortato","esoso","espanso","espresso","essenza","esso","esteso","estimare","estonia","estroso","esultare","etilico","etnico","etrusco","etto","euclideo","europa","evaso","evidenza","evitato","evoluto","evviva","fabbrica","faccenda","fachiro","falco","famiglia","fanale","fanfara","fango","fantasma","fare","farfalla","farinoso","farmaco","fascia","fastoso","fasullo","faticare","fato","favoloso","febbre","fecola","fede","fegato","felpa","feltro","femmina","fendere","fenomeno","fermento","ferro","fertile","fessura","festivo","fetta","feudo","fiaba","fiducia","fifa","figurato","filo","finanza","finestra","finire","fiore","fiscale","fisico","fiume","flacone","flamenco","flebo","flemma","florido","fluente","fluoro","fobico","focaccia","focoso","foderato","foglio","folata","folclore","folgore","fondente","fonetico","fonia","fontana","forbito","forchetta","foresta","formica","fornaio","foro","fortezza","forzare","fosfato","fosso","fracasso","frana","frassino","fratello","freccetta","frenata","fresco","frigo","frollino","fronde","frugale","frutta","fucilata","fucsia","fuggente","fulmine","fulvo","fumante","fumetto","fumoso","fune","funzione","fuoco","furbo","furgone","furore","fuso","futile","gabbiano","gaffe","galateo","gallina","galoppo","gambero","gamma","garanzia","garbo","garofano","garzone","gasdotto","gasolio","gastrico","gatto","gaudio","gazebo","gazzella","geco","gelatina","gelso","gemello","gemmato","gene","genitore","gennaio","genotipo","gergo","ghepardo","ghiaccio","ghisa","giallo","gilda","ginepro","giocare","gioiello","giorno","giove","girato","girone","gittata","giudizio","giurato","giusto","globulo","glutine","gnomo","gobba","golf","gomito","gommone","gonfio","gonna","governo","gracile","grado","grafico","grammo","grande","grattare","gravoso","grazia","greca","gregge","grifone","grigio","grinza","grotta","gruppo","guadagno","guaio","guanto","guardare","gufo","guidare","ibernato","icona","identico","idillio","idolo","idra","idrico","idrogeno","igiene","ignaro","ignorato","ilare","illeso","illogico","illudere","imballo","imbevuto","imbocco","imbuto","immane","immerso","immolato","impacco","impeto","impiego","importo","impronta","inalare","inarcare","inattivo","incanto","incendio","inchino","incisivo","incluso","incontro","incrocio","incubo","indagine","india","indole","inedito","infatti","infilare","inflitto","ingaggio","ingegno","inglese","ingordo","ingrosso","innesco","inodore","inoltrare","inondato","insano","insetto","insieme","insonnia","insulina","intasato","intero","intonaco","intuito","inumidire","invalido","invece","invito","iperbole","ipnotico","ipotesi","ippica","iride","irlanda","ironico","irrigato","irrorare","isolato","isotopo","isterico","istituto","istrice","italia","iterare","labbro","labirinto","lacca","lacerato","lacrima","lacuna","laddove","lago","lampo","lancetta","lanterna","lardoso","larga","laringe","lastra","latenza","latino","lattuga","lavagna","lavoro","legale","leggero","lembo","lentezza","lenza","leone","lepre","lesivo","lessato","lesto","letterale","leva","levigato","libero","lido","lievito","lilla","limatura","limitare","limpido","lineare","lingua","liquido","lira","lirica","lisca","lite","litigio","livrea","locanda","lode","logica","lombare","londra","longevo","loquace","lorenzo","loto","lotteria","luce","lucidato","lumaca","luminoso","lungo","lupo","luppolo","lusinga","lusso","lutto","macabro","macchina","macero","macinato","madama","magico","maglia","magnete","magro","maiolica","malafede","malgrado","malinteso","malsano","malto","malumore","mana","mancia","mandorla","mangiare","manifesto","mannaro","manovra","mansarda","mantide","manubrio","mappa","maratona","marcire","maretta","marmo","marsupio","maschera","massaia","mastino","materasso","matricola","mattone","maturo","mazurca","meandro","meccanico","mecenate","medesimo","meditare","mega","melassa","melis","melodia","meninge","meno","mensola","mercurio","merenda","merlo","meschino","mese","messere","mestolo","metallo","metodo","mettere","miagolare","mica","micelio","michele","microbo","midollo","miele","migliore","milano","milite","mimosa","minerale","mini","minore","mirino","mirtillo","miscela","missiva","misto","misurare","mitezza","mitigare","mitra","mittente","mnemonico","modello","modifica","modulo","mogano","mogio","mole","molosso","monastero","monco","mondina","monetario","monile","monotono","monsone","montato","monviso","mora","mordere","morsicato","mostro","motivato","motosega","motto","movenza","movimento","mozzo","mucca","mucosa","muffa","mughetto","mugnaio","mulatto","mulinello","multiplo","mummia","munto","muovere","murale","musa","muscolo","musica","mutevole","muto","nababbo","nafta","nanometro","narciso","narice","narrato","nascere","nastrare","naturale","nautica","naviglio","nebulosa","necrosi","negativo","negozio","nemmeno","neofita","neretto","nervo","nessuno","nettuno","neutrale","neve","nevrotico","nicchia","ninfa","nitido","nobile","nocivo","nodo","nome","nomina","nordico","normale","norvegese","nostrano","notare","notizia","notturno","novella","nucleo","nulla","numero","nuovo","nutrire","nuvola","nuziale","oasi","obbedire","obbligo","obelisco","oblio","obolo","obsoleto","occasione","occhio","occidente","occorrere","occultare","ocra","oculato","odierno","odorare","offerta","offrire","offuscato","oggetto","oggi","ognuno","olandese","olfatto","oliato","oliva","ologramma","oltre","omaggio","ombelico","ombra","omega","omissione","ondoso","onere","onice","onnivoro","onorevole","onta","operato","opinione","opposto","oracolo","orafo","ordine","orecchino","orefice","orfano","organico","origine","orizzonte","orma","ormeggio","ornativo","orologio","orrendo","orribile","ortensia","ortica","orzata","orzo","osare","oscurare","osmosi","ospedale","ospite","ossa","ossidare","ostacolo","oste","otite","otre","ottagono","ottimo","ottobre","ovale","ovest","ovino","oviparo","ovocito","ovunque","ovviare","ozio","pacchetto","pace","pacifico","padella","padrone","paese","paga","pagina","palazzina","palesare","pallido","palo","palude","pandoro","pannello","paolo","paonazzo","paprica","parabola","parcella","parere","pargolo","pari","parlato","parola","partire","parvenza","parziale","passivo","pasticca","patacca","patologia","pattume","pavone","peccato","pedalare","pedonale","peggio","peloso","penare","pendice","penisola","pennuto","penombra","pensare","pentola","pepe","pepita","perbene","percorso","perdonato","perforare","pergamena","periodo","permesso","perno","perplesso","persuaso","pertugio","pervaso","pesatore","pesista","peso","pestifero","petalo","pettine","petulante","pezzo","piacere","pianta","piattino","piccino","picozza","piega","pietra","piffero","pigiama","pigolio","pigro","pila","pilifero","pillola","pilota","pimpante","pineta","pinna","pinolo","pioggia","piombo","piramide","piretico","pirite","pirolisi","pitone","pizzico","placebo","planare","plasma","platano","plenario","pochezza","poderoso","podismo","poesia","poggiare","polenta","poligono","pollice","polmonite","polpetta","polso","poltrona","polvere","pomice","pomodoro","ponte","popoloso","porfido","poroso","porpora","porre","portata","posa","positivo","possesso","postulato","potassio","potere","pranzo","prassi","pratica","precluso","predica","prefisso","pregiato","prelievo","premere","prenotare","preparato","presenza","pretesto","prevalso","prima","principe","privato","problema","procura","produrre","profumo","progetto","prolunga","promessa","pronome","proposta","proroga","proteso","prova","prudente","prugna","prurito","psiche","pubblico","pudica","pugilato","pugno","pulce","pulito","pulsante","puntare","pupazzo","pupilla","puro","quadro","qualcosa","quasi","querela","quota","raccolto","raddoppio","radicale","radunato","raffica","ragazzo","ragione","ragno","ramarro","ramingo","ramo","randagio","rantolare","rapato","rapina","rappreso","rasatura","raschiato","rasente","rassegna","rastrello","rata","ravveduto","reale","recepire","recinto","recluta","recondito","recupero","reddito","redimere","regalato","registro","regola","regresso","relazione","remare","remoto","renna","replica","reprimere","reputare","resa","residente","responso","restauro","rete","retina","retorica","rettifica","revocato","riassunto","ribadire","ribelle","ribrezzo","ricarica","ricco","ricevere","riciclato","ricordo","ricreduto","ridicolo","ridurre","rifasare","riflesso","riforma","rifugio","rigare","rigettato","righello","rilassato","rilevato","rimanere","rimbalzo","rimedio","rimorchio","rinascita","rincaro","rinforzo","rinnovo","rinomato","rinsavito","rintocco","rinuncia","rinvenire","riparato","ripetuto","ripieno","riportare","ripresa","ripulire","risata","rischio","riserva","risibile","riso","rispetto","ristoro","risultato","risvolto","ritardo","ritegno","ritmico","ritrovo","riunione","riva","riverso","rivincita","rivolto","rizoma","roba","robotico","robusto","roccia","roco","rodaggio","rodere","roditore","rogito","rollio","romantico","rompere","ronzio","rosolare","rospo","rotante","rotondo","rotula","rovescio","rubizzo","rubrica","ruga","rullino","rumine","rumoroso","ruolo","rupe","russare","rustico","sabato","sabbiare","sabotato","sagoma","salasso","saldatura","salgemma","salivare","salmone","salone","saltare","saluto","salvo","sapere","sapido","saporito","saraceno","sarcasmo","sarto","sassoso","satellite","satira","satollo","saturno","savana","savio","saziato","sbadiglio","sbalzo","sbancato","sbarra","sbattere","sbavare","sbendare","sbirciare","sbloccato","sbocciato","sbrinare","sbruffone","sbuffare","scabroso","scadenza","scala","scambiare","scandalo","scapola","scarso","scatenare","scavato","scelto","scenico","scettro","scheda","schiena","sciarpa","scienza","scindere","scippo","sciroppo","scivolo","sclerare","scodella","scolpito","scomparto","sconforto","scoprire","scorta","scossone","scozzese","scriba","scrollare","scrutinio","scuderia","scultore","scuola","scuro","scusare","sdebitare","sdoganare","seccatura","secondo","sedano","seggiola","segnalato","segregato","seguito","selciato","selettivo","sella","selvaggio","semaforo","sembrare","seme","seminato","sempre","senso","sentire","sepolto","sequenza","serata","serbato","sereno","serio","serpente","serraglio","servire","sestina","setola","settimana","sfacelo","sfaldare","sfamato","sfarzoso","sfaticato","sfera","sfida","sfilato","sfinge","sfocato","sfoderare","sfogo","sfoltire","sforzato","sfratto","sfruttato","sfuggito","sfumare","sfuso","sgabello","sgarbato","sgonfiare","sgorbio","sgrassato","sguardo","sibilo","siccome","sierra","sigla","signore","silenzio","sillaba","simbolo","simpatico","simulato","sinfonia","singolo","sinistro","sino","sintesi","sinusoide","sipario","sisma","sistole","situato","slitta","slogatura","sloveno","smarrito","smemorato","smentito","smeraldo","smilzo","smontare","smottato","smussato","snellire","snervato","snodo","sobbalzo","sobrio","soccorso","sociale","sodale","soffitto","sogno","soldato","solenne","solido","sollazzo","solo","solubile","solvente","somatico","somma","sonda","sonetto","sonnifero","sopire","soppeso","sopra","sorgere","sorpasso","sorriso","sorso","sorteggio","sorvolato","sospiro","sosta","sottile","spada","spalla","spargere","spatola","spavento","spazzola","specie","spedire","spegnere","spelatura","speranza","spessore","spettrale","spezzato","spia","spigoloso","spillato","spinoso","spirale","splendido","sportivo","sposo","spranga","sprecare","spronato","spruzzo","spuntino","squillo","sradicare","srotolato","stabile","stacco","staffa","stagnare","stampato","stantio","starnuto","stasera","statuto","stelo","steppa","sterzo","stiletto","stima","stirpe","stivale","stizzoso","stonato","storico","strappo","stregato","stridulo","strozzare","strutto","stuccare","stufo","stupendo","subentro","succoso","sudore","suggerito","sugo","sultano","suonare","superbo","supporto","surgelato","surrogato","sussurro","sutura","svagare","svedese","sveglio","svelare","svenuto","svezia","sviluppo","svista","svizzera","svolta","svuotare","tabacco","tabulato","tacciare","taciturno","tale","talismano","tampone","tannino","tara","tardivo","targato","tariffa","tarpare","tartaruga","tasto","tattico","taverna","tavolata","tazza","teca","tecnico","telefono","temerario","tempo","temuto","tendone","tenero","tensione","tentacolo","teorema","terme","terrazzo","terzetto","tesi","tesserato","testato","tetro","tettoia","tifare","tigella","timbro","tinto","tipico","tipografo","tiraggio","tiro","titanio","titolo","titubante","tizio","tizzone","toccare","tollerare","tolto","tombola","tomo","tonfo","tonsilla","topazio","topologia","toppa","torba","tornare","torrone","tortora","toscano","tossire","tostatura","totano","trabocco","trachea","trafila","tragedia","tralcio","tramonto","transito","trapano","trarre","trasloco","trattato","trave","treccia","tremolio","trespolo","tributo","tricheco","trifoglio","trillo","trincea","trio","tristezza","triturato","trivella","tromba","trono","troppo","trottola","trovare","truccato","tubatura","tuffato","tulipano","tumulto","tunisia","turbare","turchino","tuta","tutela","ubicato","uccello","uccisore","udire","uditivo","uffa","ufficio","uguale","ulisse","ultimato","umano","umile","umorismo","uncinetto","ungere","ungherese","unicorno","unificato","unisono","unitario","unte","uovo","upupa","uragano","urgenza","urlo","usanza","usato","uscito","usignolo","usuraio","utensile","utilizzo","utopia","vacante","vaccinato","vagabondo","vagliato","valanga","valgo","valico","valletta","valoroso","valutare","valvola","vampata","vangare","vanitoso","vano","vantaggio","vanvera","vapore","varano","varcato","variante","vasca","vedetta","vedova","veduto","vegetale","veicolo","velcro","velina","velluto","veloce","venato","vendemmia","vento","verace","verbale","vergogna","verifica","vero","verruca","verticale","vescica","vessillo","vestale","veterano","vetrina","vetusto","viandante","vibrante","vicenda","vichingo","vicinanza","vidimare","vigilia","vigneto","vigore","vile","villano","vimini","vincitore","viola","vipera","virgola","virologo","virulento","viscoso","visione","vispo","vissuto","visura","vita","vitello","vittima","vivanda","vivido","viziare","voce","voga","volatile","volere","volpe","voragine","vulcano","zampogna","zanna","zappato","zattera","zavorra","zefiro","zelante","zelo","zenzero","zerbino","zibetto","zinco","zircone","zitto","zolla","zotico","zucchero","zufolo","zulu","zuppa"]');
const require$$6 = /* @__PURE__ */ JSON.parse('["abaco","abdomen","abeja","abierto","abogado","abono","aborto","abrazo","abrir","abuelo","abuso","acabar","academia","acceso","accion","aceite","acelga","acento","aceptar","acido","aclarar","acne","acoger","acoso","activo","acto","actriz","actuar","acudir","acuerdo","acusar","adicto","admitir","adoptar","adorno","aduana","adulto","aereo","afectar","aficion","afinar","afirmar","agil","agitar","agonia","agosto","agotar","agregar","agrio","agua","agudo","aguila","aguja","ahogo","ahorro","aire","aislar","ajedrez","ajeno","ajuste","alacran","alambre","alarma","alba","album","alcalde","aldea","alegre","alejar","alerta","aleta","alfiler","alga","algodon","aliado","aliento","alivio","alma","almeja","almibar","altar","alteza","altivo","alto","altura","alumno","alzar","amable","amante","amapola","amargo","amasar","ambar","ambito","ameno","amigo","amistad","amor","amparo","amplio","ancho","anciano","ancla","andar","anden","anemia","angulo","anillo","animo","anis","anotar","antena","antiguo","antojo","anual","anular","anuncio","anadir","anejo","ano","apagar","aparato","apetito","apio","aplicar","apodo","aporte","apoyo","aprender","aprobar","apuesta","apuro","arado","arana","arar","arbitro","arbol","arbusto","archivo","arco","arder","ardilla","arduo","area","arido","aries","armonia","arnes","aroma","arpa","arpon","arreglo","arroz","arruga","arte","artista","asa","asado","asalto","ascenso","asegurar","aseo","asesor","asiento","asilo","asistir","asno","asombro","aspero","astilla","astro","astuto","asumir","asunto","atajo","ataque","atar","atento","ateo","atico","atleta","atomo","atraer","atroz","atun","audaz","audio","auge","aula","aumento","ausente","autor","aval","avance","avaro","ave","avellana","avena","avestruz","avion","aviso","ayer","ayuda","ayuno","azafran","azar","azote","azucar","azufre","azul","baba","babor","bache","bahia","baile","bajar","balanza","balcon","balde","bambu","banco","banda","bano","barba","barco","barniz","barro","bascula","baston","basura","batalla","bateria","batir","batuta","baul","bazar","bebe","bebida","bello","besar","beso","bestia","bicho","bien","bingo","blanco","bloque","blusa","boa","bobina","bobo","boca","bocina","boda","bodega","boina","bola","bolero","bolsa","bomba","bondad","bonito","bono","bonsai","borde","borrar","bosque","bote","botin","boveda","bozal","bravo","brazo","brecha","breve","brillo","brinco","brisa","broca","broma","bronce","brote","bruja","brusco","bruto","buceo","bucle","bueno","buey","bufanda","bufon","buho","buitre","bulto","burbuja","burla","burro","buscar","butaca","buzon","caballo","cabeza","cabina","cabra","cacao","cadaver","cadena","caer","cafe","caida","caiman","caja","cajon","cal","calamar","calcio","caldo","calidad","calle","calma","calor","calvo","cama","cambio","camello","camino","campo","cancer","candil","canela","canguro","canica","canto","cana","canon","caoba","caos","capaz","capitan","capote","captar","capucha","cara","carbon","carcel","careta","carga","carino","carne","carpeta","carro","carta","casa","casco","casero","caspa","castor","catorce","catre","caudal","causa","cazo","cebolla","ceder","cedro","celda","celebre","celoso","celula","cemento","ceniza","centro","cerca","cerdo","cereza","cero","cerrar","certeza","cesped","cetro","chacal","chaleco","champu","chancla","chapa","charla","chico","chiste","chivo","choque","choza","chuleta","chupar","ciclon","ciego","cielo","cien","cierto","cifra","cigarro","cima","cinco","cine","cinta","cipres","circo","ciruela","cisne","cita","ciudad","clamor","clan","claro","clase","clave","cliente","clima","clinica","cobre","coccion","cochino","cocina","coco","codigo","codo","cofre","coger","cohete","cojin","cojo","cola","colcha","colegio","colgar","colina","collar","colmo","columna","combate","comer","comida","comodo","compra","conde","conejo","conga","conocer","consejo","contar","copa","copia","corazon","corbata","corcho","cordon","corona","correr","coser","cosmos","costa","craneo","crater","crear","crecer","creido","crema","cria","crimen","cripta","crisis","cromo","cronica","croqueta","crudo","cruz","cuadro","cuarto","cuatro","cubo","cubrir","cuchara","cuello","cuento","cuerda","cuesta","cueva","cuidar","culebra","culpa","culto","cumbre","cumplir","cuna","cuneta","cuota","cupon","cupula","curar","curioso","curso","curva","cutis","dama","danza","dar","dardo","datil","deber","debil","decada","decir","dedo","defensa","definir","dejar","delfin","delgado","delito","demora","denso","dental","deporte","derecho","derrota","desayuno","deseo","desfile","desnudo","destino","desvio","detalle","detener","deuda","dia","diablo","diadema","diamante","diana","diario","dibujo","dictar","diente","dieta","diez","dificil","digno","dilema","diluir","dinero","directo","dirigir","disco","diseno","disfraz","diva","divino","doble","doce","dolor","domingo","don","donar","dorado","dormir","dorso","dos","dosis","dragon","droga","ducha","duda","duelo","dueno","dulce","duo","duque","durar","dureza","duro","ebano","ebrio","echar","eco","ecuador","edad","edicion","edificio","editor","educar","efecto","eficaz","eje","ejemplo","elefante","elegir","elemento","elevar","elipse","elite","elixir","elogio","eludir","embudo","emitir","emocion","empate","empeno","empleo","empresa","enano","encargo","enchufe","encia","enemigo","enero","enfado","enfermo","engano","enigma","enlace","enorme","enredo","ensayo","ensenar","entero","entrar","envase","envio","epoca","equipo","erizo","escala","escena","escolar","escribir","escudo","esencia","esfera","esfuerzo","espada","espejo","espia","esposa","espuma","esqui","estar","este","estilo","estufa","etapa","eterno","etica","etnia","evadir","evaluar","evento","evitar","exacto","examen","exceso","excusa","exento","exigir","exilio","existir","exito","experto","explicar","exponer","extremo","fabrica","fabula","fachada","facil","factor","faena","faja","falda","fallo","falso","faltar","fama","familia","famoso","faraon","farmacia","farol","farsa","fase","fatiga","fauna","favor","fax","febrero","fecha","feliz","feo","feria","feroz","fertil","fervor","festin","fiable","fianza","fiar","fibra","ficcion","ficha","fideo","fiebre","fiel","fiera","fiesta","figura","fijar","fijo","fila","filete","filial","filtro","fin","finca","fingir","finito","firma","flaco","flauta","flecha","flor","flota","fluir","flujo","fluor","fobia","foca","fogata","fogon","folio","folleto","fondo","forma","forro","fortuna","forzar","fosa","foto","fracaso","fragil","franja","frase","fraude","freir","freno","fresa","frio","frito","fruta","fuego","fuente","fuerza","fuga","fumar","funcion","funda","furgon","furia","fusil","futbol","futuro","gacela","gafas","gaita","gajo","gala","galeria","gallo","gamba","ganar","gancho","ganga","ganso","garaje","garza","gasolina","gastar","gato","gavilan","gemelo","gemir","gen","genero","genio","gente","geranio","gerente","germen","gesto","gigante","gimnasio","girar","giro","glaciar","globo","gloria","gol","golfo","goloso","golpe","goma","gordo","gorila","gorra","gota","goteo","gozar","grada","grafico","grano","grasa","gratis","grave","grieta","grillo","gripe","gris","grito","grosor","grua","grueso","grumo","grupo","guante","guapo","guardia","guerra","guia","guino","guion","guiso","guitarra","gusano","gustar","haber","habil","hablar","hacer","hacha","hada","hallar","hamaca","harina","haz","hazana","hebilla","hebra","hecho","helado","helio","hembra","herir","hermano","heroe","hervir","hielo","hierro","higado","higiene","hijo","himno","historia","hocico","hogar","hoguera","hoja","hombre","hongo","honor","honra","hora","hormiga","horno","hostil","hoyo","hueco","huelga","huerta","hueso","huevo","huida","huir","humano","humedo","humilde","humo","hundir","huracan","hurto","icono","ideal","idioma","idolo","iglesia","iglu","igual","ilegal","ilusion","imagen","iman","imitar","impar","imperio","imponer","impulso","incapaz","indice","inerte","infiel","informe","ingenio","inicio","inmenso","inmune","innato","insecto","instante","interes","intimo","intuir","inutil","invierno","ira","iris","ironia","isla","islote","jabali","jabon","jamon","jarabe","jardin","jarra","jaula","jazmin","jefe","jeringa","jinete","jornada","joroba","joven","joya","juerga","jueves","juez","jugador","jugo","juguete","juicio","junco","jungla","junio","juntar","jupiter","jurar","justo","juvenil","juzgar","kilo","koala","labio","lacio","lacra","lado","ladron","lagarto","lagrima","laguna","laico","lamer","lamina","lampara","lana","lancha","langosta","lanza","lapiz","largo","larva","lastima","lata","latex","latir","laurel","lavar","lazo","leal","leccion","leche","lector","leer","legion","legumbre","lejano","lengua","lento","lena","leon","leopardo","lesion","letal","letra","leve","leyenda","libertad","libro","licor","lider","lidiar","lienzo","liga","ligero","lima","limite","limon","limpio","lince","lindo","linea","lingote","lino","linterna","liquido","liso","lista","litera","litio","litro","llaga","llama","llanto","llave","llegar","llenar","llevar","llorar","llover","lluvia","lobo","locion","loco","locura","logica","logro","lombriz","lomo","lonja","lote","lucha","lucir","lugar","lujo","luna","lunes","lupa","lustro","luto","luz","maceta","macho","madera","madre","maduro","maestro","mafia","magia","mago","maiz","maldad","maleta","malla","malo","mama","mambo","mamut","manco","mando","manejar","manga","maniqui","manjar","mano","manso","manta","manana","mapa","maquina","mar","marco","marea","marfil","margen","marido","marmol","marron","martes","marzo","masa","mascara","masivo","matar","materia","matiz","matriz","maximo","mayor","mazorca","mecha","medalla","medio","medula","mejilla","mejor","melena","melon","memoria","menor","mensaje","mente","menu","mercado","merengue","merito","mes","meson","meta","meter","metodo","metro","mezcla","miedo","miel","miembro","miga","mil","milagro","militar","millon","mimo","mina","minero","minimo","minuto","miope","mirar","misa","miseria","misil","mismo","mitad","mito","mochila","mocion","moda","modelo","moho","mojar","molde","moler","molino","momento","momia","monarca","moneda","monja","monto","mono","morada","morder","moreno","morir","morro","morsa","mortal","mosca","mostrar","motivo","mover","movil","mozo","mucho","mudar","mueble","muela","muerte","muestra","mugre","mujer","mula","muleta","multa","mundo","muneca","mural","muro","musculo","museo","musgo","musica","muslo","nacar","nacion","nadar","naipe","naranja","nariz","narrar","nasal","natal","nativo","natural","nausea","naval","nave","navidad","necio","nectar","negar","negocio","negro","neon","nervio","neto","neutro","nevar","nevera","nicho","nido","niebla","nieto","ninez","nino","nitido","nivel","nobleza","noche","nomina","noria","norma","norte","nota","noticia","novato","novela","novio","nube","nuca","nucleo","nudillo","nudo","nuera","nueve","nuez","nulo","numero","nutria","oasis","obeso","obispo","objeto","obra","obrero","observar","obtener","obvio","oca","ocaso","oceano","ochenta","ocho","ocio","ocre","octavo","octubre","oculto","ocupar","ocurrir","odiar","odio","odisea","oeste","ofensa","oferta","oficio","ofrecer","ogro","oido","oir","ojo","ola","oleada","olfato","olivo","olla","olmo","olor","olvido","ombligo","onda","onza","opaco","opcion","opera","opinar","oponer","optar","optica","opuesto","oracion","orador","oral","orbita","orca","orden","oreja","organo","orgia","orgullo","oriente","origen","orilla","oro","orquesta","oruga","osadia","oscuro","osezno","oso","ostra","otono","otro","oveja","ovulo","oxido","oxigeno","oyente","ozono","pacto","padre","paella","pagina","pago","pais","pajaro","palabra","palco","paleta","palido","palma","paloma","palpar","pan","panal","panico","pantera","panuelo","papa","papel","papilla","paquete","parar","parcela","pared","parir","paro","parpado","parque","parrafo","parte","pasar","paseo","pasion","paso","pasta","pata","patio","patria","pausa","pauta","pavo","payaso","peaton","pecado","pecera","pecho","pedal","pedir","pegar","peine","pelar","peldano","pelea","peligro","pellejo","pelo","peluca","pena","pensar","penon","peon","peor","pepino","pequeno","pera","percha","perder","pereza","perfil","perico","perla","permiso","perro","persona","pesa","pesca","pesimo","pestana","petalo","petroleo","pez","pezuna","picar","pichon","pie","piedra","pierna","pieza","pijama","pilar","piloto","pimienta","pino","pintor","pinza","pina","piojo","pipa","pirata","pisar","piscina","piso","pista","piton","pizca","placa","plan","plata","playa","plaza","pleito","pleno","plomo","pluma","plural","pobre","poco","poder","podio","poema","poesia","poeta","polen","policia","pollo","polvo","pomada","pomelo","pomo","pompa","poner","porcion","portal","posada","poseer","posible","poste","potencia","potro","pozo","prado","precoz","pregunta","premio","prensa","preso","previo","primo","principe","prision","privar","proa","probar","proceso","producto","proeza","profesor","programa","prole","promesa","pronto","propio","proximo","prueba","publico","puchero","pudor","pueblo","puerta","puesto","pulga","pulir","pulmon","pulpo","pulso","puma","punto","punal","puno","pupa","pupila","pure","quedar","queja","quemar","querer","queso","quieto","quimica","quince","quitar","rabano","rabia","rabo","racion","radical","raiz","rama","rampa","rancho","rango","rapaz","rapido","rapto","rasgo","raspa","rato","rayo","raza","razon","reaccion","realidad","rebano","rebote","recaer","receta","rechazo","recoger","recreo","recto","recurso","red","redondo","reducir","reflejo","reforma","refran","refugio","regalo","regir","regla","regreso","rehen","reino","reir","reja","relato","relevo","relieve","relleno","reloj","remar","remedio","remo","rencor","rendir","renta","reparto","repetir","reposo","reptil","res","rescate","resina","respeto","resto","resumen","retiro","retorno","retrato","reunir","reves","revista","rey","rezar","rico","riego","rienda","riesgo","rifa","rigido","rigor","rincon","rinon","rio","riqueza","risa","ritmo","rito","rizo","roble","roce","rociar","rodar","rodeo","rodilla","roer","rojizo","rojo","romero","romper","ron","ronco","ronda","ropa","ropero","rosa","rosca","rostro","rotar","rubi","rubor","rudo","rueda","rugir","ruido","ruina","ruleta","rulo","rumbo","rumor","ruptura","ruta","rutina","sabado","saber","sabio","sable","sacar","sagaz","sagrado","sala","saldo","salero","salir","salmon","salon","salsa","salto","salud","salvar","samba","sancion","sandia","sanear","sangre","sanidad","sano","santo","sapo","saque","sardina","sarten","sastre","satan","sauna","saxofon","seccion","seco","secreto","secta","sed","seguir","seis","sello","selva","semana","semilla","senda","sensor","senal","senor","separar","sepia","sequia","ser","serie","sermon","servir","sesenta","sesion","seta","setenta","severo","sexo","sexto","sidra","siesta","siete","siglo","signo","silaba","silbar","silencio","silla","simbolo","simio","sirena","sistema","sitio","situar","sobre","socio","sodio","sol","solapa","soldado","soledad","solido","soltar","solucion","sombra","sondeo","sonido","sonoro","sonrisa","sopa","soplar","soporte","sordo","sorpresa","sorteo","sosten","sotano","suave","subir","suceso","sudor","suegra","suelo","sueno","suerte","sufrir","sujeto","sultan","sumar","superar","suplir","suponer","supremo","sur","surco","sureno","surgir","susto","sutil","tabaco","tabique","tabla","tabu","taco","tacto","tajo","talar","talco","talento","talla","talon","tamano","tambor","tango","tanque","tapa","tapete","tapia","tapon","taquilla","tarde","tarea","tarifa","tarjeta","tarot","tarro","tarta","tatuaje","tauro","taza","tazon","teatro","techo","tecla","tecnica","tejado","tejer","tejido","tela","telefono","tema","temor","templo","tenaz","tender","tener","tenis","tenso","teoria","terapia","terco","termino","ternura","terror","tesis","tesoro","testigo","tetera","texto","tez","tibio","tiburon","tiempo","tienda","tierra","tieso","tigre","tijera","tilde","timbre","timido","timo","tinta","tio","tipico","tipo","tira","tiron","titan","titere","titulo","tiza","toalla","tobillo","tocar","tocino","todo","toga","toldo","tomar","tono","tonto","topar","tope","toque","torax","torero","tormenta","torneo","toro","torpedo","torre","torso","tortuga","tos","tosco","toser","toxico","trabajo","tractor","traer","trafico","trago","traje","tramo","trance","trato","trauma","trazar","trebol","tregua","treinta","tren","trepar","tres","tribu","trigo","tripa","triste","triunfo","trofeo","trompa","tronco","tropa","trote","trozo","truco","trueno","trufa","tuberia","tubo","tuerto","tumba","tumor","tunel","tunica","turbina","turismo","turno","tutor","ubicar","ulcera","umbral","unidad","unir","universo","uno","untar","una","urbano","urbe","urgente","urna","usar","usuario","util","utopia","uva","vaca","vacio","vacuna","vagar","vago","vaina","vajilla","vale","valido","valle","valor","valvula","vampiro","vara","variar","varon","vaso","vecino","vector","vehiculo","veinte","vejez","vela","velero","veloz","vena","vencer","venda","veneno","vengar","venir","venta","venus","ver","verano","verbo","verde","vereda","verja","verso","verter","via","viaje","vibrar","vicio","victima","vida","video","vidrio","viejo","viernes","vigor","vil","villa","vinagre","vino","vinedo","violin","viral","virgo","virtud","visor","vispera","vista","vitamina","viudo","vivaz","vivero","vivir","vivo","volcan","volumen","volver","voraz","votar","voto","voz","vuelo","vulgar","yacer","yate","yegua","yema","yerno","yeso","yodo","yoga","yogur","zafiro","zanja","zapato","zarza","zona","zorro","zumo","zurdo"]');
const require$$7 = /* @__PURE__ */ JSON.parse('["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""]');
const require$$8 = /* @__PURE__ */ JSON.parse('["abacate","abaixo","abalar","abater","abduzir","abelha","aberto","abismo","abotoar","abranger","abreviar","abrigar","abrupto","absinto","absoluto","absurdo","abutre","acabado","acalmar","acampar","acanhar","acaso","aceitar","acelerar","acenar","acervo","acessar","acetona","achatar","acidez","acima","acionado","acirrar","aclamar","aclive","acolhida","acomodar","acoplar","acordar","acumular","acusador","adaptar","adega","adentro","adepto","adequar","aderente","adesivo","adeus","adiante","aditivo","adjetivo","adjunto","admirar","adorar","adquirir","adubo","adverso","advogado","aeronave","afastar","aferir","afetivo","afinador","afivelar","aflito","afluente","afrontar","agachar","agarrar","agasalho","agenciar","agilizar","agiota","agitado","agora","agradar","agreste","agrupar","aguardar","agulha","ajoelhar","ajudar","ajustar","alameda","alarme","alastrar","alavanca","albergue","albino","alcatra","aldeia","alecrim","alegria","alertar","alface","alfinete","algum","alheio","aliar","alicate","alienar","alinhar","aliviar","almofada","alocar","alpiste","alterar","altitude","alucinar","alugar","aluno","alusivo","alvo","amaciar","amador","amarelo","amassar","ambas","ambiente","ameixa","amenizar","amido","amistoso","amizade","amolador","amontoar","amoroso","amostra","amparar","ampliar","ampola","anagrama","analisar","anarquia","anatomia","andaime","anel","anexo","angular","animar","anjo","anomalia","anotado","ansioso","anterior","anuidade","anunciar","anzol","apagador","apalpar","apanhado","apego","apelido","apertada","apesar","apetite","apito","aplauso","aplicada","apoio","apontar","aposta","aprendiz","aprovar","aquecer","arame","aranha","arara","arcada","ardente","areia","arejar","arenito","aresta","argiloso","argola","arma","arquivo","arraial","arrebate","arriscar","arroba","arrumar","arsenal","arterial","artigo","arvoredo","asfaltar","asilado","aspirar","assador","assinar","assoalho","assunto","astral","atacado","atadura","atalho","atarefar","atear","atender","aterro","ateu","atingir","atirador","ativo","atoleiro","atracar","atrevido","atriz","atual","atum","auditor","aumentar","aura","aurora","autismo","autoria","autuar","avaliar","avante","avaria","avental","avesso","aviador","avisar","avulso","axila","azarar","azedo","azeite","azulejo","babar","babosa","bacalhau","bacharel","bacia","bagagem","baiano","bailar","baioneta","bairro","baixista","bajular","baleia","baliza","balsa","banal","bandeira","banho","banir","banquete","barato","barbado","baronesa","barraca","barulho","baseado","bastante","batata","batedor","batida","batom","batucar","baunilha","beber","beijo","beirada","beisebol","beldade","beleza","belga","beliscar","bendito","bengala","benzer","berimbau","berlinda","berro","besouro","bexiga","bezerro","bico","bicudo","bienal","bifocal","bifurcar","bigorna","bilhete","bimestre","bimotor","biologia","biombo","biosfera","bipolar","birrento","biscoito","bisneto","bispo","bissexto","bitola","bizarro","blindado","bloco","bloquear","boato","bobagem","bocado","bocejo","bochecha","boicotar","bolada","boletim","bolha","bolo","bombeiro","bonde","boneco","bonita","borbulha","borda","boreal","borracha","bovino","boxeador","branco","brasa","braveza","breu","briga","brilho","brincar","broa","brochura","bronzear","broto","bruxo","bucha","budismo","bufar","bule","buraco","busca","busto","buzina","cabana","cabelo","cabide","cabo","cabrito","cacau","cacetada","cachorro","cacique","cadastro","cadeado","cafezal","caiaque","caipira","caixote","cajado","caju","calafrio","calcular","caldeira","calibrar","calmante","calota","camada","cambista","camisa","camomila","campanha","camuflar","canavial","cancelar","caneta","canguru","canhoto","canivete","canoa","cansado","cantar","canudo","capacho","capela","capinar","capotar","capricho","captador","capuz","caracol","carbono","cardeal","careca","carimbar","carneiro","carpete","carreira","cartaz","carvalho","casaco","casca","casebre","castelo","casulo","catarata","cativar","caule","causador","cautelar","cavalo","caverna","cebola","cedilha","cegonha","celebrar","celular","cenoura","censo","centeio","cercar","cerrado","certeiro","cerveja","cetim","cevada","chacota","chaleira","chamado","chapada","charme","chatice","chave","chefe","chegada","cheiro","cheque","chicote","chifre","chinelo","chocalho","chover","chumbo","chutar","chuva","cicatriz","ciclone","cidade","cidreira","ciente","cigana","cimento","cinto","cinza","ciranda","circuito","cirurgia","citar","clareza","clero","clicar","clone","clube","coado","coagir","cobaia","cobertor","cobrar","cocada","coelho","coentro","coeso","cogumelo","coibir","coifa","coiote","colar","coleira","colher","colidir","colmeia","colono","coluna","comando","combinar","comentar","comitiva","comover","complexo","comum","concha","condor","conectar","confuso","congelar","conhecer","conjugar","consumir","contrato","convite","cooperar","copeiro","copiador","copo","coquetel","coragem","cordial","corneta","coronha","corporal","correio","cortejo","coruja","corvo","cosseno","costela","cotonete","couro","couve","covil","cozinha","cratera","cravo","creche","credor","creme","crer","crespo","criada","criminal","crioulo","crise","criticar","crosta","crua","cruzeiro","cubano","cueca","cuidado","cujo","culatra","culminar","culpar","cultura","cumprir","cunhado","cupido","curativo","curral","cursar","curto","cuspir","custear","cutelo","damasco","datar","debater","debitar","deboche","debulhar","decalque","decimal","declive","decote","decretar","dedal","dedicado","deduzir","defesa","defumar","degelo","degrau","degustar","deitado","deixar","delator","delegado","delinear","delonga","demanda","demitir","demolido","dentista","depenado","depilar","depois","depressa","depurar","deriva","derramar","desafio","desbotar","descanso","desenho","desfiado","desgaste","desigual","deslize","desmamar","desova","despesa","destaque","desviar","detalhar","detentor","detonar","detrito","deusa","dever","devido","devotado","dezena","diagrama","dialeto","didata","difuso","digitar","dilatado","diluente","diminuir","dinastia","dinheiro","diocese","direto","discreta","disfarce","disparo","disquete","dissipar","distante","ditador","diurno","diverso","divisor","divulgar","dizer","dobrador","dolorido","domador","dominado","donativo","donzela","dormente","dorsal","dosagem","dourado","doutor","drenagem","drible","drogaria","duelar","duende","dueto","duplo","duquesa","durante","duvidoso","eclodir","ecoar","ecologia","edificar","edital","educado","efeito","efetivar","ejetar","elaborar","eleger","eleitor","elenco","elevador","eliminar","elogiar","embargo","embolado","embrulho","embutido","emenda","emergir","emissor","empatia","empenho","empinado","empolgar","emprego","empurrar","emulador","encaixe","encenado","enchente","encontro","endeusar","endossar","enfaixar","enfeite","enfim","engajado","engenho","englobar","engomado","engraxar","enguia","enjoar","enlatar","enquanto","enraizar","enrolado","enrugar","ensaio","enseada","ensino","ensopado","entanto","enteado","entidade","entortar","entrada","entulho","envergar","enviado","envolver","enxame","enxerto","enxofre","enxuto","epiderme","equipar","ereto","erguido","errata","erva","ervilha","esbanjar","esbelto","escama","escola","escrita","escuta","esfinge","esfolar","esfregar","esfumado","esgrima","esmalte","espanto","espelho","espiga","esponja","espreita","espumar","esquerda","estaca","esteira","esticar","estofado","estrela","estudo","esvaziar","etanol","etiqueta","euforia","europeu","evacuar","evaporar","evasivo","eventual","evidente","evoluir","exagero","exalar","examinar","exato","exausto","excesso","excitar","exclamar","executar","exemplo","exibir","exigente","exonerar","expandir","expelir","expirar","explanar","exposto","expresso","expulsar","externo","extinto","extrato","fabricar","fabuloso","faceta","facial","fada","fadiga","faixa","falar","falta","familiar","fandango","fanfarra","fantoche","fardado","farelo","farinha","farofa","farpa","fartura","fatia","fator","favorita","faxina","fazenda","fechado","feijoada","feirante","felino","feminino","fenda","feno","fera","feriado","ferrugem","ferver","festejar","fetal","feudal","fiapo","fibrose","ficar","ficheiro","figurado","fileira","filho","filme","filtrar","firmeza","fisgada","fissura","fita","fivela","fixador","fixo","flacidez","flamingo","flanela","flechada","flora","flutuar","fluxo","focal","focinho","fofocar","fogo","foguete","foice","folgado","folheto","forjar","formiga","forno","forte","fosco","fossa","fragata","fralda","frango","frasco","fraterno","freira","frente","fretar","frieza","friso","fritura","fronha","frustrar","fruteira","fugir","fulano","fuligem","fundar","fungo","funil","furador","furioso","futebol","gabarito","gabinete","gado","gaiato","gaiola","gaivota","galega","galho","galinha","galocha","ganhar","garagem","garfo","gargalo","garimpo","garoupa","garrafa","gasoduto","gasto","gata","gatilho","gaveta","gazela","gelado","geleia","gelo","gemada","gemer","gemido","generoso","gengiva","genial","genoma","genro","geologia","gerador","germinar","gesso","gestor","ginasta","gincana","gingado","girafa","girino","glacial","glicose","global","glorioso","goela","goiaba","golfe","golpear","gordura","gorjeta","gorro","gostoso","goteira","governar","gracejo","gradual","grafite","gralha","grampo","granada","gratuito","graveto","graxa","grego","grelhar","greve","grilo","grisalho","gritaria","grosso","grotesco","grudado","grunhido","gruta","guache","guarani","guaxinim","guerrear","guiar","guincho","guisado","gula","guloso","guru","habitar","harmonia","haste","haver","hectare","herdar","heresia","hesitar","hiato","hibernar","hidratar","hiena","hino","hipismo","hipnose","hipoteca","hoje","holofote","homem","honesto","honrado","hormonal","hospedar","humorado","iate","ideia","idoso","ignorado","igreja","iguana","ileso","ilha","iludido","iluminar","ilustrar","imagem","imediato","imenso","imersivo","iminente","imitador","imortal","impacto","impedir","implante","impor","imprensa","impune","imunizar","inalador","inapto","inativo","incenso","inchar","incidir","incluir","incolor","indeciso","indireto","indutor","ineficaz","inerente","infantil","infestar","infinito","inflamar","informal","infrator","ingerir","inibido","inicial","inimigo","injetar","inocente","inodoro","inovador","inox","inquieto","inscrito","inseto","insistir","inspetor","instalar","insulto","intacto","integral","intimar","intocado","intriga","invasor","inverno","invicto","invocar","iogurte","iraniano","ironizar","irreal","irritado","isca","isento","isolado","isqueiro","italiano","janeiro","jangada","janta","jararaca","jardim","jarro","jasmim","jato","javali","jazida","jejum","joaninha","joelhada","jogador","joia","jornal","jorrar","jovem","juba","judeu","judoca","juiz","julgador","julho","jurado","jurista","juro","justa","labareda","laboral","lacre","lactante","ladrilho","lagarta","lagoa","laje","lamber","lamentar","laminar","lampejo","lanche","lapidar","lapso","laranja","lareira","largura","lasanha","lastro","lateral","latido","lavanda","lavoura","lavrador","laxante","lazer","lealdade","lebre","legado","legendar","legista","leigo","leiloar","leitura","lembrete","leme","lenhador","lentilha","leoa","lesma","leste","letivo","letreiro","levar","leveza","levitar","liberal","libido","liderar","ligar","ligeiro","limitar","limoeiro","limpador","linda","linear","linhagem","liquidez","listagem","lisura","litoral","livro","lixa","lixeira","locador","locutor","lojista","lombo","lona","longe","lontra","lorde","lotado","loteria","loucura","lousa","louvar","luar","lucidez","lucro","luneta","lustre","lutador","luva","macaco","macete","machado","macio","madeira","madrinha","magnata","magreza","maior","mais","malandro","malha","malote","maluco","mamilo","mamoeiro","mamute","manada","mancha","mandato","manequim","manhoso","manivela","manobrar","mansa","manter","manusear","mapeado","maquinar","marcador","maresia","marfim","margem","marinho","marmita","maroto","marquise","marreco","martelo","marujo","mascote","masmorra","massagem","mastigar","matagal","materno","matinal","matutar","maxilar","medalha","medida","medusa","megafone","meiga","melancia","melhor","membro","memorial","menino","menos","mensagem","mental","merecer","mergulho","mesada","mesclar","mesmo","mesquita","mestre","metade","meteoro","metragem","mexer","mexicano","micro","migalha","migrar","milagre","milenar","milhar","mimado","minerar","minhoca","ministro","minoria","miolo","mirante","mirtilo","misturar","mocidade","moderno","modular","moeda","moer","moinho","moita","moldura","moleza","molho","molinete","molusco","montanha","moqueca","morango","morcego","mordomo","morena","mosaico","mosquete","mostarda","motel","motim","moto","motriz","muda","muito","mulata","mulher","multar","mundial","munido","muralha","murcho","muscular","museu","musical","nacional","nadador","naja","namoro","narina","narrado","nascer","nativa","natureza","navalha","navegar","navio","neblina","nebuloso","negativa","negociar","negrito","nervoso","neta","neural","nevasca","nevoeiro","ninar","ninho","nitidez","nivelar","nobreza","noite","noiva","nomear","nominal","nordeste","nortear","notar","noticiar","noturno","novelo","novilho","novo","nublado","nudez","numeral","nupcial","nutrir","nuvem","obcecado","obedecer","objetivo","obrigado","obscuro","obstetra","obter","obturar","ocidente","ocioso","ocorrer","oculista","ocupado","ofegante","ofensiva","oferenda","oficina","ofuscado","ogiva","olaria","oleoso","olhar","oliveira","ombro","omelete","omisso","omitir","ondulado","oneroso","ontem","opcional","operador","oponente","oportuno","oposto","orar","orbitar","ordem","ordinal","orfanato","orgasmo","orgulho","oriental","origem","oriundo","orla","ortodoxo","orvalho","oscilar","ossada","osso","ostentar","otimismo","ousadia","outono","outubro","ouvido","ovelha","ovular","oxidar","oxigenar","pacato","paciente","pacote","pactuar","padaria","padrinho","pagar","pagode","painel","pairar","paisagem","palavra","palestra","palheta","palito","palmada","palpitar","pancada","panela","panfleto","panqueca","pantanal","papagaio","papelada","papiro","parafina","parcial","pardal","parede","partida","pasmo","passado","pastel","patamar","patente","patinar","patrono","paulada","pausar","peculiar","pedalar","pedestre","pediatra","pedra","pegada","peitoral","peixe","pele","pelicano","penca","pendurar","peneira","penhasco","pensador","pente","perceber","perfeito","pergunta","perito","permitir","perna","perplexo","persiana","pertence","peruca","pescado","pesquisa","pessoa","petiscar","piada","picado","piedade","pigmento","pilastra","pilhado","pilotar","pimenta","pincel","pinguim","pinha","pinote","pintar","pioneiro","pipoca","piquete","piranha","pires","pirueta","piscar","pistola","pitanga","pivete","planta","plaqueta","platina","plebeu","plumagem","pluvial","pneu","poda","poeira","poetisa","polegada","policiar","poluente","polvilho","pomar","pomba","ponderar","pontaria","populoso","porta","possuir","postal","pote","poupar","pouso","povoar","praia","prancha","prato","praxe","prece","predador","prefeito","premiar","prensar","preparar","presilha","pretexto","prevenir","prezar","primata","princesa","prisma","privado","processo","produto","profeta","proibido","projeto","prometer","propagar","prosa","protetor","provador","publicar","pudim","pular","pulmonar","pulseira","punhal","punir","pupilo","pureza","puxador","quadra","quantia","quarto","quase","quebrar","queda","queijo","quente","querido","quimono","quina","quiosque","rabanada","rabisco","rachar","racionar","radial","raiar","rainha","raio","raiva","rajada","ralado","ramal","ranger","ranhura","rapadura","rapel","rapidez","raposa","raquete","raridade","rasante","rascunho","rasgar","raspador","rasteira","rasurar","ratazana","ratoeira","realeza","reanimar","reaver","rebaixar","rebelde","rebolar","recado","recente","recheio","recibo","recordar","recrutar","recuar","rede","redimir","redonda","reduzida","reenvio","refinar","refletir","refogar","refresco","refugiar","regalia","regime","regra","reinado","reitor","rejeitar","relativo","remador","remendo","remorso","renovado","reparo","repelir","repleto","repolho","represa","repudiar","requerer","resenha","resfriar","resgatar","residir","resolver","respeito","ressaca","restante","resumir","retalho","reter","retirar","retomada","retratar","revelar","revisor","revolta","riacho","rica","rigidez","rigoroso","rimar","ringue","risada","risco","risonho","robalo","rochedo","rodada","rodeio","rodovia","roedor","roleta","romano","roncar","rosado","roseira","rosto","rota","roteiro","rotina","rotular","rouco","roupa","roxo","rubro","rugido","rugoso","ruivo","rumo","rupestre","russo","sabor","saciar","sacola","sacudir","sadio","safira","saga","sagrada","saibro","salada","saleiro","salgado","saliva","salpicar","salsicha","saltar","salvador","sambar","samurai","sanar","sanfona","sangue","sanidade","sapato","sarda","sargento","sarjeta","saturar","saudade","saxofone","sazonal","secar","secular","seda","sedento","sediado","sedoso","sedutor","segmento","segredo","segundo","seiva","seleto","selvagem","semanal","semente","senador","senhor","sensual","sentado","separado","sereia","seringa","serra","servo","setembro","setor","sigilo","silhueta","silicone","simetria","simpatia","simular","sinal","sincero","singular","sinopse","sintonia","sirene","siri","situado","soberano","sobra","socorro","sogro","soja","solda","soletrar","solteiro","sombrio","sonata","sondar","sonegar","sonhador","sono","soprano","soquete","sorrir","sorteio","sossego","sotaque","soterrar","sovado","sozinho","suavizar","subida","submerso","subsolo","subtrair","sucata","sucesso","suco","sudeste","sufixo","sugador","sugerir","sujeito","sulfato","sumir","suor","superior","suplicar","suposto","suprimir","surdina","surfista","surpresa","surreal","surtir","suspiro","sustento","tabela","tablete","tabuada","tacho","tagarela","talher","talo","talvez","tamanho","tamborim","tampa","tangente","tanto","tapar","tapioca","tardio","tarefa","tarja","tarraxa","tatuagem","taurino","taxativo","taxista","teatral","tecer","tecido","teclado","tedioso","teia","teimar","telefone","telhado","tempero","tenente","tensor","tentar","termal","terno","terreno","tese","tesoura","testado","teto","textura","texugo","tiara","tigela","tijolo","timbrar","timidez","tingido","tinteiro","tiragem","titular","toalha","tocha","tolerar","tolice","tomada","tomilho","tonel","tontura","topete","tora","torcido","torneio","torque","torrada","torto","tostar","touca","toupeira","toxina","trabalho","tracejar","tradutor","trafegar","trajeto","trama","trancar","trapo","traseiro","tratador","travar","treino","tremer","trepidar","trevo","triagem","tribo","triciclo","tridente","trilogia","trindade","triplo","triturar","triunfal","trocar","trombeta","trova","trunfo","truque","tubular","tucano","tudo","tulipa","tupi","turbo","turma","turquesa","tutelar","tutorial","uivar","umbigo","unha","unidade","uniforme","urologia","urso","urtiga","urubu","usado","usina","usufruir","vacina","vadiar","vagaroso","vaidoso","vala","valente","validade","valores","vantagem","vaqueiro","varanda","vareta","varrer","vascular","vasilha","vassoura","vazar","vazio","veado","vedar","vegetar","veicular","veleiro","velhice","veludo","vencedor","vendaval","venerar","ventre","verbal","verdade","vereador","vergonha","vermelho","verniz","versar","vertente","vespa","vestido","vetorial","viaduto","viagem","viajar","viatura","vibrador","videira","vidraria","viela","viga","vigente","vigiar","vigorar","vilarejo","vinco","vinheta","vinil","violeta","virada","virtude","visitar","visto","vitral","viveiro","vizinho","voador","voar","vogal","volante","voleibol","voltagem","volumoso","vontade","vulto","vuvuzela","xadrez","xarope","xeque","xeretar","xerife","xingar","zangado","zarpar","zebu","zelador","zombar","zoologia","zumbido"]');
const require$$9 = /* @__PURE__ */ JSON.parse('["abandon","ability","able","about","above","absent","absorb","abstract","absurd","abuse","access","accident","account","accuse","achieve","acid","acoustic","acquire","across","act","action","actor","actress","actual","adapt","add","addict","address","adjust","admit","adult","advance","advice","aerobic","affair","afford","afraid","again","age","agent","agree","ahead","aim","air","airport","aisle","alarm","album","alcohol","alert","alien","all","alley","allow","almost","alone","alpha","already","also","alter","always","amateur","amazing","among","amount","amused","analyst","anchor","ancient","anger","angle","angry","animal","ankle","announce","annual","another","answer","antenna","antique","anxiety","any","apart","apology","appear","apple","approve","april","arch","arctic","area","arena","argue","arm","armed","armor","army","around","arrange","arrest","arrive","arrow","art","artefact","artist","artwork","ask","aspect","assault","asset","assist","assume","asthma","athlete","atom","attack","attend","attitude","attract","auction","audit","august","aunt","author","auto","autumn","average","avocado","avoid","awake","aware","away","awesome","awful","awkward","axis","baby","bachelor","bacon","badge","bag","balance","balcony","ball","bamboo","banana","banner","bar","barely","bargain","barrel","base","basic","basket","battle","beach","bean","beauty","because","become","beef","before","begin","behave","behind","believe","below","belt","bench","benefit","best","betray","better","between","beyond","bicycle","bid","bike","bind","biology","bird","birth","bitter","black","blade","blame","blanket","blast","bleak","bless","blind","blood","blossom","blouse","blue","blur","blush","board","boat","body","boil","bomb","bone","bonus","book","boost","border","boring","borrow","boss","bottom","bounce","box","boy","bracket","brain","brand","brass","brave","bread","breeze","brick","bridge","brief","bright","bring","brisk","broccoli","broken","bronze","broom","brother","brown","brush","bubble","buddy","budget","buffalo","build","bulb","bulk","bullet","bundle","bunker","burden","burger","burst","bus","business","busy","butter","buyer","buzz","cabbage","cabin","cable","cactus","cage","cake","call","calm","camera","camp","can","canal","cancel","candy","cannon","canoe","canvas","canyon","capable","capital","captain","car","carbon","card","cargo","carpet","carry","cart","case","cash","casino","castle","casual","cat","catalog","catch","category","cattle","caught","cause","caution","cave","ceiling","celery","cement","census","century","cereal","certain","chair","chalk","champion","change","chaos","chapter","charge","chase","chat","cheap","check","cheese","chef","cherry","chest","chicken","chief","child","chimney","choice","choose","chronic","chuckle","chunk","churn","cigar","cinnamon","circle","citizen","city","civil","claim","clap","clarify","claw","clay","clean","clerk","clever","click","client","cliff","climb","clinic","clip","clock","clog","close","cloth","cloud","clown","club","clump","cluster","clutch","coach","coast","coconut","code","coffee","coil","coin","collect","color","column","combine","come","comfort","comic","common","company","concert","conduct","confirm","congress","connect","consider","control","convince","cook","cool","copper","copy","coral","core","corn","correct","cost","cotton","couch","country","couple","course","cousin","cover","coyote","crack","cradle","craft","cram","crane","crash","crater","crawl","crazy","cream","credit","creek","crew","cricket","crime","crisp","critic","crop","cross","crouch","crowd","crucial","cruel","cruise","crumble","crunch","crush","cry","crystal","cube","culture","cup","cupboard","curious","current","curtain","curve","cushion","custom","cute","cycle","dad","damage","damp","dance","danger","daring","dash","daughter","dawn","day","deal","debate","debris","decade","december","decide","decline","decorate","decrease","deer","defense","define","defy","degree","delay","deliver","demand","demise","denial","dentist","deny","depart","depend","deposit","depth","deputy","derive","describe","desert","design","desk","despair","destroy","detail","detect","develop","device","devote","diagram","dial","diamond","diary","dice","diesel","diet","differ","digital","dignity","dilemma","dinner","dinosaur","direct","dirt","disagree","discover","disease","dish","dismiss","disorder","display","distance","divert","divide","divorce","dizzy","doctor","document","dog","doll","dolphin","domain","donate","donkey","donor","door","dose","double","dove","draft","dragon","drama","drastic","draw","dream","dress","drift","drill","drink","drip","drive","drop","drum","dry","duck","dumb","dune","during","dust","dutch","duty","dwarf","dynamic","eager","eagle","early","earn","earth","easily","east","easy","echo","ecology","economy","edge","edit","educate","effort","egg","eight","either","elbow","elder","electric","elegant","element","elephant","elevator","elite","else","embark","embody","embrace","emerge","emotion","employ","empower","empty","enable","enact","end","endless","endorse","enemy","energy","enforce","engage","engine","enhance","enjoy","enlist","enough","enrich","enroll","ensure","enter","entire","entry","envelope","episode","equal","equip","era","erase","erode","erosion","error","erupt","escape","essay","essence","estate","eternal","ethics","evidence","evil","evoke","evolve","exact","example","excess","exchange","excite","exclude","excuse","execute","exercise","exhaust","exhibit","exile","exist","exit","exotic","expand","expect","expire","explain","expose","express","extend","extra","eye","eyebrow","fabric","face","faculty","fade","faint","faith","fall","false","fame","family","famous","fan","fancy","fantasy","farm","fashion","fat","fatal","father","fatigue","fault","favorite","feature","february","federal","fee","feed","feel","female","fence","festival","fetch","fever","few","fiber","fiction","field","figure","file","film","filter","final","find","fine","finger","finish","fire","firm","first","fiscal","fish","fit","fitness","fix","flag","flame","flash","flat","flavor","flee","flight","flip","float","flock","floor","flower","fluid","flush","fly","foam","focus","fog","foil","fold","follow","food","foot","force","forest","forget","fork","fortune","forum","forward","fossil","foster","found","fox","fragile","frame","frequent","fresh","friend","fringe","frog","front","frost","frown","frozen","fruit","fuel","fun","funny","furnace","fury","future","gadget","gain","galaxy","gallery","game","gap","garage","garbage","garden","garlic","garment","gas","gasp","gate","gather","gauge","gaze","general","genius","genre","gentle","genuine","gesture","ghost","giant","gift","giggle","ginger","giraffe","girl","give","glad","glance","glare","glass","glide","glimpse","globe","gloom","glory","glove","glow","glue","goat","goddess","gold","good","goose","gorilla","gospel","gossip","govern","gown","grab","grace","grain","grant","grape","grass","gravity","great","green","grid","grief","grit","grocery","group","grow","grunt","guard","guess","guide","guilt","guitar","gun","gym","habit","hair","half","hammer","hamster","hand","happy","harbor","hard","harsh","harvest","hat","have","hawk","hazard","head","health","heart","heavy","hedgehog","height","hello","helmet","help","hen","hero","hidden","high","hill","hint","hip","hire","history","hobby","hockey","hold","hole","holiday","hollow","home","honey","hood","hope","horn","horror","horse","hospital","host","hotel","hour","hover","hub","huge","human","humble","humor","hundred","hungry","hunt","hurdle","hurry","hurt","husband","hybrid","ice","icon","idea","identify","idle","ignore","ill","illegal","illness","image","imitate","immense","immune","impact","impose","improve","impulse","inch","include","income","increase","index","indicate","indoor","industry","infant","inflict","inform","inhale","inherit","initial","inject","injury","inmate","inner","innocent","input","inquiry","insane","insect","inside","inspire","install","intact","interest","into","invest","invite","involve","iron","island","isolate","issue","item","ivory","jacket","jaguar","jar","jazz","jealous","jeans","jelly","jewel","job","join","joke","journey","joy","judge","juice","jump","jungle","junior","junk","just","kangaroo","keen","keep","ketchup","key","kick","kid","kidney","kind","kingdom","kiss","kit","kitchen","kite","kitten","kiwi","knee","knife","knock","know","lab","label","labor","ladder","lady","lake","lamp","language","laptop","large","later","latin","laugh","laundry","lava","law","lawn","lawsuit","layer","lazy","leader","leaf","learn","leave","lecture","left","leg","legal","legend","leisure","lemon","lend","length","lens","leopard","lesson","letter","level","liar","liberty","library","license","life","lift","light","like","limb","limit","link","lion","liquid","list","little","live","lizard","load","loan","lobster","local","lock","logic","lonely","long","loop","lottery","loud","lounge","love","loyal","lucky","luggage","lumber","lunar","lunch","luxury","lyrics","machine","mad","magic","magnet","maid","mail","main","major","make","mammal","man","manage","mandate","mango","mansion","manual","maple","marble","march","margin","marine","market","marriage","mask","mass","master","match","material","math","matrix","matter","maximum","maze","meadow","mean","measure","meat","mechanic","medal","media","melody","melt","member","memory","mention","menu","mercy","merge","merit","merry","mesh","message","metal","method","middle","midnight","milk","million","mimic","mind","minimum","minor","minute","miracle","mirror","misery","miss","mistake","mix","mixed","mixture","mobile","model","modify","mom","moment","monitor","monkey","monster","month","moon","moral","more","morning","mosquito","mother","motion","motor","mountain","mouse","move","movie","much","muffin","mule","multiply","muscle","museum","mushroom","music","must","mutual","myself","mystery","myth","naive","name","napkin","narrow","nasty","nation","nature","near","neck","need","negative","neglect","neither","nephew","nerve","nest","net","network","neutral","never","news","next","nice","night","noble","noise","nominee","noodle","normal","north","nose","notable","note","nothing","notice","novel","now","nuclear","number","nurse","nut","oak","obey","object","oblige","obscure","observe","obtain","obvious","occur","ocean","october","odor","off","offer","office","often","oil","okay","old","olive","olympic","omit","once","one","onion","online","only","open","opera","opinion","oppose","option","orange","orbit","orchard","order","ordinary","organ","orient","original","orphan","ostrich","other","outdoor","outer","output","outside","oval","oven","over","own","owner","oxygen","oyster","ozone","pact","paddle","page","pair","palace","palm","panda","panel","panic","panther","paper","parade","parent","park","parrot","party","pass","patch","path","patient","patrol","pattern","pause","pave","payment","peace","peanut","pear","peasant","pelican","pen","penalty","pencil","people","pepper","perfect","permit","person","pet","phone","photo","phrase","physical","piano","picnic","picture","piece","pig","pigeon","pill","pilot","pink","pioneer","pipe","pistol","pitch","pizza","place","planet","plastic","plate","play","please","pledge","pluck","plug","plunge","poem","poet","point","polar","pole","police","pond","pony","pool","popular","portion","position","possible","post","potato","pottery","poverty","powder","power","practice","praise","predict","prefer","prepare","present","pretty","prevent","price","pride","primary","print","priority","prison","private","prize","problem","process","produce","profit","program","project","promote","proof","property","prosper","protect","proud","provide","public","pudding","pull","pulp","pulse","pumpkin","punch","pupil","puppy","purchase","purity","purpose","purse","push","put","puzzle","pyramid","quality","quantum","quarter","question","quick","quit","quiz","quote","rabbit","raccoon","race","rack","radar","radio","rail","rain","raise","rally","ramp","ranch","random","range","rapid","rare","rate","rather","raven","raw","razor","ready","real","reason","rebel","rebuild","recall","receive","recipe","record","recycle","reduce","reflect","reform","refuse","region","regret","regular","reject","relax","release","relief","rely","remain","remember","remind","remove","render","renew","rent","reopen","repair","repeat","replace","report","require","rescue","resemble","resist","resource","response","result","retire","retreat","return","reunion","reveal","review","reward","rhythm","rib","ribbon","rice","rich","ride","ridge","rifle","right","rigid","ring","riot","ripple","risk","ritual","rival","river","road","roast","robot","robust","rocket","romance","roof","rookie","room","rose","rotate","rough","round","route","royal","rubber","rude","rug","rule","run","runway","rural","sad","saddle","sadness","safe","sail","salad","salmon","salon","salt","salute","same","sample","sand","satisfy","satoshi","sauce","sausage","save","say","scale","scan","scare","scatter","scene","scheme","school","science","scissors","scorpion","scout","scrap","screen","script","scrub","sea","search","season","seat","second","secret","section","security","seed","seek","segment","select","sell","seminar","senior","sense","sentence","series","service","session","settle","setup","seven","shadow","shaft","shallow","share","shed","shell","sheriff","shield","shift","shine","ship","shiver","shock","shoe","shoot","shop","short","shoulder","shove","shrimp","shrug","shuffle","shy","sibling","sick","side","siege","sight","sign","silent","silk","silly","silver","similar","simple","since","sing","siren","sister","situate","six","size","skate","sketch","ski","skill","skin","skirt","skull","slab","slam","sleep","slender","slice","slide","slight","slim","slogan","slot","slow","slush","small","smart","smile","smoke","smooth","snack","snake","snap","sniff","snow","soap","soccer","social","sock","soda","soft","solar","soldier","solid","solution","solve","someone","song","soon","sorry","sort","soul","sound","soup","source","south","space","spare","spatial","spawn","speak","special","speed","spell","spend","sphere","spice","spider","spike","spin","spirit","split","spoil","sponsor","spoon","sport","spot","spray","spread","spring","spy","square","squeeze","squirrel","stable","stadium","staff","stage","stairs","stamp","stand","start","state","stay","steak","steel","stem","step","stereo","stick","still","sting","stock","stomach","stone","stool","story","stove","strategy","street","strike","strong","struggle","student","stuff","stumble","style","subject","submit","subway","success","such","sudden","suffer","sugar","suggest","suit","summer","sun","sunny","sunset","super","supply","supreme","sure","surface","surge","surprise","surround","survey","suspect","sustain","swallow","swamp","swap","swarm","swear","sweet","swift","swim","swing","switch","sword","symbol","symptom","syrup","system","table","tackle","tag","tail","talent","talk","tank","tape","target","task","taste","tattoo","taxi","teach","team","tell","ten","tenant","tennis","tent","term","test","text","thank","that","theme","then","theory","there","they","thing","this","thought","three","thrive","throw","thumb","thunder","ticket","tide","tiger","tilt","timber","time","tiny","tip","tired","tissue","title","toast","tobacco","today","toddler","toe","together","toilet","token","tomato","tomorrow","tone","tongue","tonight","tool","tooth","top","topic","topple","torch","tornado","tortoise","toss","total","tourist","toward","tower","town","toy","track","trade","traffic","tragic","train","transfer","trap","trash","travel","tray","treat","tree","trend","trial","tribe","trick","trigger","trim","trip","trophy","trouble","truck","true","truly","trumpet","trust","truth","try","tube","tuition","tumble","tuna","tunnel","turkey","turn","turtle","twelve","twenty","twice","twin","twist","two","type","typical","ugly","umbrella","unable","unaware","uncle","uncover","under","undo","unfair","unfold","unhappy","uniform","unique","unit","universe","unknown","unlock","until","unusual","unveil","update","upgrade","uphold","upon","upper","upset","urban","urge","usage","use","used","useful","useless","usual","utility","vacant","vacuum","vague","valid","valley","valve","van","vanish","vapor","various","vast","vault","vehicle","velvet","vendor","venture","venue","verb","verify","version","very","vessel","veteran","viable","vibrant","vicious","victory","video","view","village","vintage","violin","virtual","virus","visa","visit","visual","vital","vivid","vocal","voice","void","volcano","volume","vote","voyage","wage","wagon","wait","walk","wall","walnut","want","warfare","warm","warrior","wash","wasp","waste","water","wave","way","wealth","weapon","wear","weasel","weather","web","wedding","weekend","weird","welcome","west","wet","whale","what","wheat","wheel","when","where","whip","whisper","wide","width","wife","wild","will","win","window","wine","wing","wink","winner","winter","wire","wisdom","wise","wish","witness","wolf","woman","wonder","wood","wool","word","work","world","worry","worth","wrap","wreck","wrestle","wrist","write","wrong","yard","year","yellow","you","young","youth","zebra","zero","zone","zoo"]');
var hasRequired_wordlists;
function require_wordlists() {
  if (hasRequired_wordlists) return _wordlists;
  hasRequired_wordlists = 1;
  Object.defineProperty(_wordlists, "__esModule", { value: true });
  const wordlists = {};
  _wordlists.wordlists = wordlists;
  let _default;
  _wordlists._default = _default;
  try {
    _wordlists._default = _default = require$$0;
    wordlists.czech = _default;
  } catch (err) {
  }
  try {
    _wordlists._default = _default = require$$1;
    wordlists.chinese_simplified = _default;
  } catch (err) {
  }
  try {
    _wordlists._default = _default = require$$2;
    wordlists.chinese_traditional = _default;
  } catch (err) {
  }
  try {
    _wordlists._default = _default = require$$3;
    wordlists.korean = _default;
  } catch (err) {
  }
  try {
    _wordlists._default = _default = require$$4;
    wordlists.french = _default;
  } catch (err) {
  }
  try {
    _wordlists._default = _default = require$$5;
    wordlists.italian = _default;
  } catch (err) {
  }
  try {
    _wordlists._default = _default = require$$6;
    wordlists.spanish = _default;
  } catch (err) {
  }
  try {
    _wordlists._default = _default = require$$7;
    wordlists.japanese = _default;
    wordlists.JA = _default;
  } catch (err) {
  }
  try {
    _wordlists._default = _default = require$$8;
    wordlists.portuguese = _default;
  } catch (err) {
  }
  try {
    _wordlists._default = _default = require$$9;
    wordlists.english = _default;
    wordlists.EN = _default;
  } catch (err) {
  }
  return _wordlists;
}
var hasRequiredSrc;
function requireSrc() {
  if (hasRequiredSrc) return src;
  hasRequiredSrc = 1;
  Object.defineProperty(src, "__esModule", { value: true });
  const sha256_1 = /* @__PURE__ */ requireSha256();
  const sha512_1 = /* @__PURE__ */ requireSha512();
  const pbkdf2_1 = /* @__PURE__ */ requirePbkdf2();
  const utils_1 = /* @__PURE__ */ requireUtils();
  const _wordlists_1 = require_wordlists();
  let DEFAULT_WORDLIST = _wordlists_1._default;
  const INVALID_MNEMONIC = "Invalid mnemonic";
  const INVALID_ENTROPY = "Invalid entropy";
  const INVALID_CHECKSUM = "Invalid mnemonic checksum";
  const WORDLIST_REQUIRED = "A wordlist is required but a default could not be found.\nPlease pass a 2048 word array explicitly.";
  function normalize(str) {
    return (str || "").normalize("NFKD");
  }
  function lpad(str, padString, length) {
    while (str.length < length) {
      str = padString + str;
    }
    return str;
  }
  function binaryToByte(bin) {
    return parseInt(bin, 2);
  }
  function bytesToBinary(bytes) {
    return bytes.map((x) => lpad(x.toString(2), "0", 8)).join("");
  }
  function deriveChecksumBits(entropyBuffer) {
    const ENT = entropyBuffer.length * 8;
    const CS = ENT / 32;
    const hash = sha256_1.sha256(Uint8Array.from(entropyBuffer));
    return bytesToBinary(Array.from(hash)).slice(0, CS);
  }
  function salt(password) {
    return "mnemonic" + (password || "");
  }
  function mnemonicToSeedSync(mnemonic2, password) {
    const mnemonicBuffer = Uint8Array.from(Buffer.from(normalize(mnemonic2), "utf8"));
    const saltBuffer = Uint8Array.from(Buffer.from(salt(normalize(password)), "utf8"));
    const res = pbkdf2_1.pbkdf2(sha512_1.sha512, mnemonicBuffer, saltBuffer, {
      c: 2048,
      dkLen: 64
    });
    return Buffer.from(res);
  }
  src.mnemonicToSeedSync = mnemonicToSeedSync;
  function mnemonicToSeed(mnemonic2, password) {
    const mnemonicBuffer = Uint8Array.from(Buffer.from(normalize(mnemonic2), "utf8"));
    const saltBuffer = Uint8Array.from(Buffer.from(salt(normalize(password)), "utf8"));
    return pbkdf2_1.pbkdf2Async(sha512_1.sha512, mnemonicBuffer, saltBuffer, {
      c: 2048,
      dkLen: 64
    }).then((res) => Buffer.from(res));
  }
  src.mnemonicToSeed = mnemonicToSeed;
  function mnemonicToEntropy(mnemonic2, wordlist2) {
    wordlist2 = wordlist2 || DEFAULT_WORDLIST;
    if (!wordlist2) {
      throw new Error(WORDLIST_REQUIRED);
    }
    const words = normalize(mnemonic2).split(" ");
    if (words.length % 3 !== 0) {
      throw new Error(INVALID_MNEMONIC);
    }
    const bits = words.map((word) => {
      const index = wordlist2.indexOf(word);
      if (index === -1) {
        throw new Error(INVALID_MNEMONIC);
      }
      return lpad(index.toString(2), "0", 11);
    }).join("");
    const dividerIndex = Math.floor(bits.length / 33) * 32;
    const entropyBits = bits.slice(0, dividerIndex);
    const checksumBits = bits.slice(dividerIndex);
    const entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);
    if (entropyBytes.length < 16) {
      throw new Error(INVALID_ENTROPY);
    }
    if (entropyBytes.length > 32) {
      throw new Error(INVALID_ENTROPY);
    }
    if (entropyBytes.length % 4 !== 0) {
      throw new Error(INVALID_ENTROPY);
    }
    const entropy = Buffer.from(entropyBytes);
    const newChecksum = deriveChecksumBits(entropy);
    if (newChecksum !== checksumBits) {
      throw new Error(INVALID_CHECKSUM);
    }
    return entropy.toString("hex");
  }
  src.mnemonicToEntropy = mnemonicToEntropy;
  function entropyToMnemonic(entropy, wordlist2) {
    if (!Buffer.isBuffer(entropy)) {
      entropy = Buffer.from(entropy, "hex");
    }
    wordlist2 = wordlist2 || DEFAULT_WORDLIST;
    if (!wordlist2) {
      throw new Error(WORDLIST_REQUIRED);
    }
    if (entropy.length < 16) {
      throw new TypeError(INVALID_ENTROPY);
    }
    if (entropy.length > 32) {
      throw new TypeError(INVALID_ENTROPY);
    }
    if (entropy.length % 4 !== 0) {
      throw new TypeError(INVALID_ENTROPY);
    }
    const entropyBits = bytesToBinary(Array.from(entropy));
    const checksumBits = deriveChecksumBits(entropy);
    const bits = entropyBits + checksumBits;
    const chunks = bits.match(/(.{1,11})/g);
    const words = chunks.map((binary2) => {
      const index = binaryToByte(binary2);
      return wordlist2[index];
    });
    return wordlist2[0] === "" ? words.join("") : words.join(" ");
  }
  src.entropyToMnemonic = entropyToMnemonic;
  function generateMnemonic(strength, rng, wordlist2) {
    strength = strength || 128;
    if (strength % 32 !== 0) {
      throw new TypeError(INVALID_ENTROPY);
    }
    rng = rng || ((size) => Buffer.from(utils_1.randomBytes(size)));
    return entropyToMnemonic(rng(strength / 8), wordlist2);
  }
  src.generateMnemonic = generateMnemonic;
  function validateMnemonic(mnemonic2, wordlist2) {
    try {
      mnemonicToEntropy(mnemonic2, wordlist2);
    } catch (e) {
      return false;
    }
    return true;
  }
  src.validateMnemonic = validateMnemonic;
  function setDefaultWordlist(language) {
    const result = _wordlists_1.wordlists[language];
    if (result) {
      DEFAULT_WORDLIST = result;
    } else {
      throw new Error('Could not find wordlist for language "' + language + '"');
    }
  }
  src.setDefaultWordlist = setDefaultWordlist;
  function getDefaultWordlist() {
    if (!DEFAULT_WORDLIST) {
      throw new Error("No Default Wordlist set");
    }
    return Object.keys(_wordlists_1.wordlists).filter((lang) => {
      if (lang === "JA" || lang === "EN") {
        return false;
      }
      return _wordlists_1.wordlists[lang].every((word, index) => word === DEFAULT_WORDLIST[index]);
    })[0];
  }
  src.getDefaultWordlist = getDefaultWordlist;
  var _wordlists_2 = require_wordlists();
  src.wordlists = _wordlists_2.wordlists;
  return src;
}
requireSrc();
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __async = (__this, __arguments, generator2) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator2.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator2.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator2 = generator2.apply(__this, __arguments)).next());
  });
};
window.injectWalletKit = (options) => {
  try {
    injectBridgeCode(window, options, new SwiftTransport(window));
  } catch (_error) {
  }
};
window.id = crypto.randomUUID();
class SwiftTransport {
  constructor(window2) {
    this.eventCallback = null;
    this.messageListener = null;
    this.window = window2;
    this.setupMessageListener();
  }
  setupMessageListener() {
    this.messageListener = (event) => {
      if (event.source !== this.window) return;
      const data = event.data;
      if (!data || typeof data !== "object") return;
      if (data.type === TONCONNECT_BRIDGE_EVENT) {
        this.handleEvent(data.event);
        return;
      }
    };
    this.window.addEventListener("message", this.messageListener);
  }
  handleEvent(event) {
    if (this.eventCallback) {
      try {
        this.eventCallback(event);
      } catch (error2) {
        console.error("TonConnect event callback error:", error2);
      }
    }
  }
  send(request) {
    return __async(this, null, function* () {
      let timeout = request.method === "restoreConnection" ? RESTORE_CONNECTION_TIMEOUT : DEFAULT_REQUEST_TIMEOUT;
      let response = yield window.webkit.messageHandlers.walletKitInjectionBridge.postMessage(__spreadProps(__spreadValues({}, request), {
        frameID: window.id,
        timeout
      }));
      if (!response || typeof response !== "object") {
        return Promise.reject(new Error("Invalid response"));
      }
      if (response.success) {
        return Promise.resolve(response.payload);
      } else {
        return Promise.reject(response.error);
      }
    });
  }
  onEvent(callback) {
    this.eventCallback = callback;
  }
  isAvailable() {
    return true;
  }
  requestContentScriptInjection() {
  }
  destroy() {
  }
}
//# sourceMappingURL=inject.mjs.map
